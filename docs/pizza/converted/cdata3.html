<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>cdata3 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cdata3</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-


__all__ = [&#39;Box&#39;, &#39;Capped&#39;, &#39;Cylinder&#39;, &#39;Group&#39;, &#39;Line&#39;, &#39;Random&#39;, &#39;Shell&#39;, &#39;Sphere&#39;, &#39;Surface&#39;, &#39;Union&#39;, &#39;box_triangulate&#39;, &#39;cdata&#39;, &#39;connect&#39;, &#39;cross&#39;, &#39;normal&#39;, &#39;normalize&#39;, &#39;vertex&#39;]
# cdata3.py

&#34;&#34;&#34;
cdata3.py

Module converted from Python 2.x to Python 3.x.

cdata tool

Read, create, manipulate ChemCell data files

## How to specify and print 2d particles

c = cdata()                        create a datafile object
c = cdata(&#34;mem.surf&#34;)              read in one or more ChemCell data files
c = cdata(&#34;mem.part.gz mem.surf&#34;)  can be gzipped
c = cdata(&#34;mem.*&#34;)                 wildcard expands to multiple files
c.read(&#34;mem.surf&#34;)                 read in one or more data files

  read() has same argument options as constructor
  files contain the following kinds of entries, each of which becomes an object
    particles, triangles, region, facets
    particles is a list of particles -&gt; becomes a group
    triangles is 3 lists of vertices, triangles, connections -&gt; becomes a surf
    region is a ChemCell command defining a region -&gt; becomes a region
    facets is a CUBIT format of vertices and triangles -&gt; becomes a surf
  each object is assigned an ID = name in file
  ID can be any number or string, must be unique

c.box(ID,xlo,ylo,zlo,xhi,yhi,zhi)  create a box region
c.sphere(ID,x,y,z,r)               create a sphere region
c.shell(ID,x,y,z,r,rinner)         create a shell region
c.cyl(ID,&#39;x&#39;,c1,c2,r,lo,hi)        create a axis-aligned cylinder region
c.cap(ID,&#39;x&#39;,c1,c2,r,lo,hi)        create a axis-aligned capped-cylinder region
c.q(ID,q1,q2,...)                  set region triangulation quality factors

  box() can create an axis-aligned plane, line, or point if lo=hi
  cyl() can create an axis-aligned circle if lo=hi
  for cyl() and cap(): &#39;x&#39; c1,c2 = y,z; &#39;y&#39; c1,c2 = x,z; &#39;z&#39; c,c2 = x,y
  q&#39;s are size factors for region triangulation
    for box, q1,q2,q3 = # of divisions per xyz of box
    for sphere or shell, q1 = # of divisions per face edge of embedded cube
    for cyl or cap, q1 = # of divisions per face edge of end cap, must be even
                    q2 = # of divisions along length of cylinder

c.line(ID,x1,y1,z1,x2,y2,z2)       create a line object with one line
c.lbox(ID,xlo,ylo,zlo,xhi,yhi,zhi) create a line object with 12 box lines

c.surf(ID,id-region)               create a triangulated surf from a region
c.surftri(ID,id-surf,t1,t2,...)    create a tri surf from list of id-surf tris
c.surfselect(ID,id-surf,test)      create a tri surf from test on id-surf tris
c.bins(ID,nx,ny)                   set binning parameters for a surf

  triangulation of a shell is just done for the outer sphere
  for surftri(), one or more tri indices (1-N) must be listed
  for surfselect(), test is string like &#34;$x &lt; 2.0 and $y &gt; 0.0&#34;
  bins are used when particles are created inside/outside a surf

c.part(ID,n,id_in)                 create N particles inside object id_in
c.part(ID,n,id_in,id_out)          particles are also outside object id_out
c.part2d(ID,n,id_on)               create 2d particles on object id_on
c.partarray(ID,nx,nz,nz,x,y,z,dx,dy,dz)   create 3d grid of particles
c.partring(ID,n,x,y,z,r,&#39;x&#39;)              create ring of particles
c.partsurf(ID,id_on)               change surf of existing 2d particle group
c.seed(43284)                      set random # seed (def = 12345)

  generate particle positions randomly (unless otherwise noted)
  for part(), id_in and id_out must be IDs of a surf, region, or union object
    inside a union object means inside any of the lower-level objects
    outside a union object means outside all of the lower-level objects
  for part2d(), id_on must be ID of a surf, region, or union object
  for part2d(), particles will be written as 2d assigned to surf id_on
  for partring(), ring axis is in &#39;x&#39;,&#39;y&#39;, or &#39;z&#39; direction
  partsurf() changes surf id_on for an existing 2d particle group

x,n = c.random(ID)                 pick a random pt on surf of object ID

c.project(ID,ID2,dx,dy,dz,eps,fg)  project particles in ID to surf of obj ID2

  random() returns pt = [x,y,z] and normal vec n [nx,ny,nz]
  project() remaps particle coords in group ID
    moves each particle along dir until they are within eps of surface
    if no fg arg, dir = (dx,dy,dz)
    if fg arg, dir = line from particle coord to (dx,dy,dz)
    ID2 can be surf or region obj
    particles are converted to 2d assigned to surf ID2

c.center(ID,x,y,z)                 set center point of object
c.trans(ID,dx,dy,dz)               translate an object
c.rotate(ID,&#39;x&#39;,1,1,0,&#39;z&#39;,-1,1,0)  rotate an object
c.scale(ID,sx,sy,sz)               scale an object

  objects must be surface or particle group, regions cannot be changed
  for center(), default is middle of bounding box (set when obj is created)
  for rotate(), set any 2 axes, must be orthogonal, 3rd is inferred
    object is rotated so that it&#39;s current xyz axes point along new ones
  rotation and scaling occur relative to center point

c.union(ID,id1,id2,...)            create a new union object from id1,id2,etc
c.join(ID,id1,id2,...)             create a new object by joining id1,id2,etc
c.delete(id1,id2,...)              delete one or more objects
c.rename(ID,IDnew)                 rename an object
c.copy(ID,IDnew)                   create a new object as copy of old object

  for union, all lower-level objects must be of surface, region, or union style
  for join, all joined objects must be of same style: group, surf, line
    new object is the same style

c.select(id1,id2,...)              select one or more objects
c.select()                         select all objects
c.unselect(id1,id2,...)            unselect one or more objects
c.unselect()                       unselect all objects

  selection applies to write() and viz()

c.write(&#34;file&#34;)                    write all selected objs to ChemCell file
c.write(&#34;file&#34;,id1,id2,...)        write only listed &amp; selected objects to file
c.append(&#34;file&#34;)                   append all selected objs to ChemCell file
c.append(&#34;file&#34;,id1,id2,...)       append only listed &amp; selected objects

  union objects are skipped, not written to file

index,time,flag = c.iterator(0/1)          loop over single snapshot
time,box,atoms,bonds,tris,lines = c.viz(index)   return list of viz objects

  iterator() and viz() are compatible with equivalent dump calls
  iterator() called with arg = 0 first time, with arg = 1 on subsequent calls
    index = timestep index within dump object (only 0 for data file)
    time = timestep value (only 0 for data file)
    flag = -1 when iteration is done, 1 otherwise
  viz() returns info for selected objs for specified timestep index (must be 0)
    time = 0
    box = [xlo,ylo,zlo,xhi,yhi,zhi]
    atoms = id,type,x,y,z for each atom as 2d array
      NULL if atoms do not exist
    bonds = NULL
    tris = id,type,x1,y1,z1,x2,y2,z2,x3,y3,z3,nx,ny,nz for each tri as 2d array
      regions are triangulated according to q() settings by viz()
      NULL if surfaces do not exist
    lines = id,type,x1,y1,z1,x2,y2,z2 for each line as 2d array
      NULL if lines do not exist
    types are assigned to each object of same style in ascending order
&#34;&#34;&#34;

# History
#      11/05, Steve Plimpton (SNL): original version
# 2025-01-17, first conversion in connection with the update of pizza.dump3

# ToDo list

# Variables
#   nselect = 1 = # of snapshots
#   ids = dictionary of IDs that points to object index
#   objs = list of objects, style = REGION, SURFACE, GROUP, UNION

# Imports and external programs

import sys
import glob
from os import popen
from math import sqrt, pi, cos, sin, fabs
from copy import deepcopy

##############################################################################
# External dependency
PIZZA_GUNZIP = &#34;gunzip&#34;

##############################################################################
# Define constants for object styles

REGION   = 1
SURFACE  = 2
GROUP    = 3
UNION    = 4

BOX      = 5
SPHERE   = 6
SHELL    = 7
CYLINDER = 8
CAPPED   = 9
LINE     = 10

EPSILON  = 1.0e-6
BIG      = 1.0e20

##############################################################################
# Random Number Generator

IM = 2147483647
AM = 1.0 / IM
IA = 16807
IQ = 127773
IR = 2836

class Random:
    &#34;&#34;&#34;
    Simple linear congruential generator (LCG) for random numbers.
    &#34;&#34;&#34;
    def __init__(self, seed):
        self.seed = seed
    
    def __call__(self):
        k = self.seed // IQ
        self.seed = IA * (self.seed - k * IQ) - IR * k
        if self.seed &lt; 0:
            self.seed += IM
        return AM * self.seed

##############################################################################
# Vector Helpers

def cross(a, b):
    &#34;&#34;&#34;
    Compute the cross product of vectors a and b (each 3D).
    &#34;&#34;&#34;
    return [
        a[1]*b[2] - a[2]*b[1],
        a[2]*b[0] - a[0]*b[2],
        a[0]*b[1] - a[1]*b[0]
    ]

def normalize(a):
    &#34;&#34;&#34;
    Normalize vector a in-place to unit length.
    &#34;&#34;&#34;
    length = sqrt(a[0]**2 + a[1]**2 + a[2]**2)
    if length != 0.0:
        a[0] /= length
        a[1] /= length
        a[2] /= length

def normal(x, y, z):
    &#34;&#34;&#34;
    Compute the normal vector for a triangle with vertices x, y, z.
    Each vertex is a 3D coordinate [x, y, z].
    &#34;&#34;&#34;
    v1 = [y[i] - x[i] for i in range(3)]
    v2 = [z[i] - y[i] for i in range(3)]
    n = cross(v1, v2)
    normalize(n)
    return n


##############################################################################
# Triangulation Helpers

def vertex(v, vertices, vdict):
    &#34;&#34;&#34;
    Add a vertex to the vertices list if not already present.
    Return the index of the vertex in the vertices list.
    &#34;&#34;&#34;
    vtup = tuple(v)
    if vtup in vdict:
        return vdict[vtup]
    idx = len(vertices)
    vertices.append(v)
    vdict[vtup] = idx
    return idx

def connect(nvert, ntri, triangles):
    &#34;&#34;&#34;
    Create connections between triangles in a triangulated surface.
    Each triangle has 3 vertices. Return a list of connections for each tri.
    &#34;&#34;&#34;
    # v2tri[v] = list of triangles that vertex v is a member of
    v2tri = [[] for _ in range(nvert)]
    for i in range(ntri):
        for vert in triangles[i]:
            v2tri[vert-1].append(i)
    
    connections = []
    for i in range(ntri):
        connect_tri = [0]*6  # [tri1, edge1, tri2, edge2, tri3, edge3]
        v = triangles[i]
        
        # For edges (v[0]-v[1]), (v[1]-v[2]), (v[2]-v[0])
        edges = [
            (v[0], v[1]),
            (v[1], v[2]),
            (v[2], v[0])
        ]
        
        for edge_idx, (startv, endv) in enumerate(edges):
            # Triangles sharing startv
            for itri in v2tri[startv-1]:
                if itri == i:
                    continue
                if endv in triangles[itri]:
                    connect_tri[2*edge_idx] = itri+1
                    # Figure out which edge in itri
                    # (this is approximate; advanced logic may be required)
                    other_tri = triangles[itri]
                    # Attempt to find local edge
                    # For simplicity, store edge=1 if other_tri&#39;s first edge,
                    # edge=2 if second, edge=3 if third, etc.
                    # This might need deeper logic if the &#39;edge index&#39; is critical.
                    connect_tri[2*edge_idx + 1] = 1  # Simplify for now
                    break
        
        connections.append(connect_tri)
    return connections

def box_triangulate(q1, q2, q3):
    &#34;&#34;&#34;
    Triangulate a unit box from (0,0,0) to (1,1,1) with spacings q1, q2, q3.
    Return a list of vertices and triangles. Triangles are oriented outward.
    &#34;&#34;&#34;
    dx = 1.0/q1 if q1 else 1.0
    dy = 1.0/q2 if q2 else 1.0
    dz = 1.0/q3 if q3 else 1.0
    
    vdict = {}
    vertices = []
    triangles = []
    
    # Triangulate faces in x=0, x=1, y=0, y=1, z=0, z=1, etc.
    # This method can be quite extensive; for clarity, partial examples
    # are included. Adjust logic as needed to cover all box faces.
    
    # Face x=0
    for j in range(q2):
        for k in range(q3):
            v1 = (0,      j*dy,     k*dz)
            v2 = (0, (j+1)*dy,     k*dz)
            v3 = (0, (j+1)*dy, (k+1)*dz)
            v4 = (0,      j*dy, (k+1)*dz)
            
            iv1 = vertex(list(v1), vertices, vdict)
            iv2 = vertex(list(v2), vertices, vdict)
            iv3 = vertex(list(v3), vertices, vdict)
            iv4 = vertex(list(v4), vertices, vdict)
            
            # Two triangles per cell
            triangles.append([iv1+1, iv3+1, iv2+1])
            triangles.append([iv1+1, iv4+1, iv3+1])
    
    # Similarly handle x=1, y=0, y=1, z=0, z=1 faces...
    # For brevity, only partial face coverage is shown here.
    # Extend similarly if a full triangulation is required.
    
    return vertices, triangles


##############################################################################
# Base Classes for cdata

class Surface:
    def __init__(self):
        self.select = 0
        self.style = SURFACE
        self.id = &#34;&#34;
        self.nvert = 0
        self.ntri = 0
        self.nbinx = 0
        self.nbiny = 0
        self.vertices = []
        self.triangles = []
        self.connections = []
        # For bounding box center
        self.xc = 0.0
        self.yc = 0.0
        self.zc = 0.0
    
    def bbox(self):
        &#34;&#34;&#34;
        Return bounding box of all vertices in this surface.
        &#34;&#34;&#34;
        if not self.vertices:
            return (0, 0, 0, 0, 0, 0)
        xs = [float(v[0]) for v in self.vertices]
        ys = [float(v[1]) for v in self.vertices]
        zs = [float(v[2]) for v in self.vertices]
        return (min(xs), min(ys), min(zs), max(xs), max(ys), max(zs))
    
    def center(self, x=None, y=None, z=None):
        &#34;&#34;&#34;
        Set center of the surface explicitly or to the midpoint of bounding box.
        &#34;&#34;&#34;
        if x is not None and y is not None and z is not None:
            self.xc = x
            self.yc = y
            self.zc = z
        else:
            xlo, ylo, zlo, xhi, yhi, zhi = self.bbox()
            self.xc = 0.5 * (xlo + xhi)
            self.yc = 0.5 * (ylo + yhi)
            self.zc = 0.5 * (zlo + zhi)
    
    def inside_prep(self):
        &#34;&#34;&#34;
        Prepare binning if you want to accelerate inside() checks.
        Depending on usage, implement as needed.
        &#34;&#34;&#34;
        pass
    
    def inside(self, x, y, z):
        &#34;&#34;&#34;
        Check if point (x, y, z) is inside this closed surface.
        By default, return False (0).
        Implement if needed.
        &#34;&#34;&#34;
        return 0
    
    def area(self):
        &#34;&#34;&#34;
        Return total surface area of this surface.
        By default, sum the area of each triangle.
        &#34;&#34;&#34;
        # For each tri, area = 1/2 * cross(v2 - v1, v3 - v1)
        # We&#39;ll accumulate it.
        total_area = 0.0
        for tri in self.triangles:
            v1 = self.vertices[tri[0]-1]
            v2 = self.vertices[tri[1]-1]
            v3 = self.vertices[tri[2]-1]
            # Compute area
            side1 = [v2[i] - v1[i] for i in range(3)]
            side2 = [v3[i] - v1[i] for i in range(3)]
            cr = cross(side1, side2)
            tri_area = 0.5 * sqrt(cr[0]**2 + cr[1]**2 + cr[2]**2)
            total_area += tri_area
        return total_area
    
    def loc2d(self, area, random_fn):
        &#34;&#34;&#34;
        Return a random point on the surface, given a pre-chosen &#39;area&#39; fraction.
        By default, pick from triangles in ascending area order.
        Must implement your own partial sums if you want a strict area-based sampling.
        &#34;&#34;&#34;
        # Simple placeholder: pick any tri
        if not self.triangles:
            return ([0.0, 0.0, 0.0], [0.0, 0.0, 1.0])
        # For now, pick the first triangle
        tri = self.triangles[0]
        v1 = self.vertices[tri[0]-1]
        v2 = self.vertices[tri[1]-1]
        v3 = self.vertices[tri[2]-1]
        # Barycentric random
        r1 = random_fn()
        r2 = random_fn()
        if r1 + r2 &gt; 1.0:
            r1 = 1.0 - r1
            r2 = 1.0 - r2
        x = v1[0] + r1*(v2[0] - v1[0]) + r2*(v3[0] - v1[0])
        y = v1[1] + r1*(v2[1] - v1[1]) + r2*(v3[1] - v1[1])
        z = v1[2] + r1*(v2[2] - v1[2]) + r2*(v3[2] - v1[2])
        n = normal(v1, v2, v3)
        return ([x, y, z], n)

class Group:
    def __init__(self):
        self.select = 0
        self.style = GROUP
        self.id = &#34;&#34;
        self.npart = 0
        self.xyz = []
        self.on_id = &#34;&#34;
        # For bounding box center
        self.xc = 0.0
        self.yc = 0.0
        self.zc = 0.0
    
    def bbox(self):
        &#34;&#34;&#34;
        Return bounding box of all particles in this group.
        &#34;&#34;&#34;
        if not self.xyz:
            return (0, 0, 0, 0, 0, 0)
        xs = [p[0] for p in self.xyz]
        ys = [p[1] for p in self.xyz]
        zs = [p[2] for p in self.xyz]
        return (min(xs), min(ys), min(zs), max(xs), max(ys), max(zs))
    
    def center(self, x=None, y=None, z=None):
        &#34;&#34;&#34;
        Set center of the group explicitly or to the midpoint of bounding box.
        &#34;&#34;&#34;
        if x is not None and y is not None and z is not None:
            self.xc = x
            self.yc = y
            self.zc = z
        else:
            xlo, ylo, zlo, xhi, yhi, zhi = self.bbox()
            self.xc = 0.5 * (xlo + xhi)
            self.yc = 0.5 * (ylo + yhi)
            self.zc = 0.5 * (zlo + zhi)

class Box:
    def __init__(self, *args):
        self.select = 0
        self.style = REGION
        self.id = &#34;&#34;
        self.substyle = BOX
        self.xlo = float(args[0])
        self.ylo = float(args[1])
        self.zlo = float(args[2])
        self.xhi = float(args[3])
        self.yhi = float(args[4])
        self.zhi = float(args[5])
        # Default triangulation quality
        self.q1 = self.q2 = self.q3 = 1.0

    def bbox(self):
        return (self.xlo, self.ylo, self.zlo, self.xhi, self.yhi, self.zhi)

    def inside(self, x, y, z):
        if x &lt; self.xlo or x &gt; self.xhi: return 0
        if y &lt; self.ylo or y &gt; self.yhi: return 0
        if z &lt; self.zlo or z &gt; self.zhi: return 0
        return 1

    def triangulate(self):
        vertices, triangles = box_triangulate(int(self.q1),
                                              int(self.q2),
                                              int(self.q3))
        self.nvert = len(vertices)
        self.ntri = len(triangles)
        self.vertices = []
        for i in range(self.nvert):
            v1 = self.xlo + vertices[i][0]*(self.xhi - self.xlo)
            v2 = self.ylo + vertices[i][1]*(self.yhi - self.ylo)
            v3 = self.zlo + vertices[i][2]*(self.zhi - self.zlo)
            self.vertices.append([v1, v2, v3])
        self.triangles = []
        for tri in triangles:
            self.triangles.append([tri[0], tri[1], tri[2]])
        self.connections = connect(self.nvert, self.ntri, self.triangles)

    def area(self):
        xsize = self.xhi - self.xlo
        ysize = self.yhi - self.ylo
        zsize = self.zhi - self.zlo
        # area of all 6 faces
        faces = [
            ysize*zsize,
            ysize*zsize,
            xsize*zsize,
            xsize*zsize,
            xsize*ysize,
            xsize*ysize,
        ]
        # Store cumulative if desired, but we’ll just return sum
        return sum(faces)

    def loc2d(self, area, random_fn):
        &#34;&#34;&#34;
        Return a random point on the surface, ignoring partial sums for now.
        This is a simplified approach. Adjust to handle &#39;area&#39; fraction properly.
        &#34;&#34;&#34;
        # For demonstration, pick one face (e.g., x=low)
        r1, r2 = random_fn(), random_fn()
        xsize = self.xhi - self.xlo
        ysize = self.yhi - self.ylo
        zsize = self.zhi - self.zlo
        # Suppose we pick face x=low
        return ([self.xlo,
                 self.ylo + r1*ysize,
                 self.zlo + r2*zsize],
                [-1.0, 0.0, 0.0])

    def command(self):
        return f&#34;{self.id} box {self.xlo} {self.ylo} {self.zlo} {self.xhi} {self.yhi} {self.zhi}&#34;

class Sphere:
    def __init__(self, *args):
        self.select = 0
        self.style = REGION
        self.id = &#34;&#34;
        self.substyle = SPHERE
        self.x = float(args[0])
        self.y = float(args[1])
        self.z = float(args[2])
        self.r = float(args[3])
        self.rsq = self.r**2
        # Triangulation quality
        self.q1 = 2.0

    def bbox(self):
        return (self.x-self.r, self.y-self.r, self.z-self.r,
                self.x+self.r, self.y+self.r, self.z+self.r)

    def inside(self, x, y, z):
        dx = x - self.x
        dy = y - self.y
        dz = z - self.z
        if (dx*dx + dy*dy + dz*dz) &gt; self.rsq:
            return 0
        return 1

    def triangulate(self):
        vertices, triangles = box_triangulate(int(self.q1),
                                              int(self.q1),
                                              int(self.q1))
        self.nvert = len(vertices)
        self.ntri = len(triangles)
        self.vertices = []
        for i in range(self.nvert):
            v1 = vertices[i][0] - 0.5
            v2 = vertices[i][1] - 0.5
            v3 = vertices[i][2] - 0.5
            c = [v1, v2, v3]
            normalize(c)
            c[0] = self.x + self.r*c[0]
            c[1] = self.y + self.r*c[1]
            c[2] = self.z + self.r*c[2]
            self.vertices.append(c)
        self.triangles = []
        for tri in triangles:
            self.triangles.append([tri[0], tri[1], tri[2]])
        self.connections = connect(self.nvert, self.ntri, self.triangles)

    def area(self):
        return 4.0 * pi * (self.r**2)

    def loc2d(self, area, random_fn):
        &#34;&#34;&#34;
        Return a random location on the sphere surface.
        &#34;&#34;&#34;
        while True:
            x_ = random_fn() - 0.5
            y_ = random_fn() - 0.5
            z_ = random_fn() - 0.5
            if (x_*x_ + y_*y_ + z_*z_) &lt;= 0.25:
                break
        c = [x_, y_, z_]
        normalize(c)
        return ([self.x + self.r*c[0],
                 self.y + self.r*c[1],
                 self.z + self.r*c[2]],
                c)

    def command(self):
        return f&#34;{self.id} sphere {self.x} {self.y} {self.z} {self.r}&#34;

class Shell(Sphere):
    def __init__(self, *args):
        super().__init__(*args[:4])
        self.substyle = SHELL
        self.rinner = float(args[4])
        self.innersq = self.rinner**2

    def inside(self, x, y, z):
        dx = x - self.x
        dy = y - self.y
        dz = z - self.z
        rsq = dx*dx + dy*dy + dz*dz
        if rsq &gt; self.rsq or rsq &lt; self.innersq:
            return 0
        return 1

    def command(self):
        return f&#34;{self.id} shell {self.x} {self.y} {self.z} {self.r} {self.rinner}&#34;

class Cylinder:
    def __init__(self, *args):
        self.select = 0
        self.style = REGION
        self.id = &#34;&#34;
        self.substyle = CYLINDER
        self.axis = args[0]
        self.c1 = float(args[1])
        self.c2 = float(args[2])
        self.r = float(args[3])
        self.lo = float(args[4])
        self.hi = float(args[5])
        self.rsq = self.r**2
        self.q1 = 2
        self.q2 = 1

    def bbox(self):
        if self.axis == &#39;x&#39;:
            return (self.lo, self.c1-self.r, self.c2-self.r,
                    self.hi, self.c1+self.r, self.c2+self.r)
        elif self.axis == &#39;y&#39;:
            return (self.c1-self.r, self.lo, self.c2-self.r,
                    self.c1+self.r, self.hi, self.c2+self.r)
        elif self.axis == &#39;z&#39;:
            return (self.c1-self.r, self.c2-self.r, self.lo,
                    self.c1+self.r, self.c2+self.r, self.hi)
        return (0, 0, 0, 0, 0, 0)

    def inside(self, x, y, z):
        if self.axis == &#39;x&#39;:
            d1 = y - self.c1
            d2 = z - self.c2
            d3 = x
        elif self.axis == &#39;y&#39;:
            d1 = x - self.c1
            d2 = z - self.c2
            d3 = y
        else:  # &#39;z&#39;
            d1 = x - self.c1
            d2 = y - self.c2
            d3 = z
        rsq = d1*d1 + d2*d2
        if rsq &gt; self.rsq:
            return 0
        if d3 &lt; self.lo or d3 &gt; self.hi:
            return 0
        return 1

    def triangulate(self):
        vertices, triangles = box_triangulate(self.q1, self.q1, self.q2)
        self.nvert = len(vertices)
        self.ntri = len(triangles)
        self.vertices = []
        for v in vertices:
            v1 = v[0] - 0.5
            v2 = v[1] - 0.5
            v3 = v[2]
            c = [v1, v2, 0]
            normalize(c)
            length = max(fabs(v1), fabs(v2)) * 2.0
            c[0] *= length
            c[1] *= length
            p1 = self.c1 + self.r*c[0]
            p2 = self.c2 + self.r*c[1]
            p3 = self.lo + v3*(self.hi - self.lo)
            if self.axis == &#39;x&#39;:
                self.vertices.append([p3, p1, p2])
            elif self.axis == &#39;y&#39;:
                self.vertices.append([p1, p3, p2])
            else:
                self.vertices.append([p1, p2, p3])
        self.triangles = [[t[0], t[1], t[2]] for t in triangles]
        self.connections = connect(self.nvert, self.ntri, self.triangles)

    def area(self):
        &#34;&#34;&#34;
        Cylinder area = 2 * (circle area) + side area = 2 * (πr²) + (2πr * length)
        But we store partial sums if needed.
        &#34;&#34;&#34;
        circle_area = pi * self.r**2
        length = self.hi - self.lo
        top_bottom = 2*circle_area
        side = 2*pi*self.r*length
        self.areas = [circle_area, top_bottom, top_bottom+side]
        return top_bottom + side

    def loc2d(self, area, random_fn):
        # Implementation stub
        return ([self.c1, self.c2, self.lo], [1, 0, 0])

    def command(self):
        return (f&#34;{self.id} cylinder {self.axis} {self.c1} {self.c2} &#34;
                f&#34;{self.r} {self.lo} {self.hi}&#34;)

class Capped:
    def __init__(self, *args):
        self.select = 0
        self.style = REGION
        self.id = &#34;&#34;
        self.substyle = CAPPED
        self.axis = args[0]
        self.c1 = float(args[1])
        self.c2 = float(args[2])
        self.r = float(args[3])
        self.lo = float(args[4])
        self.hi = float(args[5])
        self.rsq = self.r**2
        self.q1 = 2
        self.q2 = 1

    def bbox(self):
        if self.axis == &#39;x&#39;:
            return (self.lo - self.r, self.c1 - self.r, self.c2 - self.r,
                    self.hi + self.r, self.c1 + self.r, self.c2 + self.r)
        elif self.axis == &#39;y&#39;:
            return (self.c1 - self.r, self.lo - self.r, self.c2 - self.r,
                    self.c1 + self.r, self.hi + self.r, self.c2 + self.r)
        else:  # &#39;z&#39;
            return (self.c1 - self.r, self.c2 - self.r, self.lo - self.r,
                    self.c1 + self.r, self.c2 + self.r, self.hi + self.r)

    def inside(self, x, y, z):
        if self.axis == &#39;x&#39;:
            d1 = y - self.c1
            d2 = z - self.c2
            d3 = x
        elif self.axis == &#39;y&#39;:
            d1 = x - self.c1
            d2 = z - self.c2
            d3 = y
        else:  # &#39;z&#39;
            d1 = x - self.c1
            d2 = y - self.c2
            d3 = z
        rsq = d1*d1 + d2*d2
        if self.lo &lt;= d3 &lt;= self.hi:
            if rsq &gt; self.rsq:
                return 0
        elif d3 &lt; self.lo:
            if (d1*d1 + d2*d2 + (d3 - self.lo)**2) &gt; self.rsq:
                return 0
        else:
            if (d1*d1 + d2*d2 + (d3 - self.hi)**2) &gt; self.rsq:
                return 0
        return 1

    def triangulate(self):
        if self.q1 % 2 != 0:
            raise Exception(&#34;Capped cylinder q1 must be even&#34;)
        vertices, triangles = box_triangulate(int(self.q1),
                                              int(self.q1),
                                              int(self.q2 + self.q1))
        self.nvert = len(vertices)
        self.ntri = len(triangles)
        self.vertices = []
        # For a capped cylinder, partial code:
        cutlo = (self.q1 // 2) * 1.0 / (self.q2 + self.q1) + EPSILON
        cuthi = 1.0 - cutlo
        for v in vertices:
            v1 = v[0]
            v2 = v[1]
            v3 = v[2]
            if v3 &lt; cutlo:
                c = [v1 - 0.5, v2 - 0.5, (v3 - cutlo)*(0.5/cutlo)]
                normalize(c)
                p1 = self.c1 + self.r*c[0]
                p2 = self.c2 + self.r*c[1]
                p3 = self.lo + self.r*c[2]
            elif v3 &gt; cuthi:
                c = [v1 - 0.5, v2 - 0.5, (v3 - cuthi)*(0.5/cutlo)]
                normalize(c)
                p1 = self.c1 + self.r*c[0]
                p2 = self.c2 + self.r*c[1]
                p3 = self.hi + self.r*c[2]
            else:
                c = [v1 - 0.5, v2 - 0.5, 0.0]
                normalize(c)
                p1 = self.c1 + self.r*c[0]
                p2 = self.c2 + self.r*c[1]
                frac = (v3 - cutlo) / (cuthi - cutlo)
                p3 = self.lo + frac * (self.hi - self.lo)
            if self.axis == &#39;x&#39;:
                self.vertices.append([p3, p1, p2])
            elif self.axis == &#39;y&#39;:
                self.vertices.append([p1, p3, p2])
            else:
                self.vertices.append([p1, p2, p3])
        self.triangles = [[t[0], t[1], t[2]] for t in triangles]
        self.connections = connect(self.nvert, self.ntri, self.triangles)

    def area(self):
        &#34;&#34;&#34;
        Surface area of a capped cylinder = cylinder area + 2 * hemisphere discs.
        Approximate if needed. Or store partial sums if you want area-based loc2d.
        &#34;&#34;&#34;
        # Simplistic example:
        side_area = 2 * pi * self.r * (self.hi - self.lo)
        circle_area = pi * self.r * self.r
        # top circle + bottom circle
        top_bottom_area = 2 * circle_area
        return side_area + top_bottom_area

    def loc2d(self, area, random_fn):
        &#34;&#34;&#34;
        Return a random location on the capped cylinder surface.
        &#34;&#34;&#34;
        # Implement a full partition if you want exact coverage.
        return ([self.c1, self.c2, self.lo], [1, 0, 0])

    def command(self):
        return (f&#34;{self.id} capped {self.axis} {self.c1} {self.c2} &#34;
                f&#34;{self.r} {self.lo} {self.hi}&#34;)

class Line:
    def __init__(self):
        self.select = 0
        self.style = LINE
        self.id = &#34;&#34;
        self.nline = 0
        self.pairs = []
    
    def bbox(self):
        &#34;&#34;&#34;
        Return bounding box around all line segments.
        &#34;&#34;&#34;
        if not self.pairs:
            return (0, 0, 0, 0, 0, 0)
        xs = [p[0] for p in self.pairs] + [p[3] for p in self.pairs]
        ys = [p[1] for p in self.pairs] + [p[4] for p in self.pairs]
        zs = [p[2] for p in self.pairs] + [p[5] for p in self.pairs]
        return (min(xs), min(ys), min(zs), max(xs), max(ys), max(zs))
    
    def addline(self, coords):
        &#34;&#34;&#34;
        Add a single line segment (x1, y1, z1, x2, y2, z2).
        &#34;&#34;&#34;
        self.nline += 1
        self.pairs.append(list(coords))

class Union:
    def __init__(self, ids, objs, *list_ids):
        self.select = 0
        self.style = UNION
        self.id = &#34;&#34;
        # child objects
        self.objs = []
        for obj_id in list_ids:
            obj = objs[ids[obj_id]]
            if obj.style not in [SURFACE, REGION, UNION]:
                raise Exception(&#34;Union child object is of invalid style&#34;)
            self.objs.append(obj)
    
    def bbox(self):
        if not self.objs:
            return (0, 0, 0, 0, 0, 0)
        xlo, ylo, zlo, xhi, yhi, zhi = self.objs[0].bbox()
        for obj in self.objs[1:]:
            xxlo, yylo, zzlo, xxhi, yyhi, zzhi = obj.bbox()
            if xxlo &lt; xlo: xlo = xxlo
            if yylo &lt; ylo: ylo = yylo
            if zzlo &lt; zlo: zlo = zzlo
            if xxhi &gt; xhi: xhi = xxhi
            if yyhi &gt; yhi: yhi = yyhi
            if zzhi &gt; zhi: zhi = zzhi
        return (xlo, ylo, zlo, xhi, yhi, zhi)
    
    def inside(self, x, y, z):
        # inside union if inside any of its child objects
        for obj in self.objs:
            if obj.inside(x, y, z):
                return 1
        return 0
    
    def area(self):
        # sum areas of child objects
        total = 0.0
        for obj in self.objs:
            total += obj.area()
        return total
    
    def loc2d(self, area, random_fn):
        &#34;&#34;&#34;
        Return a random location on the union surface, if needed.
        This would require partial sums across each child&#39;s area.
        For brevity, pick first child.
        &#34;&#34;&#34;
        if not self.objs:
            return ([0,0,0], [0,0,1])
        return self.objs[0].loc2d(area, random_fn)



# --------------------------------------------------------------------
# cdata Class Definition

class cdata:
    &#34;&#34;&#34;
    cdata class for reading, creating, and manipulating ChemCell data files.
    &#34;&#34;&#34;
    
    # --------------------------------------------------------------------
    
    def __init__(self, *list):
        &#34;&#34;&#34;
        Initialize the cdata object.

        Parameters:
            *list: Variable length argument list of file names to read.
        &#34;&#34;&#34;
        self.nselect = 1
        self.ids = {}
        self.objs = []
        self.random = Random(12345)

        if len(list):
            self.read(*list)
    
    # --------------------------------------------------------------------
    
    def read(self, *list):
        &#34;&#34;&#34;
        Read ChemCell data files and populate objects.

        Parameters:
            *list: Variable length argument list of file names to read.
        &#34;&#34;&#34;
        # flist = list of all data file names
        words = list[0].split()
        flist = []
        for word in words:
            flist += glob.glob(word)
        if len(flist) == 0 and len(list) == 1:
            raise Exception(&#34;no data file specified&#34;)
    
        for file in flist:
            # Test for gzipped file
            if file.endswith(&#34;.gz&#34;):
                f = popen(f&#34;{PIZZA_GUNZIP} -c {file}&#34;, &#39;r&#39;)
            else:
                f = open(file, &#39;r&#39;)
    
            # Read all entries in file
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                if not line:
                    continue
                elif line.startswith(&#34;triangles&#34;):
                    flag = &#34;triangles&#34;
                elif line.startswith(&#34;particles&#34;):
                    flag = &#34;particles&#34;
                elif line.startswith(&#34;facets&#34;):
                    flag = &#34;facets&#34;
                elif line.startswith(&#34;region&#34;):
                    flag = &#34;region&#34;
                else:
                    print(&#34;unknown line:&#34;, line)
                    raise Exception(&#34;unrecognized ChemCell data file&#34;)
    
                # Create a surface object from set of triangles or facets
                if flag in [&#34;triangles&#34;, &#34;facets&#34;]:
                    tmp, id, nvert, ntri = line.split()
                    nvert = int(nvert)
                    ntri = int(ntri)
    
                    if id in self.ids:
                        raise Exception(f&#34;ID {id} is already in use&#34;)
    
                    f.readline()  # Read past header
                    vertices = []
                    for _ in range(nvert):
                        parts = f.readline().split()
                        vertices.append([float(value) for value in parts[1:]])
                    f.readline()  # Read past another header
                    triangles = []
                    for _ in range(ntri):
                        parts = f.readline().split()
                        triangles.append([int(value) for value in parts[1:]])
    
                    if flag == &#34;triangles&#34;:
                        f.readline()  # Read past another header
                        connections = []
                        for _ in range(ntri):
                            parts = f.readline().split()
                            connections.append([int(value) for value in parts[1:]])
                    else:
                        connections = connect(nvert, ntri, triangles)
                    
                    obj = Surface()
                    obj.select = 1
                    self.ids[id] = len(self.objs)
                    self.objs.append(obj)
                    obj.id = id
                    obj.style = SURFACE
                    obj.nvert = nvert
                    obj.ntri = ntri
                    obj.vertices = vertices
                    obj.triangles = triangles
                    obj.connections = connections
                    obj.center()
                  
                    print(id, end=&#39; &#39;)
                    sys.stdout.flush()
    
                # Create a group object from list of particles
                if flag == &#34;particles&#34;:
                    words = line.split()
                    id = words[1]
                    npart = int(words[2])
    
                    if id in self.ids:
                        raise Exception(f&#34;ID {id} is already in use&#34;)
    
                    f.readline()  # Read past header
                    xyz = []
                    for _ in range(npart):
                        parts = f.readline().split()
                        xyz.append([float(value) for value in parts[1:]])
    
                    obj = Group()
                    obj.select = 1
                    self.ids[id] = len(self.objs)
                    self.objs.append(obj)
                    obj.id = id
                    obj.style = GROUP
                    obj.on_id = &#34;&#34;
                    if len(words) == 4:
                        obj.on_id = words[3]
                    obj.npart = npart
                    obj.xyz = xyz
                    obj.center()
                    
                    print(id, end=&#39; &#39;)
                    sys.stdout.flush()
    
                # Create a region object from ChemCell region command
                if flag == &#34;region&#34;:
                    words = line.split()
                    id = words[1]
                    style = words[2]
                    args = words[3:]
                    
                    if style == &#34;box&#34;:
                        obj = Box(*args)
                        obj.substyle = BOX
                    elif style == &#34;sphere&#34;:
                        obj = Sphere(*args)
                    elif style == &#34;shell&#34;:
                        obj = Shell(*args)
                    elif style == &#34;cylinder&#34;:
                        obj = Cylinder(*args)
                    elif style == &#34;capped&#34;:
                        obj = Capped(*args)
                    else:
                        raise Exception(f&#34;Unknown region style: {style}&#34;)
                    
                    obj.select = 1
                    self.ids[id] = len(self.objs)
                    self.objs.append(obj)
                    obj.id = id
                    obj.style = REGION
                    
                    print(id, end=&#39; &#39;)
                    sys.stdout.flush()
    
            f.close()
        print()
    
    # --------------------------------------------------------------------
    # Create Box Region
    
    def box(self, id, *args):
        &#34;&#34;&#34;
        Create a box region.

        Parameters:
            id (str): Unique identifier for the box.
            args: xlo, ylo, zlo, xhi, yhi, zhi
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Box(*args)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = REGION
        obj.substyle = BOX
    
    # --------------------------------------------------------------------
    # Create Sphere Region
    
    def sphere(self, id, *args):
        &#34;&#34;&#34;
        Create a sphere region.

        Parameters:
            id (str): Unique identifier for the sphere.
            args: x, y, z, r
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Sphere(*args)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = REGION
        obj.substyle = SPHERE
    
    # --------------------------------------------------------------------
    # Create Shell Region
    
    def shell(self, id, *args):
        &#34;&#34;&#34;
        Create a shell region.

        Parameters:
            id (str): Unique identifier for the shell.
            args: x, y, z, r, rinner
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Shell(*args)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = REGION
        obj.substyle = SHELL
    
    # --------------------------------------------------------------------
    # Create Cylinder Region
    
    def cyl(self, id, *args):
        &#34;&#34;&#34;
        Create a cylinder region.

        Parameters:
            id (str): Unique identifier for the cylinder.
            args: axis, c1, c2, r, lo, hi
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Cylinder(*args)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = REGION
        obj.substyle = CYLINDER
    
    # --------------------------------------------------------------------
    # Create Capped-Cylinder Region
    
    def cap(self, id, *args):
        &#34;&#34;&#34;
        Create a capped-cylinder region.

        Parameters:
            id (str): Unique identifier for the capped-cylinder.
            args: axis, c1, c2, r, lo, hi
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Capped(*args)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = REGION
        obj.substyle = CAPPED
    
    # --------------------------------------------------------------------
    # Set Quality Factors for a Region&#39;s Triangulation
    
    def q(self, id, *args):
        &#34;&#34;&#34;
        Set quality factors for a region&#39;s triangulation routine.

        Parameters:
            id (str): Identifier of the region.
            args: Quality factors (q1, q2, ...)
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style != REGION:
            raise Exception(&#34;Can only use q() on a region object&#34;)
        for n, arg in enumerate(args, start=1):
            setattr(obj, f&#34;q{n}&#34;, arg)
    
    # --------------------------------------------------------------------
    # Create a Line Object with a Single Line
    
    def line(self, id, *args):
        &#34;&#34;&#34;
        Create a line object with a single line.

        Parameters:
            id (str): Unique identifier for the line.
            args: x1, y1, z1, x2, y2, z2
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Line()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = LINE
        obj.nline = 0
        obj.pairs = []
        
        obj.addline(args)
    
    # --------------------------------------------------------------------
    # Create a Line Object with 12 Box Lines
    
    def lbox(self, id, *args):
        &#34;&#34;&#34;
        Create a line object with 12 lines representing a box.

        Parameters:
            id (str): Unique identifier for the line box.
            args: xlo, ylo, zlo, xhi, yhi, zhi
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Line()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = LINE
        obj.nline = 0
        obj.pairs = []
        
        xlo, ylo, zlo, xhi, yhi, zhi = args
        obj.addline([xlo, ylo, zlo, xhi, ylo, zlo])
        obj.addline([xlo, yhi, zlo, xhi, yhi, zlo])
        obj.addline([xlo, yhi, zhi, xhi, yhi, zhi])
        obj.addline([xlo, ylo, zhi, xhi, ylo, zhi])
        obj.addline([xlo, ylo, zlo, xlo, yhi, zlo])
        obj.addline([xhi, ylo, zlo, xhi, yhi, zlo])
        obj.addline([xhi, ylo, zhi, xhi, yhi, zhi])
        obj.addline([xlo, ylo, zhi, xlo, yhi, zhi])
        obj.addline([xlo, ylo, zlo, xlo, ylo, zhi])
        obj.addline([xhi, ylo, zlo, xhi, ylo, zhi])
        obj.addline([xhi, yhi, zlo, xhi, yhi, zhi])
        obj.addline([xlo, yhi, zlo, xlo, yhi, zhi])
    
    # --------------------------------------------------------------------
    # Create a Triangulated Surface Object from a Region Object
    
    def surf(self, id, id_region):
        &#34;&#34;&#34;
        Create a triangulated surface from a region object.

        Parameters:
            id (str): Unique identifier for the surface.
            id_region (str): Identifier of the region to triangulate.
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        region = self.objs[self.ids[id_region]]
        region.triangulate()
        
        obj = Surface()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = SURFACE
        obj.nvert = region.nvert
        obj.ntri = region.ntri
        obj.vertices = deepcopy(region.vertices)
        obj.triangles = deepcopy(region.triangles)
        obj.connections = deepcopy(region.connections)
        obj.center()
    
    # --------------------------------------------------------------------
    # Create a Triangulated Surface Object from List of Triangle Indices
    
    def surftri(self, id, id_surf, *list_indices):
        &#34;&#34;&#34;
        Create a triangulated surface from a list of triangle indices in another surface.

        Parameters:
            id (str): Unique identifier for the new surface.
            id_surf (str): Identifier of the existing surface.
            *list_indices: Triangle indices to include (1-based indexing).
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        o = self.objs[self.ids[id_surf]]
        
        obj = Surface()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = SURFACE
        obj.nvert = 0
        obj.ntri = 0
        obj.vertices = []
        obj.triangles = []
    
        # Subtract 1 from tri and vert to convert to 0-based indexing
        for i in list_indices:
            tri = o.triangles[i-1]
            v1 = o.triangles[i-1][0]
            v2 = o.triangles[i-1][1]
            v3 = o.triangles[i-1][2]
            obj.vertices.append(o.vertices[v1-1][:])
            obj.vertices.append(o.vertices[v2-1][:])
            obj.vertices.append(o.vertices[v3-1][:])
            obj.triangles.append([obj.nvert+1, obj.nvert+2, obj.nvert+3])
            obj.nvert += 3
            obj.ntri += 1
    
        # Make any connections in new set of triangles
        obj.connections = connect(obj.nvert, obj.ntri, obj.triangles)
        obj.center()
    
    # --------------------------------------------------------------------
    # Create a Triangulated Surface Object by Selecting Triangles Based on a Test
    
    def surfselect(self, id, id_surf, teststr):
        &#34;&#34;&#34;
        Create a triangulated surface by selecting triangles based on a test string.

        Parameters:
            id (str): Unique identifier for the new surface.
            id_surf (str): Identifier of the existing surface.
            teststr (str): Test condition (e.g., &#34;$x &lt; 2.0 and $y &gt; 0.0&#34;).
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        o = self.objs[self.ids[id_surf]]
        
        obj = Surface()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = SURFACE
        obj.nvert = 0
        obj.ntri = 0
        obj.vertices = []
        obj.triangles = []
    
        # Replace $var with o.vertices reference and compile test string
        cmd1 = teststr.replace(&#34;$x&#34;, &#34;o.vertices[v1][0]&#34;)
        cmd1 = cmd1.replace(&#34;$y&#34;, &#34;o.vertices[v1][1]&#34;)
        cmd1 = &#34;flag1 = &#34; + cmd1.replace(&#34;$z&#34;, &#34;o.vertices[v1][2]&#34;)
        ccmd1 = compile(cmd1, &#39;&#39;, &#39;single&#39;)
    
        cmd2 = teststr.replace(&#34;$x&#34;, &#34;o.vertices[v2][0]&#34;)
        cmd2 = cmd2.replace(&#34;$y&#34;, &#34;o.vertices[v2][1]&#34;)
        cmd2 = &#34;flag2 = &#34; + cmd2.replace(&#34;$z&#34;, &#34;o.vertices[v2][2]&#34;)
        ccmd2 = compile(cmd2, &#39;&#39;, &#39;single&#39;)
    
        cmd3 = teststr.replace(&#34;$x&#34;, &#34;o.vertices[v3][0]&#34;)
        cmd3 = cmd3.replace(&#34;$y&#34;, &#34;o.vertices[v3][1]&#34;)
        cmd3 = &#34;flag3 = &#34; + cmd3.replace(&#34;$z&#34;, &#34;o.vertices[v3][2]&#34;)
        ccmd3 = compile(cmd3, &#39;&#39;, &#39;single&#39;)
    
        # Loop over triangles in id_surf
        for tri in o.triangles:
            v1 = tri[0] - 1
            v2 = tri[1] - 1
            v3 = tri[2] - 1
            exec(ccmd1)
            exec(ccmd2)
            exec(ccmd3)
            if flag1 and flag2 and flag3:
                obj.vertices.append(o.vertices[v1][:])
                obj.vertices.append(o.vertices[v2][:])
                obj.vertices.append(o.vertices[v3][:])
                obj.triangles.append([obj.nvert+1, obj.nvert+2, obj.nvert+3])
                obj.nvert += 3
                obj.ntri += 1
    
        # Make any connections in new set of triangles
        obj.connections = connect(obj.nvert, obj.ntri, obj.triangles)
        obj.center()
    
    # --------------------------------------------------------------------
    # Set Binning Parameters for a Surface
    
    def bins(self, id, nx, ny):
        &#34;&#34;&#34;
        Set binning parameters for a surface.

        Parameters:
            id (str): Identifier of the surface.
            nx (int): Number of bins in the x-direction.
            ny (int): Number of bins in the y-direction.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style != SURFACE:
            raise Exception(&#34;Can only set bins for surface&#34;)
        obj.nbinx = nx
        obj.nbiny = ny
    
    # --------------------------------------------------------------------
    # Create a Group Object with N Particles Inside and Outside Constraints
    
    def part(self, id, npart, in_id, out_id=None):
        &#34;&#34;&#34;
        Create a group with N particles inside a specified object and optionally outside another.

        Parameters:
            id (str): Unique identifier for the particle group.
            npart (int): Number of particles to create.
            in_id (str): Identifier of the object particles should be inside.
            out_id (str, optional): Identifier of the object particles should be outside.
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        obj = Group()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = GROUP
        obj.on_id = &#34;&#34;
        obj.npart = npart
        obj.xyz = []
    
        in_obj = self.objs[self.ids[in_id]]
        if out_id:
            out_obj = self.objs[self.ids[out_id]]
    
        # Pre-process SURFACE objects to bin their triangles for faster searching
        if in_obj.style == SURFACE:
            in_obj.inside_prep()
        if out_id and out_obj.style == SURFACE:
            out_obj.inside_prep()
    
        # Bounding box for generating points
        xlo, ylo, zlo, xhi, yhi, zhi = in_obj.bbox()
        xsize = xhi - xlo
        ysize = yhi - ylo
        zsize = zhi - zlo
    
        # Generate particles until have enough that satisfy in/out constraints
        count = attempt = 0
        while count &lt; npart:
            attempt += 1
            x = xlo + self.random() * xsize
            y = ylo + self.random() * ysize
            z = zlo + self.random() * zsize
            if not in_obj.inside(x, y, z):
                continue
            if out_id and out_obj.inside(x, y, z):
                continue
            obj.xyz.append([x, y, z])
            count += 1
    
        obj.center()
        print(f&#34;Created {count} particles in {attempt} attempts&#34;)
    
    # --------------------------------------------------------------------
    # Create a Group Object with N 2D Particles on a Surface
    
    def part2d(self, id, npart, on_id):
        &#34;&#34;&#34;
        Create a group with N 2D particles on a specified surface.

        Parameters:
            id (str): Unique identifier for the 2D particle group.
            npart (int): Number of particles to create.
            on_id (str): Identifier of the object particles should be on.
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        obj = Group()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = GROUP
        obj.on_id = on_id
        obj.npart = npart
        obj.xyz = []
    
        on_obj = self.objs[self.ids[on_id]]
        if on_obj.style not in [SURFACE, REGION, UNION]:
            raise Exception(&#34;Illegal ID to place particles on&#34;)
        totalarea = on_obj.area()
        
        for _ in range(npart):
            area = self.random() * totalarea
            pt, norm = on_obj.loc2d(area, self.random)
            obj.xyz.append(pt)
        
        obj.center()
        print(f&#34;Created {npart} particles on area of {totalarea}&#34;)
    
    # --------------------------------------------------------------------
    # Create a 3D Array of Particles
    
    def partarray(self, id, nx, ny, nz, x, y, z, dx, dy, dz):
        &#34;&#34;&#34;
        Create a 3D grid of particles.

        Parameters:
            id (str): Unique identifier for the particle array.
            nx, ny, nz (int): Number of particles in x, y, z directions.
            x, y, z (float): Starting coordinates.
            dx, dy, dz (float): Spacing between particles.
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        obj = Group()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = GROUP
        obj.on_id = &#34;&#34;
        obj.npart = nx * ny * nz
        obj.xyz = []
    
        for k in range(nz):
            znew = z + k * dz
            for j in range(ny):
                ynew = y + j * dy
                for i in range(nx):
                    xnew = x + i * dx
                    obj.xyz.append([xnew, ynew, znew])
                    
        obj.center()
        print(f&#34;Created {nx * ny * nz} particles&#34;)
    
    # --------------------------------------------------------------------
    # Create a Ring of Particles
    
    def partring(self, id, n, x, y, z, r, axis):
        &#34;&#34;&#34;
        Create a ring of N particles.

        Parameters:
            id (str): Unique identifier for the particle ring.
            n (int): Number of particles in the ring.
            x, y, z (float): Center coordinates of the ring.
            r (float): Radius of the ring.
            axis (str): Axis of the ring (&#39;x&#39;, &#39;y&#39;, or &#39;z&#39;).
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        obj = Group()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = GROUP
        obj.on_id = &#34;&#34;
        obj.npart = n
        obj.xyz = []
    
        deltheta = 2.0 * pi / n
        for i in range(n):
            theta = i * deltheta
            if axis == &#39;x&#39;:
                xnew = x
                ynew = y + r * cos(theta)
                znew = z + r * sin(theta)
            elif axis == &#39;y&#39;:
                xnew = x + r * cos(theta)
                ynew = y
                znew = z + r * sin(theta)
            elif axis == &#39;z&#39;:
                xnew = x + r * cos(theta)
                ynew = y + r * sin(theta)
                znew = z
            else:
                raise Exception(&#34;Invalid axis for partring()&#34;)
            obj.xyz.append([xnew, ynew, znew])
                
        obj.center()
        print(f&#34;Created {n} particles&#34;)
    
    # --------------------------------------------------------------------
    # Change Surface Assignment for a 2D Group of Particles
    
    def partsurf(self, id, on_id):
        &#34;&#34;&#34;
        Change the surface assignment for a 2D group of particles.

        Parameters:
            id (str): Identifier of the particle group.
            on_id (str): New surface identifier.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style != GROUP:
            raise Exception(&#34;Must use particle group with partsurf()&#34;)
        if not obj.on_id:
            raise Exception(&#34;Must use partsurf() with 2d particles&#34;)
        obj.on_id = on_id
    
    # --------------------------------------------------------------------
    # Set Random Number Seed
    
    def seed(self, new_seed):
        &#34;&#34;&#34;
        Set the random number generator seed.

        Parameters:
            new_seed (int): New seed value.
        &#34;&#34;&#34;
        self.random.seed = new_seed
    
    # --------------------------------------------------------------------
    # Pick a Random Point on Surface of Object
    
    def random(self, id):
        &#34;&#34;&#34;
        Pick a random point on the surface of the specified object.

        Parameters:
            id (str): Identifier of the surface or region.

        Returns:
            tuple: (point [x, y, z], normal vector [nx, ny, nz])
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style not in [SURFACE, REGION]:
            raise Exception(&#34;Must use surf or region with random()&#34;)
    
        totalarea = obj.area()
        area = self.random() * totalarea
        pt, norm = obj.loc2d(area, self.random)
        return pt, norm
    
    # --------------------------------------------------------------------
    # Project Particles to Surface of Another Object
    
    def project(self, id, id2, dx, dy, dz, EPS, flag=None):
        &#34;&#34;&#34;
        Project particles in group ID to the surface of object ID2.

        Parameters:
            id (str): Identifier of the particle group.
            id2 (str): Identifier of the target surface or region.
            dx, dy, dz (float): Direction components for projection.
            EPS (float): Epsilon value for proximity.
            flag (bool, optional): If True, direction is from particle to (dx, dy, dz).
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style != GROUP:
            raise Exception(&#34;Must use particle group as 1st obj of project()&#34;)
        obj_on = self.objs[self.ids[id2]]
        if obj_on.style not in [SURFACE, REGION]:
            raise Exception(&#34;Must use surf or region as 2nd obj of project()&#34;)
    
        # Pre-process SURFACE to bin its triangles for faster searching
        if obj_on.style == SURFACE:
            obj_on.inside_prep()
    
        # For each particle, move it in dir from current location
        # Move along dir until get within EPS of surf
        # factor = multiply bracketing distance by this amount each iteration
        # maxscale = max multiple of dir vector to bracket in each direction
    
        factor = 2
        maxscale = 10.0
    
        for i in range(obj.npart):
            x, y, z_coord = obj.xyz[i]
            if flag:
                dir_vector = [dx - x, dy - y, dz - z_coord]
            else:
                dir_vector = [dx, dy, dz]
            normalize(dir_vector)
            
            # Start = inside/outside at starting point
            # Stop = inside/outside at bracketing point
            start = obj_on.inside(x, y, z_coord)
            stop = 0 if start else 1
    
            # Iterate to find bracketing point or until scale dist &gt; maxdist
            # Bracket point = xyz +/- scale*dir
            # Multiply scale by factor each iteration
    
            scale = EPS
            bracket = start
            while scale &lt; maxscale:
                xnew = x + scale * dir_vector[0]
                ynew = y + scale * dir_vector[1]
                znew = z_coord + scale * dir_vector[2]
                bracket = obj_on.inside(xnew, ynew, znew)
                if bracket == stop:
                    break
                xnew_neg = x - scale * dir_vector[0]
                ynew_neg = y - scale * dir_vector[1]
                znew_neg = z_coord - scale * dir_vector[2]
                bracket = obj_on.inside(xnew_neg, ynew_neg, znew_neg)
                if bracket == stop:
                    xnew, ynew, znew = xnew_neg, ynew_neg, znew_neg
                    break
                scale *= factor
    
            if bracket == start:
                raise Exception(f&#34;Could not find bracket point for particle {i}&#34;)
    
            # Bisection search to zoom in to within EPS of surface
            # Separation = distance between 2 points
            delx = xnew - x
            dely = ynew - y
            delz = znew - z_coord
            separation = sqrt(delx**2 + dely**2 + delz**2)
            while separation &gt; EPS:
                xmid = 0.5 * (x + xnew)
                ymid = 0.5 * (y + ynew)
                zmid = 0.5 * (z_coord + znew)
                value = obj_on.inside(xmid, ymid, zmid)
                if value == start:
                    x, y, z_coord = xmid, ymid, zmid
                else:
                    xnew, ynew, znew = xmid, ymid, zmid
                delx = xnew - x
                dely = ynew - y
                delz = znew - z_coord
                separation = sqrt(delx**2 + dely**2 + delz**2)
    
            obj.xyz[i][0] = x
            obj.xyz[i][1] = y
            obj.xyz[i][2] = z_coord
    
        obj.on_id = id2
        obj.center()
    
    # --------------------------------------------------------------------
    # Set Center Point of an Object
    
    def center(self, id, x, y, z):
        &#34;&#34;&#34;
        Set the center point of an object.

        Parameters:
            id (str): Identifier of the object.
            x, y, z (float): New center coordinates.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style not in [SURFACE, GROUP]:
            raise Exception(&#34;Can only use center() on a surface or group object&#34;)
        obj.center(x, y, z)
    
    # --------------------------------------------------------------------
    # Translate an Object by dx, dy, dz
    
    def trans(self, id, dx, dy, dz):
        &#34;&#34;&#34;
        Translate an object by a displacement.

        Parameters:
            id (str): Identifier of the object.
            dx, dy, dz (float): Displacement along x, y, z axes.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style not in [SURFACE, GROUP]:
            raise Exception(&#34;Can only use trans() on a surface or group object&#34;)
        obj.xc += dx
        obj.yc += dy
        obj.zc += dz
    
        # Apply translation to each vertex or particle coordinate
        if obj.style == SURFACE:
            for vert in obj.vertices:
                vert[0] += dx
                vert[1] += dy
                vert[2] += dz
        elif obj.style == GROUP:
            for particle in obj.xyz:
                particle[0] += dx
                particle[1] += dy
                particle[2] += dz
    
    # --------------------------------------------------------------------
    # Rotate an Object to Align Current Axes with New Axes
    
    def rotate(self, id, axis1, i1, j1, k1, axis2, i2, j2, k2):
        &#34;&#34;&#34;
        Rotate an object so that its current axes align with new ones.

        Parameters:
            id (str): Identifier of the object.
            axis1 (str): First axis to rotate (&#39;x&#39;, &#39;y&#39;, &#39;z&#39;).
            i1, j1, k1 (float): Direction cosines for the first new axis.
            axis2 (str): Second axis to rotate (&#39;x&#39;, &#39;y&#39;, &#39;z&#39;).
            i2, j2, k2 (float): Direction cosines for the second new axis.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style not in [SURFACE, GROUP]:
            raise Exception(&#34;Can only use rotate() on a surface or group object&#34;)
    
        # Create new axes
        new_axes = {&#39;x&#39;: None, &#39;y&#39;: None, &#39;z&#39;: None}
        if axis1 in new_axes:
            new_axes[axis1] = [i1, j1, k1]
        else:
            raise Exception(&#34;Invalid axis for rotate()&#34;)
        
        if axis2 in new_axes:
            new_axes[axis2] = [i2, j2, k2]
        else:
            raise Exception(&#34;Invalid axis for rotate()&#34;)
    
        # Infer the third axis
        axes = [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]
        missing_axis = next((ax for ax in axes if new_axes[ax] is None), None)
        if missing_axis is None:
            raise Exception(&#34;All three axes are already defined&#34;)
        other_axes = [ax for ax in axes if ax != missing_axis]
        new_axes[missing_axis] = cross(new_axes[other_axes[0]], new_axes[other_axes[1]])
        normalize(new_axes[missing_axis])
    
        # Orthonormalize the axes
        normalize(new_axes[&#39;x&#39;])
        normalize(new_axes[&#39;y&#39;])
        normalize(new_axes[&#39;z&#39;])
    
        # Apply rotation matrix to each vertex or particle coordinate
        if obj.style == SURFACE:
            for vert in obj.vertices:
                x = vert[0] - obj.xc
                y = vert[1] - obj.yc
                z = vert[2] - obj.zc
                xn = new_axes[&#39;x&#39;][0]*x + new_axes[&#39;x&#39;][1]*y + new_axes[&#39;x&#39;][2]*z
                yn = new_axes[&#39;y&#39;][0]*x + new_axes[&#39;y&#39;][1]*y + new_axes[&#39;y&#39;][2]*z
                zn = new_axes[&#39;z&#39;][0]*x + new_axes[&#39;z&#39;][1]*y + new_axes[&#39;z&#39;][2]*z
                vert[0] = xn + obj.xc
                vert[1] = yn + obj.yc
                vert[2] = zn + obj.zc
        elif obj.style == GROUP:
            for particle in obj.xyz:
                x = particle[0] - obj.xc
                y = particle[1] - obj.yc
                z = particle[2] - obj.zc
                xn = new_axes[&#39;x&#39;][0]*x + new_axes[&#39;x&#39;][1]*y + new_axes[&#39;x&#39;][2]*z
                yn = new_axes[&#39;y&#39;][0]*x + new_axes[&#39;y&#39;][1]*y + new_axes[&#39;y&#39;][2]*z
                zn = new_axes[&#39;z&#39;][0]*x + new_axes[&#39;z&#39;][1]*y + new_axes[&#39;z&#39;][2]*z
                particle[0] = xn + obj.xc
                particle[1] = yn + obj.yc
                particle[2] = zn + obj.zc
    
    # --------------------------------------------------------------------
    # Scale an Object by sx, sy, sz Factors
    
    def scale(self, id, sx, sy, sz):
        &#34;&#34;&#34;
        Scale an object by specified factors along each axis.

        Parameters:
            id (str): Identifier of the object.
            sx, sy, sz (float): Scaling factors along x, y, z axes.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style not in [SURFACE, GROUP]:
            raise Exception(&#34;Can only use scale() on a surface or group object&#34;)
        if obj.style == SURFACE:
            for vert in obj.vertices:
                vert[0] = obj.xc + sx * (vert[0] - obj.xc)
                vert[1] = obj.yc + sy * (vert[1] - obj.yc)
                vert[2] = obj.zc + sz * (vert[2] - obj.zc)
        elif obj.style == GROUP:
            for particle in obj.xyz:
                particle[0] = obj.xc + sx * (particle[0] - obj.xc)
                particle[1] = obj.yc + sy * (particle[1] - obj.yc)
                particle[2] = obj.zc + sz * (particle[2] - obj.zc)
    
    # --------------------------------------------------------------------
    # Create a Union Object from Other Objects
    
    def union(self, id, *list_ids):
        &#34;&#34;&#34;
        Create a union object from a list of other objects.

        Parameters:
            id (str): Unique identifier for the union.
            *list_ids: Identifiers of objects to include in the union.
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Union(self.ids, self.objs, *list_ids)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = UNION
    
    # --------------------------------------------------------------------
    # Join Objects to Form a New Object
    
    def join(self, id, *list_ids):
        &#34;&#34;&#34;
        Join multiple objects of the same style into a new object.

        Parameters:
            id (str): Unique identifier for the new joined object.
            *list_ids: Identifiers of objects to join.
        &#34;&#34;&#34;
        if not list_ids:
            raise Exception(&#34;No objects provided to join&#34;)
        style = self.objs[self.ids[list_ids[0]]].style
        if style == GROUP:
            obj = Group()
        elif style == SURFACE:
            obj = Surface()
        elif style == LINE:
            obj = Line()
        else:
            raise Exception(&#34;Cannot perform join on these object styles&#34;)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = style
    
        if style == GROUP:
            obj.on_id = self.objs[self.ids[list_ids[0]]].on_id
            obj.npart = 0
            obj.xyz = []
        elif style == SURFACE:
            obj.nvert = obj.ntri = 0
            obj.vertices = []
            obj.triangles = []
            obj.connections = []
        elif style == LINE:
            obj.nline = 0
            obj.pairs = []
            
        for obj_id in list_ids:
            o = self.objs[self.ids[obj_id]]
            if o.style != style:
                raise Exception(&#34;All joined objects must be of same style&#34;)
    
            # Force deep copy of particle coordinates
            if style == GROUP:
                if o.on_id != obj.on_id:
                    raise Exception(&#34;Particle group surfaces do not match&#34;)
                for xyz in o.xyz:
                    obj.xyz.append(xyz[:])
                obj.npart += o.npart
                obj.center()
                
            # Force deep copy of triangle vertices and indices
            elif style == SURFACE:
                for vert in o.vertices:
                    obj.vertices.append(vert[:])
                for tri in o.triangles:
                    obj.triangles.append([tri[0]+obj.nvert, tri[1]+obj.nvert, tri[2]+obj.nvert])
                for conn in o.connections:
                    new_conn = conn[:]
                    if new_conn[0]:
                        new_conn[0] += obj.ntri
                    if new_conn[2]:
                        new_conn[2] += obj.ntri
                    if new_conn[4]:
                        new_conn[4] += obj.ntri
                    obj.connections.append(new_conn)
                obj.nvert += o.nvert
                obj.ntri += o.ntri
                obj.center()
    
            # Force deep copy of line point pairs
            elif style == LINE:
                obj.pairs += o.pairs[:]
                obj.nline += o.nline
    
    # --------------------------------------------------------------------
    # Delete Objects from the cdata
    
    def delete(self, *list_ids):
        &#34;&#34;&#34;
        Delete objects from the cdata.

        Parameters:
            *list_ids: Identifiers of objects to delete.
        &#34;&#34;&#34;
        for id in list_ids:
            if id not in self.ids:
                raise Exception(f&#34;ID {id} does not exist&#34;)
            i = self.ids[id]
            del self.ids[id]
            del self.objs[i]
            # Update indices in self.ids
            for key in self.ids:
                if self.ids[key] &gt; i:
                    self.ids[key] -= 1
    
    # --------------------------------------------------------------------
    # Rename an Object
    
    def rename(self, id_old, id_new):
        &#34;&#34;&#34;
        Rename an object.

        Parameters:
            id_old (str): Current identifier of the object.
            id_new (str): New identifier for the object.
        &#34;&#34;&#34;
        if id_new in self.ids:
            raise Exception(f&#34;ID {id_new} is already in use&#34;)
        if id_old not in self.ids:
            raise Exception(f&#34;ID {id_old} does not exist&#34;)
        i = self.ids[id_old]
        self.ids[id_new] = i
        self.objs[i].id = id_new
        del self.ids[id_old]
    
    # --------------------------------------------------------------------
    # Create a Deep Copy of an Object with a New ID
    
    def copy(self, id_old, id_new):
        &#34;&#34;&#34;
        Create a deep copy of an object with a new identifier.

        Parameters:
            id_old (str): Identifier of the object to copy.
            id_new (str): New identifier for the copied object.
        &#34;&#34;&#34;
        if id_new in self.ids:
            raise Exception(f&#34;ID {id_new} is already in use&#34;)
        if id_old not in self.ids:
            raise Exception(f&#34;ID {id_old} does not exist&#34;)
        obj = deepcopy(self.objs[self.ids[id_old]])
        obj.select = 1
        self.ids[id_new] = len(self.objs)
        self.objs.append(obj)
        obj.id = id_new
    
    # --------------------------------------------------------------------
    # Select Objects
    
    def select(self, *list_ids):
        &#34;&#34;&#34;
        Select one or more objects.

        Parameters:
            *list_ids: Identifiers of objects to select. If empty, selects all.
        &#34;&#34;&#34;
        if not list_ids:
            list_ids = self.ids.keys()
        for id in list_ids:
            if id not in self.ids:
                raise Exception(f&#34;ID {id} does not exist&#34;)
            obj = self.objs[self.ids[id]]
            obj.select = 1
    
    # --------------------------------------------------------------------
    # Unselect Objects
    
    def unselect(self, *list_ids):
        &#34;&#34;&#34;
        Unselect one or more objects.

        Parameters:
            *list_ids: Identifiers of objects to unselect. If empty, unselects all.
        &#34;&#34;&#34;
        if not list_ids:
            list_ids = self.ids.keys()
        for id in list_ids:
            if id not in self.ids:
                raise Exception(f&#34;ID {id} does not exist&#34;)
            obj = self.objs[self.ids[id]]
            obj.select = 0
    
    # --------------------------------------------------------------------
    # Write Objects to ChemCell Data File
    
    def write(self, file, *list_ids):
        &#34;&#34;&#34;
        Write selected objects to a ChemCell data file.

        Parameters:
            file (str): Filename to write to.
            *list_ids: Identifiers of objects to write. If empty, writes all selected.
        &#34;&#34;&#34;
        if not list_ids:
            vlist = list(range(len(self.objs)))
        else:
            vlist = []
            for id in list_ids:
                if id not in self.ids:
                    raise Exception(f&#34;ID {id} does not exist&#34;)
                vlist.append(self.ids[id])
    
        with open(file, &#39;w&#39;) as fp:
            self.filewrite(fp, vlist)
    
    # --------------------------------------------------------------------
    # Append Objects to an Existing ChemCell Data File
    
    def append(self, file, *list_ids):
        &#34;&#34;&#34;
        Append selected objects to an existing ChemCell data file.

        Parameters:
            file (str): Filename to append to.
            *list_ids: Identifiers of objects to append. If empty, appends all selected.
        &#34;&#34;&#34;
        if not list_ids:
            vlist = list(range(len(self.objs)))
        else:
            vlist = []
            for id in list_ids:
                if id not in self.ids:
                    raise Exception(f&#34;ID {id} does not exist&#34;)
                vlist.append(self.ids[id])
    
        with open(file, &#39;a&#39;) as fp:
            self.filewrite(fp, vlist)
    
    # --------------------------------------------------------------------
    # Write Objects to an Opened Data File
    
    def filewrite(self, fp, vlist):
        &#34;&#34;&#34;
        Write objects to an already opened data file.

        Parameters:
            fp (file object): Opened file object to write to.
            vlist (list): List of object indices to write.
        &#34;&#34;&#34;
        for index in vlist:
            obj = self.objs[index]
            if not obj.select:
                continue
            if obj.style == GROUP:
                if not obj.on_id:
                    print(f&#34;particles {obj.id} {obj.npart}&#34;, file=fp)
                else:
                    print(f&#34;particles {obj.id} {obj.npart} {obj.on_id}&#34;, file=fp)
                print(file=fp)
                for i, xyz in enumerate(obj.xyz, start=1):
                    print(f&#34;{i} {xyz[0]} {xyz[1]} {xyz[2]}&#34;, file=fp)
                print(file=fp)
            if obj.style == SURFACE:
                print(f&#34;triangles {obj.id} {obj.nvert} {obj.ntri}&#34;, file=fp)
                print(file=fp)
                for i, vert in enumerate(obj.vertices, start=1):
                    print(f&#34;{i} {vert[0]} {vert[1]} {vert[2]}&#34;, file=fp)
                for i, tri in enumerate(obj.triangles, start=1):
                    print(f&#34;{i} {tri[0]} {tri[1]} {tri[2]}&#34;, file=fp)
                for i, conn in enumerate(obj.connections, start=1):
                    print(f&#34;{i} {conn[0]} {conn[1]} {conn[2]} {conn[3]} {conn[4]} {conn[5]}&#34;, file=fp)
            if obj.style == REGION:
                print(f&#34;region {obj.command()}&#34;, file=fp)
    
    # --------------------------------------------------------------------
    # Iterator Method for Other Tools
    
    def iterator(self, flag):
        &#34;&#34;&#34;
        Iterator method compatible with equivalent dump calls.

        Parameters:
            flag (int): 0 for first call, 1 for subsequent calls.

        Returns:
            tuple: (index, time, flag)
        &#34;&#34;&#34;
        if flag == 0:
            return (0, 0, 1)
        return (0, 0, -1)
    
    # --------------------------------------------------------------------
    # Visualization Method
    
    def viz(self, isnap):
        &#34;&#34;&#34;
        Return list of atoms, bonds, tris, and lines for visualization.

        Parameters:
            isnap (int): Snapshot index. Must be 0 for cdata.

        Returns:
            tuple: (time, box, atoms, bonds, tris, lines)
        &#34;&#34;&#34;
        if isnap:
            raise Exception(&#34;cannot call cdata.viz() with isnap != 0&#34;)
        
        # Create atom list from sum of all particle groups
        # id = running count
        # type = running type of particle group
    
        id_count = itype = 0
        atoms = []
        for obj in self.objs:
            if obj.style != GROUP:
                continue
            if not obj.select:
                continue
            itype += 1
            for xyz in obj.xyz:
                id_count += 1
                atoms.append([id_count, itype, xyz[0], xyz[1], xyz[2]])
    
        # No bonds
        bonds = []
    
        # Create triangle list from sum of all surfaces and regions
        # id = running count
        # type = type of set of tris
    
        id_count = itype = 0
        tris = []
        for obj in self.objs:
            if obj.style not in [SURFACE, REGION]:
                continue
            if not obj.select:
                continue
            if obj.style == REGION:
                obj.triangulate()
            itype += 1
            for tri in obj.triangles:
                v1 = obj.vertices[tri[0]-1]
                v2 = obj.vertices[tri[1]-1]
                v3 = obj.vertices[tri[2]-1]
                list_vertices = v1 + v2 + v3
                n = normal(list_vertices[0:3], list_vertices[3:6], list_vertices[6:9])
                id_count += 1
                tris.append([id_count, itype] + list_vertices + n)
    
        # Create line list from sum of all line objects
        id_count = itype = 0
        lines = []
        for obj in self.objs:
            if obj.style != LINE:
                continue
            if not obj.select:
                continue
            itype += 1
            for pair in obj.pairs:
                id_count += 1
                lines.append([id_count, itype] + pair)
        
        return (0, self.bbox(), atoms, bonds, tris, lines)
    
    # --------------------------------------------------------------------
    # Find Time Method (Not Applicable for cdata)
    
    def findtime(self, n):
        &#34;&#34;&#34;
        Find the index of a given timestep.

        Parameters:
            n (int): The timestep to find.

        Returns:
            int: The index of the timestep.

        Raises:
            Exception: Always, since cdata does not support multiple timesteps.
        &#34;&#34;&#34;
        if n == 0:
            return 0
        raise Exception(f&#34;no step {n} exists&#34;)
    
    # --------------------------------------------------------------------
    # Return Bounding Box that Encloses All Selected Objects
    
    def maxbox(self):
        &#34;&#34;&#34;
        Return the bounding box that encloses all selected objects.

        Returns:
            tuple: (xlo, ylo, zlo, xhi, yhi, zhi)
        &#34;&#34;&#34;
        return self.bbox()
    
    # --------------------------------------------------------------------
    # Return Bounding Box that Encloses All Selected Objects
    
    def bbox(self):
        &#34;&#34;&#34;
        Compute the bounding box that encloses all selected objects.

        Returns:
            tuple: (xlo, ylo, zlo, xhi, yhi, zhi)
        &#34;&#34;&#34;
        xlo = ylo = zlo = float(&#39;inf&#39;)
        xhi = yhi = zhi = float(&#39;-inf&#39;)
        for obj in self.objs:
            if not obj.select:
                continue
            xxlo, yylo, zzlo, xxhi, yyhi, zzhi = obj.bbox()
            xlo = min(xxlo, xlo)
            ylo = min(yylo, ylo)
            zlo = min(zzlo, zlo)
            xhi = max(xxhi, xhi)
            yhi = max(yyhi, yhi)
            zhi = max(zzhi, zhi)
    
        return (xlo, ylo, zlo, xhi, yhi, zhi)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cdata3.box_triangulate"><code class="name flex">
<span>def <span class="ident">box_triangulate</span></span>(<span>q1, q2, q3)</span>
</code></dt>
<dd>
<div class="desc"><p>Triangulate a unit box from (0,0,0) to (1,1,1) with spacings q1, q2, q3.
Return a list of vertices and triangles. Triangles are oriented outward.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def box_triangulate(q1, q2, q3):
    &#34;&#34;&#34;
    Triangulate a unit box from (0,0,0) to (1,1,1) with spacings q1, q2, q3.
    Return a list of vertices and triangles. Triangles are oriented outward.
    &#34;&#34;&#34;
    dx = 1.0/q1 if q1 else 1.0
    dy = 1.0/q2 if q2 else 1.0
    dz = 1.0/q3 if q3 else 1.0
    
    vdict = {}
    vertices = []
    triangles = []
    
    # Triangulate faces in x=0, x=1, y=0, y=1, z=0, z=1, etc.
    # This method can be quite extensive; for clarity, partial examples
    # are included. Adjust logic as needed to cover all box faces.
    
    # Face x=0
    for j in range(q2):
        for k in range(q3):
            v1 = (0,      j*dy,     k*dz)
            v2 = (0, (j+1)*dy,     k*dz)
            v3 = (0, (j+1)*dy, (k+1)*dz)
            v4 = (0,      j*dy, (k+1)*dz)
            
            iv1 = vertex(list(v1), vertices, vdict)
            iv2 = vertex(list(v2), vertices, vdict)
            iv3 = vertex(list(v3), vertices, vdict)
            iv4 = vertex(list(v4), vertices, vdict)
            
            # Two triangles per cell
            triangles.append([iv1+1, iv3+1, iv2+1])
            triangles.append([iv1+1, iv4+1, iv3+1])
    
    # Similarly handle x=1, y=0, y=1, z=0, z=1 faces...
    # For brevity, only partial face coverage is shown here.
    # Extend similarly if a full triangulation is required.
    
    return vertices, triangles</code></pre>
</details>
</dd>
<dt id="cdata3.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>nvert, ntri, triangles)</span>
</code></dt>
<dd>
<div class="desc"><p>Create connections between triangles in a triangulated surface.
Each triangle has 3 vertices. Return a list of connections for each tri.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(nvert, ntri, triangles):
    &#34;&#34;&#34;
    Create connections between triangles in a triangulated surface.
    Each triangle has 3 vertices. Return a list of connections for each tri.
    &#34;&#34;&#34;
    # v2tri[v] = list of triangles that vertex v is a member of
    v2tri = [[] for _ in range(nvert)]
    for i in range(ntri):
        for vert in triangles[i]:
            v2tri[vert-1].append(i)
    
    connections = []
    for i in range(ntri):
        connect_tri = [0]*6  # [tri1, edge1, tri2, edge2, tri3, edge3]
        v = triangles[i]
        
        # For edges (v[0]-v[1]), (v[1]-v[2]), (v[2]-v[0])
        edges = [
            (v[0], v[1]),
            (v[1], v[2]),
            (v[2], v[0])
        ]
        
        for edge_idx, (startv, endv) in enumerate(edges):
            # Triangles sharing startv
            for itri in v2tri[startv-1]:
                if itri == i:
                    continue
                if endv in triangles[itri]:
                    connect_tri[2*edge_idx] = itri+1
                    # Figure out which edge in itri
                    # (this is approximate; advanced logic may be required)
                    other_tri = triangles[itri]
                    # Attempt to find local edge
                    # For simplicity, store edge=1 if other_tri&#39;s first edge,
                    # edge=2 if second, edge=3 if third, etc.
                    # This might need deeper logic if the &#39;edge index&#39; is critical.
                    connect_tri[2*edge_idx + 1] = 1  # Simplify for now
                    break
        
        connections.append(connect_tri)
    return connections</code></pre>
</details>
</dd>
<dt id="cdata3.cross"><code class="name flex">
<span>def <span class="ident">cross</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the cross product of vectors a and b (each 3D).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross(a, b):
    &#34;&#34;&#34;
    Compute the cross product of vectors a and b (each 3D).
    &#34;&#34;&#34;
    return [
        a[1]*b[2] - a[2]*b[1],
        a[2]*b[0] - a[0]*b[2],
        a[0]*b[1] - a[1]*b[0]
    ]</code></pre>
</details>
</dd>
<dt id="cdata3.normal"><code class="name flex">
<span>def <span class="ident">normal</span></span>(<span>x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the normal vector for a triangle with vertices x, y, z.
Each vertex is a 3D coordinate [x, y, z].</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normal(x, y, z):
    &#34;&#34;&#34;
    Compute the normal vector for a triangle with vertices x, y, z.
    Each vertex is a 3D coordinate [x, y, z].
    &#34;&#34;&#34;
    v1 = [y[i] - x[i] for i in range(3)]
    v2 = [z[i] - y[i] for i in range(3)]
    n = cross(v1, v2)
    normalize(n)
    return n</code></pre>
</details>
</dd>
<dt id="cdata3.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>a)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize vector a in-place to unit length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(a):
    &#34;&#34;&#34;
    Normalize vector a in-place to unit length.
    &#34;&#34;&#34;
    length = sqrt(a[0]**2 + a[1]**2 + a[2]**2)
    if length != 0.0:
        a[0] /= length
        a[1] /= length
        a[2] /= length</code></pre>
</details>
</dd>
<dt id="cdata3.vertex"><code class="name flex">
<span>def <span class="ident">vertex</span></span>(<span>v, vertices, vdict)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a vertex to the vertices list if not already present.
Return the index of the vertex in the vertices list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vertex(v, vertices, vdict):
    &#34;&#34;&#34;
    Add a vertex to the vertices list if not already present.
    Return the index of the vertex in the vertices list.
    &#34;&#34;&#34;
    vtup = tuple(v)
    if vtup in vdict:
        return vdict[vtup]
    idx = len(vertices)
    vertices.append(v)
    vdict[vtup] = idx
    return idx</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cdata3.Box"><code class="flex name class">
<span>class <span class="ident">Box</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Box:
    def __init__(self, *args):
        self.select = 0
        self.style = REGION
        self.id = &#34;&#34;
        self.substyle = BOX
        self.xlo = float(args[0])
        self.ylo = float(args[1])
        self.zlo = float(args[2])
        self.xhi = float(args[3])
        self.yhi = float(args[4])
        self.zhi = float(args[5])
        # Default triangulation quality
        self.q1 = self.q2 = self.q3 = 1.0

    def bbox(self):
        return (self.xlo, self.ylo, self.zlo, self.xhi, self.yhi, self.zhi)

    def inside(self, x, y, z):
        if x &lt; self.xlo or x &gt; self.xhi: return 0
        if y &lt; self.ylo or y &gt; self.yhi: return 0
        if z &lt; self.zlo or z &gt; self.zhi: return 0
        return 1

    def triangulate(self):
        vertices, triangles = box_triangulate(int(self.q1),
                                              int(self.q2),
                                              int(self.q3))
        self.nvert = len(vertices)
        self.ntri = len(triangles)
        self.vertices = []
        for i in range(self.nvert):
            v1 = self.xlo + vertices[i][0]*(self.xhi - self.xlo)
            v2 = self.ylo + vertices[i][1]*(self.yhi - self.ylo)
            v3 = self.zlo + vertices[i][2]*(self.zhi - self.zlo)
            self.vertices.append([v1, v2, v3])
        self.triangles = []
        for tri in triangles:
            self.triangles.append([tri[0], tri[1], tri[2]])
        self.connections = connect(self.nvert, self.ntri, self.triangles)

    def area(self):
        xsize = self.xhi - self.xlo
        ysize = self.yhi - self.ylo
        zsize = self.zhi - self.zlo
        # area of all 6 faces
        faces = [
            ysize*zsize,
            ysize*zsize,
            xsize*zsize,
            xsize*zsize,
            xsize*ysize,
            xsize*ysize,
        ]
        # Store cumulative if desired, but we’ll just return sum
        return sum(faces)

    def loc2d(self, area, random_fn):
        &#34;&#34;&#34;
        Return a random point on the surface, ignoring partial sums for now.
        This is a simplified approach. Adjust to handle &#39;area&#39; fraction properly.
        &#34;&#34;&#34;
        # For demonstration, pick one face (e.g., x=low)
        r1, r2 = random_fn(), random_fn()
        xsize = self.xhi - self.xlo
        ysize = self.yhi - self.ylo
        zsize = self.zhi - self.zlo
        # Suppose we pick face x=low
        return ([self.xlo,
                 self.ylo + r1*ysize,
                 self.zlo + r2*zsize],
                [-1.0, 0.0, 0.0])

    def command(self):
        return f&#34;{self.id} box {self.xlo} {self.ylo} {self.zlo} {self.xhi} {self.yhi} {self.zhi}&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cdata3.Box.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area(self):
    xsize = self.xhi - self.xlo
    ysize = self.yhi - self.ylo
    zsize = self.zhi - self.zlo
    # area of all 6 faces
    faces = [
        ysize*zsize,
        ysize*zsize,
        xsize*zsize,
        xsize*zsize,
        xsize*ysize,
        xsize*ysize,
    ]
    # Store cumulative if desired, but we’ll just return sum
    return sum(faces)</code></pre>
</details>
</dd>
<dt id="cdata3.Box.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self):
    return (self.xlo, self.ylo, self.zlo, self.xhi, self.yhi, self.zhi)</code></pre>
</details>
</dd>
<dt id="cdata3.Box.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(self):
    return f&#34;{self.id} box {self.xlo} {self.ylo} {self.zlo} {self.xhi} {self.yhi} {self.zhi}&#34;</code></pre>
</details>
</dd>
<dt id="cdata3.Box.inside"><code class="name flex">
<span>def <span class="ident">inside</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inside(self, x, y, z):
    if x &lt; self.xlo or x &gt; self.xhi: return 0
    if y &lt; self.ylo or y &gt; self.yhi: return 0
    if z &lt; self.zlo or z &gt; self.zhi: return 0
    return 1</code></pre>
</details>
</dd>
<dt id="cdata3.Box.loc2d"><code class="name flex">
<span>def <span class="ident">loc2d</span></span>(<span>self, area, random_fn)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a random point on the surface, ignoring partial sums for now.
This is a simplified approach. Adjust to handle 'area' fraction properly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loc2d(self, area, random_fn):
    &#34;&#34;&#34;
    Return a random point on the surface, ignoring partial sums for now.
    This is a simplified approach. Adjust to handle &#39;area&#39; fraction properly.
    &#34;&#34;&#34;
    # For demonstration, pick one face (e.g., x=low)
    r1, r2 = random_fn(), random_fn()
    xsize = self.xhi - self.xlo
    ysize = self.yhi - self.ylo
    zsize = self.zhi - self.zlo
    # Suppose we pick face x=low
    return ([self.xlo,
             self.ylo + r1*ysize,
             self.zlo + r2*zsize],
            [-1.0, 0.0, 0.0])</code></pre>
</details>
</dd>
<dt id="cdata3.Box.triangulate"><code class="name flex">
<span>def <span class="ident">triangulate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangulate(self):
    vertices, triangles = box_triangulate(int(self.q1),
                                          int(self.q2),
                                          int(self.q3))
    self.nvert = len(vertices)
    self.ntri = len(triangles)
    self.vertices = []
    for i in range(self.nvert):
        v1 = self.xlo + vertices[i][0]*(self.xhi - self.xlo)
        v2 = self.ylo + vertices[i][1]*(self.yhi - self.ylo)
        v3 = self.zlo + vertices[i][2]*(self.zhi - self.zlo)
        self.vertices.append([v1, v2, v3])
    self.triangles = []
    for tri in triangles:
        self.triangles.append([tri[0], tri[1], tri[2]])
    self.connections = connect(self.nvert, self.ntri, self.triangles)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cdata3.Capped"><code class="flex name class">
<span>class <span class="ident">Capped</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Capped:
    def __init__(self, *args):
        self.select = 0
        self.style = REGION
        self.id = &#34;&#34;
        self.substyle = CAPPED
        self.axis = args[0]
        self.c1 = float(args[1])
        self.c2 = float(args[2])
        self.r = float(args[3])
        self.lo = float(args[4])
        self.hi = float(args[5])
        self.rsq = self.r**2
        self.q1 = 2
        self.q2 = 1

    def bbox(self):
        if self.axis == &#39;x&#39;:
            return (self.lo - self.r, self.c1 - self.r, self.c2 - self.r,
                    self.hi + self.r, self.c1 + self.r, self.c2 + self.r)
        elif self.axis == &#39;y&#39;:
            return (self.c1 - self.r, self.lo - self.r, self.c2 - self.r,
                    self.c1 + self.r, self.hi + self.r, self.c2 + self.r)
        else:  # &#39;z&#39;
            return (self.c1 - self.r, self.c2 - self.r, self.lo - self.r,
                    self.c1 + self.r, self.c2 + self.r, self.hi + self.r)

    def inside(self, x, y, z):
        if self.axis == &#39;x&#39;:
            d1 = y - self.c1
            d2 = z - self.c2
            d3 = x
        elif self.axis == &#39;y&#39;:
            d1 = x - self.c1
            d2 = z - self.c2
            d3 = y
        else:  # &#39;z&#39;
            d1 = x - self.c1
            d2 = y - self.c2
            d3 = z
        rsq = d1*d1 + d2*d2
        if self.lo &lt;= d3 &lt;= self.hi:
            if rsq &gt; self.rsq:
                return 0
        elif d3 &lt; self.lo:
            if (d1*d1 + d2*d2 + (d3 - self.lo)**2) &gt; self.rsq:
                return 0
        else:
            if (d1*d1 + d2*d2 + (d3 - self.hi)**2) &gt; self.rsq:
                return 0
        return 1

    def triangulate(self):
        if self.q1 % 2 != 0:
            raise Exception(&#34;Capped cylinder q1 must be even&#34;)
        vertices, triangles = box_triangulate(int(self.q1),
                                              int(self.q1),
                                              int(self.q2 + self.q1))
        self.nvert = len(vertices)
        self.ntri = len(triangles)
        self.vertices = []
        # For a capped cylinder, partial code:
        cutlo = (self.q1 // 2) * 1.0 / (self.q2 + self.q1) + EPSILON
        cuthi = 1.0 - cutlo
        for v in vertices:
            v1 = v[0]
            v2 = v[1]
            v3 = v[2]
            if v3 &lt; cutlo:
                c = [v1 - 0.5, v2 - 0.5, (v3 - cutlo)*(0.5/cutlo)]
                normalize(c)
                p1 = self.c1 + self.r*c[0]
                p2 = self.c2 + self.r*c[1]
                p3 = self.lo + self.r*c[2]
            elif v3 &gt; cuthi:
                c = [v1 - 0.5, v2 - 0.5, (v3 - cuthi)*(0.5/cutlo)]
                normalize(c)
                p1 = self.c1 + self.r*c[0]
                p2 = self.c2 + self.r*c[1]
                p3 = self.hi + self.r*c[2]
            else:
                c = [v1 - 0.5, v2 - 0.5, 0.0]
                normalize(c)
                p1 = self.c1 + self.r*c[0]
                p2 = self.c2 + self.r*c[1]
                frac = (v3 - cutlo) / (cuthi - cutlo)
                p3 = self.lo + frac * (self.hi - self.lo)
            if self.axis == &#39;x&#39;:
                self.vertices.append([p3, p1, p2])
            elif self.axis == &#39;y&#39;:
                self.vertices.append([p1, p3, p2])
            else:
                self.vertices.append([p1, p2, p3])
        self.triangles = [[t[0], t[1], t[2]] for t in triangles]
        self.connections = connect(self.nvert, self.ntri, self.triangles)

    def area(self):
        &#34;&#34;&#34;
        Surface area of a capped cylinder = cylinder area + 2 * hemisphere discs.
        Approximate if needed. Or store partial sums if you want area-based loc2d.
        &#34;&#34;&#34;
        # Simplistic example:
        side_area = 2 * pi * self.r * (self.hi - self.lo)
        circle_area = pi * self.r * self.r
        # top circle + bottom circle
        top_bottom_area = 2 * circle_area
        return side_area + top_bottom_area

    def loc2d(self, area, random_fn):
        &#34;&#34;&#34;
        Return a random location on the capped cylinder surface.
        &#34;&#34;&#34;
        # Implement a full partition if you want exact coverage.
        return ([self.c1, self.c2, self.lo], [1, 0, 0])

    def command(self):
        return (f&#34;{self.id} capped {self.axis} {self.c1} {self.c2} &#34;
                f&#34;{self.r} {self.lo} {self.hi}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cdata3.Capped.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Surface area of a capped cylinder = cylinder area + 2 * hemisphere discs.
Approximate if needed. Or store partial sums if you want area-based loc2d.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area(self):
    &#34;&#34;&#34;
    Surface area of a capped cylinder = cylinder area + 2 * hemisphere discs.
    Approximate if needed. Or store partial sums if you want area-based loc2d.
    &#34;&#34;&#34;
    # Simplistic example:
    side_area = 2 * pi * self.r * (self.hi - self.lo)
    circle_area = pi * self.r * self.r
    # top circle + bottom circle
    top_bottom_area = 2 * circle_area
    return side_area + top_bottom_area</code></pre>
</details>
</dd>
<dt id="cdata3.Capped.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self):
    if self.axis == &#39;x&#39;:
        return (self.lo - self.r, self.c1 - self.r, self.c2 - self.r,
                self.hi + self.r, self.c1 + self.r, self.c2 + self.r)
    elif self.axis == &#39;y&#39;:
        return (self.c1 - self.r, self.lo - self.r, self.c2 - self.r,
                self.c1 + self.r, self.hi + self.r, self.c2 + self.r)
    else:  # &#39;z&#39;
        return (self.c1 - self.r, self.c2 - self.r, self.lo - self.r,
                self.c1 + self.r, self.c2 + self.r, self.hi + self.r)</code></pre>
</details>
</dd>
<dt id="cdata3.Capped.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(self):
    return (f&#34;{self.id} capped {self.axis} {self.c1} {self.c2} &#34;
            f&#34;{self.r} {self.lo} {self.hi}&#34;)</code></pre>
</details>
</dd>
<dt id="cdata3.Capped.inside"><code class="name flex">
<span>def <span class="ident">inside</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inside(self, x, y, z):
    if self.axis == &#39;x&#39;:
        d1 = y - self.c1
        d2 = z - self.c2
        d3 = x
    elif self.axis == &#39;y&#39;:
        d1 = x - self.c1
        d2 = z - self.c2
        d3 = y
    else:  # &#39;z&#39;
        d1 = x - self.c1
        d2 = y - self.c2
        d3 = z
    rsq = d1*d1 + d2*d2
    if self.lo &lt;= d3 &lt;= self.hi:
        if rsq &gt; self.rsq:
            return 0
    elif d3 &lt; self.lo:
        if (d1*d1 + d2*d2 + (d3 - self.lo)**2) &gt; self.rsq:
            return 0
    else:
        if (d1*d1 + d2*d2 + (d3 - self.hi)**2) &gt; self.rsq:
            return 0
    return 1</code></pre>
</details>
</dd>
<dt id="cdata3.Capped.loc2d"><code class="name flex">
<span>def <span class="ident">loc2d</span></span>(<span>self, area, random_fn)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a random location on the capped cylinder surface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loc2d(self, area, random_fn):
    &#34;&#34;&#34;
    Return a random location on the capped cylinder surface.
    &#34;&#34;&#34;
    # Implement a full partition if you want exact coverage.
    return ([self.c1, self.c2, self.lo], [1, 0, 0])</code></pre>
</details>
</dd>
<dt id="cdata3.Capped.triangulate"><code class="name flex">
<span>def <span class="ident">triangulate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangulate(self):
    if self.q1 % 2 != 0:
        raise Exception(&#34;Capped cylinder q1 must be even&#34;)
    vertices, triangles = box_triangulate(int(self.q1),
                                          int(self.q1),
                                          int(self.q2 + self.q1))
    self.nvert = len(vertices)
    self.ntri = len(triangles)
    self.vertices = []
    # For a capped cylinder, partial code:
    cutlo = (self.q1 // 2) * 1.0 / (self.q2 + self.q1) + EPSILON
    cuthi = 1.0 - cutlo
    for v in vertices:
        v1 = v[0]
        v2 = v[1]
        v3 = v[2]
        if v3 &lt; cutlo:
            c = [v1 - 0.5, v2 - 0.5, (v3 - cutlo)*(0.5/cutlo)]
            normalize(c)
            p1 = self.c1 + self.r*c[0]
            p2 = self.c2 + self.r*c[1]
            p3 = self.lo + self.r*c[2]
        elif v3 &gt; cuthi:
            c = [v1 - 0.5, v2 - 0.5, (v3 - cuthi)*(0.5/cutlo)]
            normalize(c)
            p1 = self.c1 + self.r*c[0]
            p2 = self.c2 + self.r*c[1]
            p3 = self.hi + self.r*c[2]
        else:
            c = [v1 - 0.5, v2 - 0.5, 0.0]
            normalize(c)
            p1 = self.c1 + self.r*c[0]
            p2 = self.c2 + self.r*c[1]
            frac = (v3 - cutlo) / (cuthi - cutlo)
            p3 = self.lo + frac * (self.hi - self.lo)
        if self.axis == &#39;x&#39;:
            self.vertices.append([p3, p1, p2])
        elif self.axis == &#39;y&#39;:
            self.vertices.append([p1, p3, p2])
        else:
            self.vertices.append([p1, p2, p3])
    self.triangles = [[t[0], t[1], t[2]] for t in triangles]
    self.connections = connect(self.nvert, self.ntri, self.triangles)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cdata3.Cylinder"><code class="flex name class">
<span>class <span class="ident">Cylinder</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cylinder:
    def __init__(self, *args):
        self.select = 0
        self.style = REGION
        self.id = &#34;&#34;
        self.substyle = CYLINDER
        self.axis = args[0]
        self.c1 = float(args[1])
        self.c2 = float(args[2])
        self.r = float(args[3])
        self.lo = float(args[4])
        self.hi = float(args[5])
        self.rsq = self.r**2
        self.q1 = 2
        self.q2 = 1

    def bbox(self):
        if self.axis == &#39;x&#39;:
            return (self.lo, self.c1-self.r, self.c2-self.r,
                    self.hi, self.c1+self.r, self.c2+self.r)
        elif self.axis == &#39;y&#39;:
            return (self.c1-self.r, self.lo, self.c2-self.r,
                    self.c1+self.r, self.hi, self.c2+self.r)
        elif self.axis == &#39;z&#39;:
            return (self.c1-self.r, self.c2-self.r, self.lo,
                    self.c1+self.r, self.c2+self.r, self.hi)
        return (0, 0, 0, 0, 0, 0)

    def inside(self, x, y, z):
        if self.axis == &#39;x&#39;:
            d1 = y - self.c1
            d2 = z - self.c2
            d3 = x
        elif self.axis == &#39;y&#39;:
            d1 = x - self.c1
            d2 = z - self.c2
            d3 = y
        else:  # &#39;z&#39;
            d1 = x - self.c1
            d2 = y - self.c2
            d3 = z
        rsq = d1*d1 + d2*d2
        if rsq &gt; self.rsq:
            return 0
        if d3 &lt; self.lo or d3 &gt; self.hi:
            return 0
        return 1

    def triangulate(self):
        vertices, triangles = box_triangulate(self.q1, self.q1, self.q2)
        self.nvert = len(vertices)
        self.ntri = len(triangles)
        self.vertices = []
        for v in vertices:
            v1 = v[0] - 0.5
            v2 = v[1] - 0.5
            v3 = v[2]
            c = [v1, v2, 0]
            normalize(c)
            length = max(fabs(v1), fabs(v2)) * 2.0
            c[0] *= length
            c[1] *= length
            p1 = self.c1 + self.r*c[0]
            p2 = self.c2 + self.r*c[1]
            p3 = self.lo + v3*(self.hi - self.lo)
            if self.axis == &#39;x&#39;:
                self.vertices.append([p3, p1, p2])
            elif self.axis == &#39;y&#39;:
                self.vertices.append([p1, p3, p2])
            else:
                self.vertices.append([p1, p2, p3])
        self.triangles = [[t[0], t[1], t[2]] for t in triangles]
        self.connections = connect(self.nvert, self.ntri, self.triangles)

    def area(self):
        &#34;&#34;&#34;
        Cylinder area = 2 * (circle area) + side area = 2 * (πr²) + (2πr * length)
        But we store partial sums if needed.
        &#34;&#34;&#34;
        circle_area = pi * self.r**2
        length = self.hi - self.lo
        top_bottom = 2*circle_area
        side = 2*pi*self.r*length
        self.areas = [circle_area, top_bottom, top_bottom+side]
        return top_bottom + side

    def loc2d(self, area, random_fn):
        # Implementation stub
        return ([self.c1, self.c2, self.lo], [1, 0, 0])

    def command(self):
        return (f&#34;{self.id} cylinder {self.axis} {self.c1} {self.c2} &#34;
                f&#34;{self.r} {self.lo} {self.hi}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cdata3.Cylinder.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cylinder area = 2 * (circle area) + side area = 2 * (πr²) + (2πr * length)
But we store partial sums if needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area(self):
    &#34;&#34;&#34;
    Cylinder area = 2 * (circle area) + side area = 2 * (πr²) + (2πr * length)
    But we store partial sums if needed.
    &#34;&#34;&#34;
    circle_area = pi * self.r**2
    length = self.hi - self.lo
    top_bottom = 2*circle_area
    side = 2*pi*self.r*length
    self.areas = [circle_area, top_bottom, top_bottom+side]
    return top_bottom + side</code></pre>
</details>
</dd>
<dt id="cdata3.Cylinder.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self):
    if self.axis == &#39;x&#39;:
        return (self.lo, self.c1-self.r, self.c2-self.r,
                self.hi, self.c1+self.r, self.c2+self.r)
    elif self.axis == &#39;y&#39;:
        return (self.c1-self.r, self.lo, self.c2-self.r,
                self.c1+self.r, self.hi, self.c2+self.r)
    elif self.axis == &#39;z&#39;:
        return (self.c1-self.r, self.c2-self.r, self.lo,
                self.c1+self.r, self.c2+self.r, self.hi)
    return (0, 0, 0, 0, 0, 0)</code></pre>
</details>
</dd>
<dt id="cdata3.Cylinder.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(self):
    return (f&#34;{self.id} cylinder {self.axis} {self.c1} {self.c2} &#34;
            f&#34;{self.r} {self.lo} {self.hi}&#34;)</code></pre>
</details>
</dd>
<dt id="cdata3.Cylinder.inside"><code class="name flex">
<span>def <span class="ident">inside</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inside(self, x, y, z):
    if self.axis == &#39;x&#39;:
        d1 = y - self.c1
        d2 = z - self.c2
        d3 = x
    elif self.axis == &#39;y&#39;:
        d1 = x - self.c1
        d2 = z - self.c2
        d3 = y
    else:  # &#39;z&#39;
        d1 = x - self.c1
        d2 = y - self.c2
        d3 = z
    rsq = d1*d1 + d2*d2
    if rsq &gt; self.rsq:
        return 0
    if d3 &lt; self.lo or d3 &gt; self.hi:
        return 0
    return 1</code></pre>
</details>
</dd>
<dt id="cdata3.Cylinder.loc2d"><code class="name flex">
<span>def <span class="ident">loc2d</span></span>(<span>self, area, random_fn)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loc2d(self, area, random_fn):
    # Implementation stub
    return ([self.c1, self.c2, self.lo], [1, 0, 0])</code></pre>
</details>
</dd>
<dt id="cdata3.Cylinder.triangulate"><code class="name flex">
<span>def <span class="ident">triangulate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangulate(self):
    vertices, triangles = box_triangulate(self.q1, self.q1, self.q2)
    self.nvert = len(vertices)
    self.ntri = len(triangles)
    self.vertices = []
    for v in vertices:
        v1 = v[0] - 0.5
        v2 = v[1] - 0.5
        v3 = v[2]
        c = [v1, v2, 0]
        normalize(c)
        length = max(fabs(v1), fabs(v2)) * 2.0
        c[0] *= length
        c[1] *= length
        p1 = self.c1 + self.r*c[0]
        p2 = self.c2 + self.r*c[1]
        p3 = self.lo + v3*(self.hi - self.lo)
        if self.axis == &#39;x&#39;:
            self.vertices.append([p3, p1, p2])
        elif self.axis == &#39;y&#39;:
            self.vertices.append([p1, p3, p2])
        else:
            self.vertices.append([p1, p2, p3])
    self.triangles = [[t[0], t[1], t[2]] for t in triangles]
    self.connections = connect(self.nvert, self.ntri, self.triangles)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cdata3.Group"><code class="flex name class">
<span>class <span class="ident">Group</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Group:
    def __init__(self):
        self.select = 0
        self.style = GROUP
        self.id = &#34;&#34;
        self.npart = 0
        self.xyz = []
        self.on_id = &#34;&#34;
        # For bounding box center
        self.xc = 0.0
        self.yc = 0.0
        self.zc = 0.0
    
    def bbox(self):
        &#34;&#34;&#34;
        Return bounding box of all particles in this group.
        &#34;&#34;&#34;
        if not self.xyz:
            return (0, 0, 0, 0, 0, 0)
        xs = [p[0] for p in self.xyz]
        ys = [p[1] for p in self.xyz]
        zs = [p[2] for p in self.xyz]
        return (min(xs), min(ys), min(zs), max(xs), max(ys), max(zs))
    
    def center(self, x=None, y=None, z=None):
        &#34;&#34;&#34;
        Set center of the group explicitly or to the midpoint of bounding box.
        &#34;&#34;&#34;
        if x is not None and y is not None and z is not None:
            self.xc = x
            self.yc = y
            self.zc = z
        else:
            xlo, ylo, zlo, xhi, yhi, zhi = self.bbox()
            self.xc = 0.5 * (xlo + xhi)
            self.yc = 0.5 * (ylo + yhi)
            self.zc = 0.5 * (zlo + zhi)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cdata3.Group.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return bounding box of all particles in this group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self):
    &#34;&#34;&#34;
    Return bounding box of all particles in this group.
    &#34;&#34;&#34;
    if not self.xyz:
        return (0, 0, 0, 0, 0, 0)
    xs = [p[0] for p in self.xyz]
    ys = [p[1] for p in self.xyz]
    zs = [p[2] for p in self.xyz]
    return (min(xs), min(ys), min(zs), max(xs), max(ys), max(zs))</code></pre>
</details>
</dd>
<dt id="cdata3.Group.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self, x=None, y=None, z=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set center of the group explicitly or to the midpoint of bounding box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(self, x=None, y=None, z=None):
    &#34;&#34;&#34;
    Set center of the group explicitly or to the midpoint of bounding box.
    &#34;&#34;&#34;
    if x is not None and y is not None and z is not None:
        self.xc = x
        self.yc = y
        self.zc = z
    else:
        xlo, ylo, zlo, xhi, yhi, zhi = self.bbox()
        self.xc = 0.5 * (xlo + xhi)
        self.yc = 0.5 * (ylo + yhi)
        self.zc = 0.5 * (zlo + zhi)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cdata3.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Line:
    def __init__(self):
        self.select = 0
        self.style = LINE
        self.id = &#34;&#34;
        self.nline = 0
        self.pairs = []
    
    def bbox(self):
        &#34;&#34;&#34;
        Return bounding box around all line segments.
        &#34;&#34;&#34;
        if not self.pairs:
            return (0, 0, 0, 0, 0, 0)
        xs = [p[0] for p in self.pairs] + [p[3] for p in self.pairs]
        ys = [p[1] for p in self.pairs] + [p[4] for p in self.pairs]
        zs = [p[2] for p in self.pairs] + [p[5] for p in self.pairs]
        return (min(xs), min(ys), min(zs), max(xs), max(ys), max(zs))
    
    def addline(self, coords):
        &#34;&#34;&#34;
        Add a single line segment (x1, y1, z1, x2, y2, z2).
        &#34;&#34;&#34;
        self.nline += 1
        self.pairs.append(list(coords))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cdata3.Line.addline"><code class="name flex">
<span>def <span class="ident">addline</span></span>(<span>self, coords)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a single line segment (x1, y1, z1, x2, y2, z2).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addline(self, coords):
    &#34;&#34;&#34;
    Add a single line segment (x1, y1, z1, x2, y2, z2).
    &#34;&#34;&#34;
    self.nline += 1
    self.pairs.append(list(coords))</code></pre>
</details>
</dd>
<dt id="cdata3.Line.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return bounding box around all line segments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self):
    &#34;&#34;&#34;
    Return bounding box around all line segments.
    &#34;&#34;&#34;
    if not self.pairs:
        return (0, 0, 0, 0, 0, 0)
    xs = [p[0] for p in self.pairs] + [p[3] for p in self.pairs]
    ys = [p[1] for p in self.pairs] + [p[4] for p in self.pairs]
    zs = [p[2] for p in self.pairs] + [p[5] for p in self.pairs]
    return (min(xs), min(ys), min(zs), max(xs), max(ys), max(zs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cdata3.Random"><code class="flex name class">
<span>class <span class="ident">Random</span></span>
<span>(</span><span>seed)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple linear congruential generator (LCG) for random numbers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Random:
    &#34;&#34;&#34;
    Simple linear congruential generator (LCG) for random numbers.
    &#34;&#34;&#34;
    def __init__(self, seed):
        self.seed = seed
    
    def __call__(self):
        k = self.seed // IQ
        self.seed = IA * (self.seed - k * IQ) - IR * k
        if self.seed &lt; 0:
            self.seed += IM
        return AM * self.seed</code></pre>
</details>
</dd>
<dt id="cdata3.Shell"><code class="flex name class">
<span>class <span class="ident">Shell</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shell(Sphere):
    def __init__(self, *args):
        super().__init__(*args[:4])
        self.substyle = SHELL
        self.rinner = float(args[4])
        self.innersq = self.rinner**2

    def inside(self, x, y, z):
        dx = x - self.x
        dy = y - self.y
        dz = z - self.z
        rsq = dx*dx + dy*dy + dz*dz
        if rsq &gt; self.rsq or rsq &lt; self.innersq:
            return 0
        return 1

    def command(self):
        return f&#34;{self.id} shell {self.x} {self.y} {self.z} {self.r} {self.rinner}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cdata3.Sphere" href="#cdata3.Sphere">Sphere</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cdata3.Shell.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(self):
    return f&#34;{self.id} shell {self.x} {self.y} {self.z} {self.r} {self.rinner}&#34;</code></pre>
</details>
</dd>
<dt id="cdata3.Shell.inside"><code class="name flex">
<span>def <span class="ident">inside</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inside(self, x, y, z):
    dx = x - self.x
    dy = y - self.y
    dz = z - self.z
    rsq = dx*dx + dy*dy + dz*dz
    if rsq &gt; self.rsq or rsq &lt; self.innersq:
        return 0
    return 1</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cdata3.Sphere" href="#cdata3.Sphere">Sphere</a></b></code>:
<ul class="hlist">
<li><code><a title="cdata3.Sphere.loc2d" href="#cdata3.Sphere.loc2d">loc2d</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="cdata3.Sphere"><code class="flex name class">
<span>class <span class="ident">Sphere</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sphere:
    def __init__(self, *args):
        self.select = 0
        self.style = REGION
        self.id = &#34;&#34;
        self.substyle = SPHERE
        self.x = float(args[0])
        self.y = float(args[1])
        self.z = float(args[2])
        self.r = float(args[3])
        self.rsq = self.r**2
        # Triangulation quality
        self.q1 = 2.0

    def bbox(self):
        return (self.x-self.r, self.y-self.r, self.z-self.r,
                self.x+self.r, self.y+self.r, self.z+self.r)

    def inside(self, x, y, z):
        dx = x - self.x
        dy = y - self.y
        dz = z - self.z
        if (dx*dx + dy*dy + dz*dz) &gt; self.rsq:
            return 0
        return 1

    def triangulate(self):
        vertices, triangles = box_triangulate(int(self.q1),
                                              int(self.q1),
                                              int(self.q1))
        self.nvert = len(vertices)
        self.ntri = len(triangles)
        self.vertices = []
        for i in range(self.nvert):
            v1 = vertices[i][0] - 0.5
            v2 = vertices[i][1] - 0.5
            v3 = vertices[i][2] - 0.5
            c = [v1, v2, v3]
            normalize(c)
            c[0] = self.x + self.r*c[0]
            c[1] = self.y + self.r*c[1]
            c[2] = self.z + self.r*c[2]
            self.vertices.append(c)
        self.triangles = []
        for tri in triangles:
            self.triangles.append([tri[0], tri[1], tri[2]])
        self.connections = connect(self.nvert, self.ntri, self.triangles)

    def area(self):
        return 4.0 * pi * (self.r**2)

    def loc2d(self, area, random_fn):
        &#34;&#34;&#34;
        Return a random location on the sphere surface.
        &#34;&#34;&#34;
        while True:
            x_ = random_fn() - 0.5
            y_ = random_fn() - 0.5
            z_ = random_fn() - 0.5
            if (x_*x_ + y_*y_ + z_*z_) &lt;= 0.25:
                break
        c = [x_, y_, z_]
        normalize(c)
        return ([self.x + self.r*c[0],
                 self.y + self.r*c[1],
                 self.z + self.r*c[2]],
                c)

    def command(self):
        return f&#34;{self.id} sphere {self.x} {self.y} {self.z} {self.r}&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cdata3.Shell" href="#cdata3.Shell">Shell</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cdata3.Sphere.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area(self):
    return 4.0 * pi * (self.r**2)</code></pre>
</details>
</dd>
<dt id="cdata3.Sphere.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self):
    return (self.x-self.r, self.y-self.r, self.z-self.r,
            self.x+self.r, self.y+self.r, self.z+self.r)</code></pre>
</details>
</dd>
<dt id="cdata3.Sphere.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(self):
    return f&#34;{self.id} sphere {self.x} {self.y} {self.z} {self.r}&#34;</code></pre>
</details>
</dd>
<dt id="cdata3.Sphere.inside"><code class="name flex">
<span>def <span class="ident">inside</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inside(self, x, y, z):
    dx = x - self.x
    dy = y - self.y
    dz = z - self.z
    if (dx*dx + dy*dy + dz*dz) &gt; self.rsq:
        return 0
    return 1</code></pre>
</details>
</dd>
<dt id="cdata3.Sphere.loc2d"><code class="name flex">
<span>def <span class="ident">loc2d</span></span>(<span>self, area, random_fn)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a random location on the sphere surface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loc2d(self, area, random_fn):
    &#34;&#34;&#34;
    Return a random location on the sphere surface.
    &#34;&#34;&#34;
    while True:
        x_ = random_fn() - 0.5
        y_ = random_fn() - 0.5
        z_ = random_fn() - 0.5
        if (x_*x_ + y_*y_ + z_*z_) &lt;= 0.25:
            break
    c = [x_, y_, z_]
    normalize(c)
    return ([self.x + self.r*c[0],
             self.y + self.r*c[1],
             self.z + self.r*c[2]],
            c)</code></pre>
</details>
</dd>
<dt id="cdata3.Sphere.triangulate"><code class="name flex">
<span>def <span class="ident">triangulate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangulate(self):
    vertices, triangles = box_triangulate(int(self.q1),
                                          int(self.q1),
                                          int(self.q1))
    self.nvert = len(vertices)
    self.ntri = len(triangles)
    self.vertices = []
    for i in range(self.nvert):
        v1 = vertices[i][0] - 0.5
        v2 = vertices[i][1] - 0.5
        v3 = vertices[i][2] - 0.5
        c = [v1, v2, v3]
        normalize(c)
        c[0] = self.x + self.r*c[0]
        c[1] = self.y + self.r*c[1]
        c[2] = self.z + self.r*c[2]
        self.vertices.append(c)
    self.triangles = []
    for tri in triangles:
        self.triangles.append([tri[0], tri[1], tri[2]])
    self.connections = connect(self.nvert, self.ntri, self.triangles)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cdata3.Surface"><code class="flex name class">
<span>class <span class="ident">Surface</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Surface:
    def __init__(self):
        self.select = 0
        self.style = SURFACE
        self.id = &#34;&#34;
        self.nvert = 0
        self.ntri = 0
        self.nbinx = 0
        self.nbiny = 0
        self.vertices = []
        self.triangles = []
        self.connections = []
        # For bounding box center
        self.xc = 0.0
        self.yc = 0.0
        self.zc = 0.0
    
    def bbox(self):
        &#34;&#34;&#34;
        Return bounding box of all vertices in this surface.
        &#34;&#34;&#34;
        if not self.vertices:
            return (0, 0, 0, 0, 0, 0)
        xs = [float(v[0]) for v in self.vertices]
        ys = [float(v[1]) for v in self.vertices]
        zs = [float(v[2]) for v in self.vertices]
        return (min(xs), min(ys), min(zs), max(xs), max(ys), max(zs))
    
    def center(self, x=None, y=None, z=None):
        &#34;&#34;&#34;
        Set center of the surface explicitly or to the midpoint of bounding box.
        &#34;&#34;&#34;
        if x is not None and y is not None and z is not None:
            self.xc = x
            self.yc = y
            self.zc = z
        else:
            xlo, ylo, zlo, xhi, yhi, zhi = self.bbox()
            self.xc = 0.5 * (xlo + xhi)
            self.yc = 0.5 * (ylo + yhi)
            self.zc = 0.5 * (zlo + zhi)
    
    def inside_prep(self):
        &#34;&#34;&#34;
        Prepare binning if you want to accelerate inside() checks.
        Depending on usage, implement as needed.
        &#34;&#34;&#34;
        pass
    
    def inside(self, x, y, z):
        &#34;&#34;&#34;
        Check if point (x, y, z) is inside this closed surface.
        By default, return False (0).
        Implement if needed.
        &#34;&#34;&#34;
        return 0
    
    def area(self):
        &#34;&#34;&#34;
        Return total surface area of this surface.
        By default, sum the area of each triangle.
        &#34;&#34;&#34;
        # For each tri, area = 1/2 * cross(v2 - v1, v3 - v1)
        # We&#39;ll accumulate it.
        total_area = 0.0
        for tri in self.triangles:
            v1 = self.vertices[tri[0]-1]
            v2 = self.vertices[tri[1]-1]
            v3 = self.vertices[tri[2]-1]
            # Compute area
            side1 = [v2[i] - v1[i] for i in range(3)]
            side2 = [v3[i] - v1[i] for i in range(3)]
            cr = cross(side1, side2)
            tri_area = 0.5 * sqrt(cr[0]**2 + cr[1]**2 + cr[2]**2)
            total_area += tri_area
        return total_area
    
    def loc2d(self, area, random_fn):
        &#34;&#34;&#34;
        Return a random point on the surface, given a pre-chosen &#39;area&#39; fraction.
        By default, pick from triangles in ascending area order.
        Must implement your own partial sums if you want a strict area-based sampling.
        &#34;&#34;&#34;
        # Simple placeholder: pick any tri
        if not self.triangles:
            return ([0.0, 0.0, 0.0], [0.0, 0.0, 1.0])
        # For now, pick the first triangle
        tri = self.triangles[0]
        v1 = self.vertices[tri[0]-1]
        v2 = self.vertices[tri[1]-1]
        v3 = self.vertices[tri[2]-1]
        # Barycentric random
        r1 = random_fn()
        r2 = random_fn()
        if r1 + r2 &gt; 1.0:
            r1 = 1.0 - r1
            r2 = 1.0 - r2
        x = v1[0] + r1*(v2[0] - v1[0]) + r2*(v3[0] - v1[0])
        y = v1[1] + r1*(v2[1] - v1[1]) + r2*(v3[1] - v1[1])
        z = v1[2] + r1*(v2[2] - v1[2]) + r2*(v3[2] - v1[2])
        n = normal(v1, v2, v3)
        return ([x, y, z], n)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cdata3.Surface.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return total surface area of this surface.
By default, sum the area of each triangle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area(self):
    &#34;&#34;&#34;
    Return total surface area of this surface.
    By default, sum the area of each triangle.
    &#34;&#34;&#34;
    # For each tri, area = 1/2 * cross(v2 - v1, v3 - v1)
    # We&#39;ll accumulate it.
    total_area = 0.0
    for tri in self.triangles:
        v1 = self.vertices[tri[0]-1]
        v2 = self.vertices[tri[1]-1]
        v3 = self.vertices[tri[2]-1]
        # Compute area
        side1 = [v2[i] - v1[i] for i in range(3)]
        side2 = [v3[i] - v1[i] for i in range(3)]
        cr = cross(side1, side2)
        tri_area = 0.5 * sqrt(cr[0]**2 + cr[1]**2 + cr[2]**2)
        total_area += tri_area
    return total_area</code></pre>
</details>
</dd>
<dt id="cdata3.Surface.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return bounding box of all vertices in this surface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self):
    &#34;&#34;&#34;
    Return bounding box of all vertices in this surface.
    &#34;&#34;&#34;
    if not self.vertices:
        return (0, 0, 0, 0, 0, 0)
    xs = [float(v[0]) for v in self.vertices]
    ys = [float(v[1]) for v in self.vertices]
    zs = [float(v[2]) for v in self.vertices]
    return (min(xs), min(ys), min(zs), max(xs), max(ys), max(zs))</code></pre>
</details>
</dd>
<dt id="cdata3.Surface.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self, x=None, y=None, z=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set center of the surface explicitly or to the midpoint of bounding box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(self, x=None, y=None, z=None):
    &#34;&#34;&#34;
    Set center of the surface explicitly or to the midpoint of bounding box.
    &#34;&#34;&#34;
    if x is not None and y is not None and z is not None:
        self.xc = x
        self.yc = y
        self.zc = z
    else:
        xlo, ylo, zlo, xhi, yhi, zhi = self.bbox()
        self.xc = 0.5 * (xlo + xhi)
        self.yc = 0.5 * (ylo + yhi)
        self.zc = 0.5 * (zlo + zhi)</code></pre>
</details>
</dd>
<dt id="cdata3.Surface.inside"><code class="name flex">
<span>def <span class="ident">inside</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if point (x, y, z) is inside this closed surface.
By default, return False (0).
Implement if needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inside(self, x, y, z):
    &#34;&#34;&#34;
    Check if point (x, y, z) is inside this closed surface.
    By default, return False (0).
    Implement if needed.
    &#34;&#34;&#34;
    return 0</code></pre>
</details>
</dd>
<dt id="cdata3.Surface.inside_prep"><code class="name flex">
<span>def <span class="ident">inside_prep</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare binning if you want to accelerate inside() checks.
Depending on usage, implement as needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inside_prep(self):
    &#34;&#34;&#34;
    Prepare binning if you want to accelerate inside() checks.
    Depending on usage, implement as needed.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="cdata3.Surface.loc2d"><code class="name flex">
<span>def <span class="ident">loc2d</span></span>(<span>self, area, random_fn)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a random point on the surface, given a pre-chosen 'area' fraction.
By default, pick from triangles in ascending area order.
Must implement your own partial sums if you want a strict area-based sampling.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loc2d(self, area, random_fn):
    &#34;&#34;&#34;
    Return a random point on the surface, given a pre-chosen &#39;area&#39; fraction.
    By default, pick from triangles in ascending area order.
    Must implement your own partial sums if you want a strict area-based sampling.
    &#34;&#34;&#34;
    # Simple placeholder: pick any tri
    if not self.triangles:
        return ([0.0, 0.0, 0.0], [0.0, 0.0, 1.0])
    # For now, pick the first triangle
    tri = self.triangles[0]
    v1 = self.vertices[tri[0]-1]
    v2 = self.vertices[tri[1]-1]
    v3 = self.vertices[tri[2]-1]
    # Barycentric random
    r1 = random_fn()
    r2 = random_fn()
    if r1 + r2 &gt; 1.0:
        r1 = 1.0 - r1
        r2 = 1.0 - r2
    x = v1[0] + r1*(v2[0] - v1[0]) + r2*(v3[0] - v1[0])
    y = v1[1] + r1*(v2[1] - v1[1]) + r2*(v3[1] - v1[1])
    z = v1[2] + r1*(v2[2] - v1[2]) + r2*(v3[2] - v1[2])
    n = normal(v1, v2, v3)
    return ([x, y, z], n)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cdata3.Union"><code class="flex name class">
<span>class <span class="ident">Union</span></span>
<span>(</span><span>ids, objs, *list_ids)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Union:
    def __init__(self, ids, objs, *list_ids):
        self.select = 0
        self.style = UNION
        self.id = &#34;&#34;
        # child objects
        self.objs = []
        for obj_id in list_ids:
            obj = objs[ids[obj_id]]
            if obj.style not in [SURFACE, REGION, UNION]:
                raise Exception(&#34;Union child object is of invalid style&#34;)
            self.objs.append(obj)
    
    def bbox(self):
        if not self.objs:
            return (0, 0, 0, 0, 0, 0)
        xlo, ylo, zlo, xhi, yhi, zhi = self.objs[0].bbox()
        for obj in self.objs[1:]:
            xxlo, yylo, zzlo, xxhi, yyhi, zzhi = obj.bbox()
            if xxlo &lt; xlo: xlo = xxlo
            if yylo &lt; ylo: ylo = yylo
            if zzlo &lt; zlo: zlo = zzlo
            if xxhi &gt; xhi: xhi = xxhi
            if yyhi &gt; yhi: yhi = yyhi
            if zzhi &gt; zhi: zhi = zzhi
        return (xlo, ylo, zlo, xhi, yhi, zhi)
    
    def inside(self, x, y, z):
        # inside union if inside any of its child objects
        for obj in self.objs:
            if obj.inside(x, y, z):
                return 1
        return 0
    
    def area(self):
        # sum areas of child objects
        total = 0.0
        for obj in self.objs:
            total += obj.area()
        return total
    
    def loc2d(self, area, random_fn):
        &#34;&#34;&#34;
        Return a random location on the union surface, if needed.
        This would require partial sums across each child&#39;s area.
        For brevity, pick first child.
        &#34;&#34;&#34;
        if not self.objs:
            return ([0,0,0], [0,0,1])
        return self.objs[0].loc2d(area, random_fn)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cdata3.Union.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area(self):
    # sum areas of child objects
    total = 0.0
    for obj in self.objs:
        total += obj.area()
    return total</code></pre>
</details>
</dd>
<dt id="cdata3.Union.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self):
    if not self.objs:
        return (0, 0, 0, 0, 0, 0)
    xlo, ylo, zlo, xhi, yhi, zhi = self.objs[0].bbox()
    for obj in self.objs[1:]:
        xxlo, yylo, zzlo, xxhi, yyhi, zzhi = obj.bbox()
        if xxlo &lt; xlo: xlo = xxlo
        if yylo &lt; ylo: ylo = yylo
        if zzlo &lt; zlo: zlo = zzlo
        if xxhi &gt; xhi: xhi = xxhi
        if yyhi &gt; yhi: yhi = yyhi
        if zzhi &gt; zhi: zhi = zzhi
    return (xlo, ylo, zlo, xhi, yhi, zhi)</code></pre>
</details>
</dd>
<dt id="cdata3.Union.inside"><code class="name flex">
<span>def <span class="ident">inside</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inside(self, x, y, z):
    # inside union if inside any of its child objects
    for obj in self.objs:
        if obj.inside(x, y, z):
            return 1
    return 0</code></pre>
</details>
</dd>
<dt id="cdata3.Union.loc2d"><code class="name flex">
<span>def <span class="ident">loc2d</span></span>(<span>self, area, random_fn)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a random location on the union surface, if needed.
This would require partial sums across each child's area.
For brevity, pick first child.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loc2d(self, area, random_fn):
    &#34;&#34;&#34;
    Return a random location on the union surface, if needed.
    This would require partial sums across each child&#39;s area.
    For brevity, pick first child.
    &#34;&#34;&#34;
    if not self.objs:
        return ([0,0,0], [0,0,1])
    return self.objs[0].loc2d(area, random_fn)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cdata3.cdata"><code class="flex name class">
<span>class <span class="ident">cdata</span></span>
<span>(</span><span>*list)</span>
</code></dt>
<dd>
<div class="desc"><p>cdata class for reading, creating, and manipulating ChemCell data files.</p>
<p>Initialize the cdata object.</p>
<h2 id="parameters">Parameters</h2>
<p>*list: Variable length argument list of file names to read.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class cdata:
    &#34;&#34;&#34;
    cdata class for reading, creating, and manipulating ChemCell data files.
    &#34;&#34;&#34;
    
    # --------------------------------------------------------------------
    
    def __init__(self, *list):
        &#34;&#34;&#34;
        Initialize the cdata object.

        Parameters:
            *list: Variable length argument list of file names to read.
        &#34;&#34;&#34;
        self.nselect = 1
        self.ids = {}
        self.objs = []
        self.random = Random(12345)

        if len(list):
            self.read(*list)
    
    # --------------------------------------------------------------------
    
    def read(self, *list):
        &#34;&#34;&#34;
        Read ChemCell data files and populate objects.

        Parameters:
            *list: Variable length argument list of file names to read.
        &#34;&#34;&#34;
        # flist = list of all data file names
        words = list[0].split()
        flist = []
        for word in words:
            flist += glob.glob(word)
        if len(flist) == 0 and len(list) == 1:
            raise Exception(&#34;no data file specified&#34;)
    
        for file in flist:
            # Test for gzipped file
            if file.endswith(&#34;.gz&#34;):
                f = popen(f&#34;{PIZZA_GUNZIP} -c {file}&#34;, &#39;r&#39;)
            else:
                f = open(file, &#39;r&#39;)
    
            # Read all entries in file
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                if not line:
                    continue
                elif line.startswith(&#34;triangles&#34;):
                    flag = &#34;triangles&#34;
                elif line.startswith(&#34;particles&#34;):
                    flag = &#34;particles&#34;
                elif line.startswith(&#34;facets&#34;):
                    flag = &#34;facets&#34;
                elif line.startswith(&#34;region&#34;):
                    flag = &#34;region&#34;
                else:
                    print(&#34;unknown line:&#34;, line)
                    raise Exception(&#34;unrecognized ChemCell data file&#34;)
    
                # Create a surface object from set of triangles or facets
                if flag in [&#34;triangles&#34;, &#34;facets&#34;]:
                    tmp, id, nvert, ntri = line.split()
                    nvert = int(nvert)
                    ntri = int(ntri)
    
                    if id in self.ids:
                        raise Exception(f&#34;ID {id} is already in use&#34;)
    
                    f.readline()  # Read past header
                    vertices = []
                    for _ in range(nvert):
                        parts = f.readline().split()
                        vertices.append([float(value) for value in parts[1:]])
                    f.readline()  # Read past another header
                    triangles = []
                    for _ in range(ntri):
                        parts = f.readline().split()
                        triangles.append([int(value) for value in parts[1:]])
    
                    if flag == &#34;triangles&#34;:
                        f.readline()  # Read past another header
                        connections = []
                        for _ in range(ntri):
                            parts = f.readline().split()
                            connections.append([int(value) for value in parts[1:]])
                    else:
                        connections = connect(nvert, ntri, triangles)
                    
                    obj = Surface()
                    obj.select = 1
                    self.ids[id] = len(self.objs)
                    self.objs.append(obj)
                    obj.id = id
                    obj.style = SURFACE
                    obj.nvert = nvert
                    obj.ntri = ntri
                    obj.vertices = vertices
                    obj.triangles = triangles
                    obj.connections = connections
                    obj.center()
                  
                    print(id, end=&#39; &#39;)
                    sys.stdout.flush()
    
                # Create a group object from list of particles
                if flag == &#34;particles&#34;:
                    words = line.split()
                    id = words[1]
                    npart = int(words[2])
    
                    if id in self.ids:
                        raise Exception(f&#34;ID {id} is already in use&#34;)
    
                    f.readline()  # Read past header
                    xyz = []
                    for _ in range(npart):
                        parts = f.readline().split()
                        xyz.append([float(value) for value in parts[1:]])
    
                    obj = Group()
                    obj.select = 1
                    self.ids[id] = len(self.objs)
                    self.objs.append(obj)
                    obj.id = id
                    obj.style = GROUP
                    obj.on_id = &#34;&#34;
                    if len(words) == 4:
                        obj.on_id = words[3]
                    obj.npart = npart
                    obj.xyz = xyz
                    obj.center()
                    
                    print(id, end=&#39; &#39;)
                    sys.stdout.flush()
    
                # Create a region object from ChemCell region command
                if flag == &#34;region&#34;:
                    words = line.split()
                    id = words[1]
                    style = words[2]
                    args = words[3:]
                    
                    if style == &#34;box&#34;:
                        obj = Box(*args)
                        obj.substyle = BOX
                    elif style == &#34;sphere&#34;:
                        obj = Sphere(*args)
                    elif style == &#34;shell&#34;:
                        obj = Shell(*args)
                    elif style == &#34;cylinder&#34;:
                        obj = Cylinder(*args)
                    elif style == &#34;capped&#34;:
                        obj = Capped(*args)
                    else:
                        raise Exception(f&#34;Unknown region style: {style}&#34;)
                    
                    obj.select = 1
                    self.ids[id] = len(self.objs)
                    self.objs.append(obj)
                    obj.id = id
                    obj.style = REGION
                    
                    print(id, end=&#39; &#39;)
                    sys.stdout.flush()
    
            f.close()
        print()
    
    # --------------------------------------------------------------------
    # Create Box Region
    
    def box(self, id, *args):
        &#34;&#34;&#34;
        Create a box region.

        Parameters:
            id (str): Unique identifier for the box.
            args: xlo, ylo, zlo, xhi, yhi, zhi
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Box(*args)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = REGION
        obj.substyle = BOX
    
    # --------------------------------------------------------------------
    # Create Sphere Region
    
    def sphere(self, id, *args):
        &#34;&#34;&#34;
        Create a sphere region.

        Parameters:
            id (str): Unique identifier for the sphere.
            args: x, y, z, r
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Sphere(*args)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = REGION
        obj.substyle = SPHERE
    
    # --------------------------------------------------------------------
    # Create Shell Region
    
    def shell(self, id, *args):
        &#34;&#34;&#34;
        Create a shell region.

        Parameters:
            id (str): Unique identifier for the shell.
            args: x, y, z, r, rinner
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Shell(*args)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = REGION
        obj.substyle = SHELL
    
    # --------------------------------------------------------------------
    # Create Cylinder Region
    
    def cyl(self, id, *args):
        &#34;&#34;&#34;
        Create a cylinder region.

        Parameters:
            id (str): Unique identifier for the cylinder.
            args: axis, c1, c2, r, lo, hi
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Cylinder(*args)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = REGION
        obj.substyle = CYLINDER
    
    # --------------------------------------------------------------------
    # Create Capped-Cylinder Region
    
    def cap(self, id, *args):
        &#34;&#34;&#34;
        Create a capped-cylinder region.

        Parameters:
            id (str): Unique identifier for the capped-cylinder.
            args: axis, c1, c2, r, lo, hi
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Capped(*args)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = REGION
        obj.substyle = CAPPED
    
    # --------------------------------------------------------------------
    # Set Quality Factors for a Region&#39;s Triangulation
    
    def q(self, id, *args):
        &#34;&#34;&#34;
        Set quality factors for a region&#39;s triangulation routine.

        Parameters:
            id (str): Identifier of the region.
            args: Quality factors (q1, q2, ...)
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style != REGION:
            raise Exception(&#34;Can only use q() on a region object&#34;)
        for n, arg in enumerate(args, start=1):
            setattr(obj, f&#34;q{n}&#34;, arg)
    
    # --------------------------------------------------------------------
    # Create a Line Object with a Single Line
    
    def line(self, id, *args):
        &#34;&#34;&#34;
        Create a line object with a single line.

        Parameters:
            id (str): Unique identifier for the line.
            args: x1, y1, z1, x2, y2, z2
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Line()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = LINE
        obj.nline = 0
        obj.pairs = []
        
        obj.addline(args)
    
    # --------------------------------------------------------------------
    # Create a Line Object with 12 Box Lines
    
    def lbox(self, id, *args):
        &#34;&#34;&#34;
        Create a line object with 12 lines representing a box.

        Parameters:
            id (str): Unique identifier for the line box.
            args: xlo, ylo, zlo, xhi, yhi, zhi
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Line()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = LINE
        obj.nline = 0
        obj.pairs = []
        
        xlo, ylo, zlo, xhi, yhi, zhi = args
        obj.addline([xlo, ylo, zlo, xhi, ylo, zlo])
        obj.addline([xlo, yhi, zlo, xhi, yhi, zlo])
        obj.addline([xlo, yhi, zhi, xhi, yhi, zhi])
        obj.addline([xlo, ylo, zhi, xhi, ylo, zhi])
        obj.addline([xlo, ylo, zlo, xlo, yhi, zlo])
        obj.addline([xhi, ylo, zlo, xhi, yhi, zlo])
        obj.addline([xhi, ylo, zhi, xhi, yhi, zhi])
        obj.addline([xlo, ylo, zhi, xlo, yhi, zhi])
        obj.addline([xlo, ylo, zlo, xlo, ylo, zhi])
        obj.addline([xhi, ylo, zlo, xhi, ylo, zhi])
        obj.addline([xhi, yhi, zlo, xhi, yhi, zhi])
        obj.addline([xlo, yhi, zlo, xlo, yhi, zhi])
    
    # --------------------------------------------------------------------
    # Create a Triangulated Surface Object from a Region Object
    
    def surf(self, id, id_region):
        &#34;&#34;&#34;
        Create a triangulated surface from a region object.

        Parameters:
            id (str): Unique identifier for the surface.
            id_region (str): Identifier of the region to triangulate.
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        region = self.objs[self.ids[id_region]]
        region.triangulate()
        
        obj = Surface()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = SURFACE
        obj.nvert = region.nvert
        obj.ntri = region.ntri
        obj.vertices = deepcopy(region.vertices)
        obj.triangles = deepcopy(region.triangles)
        obj.connections = deepcopy(region.connections)
        obj.center()
    
    # --------------------------------------------------------------------
    # Create a Triangulated Surface Object from List of Triangle Indices
    
    def surftri(self, id, id_surf, *list_indices):
        &#34;&#34;&#34;
        Create a triangulated surface from a list of triangle indices in another surface.

        Parameters:
            id (str): Unique identifier for the new surface.
            id_surf (str): Identifier of the existing surface.
            *list_indices: Triangle indices to include (1-based indexing).
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        o = self.objs[self.ids[id_surf]]
        
        obj = Surface()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = SURFACE
        obj.nvert = 0
        obj.ntri = 0
        obj.vertices = []
        obj.triangles = []
    
        # Subtract 1 from tri and vert to convert to 0-based indexing
        for i in list_indices:
            tri = o.triangles[i-1]
            v1 = o.triangles[i-1][0]
            v2 = o.triangles[i-1][1]
            v3 = o.triangles[i-1][2]
            obj.vertices.append(o.vertices[v1-1][:])
            obj.vertices.append(o.vertices[v2-1][:])
            obj.vertices.append(o.vertices[v3-1][:])
            obj.triangles.append([obj.nvert+1, obj.nvert+2, obj.nvert+3])
            obj.nvert += 3
            obj.ntri += 1
    
        # Make any connections in new set of triangles
        obj.connections = connect(obj.nvert, obj.ntri, obj.triangles)
        obj.center()
    
    # --------------------------------------------------------------------
    # Create a Triangulated Surface Object by Selecting Triangles Based on a Test
    
    def surfselect(self, id, id_surf, teststr):
        &#34;&#34;&#34;
        Create a triangulated surface by selecting triangles based on a test string.

        Parameters:
            id (str): Unique identifier for the new surface.
            id_surf (str): Identifier of the existing surface.
            teststr (str): Test condition (e.g., &#34;$x &lt; 2.0 and $y &gt; 0.0&#34;).
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        o = self.objs[self.ids[id_surf]]
        
        obj = Surface()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = SURFACE
        obj.nvert = 0
        obj.ntri = 0
        obj.vertices = []
        obj.triangles = []
    
        # Replace $var with o.vertices reference and compile test string
        cmd1 = teststr.replace(&#34;$x&#34;, &#34;o.vertices[v1][0]&#34;)
        cmd1 = cmd1.replace(&#34;$y&#34;, &#34;o.vertices[v1][1]&#34;)
        cmd1 = &#34;flag1 = &#34; + cmd1.replace(&#34;$z&#34;, &#34;o.vertices[v1][2]&#34;)
        ccmd1 = compile(cmd1, &#39;&#39;, &#39;single&#39;)
    
        cmd2 = teststr.replace(&#34;$x&#34;, &#34;o.vertices[v2][0]&#34;)
        cmd2 = cmd2.replace(&#34;$y&#34;, &#34;o.vertices[v2][1]&#34;)
        cmd2 = &#34;flag2 = &#34; + cmd2.replace(&#34;$z&#34;, &#34;o.vertices[v2][2]&#34;)
        ccmd2 = compile(cmd2, &#39;&#39;, &#39;single&#39;)
    
        cmd3 = teststr.replace(&#34;$x&#34;, &#34;o.vertices[v3][0]&#34;)
        cmd3 = cmd3.replace(&#34;$y&#34;, &#34;o.vertices[v3][1]&#34;)
        cmd3 = &#34;flag3 = &#34; + cmd3.replace(&#34;$z&#34;, &#34;o.vertices[v3][2]&#34;)
        ccmd3 = compile(cmd3, &#39;&#39;, &#39;single&#39;)
    
        # Loop over triangles in id_surf
        for tri in o.triangles:
            v1 = tri[0] - 1
            v2 = tri[1] - 1
            v3 = tri[2] - 1
            exec(ccmd1)
            exec(ccmd2)
            exec(ccmd3)
            if flag1 and flag2 and flag3:
                obj.vertices.append(o.vertices[v1][:])
                obj.vertices.append(o.vertices[v2][:])
                obj.vertices.append(o.vertices[v3][:])
                obj.triangles.append([obj.nvert+1, obj.nvert+2, obj.nvert+3])
                obj.nvert += 3
                obj.ntri += 1
    
        # Make any connections in new set of triangles
        obj.connections = connect(obj.nvert, obj.ntri, obj.triangles)
        obj.center()
    
    # --------------------------------------------------------------------
    # Set Binning Parameters for a Surface
    
    def bins(self, id, nx, ny):
        &#34;&#34;&#34;
        Set binning parameters for a surface.

        Parameters:
            id (str): Identifier of the surface.
            nx (int): Number of bins in the x-direction.
            ny (int): Number of bins in the y-direction.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style != SURFACE:
            raise Exception(&#34;Can only set bins for surface&#34;)
        obj.nbinx = nx
        obj.nbiny = ny
    
    # --------------------------------------------------------------------
    # Create a Group Object with N Particles Inside and Outside Constraints
    
    def part(self, id, npart, in_id, out_id=None):
        &#34;&#34;&#34;
        Create a group with N particles inside a specified object and optionally outside another.

        Parameters:
            id (str): Unique identifier for the particle group.
            npart (int): Number of particles to create.
            in_id (str): Identifier of the object particles should be inside.
            out_id (str, optional): Identifier of the object particles should be outside.
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        obj = Group()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = GROUP
        obj.on_id = &#34;&#34;
        obj.npart = npart
        obj.xyz = []
    
        in_obj = self.objs[self.ids[in_id]]
        if out_id:
            out_obj = self.objs[self.ids[out_id]]
    
        # Pre-process SURFACE objects to bin their triangles for faster searching
        if in_obj.style == SURFACE:
            in_obj.inside_prep()
        if out_id and out_obj.style == SURFACE:
            out_obj.inside_prep()
    
        # Bounding box for generating points
        xlo, ylo, zlo, xhi, yhi, zhi = in_obj.bbox()
        xsize = xhi - xlo
        ysize = yhi - ylo
        zsize = zhi - zlo
    
        # Generate particles until have enough that satisfy in/out constraints
        count = attempt = 0
        while count &lt; npart:
            attempt += 1
            x = xlo + self.random() * xsize
            y = ylo + self.random() * ysize
            z = zlo + self.random() * zsize
            if not in_obj.inside(x, y, z):
                continue
            if out_id and out_obj.inside(x, y, z):
                continue
            obj.xyz.append([x, y, z])
            count += 1
    
        obj.center()
        print(f&#34;Created {count} particles in {attempt} attempts&#34;)
    
    # --------------------------------------------------------------------
    # Create a Group Object with N 2D Particles on a Surface
    
    def part2d(self, id, npart, on_id):
        &#34;&#34;&#34;
        Create a group with N 2D particles on a specified surface.

        Parameters:
            id (str): Unique identifier for the 2D particle group.
            npart (int): Number of particles to create.
            on_id (str): Identifier of the object particles should be on.
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        obj = Group()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = GROUP
        obj.on_id = on_id
        obj.npart = npart
        obj.xyz = []
    
        on_obj = self.objs[self.ids[on_id]]
        if on_obj.style not in [SURFACE, REGION, UNION]:
            raise Exception(&#34;Illegal ID to place particles on&#34;)
        totalarea = on_obj.area()
        
        for _ in range(npart):
            area = self.random() * totalarea
            pt, norm = on_obj.loc2d(area, self.random)
            obj.xyz.append(pt)
        
        obj.center()
        print(f&#34;Created {npart} particles on area of {totalarea}&#34;)
    
    # --------------------------------------------------------------------
    # Create a 3D Array of Particles
    
    def partarray(self, id, nx, ny, nz, x, y, z, dx, dy, dz):
        &#34;&#34;&#34;
        Create a 3D grid of particles.

        Parameters:
            id (str): Unique identifier for the particle array.
            nx, ny, nz (int): Number of particles in x, y, z directions.
            x, y, z (float): Starting coordinates.
            dx, dy, dz (float): Spacing between particles.
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        obj = Group()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = GROUP
        obj.on_id = &#34;&#34;
        obj.npart = nx * ny * nz
        obj.xyz = []
    
        for k in range(nz):
            znew = z + k * dz
            for j in range(ny):
                ynew = y + j * dy
                for i in range(nx):
                    xnew = x + i * dx
                    obj.xyz.append([xnew, ynew, znew])
                    
        obj.center()
        print(f&#34;Created {nx * ny * nz} particles&#34;)
    
    # --------------------------------------------------------------------
    # Create a Ring of Particles
    
    def partring(self, id, n, x, y, z, r, axis):
        &#34;&#34;&#34;
        Create a ring of N particles.

        Parameters:
            id (str): Unique identifier for the particle ring.
            n (int): Number of particles in the ring.
            x, y, z (float): Center coordinates of the ring.
            r (float): Radius of the ring.
            axis (str): Axis of the ring (&#39;x&#39;, &#39;y&#39;, or &#39;z&#39;).
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
    
        obj = Group()
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = GROUP
        obj.on_id = &#34;&#34;
        obj.npart = n
        obj.xyz = []
    
        deltheta = 2.0 * pi / n
        for i in range(n):
            theta = i * deltheta
            if axis == &#39;x&#39;:
                xnew = x
                ynew = y + r * cos(theta)
                znew = z + r * sin(theta)
            elif axis == &#39;y&#39;:
                xnew = x + r * cos(theta)
                ynew = y
                znew = z + r * sin(theta)
            elif axis == &#39;z&#39;:
                xnew = x + r * cos(theta)
                ynew = y + r * sin(theta)
                znew = z
            else:
                raise Exception(&#34;Invalid axis for partring()&#34;)
            obj.xyz.append([xnew, ynew, znew])
                
        obj.center()
        print(f&#34;Created {n} particles&#34;)
    
    # --------------------------------------------------------------------
    # Change Surface Assignment for a 2D Group of Particles
    
    def partsurf(self, id, on_id):
        &#34;&#34;&#34;
        Change the surface assignment for a 2D group of particles.

        Parameters:
            id (str): Identifier of the particle group.
            on_id (str): New surface identifier.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style != GROUP:
            raise Exception(&#34;Must use particle group with partsurf()&#34;)
        if not obj.on_id:
            raise Exception(&#34;Must use partsurf() with 2d particles&#34;)
        obj.on_id = on_id
    
    # --------------------------------------------------------------------
    # Set Random Number Seed
    
    def seed(self, new_seed):
        &#34;&#34;&#34;
        Set the random number generator seed.

        Parameters:
            new_seed (int): New seed value.
        &#34;&#34;&#34;
        self.random.seed = new_seed
    
    # --------------------------------------------------------------------
    # Pick a Random Point on Surface of Object
    
    def random(self, id):
        &#34;&#34;&#34;
        Pick a random point on the surface of the specified object.

        Parameters:
            id (str): Identifier of the surface or region.

        Returns:
            tuple: (point [x, y, z], normal vector [nx, ny, nz])
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style not in [SURFACE, REGION]:
            raise Exception(&#34;Must use surf or region with random()&#34;)
    
        totalarea = obj.area()
        area = self.random() * totalarea
        pt, norm = obj.loc2d(area, self.random)
        return pt, norm
    
    # --------------------------------------------------------------------
    # Project Particles to Surface of Another Object
    
    def project(self, id, id2, dx, dy, dz, EPS, flag=None):
        &#34;&#34;&#34;
        Project particles in group ID to the surface of object ID2.

        Parameters:
            id (str): Identifier of the particle group.
            id2 (str): Identifier of the target surface or region.
            dx, dy, dz (float): Direction components for projection.
            EPS (float): Epsilon value for proximity.
            flag (bool, optional): If True, direction is from particle to (dx, dy, dz).
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style != GROUP:
            raise Exception(&#34;Must use particle group as 1st obj of project()&#34;)
        obj_on = self.objs[self.ids[id2]]
        if obj_on.style not in [SURFACE, REGION]:
            raise Exception(&#34;Must use surf or region as 2nd obj of project()&#34;)
    
        # Pre-process SURFACE to bin its triangles for faster searching
        if obj_on.style == SURFACE:
            obj_on.inside_prep()
    
        # For each particle, move it in dir from current location
        # Move along dir until get within EPS of surf
        # factor = multiply bracketing distance by this amount each iteration
        # maxscale = max multiple of dir vector to bracket in each direction
    
        factor = 2
        maxscale = 10.0
    
        for i in range(obj.npart):
            x, y, z_coord = obj.xyz[i]
            if flag:
                dir_vector = [dx - x, dy - y, dz - z_coord]
            else:
                dir_vector = [dx, dy, dz]
            normalize(dir_vector)
            
            # Start = inside/outside at starting point
            # Stop = inside/outside at bracketing point
            start = obj_on.inside(x, y, z_coord)
            stop = 0 if start else 1
    
            # Iterate to find bracketing point or until scale dist &gt; maxdist
            # Bracket point = xyz +/- scale*dir
            # Multiply scale by factor each iteration
    
            scale = EPS
            bracket = start
            while scale &lt; maxscale:
                xnew = x + scale * dir_vector[0]
                ynew = y + scale * dir_vector[1]
                znew = z_coord + scale * dir_vector[2]
                bracket = obj_on.inside(xnew, ynew, znew)
                if bracket == stop:
                    break
                xnew_neg = x - scale * dir_vector[0]
                ynew_neg = y - scale * dir_vector[1]
                znew_neg = z_coord - scale * dir_vector[2]
                bracket = obj_on.inside(xnew_neg, ynew_neg, znew_neg)
                if bracket == stop:
                    xnew, ynew, znew = xnew_neg, ynew_neg, znew_neg
                    break
                scale *= factor
    
            if bracket == start:
                raise Exception(f&#34;Could not find bracket point for particle {i}&#34;)
    
            # Bisection search to zoom in to within EPS of surface
            # Separation = distance between 2 points
            delx = xnew - x
            dely = ynew - y
            delz = znew - z_coord
            separation = sqrt(delx**2 + dely**2 + delz**2)
            while separation &gt; EPS:
                xmid = 0.5 * (x + xnew)
                ymid = 0.5 * (y + ynew)
                zmid = 0.5 * (z_coord + znew)
                value = obj_on.inside(xmid, ymid, zmid)
                if value == start:
                    x, y, z_coord = xmid, ymid, zmid
                else:
                    xnew, ynew, znew = xmid, ymid, zmid
                delx = xnew - x
                dely = ynew - y
                delz = znew - z_coord
                separation = sqrt(delx**2 + dely**2 + delz**2)
    
            obj.xyz[i][0] = x
            obj.xyz[i][1] = y
            obj.xyz[i][2] = z_coord
    
        obj.on_id = id2
        obj.center()
    
    # --------------------------------------------------------------------
    # Set Center Point of an Object
    
    def center(self, id, x, y, z):
        &#34;&#34;&#34;
        Set the center point of an object.

        Parameters:
            id (str): Identifier of the object.
            x, y, z (float): New center coordinates.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style not in [SURFACE, GROUP]:
            raise Exception(&#34;Can only use center() on a surface or group object&#34;)
        obj.center(x, y, z)
    
    # --------------------------------------------------------------------
    # Translate an Object by dx, dy, dz
    
    def trans(self, id, dx, dy, dz):
        &#34;&#34;&#34;
        Translate an object by a displacement.

        Parameters:
            id (str): Identifier of the object.
            dx, dy, dz (float): Displacement along x, y, z axes.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style not in [SURFACE, GROUP]:
            raise Exception(&#34;Can only use trans() on a surface or group object&#34;)
        obj.xc += dx
        obj.yc += dy
        obj.zc += dz
    
        # Apply translation to each vertex or particle coordinate
        if obj.style == SURFACE:
            for vert in obj.vertices:
                vert[0] += dx
                vert[1] += dy
                vert[2] += dz
        elif obj.style == GROUP:
            for particle in obj.xyz:
                particle[0] += dx
                particle[1] += dy
                particle[2] += dz
    
    # --------------------------------------------------------------------
    # Rotate an Object to Align Current Axes with New Axes
    
    def rotate(self, id, axis1, i1, j1, k1, axis2, i2, j2, k2):
        &#34;&#34;&#34;
        Rotate an object so that its current axes align with new ones.

        Parameters:
            id (str): Identifier of the object.
            axis1 (str): First axis to rotate (&#39;x&#39;, &#39;y&#39;, &#39;z&#39;).
            i1, j1, k1 (float): Direction cosines for the first new axis.
            axis2 (str): Second axis to rotate (&#39;x&#39;, &#39;y&#39;, &#39;z&#39;).
            i2, j2, k2 (float): Direction cosines for the second new axis.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style not in [SURFACE, GROUP]:
            raise Exception(&#34;Can only use rotate() on a surface or group object&#34;)
    
        # Create new axes
        new_axes = {&#39;x&#39;: None, &#39;y&#39;: None, &#39;z&#39;: None}
        if axis1 in new_axes:
            new_axes[axis1] = [i1, j1, k1]
        else:
            raise Exception(&#34;Invalid axis for rotate()&#34;)
        
        if axis2 in new_axes:
            new_axes[axis2] = [i2, j2, k2]
        else:
            raise Exception(&#34;Invalid axis for rotate()&#34;)
    
        # Infer the third axis
        axes = [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]
        missing_axis = next((ax for ax in axes if new_axes[ax] is None), None)
        if missing_axis is None:
            raise Exception(&#34;All three axes are already defined&#34;)
        other_axes = [ax for ax in axes if ax != missing_axis]
        new_axes[missing_axis] = cross(new_axes[other_axes[0]], new_axes[other_axes[1]])
        normalize(new_axes[missing_axis])
    
        # Orthonormalize the axes
        normalize(new_axes[&#39;x&#39;])
        normalize(new_axes[&#39;y&#39;])
        normalize(new_axes[&#39;z&#39;])
    
        # Apply rotation matrix to each vertex or particle coordinate
        if obj.style == SURFACE:
            for vert in obj.vertices:
                x = vert[0] - obj.xc
                y = vert[1] - obj.yc
                z = vert[2] - obj.zc
                xn = new_axes[&#39;x&#39;][0]*x + new_axes[&#39;x&#39;][1]*y + new_axes[&#39;x&#39;][2]*z
                yn = new_axes[&#39;y&#39;][0]*x + new_axes[&#39;y&#39;][1]*y + new_axes[&#39;y&#39;][2]*z
                zn = new_axes[&#39;z&#39;][0]*x + new_axes[&#39;z&#39;][1]*y + new_axes[&#39;z&#39;][2]*z
                vert[0] = xn + obj.xc
                vert[1] = yn + obj.yc
                vert[2] = zn + obj.zc
        elif obj.style == GROUP:
            for particle in obj.xyz:
                x = particle[0] - obj.xc
                y = particle[1] - obj.yc
                z = particle[2] - obj.zc
                xn = new_axes[&#39;x&#39;][0]*x + new_axes[&#39;x&#39;][1]*y + new_axes[&#39;x&#39;][2]*z
                yn = new_axes[&#39;y&#39;][0]*x + new_axes[&#39;y&#39;][1]*y + new_axes[&#39;y&#39;][2]*z
                zn = new_axes[&#39;z&#39;][0]*x + new_axes[&#39;z&#39;][1]*y + new_axes[&#39;z&#39;][2]*z
                particle[0] = xn + obj.xc
                particle[1] = yn + obj.yc
                particle[2] = zn + obj.zc
    
    # --------------------------------------------------------------------
    # Scale an Object by sx, sy, sz Factors
    
    def scale(self, id, sx, sy, sz):
        &#34;&#34;&#34;
        Scale an object by specified factors along each axis.

        Parameters:
            id (str): Identifier of the object.
            sx, sy, sz (float): Scaling factors along x, y, z axes.
        &#34;&#34;&#34;
        obj = self.objs[self.ids[id]]
        if obj.style not in [SURFACE, GROUP]:
            raise Exception(&#34;Can only use scale() on a surface or group object&#34;)
        if obj.style == SURFACE:
            for vert in obj.vertices:
                vert[0] = obj.xc + sx * (vert[0] - obj.xc)
                vert[1] = obj.yc + sy * (vert[1] - obj.yc)
                vert[2] = obj.zc + sz * (vert[2] - obj.zc)
        elif obj.style == GROUP:
            for particle in obj.xyz:
                particle[0] = obj.xc + sx * (particle[0] - obj.xc)
                particle[1] = obj.yc + sy * (particle[1] - obj.yc)
                particle[2] = obj.zc + sz * (particle[2] - obj.zc)
    
    # --------------------------------------------------------------------
    # Create a Union Object from Other Objects
    
    def union(self, id, *list_ids):
        &#34;&#34;&#34;
        Create a union object from a list of other objects.

        Parameters:
            id (str): Unique identifier for the union.
            *list_ids: Identifiers of objects to include in the union.
        &#34;&#34;&#34;
        if id in self.ids:
            raise Exception(f&#34;ID {id} is already in use&#34;)
        obj = Union(self.ids, self.objs, *list_ids)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = UNION
    
    # --------------------------------------------------------------------
    # Join Objects to Form a New Object
    
    def join(self, id, *list_ids):
        &#34;&#34;&#34;
        Join multiple objects of the same style into a new object.

        Parameters:
            id (str): Unique identifier for the new joined object.
            *list_ids: Identifiers of objects to join.
        &#34;&#34;&#34;
        if not list_ids:
            raise Exception(&#34;No objects provided to join&#34;)
        style = self.objs[self.ids[list_ids[0]]].style
        if style == GROUP:
            obj = Group()
        elif style == SURFACE:
            obj = Surface()
        elif style == LINE:
            obj = Line()
        else:
            raise Exception(&#34;Cannot perform join on these object styles&#34;)
        obj.select = 1
        self.ids[id] = len(self.objs)
        self.objs.append(obj)
        obj.id = id
        obj.style = style
    
        if style == GROUP:
            obj.on_id = self.objs[self.ids[list_ids[0]]].on_id
            obj.npart = 0
            obj.xyz = []
        elif style == SURFACE:
            obj.nvert = obj.ntri = 0
            obj.vertices = []
            obj.triangles = []
            obj.connections = []
        elif style == LINE:
            obj.nline = 0
            obj.pairs = []
            
        for obj_id in list_ids:
            o = self.objs[self.ids[obj_id]]
            if o.style != style:
                raise Exception(&#34;All joined objects must be of same style&#34;)
    
            # Force deep copy of particle coordinates
            if style == GROUP:
                if o.on_id != obj.on_id:
                    raise Exception(&#34;Particle group surfaces do not match&#34;)
                for xyz in o.xyz:
                    obj.xyz.append(xyz[:])
                obj.npart += o.npart
                obj.center()
                
            # Force deep copy of triangle vertices and indices
            elif style == SURFACE:
                for vert in o.vertices:
                    obj.vertices.append(vert[:])
                for tri in o.triangles:
                    obj.triangles.append([tri[0]+obj.nvert, tri[1]+obj.nvert, tri[2]+obj.nvert])
                for conn in o.connections:
                    new_conn = conn[:]
                    if new_conn[0]:
                        new_conn[0] += obj.ntri
                    if new_conn[2]:
                        new_conn[2] += obj.ntri
                    if new_conn[4]:
                        new_conn[4] += obj.ntri
                    obj.connections.append(new_conn)
                obj.nvert += o.nvert
                obj.ntri += o.ntri
                obj.center()
    
            # Force deep copy of line point pairs
            elif style == LINE:
                obj.pairs += o.pairs[:]
                obj.nline += o.nline
    
    # --------------------------------------------------------------------
    # Delete Objects from the cdata
    
    def delete(self, *list_ids):
        &#34;&#34;&#34;
        Delete objects from the cdata.

        Parameters:
            *list_ids: Identifiers of objects to delete.
        &#34;&#34;&#34;
        for id in list_ids:
            if id not in self.ids:
                raise Exception(f&#34;ID {id} does not exist&#34;)
            i = self.ids[id]
            del self.ids[id]
            del self.objs[i]
            # Update indices in self.ids
            for key in self.ids:
                if self.ids[key] &gt; i:
                    self.ids[key] -= 1
    
    # --------------------------------------------------------------------
    # Rename an Object
    
    def rename(self, id_old, id_new):
        &#34;&#34;&#34;
        Rename an object.

        Parameters:
            id_old (str): Current identifier of the object.
            id_new (str): New identifier for the object.
        &#34;&#34;&#34;
        if id_new in self.ids:
            raise Exception(f&#34;ID {id_new} is already in use&#34;)
        if id_old not in self.ids:
            raise Exception(f&#34;ID {id_old} does not exist&#34;)
        i = self.ids[id_old]
        self.ids[id_new] = i
        self.objs[i].id = id_new
        del self.ids[id_old]
    
    # --------------------------------------------------------------------
    # Create a Deep Copy of an Object with a New ID
    
    def copy(self, id_old, id_new):
        &#34;&#34;&#34;
        Create a deep copy of an object with a new identifier.

        Parameters:
            id_old (str): Identifier of the object to copy.
            id_new (str): New identifier for the copied object.
        &#34;&#34;&#34;
        if id_new in self.ids:
            raise Exception(f&#34;ID {id_new} is already in use&#34;)
        if id_old not in self.ids:
            raise Exception(f&#34;ID {id_old} does not exist&#34;)
        obj = deepcopy(self.objs[self.ids[id_old]])
        obj.select = 1
        self.ids[id_new] = len(self.objs)
        self.objs.append(obj)
        obj.id = id_new
    
    # --------------------------------------------------------------------
    # Select Objects
    
    def select(self, *list_ids):
        &#34;&#34;&#34;
        Select one or more objects.

        Parameters:
            *list_ids: Identifiers of objects to select. If empty, selects all.
        &#34;&#34;&#34;
        if not list_ids:
            list_ids = self.ids.keys()
        for id in list_ids:
            if id not in self.ids:
                raise Exception(f&#34;ID {id} does not exist&#34;)
            obj = self.objs[self.ids[id]]
            obj.select = 1
    
    # --------------------------------------------------------------------
    # Unselect Objects
    
    def unselect(self, *list_ids):
        &#34;&#34;&#34;
        Unselect one or more objects.

        Parameters:
            *list_ids: Identifiers of objects to unselect. If empty, unselects all.
        &#34;&#34;&#34;
        if not list_ids:
            list_ids = self.ids.keys()
        for id in list_ids:
            if id not in self.ids:
                raise Exception(f&#34;ID {id} does not exist&#34;)
            obj = self.objs[self.ids[id]]
            obj.select = 0
    
    # --------------------------------------------------------------------
    # Write Objects to ChemCell Data File
    
    def write(self, file, *list_ids):
        &#34;&#34;&#34;
        Write selected objects to a ChemCell data file.

        Parameters:
            file (str): Filename to write to.
            *list_ids: Identifiers of objects to write. If empty, writes all selected.
        &#34;&#34;&#34;
        if not list_ids:
            vlist = list(range(len(self.objs)))
        else:
            vlist = []
            for id in list_ids:
                if id not in self.ids:
                    raise Exception(f&#34;ID {id} does not exist&#34;)
                vlist.append(self.ids[id])
    
        with open(file, &#39;w&#39;) as fp:
            self.filewrite(fp, vlist)
    
    # --------------------------------------------------------------------
    # Append Objects to an Existing ChemCell Data File
    
    def append(self, file, *list_ids):
        &#34;&#34;&#34;
        Append selected objects to an existing ChemCell data file.

        Parameters:
            file (str): Filename to append to.
            *list_ids: Identifiers of objects to append. If empty, appends all selected.
        &#34;&#34;&#34;
        if not list_ids:
            vlist = list(range(len(self.objs)))
        else:
            vlist = []
            for id in list_ids:
                if id not in self.ids:
                    raise Exception(f&#34;ID {id} does not exist&#34;)
                vlist.append(self.ids[id])
    
        with open(file, &#39;a&#39;) as fp:
            self.filewrite(fp, vlist)
    
    # --------------------------------------------------------------------
    # Write Objects to an Opened Data File
    
    def filewrite(self, fp, vlist):
        &#34;&#34;&#34;
        Write objects to an already opened data file.

        Parameters:
            fp (file object): Opened file object to write to.
            vlist (list): List of object indices to write.
        &#34;&#34;&#34;
        for index in vlist:
            obj = self.objs[index]
            if not obj.select:
                continue
            if obj.style == GROUP:
                if not obj.on_id:
                    print(f&#34;particles {obj.id} {obj.npart}&#34;, file=fp)
                else:
                    print(f&#34;particles {obj.id} {obj.npart} {obj.on_id}&#34;, file=fp)
                print(file=fp)
                for i, xyz in enumerate(obj.xyz, start=1):
                    print(f&#34;{i} {xyz[0]} {xyz[1]} {xyz[2]}&#34;, file=fp)
                print(file=fp)
            if obj.style == SURFACE:
                print(f&#34;triangles {obj.id} {obj.nvert} {obj.ntri}&#34;, file=fp)
                print(file=fp)
                for i, vert in enumerate(obj.vertices, start=1):
                    print(f&#34;{i} {vert[0]} {vert[1]} {vert[2]}&#34;, file=fp)
                for i, tri in enumerate(obj.triangles, start=1):
                    print(f&#34;{i} {tri[0]} {tri[1]} {tri[2]}&#34;, file=fp)
                for i, conn in enumerate(obj.connections, start=1):
                    print(f&#34;{i} {conn[0]} {conn[1]} {conn[2]} {conn[3]} {conn[4]} {conn[5]}&#34;, file=fp)
            if obj.style == REGION:
                print(f&#34;region {obj.command()}&#34;, file=fp)
    
    # --------------------------------------------------------------------
    # Iterator Method for Other Tools
    
    def iterator(self, flag):
        &#34;&#34;&#34;
        Iterator method compatible with equivalent dump calls.

        Parameters:
            flag (int): 0 for first call, 1 for subsequent calls.

        Returns:
            tuple: (index, time, flag)
        &#34;&#34;&#34;
        if flag == 0:
            return (0, 0, 1)
        return (0, 0, -1)
    
    # --------------------------------------------------------------------
    # Visualization Method
    
    def viz(self, isnap):
        &#34;&#34;&#34;
        Return list of atoms, bonds, tris, and lines for visualization.

        Parameters:
            isnap (int): Snapshot index. Must be 0 for cdata.

        Returns:
            tuple: (time, box, atoms, bonds, tris, lines)
        &#34;&#34;&#34;
        if isnap:
            raise Exception(&#34;cannot call cdata.viz() with isnap != 0&#34;)
        
        # Create atom list from sum of all particle groups
        # id = running count
        # type = running type of particle group
    
        id_count = itype = 0
        atoms = []
        for obj in self.objs:
            if obj.style != GROUP:
                continue
            if not obj.select:
                continue
            itype += 1
            for xyz in obj.xyz:
                id_count += 1
                atoms.append([id_count, itype, xyz[0], xyz[1], xyz[2]])
    
        # No bonds
        bonds = []
    
        # Create triangle list from sum of all surfaces and regions
        # id = running count
        # type = type of set of tris
    
        id_count = itype = 0
        tris = []
        for obj in self.objs:
            if obj.style not in [SURFACE, REGION]:
                continue
            if not obj.select:
                continue
            if obj.style == REGION:
                obj.triangulate()
            itype += 1
            for tri in obj.triangles:
                v1 = obj.vertices[tri[0]-1]
                v2 = obj.vertices[tri[1]-1]
                v3 = obj.vertices[tri[2]-1]
                list_vertices = v1 + v2 + v3
                n = normal(list_vertices[0:3], list_vertices[3:6], list_vertices[6:9])
                id_count += 1
                tris.append([id_count, itype] + list_vertices + n)
    
        # Create line list from sum of all line objects
        id_count = itype = 0
        lines = []
        for obj in self.objs:
            if obj.style != LINE:
                continue
            if not obj.select:
                continue
            itype += 1
            for pair in obj.pairs:
                id_count += 1
                lines.append([id_count, itype] + pair)
        
        return (0, self.bbox(), atoms, bonds, tris, lines)
    
    # --------------------------------------------------------------------
    # Find Time Method (Not Applicable for cdata)
    
    def findtime(self, n):
        &#34;&#34;&#34;
        Find the index of a given timestep.

        Parameters:
            n (int): The timestep to find.

        Returns:
            int: The index of the timestep.

        Raises:
            Exception: Always, since cdata does not support multiple timesteps.
        &#34;&#34;&#34;
        if n == 0:
            return 0
        raise Exception(f&#34;no step {n} exists&#34;)
    
    # --------------------------------------------------------------------
    # Return Bounding Box that Encloses All Selected Objects
    
    def maxbox(self):
        &#34;&#34;&#34;
        Return the bounding box that encloses all selected objects.

        Returns:
            tuple: (xlo, ylo, zlo, xhi, yhi, zhi)
        &#34;&#34;&#34;
        return self.bbox()
    
    # --------------------------------------------------------------------
    # Return Bounding Box that Encloses All Selected Objects
    
    def bbox(self):
        &#34;&#34;&#34;
        Compute the bounding box that encloses all selected objects.

        Returns:
            tuple: (xlo, ylo, zlo, xhi, yhi, zhi)
        &#34;&#34;&#34;
        xlo = ylo = zlo = float(&#39;inf&#39;)
        xhi = yhi = zhi = float(&#39;-inf&#39;)
        for obj in self.objs:
            if not obj.select:
                continue
            xxlo, yylo, zzlo, xxhi, yyhi, zzhi = obj.bbox()
            xlo = min(xxlo, xlo)
            ylo = min(yylo, ylo)
            zlo = min(zzlo, zlo)
            xhi = max(xxhi, xhi)
            yhi = max(yyhi, yhi)
            zhi = max(zzhi, zhi)
    
        return (xlo, ylo, zlo, xhi, yhi, zhi)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cdata3.cdata.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, file, *list_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Append selected objects to an existing ChemCell data file.</p>
<h2 id="parameters">Parameters</h2>
<p>file (str): Filename to append to.
*list_ids: Identifiers of objects to append. If empty, appends all selected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, file, *list_ids):
    &#34;&#34;&#34;
    Append selected objects to an existing ChemCell data file.

    Parameters:
        file (str): Filename to append to.
        *list_ids: Identifiers of objects to append. If empty, appends all selected.
    &#34;&#34;&#34;
    if not list_ids:
        vlist = list(range(len(self.objs)))
    else:
        vlist = []
        for id in list_ids:
            if id not in self.ids:
                raise Exception(f&#34;ID {id} does not exist&#34;)
            vlist.append(self.ids[id])

    with open(file, &#39;a&#39;) as fp:
        self.filewrite(fp, vlist)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.bbox"><code class="name flex">
<span>def <span class="ident">bbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the bounding box that encloses all selected objects.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(xlo, ylo, zlo, xhi, yhi, zhi)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox(self):
    &#34;&#34;&#34;
    Compute the bounding box that encloses all selected objects.

    Returns:
        tuple: (xlo, ylo, zlo, xhi, yhi, zhi)
    &#34;&#34;&#34;
    xlo = ylo = zlo = float(&#39;inf&#39;)
    xhi = yhi = zhi = float(&#39;-inf&#39;)
    for obj in self.objs:
        if not obj.select:
            continue
        xxlo, yylo, zzlo, xxhi, yyhi, zzhi = obj.bbox()
        xlo = min(xxlo, xlo)
        ylo = min(yylo, ylo)
        zlo = min(zzlo, zlo)
        xhi = max(xxhi, xhi)
        yhi = max(yyhi, yhi)
        zhi = max(zzhi, zhi)

    return (xlo, ylo, zlo, xhi, yhi, zhi)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.bins"><code class="name flex">
<span>def <span class="ident">bins</span></span>(<span>self, id, nx, ny)</span>
</code></dt>
<dd>
<div class="desc"><p>Set binning parameters for a surface.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Identifier of the surface.
nx (int): Number of bins in the x-direction.
ny (int): Number of bins in the y-direction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bins(self, id, nx, ny):
    &#34;&#34;&#34;
    Set binning parameters for a surface.

    Parameters:
        id (str): Identifier of the surface.
        nx (int): Number of bins in the x-direction.
        ny (int): Number of bins in the y-direction.
    &#34;&#34;&#34;
    obj = self.objs[self.ids[id]]
    if obj.style != SURFACE:
        raise Exception(&#34;Can only set bins for surface&#34;)
    obj.nbinx = nx
    obj.nbiny = ny</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.box"><code class="name flex">
<span>def <span class="ident">box</span></span>(<span>self, id, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a box region.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the box.
args: xlo, ylo, zlo, xhi, yhi, zhi</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def box(self, id, *args):
    &#34;&#34;&#34;
    Create a box region.

    Parameters:
        id (str): Unique identifier for the box.
        args: xlo, ylo, zlo, xhi, yhi, zhi
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)
    obj = Box(*args)
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = REGION
    obj.substyle = BOX</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.cap"><code class="name flex">
<span>def <span class="ident">cap</span></span>(<span>self, id, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a capped-cylinder region.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the capped-cylinder.
args: axis, c1, c2, r, lo, hi</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cap(self, id, *args):
    &#34;&#34;&#34;
    Create a capped-cylinder region.

    Parameters:
        id (str): Unique identifier for the capped-cylinder.
        args: axis, c1, c2, r, lo, hi
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)
    obj = Capped(*args)
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = REGION
    obj.substyle = CAPPED</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self, id, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the center point of an object.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Identifier of the object.
x, y, z (float): New center coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(self, id, x, y, z):
    &#34;&#34;&#34;
    Set the center point of an object.

    Parameters:
        id (str): Identifier of the object.
        x, y, z (float): New center coordinates.
    &#34;&#34;&#34;
    obj = self.objs[self.ids[id]]
    if obj.style not in [SURFACE, GROUP]:
        raise Exception(&#34;Can only use center() on a surface or group object&#34;)
    obj.center(x, y, z)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, id_old, id_new)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a deep copy of an object with a new identifier.</p>
<h2 id="parameters">Parameters</h2>
<p>id_old (str): Identifier of the object to copy.
id_new (str): New identifier for the copied object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, id_old, id_new):
    &#34;&#34;&#34;
    Create a deep copy of an object with a new identifier.

    Parameters:
        id_old (str): Identifier of the object to copy.
        id_new (str): New identifier for the copied object.
    &#34;&#34;&#34;
    if id_new in self.ids:
        raise Exception(f&#34;ID {id_new} is already in use&#34;)
    if id_old not in self.ids:
        raise Exception(f&#34;ID {id_old} does not exist&#34;)
    obj = deepcopy(self.objs[self.ids[id_old]])
    obj.select = 1
    self.ids[id_new] = len(self.objs)
    self.objs.append(obj)
    obj.id = id_new</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.cyl"><code class="name flex">
<span>def <span class="ident">cyl</span></span>(<span>self, id, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a cylinder region.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the cylinder.
args: axis, c1, c2, r, lo, hi</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cyl(self, id, *args):
    &#34;&#34;&#34;
    Create a cylinder region.

    Parameters:
        id (str): Unique identifier for the cylinder.
        args: axis, c1, c2, r, lo, hi
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)
    obj = Cylinder(*args)
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = REGION
    obj.substyle = CYLINDER</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, *list_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete objects from the cdata.</p>
<h2 id="parameters">Parameters</h2>
<p>*list_ids: Identifiers of objects to delete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, *list_ids):
    &#34;&#34;&#34;
    Delete objects from the cdata.

    Parameters:
        *list_ids: Identifiers of objects to delete.
    &#34;&#34;&#34;
    for id in list_ids:
        if id not in self.ids:
            raise Exception(f&#34;ID {id} does not exist&#34;)
        i = self.ids[id]
        del self.ids[id]
        del self.objs[i]
        # Update indices in self.ids
        for key in self.ids:
            if self.ids[key] &gt; i:
                self.ids[key] -= 1</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.filewrite"><code class="name flex">
<span>def <span class="ident">filewrite</span></span>(<span>self, fp, vlist)</span>
</code></dt>
<dd>
<div class="desc"><p>Write objects to an already opened data file.</p>
<h2 id="parameters">Parameters</h2>
<p>fp (file object): Opened file object to write to.
vlist (list): List of object indices to write.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filewrite(self, fp, vlist):
    &#34;&#34;&#34;
    Write objects to an already opened data file.

    Parameters:
        fp (file object): Opened file object to write to.
        vlist (list): List of object indices to write.
    &#34;&#34;&#34;
    for index in vlist:
        obj = self.objs[index]
        if not obj.select:
            continue
        if obj.style == GROUP:
            if not obj.on_id:
                print(f&#34;particles {obj.id} {obj.npart}&#34;, file=fp)
            else:
                print(f&#34;particles {obj.id} {obj.npart} {obj.on_id}&#34;, file=fp)
            print(file=fp)
            for i, xyz in enumerate(obj.xyz, start=1):
                print(f&#34;{i} {xyz[0]} {xyz[1]} {xyz[2]}&#34;, file=fp)
            print(file=fp)
        if obj.style == SURFACE:
            print(f&#34;triangles {obj.id} {obj.nvert} {obj.ntri}&#34;, file=fp)
            print(file=fp)
            for i, vert in enumerate(obj.vertices, start=1):
                print(f&#34;{i} {vert[0]} {vert[1]} {vert[2]}&#34;, file=fp)
            for i, tri in enumerate(obj.triangles, start=1):
                print(f&#34;{i} {tri[0]} {tri[1]} {tri[2]}&#34;, file=fp)
            for i, conn in enumerate(obj.connections, start=1):
                print(f&#34;{i} {conn[0]} {conn[1]} {conn[2]} {conn[3]} {conn[4]} {conn[5]}&#34;, file=fp)
        if obj.style == REGION:
            print(f&#34;region {obj.command()}&#34;, file=fp)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.findtime"><code class="name flex">
<span>def <span class="ident">findtime</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the index of a given timestep.</p>
<h2 id="parameters">Parameters</h2>
<p>n (int): The timestep to find.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The index of the timestep.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Always, since cdata does not support multiple timesteps.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findtime(self, n):
    &#34;&#34;&#34;
    Find the index of a given timestep.

    Parameters:
        n (int): The timestep to find.

    Returns:
        int: The index of the timestep.

    Raises:
        Exception: Always, since cdata does not support multiple timesteps.
    &#34;&#34;&#34;
    if n == 0:
        return 0
    raise Exception(f&#34;no step {n} exists&#34;)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.iterator"><code class="name flex">
<span>def <span class="ident">iterator</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterator method compatible with equivalent dump calls.</p>
<h2 id="parameters">Parameters</h2>
<p>flag (int): 0 for first call, 1 for subsequent calls.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(index, time, flag)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterator(self, flag):
    &#34;&#34;&#34;
    Iterator method compatible with equivalent dump calls.

    Parameters:
        flag (int): 0 for first call, 1 for subsequent calls.

    Returns:
        tuple: (index, time, flag)
    &#34;&#34;&#34;
    if flag == 0:
        return (0, 0, 1)
    return (0, 0, -1)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, id, *list_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Join multiple objects of the same style into a new object.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the new joined object.
*list_ids: Identifiers of objects to join.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self, id, *list_ids):
    &#34;&#34;&#34;
    Join multiple objects of the same style into a new object.

    Parameters:
        id (str): Unique identifier for the new joined object.
        *list_ids: Identifiers of objects to join.
    &#34;&#34;&#34;
    if not list_ids:
        raise Exception(&#34;No objects provided to join&#34;)
    style = self.objs[self.ids[list_ids[0]]].style
    if style == GROUP:
        obj = Group()
    elif style == SURFACE:
        obj = Surface()
    elif style == LINE:
        obj = Line()
    else:
        raise Exception(&#34;Cannot perform join on these object styles&#34;)
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = style

    if style == GROUP:
        obj.on_id = self.objs[self.ids[list_ids[0]]].on_id
        obj.npart = 0
        obj.xyz = []
    elif style == SURFACE:
        obj.nvert = obj.ntri = 0
        obj.vertices = []
        obj.triangles = []
        obj.connections = []
    elif style == LINE:
        obj.nline = 0
        obj.pairs = []
        
    for obj_id in list_ids:
        o = self.objs[self.ids[obj_id]]
        if o.style != style:
            raise Exception(&#34;All joined objects must be of same style&#34;)

        # Force deep copy of particle coordinates
        if style == GROUP:
            if o.on_id != obj.on_id:
                raise Exception(&#34;Particle group surfaces do not match&#34;)
            for xyz in o.xyz:
                obj.xyz.append(xyz[:])
            obj.npart += o.npart
            obj.center()
            
        # Force deep copy of triangle vertices and indices
        elif style == SURFACE:
            for vert in o.vertices:
                obj.vertices.append(vert[:])
            for tri in o.triangles:
                obj.triangles.append([tri[0]+obj.nvert, tri[1]+obj.nvert, tri[2]+obj.nvert])
            for conn in o.connections:
                new_conn = conn[:]
                if new_conn[0]:
                    new_conn[0] += obj.ntri
                if new_conn[2]:
                    new_conn[2] += obj.ntri
                if new_conn[4]:
                    new_conn[4] += obj.ntri
                obj.connections.append(new_conn)
            obj.nvert += o.nvert
            obj.ntri += o.ntri
            obj.center()

        # Force deep copy of line point pairs
        elif style == LINE:
            obj.pairs += o.pairs[:]
            obj.nline += o.nline</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.lbox"><code class="name flex">
<span>def <span class="ident">lbox</span></span>(<span>self, id, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a line object with 12 lines representing a box.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the line box.
args: xlo, ylo, zlo, xhi, yhi, zhi</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lbox(self, id, *args):
    &#34;&#34;&#34;
    Create a line object with 12 lines representing a box.

    Parameters:
        id (str): Unique identifier for the line box.
        args: xlo, ylo, zlo, xhi, yhi, zhi
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)
    obj = Line()
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = LINE
    obj.nline = 0
    obj.pairs = []
    
    xlo, ylo, zlo, xhi, yhi, zhi = args
    obj.addline([xlo, ylo, zlo, xhi, ylo, zlo])
    obj.addline([xlo, yhi, zlo, xhi, yhi, zlo])
    obj.addline([xlo, yhi, zhi, xhi, yhi, zhi])
    obj.addline([xlo, ylo, zhi, xhi, ylo, zhi])
    obj.addline([xlo, ylo, zlo, xlo, yhi, zlo])
    obj.addline([xhi, ylo, zlo, xhi, yhi, zlo])
    obj.addline([xhi, ylo, zhi, xhi, yhi, zhi])
    obj.addline([xlo, ylo, zhi, xlo, yhi, zhi])
    obj.addline([xlo, ylo, zlo, xlo, ylo, zhi])
    obj.addline([xhi, ylo, zlo, xhi, ylo, zhi])
    obj.addline([xhi, yhi, zlo, xhi, yhi, zhi])
    obj.addline([xlo, yhi, zlo, xlo, yhi, zhi])</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>self, id, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a line object with a single line.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the line.
args: x1, y1, z1, x2, y2, z2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def line(self, id, *args):
    &#34;&#34;&#34;
    Create a line object with a single line.

    Parameters:
        id (str): Unique identifier for the line.
        args: x1, y1, z1, x2, y2, z2
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)
    obj = Line()
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = LINE
    obj.nline = 0
    obj.pairs = []
    
    obj.addline(args)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.maxbox"><code class="name flex">
<span>def <span class="ident">maxbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the bounding box that encloses all selected objects.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(xlo, ylo, zlo, xhi, yhi, zhi)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxbox(self):
    &#34;&#34;&#34;
    Return the bounding box that encloses all selected objects.

    Returns:
        tuple: (xlo, ylo, zlo, xhi, yhi, zhi)
    &#34;&#34;&#34;
    return self.bbox()</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.part"><code class="name flex">
<span>def <span class="ident">part</span></span>(<span>self, id, npart, in_id, out_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a group with N particles inside a specified object and optionally outside another.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the particle group.
npart (int): Number of particles to create.
in_id (str): Identifier of the object particles should be inside.
out_id (str, optional): Identifier of the object particles should be outside.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def part(self, id, npart, in_id, out_id=None):
    &#34;&#34;&#34;
    Create a group with N particles inside a specified object and optionally outside another.

    Parameters:
        id (str): Unique identifier for the particle group.
        npart (int): Number of particles to create.
        in_id (str): Identifier of the object particles should be inside.
        out_id (str, optional): Identifier of the object particles should be outside.
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)

    obj = Group()
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = GROUP
    obj.on_id = &#34;&#34;
    obj.npart = npart
    obj.xyz = []

    in_obj = self.objs[self.ids[in_id]]
    if out_id:
        out_obj = self.objs[self.ids[out_id]]

    # Pre-process SURFACE objects to bin their triangles for faster searching
    if in_obj.style == SURFACE:
        in_obj.inside_prep()
    if out_id and out_obj.style == SURFACE:
        out_obj.inside_prep()

    # Bounding box for generating points
    xlo, ylo, zlo, xhi, yhi, zhi = in_obj.bbox()
    xsize = xhi - xlo
    ysize = yhi - ylo
    zsize = zhi - zlo

    # Generate particles until have enough that satisfy in/out constraints
    count = attempt = 0
    while count &lt; npart:
        attempt += 1
        x = xlo + self.random() * xsize
        y = ylo + self.random() * ysize
        z = zlo + self.random() * zsize
        if not in_obj.inside(x, y, z):
            continue
        if out_id and out_obj.inside(x, y, z):
            continue
        obj.xyz.append([x, y, z])
        count += 1

    obj.center()
    print(f&#34;Created {count} particles in {attempt} attempts&#34;)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.part2d"><code class="name flex">
<span>def <span class="ident">part2d</span></span>(<span>self, id, npart, on_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a group with N 2D particles on a specified surface.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the 2D particle group.
npart (int): Number of particles to create.
on_id (str): Identifier of the object particles should be on.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def part2d(self, id, npart, on_id):
    &#34;&#34;&#34;
    Create a group with N 2D particles on a specified surface.

    Parameters:
        id (str): Unique identifier for the 2D particle group.
        npart (int): Number of particles to create.
        on_id (str): Identifier of the object particles should be on.
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)

    obj = Group()
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = GROUP
    obj.on_id = on_id
    obj.npart = npart
    obj.xyz = []

    on_obj = self.objs[self.ids[on_id]]
    if on_obj.style not in [SURFACE, REGION, UNION]:
        raise Exception(&#34;Illegal ID to place particles on&#34;)
    totalarea = on_obj.area()
    
    for _ in range(npart):
        area = self.random() * totalarea
        pt, norm = on_obj.loc2d(area, self.random)
        obj.xyz.append(pt)
    
    obj.center()
    print(f&#34;Created {npart} particles on area of {totalarea}&#34;)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.partarray"><code class="name flex">
<span>def <span class="ident">partarray</span></span>(<span>self, id, nx, ny, nz, x, y, z, dx, dy, dz)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 3D grid of particles.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the particle array.
nx, ny, nz (int): Number of particles in x, y, z directions.
x, y, z (float): Starting coordinates.
dx, dy, dz (float): Spacing between particles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partarray(self, id, nx, ny, nz, x, y, z, dx, dy, dz):
    &#34;&#34;&#34;
    Create a 3D grid of particles.

    Parameters:
        id (str): Unique identifier for the particle array.
        nx, ny, nz (int): Number of particles in x, y, z directions.
        x, y, z (float): Starting coordinates.
        dx, dy, dz (float): Spacing between particles.
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)

    obj = Group()
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = GROUP
    obj.on_id = &#34;&#34;
    obj.npart = nx * ny * nz
    obj.xyz = []

    for k in range(nz):
        znew = z + k * dz
        for j in range(ny):
            ynew = y + j * dy
            for i in range(nx):
                xnew = x + i * dx
                obj.xyz.append([xnew, ynew, znew])
                
    obj.center()
    print(f&#34;Created {nx * ny * nz} particles&#34;)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.partring"><code class="name flex">
<span>def <span class="ident">partring</span></span>(<span>self, id, n, x, y, z, r, axis)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a ring of N particles.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the particle ring.
n (int): Number of particles in the ring.
x, y, z (float): Center coordinates of the ring.
r (float): Radius of the ring.
axis (str): Axis of the ring ('x', 'y', or 'z').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partring(self, id, n, x, y, z, r, axis):
    &#34;&#34;&#34;
    Create a ring of N particles.

    Parameters:
        id (str): Unique identifier for the particle ring.
        n (int): Number of particles in the ring.
        x, y, z (float): Center coordinates of the ring.
        r (float): Radius of the ring.
        axis (str): Axis of the ring (&#39;x&#39;, &#39;y&#39;, or &#39;z&#39;).
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)

    obj = Group()
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = GROUP
    obj.on_id = &#34;&#34;
    obj.npart = n
    obj.xyz = []

    deltheta = 2.0 * pi / n
    for i in range(n):
        theta = i * deltheta
        if axis == &#39;x&#39;:
            xnew = x
            ynew = y + r * cos(theta)
            znew = z + r * sin(theta)
        elif axis == &#39;y&#39;:
            xnew = x + r * cos(theta)
            ynew = y
            znew = z + r * sin(theta)
        elif axis == &#39;z&#39;:
            xnew = x + r * cos(theta)
            ynew = y + r * sin(theta)
            znew = z
        else:
            raise Exception(&#34;Invalid axis for partring()&#34;)
        obj.xyz.append([xnew, ynew, znew])
            
    obj.center()
    print(f&#34;Created {n} particles&#34;)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.partsurf"><code class="name flex">
<span>def <span class="ident">partsurf</span></span>(<span>self, id, on_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the surface assignment for a 2D group of particles.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Identifier of the particle group.
on_id (str): New surface identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def partsurf(self, id, on_id):
    &#34;&#34;&#34;
    Change the surface assignment for a 2D group of particles.

    Parameters:
        id (str): Identifier of the particle group.
        on_id (str): New surface identifier.
    &#34;&#34;&#34;
    obj = self.objs[self.ids[id]]
    if obj.style != GROUP:
        raise Exception(&#34;Must use particle group with partsurf()&#34;)
    if not obj.on_id:
        raise Exception(&#34;Must use partsurf() with 2d particles&#34;)
    obj.on_id = on_id</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, id, id2, dx, dy, dz, EPS, flag=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Project particles in group ID to the surface of object ID2.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Identifier of the particle group.
id2 (str): Identifier of the target surface or region.
dx, dy, dz (float): Direction components for projection.
EPS (float): Epsilon value for proximity.
flag (bool, optional): If True, direction is from particle to (dx, dy, dz).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, id, id2, dx, dy, dz, EPS, flag=None):
    &#34;&#34;&#34;
    Project particles in group ID to the surface of object ID2.

    Parameters:
        id (str): Identifier of the particle group.
        id2 (str): Identifier of the target surface or region.
        dx, dy, dz (float): Direction components for projection.
        EPS (float): Epsilon value for proximity.
        flag (bool, optional): If True, direction is from particle to (dx, dy, dz).
    &#34;&#34;&#34;
    obj = self.objs[self.ids[id]]
    if obj.style != GROUP:
        raise Exception(&#34;Must use particle group as 1st obj of project()&#34;)
    obj_on = self.objs[self.ids[id2]]
    if obj_on.style not in [SURFACE, REGION]:
        raise Exception(&#34;Must use surf or region as 2nd obj of project()&#34;)

    # Pre-process SURFACE to bin its triangles for faster searching
    if obj_on.style == SURFACE:
        obj_on.inside_prep()

    # For each particle, move it in dir from current location
    # Move along dir until get within EPS of surf
    # factor = multiply bracketing distance by this amount each iteration
    # maxscale = max multiple of dir vector to bracket in each direction

    factor = 2
    maxscale = 10.0

    for i in range(obj.npart):
        x, y, z_coord = obj.xyz[i]
        if flag:
            dir_vector = [dx - x, dy - y, dz - z_coord]
        else:
            dir_vector = [dx, dy, dz]
        normalize(dir_vector)
        
        # Start = inside/outside at starting point
        # Stop = inside/outside at bracketing point
        start = obj_on.inside(x, y, z_coord)
        stop = 0 if start else 1

        # Iterate to find bracketing point or until scale dist &gt; maxdist
        # Bracket point = xyz +/- scale*dir
        # Multiply scale by factor each iteration

        scale = EPS
        bracket = start
        while scale &lt; maxscale:
            xnew = x + scale * dir_vector[0]
            ynew = y + scale * dir_vector[1]
            znew = z_coord + scale * dir_vector[2]
            bracket = obj_on.inside(xnew, ynew, znew)
            if bracket == stop:
                break
            xnew_neg = x - scale * dir_vector[0]
            ynew_neg = y - scale * dir_vector[1]
            znew_neg = z_coord - scale * dir_vector[2]
            bracket = obj_on.inside(xnew_neg, ynew_neg, znew_neg)
            if bracket == stop:
                xnew, ynew, znew = xnew_neg, ynew_neg, znew_neg
                break
            scale *= factor

        if bracket == start:
            raise Exception(f&#34;Could not find bracket point for particle {i}&#34;)

        # Bisection search to zoom in to within EPS of surface
        # Separation = distance between 2 points
        delx = xnew - x
        dely = ynew - y
        delz = znew - z_coord
        separation = sqrt(delx**2 + dely**2 + delz**2)
        while separation &gt; EPS:
            xmid = 0.5 * (x + xnew)
            ymid = 0.5 * (y + ynew)
            zmid = 0.5 * (z_coord + znew)
            value = obj_on.inside(xmid, ymid, zmid)
            if value == start:
                x, y, z_coord = xmid, ymid, zmid
            else:
                xnew, ynew, znew = xmid, ymid, zmid
            delx = xnew - x
            dely = ynew - y
            delz = znew - z_coord
            separation = sqrt(delx**2 + dely**2 + delz**2)

        obj.xyz[i][0] = x
        obj.xyz[i][1] = y
        obj.xyz[i][2] = z_coord

    obj.on_id = id2
    obj.center()</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.q"><code class="name flex">
<span>def <span class="ident">q</span></span>(<span>self, id, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Set quality factors for a region's triangulation routine.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Identifier of the region.
args: Quality factors (q1, q2, &hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def q(self, id, *args):
    &#34;&#34;&#34;
    Set quality factors for a region&#39;s triangulation routine.

    Parameters:
        id (str): Identifier of the region.
        args: Quality factors (q1, q2, ...)
    &#34;&#34;&#34;
    obj = self.objs[self.ids[id]]
    if obj.style != REGION:
        raise Exception(&#34;Can only use q() on a region object&#34;)
    for n, arg in enumerate(args, start=1):
        setattr(obj, f&#34;q{n}&#34;, arg)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.random"><code class="name flex">
<span>def <span class="ident">random</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Pick a random point on the surface of the specified object.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Identifier of the surface or region.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(point [x, y, z], normal vector [nx, ny, nz])</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random(self, id):
    &#34;&#34;&#34;
    Pick a random point on the surface of the specified object.

    Parameters:
        id (str): Identifier of the surface or region.

    Returns:
        tuple: (point [x, y, z], normal vector [nx, ny, nz])
    &#34;&#34;&#34;
    obj = self.objs[self.ids[id]]
    if obj.style not in [SURFACE, REGION]:
        raise Exception(&#34;Must use surf or region with random()&#34;)

    totalarea = obj.area()
    area = self.random() * totalarea
    pt, norm = obj.loc2d(area, self.random)
    return pt, norm</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, *list)</span>
</code></dt>
<dd>
<div class="desc"><p>Read ChemCell data files and populate objects.</p>
<h2 id="parameters">Parameters</h2>
<p>*list: Variable length argument list of file names to read.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, *list):
    &#34;&#34;&#34;
    Read ChemCell data files and populate objects.

    Parameters:
        *list: Variable length argument list of file names to read.
    &#34;&#34;&#34;
    # flist = list of all data file names
    words = list[0].split()
    flist = []
    for word in words:
        flist += glob.glob(word)
    if len(flist) == 0 and len(list) == 1:
        raise Exception(&#34;no data file specified&#34;)

    for file in flist:
        # Test for gzipped file
        if file.endswith(&#34;.gz&#34;):
            f = popen(f&#34;{PIZZA_GUNZIP} -c {file}&#34;, &#39;r&#39;)
        else:
            f = open(file, &#39;r&#39;)

        # Read all entries in file
        while True:
            line = f.readline()
            if not line:
                break
            line = line.strip()
            if not line:
                continue
            elif line.startswith(&#34;triangles&#34;):
                flag = &#34;triangles&#34;
            elif line.startswith(&#34;particles&#34;):
                flag = &#34;particles&#34;
            elif line.startswith(&#34;facets&#34;):
                flag = &#34;facets&#34;
            elif line.startswith(&#34;region&#34;):
                flag = &#34;region&#34;
            else:
                print(&#34;unknown line:&#34;, line)
                raise Exception(&#34;unrecognized ChemCell data file&#34;)

            # Create a surface object from set of triangles or facets
            if flag in [&#34;triangles&#34;, &#34;facets&#34;]:
                tmp, id, nvert, ntri = line.split()
                nvert = int(nvert)
                ntri = int(ntri)

                if id in self.ids:
                    raise Exception(f&#34;ID {id} is already in use&#34;)

                f.readline()  # Read past header
                vertices = []
                for _ in range(nvert):
                    parts = f.readline().split()
                    vertices.append([float(value) for value in parts[1:]])
                f.readline()  # Read past another header
                triangles = []
                for _ in range(ntri):
                    parts = f.readline().split()
                    triangles.append([int(value) for value in parts[1:]])

                if flag == &#34;triangles&#34;:
                    f.readline()  # Read past another header
                    connections = []
                    for _ in range(ntri):
                        parts = f.readline().split()
                        connections.append([int(value) for value in parts[1:]])
                else:
                    connections = connect(nvert, ntri, triangles)
                
                obj = Surface()
                obj.select = 1
                self.ids[id] = len(self.objs)
                self.objs.append(obj)
                obj.id = id
                obj.style = SURFACE
                obj.nvert = nvert
                obj.ntri = ntri
                obj.vertices = vertices
                obj.triangles = triangles
                obj.connections = connections
                obj.center()
              
                print(id, end=&#39; &#39;)
                sys.stdout.flush()

            # Create a group object from list of particles
            if flag == &#34;particles&#34;:
                words = line.split()
                id = words[1]
                npart = int(words[2])

                if id in self.ids:
                    raise Exception(f&#34;ID {id} is already in use&#34;)

                f.readline()  # Read past header
                xyz = []
                for _ in range(npart):
                    parts = f.readline().split()
                    xyz.append([float(value) for value in parts[1:]])

                obj = Group()
                obj.select = 1
                self.ids[id] = len(self.objs)
                self.objs.append(obj)
                obj.id = id
                obj.style = GROUP
                obj.on_id = &#34;&#34;
                if len(words) == 4:
                    obj.on_id = words[3]
                obj.npart = npart
                obj.xyz = xyz
                obj.center()
                
                print(id, end=&#39; &#39;)
                sys.stdout.flush()

            # Create a region object from ChemCell region command
            if flag == &#34;region&#34;:
                words = line.split()
                id = words[1]
                style = words[2]
                args = words[3:]
                
                if style == &#34;box&#34;:
                    obj = Box(*args)
                    obj.substyle = BOX
                elif style == &#34;sphere&#34;:
                    obj = Sphere(*args)
                elif style == &#34;shell&#34;:
                    obj = Shell(*args)
                elif style == &#34;cylinder&#34;:
                    obj = Cylinder(*args)
                elif style == &#34;capped&#34;:
                    obj = Capped(*args)
                else:
                    raise Exception(f&#34;Unknown region style: {style}&#34;)
                
                obj.select = 1
                self.ids[id] = len(self.objs)
                self.objs.append(obj)
                obj.id = id
                obj.style = REGION
                
                print(id, end=&#39; &#39;)
                sys.stdout.flush()

        f.close()
    print()</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, id_old, id_new)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename an object.</p>
<h2 id="parameters">Parameters</h2>
<p>id_old (str): Current identifier of the object.
id_new (str): New identifier for the object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(self, id_old, id_new):
    &#34;&#34;&#34;
    Rename an object.

    Parameters:
        id_old (str): Current identifier of the object.
        id_new (str): New identifier for the object.
    &#34;&#34;&#34;
    if id_new in self.ids:
        raise Exception(f&#34;ID {id_new} is already in use&#34;)
    if id_old not in self.ids:
        raise Exception(f&#34;ID {id_old} does not exist&#34;)
    i = self.ids[id_old]
    self.ids[id_new] = i
    self.objs[i].id = id_new
    del self.ids[id_old]</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, id, axis1, i1, j1, k1, axis2, i2, j2, k2)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate an object so that its current axes align with new ones.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Identifier of the object.
axis1 (str): First axis to rotate ('x', 'y', 'z').
i1, j1, k1 (float): Direction cosines for the first new axis.
axis2 (str): Second axis to rotate ('x', 'y', 'z').
i2, j2, k2 (float): Direction cosines for the second new axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate(self, id, axis1, i1, j1, k1, axis2, i2, j2, k2):
    &#34;&#34;&#34;
    Rotate an object so that its current axes align with new ones.

    Parameters:
        id (str): Identifier of the object.
        axis1 (str): First axis to rotate (&#39;x&#39;, &#39;y&#39;, &#39;z&#39;).
        i1, j1, k1 (float): Direction cosines for the first new axis.
        axis2 (str): Second axis to rotate (&#39;x&#39;, &#39;y&#39;, &#39;z&#39;).
        i2, j2, k2 (float): Direction cosines for the second new axis.
    &#34;&#34;&#34;
    obj = self.objs[self.ids[id]]
    if obj.style not in [SURFACE, GROUP]:
        raise Exception(&#34;Can only use rotate() on a surface or group object&#34;)

    # Create new axes
    new_axes = {&#39;x&#39;: None, &#39;y&#39;: None, &#39;z&#39;: None}
    if axis1 in new_axes:
        new_axes[axis1] = [i1, j1, k1]
    else:
        raise Exception(&#34;Invalid axis for rotate()&#34;)
    
    if axis2 in new_axes:
        new_axes[axis2] = [i2, j2, k2]
    else:
        raise Exception(&#34;Invalid axis for rotate()&#34;)

    # Infer the third axis
    axes = [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]
    missing_axis = next((ax for ax in axes if new_axes[ax] is None), None)
    if missing_axis is None:
        raise Exception(&#34;All three axes are already defined&#34;)
    other_axes = [ax for ax in axes if ax != missing_axis]
    new_axes[missing_axis] = cross(new_axes[other_axes[0]], new_axes[other_axes[1]])
    normalize(new_axes[missing_axis])

    # Orthonormalize the axes
    normalize(new_axes[&#39;x&#39;])
    normalize(new_axes[&#39;y&#39;])
    normalize(new_axes[&#39;z&#39;])

    # Apply rotation matrix to each vertex or particle coordinate
    if obj.style == SURFACE:
        for vert in obj.vertices:
            x = vert[0] - obj.xc
            y = vert[1] - obj.yc
            z = vert[2] - obj.zc
            xn = new_axes[&#39;x&#39;][0]*x + new_axes[&#39;x&#39;][1]*y + new_axes[&#39;x&#39;][2]*z
            yn = new_axes[&#39;y&#39;][0]*x + new_axes[&#39;y&#39;][1]*y + new_axes[&#39;y&#39;][2]*z
            zn = new_axes[&#39;z&#39;][0]*x + new_axes[&#39;z&#39;][1]*y + new_axes[&#39;z&#39;][2]*z
            vert[0] = xn + obj.xc
            vert[1] = yn + obj.yc
            vert[2] = zn + obj.zc
    elif obj.style == GROUP:
        for particle in obj.xyz:
            x = particle[0] - obj.xc
            y = particle[1] - obj.yc
            z = particle[2] - obj.zc
            xn = new_axes[&#39;x&#39;][0]*x + new_axes[&#39;x&#39;][1]*y + new_axes[&#39;x&#39;][2]*z
            yn = new_axes[&#39;y&#39;][0]*x + new_axes[&#39;y&#39;][1]*y + new_axes[&#39;y&#39;][2]*z
            zn = new_axes[&#39;z&#39;][0]*x + new_axes[&#39;z&#39;][1]*y + new_axes[&#39;z&#39;][2]*z
            particle[0] = xn + obj.xc
            particle[1] = yn + obj.yc
            particle[2] = zn + obj.zc</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, id, sx, sy, sz)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale an object by specified factors along each axis.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Identifier of the object.
sx, sy, sz (float): Scaling factors along x, y, z axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, id, sx, sy, sz):
    &#34;&#34;&#34;
    Scale an object by specified factors along each axis.

    Parameters:
        id (str): Identifier of the object.
        sx, sy, sz (float): Scaling factors along x, y, z axes.
    &#34;&#34;&#34;
    obj = self.objs[self.ids[id]]
    if obj.style not in [SURFACE, GROUP]:
        raise Exception(&#34;Can only use scale() on a surface or group object&#34;)
    if obj.style == SURFACE:
        for vert in obj.vertices:
            vert[0] = obj.xc + sx * (vert[0] - obj.xc)
            vert[1] = obj.yc + sy * (vert[1] - obj.yc)
            vert[2] = obj.zc + sz * (vert[2] - obj.zc)
    elif obj.style == GROUP:
        for particle in obj.xyz:
            particle[0] = obj.xc + sx * (particle[0] - obj.xc)
            particle[1] = obj.yc + sy * (particle[1] - obj.yc)
            particle[2] = obj.zc + sz * (particle[2] - obj.zc)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.seed"><code class="name flex">
<span>def <span class="ident">seed</span></span>(<span>self, new_seed)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the random number generator seed.</p>
<h2 id="parameters">Parameters</h2>
<p>new_seed (int): New seed value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seed(self, new_seed):
    &#34;&#34;&#34;
    Set the random number generator seed.

    Parameters:
        new_seed (int): New seed value.
    &#34;&#34;&#34;
    self.random.seed = new_seed</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, *list_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Select one or more objects.</p>
<h2 id="parameters">Parameters</h2>
<p>*list_ids: Identifiers of objects to select. If empty, selects all.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, *list_ids):
    &#34;&#34;&#34;
    Select one or more objects.

    Parameters:
        *list_ids: Identifiers of objects to select. If empty, selects all.
    &#34;&#34;&#34;
    if not list_ids:
        list_ids = self.ids.keys()
    for id in list_ids:
        if id not in self.ids:
            raise Exception(f&#34;ID {id} does not exist&#34;)
        obj = self.objs[self.ids[id]]
        obj.select = 1</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.shell"><code class="name flex">
<span>def <span class="ident">shell</span></span>(<span>self, id, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a shell region.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the shell.
args: x, y, z, r, rinner</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shell(self, id, *args):
    &#34;&#34;&#34;
    Create a shell region.

    Parameters:
        id (str): Unique identifier for the shell.
        args: x, y, z, r, rinner
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)
    obj = Shell(*args)
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = REGION
    obj.substyle = SHELL</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.sphere"><code class="name flex">
<span>def <span class="ident">sphere</span></span>(<span>self, id, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a sphere region.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the sphere.
args: x, y, z, r</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sphere(self, id, *args):
    &#34;&#34;&#34;
    Create a sphere region.

    Parameters:
        id (str): Unique identifier for the sphere.
        args: x, y, z, r
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)
    obj = Sphere(*args)
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = REGION
    obj.substyle = SPHERE</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.surf"><code class="name flex">
<span>def <span class="ident">surf</span></span>(<span>self, id, id_region)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a triangulated surface from a region object.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the surface.
id_region (str): Identifier of the region to triangulate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surf(self, id, id_region):
    &#34;&#34;&#34;
    Create a triangulated surface from a region object.

    Parameters:
        id (str): Unique identifier for the surface.
        id_region (str): Identifier of the region to triangulate.
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)

    region = self.objs[self.ids[id_region]]
    region.triangulate()
    
    obj = Surface()
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = SURFACE
    obj.nvert = region.nvert
    obj.ntri = region.ntri
    obj.vertices = deepcopy(region.vertices)
    obj.triangles = deepcopy(region.triangles)
    obj.connections = deepcopy(region.connections)
    obj.center()</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.surfselect"><code class="name flex">
<span>def <span class="ident">surfselect</span></span>(<span>self, id, id_surf, teststr)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a triangulated surface by selecting triangles based on a test string.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the new surface.
id_surf (str): Identifier of the existing surface.
teststr (str): Test condition (e.g., "$x &lt; 2.0 and $y &gt; 0.0").</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surfselect(self, id, id_surf, teststr):
    &#34;&#34;&#34;
    Create a triangulated surface by selecting triangles based on a test string.

    Parameters:
        id (str): Unique identifier for the new surface.
        id_surf (str): Identifier of the existing surface.
        teststr (str): Test condition (e.g., &#34;$x &lt; 2.0 and $y &gt; 0.0&#34;).
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)

    o = self.objs[self.ids[id_surf]]
    
    obj = Surface()
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = SURFACE
    obj.nvert = 0
    obj.ntri = 0
    obj.vertices = []
    obj.triangles = []

    # Replace $var with o.vertices reference and compile test string
    cmd1 = teststr.replace(&#34;$x&#34;, &#34;o.vertices[v1][0]&#34;)
    cmd1 = cmd1.replace(&#34;$y&#34;, &#34;o.vertices[v1][1]&#34;)
    cmd1 = &#34;flag1 = &#34; + cmd1.replace(&#34;$z&#34;, &#34;o.vertices[v1][2]&#34;)
    ccmd1 = compile(cmd1, &#39;&#39;, &#39;single&#39;)

    cmd2 = teststr.replace(&#34;$x&#34;, &#34;o.vertices[v2][0]&#34;)
    cmd2 = cmd2.replace(&#34;$y&#34;, &#34;o.vertices[v2][1]&#34;)
    cmd2 = &#34;flag2 = &#34; + cmd2.replace(&#34;$z&#34;, &#34;o.vertices[v2][2]&#34;)
    ccmd2 = compile(cmd2, &#39;&#39;, &#39;single&#39;)

    cmd3 = teststr.replace(&#34;$x&#34;, &#34;o.vertices[v3][0]&#34;)
    cmd3 = cmd3.replace(&#34;$y&#34;, &#34;o.vertices[v3][1]&#34;)
    cmd3 = &#34;flag3 = &#34; + cmd3.replace(&#34;$z&#34;, &#34;o.vertices[v3][2]&#34;)
    ccmd3 = compile(cmd3, &#39;&#39;, &#39;single&#39;)

    # Loop over triangles in id_surf
    for tri in o.triangles:
        v1 = tri[0] - 1
        v2 = tri[1] - 1
        v3 = tri[2] - 1
        exec(ccmd1)
        exec(ccmd2)
        exec(ccmd3)
        if flag1 and flag2 and flag3:
            obj.vertices.append(o.vertices[v1][:])
            obj.vertices.append(o.vertices[v2][:])
            obj.vertices.append(o.vertices[v3][:])
            obj.triangles.append([obj.nvert+1, obj.nvert+2, obj.nvert+3])
            obj.nvert += 3
            obj.ntri += 1

    # Make any connections in new set of triangles
    obj.connections = connect(obj.nvert, obj.ntri, obj.triangles)
    obj.center()</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.surftri"><code class="name flex">
<span>def <span class="ident">surftri</span></span>(<span>self, id, id_surf, *list_indices)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a triangulated surface from a list of triangle indices in another surface.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the new surface.
id_surf (str): Identifier of the existing surface.
*list_indices: Triangle indices to include (1-based indexing).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surftri(self, id, id_surf, *list_indices):
    &#34;&#34;&#34;
    Create a triangulated surface from a list of triangle indices in another surface.

    Parameters:
        id (str): Unique identifier for the new surface.
        id_surf (str): Identifier of the existing surface.
        *list_indices: Triangle indices to include (1-based indexing).
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)

    o = self.objs[self.ids[id_surf]]
    
    obj = Surface()
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = SURFACE
    obj.nvert = 0
    obj.ntri = 0
    obj.vertices = []
    obj.triangles = []

    # Subtract 1 from tri and vert to convert to 0-based indexing
    for i in list_indices:
        tri = o.triangles[i-1]
        v1 = o.triangles[i-1][0]
        v2 = o.triangles[i-1][1]
        v3 = o.triangles[i-1][2]
        obj.vertices.append(o.vertices[v1-1][:])
        obj.vertices.append(o.vertices[v2-1][:])
        obj.vertices.append(o.vertices[v3-1][:])
        obj.triangles.append([obj.nvert+1, obj.nvert+2, obj.nvert+3])
        obj.nvert += 3
        obj.ntri += 1

    # Make any connections in new set of triangles
    obj.connections = connect(obj.nvert, obj.ntri, obj.triangles)
    obj.center()</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.trans"><code class="name flex">
<span>def <span class="ident">trans</span></span>(<span>self, id, dx, dy, dz)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate an object by a displacement.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Identifier of the object.
dx, dy, dz (float): Displacement along x, y, z axes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trans(self, id, dx, dy, dz):
    &#34;&#34;&#34;
    Translate an object by a displacement.

    Parameters:
        id (str): Identifier of the object.
        dx, dy, dz (float): Displacement along x, y, z axes.
    &#34;&#34;&#34;
    obj = self.objs[self.ids[id]]
    if obj.style not in [SURFACE, GROUP]:
        raise Exception(&#34;Can only use trans() on a surface or group object&#34;)
    obj.xc += dx
    obj.yc += dy
    obj.zc += dz

    # Apply translation to each vertex or particle coordinate
    if obj.style == SURFACE:
        for vert in obj.vertices:
            vert[0] += dx
            vert[1] += dy
            vert[2] += dz
    elif obj.style == GROUP:
        for particle in obj.xyz:
            particle[0] += dx
            particle[1] += dy
            particle[2] += dz</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, id, *list_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a union object from a list of other objects.</p>
<h2 id="parameters">Parameters</h2>
<p>id (str): Unique identifier for the union.
*list_ids: Identifiers of objects to include in the union.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self, id, *list_ids):
    &#34;&#34;&#34;
    Create a union object from a list of other objects.

    Parameters:
        id (str): Unique identifier for the union.
        *list_ids: Identifiers of objects to include in the union.
    &#34;&#34;&#34;
    if id in self.ids:
        raise Exception(f&#34;ID {id} is already in use&#34;)
    obj = Union(self.ids, self.objs, *list_ids)
    obj.select = 1
    self.ids[id] = len(self.objs)
    self.objs.append(obj)
    obj.id = id
    obj.style = UNION</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.unselect"><code class="name flex">
<span>def <span class="ident">unselect</span></span>(<span>self, *list_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Unselect one or more objects.</p>
<h2 id="parameters">Parameters</h2>
<p>*list_ids: Identifiers of objects to unselect. If empty, unselects all.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unselect(self, *list_ids):
    &#34;&#34;&#34;
    Unselect one or more objects.

    Parameters:
        *list_ids: Identifiers of objects to unselect. If empty, unselects all.
    &#34;&#34;&#34;
    if not list_ids:
        list_ids = self.ids.keys()
    for id in list_ids:
        if id not in self.ids:
            raise Exception(f&#34;ID {id} does not exist&#34;)
        obj = self.objs[self.ids[id]]
        obj.select = 0</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.viz"><code class="name flex">
<span>def <span class="ident">viz</span></span>(<span>self, isnap)</span>
</code></dt>
<dd>
<div class="desc"><p>Return list of atoms, bonds, tris, and lines for visualization.</p>
<h2 id="parameters">Parameters</h2>
<p>isnap (int): Snapshot index. Must be 0 for cdata.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(time, box, atoms, bonds, tris, lines)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz(self, isnap):
    &#34;&#34;&#34;
    Return list of atoms, bonds, tris, and lines for visualization.

    Parameters:
        isnap (int): Snapshot index. Must be 0 for cdata.

    Returns:
        tuple: (time, box, atoms, bonds, tris, lines)
    &#34;&#34;&#34;
    if isnap:
        raise Exception(&#34;cannot call cdata.viz() with isnap != 0&#34;)
    
    # Create atom list from sum of all particle groups
    # id = running count
    # type = running type of particle group

    id_count = itype = 0
    atoms = []
    for obj in self.objs:
        if obj.style != GROUP:
            continue
        if not obj.select:
            continue
        itype += 1
        for xyz in obj.xyz:
            id_count += 1
            atoms.append([id_count, itype, xyz[0], xyz[1], xyz[2]])

    # No bonds
    bonds = []

    # Create triangle list from sum of all surfaces and regions
    # id = running count
    # type = type of set of tris

    id_count = itype = 0
    tris = []
    for obj in self.objs:
        if obj.style not in [SURFACE, REGION]:
            continue
        if not obj.select:
            continue
        if obj.style == REGION:
            obj.triangulate()
        itype += 1
        for tri in obj.triangles:
            v1 = obj.vertices[tri[0]-1]
            v2 = obj.vertices[tri[1]-1]
            v3 = obj.vertices[tri[2]-1]
            list_vertices = v1 + v2 + v3
            n = normal(list_vertices[0:3], list_vertices[3:6], list_vertices[6:9])
            id_count += 1
            tris.append([id_count, itype] + list_vertices + n)

    # Create line list from sum of all line objects
    id_count = itype = 0
    lines = []
    for obj in self.objs:
        if obj.style != LINE:
            continue
        if not obj.select:
            continue
        itype += 1
        for pair in obj.pairs:
            id_count += 1
            lines.append([id_count, itype] + pair)
    
    return (0, self.bbox(), atoms, bonds, tris, lines)</code></pre>
</details>
</dd>
<dt id="cdata3.cdata.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, *list_ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Write selected objects to a ChemCell data file.</p>
<h2 id="parameters">Parameters</h2>
<p>file (str): Filename to write to.
*list_ids: Identifiers of objects to write. If empty, writes all selected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, *list_ids):
    &#34;&#34;&#34;
    Write selected objects to a ChemCell data file.

    Parameters:
        file (str): Filename to write to.
        *list_ids: Identifiers of objects to write. If empty, writes all selected.
    &#34;&#34;&#34;
    if not list_ids:
        vlist = list(range(len(self.objs)))
    else:
        vlist = []
        for id in list_ids:
            if id not in self.ids:
                raise Exception(f&#34;ID {id} does not exist&#34;)
            vlist.append(self.ids[id])

    with open(file, &#39;w&#39;) as fp:
        self.filewrite(fp, vlist)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="cdata3.box_triangulate" href="#cdata3.box_triangulate">box_triangulate</a></code></li>
<li><code><a title="cdata3.connect" href="#cdata3.connect">connect</a></code></li>
<li><code><a title="cdata3.cross" href="#cdata3.cross">cross</a></code></li>
<li><code><a title="cdata3.normal" href="#cdata3.normal">normal</a></code></li>
<li><code><a title="cdata3.normalize" href="#cdata3.normalize">normalize</a></code></li>
<li><code><a title="cdata3.vertex" href="#cdata3.vertex">vertex</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cdata3.Box" href="#cdata3.Box">Box</a></code></h4>
<ul class="two-column">
<li><code><a title="cdata3.Box.area" href="#cdata3.Box.area">area</a></code></li>
<li><code><a title="cdata3.Box.bbox" href="#cdata3.Box.bbox">bbox</a></code></li>
<li><code><a title="cdata3.Box.command" href="#cdata3.Box.command">command</a></code></li>
<li><code><a title="cdata3.Box.inside" href="#cdata3.Box.inside">inside</a></code></li>
<li><code><a title="cdata3.Box.loc2d" href="#cdata3.Box.loc2d">loc2d</a></code></li>
<li><code><a title="cdata3.Box.triangulate" href="#cdata3.Box.triangulate">triangulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cdata3.Capped" href="#cdata3.Capped">Capped</a></code></h4>
<ul class="two-column">
<li><code><a title="cdata3.Capped.area" href="#cdata3.Capped.area">area</a></code></li>
<li><code><a title="cdata3.Capped.bbox" href="#cdata3.Capped.bbox">bbox</a></code></li>
<li><code><a title="cdata3.Capped.command" href="#cdata3.Capped.command">command</a></code></li>
<li><code><a title="cdata3.Capped.inside" href="#cdata3.Capped.inside">inside</a></code></li>
<li><code><a title="cdata3.Capped.loc2d" href="#cdata3.Capped.loc2d">loc2d</a></code></li>
<li><code><a title="cdata3.Capped.triangulate" href="#cdata3.Capped.triangulate">triangulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cdata3.Cylinder" href="#cdata3.Cylinder">Cylinder</a></code></h4>
<ul class="two-column">
<li><code><a title="cdata3.Cylinder.area" href="#cdata3.Cylinder.area">area</a></code></li>
<li><code><a title="cdata3.Cylinder.bbox" href="#cdata3.Cylinder.bbox">bbox</a></code></li>
<li><code><a title="cdata3.Cylinder.command" href="#cdata3.Cylinder.command">command</a></code></li>
<li><code><a title="cdata3.Cylinder.inside" href="#cdata3.Cylinder.inside">inside</a></code></li>
<li><code><a title="cdata3.Cylinder.loc2d" href="#cdata3.Cylinder.loc2d">loc2d</a></code></li>
<li><code><a title="cdata3.Cylinder.triangulate" href="#cdata3.Cylinder.triangulate">triangulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cdata3.Group" href="#cdata3.Group">Group</a></code></h4>
<ul class="">
<li><code><a title="cdata3.Group.bbox" href="#cdata3.Group.bbox">bbox</a></code></li>
<li><code><a title="cdata3.Group.center" href="#cdata3.Group.center">center</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cdata3.Line" href="#cdata3.Line">Line</a></code></h4>
<ul class="">
<li><code><a title="cdata3.Line.addline" href="#cdata3.Line.addline">addline</a></code></li>
<li><code><a title="cdata3.Line.bbox" href="#cdata3.Line.bbox">bbox</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cdata3.Random" href="#cdata3.Random">Random</a></code></h4>
</li>
<li>
<h4><code><a title="cdata3.Shell" href="#cdata3.Shell">Shell</a></code></h4>
<ul class="">
<li><code><a title="cdata3.Shell.command" href="#cdata3.Shell.command">command</a></code></li>
<li><code><a title="cdata3.Shell.inside" href="#cdata3.Shell.inside">inside</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cdata3.Sphere" href="#cdata3.Sphere">Sphere</a></code></h4>
<ul class="two-column">
<li><code><a title="cdata3.Sphere.area" href="#cdata3.Sphere.area">area</a></code></li>
<li><code><a title="cdata3.Sphere.bbox" href="#cdata3.Sphere.bbox">bbox</a></code></li>
<li><code><a title="cdata3.Sphere.command" href="#cdata3.Sphere.command">command</a></code></li>
<li><code><a title="cdata3.Sphere.inside" href="#cdata3.Sphere.inside">inside</a></code></li>
<li><code><a title="cdata3.Sphere.loc2d" href="#cdata3.Sphere.loc2d">loc2d</a></code></li>
<li><code><a title="cdata3.Sphere.triangulate" href="#cdata3.Sphere.triangulate">triangulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cdata3.Surface" href="#cdata3.Surface">Surface</a></code></h4>
<ul class="two-column">
<li><code><a title="cdata3.Surface.area" href="#cdata3.Surface.area">area</a></code></li>
<li><code><a title="cdata3.Surface.bbox" href="#cdata3.Surface.bbox">bbox</a></code></li>
<li><code><a title="cdata3.Surface.center" href="#cdata3.Surface.center">center</a></code></li>
<li><code><a title="cdata3.Surface.inside" href="#cdata3.Surface.inside">inside</a></code></li>
<li><code><a title="cdata3.Surface.inside_prep" href="#cdata3.Surface.inside_prep">inside_prep</a></code></li>
<li><code><a title="cdata3.Surface.loc2d" href="#cdata3.Surface.loc2d">loc2d</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cdata3.Union" href="#cdata3.Union">Union</a></code></h4>
<ul class="">
<li><code><a title="cdata3.Union.area" href="#cdata3.Union.area">area</a></code></li>
<li><code><a title="cdata3.Union.bbox" href="#cdata3.Union.bbox">bbox</a></code></li>
<li><code><a title="cdata3.Union.inside" href="#cdata3.Union.inside">inside</a></code></li>
<li><code><a title="cdata3.Union.loc2d" href="#cdata3.Union.loc2d">loc2d</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cdata3.cdata" href="#cdata3.cdata">cdata</a></code></h4>
<ul class="two-column">
<li><code><a title="cdata3.cdata.append" href="#cdata3.cdata.append">append</a></code></li>
<li><code><a title="cdata3.cdata.bbox" href="#cdata3.cdata.bbox">bbox</a></code></li>
<li><code><a title="cdata3.cdata.bins" href="#cdata3.cdata.bins">bins</a></code></li>
<li><code><a title="cdata3.cdata.box" href="#cdata3.cdata.box">box</a></code></li>
<li><code><a title="cdata3.cdata.cap" href="#cdata3.cdata.cap">cap</a></code></li>
<li><code><a title="cdata3.cdata.center" href="#cdata3.cdata.center">center</a></code></li>
<li><code><a title="cdata3.cdata.copy" href="#cdata3.cdata.copy">copy</a></code></li>
<li><code><a title="cdata3.cdata.cyl" href="#cdata3.cdata.cyl">cyl</a></code></li>
<li><code><a title="cdata3.cdata.delete" href="#cdata3.cdata.delete">delete</a></code></li>
<li><code><a title="cdata3.cdata.filewrite" href="#cdata3.cdata.filewrite">filewrite</a></code></li>
<li><code><a title="cdata3.cdata.findtime" href="#cdata3.cdata.findtime">findtime</a></code></li>
<li><code><a title="cdata3.cdata.iterator" href="#cdata3.cdata.iterator">iterator</a></code></li>
<li><code><a title="cdata3.cdata.join" href="#cdata3.cdata.join">join</a></code></li>
<li><code><a title="cdata3.cdata.lbox" href="#cdata3.cdata.lbox">lbox</a></code></li>
<li><code><a title="cdata3.cdata.line" href="#cdata3.cdata.line">line</a></code></li>
<li><code><a title="cdata3.cdata.maxbox" href="#cdata3.cdata.maxbox">maxbox</a></code></li>
<li><code><a title="cdata3.cdata.part" href="#cdata3.cdata.part">part</a></code></li>
<li><code><a title="cdata3.cdata.part2d" href="#cdata3.cdata.part2d">part2d</a></code></li>
<li><code><a title="cdata3.cdata.partarray" href="#cdata3.cdata.partarray">partarray</a></code></li>
<li><code><a title="cdata3.cdata.partring" href="#cdata3.cdata.partring">partring</a></code></li>
<li><code><a title="cdata3.cdata.partsurf" href="#cdata3.cdata.partsurf">partsurf</a></code></li>
<li><code><a title="cdata3.cdata.project" href="#cdata3.cdata.project">project</a></code></li>
<li><code><a title="cdata3.cdata.q" href="#cdata3.cdata.q">q</a></code></li>
<li><code><a title="cdata3.cdata.random" href="#cdata3.cdata.random">random</a></code></li>
<li><code><a title="cdata3.cdata.read" href="#cdata3.cdata.read">read</a></code></li>
<li><code><a title="cdata3.cdata.rename" href="#cdata3.cdata.rename">rename</a></code></li>
<li><code><a title="cdata3.cdata.rotate" href="#cdata3.cdata.rotate">rotate</a></code></li>
<li><code><a title="cdata3.cdata.scale" href="#cdata3.cdata.scale">scale</a></code></li>
<li><code><a title="cdata3.cdata.seed" href="#cdata3.cdata.seed">seed</a></code></li>
<li><code><a title="cdata3.cdata.select" href="#cdata3.cdata.select">select</a></code></li>
<li><code><a title="cdata3.cdata.shell" href="#cdata3.cdata.shell">shell</a></code></li>
<li><code><a title="cdata3.cdata.sphere" href="#cdata3.cdata.sphere">sphere</a></code></li>
<li><code><a title="cdata3.cdata.surf" href="#cdata3.cdata.surf">surf</a></code></li>
<li><code><a title="cdata3.cdata.surfselect" href="#cdata3.cdata.surfselect">surfselect</a></code></li>
<li><code><a title="cdata3.cdata.surftri" href="#cdata3.cdata.surftri">surftri</a></code></li>
<li><code><a title="cdata3.cdata.trans" href="#cdata3.cdata.trans">trans</a></code></li>
<li><code><a title="cdata3.cdata.union" href="#cdata3.cdata.union">union</a></code></li>
<li><code><a title="cdata3.cdata.unselect" href="#cdata3.cdata.unselect">unselect</a></code></li>
<li><code><a title="cdata3.cdata.viz" href="#cdata3.cdata.viz">viz</a></code></li>
<li><code><a title="cdata3.cdata.write" href="#cdata3.cdata.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>