<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>mstruct API documentation</title>
<meta name="description" content="Module: `struct.py`
Matlab-like structure class with extensions for parameter evaluation, file paths, and automatic management of dependencies in â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mstruct</code></h1>
</header>
<section id="section-intro">
<h1 id="module-structpy">Module: <code>struct.py</code></h1>
<p>Matlab-like structure class with extensions for parameter evaluation, file paths, and automatic management of dependencies in parameter definitions. This module provides the following key classes:</p>
<ul>
<li><strong><code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code></strong>: A flexible base class that mimics Matlab structures, offering dynamic field creation, indexing, concatenation, and field-level evaluation.</li>
<li><strong><code><a title="mstruct.param" href="#mstruct.param">param</a></code></strong>: Derived from <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code>, this class enables dynamic evaluation of fields based on interdependent definitions.</li>
<li><strong><code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code></strong>: A further extension of <code><a title="mstruct.param" href="#mstruct.param">param</a></code> with automatic sorting and resolution of parameter dependencies during operations.</li>
<li><strong><code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code></strong>: A string subclass specialized for handling file paths and POSIX compatibility.</li>
</ul>
<hr>
<h2 id="purpose">Purpose</h2>
<p>This module aims to streamline the creation and manipulation of structures for scientific computation, data management, and dynamic scripting, particularly in complex workflows.</p>
<hr>
<h2 id="key-features">Key Features</h2>
<ul>
<li><strong>Flexible Dynamic Structure</strong>: Provides <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code> with field creation, deletion, and manipulation.</li>
<li><strong>Parameter Evaluation</strong>: Supports interdependent parameter evaluation with <code><a title="mstruct.param" href="#mstruct.param">param</a></code>.</li>
<li><strong>Path and String Management</strong>: Handles file paths and POSIX compliance with <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code>.</li>
<li><strong>Automatic Dependency Resolution</strong>: Manages parameter dependencies automatically with <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code>.</li>
</ul>
<hr>
<h2 id="evaluation-features-updated-for-pizza-10">Evaluation Features (Updated for Pizza 1.0)</h2>
<ul>
<li><strong>Dynamic Expressions</strong>: Evaluate expressions within <code>${...}</code> placeholders or as standalone scalar expressions.</li>
<li><strong>Matrix and Array Support</strong>: Perform advanced operations such as matrix multiplication (<code>@</code>), transposition (<code>.T</code>), and slicing within <code>${...}</code>.</li>
<li><strong>Safe Evaluation</strong>: Eliminates the use of <code>eval</code>, using <code>safe_fstring()</code> and <code><a title="mstruct.SafeEvaluator" href="#mstruct.SafeEvaluator">SafeEvaluator</a></code> for secure computation.</li>
<li><strong>Comprehensive Function Set</strong>:</li>
<li><strong>Trigonometric Functions</strong>: <code>sin</code>, <code>cos</code>, <code>tan</code>, etc.</li>
<li><strong>Exponential and Logarithmic</strong>: <code>exp</code>, <code>log</code>, <code>sqrt</code>, etc.</li>
<li><strong>Random Functions</strong>: <code>gauss</code>, <code>uniform</code>, <code>randint</code>, etc.</li>
<li><strong>Error Handling</strong>: Robust detection of undefined variables, invalid operations, and unsupported expressions.</li>
<li><strong>Type Preservation</strong>: Retains original data types (e.g., <code>float</code>, <code>numpy.ndarray</code>) for accuracy and further computation.</li>
<li><strong>Custom Formatting</strong>: Formats arrays and matrices for display with clear distinction between row/column vectors and higher-dimensional arrays.</li>
</ul>
<p>The implementation in Pizza 1.0 ensures both flexibility and security, making it ideal for scenarios requiring dynamic parameter management and safe expression evaluation.</p>
<hr>
<h2 id="examples">Examples</h2>
<h3 id="basic-struct-usage">Basic Struct Usage</h3>
<pre><code class="language-python">from struct import struct

s = struct(a=1, b=2, c='${a} + ${b}')
s.a = 10
s[&quot;b&quot;] = 5
delattr(s, &quot;c&quot;)  # Delete a field
</code></pre>
<hr>
<h3 id="parameter-evaluation-with-param">Parameter Evaluation with <code><a title="mstruct.param" href="#mstruct.param">param</a></code></h3>
<pre><code class="language-python">from struct import param

# Define parameters with dependencies
p = param(a=1, b='${a}*2', c='${b}+5')
evaluated = p.eval()  # Evaluate all fields dynamically
print(evaluated.c)  # Output: 7
</code></pre>
<hr>
<h3 id="path-management-with-pstr">Path Management with <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code></h3>
<pre><code class="language-python">from struct import pstr

# Create and manipulate POSIX-compliant paths
path = pstr(&quot;/this/is/a/path/&quot;)
combined = path / &quot;file.txt&quot;
print(combined)  # Output: &quot;/this/is/a/path/file.txt&quot;
</code></pre>
<hr>
<h3 id="automatic-dependency-handling-with-paramauto">Automatic Dependency Handling with <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code></h3>
<pre><code class="language-python">from struct import paramauto

# Automatically resolve dependencies in parameters
pa = paramauto(a=1, b='${a}+1', c='${b}*2')
pa.disp()
# Output:
# -----------
#       a: 1
#       b: ${a}+1
#        = 2
#       c: ${b}*2
#        = 4
# -----------
</code></pre>
<hr>
<h3 id="evaluation-usage">Evaluation Usage</h3>
<pre><code class="language-python">from pizza.private.mstruct import param
import numpy as np

p = param()
p.a = [1.0, 0.2, 0.03, 0.004]
p.b = np.array([p.a])
p.f = p.b.T @ p.b  # Matrix multiplication
p.g = &quot;${a[1]}&quot;    # Expression referencing `a`
p.h = &quot;${b.T @ b}&quot; # Matrix operation
print(p.eval())
</code></pre>
<hr>
<p>Created on Sun Jan 23 14:19:03 2022
<strong>Author</strong>: Olivier Vitrac, AgroParisTech</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
# Module: `struct.py`
Matlab-like structure class with extensions for parameter evaluation, file paths, and automatic management of dependencies in parameter definitions. This module provides the following key classes:

- **`struct`**: A flexible base class that mimics Matlab structures, offering dynamic field creation, indexing, concatenation, and field-level evaluation.
- **`param`**: Derived from `struct`, this class enables dynamic evaluation of fields based on interdependent definitions.
- **`paramauto`**: A further extension of `param` with automatic sorting and resolution of parameter dependencies during operations.
- **`pstr`**: A string subclass specialized for handling file paths and POSIX compatibility.

---

## Purpose
This module aims to streamline the creation and manipulation of structures for scientific computation, data management, and dynamic scripting, particularly in complex workflows.

---

## Key Features
- **Flexible Dynamic Structure**: Provides `struct` with field creation, deletion, and manipulation.
- **Parameter Evaluation**: Supports interdependent parameter evaluation with `param`.
- **Path and String Management**: Handles file paths and POSIX compliance with `pstr`.
- **Automatic Dependency Resolution**: Manages parameter dependencies automatically with `paramauto`.

---

## Evaluation Features (Updated for Pizza 1.0)
- **Dynamic Expressions**: Evaluate expressions within `${...}` placeholders or as standalone scalar expressions.
- **Matrix and Array Support**: Perform advanced operations such as matrix multiplication (`@`), transposition (`.T`), and slicing within `${...}`.
- **Safe Evaluation**: Eliminates the use of `eval`, using `safe_fstring()` and `SafeEvaluator` for secure computation.
- **Comprehensive Function Set**:
  - **Trigonometric Functions**: `sin`, `cos`, `tan`, etc.
  - **Exponential and Logarithmic**: `exp`, `log`, `sqrt`, etc.
  - **Random Functions**: `gauss`, `uniform`, `randint`, etc.
- **Error Handling**: Robust detection of undefined variables, invalid operations, and unsupported expressions.
- **Type Preservation**: Retains original data types (e.g., `float`, `numpy.ndarray`) for accuracy and further computation.
- **Custom Formatting**: Formats arrays and matrices for display with clear distinction between row/column vectors and higher-dimensional arrays.

The implementation in Pizza 1.0 ensures both flexibility and security, making it ideal for scenarios requiring dynamic parameter management and safe expression evaluation.

---

## Examples

### Basic Struct Usage
```python
from struct import struct

s = struct(a=1, b=2, c=&#39;${a} + ${b}&#39;)
s.a = 10
s[&#34;b&#34;] = 5
delattr(s, &#34;c&#34;)  # Delete a field
```

---

### Parameter Evaluation with `param`
```python
from struct import param

# Define parameters with dependencies
p = param(a=1, b=&#39;${a}*2&#39;, c=&#39;${b}+5&#39;)
evaluated = p.eval()  # Evaluate all fields dynamically
print(evaluated.c)  # Output: 7
```

---

### Path Management with `pstr`
```python
from struct import pstr

# Create and manipulate POSIX-compliant paths
path = pstr(&#34;/this/is/a/path/&#34;)
combined = path / &#34;file.txt&#34;
print(combined)  # Output: &#34;/this/is/a/path/file.txt&#34;
```

---

### Automatic Dependency Handling with `paramauto`
```python
from struct import paramauto

# Automatically resolve dependencies in parameters
pa = paramauto(a=1, b=&#39;${a}+1&#39;, c=&#39;${b}*2&#39;)
pa.disp()
# Output:
# -----------
#       a: 1
#       b: ${a}+1
#        = 2
#       c: ${b}*2
#        = 4
# -----------
```

---

### Evaluation Usage
```python
from pizza.private.mstruct import param
import numpy as np

p = param()
p.a = [1.0, 0.2, 0.03, 0.004]
p.b = np.array([p.a])
p.f = p.b.T @ p.b  # Matrix multiplication
p.g = &#34;${a[1]}&#34;    # Expression referencing `a`
p.h = &#34;${b.T @ b}&#34; # Matrix operation
print(p.eval())
```

---

Created on Sun Jan 23 14:19:03 2022
**Author**: Olivier Vitrac, AgroParisTech
&#34;&#34;&#34;

# revision history
# 2022-02-12 fix disp method for empty structures
# 2022-02-12 add type, format
# 2022-02-19 integration of the derived class param()
# 2022-02-20 code optimization, iterable class- major update
# 2022-02-26 clarify in the help the precedence s=s1+s2
# 2022-02-28 display nested structures
# 2022-03-01 implement value as list
# 2022-03-02 display correctly class names (not instances)
# 2022-03-04 add str()
# 2022-03-05 add __copy__ and __deepcopy__ methods
# 2022-03-05 AttributeError replaces KeyError in getattr() exceptions (required for for pdoc3)
# 2022-03-16 Prevent replacement/evaluation if the string is escaped \${parameter}
# 2022-03-19 add struct2dict(), dict2struct()
# 2022-03-20 add zip(), items()
# 2022-03-27 add __setitem__(), fromkeysvalues(), struct2param()
# 2022-03-28 add read() and write()
# 2022-03-29 fix protection for $var, $variable - add keysorted(), tostruct()
# 2022-03-30 specific display p&#34;this/is/my/path&#34; for pstr
# 2022-03-31 add dispmax()
# 2022-04-05 add check(), such that a.check(b) is similar to b+a
# 2022-04-09 manage None and [] values in check()
# 2022-05-14 s[:4], s[(3,5,2)] indexing a structure with a slice, list, tuple generates a substructure
# 2022-05-14 isempty (property) is TRUE for an empty structure
# 2022-05-15 __getitem__ and __set__item are now vectorized, add clear()
# 2022-05-16 add sortdefinitions(), isexpression, isdefined(), isstrdefined()
# 2022-05-16 __add__ and __iadd__ when called explicitly (not with + and +=) accept sordefinitions=True
# 2022-05-16 improved help, add tostatic() - v 0.45 (major version)
# 2022-05-17 new class paramauto() to simplify the management of multiple definitions
# 2022-05-17 catches most common errors in expressions and display explicit error messages - v 0.46
# 2023-01-18 add indexing as a dictionary s[&#34;a&#34;] is the same as s.a - 0.461
# 2023-01-19 add % as comment instead of # to enable replacement
# 2023-01-27 param.eval() add % to freeze an interpretation (needed when a list is spanned as a string)
# 2023-01-27 struct.format() will replace {var} by ${var} if var is not defined
# 2023-08-11 display &#34;&#34; as &lt;empty string&gt; if evaluated
# 2024-09-06 add _returnerror as paramm class attribute (default=true) - dscript.lambdaScriptdata overrides it
# 2024-09-12 file management for all OS
# 2024-09-12 repr() improvements
# 2024-10-09 enable @property as attribute if _propertyasattribute is True
# 2024-10-11 add _callable__ and update()
# 2024-10-22 raises an error in escape() if s is not a string
# 2024-10-25 add dellatr()
# 2024-10-26 force silentmode to + and += operators
# 2024-12-08 fix help
# 2025-01-17 enable evaluation with ! and first recursion for lists (v1.002)
# 2025-01-18 fixes and explicit imports, better management of NumpPy arrays
# 2025-01-19 consolidation of slice handling, implicit evaluation and error handling (v1.003)


__project__ = &#34;Pizza3&#34;
__author__ = &#34;Olivier Vitrac&#34;
__copyright__ = &#34;Copyright 2022&#34;
__credits__ = [&#34;Olivier Vitrac&#34;]
__license__ = &#34;GPLv3&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;1.003&#34;


# %% Dependencies
# import types     # to check types (not required anymore since only builtin types are used)
import ast         # for safe evaluation (ast.literal_eval is used to evaluate strings starting with !)
import operator    # operators
import re          # regular expression
from pathlib import Path # for path managment (note that pstr uses its own logic)
from pathlib import PurePosixPath as PurePath
from copy import copy as duplicate # to duplicate objects
from copy import deepcopy as duplicatedeep # used by __deepcopy__()
# Import math functions
import math
import random
import numpy as np

__all__ = [&#39;AttrErrorDict&#39;, &#39;SafeEvaluator&#39;, &#39;param&#39;, &#39;paramauto&#39;, &#39;pstr&#39;, &#39;struct&#39;]


# %% Private classes, variables

_list_types = (list,tuple,np.ndarray) # list types recognized as such
_numeric_types = (int,float,str,list,tuple,np.ndarray, np.generic) # numeric types recognized as such

# Safe f&#34;&#34; to evaluate ${var}, ${expression} and some expressions ${v1}+${v2}
class SafeEvaluator(ast.NodeVisitor):
    &#34;&#34;&#34;A safe evaluator class for expressions involving math, NumPy, random, and basic operators.&#34;&#34;&#34;

    def __init__(self, context):
        self.context = {**context}
        self.context.update({
            name: getattr(math, name)
            for name in [
                &#34;sin&#34;, &#34;cos&#34;, &#34;tan&#34;, &#34;asin&#34;, &#34;acos&#34;, &#34;atan&#34;, &#34;atan2&#34;, &#34;radians&#34;, &#34;degrees&#34;,
                &#34;exp&#34;, &#34;log&#34;, &#34;log10&#34;, &#34;pow&#34;, &#34;sqrt&#34;,
                &#34;ceil&#34;, &#34;floor&#34;, &#34;fmod&#34;, &#34;modf&#34;,
                &#34;fabs&#34;, &#34;hypot&#34;, &#34;pi&#34;, &#34;e&#34;
            ]
        })
        self.context.update({
            &#34;gauss&#34;: random.gauss,
            &#34;uniform&#34;: random.uniform,
            &#34;randint&#34;: random.randint,
            &#34;choice&#34;: random.choice
        })
        self.context[&#34;np&#34;] = np  # Allow &#39;np.sin&#39;, &#39;np.cos&#39;, etc.

        # Define allowed operators
        self.operators = {
            ast.Add: operator.add,
            ast.Sub: operator.sub,
            ast.Mult: operator.mul,
            ast.Div: operator.truediv,
            ast.FloorDiv: operator.floordiv,
            ast.Mod: operator.mod,
            ast.Pow: operator.pow,
            ast.USub: operator.neg,  # Unary subtraction
        }

    def visit_Name(self, node):
        if node.id in self.context:
            return self.context[node.id]
        raise ValueError(f&#34;Variable or function &#39;{node.id}&#39; is not defined&#34;)

    def visit_Constant(self, node):
        return node.value

    def visit_BinOp(self, node):
        left = self.visit(node.left)
        right = self.visit(node.right)
        op_type = type(node.op)
        if isinstance(left, np.ndarray) and isinstance(right, np.ndarray) and isinstance(node.op, ast.MatMult):
            return np.matmul(left, right)
        if op_type in self.operators:
            return self.operators[op_type](left, right)
        raise ValueError(f&#34;Unsupported operator: {op_type}&#34;)

    def visit_UnaryOp(self, node):
        operand = self.visit(node.operand)
        op_type = type(node.op)
        if op_type in self.operators:
            return self.operators[op_type](operand)
        raise ValueError(f&#34;Unsupported unary operator: {op_type}&#34;)

    def visit_Call(self, node):
        func = self.visit(node.func)
        if callable(func):
            args = [self.visit(arg) for arg in node.args]
            kwargs = {kw.arg: self.visit(kw.value) for kw in node.keywords}
            return func(*args, **kwargs)
        raise ValueError(f&#34;Function &#39;{ast.dump(node.func)}&#39; is not callable&#34;)

    def visit_Attribute(self, node):
        value = self.visit(node.value)
        attr = node.attr
        if hasattr(value, attr):
            # If the attribute is &#34;T&#34;, return the transpose of the array
            if attr == &#34;T&#34; and isinstance(value, np.ndarray):
                return value.T
            # Check if the attribute is the &#39;@&#39; matrix multiplication operator
            if attr == &#34;@&#34; and isinstance(value, np.ndarray):
                return value @ value  # or handle accordingly with another operand
            return getattr(value, attr)
        raise ValueError(f&#34;Object &#39;{value}&#39; has no attribute &#39;{attr}&#39;&#34;)

    def visit_Subscript(self, node):
        value = self.visit(node.value)
        slice_obj = self.visit(node.slice)
        try:
            return value[slice_obj]
        except Exception as e:
            raise ValueError(f&#34;Invalid index {slice_obj} for object of type {type(value).__name__}: {e}&#34;)

    def visit_Index(self, node):
        return self.visit(node.value)

    def visit_Slice(self, node):
        lower = self.visit(node.lower) if node.lower else None
        upper = self.visit(node.upper) if node.upper else None
        step = self.visit(node.step) if node.step else None
        return slice(lower, upper, step)

    def visit_ExtSlice(self, node):
        dims = tuple(self.visit(dim) for dim in node.dims)
        return dims

    def visit_Tuple(self, node):
        return tuple(self.visit(elt) for elt in node.elts)

    def visit_List(self, node):
        return [self.visit(elt) for elt in node.elts]

    def generic_visit(self, node):
        raise ValueError(f&#34;Unsupported expression: {ast.dump(node)}&#34;)

    def evaluate(self, expression):
        tree = ast.parse(expression, mode=&#39;eval&#39;)
        return self.visit(tree.body)


# Class to handle expressions containing operators correctly without being misinterpreted as attribute accesses.
class AttrErrorDict(dict):
    &#34;&#34;&#34;Custom dictionary that raises AttributeError instead of KeyError for missing keys.&#34;&#34;&#34;
    def __getitem__(self, key):
        try:
            return super().__getitem__(key)
        except KeyError:
            raise AttributeError(f&#34;Attribute &#39;{key}&#39; not found&#34;)


# %% core struct class
class struct():
    &#34;&#34;&#34;
    Class: `struct`
    ================

    A lightweight class that mimics Matlab-like structures, with additional features
    such as dynamic field creation, indexing, concatenation, and compatibility with
    evaluated parameters (`param`).

    ---

    ### Features
    - Dynamic creation of fields.
    - Indexing and iteration support for fields.
    - Concatenation and subtraction of structures.
    - Conversion to and from dictionaries.
    - Compatible with `param` and `paramauto` for evaluation and dependency handling.

    ---

    ### Examples

    #### Basic Usage
    ```python
    s = struct(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    print(s.a)  # 1
    s.d = 11    # Append a new field
    delattr(s, &#39;d&#39;)  # Delete the field
    ```

    #### Using `param` for Evaluation
    ```python
    p = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    p.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    # --------
    ```

    ---

    ### Concatenation and Subtraction
    Fields from the right-most structure overwrite existing values.
    ```python
    a = struct(a=1, b=2)
    b = struct(c=3, d=&#34;d&#34;, e=&#34;e&#34;)
    c = a + b
    e = c - a
    ```

    ---

    ### Practical Shorthands

    #### Constructing a Structure from Keys
    ```python
    s = struct.fromkeys([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;])
    # Output:
    # --------
    #      a: None
    #      b: None
    #      c: None
    #      d: None
    # --------
    ```

    #### Building a Structure from Variables in a String
    ```python
    s = struct.scan(&#34;${a} + ${b} * ${c} / ${d} --- ${ee}&#34;)
    s.a = 1
    s.b = &#34;test&#34;
    s.c = [1, &#34;a&#34;, 2]
    s.generator()
    # Output:
    # X = struct(
    #      a=1,
    #      b=&#34;test&#34;,
    #      c=[1, &#39;a&#39;, 2],
    #      d=None,
    #      ee=None
    # )
    ```

    #### Indexing and Iteration
    Structures can be indexed or sliced like lists.
    ```python
    c = a + b
    c[0]      # Access the first field
    c[-1]     # Access the last field
    c[:2]     # Slice the structure
    for field in c:
        print(field)
    ```

    ---

    ### Dynamic Dependency Management
    `struct` provides control over dependencies, sorting, and evaluation.

    ```python
    s = struct(d=3, e=&#34;${c} + {d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    s.sortdefinitions()
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}
    #      e: ${c} + ${d}
    # --------
    ```

    For dynamic evaluation, use `param`:
    ```python
    p = param(sortdefinitions=True, d=3, e=&#34;${c} + ${d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}  (= 3)
    #      e: ${c} + ${d}  (= 6)
    # --------
    ```

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two structures (`__add__`).
    - `-`: Subtraction of fields (`__sub__`).
    - `len()`: Number of fields (`__len__`).
    - `in`: Check for field existence (`__contains__`).

    #### Method Overview
    | Method                | Description                                             |
    |-----------------------|---------------------------------------------------------|
    | `check(default)`      | Populate fields with defaults if missing.               |
    | `clear()`             | Remove all fields.                                      |
    | `dict2struct(dico)`   | Create a structure from a dictionary.                   |
    | `disp()`              | Display the structure.                                  |
    | `eval()`              | Evaluate expressions within fields.                     |
    | `fromkeys(keys)`      | Create a structure from a list of keys.                 |
    | `generator()`         | Generate Python code representing the structure.        |
    | `items()`             | Return key-value pairs.                                 |
    | `keys()`              | Return all keys in the structure.                       |
    | `read(file)`          | Load structure fields from a file.                      |
    | `scan(string)`        | Extract variables from a string and populate fields.    |
    | `sortdefinitions()`   | Sort fields to resolve dependencies.                    |
    | `struct2dict()`       | Convert the structure to a dictionary.                  |
    | `values()`            | Return all field values.                                |
    | `write(file)`         | Save the structure to a file.                           |

    ---

    ### Dynamic Properties
    | Property    | Description                            |
    |-------------|----------------------------------------|
    | `isempty`   | `True` if the structure is empty.      |
    | `isdefined` | `True` if all fields are defined.      |

    ---
    &#34;&#34;&#34;

    # attributes to be overdefined
    _type = &#34;struct&#34;        # object type
    _fulltype = &#34;structure&#34; # full name
    _ftype = &#34;field&#34;        # field name
    _evalfeature = False    # true if eval() is available
    _maxdisplay = 40        # maximum number of characters to display (should be even)
    _propertyasattribute = False

    # attributes for the iterator method
    # Please keep it static, duplicate the object before changing _iter_
    _iter_ = 0

    # excluded attributes (keep the , in the Tupple if it is singleton)
    _excludedattr = {&#39;_iter_&#39;,&#39;__class__&#39;,&#39;_protection&#39;,&#39;_evaluation&#39;,&#39;_returnerror&#39;} # used by keys() and len()


    # Methods
    def __init__(self,**kwargs):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        # Optionally extend _excludedattr here
        self._excludedattr = self._excludedattr | {&#39;_excludedattr&#39;, &#39;_type&#39;, &#39;_fulltype&#39;,&#39;_ftype&#39;} # addition 2024-10-11
        self.set(**kwargs)

    def zip(self):
        &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
        return zip(self.keys(),self.values())

    @staticmethod
    def dict2struct(dico,makeparam=False):
        &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
        if isinstance(dico,dict):
            s = param() if makeparam else struct()
            s.set(**dico)
            return s
        raise TypeError(&#34;the argument must be a dictionary&#34;)

    def struct2dict(self):
        &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
        return dict(self.zip())

    def struct2param(self,protection=False,evaluation=True):
        &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
        p = param(**self.struct2dict())
        for i in range(len(self)):
            if isinstance(self[i],pstr): p[i] = pstr(p[i])
        p._protection = protection
        p._evaluation = evaluation
        return p

    def set(self,**kwargs):
        &#34;&#34;&#34; initialization &#34;&#34;&#34;
        self.__dict__.update(kwargs)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value

    def getattr(self,key):
        &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
        if key in self.__dict__:
            return self.__dict__[key]
        elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
             key not in self._excludedattr and \
             key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
            # If _propertyasattribute is True and it&#39;s a property, get its value
            return self.__class__.__dict__[key].fget(self)
        else:
            raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)

    def hasattr(self, key):
        &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
        return key in self.__dict__ or (
            getattr(self, &#39;_propertyasattribute&#39;, False) and
            key not in self._excludedattr and
            key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
        )

    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return pstr.eval(self.getattr(key))

    def __setattr__(self,key,value):
        &#34;&#34;&#34; set attribute override &#34;&#34;&#34;
        self.setattr(key,value)

    def __contains__(self,item):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(item)

    def keys(self):
        &#34;&#34;&#34; return the fields &#34;&#34;&#34;
        # keys() is used by struct() and its iterator
        return [key for key in self.__dict__.keys() if key not in self._excludedattr]

    def keyssorted(self,reverse=True):
        &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
        klist = self.keys()
        l = [len(k) for k in klist]
        return [k for _,k in sorted(zip(l,klist),reverse=reverse)]

    def values(self):
        &#34;&#34;&#34; return the values &#34;&#34;&#34;
        # values() is used by struct() and its iterator
        return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]

    @staticmethod
    def fromkeysvalues(keys,values,makeparam=False):
        &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
            use makeparam = True to create a param instead of struct
        &#34;&#34;&#34;
        if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
        if not isinstance(keys,_list_types): keys = [keys]
        if not isinstance(values,_list_types): values = [values]
        nk,nv = len(keys), len(values)
        s = param() if makeparam else struct()
        if nk&gt;0 and nv&gt;0:
            iv = 0
            for ik in range(nk):
                s.setattr(keys[ik], values[iv])
                iv = min(nv-1,iv+1)
            for ik in range(nk,nv):
                s.setattr(f&#34;key{ik}&#34;, values[ik])
        return s

    def items(self):
        &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
        return self.zip()

    def __getitem__(self,idx):
        &#34;&#34;&#34;
            s[i] returns the ith element of the structure
            s[:4] returns a structure with the four first fields
            s[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.getattr(self.keys()[idx])
            raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            return struct.fromkeysvalues(self.keys()[idx], self.values()[idx])
        elif isinstance(idx,(list,tuple)):
            k,v= self.keys(), self.values()
            nk = len(k)
            s = param() if isinstance(self,param) else struct()
            for i in idx:
                if isinstance(i,int) and i&gt;=0 and i&lt;nk:
                    s.setattr(k[i],v[i])
                else:
                    raise IndexError(&#34;idx must contains only integers ranged between 0 and %d&#34; % (nk-1))
            return s
        elif isinstance(idx,str):
            return self.getattr(idx)
        else:
            raise TypeError(&#34;The index must be an integer or a slice and not a %s&#34; % type(idx).__name__)

    def __setitem__(self,idx,value):
        &#34;&#34;&#34; set the ith element of the structure  &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                self.setattr(self.keys()[idx], value)
            else:
                raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            k = self.keys()[idx]
            if len(value)&lt;=1:
                for i in range(len(k)): self.setattr(k[i], value)
            elif len(k) == len(value):
                for i in range(len(k)): self.setattr(k[i], value[i])
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of elements in the slive (%d)&#34; \
                       % (len(value),len(idx)))
        elif isinstance(idx,(list,tuple)):
            if len(value)&lt;=1:
                for i in range(len(idx)): self[idx[i]]=value
            elif len(idx) == len(value):
                for i in range(len(idx)): self[idx[i]]=value[i]
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of indices (%d)&#34; \
                                 % (len(value),len(idx)))

    def __len__(self):
        &#34;&#34;&#34; return the number of fields &#34;&#34;&#34;
        # len() is used by struct() and its iterator
        return len(self.keys())

    def __iter__(self):
        &#34;&#34;&#34; struct iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    def __next__(self):
        &#34;&#34;&#34; increment iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum {self._ftype} iteration reached {len(self)}&#34;)

    def __add__(self,s,sortdefinitions=False,raiseerror=True, silentmode=True):
        &#34;&#34;&#34; add a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        dup.__dict__.update(s.__dict__)
        if sortdefinitions: dup.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return dup

    def __iadd__(self,s,sortdefinitions=False,raiseerror=False, silentmode=True):
        &#34;&#34;&#34; iadd a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        self.__dict__.update(s.__dict__)
        if sortdefinitions: self.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return self

    def __sub__(self,s):
        &#34;&#34;&#34; sub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        listofkeys = dup.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(dup,k)
        return dup

    def __isub__(self,s):
        &#34;&#34;&#34; isub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        listofkeys = self.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(self,k)
        return self

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        if self.__dict__=={}:
            print(f&#34;empty {self._fulltype} ({self._type} object) with no {self._type}s&#34;)
            return f&#34;empty {self._fulltype}&#34;
        else:
            tmp = self.eval() if self._evalfeature else []
            keylengths = [len(key) for key in self.__dict__]
            width = max(10,max(keylengths)+2)
            fmt = &#34;%%%ss:&#34; % width
            fmteval = fmt[:-1]+&#34;=&#34;
            fmtcls =  fmt[:-1]+&#34;:&#34;
            line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
            print(line)
            for key,value in self.__dict__.items():
                if key not in self._excludedattr:
                    if isinstance(value,_numeric_types):
                        # old code (removed on 2025-01-18)
                        # if isinstance(value,pstr):
                        #     print(fmt % key,&#39;p&#34;&#39;+self.dispmax(value)+&#39;&#34;&#39;)
                        # if isinstance(value,str) and value==&#34;&#34;:
                        #     print(fmt % key,&#39;&#34;&#34;&#39;)
                        # else:
                        #     print(fmt % key,self.dispmax(value))
                        if isinstance(value,np.ndarray):
                            print(fmt % key, struct.format_array(value))
                        else:
                            print(fmt % key,self.dispmax(value))
                    elif isinstance(value,struct):
                        print(fmt % key,self.dispmax(value.__str__()))
                    elif isinstance(value,type):
                        print(fmt % key,self.dispmax(str(value)))
                    else:
                        print(fmt % key,type(value))
                        print(fmtcls % &#34;&#34;,self.dispmax(str(value)))
                    if self._evalfeature:
                        if isinstance(self,paramauto):
                            try:
                                if isinstance(value,pstr):
                                    print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                                elif isinstance(value,str):
                                    if value == &#34;&#34;:
                                        print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(tmp.getattr(key)))
                            except Exception as err:
                                print(fmteval % &#34;&#34;,err.message, err.args)
                        else:
                            if isinstance(value,pstr):
                                print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                            elif isinstance(value,str):
                                if value == &#34;&#34;:
                                    print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                else:
                                    calcvalue =tmp.getattr(key)
                                    if isinstance(calcvalue, str) and &#34;error&#34; in calcvalue.lower():
                                        print(fmteval % &#34;&#34;,calcvalue)
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(calcvalue))
            print(line)
            return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    def disp(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        self.__repr__()

    def __str__(self):
        return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    @property
    def isempty(self):
        &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
        return len(self)==0

    def clear(self):
        &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
        for k in self.keys(): delattr(self,k)

    def format(self, s, escape=False, raiseerror=True):
        &#34;&#34;&#34;
            Format a string with fields using {field} as placeholders.
            Handles expressions like ${variable1}.

            Args:
                s (str): The input string to format.
                escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
                raiseerror (bool): If True, raises errors for missing fields.

            Returns:
                str: The formatted string.
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format_map(AttrErrorDict(self.__dict__))
                else:
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
            except AttributeError as attr_err:
                # Handle AttributeError for expressions with operators
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
                return s_  # Revert to using &#39;${&#39; for unresolved expressions
            except Exception as other_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                raise RuntimeError from other_err
        else:
            if escape:
                return s.format_map(AttrErrorDict(self.__dict__))
            else:
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))

    def format_legacy(self,s,escape=False,raiseerror=True):
        &#34;&#34;&#34;
            format a string with field (use {field} as placeholders)
                s.replace(string), s.replace(string,escape=True)
                where:
                    s is a struct object
                    string is a string with possibly ${variable1}
                    escape is a flag to prevent ${} replaced by {}
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format(**self.__dict__)
                else:
                    return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
            except KeyError as kerr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
                return s_ # instead of s (we put back $) - OV 2023/01/27
            except Exception as othererr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                raise RuntimeError from othererr
        else:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)

    def fromkeys(self,keys):
        &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
        return self+struct(**dict.fromkeys(keys,None))

    @staticmethod
    def scan(s):
        &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
        tmp = struct()
        #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
        found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
        uniq = []
        for x in found:
            if x not in uniq: uniq.append(x)
        return tmp.fromkeys(uniq)

    @staticmethod
    def isstrexpression(s):
        &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        return re.search(r&#34;\$\{.*?\}&#34;,s) is not None

    @property
    def isexpression(self):
        &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        for k,v in self.items():
            if isinstance(v,str):
                s.setattr(k,struct.isstrexpression(v))
            else:
                s.setattr(k,False)
        return s

    @staticmethod
    def isstrdefined(s,ref):
        &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        if struct.isstrexpression(s):
            k = struct.scan(s).keys()
            allfound,i,nk = True,0,len(k)
            while (i&lt;nk) and allfound:
                allfound = k[i] in ref
                i += 1
            return allfound
        else:
            return False


    def isdefined(self,ref=None):
        &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
        nk = len(k)
        if ref is None:
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
                else:
                    s.setattr(k[i],True)
        else:
            if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],ref))
                else:
                    s.setattr(k[i],True)
        return s

    def sortdefinitions(self,raiseerror=True,silentmode=False):
        &#34;&#34;&#34; sortdefintions sorts all definitions
            so that they can be executed as param().
            If any inconsistency is found, an error message is generated.

            Flags = default values
                raiseerror=True show erros of True
                silentmode=False no warning if True
        &#34;&#34;&#34;
        find = lambda xlist: [i for i, x in enumerate(xlist) if x]
        findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
        k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
        istatic = findnot(isexpr)
        idynamic = find(isexpr)
        static = struct.fromkeysvalues(
            [ k[i] for i in istatic ],
            [ v[i] for i in istatic ],
            makeparam = False)
        dynamic = struct.fromkeysvalues(
            [ k[i] for i in idynamic ],
            [ v[i] for i in idynamic ],
            makeparam=False)
        current = static # make static the current structure
        nmissing, anychange, errorfound = len(dynamic), False, False
        while nmissing:
            itst, found = 0, False
            while itst&lt;nmissing and not found:
                teststruct = current + dynamic[[itst]] # add the test field
                found = all(list(teststruct.isdefined()))
                ifound = itst
                itst += 1
            if found:
                current = teststruct # we accept the new field
                dynamic[ifound] = []
                nmissing -= 1
                anychange = True
            else:
                if raiseerror:
                    raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                                   (nmissing,len(self),self._ftype))
                else:
                    if (not errorfound) and (not silentmode):
                        print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                              (nmissing,len(self),self._ftype))
                    current = teststruct # we accept the new field (even if it cannot be interpreted)
                    dynamic[ifound] = []
                    nmissing -= 1
                    errorfound = True
        if anychange:
            self.clear() # reset all fields and assign them in the proper order
            k,v = current.keys(), current.values()
            for i in range(len(k)):
                self.setattr(k[i],v[i])

    def generator(self):
        &#34;&#34;&#34; generate Python code of the equivalent structure &#34;&#34;&#34;
        nk = len(self)
        if nk==0:
            print(&#34;X = struct()&#34;)
        else:
            ik = 0
            fmt = &#34;%%%ss=&#34; % max(10,max([len(k) for k in self.keys()])+2)
            print(&#34;\nX = struct(&#34;)
            for k in self.keys():
                ik += 1
                end = &#34;,\n&#34; if ik&lt;nk else &#34;\n&#34;+(fmt[:-1] % &#34;)&#34;)+&#34;\n&#34;
                v = getattr(self,k)
                if isinstance(v,(int,float)) or v == None:
                    print(fmt % k,v,end=end)
                elif isinstance(v,str):
                    print(fmt % k,f&#39;&#34;{v}&#34;&#39;,end=end)
                elif isinstance(v,(list,tuple)):
                    print(fmt % k,v,end=end)
                else:
                    print(fmt % k,&#34;/* unsupported type */&#34;,end=end)

    # copy and deep copy methpds for the class
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, duplicatedeep(v, memo))
        return copie


    # write a file
    def write(self, file, overwrite=True, mkdir=False):
        &#34;&#34;&#34;
            write the equivalent structure (not recursive for nested struct)
                write(filename, overwrite=True, mkdir=False)

            Parameters:
            - file: The file path to write to.
            - overwrite: Whether to overwrite the file if it exists (default: True).
            - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()

        # Check if the directory exists or if mkdir is set to True, create it
        if mkdir:
            file_path.parent.mkdir(parents=True, exist_ok=True)
        elif not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If overwrite is False and the file already exists, raise an exception
        if not overwrite and file_path.exists():
            raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
        # Open and write to the file using the resolved path
        with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
            print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
            for k, v in self.items():
                if v is None:
                    print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
                elif isinstance(v, (int, float)):
                    print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
                elif isinstance(v, str):
                    print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
                else:
                    print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)


    # read a file
    @staticmethod
    def read(file):
        &#34;&#34;&#34;
            read the equivalent structure
                read(filename)

            Parameters:
            - file: The file path to read from.
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()
        # Check if the parent directory exists, otherwise raise an error
        if not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If the file does not exist, raise an exception
        if not file_path.exists():
            raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
        # Open and read the file
        with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            s = struct()  # Assuming struct is defined elsewhere
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                expr = line.split(sep=&#34;=&#34;)
                if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                    lhs = expr[0]
                    rhs = &#34;&#34;.join(expr[1:]).strip()
                    if len(rhs) == 0 or rhs == &#34;None&#34;:
                        v = None
                    else:
                        v = eval(rhs)
                    s.setattr(lhs, v)
        return s

    # argcheck
    def check(self,default):
        &#34;&#34;&#34;
        populate fields from a default structure
            check(defaultstruct)
            missing field, None and [] values are replaced by default ones

            Note: a.check(b) is equivalent to b+a except for [] and None values
        &#34;&#34;&#34;
        if not isinstance(default,struct):
            raise TypeError(&#34;the first argument must be a structure&#34;)
        for f in default.keys():
            ref = default.getattr(f)
            if f not in self:
                self.setattr(f, ref)
            else:
                current = self.getattr(f)
                if ((current is None)  or (current==[])) and \
                    ((ref is not None) and (ref!=[])):
                        self.setattr(f, ref)


    # update values based on key:value
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple fields at once, while protecting certain attributes.

        Parameters:
        -----------
        **kwargs : dict
            The fields to update and their new values.

        Protected attributes defined in _excludedattr are not updated.

        Usage:
        ------
        s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
        &#34;&#34;&#34;
        protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

        for key, value in kwargs.items():
            if key in protected_attributes:
                print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
            else:
                self.setattr(key, value)


    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract a sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            A new instance of the same class as the original, containing
            only the specified keys.

        Usage:
        ------
        sub_struct = s(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        # Create a new instance of the same class
        sub_struct = self.__class__()

        # Get the full type and field type for error messages
        fulltype = getattr(self, &#39;_fulltype&#39;, &#39;structure&#39;)
        ftype = getattr(self, &#39;_ftype&#39;, &#39;field&#39;)

        # Add only the specified keys to the new sub-structure
        for key in keys:
            if key in self:
                sub_struct.setattr(key, self.getattr(key))
            else:
                raise KeyError(f&#34;{fulltype} does not contain the {ftype} &#39;{key}&#39;.&#34;)

        return sub_struct


    def __delattr__(self, key):
        &#34;&#34;&#34; Delete an instance attribute if it exists and is not a class or excluded attribute. &#34;&#34;&#34;
        if key in self._excludedattr:
            raise AttributeError(f&#34;Cannot delete excluded attribute &#39;{key}&#39;&#34;)
        elif key in self.__class__.__dict__:  # Check if it&#39;s a class attribute
            raise AttributeError(f&#34;Cannot delete class attribute &#39;{key}&#39;&#34;)
        elif key in self.__dict__:  # Delete only if in instance&#39;s __dict__
            del self.__dict__[key]
        else:
            raise AttributeError(f&#34;{self._type} has no attribute &#39;{key}&#39;&#34;)


    # A la Matlab display method of vectors, matrices and ND-arrays
    @staticmethod
    def format_array(value):
        &#34;&#34;&#34;Format NumPy array for display with distinctions for row and column vectors.&#34;&#34;&#34;
        dtype_str = {
            np.float64: &#34;double&#34;,
            np.float32: &#34;single&#34;,
            np.int32: &#34;int32&#34;,
            np.int64: &#34;int64&#34;,
            np.complex64: &#34;complex single&#34;,
            np.complex128: &#34;complex double&#34;,
        }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map
        max_display = 10  # Maximum number of elements to display

        # Check if the value is a 1D array (could be a row or column vector)
        if value.ndim == 1:
            if len(value) &lt;= max_display:
                formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
            else:
                formatted = f&#34;[{len(value)}Ã—1 {dtype_str}]&#34;
        # 2D array check
        elif value.ndim == 2:
            rows, cols = value.shape
            # If it&#39;s a single column (column vector), handle it as a transpose
            if cols == 1:  # Column vector (1 x n)
                if rows &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{rows}Ã—1 {dtype_str}]&#34;
            # If it&#39;s a single row (row vector), handle it as a row vector
            elif rows == 1:  # Row vector (1 x n)
                if cols &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[1Ã—{cols} {dtype_str}]&#34;
            else:  # General 2D matrix
                formatted = f&#34;[{rows}Ã—{cols} {dtype_str}]&#34;
        # For higher-dimensional arrays
        else:
            shape_str = &#34;Ã—&#34;.join(map(str, value.shape))
            formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;
        return formatted


# %% param class with scripting and evaluation capabilities
class param(struct):
    &#34;&#34;&#34;
    Class: `param`
    ==============

    A class derived from `struct` that introduces dynamic evaluation of field values.
    The `param` class acts as a container for evaluated parameters, allowing expressions
    to depend on other fields. It supports advanced evaluation, sorting of dependencies,
    and text formatting.

    ---

    ### Features
    - Inherits all functionalities of `struct`.
    - Supports dynamic evaluation of field expressions.
    - Automatically resolves dependencies between fields.
    - Includes utility methods for text formatting and evaluation.

    ---

    ### Examples

    #### Basic Usage with Evaluation
    ```python
    s = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;, d=&#34;$this is a string&#34;, e=&#34;1000 # this is my number&#34;)
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------

    s.a = 10
    s.eval()
    # Output:
    # --------
    #      a: 10
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 12)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------
    ```

    #### Handling Text Parameters
    ```python
    s = param()
    s.mypath = &#34;$/this/folder&#34;
    s.myfile = &#34;$file&#34;
    s.myext = &#34;$ext&#34;
    s.fullfile = &#34;$${mypath}/${myfile}.${myext}&#34;
    s.eval()
    # Output:
    # --------
    #    mypath: $/this/folder (= /this/folder)
    #    myfile: $file (= file)
    #     myext: $ext (= ext)
    #  fullfile: $${mypath}/${myfile}.${myext} (= /this/folder/file.ext)
    # --------
    ```

    ---

    ### Text Evaluation and Formatting

    #### Evaluate Strings
    ```python
    s = param(a=1, b=2)
    result = s.eval(&#34;this is a string with ${a} and ${b}&#34;)
    print(result)  # &#34;this is a string with 1 and 2&#34;
    ```

    #### Prevent Evaluation
    ```python
    definitions = param(a=1, b=&#34;${a}*10+${a}&#34;, c=&#34;\${a}+10&#34;, d=&#39;\${myparam}&#39;)
    text = definitions.formateval(&#34;this is my text ${a}, ${b}, \${myvar}=${c}+${d}&#34;)
    print(text)  # &#34;this is my text 1, 11, \${myvar}=\${a}+10+${myparam}&#34;
    ```

    ---

    ### Advanced Usage

    #### Rearranging and Sorting Definitions
    ```python
    s = param(
        a=1,
        f=&#34;${e}/3&#34;,
        e=&#34;${a}*${c}&#34;,
        c=&#34;${a}+${b}&#34;,
        b=2,
        d=&#34;${c}*2&#34;
    )
    s.sortdefinitions()
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} (= 3)
    #      d: ${c} * 2 (= 6)
    #      e: ${a} * ${c} (= 3)
    #      f: ${e} / 3 (= 1.0)
    # --------
    ```

    #### Internal Evaluation and Recursion with !
    ```python
    p=param()
    p.a = [0,1,2]
    p.b = &#39;![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]&#39;
    p
    # Output:
    #  -------------:----------------------------------------
    #          a: [0, 1, 2]
    #          b: ![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]
    #           = [1, 2, &#39;test&#39;, &#39;1&#39;]
    #  -------------:----------------------------------------
    # Out: parameter list (param object) with 2 definitions
    ```

    #### Error Handling
    ```python
    p = param(b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;, a=1)
    p.disp()
    # Output:
    # --------
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      a: 1
    # --------
    ```

    Sorting unresolved definitions raises errors unless explicitly suppressed:
    ```python
    p.sortdefinitions(raiseerror=False)
    # WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
    ```

    ---

    ### Utility Methods
    | Method                 | Description                                             |
    |------------------------|---------------------------------------------------------|
    | `eval()`               | Evaluate all field expressions.                         |
    | `formateval(string)`   | Format and evaluate a string with field placeholders.   |
    | `protect(string)`      | Escape variable placeholders in a string.               |
    | `sortdefinitions()`    | Sort definitions to resolve dependencies.               |
    | `escape(string)`       | Protect escaped variables in a string.                  |
    | `safe_fstring(string)` | evaluate safely complex mathemical expressions.         |

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two parameter lists, sorting definitions.
    - `-`: Subtraction of fields.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Notes
    - The `paramauto` class simplifies handling of partial definitions and inherits from `param`.
    - Use `paramauto` when definitions need to be stacked irrespective of execution order.
    &#34;&#34;&#34;

    # override
    _type = &#34;param&#34;
    _fulltype = &#34;parameter list&#34;
    _ftype = &#34;definition&#34;
    _evalfeature = True    # This class can be evaluated with .eval()
    _returnerror = True    # This class returns an error in the evaluation string (added on 2024-09-06)

    # magic constructor
    def __init__(self,_protection=False,_evaluation=True,
                 sortdefinitions=False,**kwargs):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._protection = _protection
        self._evaluation = _evaluation
        if sortdefinitions: self.sortdefinitions()

    # escape definitions if needed
    @staticmethod
    def escape(s):
        &#34;&#34;&#34;
            escape \${} as ${{}} --&gt; keep variable names
            convert ${} as {} --&gt; prepare Python replacement

            Examples:
                escape(&#34;\${a}&#34;)
                returns (&#39;${{a}}&#39;, True)

                escape(&#34;  \${abc} ${a} \${bc}&#34;)
                returns (&#39;  ${{abc}} {a} ${{bc}}&#39;, True)

                escape(&#34;${a}&#34;)
                Out[94]: (&#39;{a}&#39;, False)

                escape(&#34;${tata}&#34;)
                returns (&#39;{tata}&#39;, False)

        &#34;&#34;&#34;
        if not isinstance(s,str):
            raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)
        se, start, found = &#34;&#34;, 0, True
        while found:
            pos0 = s.find(&#34;\${&#34;,start)
            found = pos0&gt;=0
            if found:
                pos1 = s.find(&#34;}&#34;,pos0)
                found = pos1&gt;=0
                if found:
                    se += s[start:pos0].replace(&#34;${&#34;,&#34;{&#34;)+&#34;${{&#34;+s[pos0+3:pos1]+&#34;}}&#34;
                    start=pos1+1
        result = se+s[start:].replace(&#34;${&#34;,&#34;{&#34;)
        if isinstance(s,pstr): result = pstr(result)
        return result,start&gt;0

    # protect variables in a string
    def protect(self,s=&#34;&#34;):
        &#34;&#34;&#34; protect $variable as ${variable} &#34;&#34;&#34;
        if isinstance(s,str):
            t = s.replace(&#34;\$&#34;,&#34;Â£Â£&#34;) # &amp;&amp; is a placeholder
            escape = t!=s
            for k in self.keyssorted():
                t = t.replace(&#34;$&#34;+k,&#34;${&#34;+k+&#34;}&#34;)
            if escape: t = t.replace(&#34;Â£Â£&#34;,&#34;\$&#34;)
            if isinstance(s,pstr): t = pstr(t)
            return t, escape
        raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)


    # lines starting with # (hash) are interpreted as comments
    # ${variable} or {variable} are substituted by variable.value
    # any line starting with $ is assumed to be a string (no interpretation)
    # ^ is accepted in formula(replaced by **))
    def eval(self,s=&#34;&#34;,protection=False):
        &#34;&#34;&#34;
            Eval method for structure such as MS.alias

                s = p.eval() or s = p.eval(string)

                where :
                    p is a param object
                    s is a structure with evaluated fields
                    string is only used to determine whether definitions have been forgotten

        &#34;&#34;&#34;
        # Evaluate all DEFINITIONS
        # the argument s is only used by formateval() for error management
        tmp = struct()
        for key,value in self.items():
            # strings are assumed to be expressions on one single line
            if isinstance(value,str):
                # replace ${variable} (Bash, Lammps syntax) by {variable} (Python syntax)
                # use \${variable} to prevent replacement (espace with \)
                # Protect variables if required
                ispstr = isinstance(value,pstr)
                valuesafe = pstr.eval(value,ispstr=ispstr) # value.strip()
                if protection or self._protection:
                    valuesafe, escape0 = self.protect(valuesafe)
                else:
                    escape0 = False
                # replace ${var} by {var}
                valuesafe_priorescape = valuesafe
                valuesafe, escape = param.escape(valuesafe)
                escape = escape or escape0
                # replace &#34;^&#34; (Matlab, Lammps exponent) by &#34;**&#34; (Python syntax)
                valuesafe = pstr.eval(valuesafe.replace(&#34;^&#34;,&#34;**&#34;),ispstr=ispstr)
                # Remove all content after #
                # if the first character is &#39;#&#39;, it is not comment (e.g. MarkDown titles)
                poscomment = valuesafe.find(&#34;#&#34;)
                if poscomment&gt;0: valuesafe = valuesafe[0:poscomment].strip()
                # Literal string starts with $ (no interpretation), ! (evaluation)
                if not self._evaluation:
                    tmp.setattr(key, pstr.eval(tmp.format(valuesafe,escape),ispstr=ispstr))
                elif valuesafe.startswith(&#34;!&#34;):
                    try:
                        vtmp = ast.literal_eval(valuesafe[1:])
                        if isinstance(vtmp,list):
                            for i,item in enumerate(vtmp):
                                if isinstance(item,str) and not item.strip().startswith(&#34;$&#34;):
                                    try:
                                        vtmp[i] = tmp.format(item, raiseerror=False)
                                    except Exception as ve:
                                        vtmp[i] = f&#34;Error in &lt;{item}&gt;: {ve.__class__.__name__} - {str(ve)}&#34;
                        tmp.setattr(key,vtmp)
                    except (SyntaxError, ValueError) as e:
                        tmp.setattr(key, f&#34;Error: {e.__class__.__name__} - {str(e)}&#34;)
                elif valuesafe.startswith(&#34;$&#34;) and not escape:
                    tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard $
                elif valuesafe.startswith(&#34;%&#34;):
                    tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard %
                else: # string empty or which can be evaluated
                    if valuesafe==&#34;&#34;:
                        tmp.setattr(key,valuesafe) # empty content
                    else:
                        if isinstance(value,pstr): # keep path
                            tmp.setattr(key, pstr.topath(tmp.format(valuesafe,escape=escape)))
                        elif escape:  # partial evaluation
                            tmp.setattr(key, tmp.format(valuesafe,escape=True))
                        else: # full evaluation (if it fails the last string content is returned)
                            try:
                                resstr = tmp.format(valuesafe,raiseerror=False)
                            except (KeyError,NameError) as nameerr:
                                if self._returnerror: # added on 2024-09-06
                                    strnameerr = str(nameerr).replace(&#34;&#39;&#34;,&#34;&#34;)
                                    tmp.setattr(key,&#39;&lt; undef %s &#34;${%s}&#34; &gt;&#39; % \
                                            (self._ftype,strnameerr))
                                else:
                                    tmp.setattr(key,value) #we keep the original value
                            except (SyntaxError,TypeError,ValueError) as commonerr:
                                tmp.setattr(key,&#34;ERROR &lt; %s &gt;&#34; % commonerr)
                            except (IndexError,AttributeError):
                                try:
                                    resstr = param.safe_fstring(valuesafe_priorescape,tmp)
                                except Exception as fstrerr:
                                    tmp.setattr(key,&#34;Index Error &lt; %s &gt;&#34; % fstrerr)
                                else:
                                    try:
                                        # reseval = eval(resstr)
                                        # reseval = ast.literal_eval(resstr)
                                        # Use SafeEvaluator to evaluate the final expression
                                        evaluator = SafeEvaluator(tmp)
                                        reseval = evaluator.evaluate(resstr)
                                    except Exception as othererr:
                                        #tmp.setattr(key,&#34;Mathematical Error around/in ${}: &lt; %s &gt;&#34; % othererr)
                                        tmp.setattr(key,resstr)
                                    else:
                                        tmp.setattr(key,reseval)
                            except Exception as othererr:
                                tmp.setattr(key,&#34;Error in ${}: &lt; %s &gt;&#34; % othererr)
                            else:
                                try:
                                    # reseval = eval(resstr)
                                    evaluator = SafeEvaluator(tmp)
                                    reseval = evaluator.evaluate(resstr)
                                except Exception as othererr:
                                    tmp.setattr(key,resstr.replace(&#34;\n&#34;,&#34;,&#34;)) # \n replaced by ,
                                    #tmp.setattr(key,&#34;Eval Error &lt; %s &gt;&#34; % othererr)
                                else:
                                    tmp.setattr(key,reseval)
            elif isinstance(value,_numeric_types): # already a number
                tmp.setattr(key, value) # store the value with the key
            else: # unsupported types
                if s.find(&#34;{&#34;+key+&#34;}&#34;)&gt;=0:
                    print(f&#39;*** WARNING ***\n\tIn the {self._ftype}:&#34;\n{s}\n&#34;&#39;)
                else:
                    print(f&#39;unable to interpret the &#34;{key}&#34; of type {type(value)}&#39;)
        return tmp

    # formateval obeys to following rules
    # lines starting with # (hash) are interpreted as comments
    def formateval(self,s,protection=False):
        &#34;&#34;&#34;
            format method with evaluation feature

                txt = p.formateval(&#34;this my text with ${variable1}, ${variable2} &#34;)

                where:
                    p is a param object

                Example:
                    definitions = param(a=1,b=&#34;${a}&#34;,c=&#34;\${a}&#34;)
                    text = definitions.formateval(&#34;this my text ${a}, ${b}, ${c}&#34;)
                    print(text)

        &#34;&#34;&#34;
        tmp = self.eval(s,protection=protection)
        # Do all replacements in s (keep comments)
        if len(tmp)==0:
            return s
        else:
            ispstr = isinstance(s,pstr)
            ssafe, escape = param.escape(s)
            slines = ssafe.split(&#34;\n&#34;)
            for i in range(len(slines)):
                poscomment = slines[i].find(&#34;#&#34;)
                if poscomment&gt;=0:
                    while (poscomment&gt;0) and (slines[i][poscomment-1]==&#34; &#34;):
                        poscomment -= 1
                    comment = slines[i][poscomment:len(slines[i])]
                    slines[i]  = slines[i][0:poscomment]
                else:
                    comment = &#34;&#34;
                # Protect variables if required
                if protection or self._protection:
                    slines[i], escape2 = self.protect(slines[i])
                # conversion
                if ispstr:
                    slines[i] = pstr.eval(tmp.format(slines[i],escape=escape),ispstr=ispstr)
                else:
                    slines[i] = tmp.format(slines[i],escape=escape)+comment
                # convert starting % into # to authorize replacement in comments
                if len(slines[i])&gt;0:
                    if slines[i][0] == &#34;%&#34;: slines[i]=&#34;#&#34;+slines[i][1:]
            return &#34;\n&#34;.join(slines)

    # returns the equivalent structure evaluated
    def tostruct(self,protection=False):
        &#34;&#34;&#34;
            generate the evaluated structure
                tostruct(protection=False)
        &#34;&#34;&#34;
        return self.eval(protection=protection)

    # returns the equivalent structure evaluated
    def tostatic(self):
        &#34;&#34;&#34; convert dynamic a param() object to a static struct() object.
            note: no interpretation
            note: use tostruct() to interpret them and convert it to struct
            note: tostatic().struct2param() makes it reversible
        &#34;&#34;&#34;
        return struct.fromkeysvalues(self.keys(),self.values(),makeparam=False)


    # Safe fstring
    @staticmethod
    def safe_fstring(template, context):
        &#34;&#34;&#34;Safely evaluate expressions in ${} using SafeEvaluator.&#34;&#34;&#34;
        evaluator = SafeEvaluator(context)
        # Process template string in combination with safe_fstring()
        # it is required to have an output compatible with eval()
        def process_template(valuesafe):
            &#34;&#34;&#34;
            Processes the input string by:
            1. Stripping leading and trailing whitespace.
            2. Removing comments (any text after &#39;#&#39; unless &#39;#&#39; is the first character).
            3. Replacing &#39;^&#39; with &#39;**&#39;.
            4. Replacing &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;. &lt;-- not applied anymore (brings confusion)

            Args:
                valuesafe (str): The input string to process.

            Returns:
                str: The processed string.
            &#34;&#34;&#34;
            # Step 1: Strip leading and trailing whitespace
            valuesafe = valuesafe.strip()
            # Step 2: Remove comments
            # This regex removes &#39;#&#39; and everything after it if &#39;#&#39; is not the first character
            # (?&lt;!^) is a negative lookbehind that ensures &#39;#&#39; is not at the start of the string
            valuesafe = re.sub(r&#39;(?&lt;!^)\#.*&#39;, &#39;&#39;, valuesafe)
            # Step 3: Replace &#39;^&#39; with &#39;**&#39;
            valuesafe = re.sub(r&#39;\^&#39;, &#39;**&#39;, valuesafe)
            # Step 4: Replace &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;
            # (?&lt;!\$)\{ matches &#39;{&#39; not preceded by &#39;$&#39;
            # valuesafe = re.sub(r&#39;(?&lt;!\$)\{&#39;, &#39;${&#39;, valuesafe)
            # Optional: Strip again to remove any trailing whitespace left after removing comments
            valuesafe = valuesafe.strip()
            return valuesafe
        # Adjusted display for NumPy arrays
        def serialize_result(result):
            &#34;&#34;&#34;
            Serialize the result into a string that can be evaluated in Python.
            Handles NumPy arrays by converting them to lists with commas.
            Handles other iterable types appropriately.
            &#34;&#34;&#34;
            if isinstance(result, np.ndarray):
                return str(result.tolist())
            elif isinstance(result, (list, tuple, dict)):
                return str(result)
            else:
                return str(result)
        # Regular expression to find ${expr} patterns
        pattern = re.compile(r&#39;\$\{([^{}]+)\}&#39;)
        def replacer(match):
            expr = match.group(1)
            try:
                result = evaluator.evaluate(expr)
                serialized = serialize_result(result)
                return serialized
            except Exception as e:
                return f&#34;&lt;Error: {e}&gt;&#34;
        return pattern.sub(replacer, process_template(template))



# %% str class for file and paths
# this class guarantees that paths are POSIX at any time


class pstr(str):
    &#34;&#34;&#34;
    Class: `pstr`
    =============

    A specialized string class for handling paths and filenames, derived from `struct`.
    The `pstr` class ensures compatibility with POSIX-style paths and provides enhanced
    operations for path manipulation.

    ---

    ### Features
    - Maintains POSIX-style paths.
    - Automatically handles trailing slashes.
    - Supports path concatenation using `/`.
    - Converts seamlessly back to `str` for compatibility with string methods.
    - Includes additional utility methods for path evaluation and formatting.

    ---

    ### Examples

    #### Basic Usage
    ```python
    a = pstr(&#34;this/is/mypath//&#34;)
    b = pstr(&#34;mylocalfolder/myfile.ext&#34;)
    c = a / b
    print(c)  # this/is/mypath/mylocalfolder/myfile.ext
    ```

    #### Keeping Trailing Slashes
    ```python
    a = pstr(&#34;this/is/mypath//&#34;)
    print(a)  # this/is/mypath/
    ```

    ---

    ### Path Operations

    #### Path Concatenation
    Use the `/` operator to concatenate paths:
    ```python
    a = pstr(&#34;folder/subfolder&#34;)
    b = pstr(&#34;file.txt&#34;)
    c = a / b
    print(c)  # folder/subfolder/file.txt
    ```

    #### Path Evaluation
    Evaluate or convert paths while preserving the `pstr` type:
    ```python
    result = pstr.eval(&#34;some/path/afterreplacement&#34;, ispstr=True)
    print(result)  # some/path/afterreplacement
    ```

    ---

    ### Advanced Usage

    #### Using String Methods
    Methods like `replace()` convert `pstr` back to `str`. To retain the `pstr` type:
    ```python
    new_path = pstr.eval(a.replace(&#34;mypath&#34;, &#34;newpath&#34;), ispstr=True)
    print(new_path)  # this/is/newpath/
    ```

    #### Handling POSIX Paths
    The `pstr.topath()` method ensures the path remains POSIX-compliant:
    ```python
    path = pstr(&#34;C:\\Windows\\Path&#34;)
    posix_path = path.topath()
    print(posix_path)  # C:/Windows/Path
    ```

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `/`: Concatenates two paths (`__truediv__`).
    - `+`: Concatenates strings as paths, resulting in a `pstr` object (`__add__`).
    - `+=`: Adds to an existing `pstr` object (`__iadd__`).

    ---

    ### Utility Methods

    | Method          | Description                                  |
    |------------------|----------------------------------------------|
    | `eval(value)`    | Evaluates the path or string for compatibility with `pstr`. |
    | `topath()`       | Returns the POSIX-compliant path.           |

    ---

    ### Notes
    - Use `pstr` for consistent and safe handling of file paths across different platforms.
    - Converts back to `str` when using non-`pstr` specific methods to ensure compatibility.
    &#34;&#34;&#34;

    def __repr__(self):
        result = self.topath()
        if result[-1] != &#34;/&#34; and self[-1] == &#34;/&#34;:
            result += &#34;/&#34;
        return result

    def topath(self):
        &#34;&#34;&#34; return a validated path &#34;&#34;&#34;
        value = pstr(PurePath(self))
        if value[-1] != &#34;/&#34; and self [-1]==&#34;/&#34;:
            value += &#34;/&#34;
        return value


    @staticmethod
    def eval(value,ispstr=False):
        &#34;&#34;&#34; evaluate the path of it os a path &#34;&#34;&#34;
        if isinstance(value,pstr):
            return value.topath()
        elif isinstance(value,PurePath) or ispstr:
            return pstr(value).topath()
        else:
            return value

    def __truediv__(self,value):
        &#34;&#34;&#34; overload / &#34;&#34;&#34;
        operand = pstr.eval(value)
        result = pstr(PurePath(self) / operand)
        if result[-1] != &#34;/&#34; and operand[-1] == &#34;/&#34;:
            result += &#34;/&#34;
        return result

    def __add__(self,value):
        return pstr(str(self)+value)

    def __iadd__(self,value):
        return pstr(str(self)+value)


# %% class paramauto() which enforces sortdefinitions = True, raiseerror=False
class paramauto(param):
    &#34;&#34;&#34;
    Class: `paramauto`
    ==================

    A subclass of `param` with enhanced handling for automatic sorting and evaluation
    of definitions. The `paramauto` class ensures that all fields are sorted to resolve
    dependencies, allowing seamless stacking of partially defined objects.

    ---

    ### Features
    - Inherits all functionalities of `param`.
    - Automatically sorts definitions for dependency resolution.
    - Simplifies handling of partial definitions in dynamic structures.
    - Supports safe concatenation of definitions.

    ---

    ### Examples

    #### Automatic Dependency Sorting
    Definitions are automatically sorted to resolve dependencies:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${b}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${b} (= 3)
    # --------
    ```

    #### Handling Missing Definitions
    Unresolved dependencies raise warnings but do not block execution:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------
    ```

    ---

    ### Concatenation and Inheritance
    Concatenating `paramauto` objects resolves definitions:
    ```python
    p1 = paramauto(a=1, b=&#34;${a}+2&#34;)
    p2 = paramauto(c=&#34;${b}*3&#34;)
    p3 = p1 + p2
    p3.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 2 (= 3)
    #      c: ${b} * 3 (= 9)
    # --------
    ```

    ---

    ### Utility Methods

    | Method                | Description                                            |
    |-----------------------|--------------------------------------------------------|
    | `sortdefinitions()`   | Automatically sorts fields to resolve dependencies.    |
    | `eval()`              | Evaluate all fields, resolving dependencies.           |
    | `disp()`              | Display all fields with their resolved values.         |

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `+`: Concatenates two `paramauto` objects, resolving dependencies.
    - `+=`: Updates the current object with another, resolving dependencies.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Advanced Usage

    #### Partial Definitions
    The `paramauto` class simplifies handling of partially defined fields:
    ```python
    p = paramauto(a=&#34;${d}&#34;, b=&#34;${a}+1&#34;)
    p.disp()
    # Warning: Unable to resolve dependencies.
    # --------
    #      a: ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      b: ${a} + 1 (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------

    p.d = 10
    p.disp()
    # Dependencies are resolved:
    # --------
    #      d: 10
    #      a: ${d} (= 10)
    #      b: ${a} + 1 (= 11)
    # --------
    ```

    ---

    ### Notes
    - The `paramauto` class is computationally more intensive than `param` due to automatic sorting.
    - It is ideal for managing dynamic systems with complex interdependencies.

    ### Examples
                    p = paramauto()
                    p.b = &#34;${aa}&#34;
                    p.disp()
                yields
                    WARNING: unable to interpret 1/1 expressions in &#34;definitions&#34;
                      -----------:----------------------------------------
                                b: ${aa}
                                 = &lt; undef definition &#34;${aa}&#34; &gt;
                      -----------:----------------------------------------
                      p.aa = 2
                      p.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                    -----------:----------------------------------------
                    q = paramauto(c=&#34;${aa}+${b}&#34;)+p
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                              c: ${aa}+${b}
                               = 4
                    -----------:----------------------------------------
                    q.aa = 30
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 30
                              b: ${aa}
                               = 30
                              c: ${aa}+${b}
                               = 60
                    -----------:----------------------------------------
                    q.aa = &#34;${d}&#34;
                    q.disp()
                yields multiple errors (recursion)
                WARNING: unable to interpret 3/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                           aa: ${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                            b: ${aa}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                            c: ${aa}+${b}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                  -----------:----------------------------------------
                    q.d = 100
                    q.disp()
                yields
                  -----------:----------------------------------------
                            d: 100
                           aa: ${d}
                             = 100
                            b: ${aa}
                             = 100
                            c: ${aa}+${b}
                             = 200
                  -----------:----------------------------------------


            Example:

                p = paramauto(b=&#34;${a}+1&#34;,c=&#34;${a}+${d}&#34;,a=1)
                p.disp()
            generates:
                WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                            a: 1
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                  -----------:----------------------------------------
            setting p.d
                p.d = 2
                p.disp()
            produces
                  -----------:----------------------------------------
                            a: 1
                            d: 2
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = 3
                  -----------:----------------------------------------

    &#34;&#34;&#34;

    def __add__(self,p):
        return super(param,self).__add__(p,sortdefinitions=True,raiseerror=False)

    def __iadd__(self,p):
        return super(param,self).__iadd__(p,sortdefinitions=True,raiseerror=False)

    def __repr__(self):
        self.sortdefinitions(raiseerror=False)
        #super(param,self).__repr__()
        super().__repr__()
        return str(self)

# %% DEBUG
# ===================================================
# main()
# ===================================================
# for debugging purposes (code called as a script)
# the code is called from here
# ===================================================
if __name__ == &#39;__main__&#39;:
# =============================================================================
#     # very advanced
#     import os
#     from fitness.private.loadods import alias
#     local = &#34;C:/Users/olivi/OneDrive/Data/Olivier/INRA/Etudiants &amp; visiteurs/Steward Ouadi/python/test/output/&#34;
#     odsfile = &#34;fileid_conferences_FoodRisk.ods&#34;
#     fullfodsfile = os.path.join(local,odsfile)
#     p = alias(fullfodsfile)
#     p.disp()
# =============================================================================
# new feature
    a = struct(a=1,b=2)
    a[&#34;b&#34;]
# path example
    s0 = struct(a=pstr(&#34;/tmp/&#34;),b=pstr(&#34;test////&#34;),c=pstr(&#34;${a}/${b}&#34;),d=pstr(&#34;${a}/${c}&#34;),e=pstr(&#34;$c/$a&#34;))
    s = struct.struct2param(s0,protection=True)
    s.disp()
    s.a/s.b
    str(pstr.topath(f&#34;{s.a}/{s.b}&#34;))
    s.eval()
    # escape example
    definitions = param(a=1,b=&#34;${a}*10+${a}&#34;,c=&#34;\${a}+10&#34;,d=&#39;\${myparam}&#39;)
    text = definitions.formateval(&#34;this my text ${a}, ${b}, \${myvar}=${c}+${d}&#34;)
    print(text)

    definitions = param(a=1,b=&#34;$a*10+$a&#34;,c=&#34;\$a+10&#34;,d=&#39;\$myparam&#39;)
    text = definitions.formateval(&#34;this my text $a, $b, \$myvar=$c+$d&#34;,protection=True)
    print(text)
    # assignment
    s = struct(a=1,b=2)
    s[1] = 3
    s.disp()
    # conversion
    s = {&#34;a&#34;:1, &#34;b&#34;:2}
    t=struct.dict2struct(s)
    t.disp()
    sback = t.struct2dict()
    sback.__repr__()
    # file definition
    p=struct.fromkeysvalues([&#34;a&#34;,&#34;b&#34;,&#34;c&#34;,&#34;d&#34;],[1,2,3]).struct2param()
    ptxt = p.protect(&#34;$c=$a+$b&#34;)
    definitions.write(&#34;../../tmp/test.txt&#34;)
    # populate/inherit fields
    default = struct(a=1,b=&#34;2&#34;,c=[1,2,3])
    tst = struct(a=10)
    tst.check(default)
    tst.disp()
    # multiple assigment
    a = struct(a=1,b=2,c=3,d=4)
    b = struct(a=10,b=20,c=30,d=40)
    a[:2] = b[1:3]
    a[:2] = b[(1,3)]
    # reorganize definitions to enable param.eval()
    s = param(
        a = 1,
        f = &#34;${e}/3&#34;,
        e = &#34;${a}*${c}&#34;,
        c = &#34;${a}+${b}&#34;,
        b = 2,
        d = &#34;${c}*2&#34;
        )
    #s[0:2] = [1,2]
    s.isexpression
    struct.isstrdefined(&#34;${a}+${b}&#34;,s)
    s.isdefined()
    s.sortdefinitions()
    s.disp()
    p = param(b=&#34;${a}+1&#34;,c=&#34;${a}+${d}&#34;,a=1)
    p.disp()

# features 2025
    p=param()
    p.a = [0,1,2]
    p.b = &#39;![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]&#39;
    p

# Mathematical expressions
    # Example: param.safe_fstring()
    # Sample context with a NumPy array
    context = param(
        f = np.array([
            [1, 2, 3, 4],
            [5, 6, 7, 8],
            [9, 10, 11, 12],
            [13, 14, 15, 16]
        ])
    )
    # Example expressions
    expressions = [
        &#34;${a[1]}&#34;,                # Should return 0.2 (assuming &#39;a&#39; is defined in context)
        &#34;${b[0,1]} + ${a[0]}&#34;,    # Should return 1.2 (assuming &#39;b&#39; and &#39;a&#39; are defined)
        &#34;${f[0:2,1]}&#34;               # Should return the second column of &#39;f&#39;
    ]
    # Assuming &#39;a&#39; and &#39;b&#39; are defined in the context
    context.update(
        a =[1.0, 0.2, 0.03, 0.004],
        b = np.array([[1, 0.2, 0.03, 0.004]])
    )
    for expr in expressions:
        result = param.safe_fstring(expr, context)
        print(f&#34;Expression: {expr} =&gt; Result: {result}&#34;)

    # OUTPUT
    #   -------------:----------------------------------------
    # Expression: ${a[1]} =&gt; Result: 0.2
    # Expression: ${b[0,1]} + ${a[0]} =&gt; Result: 0.2 + 1.0
    # Expression: ${f[0:2,1]} =&gt; Result: [2, 6]
    #   -------------:----------------------------------------

    # Example with matrix operations
    p=param()
    p.a = [1.0, .2, .03, .004]
    p.b = np.array([p.a])
    p.c = p.a*2
    p.d = p.b*2
    p.e = p.b.T
    p.f = p.b.T@p.b # Matrix multiplication for (3x1) @ (1x3)
    p.g = &#34;${a[1]}&#34;
    p.h = &#34;${b[0,1]} + ${a[0]}&#34;
    p.i = &#34;${f[0,1]}&#34;
    p.j = &#34;${f[:,1]}&#34;
    p.k = &#34;${j}+1&#34;
    p.l = &#34;${b.T}&#34;
    p.m = &#34;${b.T @ b}&#34;    # evaluate fully the matrix operation
    p.n = &#34;${b.T} @ ${b}&#34; # concatenate two string-results separated by @
    p.o =&#34;the result is: ${b[0,1]} + ${a[0]}&#34;
    p.p = &#34;the value of a[0] is ${a[0]}&#34;
    p.q = &#34;1+1&#34;
    print(repr(p))

    # OUTPUT
    #   -------------:----------------------------------------
    #               a: [1.0, 0.2, 0.03, 0.004]
    #               b: [1 0.2 0.03 0.004] (double)
    #               c: [1.0, 0.2, 0.03, 0.0 [...] 0, 0.2, 0.03, 0.004]
    #               d: [2 0.4 0.06 0.008] (double)
    #               e: [1 0.2 0.03 0.004]T (double)
    #               f: [4Ã—4 double]
    #               g: ${a[1]}
    #                = 0.2
    #               h: ${b[0,1]} + ${a[0]}
    #                = 1.2
    #               i: ${f[0,1]}
    #                = 0.2
    #               j: ${f[:,1]}
    #                = [0.2, 0.040000000000 [...] 0001, 0.006, 0.0008]
    #               k: ${j}+1
    #                = [0.2, 0.040000000000 [...] 01, 0.006, 0.0008]+1
    #               l: ${b.T}
    #                = [[1.   ], [0.2  ], [0.03 ], [0.004]]
    #               m: ${b.T @ b}
    #                = [[1.0, 0.2, 0.03, 0. [...] , 0.00012, 1.6e-05]]
    #               n: ${b.T} @ ${b}
    #                = [[1.   ], [0.2  ], [ [...]  0.2   0.03  0.004]]
    #               o: the result is: ${b[0,1]} + ${a[0]}
    #                = the result is: 0.2 + 1.0
    #               p: the value of a[0] is ${a[0]}
    #                = the value of a[0] is 1.0
    #               q: 1+1
    #                = 2
    #   -------------:----------------------------------------
    # parameter list (param object) with 17 definitions</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mstruct.AttrErrorDict"><code class="flex name class">
<span>class <span class="ident">AttrErrorDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom dictionary that raises AttributeError instead of KeyError for missing keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttrErrorDict(dict):
    &#34;&#34;&#34;Custom dictionary that raises AttributeError instead of KeyError for missing keys.&#34;&#34;&#34;
    def __getitem__(self, key):
        try:
            return super().__getitem__(key)
        except KeyError:
            raise AttributeError(f&#34;Attribute &#39;{key}&#39; not found&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
<dt id="mstruct.SafeEvaluator"><code class="flex name class">
<span>class <span class="ident">SafeEvaluator</span></span>
<span>(</span><span>context)</span>
</code></dt>
<dd>
<div class="desc"><p>A safe evaluator class for expressions involving math, NumPy, random, and basic operators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SafeEvaluator(ast.NodeVisitor):
    &#34;&#34;&#34;A safe evaluator class for expressions involving math, NumPy, random, and basic operators.&#34;&#34;&#34;

    def __init__(self, context):
        self.context = {**context}
        self.context.update({
            name: getattr(math, name)
            for name in [
                &#34;sin&#34;, &#34;cos&#34;, &#34;tan&#34;, &#34;asin&#34;, &#34;acos&#34;, &#34;atan&#34;, &#34;atan2&#34;, &#34;radians&#34;, &#34;degrees&#34;,
                &#34;exp&#34;, &#34;log&#34;, &#34;log10&#34;, &#34;pow&#34;, &#34;sqrt&#34;,
                &#34;ceil&#34;, &#34;floor&#34;, &#34;fmod&#34;, &#34;modf&#34;,
                &#34;fabs&#34;, &#34;hypot&#34;, &#34;pi&#34;, &#34;e&#34;
            ]
        })
        self.context.update({
            &#34;gauss&#34;: random.gauss,
            &#34;uniform&#34;: random.uniform,
            &#34;randint&#34;: random.randint,
            &#34;choice&#34;: random.choice
        })
        self.context[&#34;np&#34;] = np  # Allow &#39;np.sin&#39;, &#39;np.cos&#39;, etc.

        # Define allowed operators
        self.operators = {
            ast.Add: operator.add,
            ast.Sub: operator.sub,
            ast.Mult: operator.mul,
            ast.Div: operator.truediv,
            ast.FloorDiv: operator.floordiv,
            ast.Mod: operator.mod,
            ast.Pow: operator.pow,
            ast.USub: operator.neg,  # Unary subtraction
        }

    def visit_Name(self, node):
        if node.id in self.context:
            return self.context[node.id]
        raise ValueError(f&#34;Variable or function &#39;{node.id}&#39; is not defined&#34;)

    def visit_Constant(self, node):
        return node.value

    def visit_BinOp(self, node):
        left = self.visit(node.left)
        right = self.visit(node.right)
        op_type = type(node.op)
        if isinstance(left, np.ndarray) and isinstance(right, np.ndarray) and isinstance(node.op, ast.MatMult):
            return np.matmul(left, right)
        if op_type in self.operators:
            return self.operators[op_type](left, right)
        raise ValueError(f&#34;Unsupported operator: {op_type}&#34;)

    def visit_UnaryOp(self, node):
        operand = self.visit(node.operand)
        op_type = type(node.op)
        if op_type in self.operators:
            return self.operators[op_type](operand)
        raise ValueError(f&#34;Unsupported unary operator: {op_type}&#34;)

    def visit_Call(self, node):
        func = self.visit(node.func)
        if callable(func):
            args = [self.visit(arg) for arg in node.args]
            kwargs = {kw.arg: self.visit(kw.value) for kw in node.keywords}
            return func(*args, **kwargs)
        raise ValueError(f&#34;Function &#39;{ast.dump(node.func)}&#39; is not callable&#34;)

    def visit_Attribute(self, node):
        value = self.visit(node.value)
        attr = node.attr
        if hasattr(value, attr):
            # If the attribute is &#34;T&#34;, return the transpose of the array
            if attr == &#34;T&#34; and isinstance(value, np.ndarray):
                return value.T
            # Check if the attribute is the &#39;@&#39; matrix multiplication operator
            if attr == &#34;@&#34; and isinstance(value, np.ndarray):
                return value @ value  # or handle accordingly with another operand
            return getattr(value, attr)
        raise ValueError(f&#34;Object &#39;{value}&#39; has no attribute &#39;{attr}&#39;&#34;)

    def visit_Subscript(self, node):
        value = self.visit(node.value)
        slice_obj = self.visit(node.slice)
        try:
            return value[slice_obj]
        except Exception as e:
            raise ValueError(f&#34;Invalid index {slice_obj} for object of type {type(value).__name__}: {e}&#34;)

    def visit_Index(self, node):
        return self.visit(node.value)

    def visit_Slice(self, node):
        lower = self.visit(node.lower) if node.lower else None
        upper = self.visit(node.upper) if node.upper else None
        step = self.visit(node.step) if node.step else None
        return slice(lower, upper, step)

    def visit_ExtSlice(self, node):
        dims = tuple(self.visit(dim) for dim in node.dims)
        return dims

    def visit_Tuple(self, node):
        return tuple(self.visit(elt) for elt in node.elts)

    def visit_List(self, node):
        return [self.visit(elt) for elt in node.elts]

    def generic_visit(self, node):
        raise ValueError(f&#34;Unsupported expression: {ast.dump(node)}&#34;)

    def evaluate(self, expression):
        tree = ast.parse(expression, mode=&#39;eval&#39;)
        return self.visit(tree.body)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ast.NodeVisitor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mstruct.SafeEvaluator.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, expression):
    tree = ast.parse(expression, mode=&#39;eval&#39;)
    return self.visit(tree.body)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.generic_visit"><code class="name flex">
<span>def <span class="ident">generic_visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Called if no explicit visitor function exists for a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_visit(self, node):
    raise ValueError(f&#34;Unsupported expression: {ast.dump(node)}&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Attribute"><code class="name flex">
<span>def <span class="ident">visit_Attribute</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Attribute(self, node):
    value = self.visit(node.value)
    attr = node.attr
    if hasattr(value, attr):
        # If the attribute is &#34;T&#34;, return the transpose of the array
        if attr == &#34;T&#34; and isinstance(value, np.ndarray):
            return value.T
        # Check if the attribute is the &#39;@&#39; matrix multiplication operator
        if attr == &#34;@&#34; and isinstance(value, np.ndarray):
            return value @ value  # or handle accordingly with another operand
        return getattr(value, attr)
    raise ValueError(f&#34;Object &#39;{value}&#39; has no attribute &#39;{attr}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_BinOp"><code class="name flex">
<span>def <span class="ident">visit_BinOp</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_BinOp(self, node):
    left = self.visit(node.left)
    right = self.visit(node.right)
    op_type = type(node.op)
    if isinstance(left, np.ndarray) and isinstance(right, np.ndarray) and isinstance(node.op, ast.MatMult):
        return np.matmul(left, right)
    if op_type in self.operators:
        return self.operators[op_type](left, right)
    raise ValueError(f&#34;Unsupported operator: {op_type}&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Call"><code class="name flex">
<span>def <span class="ident">visit_Call</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Call(self, node):
    func = self.visit(node.func)
    if callable(func):
        args = [self.visit(arg) for arg in node.args]
        kwargs = {kw.arg: self.visit(kw.value) for kw in node.keywords}
        return func(*args, **kwargs)
    raise ValueError(f&#34;Function &#39;{ast.dump(node.func)}&#39; is not callable&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Constant"><code class="name flex">
<span>def <span class="ident">visit_Constant</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Constant(self, node):
    return node.value</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_ExtSlice"><code class="name flex">
<span>def <span class="ident">visit_ExtSlice</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ExtSlice(self, node):
    dims = tuple(self.visit(dim) for dim in node.dims)
    return dims</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Index"><code class="name flex">
<span>def <span class="ident">visit_Index</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Index(self, node):
    return self.visit(node.value)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_List"><code class="name flex">
<span>def <span class="ident">visit_List</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_List(self, node):
    return [self.visit(elt) for elt in node.elts]</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Name(self, node):
    if node.id in self.context:
        return self.context[node.id]
    raise ValueError(f&#34;Variable or function &#39;{node.id}&#39; is not defined&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Slice"><code class="name flex">
<span>def <span class="ident">visit_Slice</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Slice(self, node):
    lower = self.visit(node.lower) if node.lower else None
    upper = self.visit(node.upper) if node.upper else None
    step = self.visit(node.step) if node.step else None
    return slice(lower, upper, step)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Subscript"><code class="name flex">
<span>def <span class="ident">visit_Subscript</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Subscript(self, node):
    value = self.visit(node.value)
    slice_obj = self.visit(node.slice)
    try:
        return value[slice_obj]
    except Exception as e:
        raise ValueError(f&#34;Invalid index {slice_obj} for object of type {type(value).__name__}: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Tuple"><code class="name flex">
<span>def <span class="ident">visit_Tuple</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Tuple(self, node):
    return tuple(self.visit(elt) for elt in node.elts)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_UnaryOp"><code class="name flex">
<span>def <span class="ident">visit_UnaryOp</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_UnaryOp(self, node):
    operand = self.visit(node.operand)
    op_type = type(node.op)
    if op_type in self.operators:
        return self.operators[op_type](operand)
    raise ValueError(f&#34;Unsupported unary operator: {op_type}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mstruct.param"><code class="flex name class">
<span>class <span class="ident">param</span></span>
<span>(</span><span>sortdefinitions=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-param">Class: <code><a title="mstruct.param" href="#mstruct.param">param</a></code></h1>
<p>A class derived from <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code> that introduces dynamic evaluation of field values.
The <code><a title="mstruct.param" href="#mstruct.param">param</a></code> class acts as a container for evaluated parameters, allowing expressions
to depend on other fields. It supports advanced evaluation, sorting of dependencies,
and text formatting.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Inherits all functionalities of <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code>.</li>
<li>Supports dynamic evaluation of field expressions.</li>
<li>Automatically resolves dependencies between fields.</li>
<li>Includes utility methods for text formatting and evaluation.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage-with-evaluation">Basic Usage with Evaluation</h4>
<pre><code class="language-python">s = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can', d=&quot;$this is a string&quot;, e=&quot;1000 # this is my number&quot;)
s.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
#      d: $this is a string (= this is a string)
#      e: 1000 # this is my number (= 1000)
# --------

s.a = 10
s.eval()
# Output:
# --------
#      a: 10
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 12)
#      d: $this is a string (= this is a string)
#      e: 1000 # this is my number (= 1000)
# --------
</code></pre>
<h4 id="handling-text-parameters">Handling Text Parameters</h4>
<pre><code class="language-python">s = param()
s.mypath = &quot;$/this/folder&quot;
s.myfile = &quot;$file&quot;
s.myext = &quot;$ext&quot;
s.fullfile = &quot;$${mypath}/${myfile}.${myext}&quot;
s.eval()
# Output:
# --------
#    mypath: $/this/folder (= /this/folder)
#    myfile: $file (= file)
#     myext: $ext (= ext)
#  fullfile: $${mypath}/${myfile}.${myext} (= /this/folder/file.ext)
# --------
</code></pre>
<hr>
<h3 id="text-evaluation-and-formatting">Text Evaluation and Formatting</h3>
<h4 id="evaluate-strings">Evaluate Strings</h4>
<pre><code class="language-python">s = param(a=1, b=2)
result = s.eval(&quot;this is a string with ${a} and ${b}&quot;)
print(result)  # &quot;this is a string with 1 and 2&quot;
</code></pre>
<h4 id="prevent-evaluation">Prevent Evaluation</h4>
<pre><code class="language-python">definitions = param(a=1, b=&quot;${a}*10+${a}&quot;, c=&quot;\${a}+10&quot;, d='\${myparam}')
text = definitions.formateval(&quot;this is my text ${a}, ${b}, \${myvar}=${c}+${d}&quot;)
print(text)  # &quot;this is my text 1, 11, \${myvar}=\${a}+10+${myparam}&quot;
</code></pre>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="rearranging-and-sorting-definitions">Rearranging and Sorting Definitions</h4>
<pre><code class="language-python">s = param(
    a=1,
    f=&quot;${e}/3&quot;,
    e=&quot;${a}*${c}&quot;,
    c=&quot;${a}+${b}&quot;,
    b=2,
    d=&quot;${c}*2&quot;
)
s.sortdefinitions()
s.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} (= 3)
#      d: ${c} * 2 (= 6)
#      e: ${a} * ${c} (= 3)
#      f: ${e} / 3 (= 1.0)
# --------
</code></pre>
<h4 id="internal-evaluation-and-recursion-with">Internal Evaluation and Recursion with !</h4>
<pre><code class="language-python">p=param()
p.a = [0,1,2]
p.b = '![1,2,&quot;test&quot;,&quot;${a[1]}&quot;]'
p
# Output:
#  -------------:----------------------------------------
#          a: [0, 1, 2]
#          b: ![1,2,&quot;test&quot;,&quot;${a[1]}&quot;]
#           = [1, 2, 'test', '1']
#  -------------:----------------------------------------
# Out: parameter list (param object) with 2 definitions
</code></pre>
<h4 id="error-handling">Error Handling</h4>
<pre><code class="language-python">p = param(b=&quot;${a}+1&quot;, c=&quot;${a}+${d}&quot;, a=1)
p.disp()
# Output:
# --------
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
#      a: 1
# --------
</code></pre>
<p>Sorting unresolved definitions raises errors unless explicitly suppressed:</p>
<pre><code class="language-python">p.sortdefinitions(raiseerror=False)
# WARNING: unable to interpret 1/3 expressions in &quot;definitions&quot;
</code></pre>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eval()</code></td>
<td>Evaluate all field expressions.</td>
</tr>
<tr>
<td><code>formateval(string)</code></td>
<td>Format and evaluate a string with field placeholders.</td>
</tr>
<tr>
<td><code>protect(string)</code></td>
<td>Escape variable placeholders in a string.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort definitions to resolve dependencies.</td>
</tr>
<tr>
<td><code>escape(string)</code></td>
<td>Protect escaped variables in a string.</td>
</tr>
<tr>
<td><code>safe_fstring(string)</code></td>
<td>evaluate safely complex mathemical expressions.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two parameter lists, sorting definitions.</li>
<li><code>-</code>: Subtraction of fields.</li>
<li><code>len()</code>: Number of fields.</li>
<li><code>in</code>: Check for field existence.</li>
</ul>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>The <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> class simplifies handling of partial definitions and inherits from <code><a title="mstruct.param" href="#mstruct.param">param</a></code>.</li>
<li>Use <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> when definitions need to be stacked irrespective of execution order.</li>
</ul>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class param(struct):
    &#34;&#34;&#34;
    Class: `param`
    ==============

    A class derived from `struct` that introduces dynamic evaluation of field values.
    The `param` class acts as a container for evaluated parameters, allowing expressions
    to depend on other fields. It supports advanced evaluation, sorting of dependencies,
    and text formatting.

    ---

    ### Features
    - Inherits all functionalities of `struct`.
    - Supports dynamic evaluation of field expressions.
    - Automatically resolves dependencies between fields.
    - Includes utility methods for text formatting and evaluation.

    ---

    ### Examples

    #### Basic Usage with Evaluation
    ```python
    s = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;, d=&#34;$this is a string&#34;, e=&#34;1000 # this is my number&#34;)
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------

    s.a = 10
    s.eval()
    # Output:
    # --------
    #      a: 10
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 12)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------
    ```

    #### Handling Text Parameters
    ```python
    s = param()
    s.mypath = &#34;$/this/folder&#34;
    s.myfile = &#34;$file&#34;
    s.myext = &#34;$ext&#34;
    s.fullfile = &#34;$${mypath}/${myfile}.${myext}&#34;
    s.eval()
    # Output:
    # --------
    #    mypath: $/this/folder (= /this/folder)
    #    myfile: $file (= file)
    #     myext: $ext (= ext)
    #  fullfile: $${mypath}/${myfile}.${myext} (= /this/folder/file.ext)
    # --------
    ```

    ---

    ### Text Evaluation and Formatting

    #### Evaluate Strings
    ```python
    s = param(a=1, b=2)
    result = s.eval(&#34;this is a string with ${a} and ${b}&#34;)
    print(result)  # &#34;this is a string with 1 and 2&#34;
    ```

    #### Prevent Evaluation
    ```python
    definitions = param(a=1, b=&#34;${a}*10+${a}&#34;, c=&#34;\${a}+10&#34;, d=&#39;\${myparam}&#39;)
    text = definitions.formateval(&#34;this is my text ${a}, ${b}, \${myvar}=${c}+${d}&#34;)
    print(text)  # &#34;this is my text 1, 11, \${myvar}=\${a}+10+${myparam}&#34;
    ```

    ---

    ### Advanced Usage

    #### Rearranging and Sorting Definitions
    ```python
    s = param(
        a=1,
        f=&#34;${e}/3&#34;,
        e=&#34;${a}*${c}&#34;,
        c=&#34;${a}+${b}&#34;,
        b=2,
        d=&#34;${c}*2&#34;
    )
    s.sortdefinitions()
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} (= 3)
    #      d: ${c} * 2 (= 6)
    #      e: ${a} * ${c} (= 3)
    #      f: ${e} / 3 (= 1.0)
    # --------
    ```

    #### Internal Evaluation and Recursion with !
    ```python
    p=param()
    p.a = [0,1,2]
    p.b = &#39;![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]&#39;
    p
    # Output:
    #  -------------:----------------------------------------
    #          a: [0, 1, 2]
    #          b: ![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]
    #           = [1, 2, &#39;test&#39;, &#39;1&#39;]
    #  -------------:----------------------------------------
    # Out: parameter list (param object) with 2 definitions
    ```

    #### Error Handling
    ```python
    p = param(b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;, a=1)
    p.disp()
    # Output:
    # --------
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      a: 1
    # --------
    ```

    Sorting unresolved definitions raises errors unless explicitly suppressed:
    ```python
    p.sortdefinitions(raiseerror=False)
    # WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
    ```

    ---

    ### Utility Methods
    | Method                 | Description                                             |
    |------------------------|---------------------------------------------------------|
    | `eval()`               | Evaluate all field expressions.                         |
    | `formateval(string)`   | Format and evaluate a string with field placeholders.   |
    | `protect(string)`      | Escape variable placeholders in a string.               |
    | `sortdefinitions()`    | Sort definitions to resolve dependencies.               |
    | `escape(string)`       | Protect escaped variables in a string.                  |
    | `safe_fstring(string)` | evaluate safely complex mathemical expressions.         |

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two parameter lists, sorting definitions.
    - `-`: Subtraction of fields.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Notes
    - The `paramauto` class simplifies handling of partial definitions and inherits from `param`.
    - Use `paramauto` when definitions need to be stacked irrespective of execution order.
    &#34;&#34;&#34;

    # override
    _type = &#34;param&#34;
    _fulltype = &#34;parameter list&#34;
    _ftype = &#34;definition&#34;
    _evalfeature = True    # This class can be evaluated with .eval()
    _returnerror = True    # This class returns an error in the evaluation string (added on 2024-09-06)

    # magic constructor
    def __init__(self,_protection=False,_evaluation=True,
                 sortdefinitions=False,**kwargs):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._protection = _protection
        self._evaluation = _evaluation
        if sortdefinitions: self.sortdefinitions()

    # escape definitions if needed
    @staticmethod
    def escape(s):
        &#34;&#34;&#34;
            escape \${} as ${{}} --&gt; keep variable names
            convert ${} as {} --&gt; prepare Python replacement

            Examples:
                escape(&#34;\${a}&#34;)
                returns (&#39;${{a}}&#39;, True)

                escape(&#34;  \${abc} ${a} \${bc}&#34;)
                returns (&#39;  ${{abc}} {a} ${{bc}}&#39;, True)

                escape(&#34;${a}&#34;)
                Out[94]: (&#39;{a}&#39;, False)

                escape(&#34;${tata}&#34;)
                returns (&#39;{tata}&#39;, False)

        &#34;&#34;&#34;
        if not isinstance(s,str):
            raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)
        se, start, found = &#34;&#34;, 0, True
        while found:
            pos0 = s.find(&#34;\${&#34;,start)
            found = pos0&gt;=0
            if found:
                pos1 = s.find(&#34;}&#34;,pos0)
                found = pos1&gt;=0
                if found:
                    se += s[start:pos0].replace(&#34;${&#34;,&#34;{&#34;)+&#34;${{&#34;+s[pos0+3:pos1]+&#34;}}&#34;
                    start=pos1+1
        result = se+s[start:].replace(&#34;${&#34;,&#34;{&#34;)
        if isinstance(s,pstr): result = pstr(result)
        return result,start&gt;0

    # protect variables in a string
    def protect(self,s=&#34;&#34;):
        &#34;&#34;&#34; protect $variable as ${variable} &#34;&#34;&#34;
        if isinstance(s,str):
            t = s.replace(&#34;\$&#34;,&#34;Â£Â£&#34;) # &amp;&amp; is a placeholder
            escape = t!=s
            for k in self.keyssorted():
                t = t.replace(&#34;$&#34;+k,&#34;${&#34;+k+&#34;}&#34;)
            if escape: t = t.replace(&#34;Â£Â£&#34;,&#34;\$&#34;)
            if isinstance(s,pstr): t = pstr(t)
            return t, escape
        raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)


    # lines starting with # (hash) are interpreted as comments
    # ${variable} or {variable} are substituted by variable.value
    # any line starting with $ is assumed to be a string (no interpretation)
    # ^ is accepted in formula(replaced by **))
    def eval(self,s=&#34;&#34;,protection=False):
        &#34;&#34;&#34;
            Eval method for structure such as MS.alias

                s = p.eval() or s = p.eval(string)

                where :
                    p is a param object
                    s is a structure with evaluated fields
                    string is only used to determine whether definitions have been forgotten

        &#34;&#34;&#34;
        # Evaluate all DEFINITIONS
        # the argument s is only used by formateval() for error management
        tmp = struct()
        for key,value in self.items():
            # strings are assumed to be expressions on one single line
            if isinstance(value,str):
                # replace ${variable} (Bash, Lammps syntax) by {variable} (Python syntax)
                # use \${variable} to prevent replacement (espace with \)
                # Protect variables if required
                ispstr = isinstance(value,pstr)
                valuesafe = pstr.eval(value,ispstr=ispstr) # value.strip()
                if protection or self._protection:
                    valuesafe, escape0 = self.protect(valuesafe)
                else:
                    escape0 = False
                # replace ${var} by {var}
                valuesafe_priorescape = valuesafe
                valuesafe, escape = param.escape(valuesafe)
                escape = escape or escape0
                # replace &#34;^&#34; (Matlab, Lammps exponent) by &#34;**&#34; (Python syntax)
                valuesafe = pstr.eval(valuesafe.replace(&#34;^&#34;,&#34;**&#34;),ispstr=ispstr)
                # Remove all content after #
                # if the first character is &#39;#&#39;, it is not comment (e.g. MarkDown titles)
                poscomment = valuesafe.find(&#34;#&#34;)
                if poscomment&gt;0: valuesafe = valuesafe[0:poscomment].strip()
                # Literal string starts with $ (no interpretation), ! (evaluation)
                if not self._evaluation:
                    tmp.setattr(key, pstr.eval(tmp.format(valuesafe,escape),ispstr=ispstr))
                elif valuesafe.startswith(&#34;!&#34;):
                    try:
                        vtmp = ast.literal_eval(valuesafe[1:])
                        if isinstance(vtmp,list):
                            for i,item in enumerate(vtmp):
                                if isinstance(item,str) and not item.strip().startswith(&#34;$&#34;):
                                    try:
                                        vtmp[i] = tmp.format(item, raiseerror=False)
                                    except Exception as ve:
                                        vtmp[i] = f&#34;Error in &lt;{item}&gt;: {ve.__class__.__name__} - {str(ve)}&#34;
                        tmp.setattr(key,vtmp)
                    except (SyntaxError, ValueError) as e:
                        tmp.setattr(key, f&#34;Error: {e.__class__.__name__} - {str(e)}&#34;)
                elif valuesafe.startswith(&#34;$&#34;) and not escape:
                    tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard $
                elif valuesafe.startswith(&#34;%&#34;):
                    tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard %
                else: # string empty or which can be evaluated
                    if valuesafe==&#34;&#34;:
                        tmp.setattr(key,valuesafe) # empty content
                    else:
                        if isinstance(value,pstr): # keep path
                            tmp.setattr(key, pstr.topath(tmp.format(valuesafe,escape=escape)))
                        elif escape:  # partial evaluation
                            tmp.setattr(key, tmp.format(valuesafe,escape=True))
                        else: # full evaluation (if it fails the last string content is returned)
                            try:
                                resstr = tmp.format(valuesafe,raiseerror=False)
                            except (KeyError,NameError) as nameerr:
                                if self._returnerror: # added on 2024-09-06
                                    strnameerr = str(nameerr).replace(&#34;&#39;&#34;,&#34;&#34;)
                                    tmp.setattr(key,&#39;&lt; undef %s &#34;${%s}&#34; &gt;&#39; % \
                                            (self._ftype,strnameerr))
                                else:
                                    tmp.setattr(key,value) #we keep the original value
                            except (SyntaxError,TypeError,ValueError) as commonerr:
                                tmp.setattr(key,&#34;ERROR &lt; %s &gt;&#34; % commonerr)
                            except (IndexError,AttributeError):
                                try:
                                    resstr = param.safe_fstring(valuesafe_priorescape,tmp)
                                except Exception as fstrerr:
                                    tmp.setattr(key,&#34;Index Error &lt; %s &gt;&#34; % fstrerr)
                                else:
                                    try:
                                        # reseval = eval(resstr)
                                        # reseval = ast.literal_eval(resstr)
                                        # Use SafeEvaluator to evaluate the final expression
                                        evaluator = SafeEvaluator(tmp)
                                        reseval = evaluator.evaluate(resstr)
                                    except Exception as othererr:
                                        #tmp.setattr(key,&#34;Mathematical Error around/in ${}: &lt; %s &gt;&#34; % othererr)
                                        tmp.setattr(key,resstr)
                                    else:
                                        tmp.setattr(key,reseval)
                            except Exception as othererr:
                                tmp.setattr(key,&#34;Error in ${}: &lt; %s &gt;&#34; % othererr)
                            else:
                                try:
                                    # reseval = eval(resstr)
                                    evaluator = SafeEvaluator(tmp)
                                    reseval = evaluator.evaluate(resstr)
                                except Exception as othererr:
                                    tmp.setattr(key,resstr.replace(&#34;\n&#34;,&#34;,&#34;)) # \n replaced by ,
                                    #tmp.setattr(key,&#34;Eval Error &lt; %s &gt;&#34; % othererr)
                                else:
                                    tmp.setattr(key,reseval)
            elif isinstance(value,_numeric_types): # already a number
                tmp.setattr(key, value) # store the value with the key
            else: # unsupported types
                if s.find(&#34;{&#34;+key+&#34;}&#34;)&gt;=0:
                    print(f&#39;*** WARNING ***\n\tIn the {self._ftype}:&#34;\n{s}\n&#34;&#39;)
                else:
                    print(f&#39;unable to interpret the &#34;{key}&#34; of type {type(value)}&#39;)
        return tmp

    # formateval obeys to following rules
    # lines starting with # (hash) are interpreted as comments
    def formateval(self,s,protection=False):
        &#34;&#34;&#34;
            format method with evaluation feature

                txt = p.formateval(&#34;this my text with ${variable1}, ${variable2} &#34;)

                where:
                    p is a param object

                Example:
                    definitions = param(a=1,b=&#34;${a}&#34;,c=&#34;\${a}&#34;)
                    text = definitions.formateval(&#34;this my text ${a}, ${b}, ${c}&#34;)
                    print(text)

        &#34;&#34;&#34;
        tmp = self.eval(s,protection=protection)
        # Do all replacements in s (keep comments)
        if len(tmp)==0:
            return s
        else:
            ispstr = isinstance(s,pstr)
            ssafe, escape = param.escape(s)
            slines = ssafe.split(&#34;\n&#34;)
            for i in range(len(slines)):
                poscomment = slines[i].find(&#34;#&#34;)
                if poscomment&gt;=0:
                    while (poscomment&gt;0) and (slines[i][poscomment-1]==&#34; &#34;):
                        poscomment -= 1
                    comment = slines[i][poscomment:len(slines[i])]
                    slines[i]  = slines[i][0:poscomment]
                else:
                    comment = &#34;&#34;
                # Protect variables if required
                if protection or self._protection:
                    slines[i], escape2 = self.protect(slines[i])
                # conversion
                if ispstr:
                    slines[i] = pstr.eval(tmp.format(slines[i],escape=escape),ispstr=ispstr)
                else:
                    slines[i] = tmp.format(slines[i],escape=escape)+comment
                # convert starting % into # to authorize replacement in comments
                if len(slines[i])&gt;0:
                    if slines[i][0] == &#34;%&#34;: slines[i]=&#34;#&#34;+slines[i][1:]
            return &#34;\n&#34;.join(slines)

    # returns the equivalent structure evaluated
    def tostruct(self,protection=False):
        &#34;&#34;&#34;
            generate the evaluated structure
                tostruct(protection=False)
        &#34;&#34;&#34;
        return self.eval(protection=protection)

    # returns the equivalent structure evaluated
    def tostatic(self):
        &#34;&#34;&#34; convert dynamic a param() object to a static struct() object.
            note: no interpretation
            note: use tostruct() to interpret them and convert it to struct
            note: tostatic().struct2param() makes it reversible
        &#34;&#34;&#34;
        return struct.fromkeysvalues(self.keys(),self.values(),makeparam=False)


    # Safe fstring
    @staticmethod
    def safe_fstring(template, context):
        &#34;&#34;&#34;Safely evaluate expressions in ${} using SafeEvaluator.&#34;&#34;&#34;
        evaluator = SafeEvaluator(context)
        # Process template string in combination with safe_fstring()
        # it is required to have an output compatible with eval()
        def process_template(valuesafe):
            &#34;&#34;&#34;
            Processes the input string by:
            1. Stripping leading and trailing whitespace.
            2. Removing comments (any text after &#39;#&#39; unless &#39;#&#39; is the first character).
            3. Replacing &#39;^&#39; with &#39;**&#39;.
            4. Replacing &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;. &lt;-- not applied anymore (brings confusion)

            Args:
                valuesafe (str): The input string to process.

            Returns:
                str: The processed string.
            &#34;&#34;&#34;
            # Step 1: Strip leading and trailing whitespace
            valuesafe = valuesafe.strip()
            # Step 2: Remove comments
            # This regex removes &#39;#&#39; and everything after it if &#39;#&#39; is not the first character
            # (?&lt;!^) is a negative lookbehind that ensures &#39;#&#39; is not at the start of the string
            valuesafe = re.sub(r&#39;(?&lt;!^)\#.*&#39;, &#39;&#39;, valuesafe)
            # Step 3: Replace &#39;^&#39; with &#39;**&#39;
            valuesafe = re.sub(r&#39;\^&#39;, &#39;**&#39;, valuesafe)
            # Step 4: Replace &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;
            # (?&lt;!\$)\{ matches &#39;{&#39; not preceded by &#39;$&#39;
            # valuesafe = re.sub(r&#39;(?&lt;!\$)\{&#39;, &#39;${&#39;, valuesafe)
            # Optional: Strip again to remove any trailing whitespace left after removing comments
            valuesafe = valuesafe.strip()
            return valuesafe
        # Adjusted display for NumPy arrays
        def serialize_result(result):
            &#34;&#34;&#34;
            Serialize the result into a string that can be evaluated in Python.
            Handles NumPy arrays by converting them to lists with commas.
            Handles other iterable types appropriately.
            &#34;&#34;&#34;
            if isinstance(result, np.ndarray):
                return str(result.tolist())
            elif isinstance(result, (list, tuple, dict)):
                return str(result)
            else:
                return str(result)
        # Regular expression to find ${expr} patterns
        pattern = re.compile(r&#39;\$\{([^{}]+)\}&#39;)
        def replacer(match):
            expr = match.group(1)
            try:
                result = evaluator.evaluate(expr)
                serialized = serialize_result(result)
                return serialized
            except Exception as e:
                return f&#34;&lt;Error: {e}&gt;&#34;
        return pattern.sub(replacer, process_template(template))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mstruct.struct" href="#mstruct.struct">struct</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mstruct.param.escape"><code class="name flex">
<span>def <span class="ident">escape</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>escape \${} as ${{}} &ndash;&gt; keep variable names
convert ${} as {} &ndash;&gt; prepare Python replacement</p>
<h2 id="examples">Examples</h2>
<p>escape("\${a}")
returns ('${{a}}', True)</p>
<p>escape("
\${abc} ${a} \${bc}")
returns ('
${{abc}} {a} ${{bc}}', True)</p>
<p>escape("${a}")
Out[94]: ('{a}', False)</p>
<p>escape("${tata}")
returns ('{tata}', False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def escape(s):
    &#34;&#34;&#34;
        escape \${} as ${{}} --&gt; keep variable names
        convert ${} as {} --&gt; prepare Python replacement

        Examples:
            escape(&#34;\${a}&#34;)
            returns (&#39;${{a}}&#39;, True)

            escape(&#34;  \${abc} ${a} \${bc}&#34;)
            returns (&#39;  ${{abc}} {a} ${{bc}}&#39;, True)

            escape(&#34;${a}&#34;)
            Out[94]: (&#39;{a}&#39;, False)

            escape(&#34;${tata}&#34;)
            returns (&#39;{tata}&#39;, False)

    &#34;&#34;&#34;
    if not isinstance(s,str):
        raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)
    se, start, found = &#34;&#34;, 0, True
    while found:
        pos0 = s.find(&#34;\${&#34;,start)
        found = pos0&gt;=0
        if found:
            pos1 = s.find(&#34;}&#34;,pos0)
            found = pos1&gt;=0
            if found:
                se += s[start:pos0].replace(&#34;${&#34;,&#34;{&#34;)+&#34;${{&#34;+s[pos0+3:pos1]+&#34;}}&#34;
                start=pos1+1
    result = se+s[start:].replace(&#34;${&#34;,&#34;{&#34;)
    if isinstance(s,pstr): result = pstr(result)
    return result,start&gt;0</code></pre>
</details>
</dd>
<dt id="mstruct.param.safe_fstring"><code class="name flex">
<span>def <span class="ident">safe_fstring</span></span>(<span>template, context)</span>
</code></dt>
<dd>
<div class="desc"><p>Safely evaluate expressions in ${} using SafeEvaluator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def safe_fstring(template, context):
    &#34;&#34;&#34;Safely evaluate expressions in ${} using SafeEvaluator.&#34;&#34;&#34;
    evaluator = SafeEvaluator(context)
    # Process template string in combination with safe_fstring()
    # it is required to have an output compatible with eval()
    def process_template(valuesafe):
        &#34;&#34;&#34;
        Processes the input string by:
        1. Stripping leading and trailing whitespace.
        2. Removing comments (any text after &#39;#&#39; unless &#39;#&#39; is the first character).
        3. Replacing &#39;^&#39; with &#39;**&#39;.
        4. Replacing &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;. &lt;-- not applied anymore (brings confusion)

        Args:
            valuesafe (str): The input string to process.

        Returns:
            str: The processed string.
        &#34;&#34;&#34;
        # Step 1: Strip leading and trailing whitespace
        valuesafe = valuesafe.strip()
        # Step 2: Remove comments
        # This regex removes &#39;#&#39; and everything after it if &#39;#&#39; is not the first character
        # (?&lt;!^) is a negative lookbehind that ensures &#39;#&#39; is not at the start of the string
        valuesafe = re.sub(r&#39;(?&lt;!^)\#.*&#39;, &#39;&#39;, valuesafe)
        # Step 3: Replace &#39;^&#39; with &#39;**&#39;
        valuesafe = re.sub(r&#39;\^&#39;, &#39;**&#39;, valuesafe)
        # Step 4: Replace &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;
        # (?&lt;!\$)\{ matches &#39;{&#39; not preceded by &#39;$&#39;
        # valuesafe = re.sub(r&#39;(?&lt;!\$)\{&#39;, &#39;${&#39;, valuesafe)
        # Optional: Strip again to remove any trailing whitespace left after removing comments
        valuesafe = valuesafe.strip()
        return valuesafe
    # Adjusted display for NumPy arrays
    def serialize_result(result):
        &#34;&#34;&#34;
        Serialize the result into a string that can be evaluated in Python.
        Handles NumPy arrays by converting them to lists with commas.
        Handles other iterable types appropriately.
        &#34;&#34;&#34;
        if isinstance(result, np.ndarray):
            return str(result.tolist())
        elif isinstance(result, (list, tuple, dict)):
            return str(result)
        else:
            return str(result)
    # Regular expression to find ${expr} patterns
    pattern = re.compile(r&#39;\$\{([^{}]+)\}&#39;)
    def replacer(match):
        expr = match.group(1)
        try:
            result = evaluator.evaluate(expr)
            serialized = serialize_result(result)
            return serialized
        except Exception as e:
            return f&#34;&lt;Error: {e}&gt;&#34;
    return pattern.sub(replacer, process_template(template))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mstruct.param.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>self, s='', protection=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Eval method for structure such as MS.alias</p>
<pre><code>s = p.eval() or s = p.eval(string)

where :
    p is a param object
    s is a structure with evaluated fields
    string is only used to determine whether definitions have been forgotten
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval(self,s=&#34;&#34;,protection=False):
    &#34;&#34;&#34;
        Eval method for structure such as MS.alias

            s = p.eval() or s = p.eval(string)

            where :
                p is a param object
                s is a structure with evaluated fields
                string is only used to determine whether definitions have been forgotten

    &#34;&#34;&#34;
    # Evaluate all DEFINITIONS
    # the argument s is only used by formateval() for error management
    tmp = struct()
    for key,value in self.items():
        # strings are assumed to be expressions on one single line
        if isinstance(value,str):
            # replace ${variable} (Bash, Lammps syntax) by {variable} (Python syntax)
            # use \${variable} to prevent replacement (espace with \)
            # Protect variables if required
            ispstr = isinstance(value,pstr)
            valuesafe = pstr.eval(value,ispstr=ispstr) # value.strip()
            if protection or self._protection:
                valuesafe, escape0 = self.protect(valuesafe)
            else:
                escape0 = False
            # replace ${var} by {var}
            valuesafe_priorescape = valuesafe
            valuesafe, escape = param.escape(valuesafe)
            escape = escape or escape0
            # replace &#34;^&#34; (Matlab, Lammps exponent) by &#34;**&#34; (Python syntax)
            valuesafe = pstr.eval(valuesafe.replace(&#34;^&#34;,&#34;**&#34;),ispstr=ispstr)
            # Remove all content after #
            # if the first character is &#39;#&#39;, it is not comment (e.g. MarkDown titles)
            poscomment = valuesafe.find(&#34;#&#34;)
            if poscomment&gt;0: valuesafe = valuesafe[0:poscomment].strip()
            # Literal string starts with $ (no interpretation), ! (evaluation)
            if not self._evaluation:
                tmp.setattr(key, pstr.eval(tmp.format(valuesafe,escape),ispstr=ispstr))
            elif valuesafe.startswith(&#34;!&#34;):
                try:
                    vtmp = ast.literal_eval(valuesafe[1:])
                    if isinstance(vtmp,list):
                        for i,item in enumerate(vtmp):
                            if isinstance(item,str) and not item.strip().startswith(&#34;$&#34;):
                                try:
                                    vtmp[i] = tmp.format(item, raiseerror=False)
                                except Exception as ve:
                                    vtmp[i] = f&#34;Error in &lt;{item}&gt;: {ve.__class__.__name__} - {str(ve)}&#34;
                    tmp.setattr(key,vtmp)
                except (SyntaxError, ValueError) as e:
                    tmp.setattr(key, f&#34;Error: {e.__class__.__name__} - {str(e)}&#34;)
            elif valuesafe.startswith(&#34;$&#34;) and not escape:
                tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard $
            elif valuesafe.startswith(&#34;%&#34;):
                tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard %
            else: # string empty or which can be evaluated
                if valuesafe==&#34;&#34;:
                    tmp.setattr(key,valuesafe) # empty content
                else:
                    if isinstance(value,pstr): # keep path
                        tmp.setattr(key, pstr.topath(tmp.format(valuesafe,escape=escape)))
                    elif escape:  # partial evaluation
                        tmp.setattr(key, tmp.format(valuesafe,escape=True))
                    else: # full evaluation (if it fails the last string content is returned)
                        try:
                            resstr = tmp.format(valuesafe,raiseerror=False)
                        except (KeyError,NameError) as nameerr:
                            if self._returnerror: # added on 2024-09-06
                                strnameerr = str(nameerr).replace(&#34;&#39;&#34;,&#34;&#34;)
                                tmp.setattr(key,&#39;&lt; undef %s &#34;${%s}&#34; &gt;&#39; % \
                                        (self._ftype,strnameerr))
                            else:
                                tmp.setattr(key,value) #we keep the original value
                        except (SyntaxError,TypeError,ValueError) as commonerr:
                            tmp.setattr(key,&#34;ERROR &lt; %s &gt;&#34; % commonerr)
                        except (IndexError,AttributeError):
                            try:
                                resstr = param.safe_fstring(valuesafe_priorescape,tmp)
                            except Exception as fstrerr:
                                tmp.setattr(key,&#34;Index Error &lt; %s &gt;&#34; % fstrerr)
                            else:
                                try:
                                    # reseval = eval(resstr)
                                    # reseval = ast.literal_eval(resstr)
                                    # Use SafeEvaluator to evaluate the final expression
                                    evaluator = SafeEvaluator(tmp)
                                    reseval = evaluator.evaluate(resstr)
                                except Exception as othererr:
                                    #tmp.setattr(key,&#34;Mathematical Error around/in ${}: &lt; %s &gt;&#34; % othererr)
                                    tmp.setattr(key,resstr)
                                else:
                                    tmp.setattr(key,reseval)
                        except Exception as othererr:
                            tmp.setattr(key,&#34;Error in ${}: &lt; %s &gt;&#34; % othererr)
                        else:
                            try:
                                # reseval = eval(resstr)
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluator.evaluate(resstr)
                            except Exception as othererr:
                                tmp.setattr(key,resstr.replace(&#34;\n&#34;,&#34;,&#34;)) # \n replaced by ,
                                #tmp.setattr(key,&#34;Eval Error &lt; %s &gt;&#34; % othererr)
                            else:
                                tmp.setattr(key,reseval)
        elif isinstance(value,_numeric_types): # already a number
            tmp.setattr(key, value) # store the value with the key
        else: # unsupported types
            if s.find(&#34;{&#34;+key+&#34;}&#34;)&gt;=0:
                print(f&#39;*** WARNING ***\n\tIn the {self._ftype}:&#34;\n{s}\n&#34;&#39;)
            else:
                print(f&#39;unable to interpret the &#34;{key}&#34; of type {type(value)}&#39;)
    return tmp</code></pre>
</details>
</dd>
<dt id="mstruct.param.formateval"><code class="name flex">
<span>def <span class="ident">formateval</span></span>(<span>self, s, protection=False)</span>
</code></dt>
<dd>
<div class="desc"><p>format method with evaluation feature</p>
<pre><code>txt = p.formateval("this my text with ${variable1}, ${variable2} ")

where:
    p is a param object

Example:
    definitions = param(a=1,b="${a}",c="\${a}")
    text = definitions.formateval("this my text ${a}, ${b}, ${c}")
    print(text)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formateval(self,s,protection=False):
    &#34;&#34;&#34;
        format method with evaluation feature

            txt = p.formateval(&#34;this my text with ${variable1}, ${variable2} &#34;)

            where:
                p is a param object

            Example:
                definitions = param(a=1,b=&#34;${a}&#34;,c=&#34;\${a}&#34;)
                text = definitions.formateval(&#34;this my text ${a}, ${b}, ${c}&#34;)
                print(text)

    &#34;&#34;&#34;
    tmp = self.eval(s,protection=protection)
    # Do all replacements in s (keep comments)
    if len(tmp)==0:
        return s
    else:
        ispstr = isinstance(s,pstr)
        ssafe, escape = param.escape(s)
        slines = ssafe.split(&#34;\n&#34;)
        for i in range(len(slines)):
            poscomment = slines[i].find(&#34;#&#34;)
            if poscomment&gt;=0:
                while (poscomment&gt;0) and (slines[i][poscomment-1]==&#34; &#34;):
                    poscomment -= 1
                comment = slines[i][poscomment:len(slines[i])]
                slines[i]  = slines[i][0:poscomment]
            else:
                comment = &#34;&#34;
            # Protect variables if required
            if protection or self._protection:
                slines[i], escape2 = self.protect(slines[i])
            # conversion
            if ispstr:
                slines[i] = pstr.eval(tmp.format(slines[i],escape=escape),ispstr=ispstr)
            else:
                slines[i] = tmp.format(slines[i],escape=escape)+comment
            # convert starting % into # to authorize replacement in comments
            if len(slines[i])&gt;0:
                if slines[i][0] == &#34;%&#34;: slines[i]=&#34;#&#34;+slines[i][1:]
        return &#34;\n&#34;.join(slines)</code></pre>
</details>
</dd>
<dt id="mstruct.param.protect"><code class="name flex">
<span>def <span class="ident">protect</span></span>(<span>self, s='')</span>
</code></dt>
<dd>
<div class="desc"><p>protect $variable as ${variable}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protect(self,s=&#34;&#34;):
    &#34;&#34;&#34; protect $variable as ${variable} &#34;&#34;&#34;
    if isinstance(s,str):
        t = s.replace(&#34;\$&#34;,&#34;Â£Â£&#34;) # &amp;&amp; is a placeholder
        escape = t!=s
        for k in self.keyssorted():
            t = t.replace(&#34;$&#34;+k,&#34;${&#34;+k+&#34;}&#34;)
        if escape: t = t.replace(&#34;Â£Â£&#34;,&#34;\$&#34;)
        if isinstance(s,pstr): t = pstr(t)
        return t, escape
    raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)</code></pre>
</details>
</dd>
<dt id="mstruct.param.tostatic"><code class="name flex">
<span>def <span class="ident">tostatic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>convert dynamic a param() object to a static struct() object.
note: no interpretation
note: use tostruct() to interpret them and convert it to struct
note: tostatic().struct2param() makes it reversible</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tostatic(self):
    &#34;&#34;&#34; convert dynamic a param() object to a static struct() object.
        note: no interpretation
        note: use tostruct() to interpret them and convert it to struct
        note: tostatic().struct2param() makes it reversible
    &#34;&#34;&#34;
    return struct.fromkeysvalues(self.keys(),self.values(),makeparam=False)</code></pre>
</details>
</dd>
<dt id="mstruct.param.tostruct"><code class="name flex">
<span>def <span class="ident">tostruct</span></span>(<span>self, protection=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generate the evaluated structure
tostruct(protection=False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tostruct(self,protection=False):
    &#34;&#34;&#34;
        generate the evaluated structure
            tostruct(protection=False)
    &#34;&#34;&#34;
    return self.eval(protection=protection)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mstruct.struct" href="#mstruct.struct">struct</a></b></code>:
<ul class="hlist">
<li><code><a title="mstruct.struct.check" href="#mstruct.struct.check">check</a></code></li>
<li><code><a title="mstruct.struct.clear" href="#mstruct.struct.clear">clear</a></code></li>
<li><code><a title="mstruct.struct.dict2struct" href="#mstruct.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="mstruct.struct.disp" href="#mstruct.struct.disp">disp</a></code></li>
<li><code><a title="mstruct.struct.dispmax" href="#mstruct.struct.dispmax">dispmax</a></code></li>
<li><code><a title="mstruct.struct.format" href="#mstruct.struct.format">format</a></code></li>
<li><code><a title="mstruct.struct.format_array" href="#mstruct.struct.format_array">format_array</a></code></li>
<li><code><a title="mstruct.struct.format_legacy" href="#mstruct.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="mstruct.struct.fromkeys" href="#mstruct.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="mstruct.struct.fromkeysvalues" href="#mstruct.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="mstruct.struct.generator" href="#mstruct.struct.generator">generator</a></code></li>
<li><code><a title="mstruct.struct.getattr" href="#mstruct.struct.getattr">getattr</a></code></li>
<li><code><a title="mstruct.struct.hasattr" href="#mstruct.struct.hasattr">hasattr</a></code></li>
<li><code><a title="mstruct.struct.isdefined" href="#mstruct.struct.isdefined">isdefined</a></code></li>
<li><code><a title="mstruct.struct.isempty" href="#mstruct.struct.isempty">isempty</a></code></li>
<li><code><a title="mstruct.struct.isexpression" href="#mstruct.struct.isexpression">isexpression</a></code></li>
<li><code><a title="mstruct.struct.isstrdefined" href="#mstruct.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="mstruct.struct.isstrexpression" href="#mstruct.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="mstruct.struct.items" href="#mstruct.struct.items">items</a></code></li>
<li><code><a title="mstruct.struct.keys" href="#mstruct.struct.keys">keys</a></code></li>
<li><code><a title="mstruct.struct.keyssorted" href="#mstruct.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="mstruct.struct.read" href="#mstruct.struct.read">read</a></code></li>
<li><code><a title="mstruct.struct.scan" href="#mstruct.struct.scan">scan</a></code></li>
<li><code><a title="mstruct.struct.set" href="#mstruct.struct.set">set</a></code></li>
<li><code><a title="mstruct.struct.setattr" href="#mstruct.struct.setattr">setattr</a></code></li>
<li><code><a title="mstruct.struct.sortdefinitions" href="#mstruct.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="mstruct.struct.struct2dict" href="#mstruct.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="mstruct.struct.struct2param" href="#mstruct.struct.struct2param">struct2param</a></code></li>
<li><code><a title="mstruct.struct.update" href="#mstruct.struct.update">update</a></code></li>
<li><code><a title="mstruct.struct.values" href="#mstruct.struct.values">values</a></code></li>
<li><code><a title="mstruct.struct.write" href="#mstruct.struct.write">write</a></code></li>
<li><code><a title="mstruct.struct.zip" href="#mstruct.struct.zip">zip</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mstruct.paramauto"><code class="flex name class">
<span>class <span class="ident">paramauto</span></span>
<span>(</span><span>sortdefinitions=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-paramauto">Class: <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code></h1>
<p>A subclass of <code><a title="mstruct.param" href="#mstruct.param">param</a></code> with enhanced handling for automatic sorting and evaluation
of definitions. The <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> class ensures that all fields are sorted to resolve
dependencies, allowing seamless stacking of partially defined objects.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Inherits all functionalities of <code><a title="mstruct.param" href="#mstruct.param">param</a></code>.</li>
<li>Automatically sorts definitions for dependency resolution.</li>
<li>Simplifies handling of partial definitions in dynamic structures.</li>
<li>Supports safe concatenation of definitions.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="automatic-dependency-sorting">Automatic Dependency Sorting</h4>
<p>Definitions are automatically sorted to resolve dependencies:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${b}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${b} (= 3)
# --------
</code></pre>
<h4 id="handling-missing-definitions">Handling Missing Definitions</h4>
<p>Unresolved dependencies raise warnings but do not block execution:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${d}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-inheritance">Concatenation and Inheritance</h3>
<p>Concatenating <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> objects resolves definitions:</p>
<pre><code class="language-python">p1 = paramauto(a=1, b=&quot;${a}+2&quot;)
p2 = paramauto(c=&quot;${b}*3&quot;)
p3 = p1 + p2
p3.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 2 (= 3)
#      c: ${b} * 3 (= 9)
# --------
</code></pre>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Automatically sorts fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate all fields, resolving dependencies.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display all fields with their resolved values.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="overloaded-operators">Overloaded Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenates two <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> objects, resolving dependencies.</li>
<li><code>+=</code>: Updates the current object with another, resolving dependencies.</li>
<li><code>len()</code>: Number of fields.</li>
<li><code>in</code>: Check for field existence.</li>
</ul>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="partial-definitions">Partial Definitions</h4>
<p>The <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> class simplifies handling of partially defined fields:</p>
<pre><code class="language-python">p = paramauto(a=&quot;${d}&quot;, b=&quot;${a}+1&quot;)
p.disp()
# Warning: Unable to resolve dependencies.
# --------
#      a: ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
#      b: ${a} + 1 (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------

p.d = 10
p.disp()
# Dependencies are resolved:
# --------
#      d: 10
#      a: ${d} (= 10)
#      b: ${a} + 1 (= 11)
# --------
</code></pre>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>The <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> class is computationally more intensive than <code><a title="mstruct.param" href="#mstruct.param">param</a></code> due to automatic sorting.</li>
<li>It is ideal for managing dynamic systems with complex interdependencies.</li>
</ul>
<h3 id="examples_1">Examples</h3>
<pre><code>            p = paramauto()
            p.b = "${aa}"
            p.disp()
        yields
            WARNING: unable to interpret 1/1 expressions in "definitions"
              -----------:----------------------------------------
                        b: ${aa}
                         = &lt; undef definition "${aa}" &gt;
              -----------:----------------------------------------
              p.aa = 2
              p.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
            -----------:----------------------------------------
            q = paramauto(c="${aa}+${b}")+p
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
                      c: ${aa}+${b}
                       = 4
            -----------:----------------------------------------
            q.aa = 30
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 30
                      b: ${aa}
                       = 30
                      c: ${aa}+${b}
                       = 60
            -----------:----------------------------------------
            q.aa = "${d}"
            q.disp()
        yields multiple errors (recursion)
        WARNING: unable to interpret 3/3 expressions in "definitions"
          -----------:----------------------------------------
                   aa: ${d}
                     = &lt; undef definition "${d}" &gt;
                    b: ${aa}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                    c: ${aa}+${b}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
          -----------:----------------------------------------
            q.d = 100
            q.disp()
        yields
          -----------:----------------------------------------
                    d: 100
                   aa: ${d}
                     = 100
                    b: ${aa}
                     = 100
                    c: ${aa}+${b}
                     = 200
          -----------:----------------------------------------


    Example:

        p = paramauto(b="${a}+1",c="${a}+${d}",a=1)
        p.disp()
    generates:
        WARNING: unable to interpret 1/3 expressions in "definitions"
          -----------:----------------------------------------
                    a: 1
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = &lt; undef definition "${d}" &gt;
          -----------:----------------------------------------
    setting p.d
        p.d = 2
        p.disp()
    produces
          -----------:----------------------------------------
                    a: 1
                    d: 2
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = 3
          -----------:----------------------------------------
</code></pre>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class paramauto(param):
    &#34;&#34;&#34;
    Class: `paramauto`
    ==================

    A subclass of `param` with enhanced handling for automatic sorting and evaluation
    of definitions. The `paramauto` class ensures that all fields are sorted to resolve
    dependencies, allowing seamless stacking of partially defined objects.

    ---

    ### Features
    - Inherits all functionalities of `param`.
    - Automatically sorts definitions for dependency resolution.
    - Simplifies handling of partial definitions in dynamic structures.
    - Supports safe concatenation of definitions.

    ---

    ### Examples

    #### Automatic Dependency Sorting
    Definitions are automatically sorted to resolve dependencies:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${b}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${b} (= 3)
    # --------
    ```

    #### Handling Missing Definitions
    Unresolved dependencies raise warnings but do not block execution:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------
    ```

    ---

    ### Concatenation and Inheritance
    Concatenating `paramauto` objects resolves definitions:
    ```python
    p1 = paramauto(a=1, b=&#34;${a}+2&#34;)
    p2 = paramauto(c=&#34;${b}*3&#34;)
    p3 = p1 + p2
    p3.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 2 (= 3)
    #      c: ${b} * 3 (= 9)
    # --------
    ```

    ---

    ### Utility Methods

    | Method                | Description                                            |
    |-----------------------|--------------------------------------------------------|
    | `sortdefinitions()`   | Automatically sorts fields to resolve dependencies.    |
    | `eval()`              | Evaluate all fields, resolving dependencies.           |
    | `disp()`              | Display all fields with their resolved values.         |

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `+`: Concatenates two `paramauto` objects, resolving dependencies.
    - `+=`: Updates the current object with another, resolving dependencies.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Advanced Usage

    #### Partial Definitions
    The `paramauto` class simplifies handling of partially defined fields:
    ```python
    p = paramauto(a=&#34;${d}&#34;, b=&#34;${a}+1&#34;)
    p.disp()
    # Warning: Unable to resolve dependencies.
    # --------
    #      a: ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      b: ${a} + 1 (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------

    p.d = 10
    p.disp()
    # Dependencies are resolved:
    # --------
    #      d: 10
    #      a: ${d} (= 10)
    #      b: ${a} + 1 (= 11)
    # --------
    ```

    ---

    ### Notes
    - The `paramauto` class is computationally more intensive than `param` due to automatic sorting.
    - It is ideal for managing dynamic systems with complex interdependencies.

    ### Examples
                    p = paramauto()
                    p.b = &#34;${aa}&#34;
                    p.disp()
                yields
                    WARNING: unable to interpret 1/1 expressions in &#34;definitions&#34;
                      -----------:----------------------------------------
                                b: ${aa}
                                 = &lt; undef definition &#34;${aa}&#34; &gt;
                      -----------:----------------------------------------
                      p.aa = 2
                      p.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                    -----------:----------------------------------------
                    q = paramauto(c=&#34;${aa}+${b}&#34;)+p
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                              c: ${aa}+${b}
                               = 4
                    -----------:----------------------------------------
                    q.aa = 30
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 30
                              b: ${aa}
                               = 30
                              c: ${aa}+${b}
                               = 60
                    -----------:----------------------------------------
                    q.aa = &#34;${d}&#34;
                    q.disp()
                yields multiple errors (recursion)
                WARNING: unable to interpret 3/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                           aa: ${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                            b: ${aa}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                            c: ${aa}+${b}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                  -----------:----------------------------------------
                    q.d = 100
                    q.disp()
                yields
                  -----------:----------------------------------------
                            d: 100
                           aa: ${d}
                             = 100
                            b: ${aa}
                             = 100
                            c: ${aa}+${b}
                             = 200
                  -----------:----------------------------------------


            Example:

                p = paramauto(b=&#34;${a}+1&#34;,c=&#34;${a}+${d}&#34;,a=1)
                p.disp()
            generates:
                WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                            a: 1
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                  -----------:----------------------------------------
            setting p.d
                p.d = 2
                p.disp()
            produces
                  -----------:----------------------------------------
                            a: 1
                            d: 2
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = 3
                  -----------:----------------------------------------

    &#34;&#34;&#34;

    def __add__(self,p):
        return super(param,self).__add__(p,sortdefinitions=True,raiseerror=False)

    def __iadd__(self,p):
        return super(param,self).__iadd__(p,sortdefinitions=True,raiseerror=False)

    def __repr__(self):
        self.sortdefinitions(raiseerror=False)
        #super(param,self).__repr__()
        super().__repr__()
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mstruct.param" href="#mstruct.param">param</a></li>
<li><a title="mstruct.struct" href="#mstruct.struct">struct</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mstruct.param" href="#mstruct.param">param</a></b></code>:
<ul class="hlist">
<li><code><a title="mstruct.param.check" href="#mstruct.struct.check">check</a></code></li>
<li><code><a title="mstruct.param.clear" href="#mstruct.struct.clear">clear</a></code></li>
<li><code><a title="mstruct.param.dict2struct" href="#mstruct.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="mstruct.param.disp" href="#mstruct.struct.disp">disp</a></code></li>
<li><code><a title="mstruct.param.dispmax" href="#mstruct.struct.dispmax">dispmax</a></code></li>
<li><code><a title="mstruct.param.escape" href="#mstruct.param.escape">escape</a></code></li>
<li><code><a title="mstruct.param.eval" href="#mstruct.param.eval">eval</a></code></li>
<li><code><a title="mstruct.param.format" href="#mstruct.struct.format">format</a></code></li>
<li><code><a title="mstruct.param.format_array" href="#mstruct.struct.format_array">format_array</a></code></li>
<li><code><a title="mstruct.param.format_legacy" href="#mstruct.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="mstruct.param.formateval" href="#mstruct.param.formateval">formateval</a></code></li>
<li><code><a title="mstruct.param.fromkeys" href="#mstruct.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="mstruct.param.fromkeysvalues" href="#mstruct.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="mstruct.param.generator" href="#mstruct.struct.generator">generator</a></code></li>
<li><code><a title="mstruct.param.getattr" href="#mstruct.struct.getattr">getattr</a></code></li>
<li><code><a title="mstruct.param.hasattr" href="#mstruct.struct.hasattr">hasattr</a></code></li>
<li><code><a title="mstruct.param.isdefined" href="#mstruct.struct.isdefined">isdefined</a></code></li>
<li><code><a title="mstruct.param.isempty" href="#mstruct.struct.isempty">isempty</a></code></li>
<li><code><a title="mstruct.param.isexpression" href="#mstruct.struct.isexpression">isexpression</a></code></li>
<li><code><a title="mstruct.param.isstrdefined" href="#mstruct.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="mstruct.param.isstrexpression" href="#mstruct.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="mstruct.param.items" href="#mstruct.struct.items">items</a></code></li>
<li><code><a title="mstruct.param.keys" href="#mstruct.struct.keys">keys</a></code></li>
<li><code><a title="mstruct.param.keyssorted" href="#mstruct.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="mstruct.param.protect" href="#mstruct.param.protect">protect</a></code></li>
<li><code><a title="mstruct.param.read" href="#mstruct.struct.read">read</a></code></li>
<li><code><a title="mstruct.param.safe_fstring" href="#mstruct.param.safe_fstring">safe_fstring</a></code></li>
<li><code><a title="mstruct.param.scan" href="#mstruct.struct.scan">scan</a></code></li>
<li><code><a title="mstruct.param.set" href="#mstruct.struct.set">set</a></code></li>
<li><code><a title="mstruct.param.setattr" href="#mstruct.struct.setattr">setattr</a></code></li>
<li><code><a title="mstruct.param.sortdefinitions" href="#mstruct.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="mstruct.param.struct2dict" href="#mstruct.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="mstruct.param.struct2param" href="#mstruct.struct.struct2param">struct2param</a></code></li>
<li><code><a title="mstruct.param.tostatic" href="#mstruct.param.tostatic">tostatic</a></code></li>
<li><code><a title="mstruct.param.tostruct" href="#mstruct.param.tostruct">tostruct</a></code></li>
<li><code><a title="mstruct.param.update" href="#mstruct.struct.update">update</a></code></li>
<li><code><a title="mstruct.param.values" href="#mstruct.struct.values">values</a></code></li>
<li><code><a title="mstruct.param.write" href="#mstruct.struct.write">write</a></code></li>
<li><code><a title="mstruct.param.zip" href="#mstruct.struct.zip">zip</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mstruct.pstr"><code class="flex name class">
<span>class <span class="ident">pstr</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-pstr">Class: <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code></h1>
<p>A specialized string class for handling paths and filenames, derived from <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code>.
The <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> class ensures compatibility with POSIX-style paths and provides enhanced
operations for path manipulation.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Maintains POSIX-style paths.</li>
<li>Automatically handles trailing slashes.</li>
<li>Supports path concatenation using <code>/</code>.</li>
<li>Converts seamlessly back to <code>str</code> for compatibility with string methods.</li>
<li>Includes additional utility methods for path evaluation and formatting.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic Usage</h4>
<pre><code class="language-python">a = pstr(&quot;this/is/mypath//&quot;)
b = pstr(&quot;mylocalfolder/myfile.ext&quot;)
c = a / b
print(c)  # this/is/mypath/mylocalfolder/myfile.ext
</code></pre>
<h4 id="keeping-trailing-slashes">Keeping Trailing Slashes</h4>
<pre><code class="language-python">a = pstr(&quot;this/is/mypath//&quot;)
print(a)  # this/is/mypath/
</code></pre>
<hr>
<h3 id="path-operations">Path Operations</h3>
<h4 id="path-concatenation">Path Concatenation</h4>
<p>Use the <code>/</code> operator to concatenate paths:</p>
<pre><code class="language-python">a = pstr(&quot;folder/subfolder&quot;)
b = pstr(&quot;file.txt&quot;)
c = a / b
print(c)  # folder/subfolder/file.txt
</code></pre>
<h4 id="path-evaluation">Path Evaluation</h4>
<p>Evaluate or convert paths while preserving the <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> type:</p>
<pre><code class="language-python">result = pstr.eval(&quot;some/path/afterreplacement&quot;, ispstr=True)
print(result)  # some/path/afterreplacement
</code></pre>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="using-string-methods">Using String Methods</h4>
<p>Methods like <code>replace()</code> convert <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> back to <code>str</code>. To retain the <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> type:</p>
<pre><code class="language-python">new_path = pstr.eval(a.replace(&quot;mypath&quot;, &quot;newpath&quot;), ispstr=True)
print(new_path)  # this/is/newpath/
</code></pre>
<h4 id="handling-posix-paths">Handling POSIX Paths</h4>
<p>The <code><a title="mstruct.pstr.topath" href="#mstruct.pstr.topath">pstr.topath()</a></code> method ensures the path remains POSIX-compliant:</p>
<pre><code class="language-python">path = pstr(&quot;C:\Windows\Path&quot;)
posix_path = path.topath()
print(posix_path)  # C:/Windows/Path
</code></pre>
<hr>
<h3 id="overloaded-operators">Overloaded Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>/</code>: Concatenates two paths (<code>__truediv__</code>).</li>
<li><code>+</code>: Concatenates strings as paths, resulting in a <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> object (<code>__add__</code>).</li>
<li><code>+=</code>: Adds to an existing <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> object (<code>__iadd__</code>).</li>
</ul>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eval(value)</code></td>
<td>Evaluates the path or string for compatibility with <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code>.</td>
</tr>
<tr>
<td><code>topath()</code></td>
<td>Returns the POSIX-compliant path.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>Use <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> for consistent and safe handling of file paths across different platforms.</li>
<li>Converts back to <code>str</code> when using non-<code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> specific methods to ensure compatibility.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pstr(str):
    &#34;&#34;&#34;
    Class: `pstr`
    =============

    A specialized string class for handling paths and filenames, derived from `struct`.
    The `pstr` class ensures compatibility with POSIX-style paths and provides enhanced
    operations for path manipulation.

    ---

    ### Features
    - Maintains POSIX-style paths.
    - Automatically handles trailing slashes.
    - Supports path concatenation using `/`.
    - Converts seamlessly back to `str` for compatibility with string methods.
    - Includes additional utility methods for path evaluation and formatting.

    ---

    ### Examples

    #### Basic Usage
    ```python
    a = pstr(&#34;this/is/mypath//&#34;)
    b = pstr(&#34;mylocalfolder/myfile.ext&#34;)
    c = a / b
    print(c)  # this/is/mypath/mylocalfolder/myfile.ext
    ```

    #### Keeping Trailing Slashes
    ```python
    a = pstr(&#34;this/is/mypath//&#34;)
    print(a)  # this/is/mypath/
    ```

    ---

    ### Path Operations

    #### Path Concatenation
    Use the `/` operator to concatenate paths:
    ```python
    a = pstr(&#34;folder/subfolder&#34;)
    b = pstr(&#34;file.txt&#34;)
    c = a / b
    print(c)  # folder/subfolder/file.txt
    ```

    #### Path Evaluation
    Evaluate or convert paths while preserving the `pstr` type:
    ```python
    result = pstr.eval(&#34;some/path/afterreplacement&#34;, ispstr=True)
    print(result)  # some/path/afterreplacement
    ```

    ---

    ### Advanced Usage

    #### Using String Methods
    Methods like `replace()` convert `pstr` back to `str`. To retain the `pstr` type:
    ```python
    new_path = pstr.eval(a.replace(&#34;mypath&#34;, &#34;newpath&#34;), ispstr=True)
    print(new_path)  # this/is/newpath/
    ```

    #### Handling POSIX Paths
    The `pstr.topath()` method ensures the path remains POSIX-compliant:
    ```python
    path = pstr(&#34;C:\\Windows\\Path&#34;)
    posix_path = path.topath()
    print(posix_path)  # C:/Windows/Path
    ```

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `/`: Concatenates two paths (`__truediv__`).
    - `+`: Concatenates strings as paths, resulting in a `pstr` object (`__add__`).
    - `+=`: Adds to an existing `pstr` object (`__iadd__`).

    ---

    ### Utility Methods

    | Method          | Description                                  |
    |------------------|----------------------------------------------|
    | `eval(value)`    | Evaluates the path or string for compatibility with `pstr`. |
    | `topath()`       | Returns the POSIX-compliant path.           |

    ---

    ### Notes
    - Use `pstr` for consistent and safe handling of file paths across different platforms.
    - Converts back to `str` when using non-`pstr` specific methods to ensure compatibility.
    &#34;&#34;&#34;

    def __repr__(self):
        result = self.topath()
        if result[-1] != &#34;/&#34; and self[-1] == &#34;/&#34;:
            result += &#34;/&#34;
        return result

    def topath(self):
        &#34;&#34;&#34; return a validated path &#34;&#34;&#34;
        value = pstr(PurePath(self))
        if value[-1] != &#34;/&#34; and self [-1]==&#34;/&#34;:
            value += &#34;/&#34;
        return value


    @staticmethod
    def eval(value,ispstr=False):
        &#34;&#34;&#34; evaluate the path of it os a path &#34;&#34;&#34;
        if isinstance(value,pstr):
            return value.topath()
        elif isinstance(value,PurePath) or ispstr:
            return pstr(value).topath()
        else:
            return value

    def __truediv__(self,value):
        &#34;&#34;&#34; overload / &#34;&#34;&#34;
        operand = pstr.eval(value)
        result = pstr(PurePath(self) / operand)
        if result[-1] != &#34;/&#34; and operand[-1] == &#34;/&#34;:
            result += &#34;/&#34;
        return result

    def __add__(self,value):
        return pstr(str(self)+value)

    def __iadd__(self,value):
        return pstr(str(self)+value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mstruct.pstr.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>value, ispstr=False)</span>
</code></dt>
<dd>
<div class="desc"><p>evaluate the path of it os a path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def eval(value,ispstr=False):
    &#34;&#34;&#34; evaluate the path of it os a path &#34;&#34;&#34;
    if isinstance(value,pstr):
        return value.topath()
    elif isinstance(value,PurePath) or ispstr:
        return pstr(value).topath()
    else:
        return value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mstruct.pstr.topath"><code class="name flex">
<span>def <span class="ident">topath</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return a validated path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def topath(self):
    &#34;&#34;&#34; return a validated path &#34;&#34;&#34;
    value = pstr(PurePath(self))
    if value[-1] != &#34;/&#34; and self [-1]==&#34;/&#34;:
        value += &#34;/&#34;
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mstruct.struct"><code class="flex name class">
<span>class <span class="ident">struct</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-struct">Class: <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code></h1>
<p>A lightweight class that mimics Matlab-like structures, with additional features
such as dynamic field creation, indexing, concatenation, and compatibility with
evaluated parameters (<code><a title="mstruct.param" href="#mstruct.param">param</a></code>).</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Dynamic creation of fields.</li>
<li>Indexing and iteration support for fields.</li>
<li>Concatenation and subtraction of structures.</li>
<li>Conversion to and from dictionaries.</li>
<li>Compatible with <code><a title="mstruct.param" href="#mstruct.param">param</a></code> and <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> for evaluation and dependency handling.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic Usage</h4>
<pre><code class="language-python">s = struct(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
print(s.a)  # 1
s.d = 11    # Append a new field
delattr(s, 'd')  # Delete the field
</code></pre>
<h4 id="using-param-for-evaluation">Using <code><a title="mstruct.param" href="#mstruct.param">param</a></code> for Evaluation</h4>
<pre><code class="language-python">p = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
p.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-subtraction">Concatenation and Subtraction</h3>
<p>Fields from the right-most structure overwrite existing values.</p>
<pre><code class="language-python">a = struct(a=1, b=2)
b = struct(c=3, d=&quot;d&quot;, e=&quot;e&quot;)
c = a + b
e = c - a
</code></pre>
<hr>
<h3 id="practical-shorthands">Practical Shorthands</h3>
<h4 id="constructing-a-structure-from-keys">Constructing a Structure from Keys</h4>
<pre><code class="language-python">s = struct.fromkeys([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
# Output:
# --------
#      a: None
#      b: None
#      c: None
#      d: None
# --------
</code></pre>
<h4 id="building-a-structure-from-variables-in-a-string">Building a Structure from Variables in a String</h4>
<pre><code class="language-python">s = struct.scan(&quot;${a} + ${b} * ${c} / ${d} --- ${ee}&quot;)
s.a = 1
s.b = &quot;test&quot;
s.c = [1, &quot;a&quot;, 2]
s.generator()
# Output:
# X = struct(
#      a=1,
#      b=&quot;test&quot;,
#      c=[1, 'a', 2],
#      d=None,
#      ee=None
# )
</code></pre>
<h4 id="indexing-and-iteration">Indexing and Iteration</h4>
<p>Structures can be indexed or sliced like lists.</p>
<pre><code class="language-python">c = a + b
c[0]      # Access the first field
c[-1]     # Access the last field
c[:2]     # Slice the structure
for field in c:
    print(field)
</code></pre>
<hr>
<h3 id="dynamic-dependency-management">Dynamic Dependency Management</h3>
<p><code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code> provides control over dependencies, sorting, and evaluation.</p>
<pre><code class="language-python">s = struct(d=3, e=&quot;${c} + {d}&quot;, c='${a} + ${b}', a=1, b=2)
s.sortdefinitions()
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}
#      e: ${c} + ${d}
# --------
</code></pre>
<p>For dynamic evaluation, use <code><a title="mstruct.param" href="#mstruct.param">param</a></code>:</p>
<pre><code class="language-python">p = param(sortdefinitions=True, d=3, e=&quot;${c} + ${d}&quot;, c='${a} + ${b}', a=1, b=2)
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}  (= 3)
#      e: ${c} + ${d}  (= 6)
# --------
</code></pre>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two structures (<code>__add__</code>).</li>
<li><code>-</code>: Subtraction of fields (<code>__sub__</code>).</li>
<li><code>len()</code>: Number of fields (<code>__len__</code>).</li>
<li><code>in</code>: Check for field existence (<code>__contains__</code>).</li>
</ul>
<h4 id="method-overview">Method Overview</h4>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>check(default)</code></td>
<td>Populate fields with defaults if missing.</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>Remove all fields.</td>
</tr>
<tr>
<td><code>dict2struct(dico)</code></td>
<td>Create a structure from a dictionary.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display the structure.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate expressions within fields.</td>
</tr>
<tr>
<td><code>fromkeys(keys)</code></td>
<td>Create a structure from a list of keys.</td>
</tr>
<tr>
<td><code>generator()</code></td>
<td>Generate Python code representing the structure.</td>
</tr>
<tr>
<td><code>items()</code></td>
<td>Return key-value pairs.</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>Return all keys in the structure.</td>
</tr>
<tr>
<td><code>read(file)</code></td>
<td>Load structure fields from a file.</td>
</tr>
<tr>
<td><code>scan(string)</code></td>
<td>Extract variables from a string and populate fields.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>struct2dict()</code></td>
<td>Convert the structure to a dictionary.</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>Return all field values.</td>
</tr>
<tr>
<td><code>write(file)</code></td>
<td>Save the structure to a file.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="dynamic-properties">Dynamic Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isempty</code></td>
<td><code>True</code> if the structure is empty.</td>
</tr>
<tr>
<td><code>isdefined</code></td>
<td><code>True</code> if all fields are defined.</td>
</tr>
</tbody>
</table>
<hr>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class struct():
    &#34;&#34;&#34;
    Class: `struct`
    ================

    A lightweight class that mimics Matlab-like structures, with additional features
    such as dynamic field creation, indexing, concatenation, and compatibility with
    evaluated parameters (`param`).

    ---

    ### Features
    - Dynamic creation of fields.
    - Indexing and iteration support for fields.
    - Concatenation and subtraction of structures.
    - Conversion to and from dictionaries.
    - Compatible with `param` and `paramauto` for evaluation and dependency handling.

    ---

    ### Examples

    #### Basic Usage
    ```python
    s = struct(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    print(s.a)  # 1
    s.d = 11    # Append a new field
    delattr(s, &#39;d&#39;)  # Delete the field
    ```

    #### Using `param` for Evaluation
    ```python
    p = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    p.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    # --------
    ```

    ---

    ### Concatenation and Subtraction
    Fields from the right-most structure overwrite existing values.
    ```python
    a = struct(a=1, b=2)
    b = struct(c=3, d=&#34;d&#34;, e=&#34;e&#34;)
    c = a + b
    e = c - a
    ```

    ---

    ### Practical Shorthands

    #### Constructing a Structure from Keys
    ```python
    s = struct.fromkeys([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;])
    # Output:
    # --------
    #      a: None
    #      b: None
    #      c: None
    #      d: None
    # --------
    ```

    #### Building a Structure from Variables in a String
    ```python
    s = struct.scan(&#34;${a} + ${b} * ${c} / ${d} --- ${ee}&#34;)
    s.a = 1
    s.b = &#34;test&#34;
    s.c = [1, &#34;a&#34;, 2]
    s.generator()
    # Output:
    # X = struct(
    #      a=1,
    #      b=&#34;test&#34;,
    #      c=[1, &#39;a&#39;, 2],
    #      d=None,
    #      ee=None
    # )
    ```

    #### Indexing and Iteration
    Structures can be indexed or sliced like lists.
    ```python
    c = a + b
    c[0]      # Access the first field
    c[-1]     # Access the last field
    c[:2]     # Slice the structure
    for field in c:
        print(field)
    ```

    ---

    ### Dynamic Dependency Management
    `struct` provides control over dependencies, sorting, and evaluation.

    ```python
    s = struct(d=3, e=&#34;${c} + {d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    s.sortdefinitions()
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}
    #      e: ${c} + ${d}
    # --------
    ```

    For dynamic evaluation, use `param`:
    ```python
    p = param(sortdefinitions=True, d=3, e=&#34;${c} + ${d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}  (= 3)
    #      e: ${c} + ${d}  (= 6)
    # --------
    ```

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two structures (`__add__`).
    - `-`: Subtraction of fields (`__sub__`).
    - `len()`: Number of fields (`__len__`).
    - `in`: Check for field existence (`__contains__`).

    #### Method Overview
    | Method                | Description                                             |
    |-----------------------|---------------------------------------------------------|
    | `check(default)`      | Populate fields with defaults if missing.               |
    | `clear()`             | Remove all fields.                                      |
    | `dict2struct(dico)`   | Create a structure from a dictionary.                   |
    | `disp()`              | Display the structure.                                  |
    | `eval()`              | Evaluate expressions within fields.                     |
    | `fromkeys(keys)`      | Create a structure from a list of keys.                 |
    | `generator()`         | Generate Python code representing the structure.        |
    | `items()`             | Return key-value pairs.                                 |
    | `keys()`              | Return all keys in the structure.                       |
    | `read(file)`          | Load structure fields from a file.                      |
    | `scan(string)`        | Extract variables from a string and populate fields.    |
    | `sortdefinitions()`   | Sort fields to resolve dependencies.                    |
    | `struct2dict()`       | Convert the structure to a dictionary.                  |
    | `values()`            | Return all field values.                                |
    | `write(file)`         | Save the structure to a file.                           |

    ---

    ### Dynamic Properties
    | Property    | Description                            |
    |-------------|----------------------------------------|
    | `isempty`   | `True` if the structure is empty.      |
    | `isdefined` | `True` if all fields are defined.      |

    ---
    &#34;&#34;&#34;

    # attributes to be overdefined
    _type = &#34;struct&#34;        # object type
    _fulltype = &#34;structure&#34; # full name
    _ftype = &#34;field&#34;        # field name
    _evalfeature = False    # true if eval() is available
    _maxdisplay = 40        # maximum number of characters to display (should be even)
    _propertyasattribute = False

    # attributes for the iterator method
    # Please keep it static, duplicate the object before changing _iter_
    _iter_ = 0

    # excluded attributes (keep the , in the Tupple if it is singleton)
    _excludedattr = {&#39;_iter_&#39;,&#39;__class__&#39;,&#39;_protection&#39;,&#39;_evaluation&#39;,&#39;_returnerror&#39;} # used by keys() and len()


    # Methods
    def __init__(self,**kwargs):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        # Optionally extend _excludedattr here
        self._excludedattr = self._excludedattr | {&#39;_excludedattr&#39;, &#39;_type&#39;, &#39;_fulltype&#39;,&#39;_ftype&#39;} # addition 2024-10-11
        self.set(**kwargs)

    def zip(self):
        &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
        return zip(self.keys(),self.values())

    @staticmethod
    def dict2struct(dico,makeparam=False):
        &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
        if isinstance(dico,dict):
            s = param() if makeparam else struct()
            s.set(**dico)
            return s
        raise TypeError(&#34;the argument must be a dictionary&#34;)

    def struct2dict(self):
        &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
        return dict(self.zip())

    def struct2param(self,protection=False,evaluation=True):
        &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
        p = param(**self.struct2dict())
        for i in range(len(self)):
            if isinstance(self[i],pstr): p[i] = pstr(p[i])
        p._protection = protection
        p._evaluation = evaluation
        return p

    def set(self,**kwargs):
        &#34;&#34;&#34; initialization &#34;&#34;&#34;
        self.__dict__.update(kwargs)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value

    def getattr(self,key):
        &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
        if key in self.__dict__:
            return self.__dict__[key]
        elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
             key not in self._excludedattr and \
             key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
            # If _propertyasattribute is True and it&#39;s a property, get its value
            return self.__class__.__dict__[key].fget(self)
        else:
            raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)

    def hasattr(self, key):
        &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
        return key in self.__dict__ or (
            getattr(self, &#39;_propertyasattribute&#39;, False) and
            key not in self._excludedattr and
            key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
        )

    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return pstr.eval(self.getattr(key))

    def __setattr__(self,key,value):
        &#34;&#34;&#34; set attribute override &#34;&#34;&#34;
        self.setattr(key,value)

    def __contains__(self,item):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(item)

    def keys(self):
        &#34;&#34;&#34; return the fields &#34;&#34;&#34;
        # keys() is used by struct() and its iterator
        return [key for key in self.__dict__.keys() if key not in self._excludedattr]

    def keyssorted(self,reverse=True):
        &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
        klist = self.keys()
        l = [len(k) for k in klist]
        return [k for _,k in sorted(zip(l,klist),reverse=reverse)]

    def values(self):
        &#34;&#34;&#34; return the values &#34;&#34;&#34;
        # values() is used by struct() and its iterator
        return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]

    @staticmethod
    def fromkeysvalues(keys,values,makeparam=False):
        &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
            use makeparam = True to create a param instead of struct
        &#34;&#34;&#34;
        if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
        if not isinstance(keys,_list_types): keys = [keys]
        if not isinstance(values,_list_types): values = [values]
        nk,nv = len(keys), len(values)
        s = param() if makeparam else struct()
        if nk&gt;0 and nv&gt;0:
            iv = 0
            for ik in range(nk):
                s.setattr(keys[ik], values[iv])
                iv = min(nv-1,iv+1)
            for ik in range(nk,nv):
                s.setattr(f&#34;key{ik}&#34;, values[ik])
        return s

    def items(self):
        &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
        return self.zip()

    def __getitem__(self,idx):
        &#34;&#34;&#34;
            s[i] returns the ith element of the structure
            s[:4] returns a structure with the four first fields
            s[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.getattr(self.keys()[idx])
            raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            return struct.fromkeysvalues(self.keys()[idx], self.values()[idx])
        elif isinstance(idx,(list,tuple)):
            k,v= self.keys(), self.values()
            nk = len(k)
            s = param() if isinstance(self,param) else struct()
            for i in idx:
                if isinstance(i,int) and i&gt;=0 and i&lt;nk:
                    s.setattr(k[i],v[i])
                else:
                    raise IndexError(&#34;idx must contains only integers ranged between 0 and %d&#34; % (nk-1))
            return s
        elif isinstance(idx,str):
            return self.getattr(idx)
        else:
            raise TypeError(&#34;The index must be an integer or a slice and not a %s&#34; % type(idx).__name__)

    def __setitem__(self,idx,value):
        &#34;&#34;&#34; set the ith element of the structure  &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                self.setattr(self.keys()[idx], value)
            else:
                raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            k = self.keys()[idx]
            if len(value)&lt;=1:
                for i in range(len(k)): self.setattr(k[i], value)
            elif len(k) == len(value):
                for i in range(len(k)): self.setattr(k[i], value[i])
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of elements in the slive (%d)&#34; \
                       % (len(value),len(idx)))
        elif isinstance(idx,(list,tuple)):
            if len(value)&lt;=1:
                for i in range(len(idx)): self[idx[i]]=value
            elif len(idx) == len(value):
                for i in range(len(idx)): self[idx[i]]=value[i]
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of indices (%d)&#34; \
                                 % (len(value),len(idx)))

    def __len__(self):
        &#34;&#34;&#34; return the number of fields &#34;&#34;&#34;
        # len() is used by struct() and its iterator
        return len(self.keys())

    def __iter__(self):
        &#34;&#34;&#34; struct iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    def __next__(self):
        &#34;&#34;&#34; increment iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum {self._ftype} iteration reached {len(self)}&#34;)

    def __add__(self,s,sortdefinitions=False,raiseerror=True, silentmode=True):
        &#34;&#34;&#34; add a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        dup.__dict__.update(s.__dict__)
        if sortdefinitions: dup.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return dup

    def __iadd__(self,s,sortdefinitions=False,raiseerror=False, silentmode=True):
        &#34;&#34;&#34; iadd a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        self.__dict__.update(s.__dict__)
        if sortdefinitions: self.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return self

    def __sub__(self,s):
        &#34;&#34;&#34; sub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        listofkeys = dup.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(dup,k)
        return dup

    def __isub__(self,s):
        &#34;&#34;&#34; isub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        listofkeys = self.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(self,k)
        return self

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        if self.__dict__=={}:
            print(f&#34;empty {self._fulltype} ({self._type} object) with no {self._type}s&#34;)
            return f&#34;empty {self._fulltype}&#34;
        else:
            tmp = self.eval() if self._evalfeature else []
            keylengths = [len(key) for key in self.__dict__]
            width = max(10,max(keylengths)+2)
            fmt = &#34;%%%ss:&#34; % width
            fmteval = fmt[:-1]+&#34;=&#34;
            fmtcls =  fmt[:-1]+&#34;:&#34;
            line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
            print(line)
            for key,value in self.__dict__.items():
                if key not in self._excludedattr:
                    if isinstance(value,_numeric_types):
                        # old code (removed on 2025-01-18)
                        # if isinstance(value,pstr):
                        #     print(fmt % key,&#39;p&#34;&#39;+self.dispmax(value)+&#39;&#34;&#39;)
                        # if isinstance(value,str) and value==&#34;&#34;:
                        #     print(fmt % key,&#39;&#34;&#34;&#39;)
                        # else:
                        #     print(fmt % key,self.dispmax(value))
                        if isinstance(value,np.ndarray):
                            print(fmt % key, struct.format_array(value))
                        else:
                            print(fmt % key,self.dispmax(value))
                    elif isinstance(value,struct):
                        print(fmt % key,self.dispmax(value.__str__()))
                    elif isinstance(value,type):
                        print(fmt % key,self.dispmax(str(value)))
                    else:
                        print(fmt % key,type(value))
                        print(fmtcls % &#34;&#34;,self.dispmax(str(value)))
                    if self._evalfeature:
                        if isinstance(self,paramauto):
                            try:
                                if isinstance(value,pstr):
                                    print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                                elif isinstance(value,str):
                                    if value == &#34;&#34;:
                                        print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(tmp.getattr(key)))
                            except Exception as err:
                                print(fmteval % &#34;&#34;,err.message, err.args)
                        else:
                            if isinstance(value,pstr):
                                print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                            elif isinstance(value,str):
                                if value == &#34;&#34;:
                                    print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                else:
                                    calcvalue =tmp.getattr(key)
                                    if isinstance(calcvalue, str) and &#34;error&#34; in calcvalue.lower():
                                        print(fmteval % &#34;&#34;,calcvalue)
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(calcvalue))
            print(line)
            return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    def disp(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        self.__repr__()

    def __str__(self):
        return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    @property
    def isempty(self):
        &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
        return len(self)==0

    def clear(self):
        &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
        for k in self.keys(): delattr(self,k)

    def format(self, s, escape=False, raiseerror=True):
        &#34;&#34;&#34;
            Format a string with fields using {field} as placeholders.
            Handles expressions like ${variable1}.

            Args:
                s (str): The input string to format.
                escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
                raiseerror (bool): If True, raises errors for missing fields.

            Returns:
                str: The formatted string.
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format_map(AttrErrorDict(self.__dict__))
                else:
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
            except AttributeError as attr_err:
                # Handle AttributeError for expressions with operators
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
                return s_  # Revert to using &#39;${&#39; for unresolved expressions
            except Exception as other_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                raise RuntimeError from other_err
        else:
            if escape:
                return s.format_map(AttrErrorDict(self.__dict__))
            else:
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))

    def format_legacy(self,s,escape=False,raiseerror=True):
        &#34;&#34;&#34;
            format a string with field (use {field} as placeholders)
                s.replace(string), s.replace(string,escape=True)
                where:
                    s is a struct object
                    string is a string with possibly ${variable1}
                    escape is a flag to prevent ${} replaced by {}
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format(**self.__dict__)
                else:
                    return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
            except KeyError as kerr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
                return s_ # instead of s (we put back $) - OV 2023/01/27
            except Exception as othererr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                raise RuntimeError from othererr
        else:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)

    def fromkeys(self,keys):
        &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
        return self+struct(**dict.fromkeys(keys,None))

    @staticmethod
    def scan(s):
        &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
        tmp = struct()
        #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
        found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
        uniq = []
        for x in found:
            if x not in uniq: uniq.append(x)
        return tmp.fromkeys(uniq)

    @staticmethod
    def isstrexpression(s):
        &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        return re.search(r&#34;\$\{.*?\}&#34;,s) is not None

    @property
    def isexpression(self):
        &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        for k,v in self.items():
            if isinstance(v,str):
                s.setattr(k,struct.isstrexpression(v))
            else:
                s.setattr(k,False)
        return s

    @staticmethod
    def isstrdefined(s,ref):
        &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        if struct.isstrexpression(s):
            k = struct.scan(s).keys()
            allfound,i,nk = True,0,len(k)
            while (i&lt;nk) and allfound:
                allfound = k[i] in ref
                i += 1
            return allfound
        else:
            return False


    def isdefined(self,ref=None):
        &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
        nk = len(k)
        if ref is None:
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
                else:
                    s.setattr(k[i],True)
        else:
            if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],ref))
                else:
                    s.setattr(k[i],True)
        return s

    def sortdefinitions(self,raiseerror=True,silentmode=False):
        &#34;&#34;&#34; sortdefintions sorts all definitions
            so that they can be executed as param().
            If any inconsistency is found, an error message is generated.

            Flags = default values
                raiseerror=True show erros of True
                silentmode=False no warning if True
        &#34;&#34;&#34;
        find = lambda xlist: [i for i, x in enumerate(xlist) if x]
        findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
        k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
        istatic = findnot(isexpr)
        idynamic = find(isexpr)
        static = struct.fromkeysvalues(
            [ k[i] for i in istatic ],
            [ v[i] for i in istatic ],
            makeparam = False)
        dynamic = struct.fromkeysvalues(
            [ k[i] for i in idynamic ],
            [ v[i] for i in idynamic ],
            makeparam=False)
        current = static # make static the current structure
        nmissing, anychange, errorfound = len(dynamic), False, False
        while nmissing:
            itst, found = 0, False
            while itst&lt;nmissing and not found:
                teststruct = current + dynamic[[itst]] # add the test field
                found = all(list(teststruct.isdefined()))
                ifound = itst
                itst += 1
            if found:
                current = teststruct # we accept the new field
                dynamic[ifound] = []
                nmissing -= 1
                anychange = True
            else:
                if raiseerror:
                    raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                                   (nmissing,len(self),self._ftype))
                else:
                    if (not errorfound) and (not silentmode):
                        print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                              (nmissing,len(self),self._ftype))
                    current = teststruct # we accept the new field (even if it cannot be interpreted)
                    dynamic[ifound] = []
                    nmissing -= 1
                    errorfound = True
        if anychange:
            self.clear() # reset all fields and assign them in the proper order
            k,v = current.keys(), current.values()
            for i in range(len(k)):
                self.setattr(k[i],v[i])

    def generator(self):
        &#34;&#34;&#34; generate Python code of the equivalent structure &#34;&#34;&#34;
        nk = len(self)
        if nk==0:
            print(&#34;X = struct()&#34;)
        else:
            ik = 0
            fmt = &#34;%%%ss=&#34; % max(10,max([len(k) for k in self.keys()])+2)
            print(&#34;\nX = struct(&#34;)
            for k in self.keys():
                ik += 1
                end = &#34;,\n&#34; if ik&lt;nk else &#34;\n&#34;+(fmt[:-1] % &#34;)&#34;)+&#34;\n&#34;
                v = getattr(self,k)
                if isinstance(v,(int,float)) or v == None:
                    print(fmt % k,v,end=end)
                elif isinstance(v,str):
                    print(fmt % k,f&#39;&#34;{v}&#34;&#39;,end=end)
                elif isinstance(v,(list,tuple)):
                    print(fmt % k,v,end=end)
                else:
                    print(fmt % k,&#34;/* unsupported type */&#34;,end=end)

    # copy and deep copy methpds for the class
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, duplicatedeep(v, memo))
        return copie


    # write a file
    def write(self, file, overwrite=True, mkdir=False):
        &#34;&#34;&#34;
            write the equivalent structure (not recursive for nested struct)
                write(filename, overwrite=True, mkdir=False)

            Parameters:
            - file: The file path to write to.
            - overwrite: Whether to overwrite the file if it exists (default: True).
            - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()

        # Check if the directory exists or if mkdir is set to True, create it
        if mkdir:
            file_path.parent.mkdir(parents=True, exist_ok=True)
        elif not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If overwrite is False and the file already exists, raise an exception
        if not overwrite and file_path.exists():
            raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
        # Open and write to the file using the resolved path
        with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
            print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
            for k, v in self.items():
                if v is None:
                    print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
                elif isinstance(v, (int, float)):
                    print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
                elif isinstance(v, str):
                    print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
                else:
                    print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)


    # read a file
    @staticmethod
    def read(file):
        &#34;&#34;&#34;
            read the equivalent structure
                read(filename)

            Parameters:
            - file: The file path to read from.
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()
        # Check if the parent directory exists, otherwise raise an error
        if not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If the file does not exist, raise an exception
        if not file_path.exists():
            raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
        # Open and read the file
        with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            s = struct()  # Assuming struct is defined elsewhere
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                expr = line.split(sep=&#34;=&#34;)
                if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                    lhs = expr[0]
                    rhs = &#34;&#34;.join(expr[1:]).strip()
                    if len(rhs) == 0 or rhs == &#34;None&#34;:
                        v = None
                    else:
                        v = eval(rhs)
                    s.setattr(lhs, v)
        return s

    # argcheck
    def check(self,default):
        &#34;&#34;&#34;
        populate fields from a default structure
            check(defaultstruct)
            missing field, None and [] values are replaced by default ones

            Note: a.check(b) is equivalent to b+a except for [] and None values
        &#34;&#34;&#34;
        if not isinstance(default,struct):
            raise TypeError(&#34;the first argument must be a structure&#34;)
        for f in default.keys():
            ref = default.getattr(f)
            if f not in self:
                self.setattr(f, ref)
            else:
                current = self.getattr(f)
                if ((current is None)  or (current==[])) and \
                    ((ref is not None) and (ref!=[])):
                        self.setattr(f, ref)


    # update values based on key:value
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple fields at once, while protecting certain attributes.

        Parameters:
        -----------
        **kwargs : dict
            The fields to update and their new values.

        Protected attributes defined in _excludedattr are not updated.

        Usage:
        ------
        s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
        &#34;&#34;&#34;
        protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

        for key, value in kwargs.items():
            if key in protected_attributes:
                print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
            else:
                self.setattr(key, value)


    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract a sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            A new instance of the same class as the original, containing
            only the specified keys.

        Usage:
        ------
        sub_struct = s(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        # Create a new instance of the same class
        sub_struct = self.__class__()

        # Get the full type and field type for error messages
        fulltype = getattr(self, &#39;_fulltype&#39;, &#39;structure&#39;)
        ftype = getattr(self, &#39;_ftype&#39;, &#39;field&#39;)

        # Add only the specified keys to the new sub-structure
        for key in keys:
            if key in self:
                sub_struct.setattr(key, self.getattr(key))
            else:
                raise KeyError(f&#34;{fulltype} does not contain the {ftype} &#39;{key}&#39;.&#34;)

        return sub_struct


    def __delattr__(self, key):
        &#34;&#34;&#34; Delete an instance attribute if it exists and is not a class or excluded attribute. &#34;&#34;&#34;
        if key in self._excludedattr:
            raise AttributeError(f&#34;Cannot delete excluded attribute &#39;{key}&#39;&#34;)
        elif key in self.__class__.__dict__:  # Check if it&#39;s a class attribute
            raise AttributeError(f&#34;Cannot delete class attribute &#39;{key}&#39;&#34;)
        elif key in self.__dict__:  # Delete only if in instance&#39;s __dict__
            del self.__dict__[key]
        else:
            raise AttributeError(f&#34;{self._type} has no attribute &#39;{key}&#39;&#34;)


    # A la Matlab display method of vectors, matrices and ND-arrays
    @staticmethod
    def format_array(value):
        &#34;&#34;&#34;Format NumPy array for display with distinctions for row and column vectors.&#34;&#34;&#34;
        dtype_str = {
            np.float64: &#34;double&#34;,
            np.float32: &#34;single&#34;,
            np.int32: &#34;int32&#34;,
            np.int64: &#34;int64&#34;,
            np.complex64: &#34;complex single&#34;,
            np.complex128: &#34;complex double&#34;,
        }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map
        max_display = 10  # Maximum number of elements to display

        # Check if the value is a 1D array (could be a row or column vector)
        if value.ndim == 1:
            if len(value) &lt;= max_display:
                formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
            else:
                formatted = f&#34;[{len(value)}Ã—1 {dtype_str}]&#34;
        # 2D array check
        elif value.ndim == 2:
            rows, cols = value.shape
            # If it&#39;s a single column (column vector), handle it as a transpose
            if cols == 1:  # Column vector (1 x n)
                if rows &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{rows}Ã—1 {dtype_str}]&#34;
            # If it&#39;s a single row (row vector), handle it as a row vector
            elif rows == 1:  # Row vector (1 x n)
                if cols &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[1Ã—{cols} {dtype_str}]&#34;
            else:  # General 2D matrix
                formatted = f&#34;[{rows}Ã—{cols} {dtype_str}]&#34;
        # For higher-dimensional arrays
        else:
            shape_str = &#34;Ã—&#34;.join(map(str, value.shape))
            formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;
        return formatted</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mstruct.param" href="#mstruct.param">param</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mstruct.struct.dict2struct"><code class="name flex">
<span>def <span class="ident">dict2struct</span></span>(<span>dico, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>create a structure from a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dict2struct(dico,makeparam=False):
    &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
    if isinstance(dico,dict):
        s = param() if makeparam else struct()
        s.set(**dico)
        return s
    raise TypeError(&#34;the argument must be a dictionary&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.format_array"><code class="name flex">
<span>def <span class="ident">format_array</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Format NumPy array for display with distinctions for row and column vectors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_array(value):
    &#34;&#34;&#34;Format NumPy array for display with distinctions for row and column vectors.&#34;&#34;&#34;
    dtype_str = {
        np.float64: &#34;double&#34;,
        np.float32: &#34;single&#34;,
        np.int32: &#34;int32&#34;,
        np.int64: &#34;int64&#34;,
        np.complex64: &#34;complex single&#34;,
        np.complex128: &#34;complex double&#34;,
    }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map
    max_display = 10  # Maximum number of elements to display

    # Check if the value is a 1D array (could be a row or column vector)
    if value.ndim == 1:
        if len(value) &lt;= max_display:
            formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
        else:
            formatted = f&#34;[{len(value)}Ã—1 {dtype_str}]&#34;
    # 2D array check
    elif value.ndim == 2:
        rows, cols = value.shape
        # If it&#39;s a single column (column vector), handle it as a transpose
        if cols == 1:  # Column vector (1 x n)
            if rows &lt;= max_display:
                formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
            else:
                formatted = f&#34;[{rows}Ã—1 {dtype_str}]&#34;
        # If it&#39;s a single row (row vector), handle it as a row vector
        elif rows == 1:  # Row vector (1 x n)
            if cols &lt;= max_display:
                formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
            else:
                formatted = f&#34;[1Ã—{cols} {dtype_str}]&#34;
        else:  # General 2D matrix
            formatted = f&#34;[{rows}Ã—{cols} {dtype_str}]&#34;
    # For higher-dimensional arrays
    else:
        shape_str = &#34;Ã—&#34;.join(map(str, value.shape))
        formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;
    return formatted</code></pre>
</details>
</dd>
<dt id="mstruct.struct.fromkeysvalues"><code class="name flex">
<span>def <span class="ident">fromkeysvalues</span></span>(<span>keys, values, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>struct.keysvalues(keys,values) creates a structure from keys and values
use makeparam = True to create a param instead of struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromkeysvalues(keys,values,makeparam=False):
    &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
        use makeparam = True to create a param instead of struct
    &#34;&#34;&#34;
    if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
    if not isinstance(keys,_list_types): keys = [keys]
    if not isinstance(values,_list_types): values = [values]
    nk,nv = len(keys), len(values)
    s = param() if makeparam else struct()
    if nk&gt;0 and nv&gt;0:
        iv = 0
        for ik in range(nk):
            s.setattr(keys[ik], values[iv])
            iv = min(nv-1,iv+1)
        for ik in range(nk,nv):
            s.setattr(f&#34;key{ik}&#34;, values[ik])
    return s</code></pre>
</details>
</dd>
<dt id="mstruct.struct.isstrdefined"><code class="name flex">
<span>def <span class="ident">isstrdefined</span></span>(<span>s, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrdefined(string,ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrdefined(s,ref):
    &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
    if struct.isstrexpression(s):
        k = struct.scan(s).keys()
        allfound,i,nk = True,0,len(k)
        while (i&lt;nk) and allfound:
            allfound = k[i] in ref
            i += 1
        return allfound
    else:
        return False</code></pre>
</details>
</dd>
<dt id="mstruct.struct.isstrexpression"><code class="name flex">
<span>def <span class="ident">isstrexpression</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrexpression(string) returns true if s contains an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrexpression(s):
    &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    return re.search(r&#34;\$\{.*?\}&#34;,s) is not None</code></pre>
</details>
</dd>
<dt id="mstruct.struct.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>read the equivalent structure
read(filename)</p>
<p>Parameters:
- file: The file path to read from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read(file):
    &#34;&#34;&#34;
        read the equivalent structure
            read(filename)

        Parameters:
        - file: The file path to read from.
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()
    # Check if the parent directory exists, otherwise raise an error
    if not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If the file does not exist, raise an exception
    if not file_path.exists():
        raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
    # Open and read the file
    with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
        s = struct()  # Assuming struct is defined elsewhere
        while True:
            line = f.readline()
            if not line:
                break
            line = line.strip()
            expr = line.split(sep=&#34;=&#34;)
            if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                lhs = expr[0]
                rhs = &#34;&#34;.join(expr[1:]).strip()
                if len(rhs) == 0 or rhs == &#34;None&#34;:
                    v = None
                else:
                    v = eval(rhs)
                s.setattr(lhs, v)
    return s</code></pre>
</details>
</dd>
<dt id="mstruct.struct.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>scan(string) scan a string for variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def scan(s):
    &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
    tmp = struct()
    #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
    found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
    uniq = []
    for x in found:
        if x not in uniq: uniq.append(x)
    return tmp.fromkeys(uniq)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="mstruct.struct.isempty"><code class="name">var <span class="ident">isempty</span></code></dt>
<dd>
<div class="desc"><p>isempty is set to True for an empty structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isempty(self):
    &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
    return len(self)==0</code></pre>
</details>
</dd>
<dt id="mstruct.struct.isexpression"><code class="name">var <span class="ident">isexpression</span></code></dt>
<dd>
<div class="desc"><p>same structure with True if it is an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isexpression(self):
    &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    for k,v in self.items():
        if isinstance(v,str):
            s.setattr(k,struct.isstrexpression(v))
        else:
            s.setattr(k,False)
    return s</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mstruct.struct.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, default)</span>
</code></dt>
<dd>
<div class="desc"><p>populate fields from a default structure
check(defaultstruct)
missing field, None and [] values are replaced by default ones</p>
<pre><code>Note: a.check(b) is equivalent to b+a except for [] and None values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self,default):
    &#34;&#34;&#34;
    populate fields from a default structure
        check(defaultstruct)
        missing field, None and [] values are replaced by default ones

        Note: a.check(b) is equivalent to b+a except for [] and None values
    &#34;&#34;&#34;
    if not isinstance(default,struct):
        raise TypeError(&#34;the first argument must be a structure&#34;)
    for f in default.keys():
        ref = default.getattr(f)
        if f not in self:
            self.setattr(f, ref)
        else:
            current = self.getattr(f)
            if ((current is None)  or (current==[])) and \
                ((ref is not None) and (ref!=[])):
                    self.setattr(f, ref)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear() delete all fields while preserving the original class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
    for k in self.keys(): delattr(self,k)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.disp"><code class="name flex">
<span>def <span class="ident">disp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>display method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disp(self):
    &#34;&#34;&#34; display method &#34;&#34;&#34;
    self.__repr__()</code></pre>
</details>
</dd>
<dt id="mstruct.struct.dispmax"><code class="name flex">
<span>def <span class="ident">dispmax</span></span>(<span>self, content)</span>
</code></dt>
<dd>
<div class="desc"><p>optimize display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispmax(self,content):
    &#34;&#34;&#34; optimize display &#34;&#34;&#34;
    strcontent = str(content)
    if len(strcontent)&gt;self._maxdisplay:
        nchar = round(self._maxdisplay/2)
        return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
    else:
        return content</code></pre>
</details>
</dd>
<dt id="mstruct.struct.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Format a string with fields using {field} as placeholders.
Handles expressions like ${variable1}.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>The input string to format.</dd>
<dt><strong><code>escape</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, prevents replacing '${' with '{'.</dd>
<dt><strong><code>raiseerror</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, raises errors for missing fields.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, s, escape=False, raiseerror=True):
    &#34;&#34;&#34;
        Format a string with fields using {field} as placeholders.
        Handles expressions like ${variable1}.

        Args:
            s (str): The input string to format.
            escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
            raiseerror (bool): If True, raises errors for missing fields.

        Returns:
            str: The formatted string.
    &#34;&#34;&#34;
    if raiseerror:
        try:
            if escape:
                return s.format_map(AttrErrorDict(self.__dict__))
            else:
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
        except AttributeError as attr_err:
            # Handle AttributeError for expressions with operators
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
            return s_  # Revert to using &#39;${&#39; for unresolved expressions
        except Exception as other_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            raise RuntimeError from other_err
    else:
        if escape:
            return s.format_map(AttrErrorDict(self.__dict__))
        else:
            return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))</code></pre>
</details>
</dd>
<dt id="mstruct.struct.format_legacy"><code class="name flex">
<span>def <span class="ident">format_legacy</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>format a string with field (use {field} as placeholders)
s.replace(string), s.replace(string,escape=True)
where:
s is a struct object
string is a string with possibly ${variable1}
escape is a flag to prevent ${} replaced by {}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_legacy(self,s,escape=False,raiseerror=True):
    &#34;&#34;&#34;
        format a string with field (use {field} as placeholders)
            s.replace(string), s.replace(string,escape=True)
            where:
                s is a struct object
                string is a string with possibly ${variable1}
                escape is a flag to prevent ${} replaced by {}
    &#34;&#34;&#34;
    if raiseerror:
        try:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
        except KeyError as kerr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
            return s_ # instead of s (we put back $) - OV 2023/01/27
        except Exception as othererr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            raise RuntimeError from othererr
    else:
        if escape:
            return s.format(**self.__dict__)
        else:
            return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.fromkeys"><code class="name flex">
<span>def <span class="ident">fromkeys</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a structure from keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromkeys(self,keys):
    &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
    return self+struct(**dict.fromkeys(keys,None))</code></pre>
</details>
</dd>
<dt id="mstruct.struct.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>generate Python code of the equivalent structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self):
    &#34;&#34;&#34; generate Python code of the equivalent structure &#34;&#34;&#34;
    nk = len(self)
    if nk==0:
        print(&#34;X = struct()&#34;)
    else:
        ik = 0
        fmt = &#34;%%%ss=&#34; % max(10,max([len(k) for k in self.keys()])+2)
        print(&#34;\nX = struct(&#34;)
        for k in self.keys():
            ik += 1
            end = &#34;,\n&#34; if ik&lt;nk else &#34;\n&#34;+(fmt[:-1] % &#34;)&#34;)+&#34;\n&#34;
            v = getattr(self,k)
            if isinstance(v,(int,float)) or v == None:
                print(fmt % k,v,end=end)
            elif isinstance(v,str):
                print(fmt % k,f&#39;&#34;{v}&#34;&#39;,end=end)
            elif isinstance(v,(list,tuple)):
                print(fmt % k,v,end=end)
            else:
                print(fmt % k,&#34;/* unsupported type */&#34;,end=end)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.getattr"><code class="name flex">
<span>def <span class="ident">getattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get attribute override to access both instance attributes and properties if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getattr(self,key):
    &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
    if key in self.__dict__:
        return self.__dict__[key]
    elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
         key not in self._excludedattr and \
         key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
        # If _propertyasattribute is True and it&#39;s a property, get its value
        return self.__class__.__dict__[key].fget(self)
    else:
        raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.hasattr"><code class="name flex">
<span>def <span class="ident">hasattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the field exists, considering properties as regular attributes if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasattr(self, key):
    &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
    return key in self.__dict__ or (
        getattr(self, &#39;_propertyasattribute&#39;, False) and
        key not in self._excludedattr and
        key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
    )</code></pre>
</details>
</dd>
<dt id="mstruct.struct.isdefined"><code class="name flex">
<span>def <span class="ident">isdefined</span></span>(<span>self, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>isdefined(ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdefined(self,ref=None):
    &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
    nk = len(k)
    if ref is None:
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
            else:
                s.setattr(k[i],True)
    else:
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],ref))
            else:
                s.setattr(k[i],True)
    return s</code></pre>
</details>
</dd>
<dt id="mstruct.struct.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all elements as iterable key, value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
    return self.zip()</code></pre>
</details>
</dd>
<dt id="mstruct.struct.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34; return the fields &#34;&#34;&#34;
    # keys() is used by struct() and its iterator
    return [key for key in self.__dict__.keys() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="mstruct.struct.keyssorted"><code class="name flex">
<span>def <span class="ident">keyssorted</span></span>(<span>self, reverse=True)</span>
</code></dt>
<dd>
<div class="desc"><p>sort keys by length()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyssorted(self,reverse=True):
    &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
    klist = self.keys()
    l = [len(k) for k in klist]
    return [k for _,k in sorted(zip(l,klist),reverse=reverse)]</code></pre>
</details>
</dd>
<dt id="mstruct.struct.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self,**kwargs):
    &#34;&#34;&#34; initialization &#34;&#34;&#34;
    self.__dict__.update(kwargs)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.setattr"><code class="name flex">
<span>def <span class="ident">setattr</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>set field and value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setattr(self,key,value):
    &#34;&#34;&#34; set field and value &#34;&#34;&#34;
    if isinstance(value,list) and len(value)==0 and key in self:
        delattr(self, key)
    else:
        self.__dict__[key] = value</code></pre>
</details>
</dd>
<dt id="mstruct.struct.sortdefinitions"><code class="name flex">
<span>def <span class="ident">sortdefinitions</span></span>(<span>self, raiseerror=True, silentmode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>sortdefintions sorts all definitions
so that they can be executed as param().
If any inconsistency is found, an error message is generated.</p>
<p>Flags = default values
raiseerror=True show erros of True
silentmode=False no warning if True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortdefinitions(self,raiseerror=True,silentmode=False):
    &#34;&#34;&#34; sortdefintions sorts all definitions
        so that they can be executed as param().
        If any inconsistency is found, an error message is generated.

        Flags = default values
            raiseerror=True show erros of True
            silentmode=False no warning if True
    &#34;&#34;&#34;
    find = lambda xlist: [i for i, x in enumerate(xlist) if x]
    findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
    k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
    istatic = findnot(isexpr)
    idynamic = find(isexpr)
    static = struct.fromkeysvalues(
        [ k[i] for i in istatic ],
        [ v[i] for i in istatic ],
        makeparam = False)
    dynamic = struct.fromkeysvalues(
        [ k[i] for i in idynamic ],
        [ v[i] for i in idynamic ],
        makeparam=False)
    current = static # make static the current structure
    nmissing, anychange, errorfound = len(dynamic), False, False
    while nmissing:
        itst, found = 0, False
        while itst&lt;nmissing and not found:
            teststruct = current + dynamic[[itst]] # add the test field
            found = all(list(teststruct.isdefined()))
            ifound = itst
            itst += 1
        if found:
            current = teststruct # we accept the new field
            dynamic[ifound] = []
            nmissing -= 1
            anychange = True
        else:
            if raiseerror:
                raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                               (nmissing,len(self),self._ftype))
            else:
                if (not errorfound) and (not silentmode):
                    print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                          (nmissing,len(self),self._ftype))
                current = teststruct # we accept the new field (even if it cannot be interpreted)
                dynamic[ifound] = []
                nmissing -= 1
                errorfound = True
    if anychange:
        self.clear() # reset all fields and assign them in the proper order
        k,v = current.keys(), current.values()
        for i in range(len(k)):
            self.setattr(k[i],v[i])</code></pre>
</details>
</dd>
<dt id="mstruct.struct.struct2dict"><code class="name flex">
<span>def <span class="ident">struct2dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create a dictionary from the current structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2dict(self):
    &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
    return dict(self.zip())</code></pre>
</details>
</dd>
<dt id="mstruct.struct.struct2param"><code class="name flex">
<span>def <span class="ident">struct2param</span></span>(<span>self, protection=False, evaluation=True)</span>
</code></dt>
<dd>
<div class="desc"><p>convert an object struct() to param()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2param(self,protection=False,evaluation=True):
    &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
    p = param(**self.struct2dict())
    for i in range(len(self)):
        if isinstance(self[i],pstr): p[i] = pstr(p[i])
    p._protection = protection
    p._evaluation = evaluation
    return p</code></pre>
</details>
</dd>
<dt id="mstruct.struct.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update multiple fields at once, while protecting certain attributes.</p>
<h2 id="parameters">Parameters:</h2>
<p>**kwargs : dict
The fields to update and their new values.</p>
<p>Protected attributes defined in _excludedattr are not updated.</p>
<h2 id="usage">Usage:</h2>
<p>s.update(a=10, b=[1, 2, 3], new_field="new_value")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update multiple fields at once, while protecting certain attributes.

    Parameters:
    -----------
    **kwargs : dict
        The fields to update and their new values.

    Protected attributes defined in _excludedattr are not updated.

    Usage:
    ------
    s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
    &#34;&#34;&#34;
    protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

    for key, value in kwargs.items():
        if key in protected_attributes:
            print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
        else:
            self.setattr(key, value)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34; return the values &#34;&#34;&#34;
    # values() is used by struct() and its iterator
    return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="mstruct.struct.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, overwrite=True, mkdir=False)</span>
</code></dt>
<dd>
<div class="desc"><p>write the equivalent structure (not recursive for nested struct)
write(filename, overwrite=True, mkdir=False)</p>
<p>Parameters:
- file: The file path to write to.
- overwrite: Whether to overwrite the file if it exists (default: True).
- mkdir: Whether to create the directory if it doesn't exist (default: False).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, overwrite=True, mkdir=False):
    &#34;&#34;&#34;
        write the equivalent structure (not recursive for nested struct)
            write(filename, overwrite=True, mkdir=False)

        Parameters:
        - file: The file path to write to.
        - overwrite: Whether to overwrite the file if it exists (default: True).
        - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()

    # Check if the directory exists or if mkdir is set to True, create it
    if mkdir:
        file_path.parent.mkdir(parents=True, exist_ok=True)
    elif not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If overwrite is False and the file already exists, raise an exception
    if not overwrite and file_path.exists():
        raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
    # Open and write to the file using the resolved path
    with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
        print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
        for k, v in self.items():
            if v is None:
                print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
            elif isinstance(v, (int, float)):
                print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
            elif isinstance(v, str):
                print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
            else:
                print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>zip keys and values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self):
    &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
    return zip(self.keys(),self.values())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#module-structpy">Module: struct.py</a><ul>
<li><a href="#purpose">Purpose</a></li>
<li><a href="#key-features">Key Features</a></li>
<li><a href="#evaluation-features-updated-for-pizza-10">Evaluation Features (Updated for Pizza 1.0)</a></li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#basic-struct-usage">Basic Struct Usage</a></li>
<li><a href="#parameter-evaluation-with-param">Parameter Evaluation with param</a></li>
<li><a href="#path-management-with-pstr">Path Management with pstr</a></li>
<li><a href="#automatic-dependency-handling-with-paramauto">Automatic Dependency Handling with paramauto</a></li>
<li><a href="#evaluation-usage">Evaluation Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mstruct.AttrErrorDict" href="#mstruct.AttrErrorDict">AttrErrorDict</a></code></h4>
</li>
<li>
<h4><code><a title="mstruct.SafeEvaluator" href="#mstruct.SafeEvaluator">SafeEvaluator</a></code></h4>
<ul class="two-column">
<li><code><a title="mstruct.SafeEvaluator.evaluate" href="#mstruct.SafeEvaluator.evaluate">evaluate</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.generic_visit" href="#mstruct.SafeEvaluator.generic_visit">generic_visit</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Attribute" href="#mstruct.SafeEvaluator.visit_Attribute">visit_Attribute</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_BinOp" href="#mstruct.SafeEvaluator.visit_BinOp">visit_BinOp</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Call" href="#mstruct.SafeEvaluator.visit_Call">visit_Call</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Constant" href="#mstruct.SafeEvaluator.visit_Constant">visit_Constant</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_ExtSlice" href="#mstruct.SafeEvaluator.visit_ExtSlice">visit_ExtSlice</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Index" href="#mstruct.SafeEvaluator.visit_Index">visit_Index</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_List" href="#mstruct.SafeEvaluator.visit_List">visit_List</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Name" href="#mstruct.SafeEvaluator.visit_Name">visit_Name</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Slice" href="#mstruct.SafeEvaluator.visit_Slice">visit_Slice</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Subscript" href="#mstruct.SafeEvaluator.visit_Subscript">visit_Subscript</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Tuple" href="#mstruct.SafeEvaluator.visit_Tuple">visit_Tuple</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_UnaryOp" href="#mstruct.SafeEvaluator.visit_UnaryOp">visit_UnaryOp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mstruct.param" href="#mstruct.param">param</a></code></h4>
<ul class="two-column">
<li><code><a title="mstruct.param.escape" href="#mstruct.param.escape">escape</a></code></li>
<li><code><a title="mstruct.param.eval" href="#mstruct.param.eval">eval</a></code></li>
<li><code><a title="mstruct.param.formateval" href="#mstruct.param.formateval">formateval</a></code></li>
<li><code><a title="mstruct.param.protect" href="#mstruct.param.protect">protect</a></code></li>
<li><code><a title="mstruct.param.safe_fstring" href="#mstruct.param.safe_fstring">safe_fstring</a></code></li>
<li><code><a title="mstruct.param.tostatic" href="#mstruct.param.tostatic">tostatic</a></code></li>
<li><code><a title="mstruct.param.tostruct" href="#mstruct.param.tostruct">tostruct</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code></h4>
</li>
<li>
<h4><code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code></h4>
<ul class="">
<li><code><a title="mstruct.pstr.eval" href="#mstruct.pstr.eval">eval</a></code></li>
<li><code><a title="mstruct.pstr.topath" href="#mstruct.pstr.topath">topath</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code></h4>
<ul class="two-column">
<li><code><a title="mstruct.struct.check" href="#mstruct.struct.check">check</a></code></li>
<li><code><a title="mstruct.struct.clear" href="#mstruct.struct.clear">clear</a></code></li>
<li><code><a title="mstruct.struct.dict2struct" href="#mstruct.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="mstruct.struct.disp" href="#mstruct.struct.disp">disp</a></code></li>
<li><code><a title="mstruct.struct.dispmax" href="#mstruct.struct.dispmax">dispmax</a></code></li>
<li><code><a title="mstruct.struct.format" href="#mstruct.struct.format">format</a></code></li>
<li><code><a title="mstruct.struct.format_array" href="#mstruct.struct.format_array">format_array</a></code></li>
<li><code><a title="mstruct.struct.format_legacy" href="#mstruct.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="mstruct.struct.fromkeys" href="#mstruct.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="mstruct.struct.fromkeysvalues" href="#mstruct.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="mstruct.struct.generator" href="#mstruct.struct.generator">generator</a></code></li>
<li><code><a title="mstruct.struct.getattr" href="#mstruct.struct.getattr">getattr</a></code></li>
<li><code><a title="mstruct.struct.hasattr" href="#mstruct.struct.hasattr">hasattr</a></code></li>
<li><code><a title="mstruct.struct.isdefined" href="#mstruct.struct.isdefined">isdefined</a></code></li>
<li><code><a title="mstruct.struct.isempty" href="#mstruct.struct.isempty">isempty</a></code></li>
<li><code><a title="mstruct.struct.isexpression" href="#mstruct.struct.isexpression">isexpression</a></code></li>
<li><code><a title="mstruct.struct.isstrdefined" href="#mstruct.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="mstruct.struct.isstrexpression" href="#mstruct.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="mstruct.struct.items" href="#mstruct.struct.items">items</a></code></li>
<li><code><a title="mstruct.struct.keys" href="#mstruct.struct.keys">keys</a></code></li>
<li><code><a title="mstruct.struct.keyssorted" href="#mstruct.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="mstruct.struct.read" href="#mstruct.struct.read">read</a></code></li>
<li><code><a title="mstruct.struct.scan" href="#mstruct.struct.scan">scan</a></code></li>
<li><code><a title="mstruct.struct.set" href="#mstruct.struct.set">set</a></code></li>
<li><code><a title="mstruct.struct.setattr" href="#mstruct.struct.setattr">setattr</a></code></li>
<li><code><a title="mstruct.struct.sortdefinitions" href="#mstruct.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="mstruct.struct.struct2dict" href="#mstruct.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="mstruct.struct.struct2param" href="#mstruct.struct.struct2param">struct2param</a></code></li>
<li><code><a title="mstruct.struct.update" href="#mstruct.struct.update">update</a></code></li>
<li><code><a title="mstruct.struct.values" href="#mstruct.struct.values">values</a></code></li>
<li><code><a title="mstruct.struct.write" href="#mstruct.struct.write">write</a></code></li>
<li><code><a title="mstruct.struct.zip" href="#mstruct.struct.zip">zip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>