<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>param_demo API documentation</title>
<meta name="description" content="Mathematical Notations and Capabilities in `param()`
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>param_demo</code></h1>
</header>
<section id="section-intro">
<h1 id="mathematical-notations-and-capabilities-in-param">Mathematical Notations and Capabilities in <code>param()</code></h1>
<p>The <code>param()</code> class extends the <code>struct</code> class and allows <strong>dynamic evaluation</strong> of expressions,
<strong>implicit calculations</strong>, and <strong>NumPy-style operations</strong>. Instances of this class are iterable and can be managed
using a Matlab-like syntax.</p>
<p><em>Note: Matlab inputs are also enabled as shorthands.</em></p>
<p>INRAE\olivier.vitrac@agroparistech.fr, rev. 2024-02-04</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# coding: utf-8
&#34;&#34;&#34;
Mathematical Notations and Capabilities in `param()`
=====================================================

The `param()` class extends the `struct` class and allows **dynamic evaluation** of expressions,
**implicit calculations**, and **NumPy-style operations**. Instances of this class are iterable and can be managed
using a Matlab-like syntax.

*Note: Matlab inputs are also enabled as shorthands.*

INRAE\olivier.vitrac@agroparistech.fr, rev. 2024-02-04

&#34;&#34;&#34;

#%% 
&#34;&#34;&#34;
Manage Dependencies
-------------------
It is mandatory to import NumPy as `np` (internal convention) if NumPy arrays are defined in strings.
The following snippet also shows how to check the current working directory (if needed):

    import os
    current_dir = os.getcwd()
    print(current_dir)
&#34;&#34;&#34;

import numpy as np
from pizza.private.mstruct import param

def prettyprint(var, value):
    &#34;&#34;&#34;Display the variable&#39;s name, its value, and its type after evaluation.&#34;&#34;&#34;
    print(f&#34;{var} = {value} (type: {type(value).__name__})&#34;)


&#34;&#34;&#34;
1. Overview
-----------
The `param()` class uses fields/attributes to store values and expressions. Fields define variables, which can be
accessed with the syntax `${var}`. For instance, if you create an instance as `p = param(var=value, ...)`, then:

- `p.var` returns the value of `${var}`.
- `p.var = value` assigns or changes the value.
- `p(&#34;var&#34;)` returns the evaluated value of `${var}` considering the current context.

Expressions are defined as strings. An expression can represent either a valid mathematical expression or an abstract
string used for templating. Unlike Python&#39;s built-in `eval()` function, the context determines whether the result is
numeric or remains a string. Vectorial calculus is enabled by using the shorthand `@{matrix}` instead of `${matrix}`.

Interpolation (substitution) and evaluation are performed in the following order:
- **Direct interpolation/substitution:** e.g., `&#34;the content of var is ${var}&#34;`.
- **Local evaluation with a text result:** e.g., `&#34;the sum of variables ${var1+var2}&#34;`, `&#34;the third value is ${var[2]}&#34;`,
  or `&#34;the sum is ${sum(var)}&#34;`.
- **Full evaluation with a numeric result:** e.g., `&#34;${var}&#34;`, `&#34;@{vector}.T&#34;`, or `&#34;@{matrix1} @ @{matrix2}&#34;`.
- **Mixed evaluation in a list:** e.g., `[&#34;var=${myvar}&#34;`, `&#34;sum=${mylist}&#34;`, `&#34;@{matrix1} @ @{matrix2}&#34;]`.

If a complete evaluation is not possible, the final result is stored with 4 significant digits by default (the precision
can be increased if needed).

Expressions must combine only operators (`+`, `*`, `**`, etc.), built-in functions (`sum`, `prod`, etc.), mathematical
functions (`sin`, `pi`, etc.), and NumPy functions (prefixed with `np.`) and operators (`@`, `.T`). Some statistics
functions are also available.

Variables can be defined as strings (e.g., `&#34;1.0&#34;`) or as numbers (`1.0` for float or int), and they can be scalar or
complex. When using text expressions, it is possible to define matrices and n-dimensional arrays using Matlab
(`$[1 2 3; 4 5 6]`), NumPy (`$[[1,2,3];[4,5,6]]`), or hybrid notations (`$[[1 2 3; 4 5 6],[7 8 9; 10 11 12]]`).
Theoretically, variables can be any Matlab type (including class instances), though in practice lists or NumPy
nd-arrays are recommended. Matlab and hybrid shorthands have been implemented for 1D vectors (row or column) up to 4D arrays,
including expansions (e.g., `&#34;$[1:10]&#34;` or `&#34;$[1:0.5:10]&#34;`).

⚠️ **Warning:** Variables are evaluated in the order they are defined; use the `paramauto()` class instead if the
order needs to be guessed or resolved. In contrast to Python f-strings where expressions are dynamically re-evaluated,
changing one field/variable in a `param` instance affects all others. Use the method `s = p.eval()` (or equivalently `s = p()`)
to convert a dynamic `param` instance into a static structure `s`.

If an error occurs during evaluation, the evaluated value is replaced by an error message.

Instances of `param` are iterable and can be managed as lists or collections (e.g., using `p[5]`, `p[1:10:2]`, `p[[0,3,8]]`).

Multiple `param` instances can be merged together using the `+` operator:
    
    pmerged = poriginal + pupdate
&#34;&#34;&#34;

#%%
&#34;&#34;&#34;
2. Define Variables
-------------------
- **Basic syntax:** Create an instance with `p = param()` and then define variables as:
  
      p.var = value
      p.var = &#34;value&#34;
      p.var = &#34;expression&#34;
  
- You can also initialize variables directly: `p = param(var1=..., var2=...)`.
- Accessing a variable: `p.var` or `getattr(p, &#34;var&#34;)` returns the raw value of `${var}`.
- To obtain a static structure, use `s = p()` or `s = p.eval()`.
- Evaluate specific variables with `p(&#34;var1&#34;, &#34;var2&#34;, ...)`.
- Prefix a string with `$` to designate it as a literal (i.e., not an expression).
- For debugging evaluation issues, use `p = param(debug=True)`.
- **Avoid** using a variable named `${e}` to prevent confusion with `exp(1)`.

**Literal expressions**

For legacy support, literal expressions can be defined either by:
- Adding the prefix `$` to the expression (e.g., `&#34;$ab&#34;`), or
- Placing the expression inside a list (e.g., `[&#34;ab&#34;]`).

The latest versions of `param()` can automatically detect literals that cannot be evaluated.
&#34;&#34;&#34;

&#34;&#34;&#34;
Literal Expressions Example
----------------------------
This example demonstrates how to use literal expressions with `param()`:
- `line1`: A raw string that escapes `${a}` to prevent substitution.
- `line2`: A list of strings.
- `line3`: A string that interpolates a value from `line2`.
- `ab`: A variable holding the literal `&#34;AB&#34;`.
- `line4`: A literal expression where the `$` prefix preserves the literal value of `ab`.
- `line5`: A plain string `&#34;ab&#34;`.
- `line6`: A string `&#34;sin(x)&#34;` that will not generate an error.
- `line7`: An expression `&#34;${sin(x)}&#34;` which will generate an error since `x` is not defined.

The evaluated static structure is obtained by calling `l()`.
&#34;&#34;&#34;

l = param()
l.line1 = r&#34;\${a}+1&#34;
l.line2 = [&#34;a&#34;, &#34;b&#34;]
l.line3 = &#39;The first letter in {line2} is &#34;${line2[0]}&#34;&#39;
l.ab = &#34;AB&#34;
l.line4 = &#34;$ab&#34;
l.line5 = &#34;ab&#34;
l.line6 = &#34;sin(x)&#34;         # This will not generate an error.
l.line7 = &#34;${sin(x)}&#34;       # This will generate an error since x is not defined.
print(&#39;The values of l:&#39;)
print(repr(l))
print(&#39;\nThe static content of l:&#39;)
s = l()  # Equivalent to s = l.eval()
s


#%%
&#34;&#34;&#34;
Numeric Examples
----------------
This example demonstrates basic numeric assignments:
- `p.a` is assigned the float `10.0`.
- `p.b` is assigned the string `&#34;10&#34;`, representing the number 10.
- `p.c` is assigned a literal string `&#34;$10&#34;` (thus it is not interpreted as a number).
- `p.d` is defined as a Python list of numbers.
- `p.f` is created by converting `p.d` into a NumPy array (as a row vector).
&#34;&#34;&#34;

p = param()
p.a = 10.0
p.b = &#34;10&#34;
p.c = &#34;$10&#34;
p.d = [1.0, 0.2, 0.03, 0.004]
p.f = np.array([p.d])


#%%
&#34;&#34;&#34;
3. Interpolation and Local Evaluation
---------------------------------------
This section demonstrates the interpolation and local evaluation capabilities:

- **Simple interpolation/substitution:** `${var}` is replaced by its content.
- **Mathematical expressions:** Expressions within `${}` are evaluated in place.
- **Local evaluation:** Supports scalars, lists, NumPy arrays, and expressions.
- **Indexing:** Use `${var[i]}` or `${var[I,j]}` to index into arrays or matrices.
- **Escaping:** Use `\${...}` to prevent execution of the interpolation.

**Supported Operations**
- Indexing of lists and arrays.
- Mathematical operations using operators like `+`, `-`, `*`, `/`.

**Supported Mathematical Functions**
- Built-in functions: `abs`, `round`, `min`, `max`, `sum`, `divmod`.
- Functions from the `math` module such as `pi`, `e`, `nan`, `inf`.
- NumPy functions (with the `np.` prefix) and operators such as `@` and `.T`.
- Statistics functions: `gauss`, `uniform`, `randint`, `choice`.
&#34;&#34;&#34;

&#34;&#34;&#34;
Scalar Evaluations Example
--------------------------
The following examples show scalar evaluations:
- `p.g` evaluates an expression that retrieves `d[1]` and adds `b`.
- `p.h` evaluates an expression combining an element from the NumPy array `f` and an element from `d`.
- `p.i` demonstrates that the notation `${d}[1] + ${b}` is equivalent to a global evaluation.
- `p.j` uses a similar pattern for matrix operations but mixing outer indexing is not recommended.

*Note: It is recommended not to mix global and local expressions (especially for indexing with NumPy arrays).*
&#34;&#34;&#34;

p.g = &#34;${d[1]}+${b}&#34;
p.h = &#34;${f[0,1]} + ${d[0]}&#34;
p.i = &#34;${d}[1]+${b}&#34;
p.j = &#34;${f}[0,1] + ${d}[0]&#34;
p  # Alternatively, use repr(p) to inspect the structure.

#%%
&#34;&#34;&#34;
Evaluation and Display of Scalar Evaluations
---------------------------------------------
The following code evaluates all expressions (using `p()`) and displays:
- The equivalence between inner and outer indexing for lists.
- The differences for NumPy arrays, where only the first value (`h`) is numeric.
- A warning to avoid using outer indexing outside of `${...}`.
&#34;&#34;&#34;

s = p()  # Equivalent to s = p.eval()
print(&#34;Inner and outer indexing are similar for list&#34;)
print(repr(p(&#34;g&#34;, &#34;i&#34;)))
print(&#39;All values are numeric (float)&#39;)
prettyprint(&#34;g&#34;, s.g)
prettyprint(&#34;i&#34;, s.i)
print(&#34;\nInner and outer indexing are not similar for NumPy arrays&#34;)
print(repr(p(&#34;h&#34;, &#34;j&#34;)))
print(&#34;Only the first value (h) is numeric&#34;)
prettyprint(&#34;h&#34;, s.h)
prettyprint(&#34;j&#34;, s.j)
print(&#39;Avoid using outer indexing; keep operations within &#34;${...}&#34;&#39;)


#%%
&#34;&#34;&#34;
List and Nested Evaluations
---------------------------
This section demonstrates that variables can hold multiple values and that results are stored in lists:

- In the following example, `q.units` is a literal string (with the `$` prefix).
- `q.a` is a list containing a literal string and another literal.
- `q.b` uses interpolation to reference `units`.
- `q.c` shows a string with both interpolation and an escaped placeholder.
&#34;&#34;&#34;

q = param()
q.units = &#34;$si&#34;
q.a = [&#34;units&#34;, &#34;$lj&#34;]
q.b = [&#34;units&#34;, &#34;${units}&#34;]
q.c = &#34;the ${a[0]} are ${units} as defined with \\${units}&#34;
q

#%%
&#34;&#34;&#34;
Text/Numeric Evaluation Example
-------------------------------
This example mixes text and numeric evaluations:
- `r.a` is a numeric list.
- `r.b` is provided as a string that represents a list with param expressions.
- `r.c` uses the `!` prefix to force recursive evaluation of expressions in lists.
- `r.d` and `r.e` combine expressions from other list entries.
- `r.f` is a list containing a mixture of expressions and literal values.
&#34;&#34;&#34;

r = param()
r.a = [0, 1, 2]
r.b = &#39;[1,2,&#34;test&#34;,&#34;${a[1]}&#34;]&#39;
r.c = &#39;![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]&#39;
r.d = &#34;${b[3]}*10&#34;
r.e = &#34;${c[3]}*10&#34;
r.f = [&#34;${a[1]+a[2]}*3&#34;, 1, 2, &#34;test&#34;, &#34;${a[1]}&#34;, &#34;${a[1]+a[2]}&#34;, &#34;${1+2}&#34;, &#34;b&#34;]
r

#%%
&#34;&#34;&#34;
Additional Numeric Example
--------------------------
This example defines a param instance `t` with parameters `o` and `p`. Then:
- `t.a` is constructed as a list containing `${o}` and `${p}`.
- `t.b` computes the sum of the elements in `a`.
- `t.c` calculates the maximum surface area using `pi` and the maximum value in `a`.
&#34;&#34;&#34;

t = param(o=10, p=100)
t.a = &#34;[${o},${p}]&#34;
t.b = &#34;the sum of a is ${sum(a)}&#34;
t.c = &#34;the maximum surface area is ${pi*max(a)**2}&#34;
t


#%%
&#34;&#34;&#34;
4. Mathematical Shorthands for Vectors, Matrices, 3D, and 4D Arrays
--------------------------------------------------------------------
Lists cannot be directly used as vectors and must be converted into NumPy arrays before performing vectorized operations.
The `param()` class offers several shorthands to seamlessly manipulate arrays using text expressions:

- **1D:** `$[1 2 3]` → `np.atleast_2d(np.array([1,2,3]))`
- **2D:** `$[[1 2],[3 4]]` → `np.array([[1,2],[3,4]])`
- **3D:** `$[[[1 2],[3 4]],[[5 6],[7 8]]]` → `np.array([[[1,2],[3,4]],[[5,6],[7,8]]])`
- **4D:** `$[[[[1 2]]]]` → `np.array([[[[1,2]]]])`

**Variable References:**
- `@{var}` is equivalent to `np.atleast_2d(np.array(${var}))`.

**Transpose:**
- Use `@{var}.T` to transpose.

**Function Application:**
- Apply a function to a vector with: `np.foo(@var)`.

**Slicing:**
- `${var[:,0]}` converts a slice into a list.
- `@{var}[:,0]` preserves the slice as a NumPy array.

**Matlab Notations Supported:**
- Automatic row vector expansion using `$[start:stop]` or `$[start:step:stop]`.
- Spaces can be used to separate values row-wise.
- Semicolons (`;`) separate rows.

**Examples:**
- `$[1, 2  ${var1} ; 4, 5  ${var2}]` is equivalent to `$[[1,2,${var1}],[4,5,${var2}]]`
- `$[1;2; 3]` becomes `$[[1],[2],[3]]`
- `[[-0.5, 0.5;-0.5, 0.5],[ -0.5,  0.5; -0.5,  0.5]]` becomes `$[[[-0.5,0.5],[-0.5,0.5]],[[-0.5,0.5],[-0.5,0.5]]]`
- `$[[1,2;3,4],[5,6; 7,8]]` becomes `$[[[1,2],[3,4]],[[5,6],[7,8]]]`
- `$[1, 2, 3; 4, 5, 6]` becomes `$[[1,2,3],[4,5,6]]`
&#34;&#34;&#34;

&#34;&#34;&#34;
Simple Definitions Example
--------------------------
This example demonstrates simple definitions using Matlab-style notations:
- `e.a` uses `$[1:3]` to create the vector `[1, 2, 3]`.
- `e.b` uses `$[1;2;3]` to create a column vector `[[1],[2],[3]]`.
- `e.c` uses `$[0.1:0.1:0.9]` to create the vector `[0.1, 0.2, ..., 0.9]`.
- `e.d` defines a 2D matrix with `$[1 2 3; 4 5 6]`.
&#34;&#34;&#34;

e = param()
e.a = &#34;$[1:3]&#34;
e.b = &#34;$[1;2;3]&#34;
e.c = &#34;$[0.1:0.1:0.9]&#34;
e.d = &#34;$[1 2 3; 4 5 6]&#34;
e

#%%
&#34;&#34;&#34;
Matrix Operations Example
-------------------------
This example illustrates simple matrix operations:
- `m.a` is a list of numeric values.
- `m.b` is a NumPy array created from `m.a` (as a row vector).
- `m.c` computes `m.a * 2` (element-wise multiplication for a list).
- `m.d` computes `m.b * 2` (element-wise multiplication for a NumPy array).
- `m.e` is the transpose of `m.b`.
- `m.f` performs matrix multiplication between the transpose of `m.b` and `m.b`.
- Variables `m.g` through `m.o` demonstrate various forms of expression evaluation, indexing, and string interpolation.
  - Note that `&#34;@{j}+1&#34;` and `&#34;${j}+1&#34;` do not have the same meaning.
- `m.p` uses a raw string (with the `r` prefix) to correctly escape `${a[0]}`.
&#34;&#34;&#34;

m = param()
m.a = [1.0, 0.2, 0.03, 0.004]
m.b = np.array([m.a])
m.c = m.a * 2
m.d = m.b * 2
m.e = m.b.T
m.f = m.b.T @ m.b  # Matrix multiplication: (3x1) @ (1x3)
m.g = &#34;${a[1]}&#34;
m.h = &#34;${b[0,1]} + ${a[0]}&#34;
m.i = &#34;${f[0,1]}&#34;
m.j = &#34;${f[:,1]}&#34;
m.k = &#34;@{j}+1&#34;  # Note: &#34;@{j}+1&#34; and &#34;${j}+1&#34; are not equivalent.
m.l = &#34;${b.T}&#34;  # `b` is already a NumPy array.
m.m = &#34;${b.T @ b}&#34;    # Full evaluation of the matrix multiplication.
m.n = &#34;${b.T} @ ${b}&#34;  # Concatenates two string results separated by &#39;@&#39;.
m.o = &#34;the result is: ${b[0,1]} + ${a[0]}&#34;
m.p = r&#34;the value of \${a[0]} is ${a[0]}&#34;
m


#%%
&#34;&#34;&#34;
Slicing Example
---------------
This example demonstrates slicing operations:
- `s.a` and `s.b` are scalar values.
- `s.c` creates a NumPy vector from an operation.
- `s.n` defines a vector using the `$` syntax.
- `s.o1` creates a copy of `n` using the `@{}` notation.
- `s.o2` creates a NumPy vector directly.
- `s.o3` performs multiplication between two vectors.
- `s.d` shows another multiplication example using a transpose.
- `s.f` uses an explicit NumPy operation.
- `s.nT` is the transpose of vector `n`.
- `s.m` attempts an illegal operation (it will be kept as a string).
- `s.o` shows the correct syntax for the operation.
- `s.p` defines a 2D NumPy array.
- `s.q` indexes the 2D array to retrieve an element.
- `s.r` slices the 2D array, returning a list.
- `s.s` applies an operation to the slice, preserving it as a NumPy array.
&#34;&#34;&#34;

s = param(debug=True)
s.a = 1.0
s.b = &#34;10.0&#34;
s.c = &#34;$[${a},2,3]*${b}&#34;
s.n = &#34;$[0,0,1]&#34;
s.o1 = &#34;@{n}&#34;
s.o2 = &#34;$[${a},2,3]&#34;
s.o3 = &#34;@{o1} @ @{o2}.T&#34;
s.d = &#34;@{n}.T @ $[[${a},2,3]]&#34;
s.f = &#34;($[${a},2,3]*${b}) @ ns.array([[0,0,1]]).T&#34;
s.nT = &#34;@{n}.T&#34;
s.m = &#34;${n.T}*2&#34;  # This illegal operation will be preserved as a string.
s.o = &#34;@{n}.T*2&#34;  # Correct syntax for the intended operation.
s.p = &#34;$[[1,2],[3,4]]&#34;
s.q = &#34;${p[1,1]}&#34;
s.r = &#34;${p[:,1]}&#34;
s.s = &#34;@{p}[:,1]+1&#34;
s


#%%
&#34;&#34;&#34;
Advanced Example
----------------
This advanced example demonstrates operations such as:
- Defining a vector `V1`.
- Computing `V2` as `V1 + 1`.
- Performing matrix multiplication between the transpose of `V1` and `V2`.
- Creating a diagonal matrix from the resulting product.
- Calculating the eigenvalues and eigenvectors of the resulting matrix.
- Displaying the first eigenvalue in a formatted string.
&#34;&#34;&#34;

a = param(debug=True)
a.V1 = &#34;$[1.0,0.2,0.03]&#34;
a.V2 = &#34;@{V1}+1&#34;
a.V3 = &#34;@{V1}.T @ @{V2}&#34;
a.V4 = &#34;np.diag(@{V3})&#34;
a.V5 = &#34;np.linalg.eig(@{V3})&#34;
a.out = &#34;the first eigenvalue is: ${V5.eigenvalues[0]}&#34;
a


#%%
&#34;&#34;&#34;
5. Global Evaluation
---------------------
A global evaluation is attempted for all expressions after interpolation and local evaluations have been performed.
If the global evaluation does not raise any error, the evaluated result is kept; otherwise, the original interpolated
expression is preserved. Since several expressions involving matrix operations require global evaluation (i.e., outside
of `${...}` or `@{...}`), it is recommended to define mathematically valid expressions and, if needed, use separate
variables to store results as text.
&#34;&#34;&#34;

&#34;&#34;&#34;
Global Evaluation Example with NumPy
-------------------------------------
This example demonstrates global evaluation:
- `u.p` creates a 2D NumPy array.
- `u.q` indexes the array to retrieve an element.
- `u.r` adds 1 to the second column of `p`.
- `u.s` reshapes a slice and performs matrix multiplication in a Matlab-like manner.
- `u.t` computes the eigenvalues and eigenvectors of the resulting matrix.
- `u.w` calculates the sum of the first two eigenvalues.
- `u.x` horizontally concatenates a literal with the sum of the eigenvalues.
&#34;&#34;&#34;

u = param(debug=True)
u.p = &#34;$[[1, 2], [3, 4]]&#34;
u.q = &#34;${p[1, 1]}&#34;
u.r = &#34;@{p}[:,1] + 1&#34;
u.s = &#34;@{p}[:, 1].reshape(-1, 1) @ @{r}&#34;
u.t = &#34;np.linalg.eig(@{s})&#34;
u.w = &#34;${t.eigenvalues[0]} + ${t.eigenvalues[1]}&#34;
u.x = &#34;$[[0,${t.eigenvalues[0]}+${t.eigenvalues[1]}]]&#34;
u


#%%
&#34;&#34;&#34;
Global Evaluation Example with Various Matrix Operations
----------------------------------------------------------
This example demonstrates various matrix operations:
- A list `l` is defined.
- Vectors and matrices (`a`, `b`, `c`) are created using Matlab-style notations.
- Element-wise and matrix operations are performed.
- More complex structures (`x0`, `y0`, `z0`) are defined using multiple operations.
- Finally, the results are flattened into vectors `X0`, `Y0`, and `Z0`.
&#34;&#34;&#34;

v = param()
v.l = [1e-3, 2e-3, 3e-3]
v.a = &#34;$[1 2 3]&#34;
v.b = &#34;$[1:3]&#34;
v.c = &#34;$[0.1:0.1:0.9]&#34;
v.scale = &#34;@{l}*2*@{a}&#34;
v.x0 = &#34;$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*${scale[0,0]}*${a[0,0]}&#34;
v.y0 = &#34;$[[[-0.5, -0.5],[0.5, 0.5]],[[ -0.5,  -0.5],[ 0.5,  0.5]]]*${scale[0,1]}*${a[0,1]}&#34;
v.z0 = &#34;$[[-0.5 0.5 ;-0.5 0.5],[ -0.5,  0.5;  -0.5,  0.5]]*${l[2]}*${a[0,2]}&#34;
v.X0 = &#34;@{x0}.flatten()&#34;
v.Y0 = &#34;@{y0}.flatten()&#34;
v.Z0 = &#34;@{z0}.flatten()&#34;
v</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="param_demo.prettyprint"><code class="name flex">
<span>def <span class="ident">prettyprint</span></span>(<span>var, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the variable's name, its value, and its type after evaluation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prettyprint(var, value):
    &#34;&#34;&#34;Display the variable&#39;s name, its value, and its type after evaluation.&#34;&#34;&#34;
    print(f&#34;{var} = {value} (type: {type(value).__name__})&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#mathematical-notations-and-capabilities-in-param">Mathematical Notations and Capabilities in param()</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="param_demo.prettyprint" href="#param_demo.prettyprint">prettyprint</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>