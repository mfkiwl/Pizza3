<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dscript API documentation</title>
<meta name="description" content="PIZZA.DSCRIPT Module Documentation
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dscript</code></h1>
</header>
<section id="section-intro">
<p>================================================================================
PIZZA.DSCRIPT Module Documentation
================================================================================</p>
<p>The <strong>PIZZA.DSCRIPT</strong> module is a versatile tool for dynamically generating and managing
<strong>pizza.scripts</strong>, especially in conjunction with <strong>LAMMPS</strong> (Large-scale Atomic/Molecular
Massively Parallel Simulator). This module provides powerful features to create complex,
parameterized scripts, manage multiple sections, and flexibly concatenate scripts to form
pipelines. It offers advanced control over script execution and generation.</p>
<h2 id="overview">Overview:</h2>
<ul>
<li><strong>pizza.script</strong>: Use this to define reusable codelets or scriptlets stored in maintainable libraries.</li>
<li><strong>pizza.dscript</strong>: Use this to dynamically generate codelets or scriptlets directly in your code,
allowing for flexible, runtime script generation.</li>
</ul>
<p>The output of <code>pizza.dscript.script()</code> is a complete script instance, similar to a standard pizza.script.
These scripts can be managed like any pizza.script, allowing you to combine them using the <code>+</code> or <code>|</code>
operators and integrate them into <strong>pizza.pipescripts</strong> for building complex, multi-step workflows.</p>
<p>Scripts/scriptlets piped with the operator "|" (pipe) are called pipescripts and are indexed with their
own variable space (static/global/local). Dscript objects preserve only some of these features with two
levels only (global/local).</p>
<h2 id="update-pizza-10">UPDATE Pizza 1.0</h2>
<p>Starting with Pizza 1.0, <code>pizza.pipescript</code> (P) and <code>pizza.dscript</code> (D) objects are fully interoperable, and one
can be converted converted into the other using pipescript.dscript() and discript.piperscript(). P objects are
automatacally generated as soon as P and D objects are combined. P objects manage dynamically forcefields and
interactions between paticles/beads whereas D objects manage them statically (fixed script). D objects must be
preferred to save to disk a script with zero-Python code. The format used is simular to the one used for forcefields
(see pizza.forcefield).</p>
<p>A previous script saved as a file can be reused dynamically, see example:</p>
<pre><code class="language-Python">    previoussteps = dscript.load(dscriptfilename)
    beadtype = previoussteps.search(&quot;ID&quot;,previoussteps.list_values(&quot;ID&quot;),&quot;beadtype&quot;)
</code></pre>
<p>A common interface list_values() enables to explore (text, graphics) the variables in scope (static/global/local).
D objects have a specific method D.var_info(details=True) and D.print_var_info(what=&hellip;) to track eventual
bugs.</p>
<h2 id="key-features">Key Features:</h2>
<ol>
<li><strong>Dynamic Script Generation</strong>:</li>
<li>
<p><code>pizza.dscript</code> allows for the generation of scripts dynamically within your code. This means that codelets
and scriptlets can be constructed at runtime, offering flexibility in handling complex scenarios.</p>
</li>
<li>
<p><strong>Combining Scripts</strong>:</p>
</li>
<li>
<p>The generated scripts can be combined using operators like <code>+</code> or <code>|</code>, enabling you to merge multiple
script sections seamlessly. This is especially useful for creating modular scripts that can be
reused across different contexts or experiments.</p>
</li>
<li>
<p><strong>Saving and Loading Scripts</strong>:</p>
</li>
<li>
<p><code>pizza.dscript.save()</code> and <code>pizza.dscript.load()</code> enable you to save and load complex scripts as text templates,
independent of both Python and LAMMPS. This functionality allows for the deployment of sophisticated scripts
without requiring the full script class libraries (commonly referred to as "workshops" in Pizza3).</p>
</li>
<li>
<p><strong>Leveraging AI for Rapid Template Generation</strong>:</p>
</li>
<li>
<p>You can even leverage Large Language Models (LLMs) to generate templates quickly. This feature allows for
automation and faster script generation, particularly useful for deploying templated workflows or codelets.</p>
</li>
<li>
<p><strong>Non-linear Execution</strong>:</p>
</li>
<li>It's important to note that <strong>pizza.scripts</strong> and <strong>pizza.dscripts</strong> are not directly equivalent to LAMMPS code.
They can be executed statically and non-linearly, without needing LAMMPS to be involved. This makes the
framework particularly useful when managing large LAMMPS simulations that span multiple submodules.</li>
</ol>
<h2 id="applications">Applications:</h2>
<p>The <strong>PIZZA.DSCRIPT</strong> module is particularly useful when you need to:
- <strong>Dynamically create and manage LAMMPS script sections</strong>.
- <strong>Merge, manipulate, and execute multiple script sections</strong> with predefined or user-defined variables.
- <strong>Generate scripts with conditional sections and custom execution logic</strong>, enabling the handling of complex simulations
and workflows.</p>
<p>The modular nature of <code>pizza.dscript</code> makes it well-suited for scenarios where you need to reuse various submodules of
LAMMPS code or mix them with pure Python logic for more advanced control.</p>
<h2 id="key-classes">Key Classes:</h2>
<ul>
<li>
<p><strong><code><a title="dscript.lambdaScriptdata" href="#dscript.lambdaScriptdata">lambdaScriptdata</a></code></strong>: Holds parameters and definitions for script execution. This class encapsulates the data and
logic needed for the dynamic generation of script elements.</p>
</li>
<li>
<p><strong><code>lambdaScript</code></strong>: Wraps a <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object to generate a <code>pizza.script instance</code> from its contents. This class
is essential for converting dynamically generated <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> objects into reusable, executable script instances.</p>
</li>
<li>
<p><strong><code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code></strong>: Manages and stores multiple script lines/items as <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> objects, supporting dynamic execution
and the concatenation of script sections. The <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> class allows for flexible script construction and execution,
making it a core component for generating dynamic LAMMPS scripts.</p>
</li>
</ul>
<h2 id="notes">Notes:</h2>
<ul>
<li><strong>Script Composition</strong>: Generated scripts can span several submodules, allowing for the reuse of script components
in different contexts. This feature enables a modular approach to script generation.</li>
<li><strong>Execution Flexibility</strong>: Since <code>pizza.dscript</code> scripts are not bound to LAMMPS directly, they can be executed
independently, making them highly flexible for preprocessing, debugging, or running custom logic within a
LAMMPS-related workflow.</li>
</ul>
<h2 id="important-distinction-between-pizzadscript-and-pizzascript-with-possible-evolution-in-the-future">Important Distinction between <strong>PIZZA.DSCRIPT</strong> and <strong>PIZZA.SCRIPT</strong>: (with possible evolution in the future)</h2>
<ul>
<li><strong>PIZZA.DSCRIPT</strong> stores the DEFINITIONS in lambdaScriptdata objects based on pizza.private.mstruct.paramauto
The practical consequence is that all variables should be within {} such as ${variable}.
The definitions will be redordered to authorize execution</li>
<li><strong>PIZZA.SCRIPT</strong> stores the DEFINITIONS in Scriptdata objects based on pizza.private.mstruct.param
The variables can be $myvar or ${myvar}. The definition order is important.</li>
</ul>
<h2 id="practical-usage">Practical Usage:</h2>
<ul>
<li>Scripts can be combined dynamically.</li>
<li>Variables in script templates are handled automatically, allowing flexible script execution.</li>
<li>Concatenate multiple scripts, with automatic merging and non-overwriting of variables.</li>
</ul>
<p>The concept of TEMPLATING is managed via shorthands</p>
<p>from dscript import dscript</p>
<pre><code>    ```python
    # Create a dscript instance
    S = dscript(name="MyScript")

    # Define script sections
    S[0] = "instruction 1"
    S[1] = "${var1} + ${var2}"

    # Set definitions
    S.DEFINITIONS.var1 = "1"
    S.DEFINITIONS.var2 = "2"

    # Enable evaluation
    S[1].eval = True

    # Generate the script
    result = S.do()
    print(result)

    # convert it into pizza.script
    s=S.script()
    rs = s.do()
    print(rs)
    ```
</code></pre>
<p>Chat GPT teaching instructions:
Copy and paste these instructions to teach chatGPT how to convert in LAMMPS code in pizza.dscript()
-----------------------------[ start here ]--------------------------------------------------</p>
<h1 id="dscript-save-file-format-instructions">DSCRIPT SAVE FILE Format Instructions:</h1>
<p>Each DSCRIPT file begins with the line <code># DSCRIPT SAVE FILE</code>. The file is divided into sections: Global Parameters, Definitions, Template, and Attributes.
1. Global Parameters Section: Enclosed in <code>{}</code> and contains key-value pairs where values can be integers, floats, strings, booleans, or lists. Example:</p>
<pre><code># GLOBAL PARAMETERS
{
    SECTIONS = ['SECTION1', 'SECTION2'],
    section = 0,
    position = 0,
    role = &quot;dscript instance&quot;,
    description = &quot;A description&quot;,
    userid = &quot;dscript&quot;,
    version = 0.1,
    verbose = False
}
</code></pre>
<ol>
<li>Definitions Section: Defines variables as key-value pairs, which can reference other variables using <code>${}</code>. Example:</li>
</ol>
<pre><code># DEFINITIONS (number of definitions=X)
var1 = value1
var2 = &quot;${var1}&quot;
</code></pre>
<ol>
<li>Template Section: Contains key-value pairs for blocks of script content. Single-line content is written as <code>key: value</code>. Multi-line content is enclosed in square brackets <code>[]</code>. Example:</li>
</ol>
<pre><code># TEMPLATE (number of lines=X)
block1: command using ${var1}
block2: [
    multi-line command 1
    multi-line command 2
]
</code></pre>
<ol>
<li>Attributes Section: Optional attributes are attached to each block as key-value pairs inside curly braces <code>{}</code>. Example:</li>
</ol>
<pre><code># ATTRIBUTES (number of lines with explicit attributes=X)
block1: {facultative=True, eval=True}
</code></pre>
<p>Definitions can be dynamically substituted into the templates using <code>${}</code> notation, and the parser should handle both single-line and multi-line templates.</p>
<pre><code>-----------------------------[ end here ]--------------------------------------------------



================================================================================
Production Example: Dynamic LAMMPS Script Generation Using `dscript` and `script`
================================================================================

This example illustrates how to dynamically generate and manage LAMMPS scripts
using the `dscript` and `script` classes. The goal is to demonstrate the flexibility
of these classes in handling script sections, overriding parameters, and generating
a script with conditions and dynamic content.

Overview:
---------
    In this example, we:
    - Define global `DEFINITIONS` that hold script parameters.
    - Create a script template with multiple lines/items, each identified by a unique key.
    - Add conditions to script lines/items to control their inclusion based on the state of variables.
    - Overwrite `DEFINITIONS` at runtime to customize the script's behavior.
    - Generate and execute the script using the `do()` method.

Key Classes Used:
-----------------
    - `dscript`: Manages multiple script lines and their dynamic execution.
    - `lamdaScript`: Wraps a `dscript` object to generate a script instance from its contents.

Practical Steps:
----------------
    1. Initialize a `dscript` object and define global variables (DEFINITIONS).
    2. Create script lines/items using keys to identify each line.
    3. Apply conditions to script lines/items to control their execution.
    4. Overwrite or add new variables to `DEFINITIONS` at runtime.
    5. Generate the final script using `lamdaScript` and execute it.

Example:
--------
    # Initialize the dscript object
    R = dscript(name=&quot;ProductionExample&quot;)

    # Define global variables (DEFINITIONS)
    R.DEFINITIONS.dimension = 3
    R.DEFINITIONS.units = &quot;$si&quot;
    R.DEFINITIONS.boundary = [&quot;sm&quot;,&quot;sm&quot;,&quot;sm&quot;]
    R.DEFINITIONS.atom_style = &quot;$smd&quot;
    R.DEFINITIONS.atom_modify = [&quot;map&quot;,&quot;array&quot;]
    R.DEFINITIONS.comm_modify = [&quot;vel&quot;,&quot;yes&quot;]
    R.DEFINITIONS.neigh_modify = [&quot;every&quot;,10,&quot;delay&quot;,0,&quot;check&quot;,&quot;yes&quot;]
    R.DEFINITIONS.newton = &quot;$off&quot;

    # Define the script template, with each line identified by a key
    R[0]        = &quot;% ${comment}&quot;
    R[&quot;dim&quot;]    = &quot;dimension    ${dimension}&quot;  # Line identified as 'dim'
    R[&quot;unit&quot;]   = &quot;units        ${units}&quot;      # Line identified as 'unit'
    R[&quot;bound&quot;]  = &quot;boundary     ${boundary}&quot;
    R[&quot;astyle&quot;] = &quot;atom_style   ${atom_style}&quot;
    R[&quot;amod&quot;]   = &quot;atom_modify  ${atom_modify}&quot;
    R[&quot;cmod&quot;]   = &quot;comm_modify  ${comm_modify}&quot;
    R[&quot;nmod&quot;]   = &quot;neigh_modify ${neigh_modify}&quot;
    R[&quot;newton&quot;] = &quot;newton       ${newton}&quot;

    # Apply a condition to the 'astyle' line; it will only be included if ${atom_style} is defined
    R[&quot;astyle&quot;].condition = &quot;${atom_style}&quot;

    # Revise the DEFINITIONS, making ${atom_style} undefined
    R.DEFINITIONS.atom_style = &quot;&quot;

    # Generate a script instance, overwriting the 'units' variable and adding a comment
    sR = R.script(units=&quot;$lj&quot;,  # Use &quot;$&quot; to prevent immediate evaluation
                  comment=&quot;$my first dynamic script&quot;)

    # Execute the script to get the final content
    ssR = sR.do()

    # Print the generated script as text
    print(ssR)

    # Save your script
    R.save(&quot;myscript.txt&quot;)

    # Load again your script
    Rcopy = dsave.load(&quot;myscript.txt&quot;)

More Compact Example:
---------------------
    # Initialization
    R2 = dscript(name=&quot;ProductionExample2&quot;)
    # Define global variables (DEFINITIONS) for the script
    R2.DEFINITIONS.dimension = 3
    R2.DEFINITIONS.units = &quot;$si&quot;
    R2.DEFINITIONS.boundary = [&quot;sm&quot;, &quot;sm&quot;, &quot;sm&quot;]
    R2.DEFINITIONS.atom_modify = [&quot;map&quot;, &quot;array&quot;]
    R2.DEFINITIONS.comm_modify = [&quot;vel&quot;, &quot;yes&quot;]
    R2.DEFINITIONS.neigh_modify = [&quot;every&quot;, 10, &quot;delay&quot;, 0, &quot;check&quot;, &quot;yes&quot;]
    R2.DEFINITIONS.newton = &quot;$off&quot;
    R2.DEFINITIONS.atom_style = &quot;$smd&quot;
    # Define the script template with a multiple line syntax
    R2[&quot;code&quot;] = &quot;&quot; &quot;
        % ${comment}
        dimension    ${dimension}
        units        ${units}
        boundary     ${boundary}
        atom_style   ${atom_style}
        atom_modify  ${atom_modify}
        comm_modify  ${comm_modify}
        neigh_modify ${neigh_modify}
        newton       ${newton}
    &quot;&quot; &quot;
    # Generate a script instance, overwriting the 'units' variable and adding a comment
    sR2 = R2.script(comment=&quot;$my first compact dscript&quot;)
    ssR2 = sR2.do()
    # Print the generated script
    print(ssR2)

Expected Output:
----------------
    Depending on the conditions and overwritten variables, the output script should
    reflect the updated `DEFINITIONS` and the conditionally included lines.

For instance:
    - The line for `atom_style` will be omitted because `atom_style` is undefined.
    - The script will include the custom units and comment specified at runtime.


Some Comments:
--------------
    pizza.dscript does not not require the definition of modules, submodules and so on.
    For comparison, pizza.script requires managing directly classes

    Usage Example
    -------------
    ```python
    from pizza.script import script

    class scriptexample(script):
        description = &quot;demonstrate commutativity of additions&quot;
        verbose = True

        DEFINITIONS = scriptdata(
            X = 10,
            Y = 20,
            R1 = &quot;${X}+${Y}&quot;,
            R2 = &quot;${Y}+${X}&quot;
        )
        TEMPLATE = &quot;&quot; &quot;
        # Property of the addition
        ${R1} = ${X} + ${Y}
        ${R2} = ${Y} + ${X}
        &quot;&quot; &quot;

    s1 = scriptexample()
    s1.do()
    ```


Load and Save features:
-----------------------
use dscript.load() and dscript.save() methods


DSCRIPT SAVE FILE Syntax:
--------------------------

A DSCRIPT SAVE FILE is a text-based representation of script instances that are dynamically loaded or saved. It consists of key sections that define global parameters, variables (definitions), script templates, and attributes. The file format is structured and flexible, allowing both minimal and extended configurations depending on the level of detail required.

### Minimal DSCRIPT File
A minimal DSCRIPT SAVE FILE includes the template section, which defines the script's core structure. The template assigns content to variables, which can then be dynamically evaluated and modified during script execution.

Example of a minimal DSCRIPT SAVE FILE:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# DSCRIPT SAVE FILE

0: % ${comment}
dim: dimension    ${dimension}
unit: units        ${units}
bound: boundary     ${boundary}
astyle: atom_style   ${atom_style}
amod: atom_modify  ${atom_modify}
cmod: comm_modify  ${comm_modify}
nmod: neigh_modify ${neigh_modify}
newton: newton       ${newton}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Example of a compact DSCRIPT SAVE FILE:
    Note the position of the []
    Use % to keep comments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# DSCRIPT SAVE FILE

mytemplate: [
    % ${comment}
    dimension    ${dimension}
    units        ${units}
    boundary     ${boundary}
    atom_style   ${atom_style}
    atom_modify  ${atom_modify}
    comm_modify  ${comm_modify}
    neigh_modify ${neigh_modify}
    newton       ${newton}
    ]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- **Required header**: The file must start with the line `# DSCRIPT SAVE FILE`. This is mandatory and serves to authenticate the file as a valid DSCRIPT file.
- **Template section**: Each line contains a variable key followed by the content. Variables (e.g., `${dimension}`) are placeholders that will be replaced during script execution. The format is `key: content`, where `key` is a unique identifier and `content` represents the script logic.

### Extended DSCRIPT File
An extended DSCRIPT file includes additional sections such as global parameters, definitions, templates, and attributes. These provide more control and flexibility over script behavior and configuration.

    Example of an extended DSCRIPT SAVE FILE:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # DSCRIPT SAVE FILE
    # generated on 20XX-XX-XX on user@localhost

    #   name = &quot;ProductionExample&quot;
    #   path = &quot;/your/path/ProductionExample.txt&quot;

    # GLOBAL PARAMETERS
    {
        SECTIONS = ['DYNAMIC'],
        section = 0,
        position = 0,
        role = 'dscript instance',
        description = 'dynamic script',
        userid = 'dscript',
        version = 0.1,
        verbose = False
    }

    # DEFINITIONS (number of definitions=9)
    dimension=3
    units=$si
    boundary=['sm', 'sm', 'sm']
    atom_style=&quot;&quot;
    atom_modify=['map', 'array']
    comm_modify=['vel', 'yes']
    neigh_modify=['every', 10, 'delay', 0, 'check', 'yes']
    newton=$off
    comment=${comment}

    # TEMPLATE (number of lines=9)
    0: % ${comment}
    dim: dimension    ${dimension}
    unit: units        ${units}
    bound: boundary     ${boundary}
    astyle: atom_style   ${atom_style}
    amod: atom_modify  ${atom_modify}
    cmod: comm_modify  ${comm_modify}
    nmod: neigh_modify ${neigh_modify}
    newton: newton       ${newton}

    # ATTRIBUTES (number of lines with explicit attributes=9)
    0:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    dim:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    unit:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    bound:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    astyle:{facultative=False, eval=False, readonly=False, condition='${atom_style}', condeval=False, detectvar=True}
    amod:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    cmod:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    nmod:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    newton:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Detailed Explanation of &quot;DSCRIPT SAVE FILE&quot; Sections:
1. **Global Parameters**:
   - Defined between `{...}` and describe the overall configuration of the script.
   - Common parameters include `SECTIONS`, `section`, `position`, `role`, `description`, `userid`, `version`, and `verbose`.
   - These parameters help control the behavior and structure of the script instance.

2. **Definitions**:
   - The `DEFINITIONS` section lists key-value pairs, where each key is a variable, and its value can be any valid Python data type (e.g., integers, strings, lists).
   - Example: `dimension=3`, `units=$si`, `boundary=['sm', 'sm', 'sm']`.
   - Variables starting with a `$` (e.g., `$si`) are typically placeholders or dynamic variables.

3. **Template**:
   - The `TEMPLATE` section defines the actual content of the script. Each line is in the format `key: content`, where `key` is a unique identifier, and `content` includes placeholders for variables (e.g., `${dimension}`).
   - Example: `dim: dimension    ${dimension}`.
   - The template is where variables from the `DEFINITIONS` section are substituted dynamically.

4. **Attributes**:
   - The `ATTRIBUTES` section defines the properties of each template entry. Each line associates a key with a dictionary of attributes (e.g., `facultative`, `eval`, `readonly`).
   - Example: `astyle:{facultative=False, eval=False, readonly=False, condition='${atom_style}', condeval=False, detectvar=True}`.
   - The attributes control how each template line behaves (e.g., whether it's evaluated, whether it depends on a condition, etc.).

### Adding Comments:
- Comments are added by starting a line with `#`. Comments can appear anywhere in the file, and they will be ignored during the loading process.
- Example:
    ```
    # This is a comment
    dim: dimension    ${dimension}  # Another comment
    ```
- Comments are typically used for documentation purposes within the DSCRIPT file, such as describing sections or explaining template logic.

### Imperative Components:
- **Header**: The line `# DSCRIPT SAVE FILE` must be present at the beginning of the file. It authenticates the file as a valid DSCRIPT file.
- **Template**: At least one template entry must be defined, as the template represents the main script content.

### Accessory Components:
- **Variable Substitution**: Variables (e.g., `${dimension}`) must be defined in the `DEFINITIONS` section to be substituted dynamically in the template content.
- **Attributes (Optional)**: Attributes are optional but provide more control over the template behavior when specified.
readonly=False, condition=None, condeval=False, detectvar=True}.

### Flexible structure
- **Global Parameters** can be defined anywhere but in a single block
- **Template** and **Attributes** lines can be mixed together.


Production example (using last features)
------------------
```python
mydscriptfile = '''
            # GLOBAL DEFINITIONS (number of definitions=4)
            dumpfile = $dump.LAMMPS
            dumpdt = 50
            thermodt = 100
            runtime = 5000


            # TEMPLATES (number of items=24)

            # LOCAL DEFINITIONS for key '0'
            dimension = 3
            units = $si
            boundary = ['f', 'f', 'f']
            atom_style = $smd
            atom_modify = ['map', 'array']
            comm_modify = ['vel', 'yes']
            neigh_modify = ['every', 10, 'delay', 0, 'check', 'yes']
            newton = $off
            name = $SimulationBox

            0: [
                % --------------[ Initialization Header (helper) for &quot;${name}&quot;   ]--------------
                # set a parameter to None or &quot;&quot; to remove the definition
                dimension    ${dimension}
                units        ${units}
                boundary     ${boundary}
                atom_style   ${atom_style}
                atom_modify  ${atom_modify}
                comm_modify  ${comm_modify}
                neigh_modify ${neigh_modify}
                newton       ${newton}
                # ------------------------------------------
             ]

            # LOCAL DEFINITIONS for key '1'
            lattice_style = $sc
            lattice_scale = 0.0008271
            lattice_spacing = [0.0008271, 0.0008271, 0.0008271]

            1: [
                % --------------[ LatticeHeader 'helper' for &quot;${name}&quot;   ]--------------
                lattice ${lattice_style} ${lattice_scale} spacing ${lattice_spacing}
                # ------------------------------------------
             ]

            # LOCAL DEFINITIONS for key '2'
            xmin = -0.03
            xmax = 0.03
            ymin = -0.01
            ymax = 0.01
            zmin = -0.03
            zmax = 0.03
            nbeads = 3

            2: [
                % --------------[ Box Header 'helper' for &quot;${name}&quot;   ]--------------
                region box block ${xmin} ${xmax} ${ymin} ${ymax} ${zmin} ${zmax}
                create_box      ${nbeads} box
                # ------------------------------------------
             ]

            # LOCAL DEFINITIONS for key '3'
            ID = $LowerCylinder
            style = $cylinder

            3: % variables to be used for ${ID} ${style}             ]

            # LOCAL DEFINITIONS for key '4'
            ID = $CentralCylinder

            4: % variables to be used for ${ID} ${style}

            # LOCAL DEFINITIONS for key '5'
            ID = $UpperCylinder

            5: % variables to be used for ${ID} ${style}

            # LOCAL DEFINITIONS for key '6'
            args = ['z', 0.0, 0.0, 36.27130939426913, 0.0, 6.045218232378189]
            side = &quot;&quot;
            move = &quot;&quot;
            rotate = &quot;&quot;
            open = &quot;&quot;
            ID = $LowerCylinder
            units = &quot;&quot;

            6: [
                % Create region ${ID} ${style} args ...  (URL: https://docs.lammps.org/region.html)
                # keywords: side, units, move, rotate, open
                # values: in|out, lattice|box, v_x v_y v_z, v_theta Px Py Pz Rx Ry Rz, integer
                region ${ID} ${style} ${args} ${side}${units}${move}${rotate}${open}
             ]

            # LOCAL DEFINITIONS for key '7'
            ID = $CentralCylinder
            args = ['z', 0.0, 0.0, 36.27130939426913, 6.045218232378189, 18.135654697134566]

            7: [
                % Create region ${ID} ${style} args ...  (URL: https://docs.lammps.org/region.html)
                # keywords: side, units, move, rotate, open
                # values: in|out, lattice|box, v_x v_y v_z, v_theta Px Py Pz Rx Ry Rz, integer
                region ${ID} ${style} ${args} ${side}${units}${move}${rotate}${open}
             ]

            # LOCAL DEFINITIONS for key '8'
            ID = $UpperCylinder
            args = ['z', 0.0, 0.0, 36.27130939426913, 18.135654697134566, 24.180872929512756]

            8: [
                % Create region ${ID} ${style} args ...  (URL: https://docs.lammps.org/region.html)
                # keywords: side, units, move, rotate, open
                # values: in|out, lattice|box, v_x v_y v_z, v_theta Px Py Pz Rx Ry Rz, integer
                region ${ID} ${style} ${args} ${side}${units}${move}${rotate}${open}
             ]

            # LOCAL DEFINITIONS for key '9'
            ID = $LowerCylinder
            beadtype = 1

            9: [
                % Create atoms of type ${beadtype} for ${ID} ${style} (https://docs.lammps.org/create_atoms.html)
                create_atoms ${beadtype} region ${ID}
             ]

            # LOCAL DEFINITIONS for key '10'
            ID = $CentralCylinder
            beadtype = 2

            10: [
                % Create atoms of type ${beadtype} for ${ID} ${style} (https://docs.lammps.org/create_atoms.html)
                create_atoms ${beadtype} region ${ID}
             ]

            # LOCAL DEFINITIONS for key '11'
            ID = $UpperCylinder
            beadtype = 3

            11: [
                % Create atoms of type ${beadtype} for ${ID} ${style} (https://docs.lammps.org/create_atoms.html)
                create_atoms ${beadtype} region ${ID}
             ]

            12: [
                # ===== [ BEGIN GROUP SECTION ] =====================================================================================
                group    lower  type     1
                group    solid  type     1 2 3
                group    fixed  type     1
                group    middle         type     2
                group    movable        type     2 3
                group    upper  type     3

                # ===== [ END GROUP SECTION ] =======================================================================================


                # [1:b1] PAIR STYLE SMD
                pair_style      hybrid/overlay smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION &amp;
                smd/tlsph smd/hertz 1.5

                # [1:b1 x 1:b1] Diagonal pair coefficient tlsph
                pair_coeff      1 1 smd/tlsph *COMMON 1000 10000.0 0.3 1.0 2.0 10.0 1000.0 &amp;
                *STRENGTH_LINEAR_PLASTIC 1000.0 0 &amp;
                *EOS_LINEAR &amp;
                *END

                # [2:b2 x 2:b2] Diagonal pair coefficient tlsph
                pair_coeff      2 2 smd/tlsph *COMMON 1000 5000.0 0.3 1.0 2.0 10.0 1000.0 &amp;
                *STRENGTH_LINEAR_PLASTIC 500.0 0 &amp;
                *EOS_LINEAR &amp;
                *END

                # [3:b3 x 3:b3] Diagonal pair coefficient tlsph
                pair_coeff      3 3 smd/tlsph *COMMON 1000 40000.0 0.3 1.0 2.0 10.0 1000.0 &amp;
                *STRENGTH_LINEAR_PLASTIC 4000.0 0 &amp;
                *EOS_LINEAR &amp;
                *END

                # [1:b1 x 2:b2] Off-diagonal pair coefficient (generic)
                pair_coeff      1 2 smd/hertz 250.0000000000001

                # [1:b1 x 3:b3] Off-diagonal pair coefficient (generic)
                pair_coeff      1 3 smd/hertz 250.0000000000001

                # [2:b2 x 3:b3] Off-diagonal pair coefficient (generic)
                pair_coeff      2 3 smd/hertz 125.00000000000003

                # ===== [ END FORCEFIELD SECTION ] ==================================================================================
             ]

            13: [
                group all union lower middle upper
                group external subtract all middle
             ]

            14: velocity all set 0.0 0.0 0.0 units box
            15: fix fix_lower lower setforce 0.0 0.0 0.0
            16: fix move_upper upper move wiggle 0.0 0.0 ${amplitude} ${period} units box
            17: fix dtfix tlsph smd/adjust_dt ${dt}
            18: fix integration_fix tlsph smd/integrate_tlsph

            19: [
                compute S all smd/tlsph_stress
                compute E all smd/tlsph_strain
                compute nn all smd/tlsph_num_neighs
             ]

            20: [
                dump dump_id all custom ${dumpdt} ${dumpfile} id type x y z vx vy vz &amp;
                c_S[1] c_S[2] c_S[4] c_nn &amp;
                c_E[1] c_E[2] c_E[4] &amp;
                vx vy vz
             ]

            21: dump_modify dump_id first yes

            22: [
                thermo ${thermodt}
                thermo_style custom step dt f_dtfix v_strain
             ]

            23: run ${runtime}
        '''
mydscript = dscript.parsesyntax(mydscriptfile,verbose=False,authentification=False)
mydscript[-1].definitions.runtime = 1000 # change local definitions of $runtime at the last step
print(mydscript.do(verbose=True))
</code></pre>
<p>Note that mydscript[-1].runtime = 1000 would have created the attribute runtime. Use definitions instead.</p>
<h2 id="printreprmydscript-1-gives-all-details">print(repr(mydscript[-1])) gives all details</h2>
<h2 id="template-content-id23-1-line-31-defs-all-variables-have-be-created-also-locally">Template Content | id:23
(1 line, 31 defs)
&lt;&mdash; all variables have be created also locally</h2>
<h2 id="run-runtime">run ${runtime}</h2>
<h2 id="detected-variable-1-1-0">Detected Variable
(1 / +1 / -0)</h2>
<h2 id="runtime-this-runtime-is-a-variable">[+] runtime
&lt;&mdash; this runtime is a variable</h2>
<h2 id="template-attributes-7-attributes">Template Attributes
(7 attributes)</h2>
<p>[ ] facultativ
[x] eval
[ ] readonly
[ ] condition
[ ] condeval
[x] detectvar
[x] runtime
&lt;&mdash; this runtime is an attribute</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li>Python 3.x</li>
<li>LAMMPS</li>
<li>Pizza3.pizza</li>
</ul>
<h2 id="installation">Installation</h2>
<p>To use the Pizza3.pizza module, ensure that you have Python 3.x and LAMMPS installed. You can integrate the module into your project by placing the <code>region.py</code> file in your working directory or your Python path.</p>
<h2 id="license">License</h2>
<p>This project is licensed under the terms of the GPLv3 license.</p>
<h2 id="contact">Contact</h2>
<p>For any queries or contributions, please contact the maintainer:
- Olivier Vitrac, Han Chen
- Email: olivier.vitrac@agroparistech.fr</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
================================================================================
PIZZA.DSCRIPT Module Documentation
================================================================================

The **PIZZA.DSCRIPT** module is a versatile tool for dynamically generating and managing
**pizza.scripts**, especially in conjunction with **LAMMPS** (Large-scale Atomic/Molecular
Massively Parallel Simulator). This module provides powerful features to create complex,
parameterized scripts, manage multiple sections, and flexibly concatenate scripts to form
pipelines. It offers advanced control over script execution and generation.

Overview:
---------
- **pizza.script**: Use this to define reusable codelets or scriptlets stored in maintainable libraries.
- **pizza.dscript**: Use this to dynamically generate codelets or scriptlets directly in your code,
   allowing for flexible, runtime script generation.

The output of `pizza.dscript.script()` is a complete script instance, similar to a standard pizza.script.
These scripts can be managed like any pizza.script, allowing you to combine them using the `+` or `|`
operators and integrate them into **pizza.pipescripts** for building complex, multi-step workflows.

Scripts/scriptlets piped with the operator &#34;|&#34; (pipe) are called pipescripts and are indexed with their
own variable space (static/global/local). Dscript objects preserve only some of these features with two
levels only (global/local).

UPDATE Pizza 1.0
-----------------
Starting with Pizza 1.0, `pizza.pipescript` (P) and `pizza.dscript` (D) objects are fully interoperable, and one
can be converted converted into the other using pipescript.dscript() and discript.piperscript(). P objects are
automatacally generated as soon as P and D objects are combined. P objects manage dynamically forcefields and
interactions between paticles/beads whereas D objects manage them statically (fixed script). D objects must be
preferred to save to disk a script with zero-Python code. The format used is simular to the one used for forcefields
(see pizza.forcefield).

A previous script saved as a file can be reused dynamically, see example:
```Python
    previoussteps = dscript.load(dscriptfilename)
    beadtype = previoussteps.search(&#34;ID&#34;,previoussteps.list_values(&#34;ID&#34;),&#34;beadtype&#34;)
```

A common interface list_values() enables to explore (text, graphics) the variables in scope (static/global/local).
D objects have a specific method D.var_info(details=True) and D.print_var_info(what=...) to track eventual
bugs.

Key Features:
-------------
1. **Dynamic Script Generation**:
   - `pizza.dscript` allows for the generation of scripts dynamically within your code. This means that codelets
     and scriptlets can be constructed at runtime, offering flexibility in handling complex scenarios.

2. **Combining Scripts**:
   - The generated scripts can be combined using operators like `+` or `|`, enabling you to merge multiple
     script sections seamlessly. This is especially useful for creating modular scripts that can be
     reused across different contexts or experiments.

3. **Saving and Loading Scripts**:
   - `pizza.dscript.save()` and `pizza.dscript.load()` enable you to save and load complex scripts as text templates,
     independent of both Python and LAMMPS. This functionality allows for the deployment of sophisticated scripts
     without requiring the full script class libraries (commonly referred to as &#34;workshops&#34; in Pizza3).

4. **Leveraging AI for Rapid Template Generation**:
   - You can even leverage Large Language Models (LLMs) to generate templates quickly. This feature allows for
     automation and faster script generation, particularly useful for deploying templated workflows or codelets.

5. **Non-linear Execution**:
   - It&#39;s important to note that **pizza.scripts** and **pizza.dscripts** are not directly equivalent to LAMMPS code.
     They can be executed statically and non-linearly, without needing LAMMPS to be involved. This makes the
     framework particularly useful when managing large LAMMPS simulations that span multiple submodules.

Applications:
-------------
The **PIZZA.DSCRIPT** module is particularly useful when you need to:
- **Dynamically create and manage LAMMPS script sections**.
- **Merge, manipulate, and execute multiple script sections** with predefined or user-defined variables.
- **Generate scripts with conditional sections and custom execution logic**, enabling the handling of complex simulations
  and workflows.

The modular nature of `pizza.dscript` makes it well-suited for scenarios where you need to reuse various submodules of
LAMMPS code or mix them with pure Python logic for more advanced control.

Key Classes:
------------
- **`lambdaScriptdata`**: Holds parameters and definitions for script execution. This class encapsulates the data and
  logic needed for the dynamic generation of script elements.

- **`lambdaScript`**: Wraps a `dscript` object to generate a `pizza.script instance` from its contents. This class
  is essential for converting dynamically generated `dscript` objects into reusable, executable script instances.

- **`dscript`**: Manages and stores multiple script lines/items as `ScriptTemplate` objects, supporting dynamic execution
  and the concatenation of script sections. The `dscript` class allows for flexible script construction and execution,
  making it a core component for generating dynamic LAMMPS scripts.

Notes:
------
- **Script Composition**: Generated scripts can span several submodules, allowing for the reuse of script components
  in different contexts. This feature enables a modular approach to script generation.
- **Execution Flexibility**: Since `pizza.dscript` scripts are not bound to LAMMPS directly, they can be executed
  independently, making them highly flexible for preprocessing, debugging, or running custom logic within a
  LAMMPS-related workflow.

Important Distinction between **PIZZA.DSCRIPT** and **PIZZA.SCRIPT**: (with possible evolution in the future)
---------------------------------------------------------------------
- **PIZZA.DSCRIPT** stores the DEFINITIONS in lambdaScriptdata objects based on pizza.private.mstruct.paramauto
  The practical consequence is that all variables should be within {} such as ${variable}.
  The definitions will be redordered to authorize execution
- **PIZZA.SCRIPT** stores the DEFINITIONS in Scriptdata objects based on pizza.private.mstruct.param
  The variables can be $myvar or ${myvar}. The definition order is important.


Practical Usage:
----------------
- Scripts can be combined dynamically.
- Variables in script templates are handled automatically, allowing flexible script execution.
- Concatenate multiple scripts, with automatic merging and non-overwriting of variables.

The concept of TEMPLATING is managed via shorthands

from dscript import dscript

        ```python
        # Create a dscript instance
        S = dscript(name=&#34;MyScript&#34;)

        # Define script sections
        S[0] = &#34;instruction 1&#34;
        S[1] = &#34;${var1} + ${var2}&#34;

        # Set definitions
        S.DEFINITIONS.var1 = &#34;1&#34;
        S.DEFINITIONS.var2 = &#34;2&#34;

        # Enable evaluation
        S[1].eval = True

        # Generate the script
        result = S.do()
        print(result)

        # convert it into pizza.script
        s=S.script()
        rs = s.do()
        print(rs)
        ```


Chat GPT teaching instructions:
Copy and paste these instructions to teach chatGPT how to convert in LAMMPS code in pizza.dscript()
-----------------------------[ start here ]--------------------------------------------------
# DSCRIPT SAVE FILE Format Instructions:
Each DSCRIPT file begins with the line `# DSCRIPT SAVE FILE`. The file is divided into sections: Global Parameters, Definitions, Template, and Attributes.
1. Global Parameters Section: Enclosed in `{}` and contains key-value pairs where values can be integers, floats, strings, booleans, or lists. Example:
```
# GLOBAL PARAMETERS
{
    SECTIONS = [&#39;SECTION1&#39;, &#39;SECTION2&#39;],
    section = 0,
    position = 0,
    role = &#34;dscript instance&#34;,
    description = &#34;A description&#34;,
    userid = &#34;dscript&#34;,
    version = 0.1,
    verbose = False
}
```
2. Definitions Section: Defines variables as key-value pairs, which can reference other variables using `${}`. Example:
```
# DEFINITIONS (number of definitions=X)
var1 = value1
var2 = &#34;${var1}&#34;
```
3. Template Section: Contains key-value pairs for blocks of script content. Single-line content is written as `key: value`. Multi-line content is enclosed in square brackets `[]`. Example:
```
# TEMPLATE (number of lines=X)
block1: command using ${var1}
block2: [
    multi-line command 1
    multi-line command 2
]
```
4. Attributes Section: Optional attributes are attached to each block as key-value pairs inside curly braces `{}`. Example:
```
# ATTRIBUTES (number of lines with explicit attributes=X)
block1: {facultative=True, eval=True}
```
Definitions can be dynamically substituted into the templates using `${}` notation, and the parser should handle both single-line and multi-line templates.
```
-----------------------------[ end here ]--------------------------------------------------



================================================================================
Production Example: Dynamic LAMMPS Script Generation Using `dscript` and `script`
================================================================================

This example illustrates how to dynamically generate and manage LAMMPS scripts
using the `dscript` and `script` classes. The goal is to demonstrate the flexibility
of these classes in handling script sections, overriding parameters, and generating
a script with conditions and dynamic content.

Overview:
---------
    In this example, we:
    - Define global `DEFINITIONS` that hold script parameters.
    - Create a script template with multiple lines/items, each identified by a unique key.
    - Add conditions to script lines/items to control their inclusion based on the state of variables.
    - Overwrite `DEFINITIONS` at runtime to customize the script&#39;s behavior.
    - Generate and execute the script using the `do()` method.

Key Classes Used:
-----------------
    - `dscript`: Manages multiple script lines and their dynamic execution.
    - `lamdaScript`: Wraps a `dscript` object to generate a script instance from its contents.

Practical Steps:
----------------
    1. Initialize a `dscript` object and define global variables (DEFINITIONS).
    2. Create script lines/items using keys to identify each line.
    3. Apply conditions to script lines/items to control their execution.
    4. Overwrite or add new variables to `DEFINITIONS` at runtime.
    5. Generate the final script using `lamdaScript` and execute it.

Example:
--------
    # Initialize the dscript object
    R = dscript(name=&#34;ProductionExample&#34;)

    # Define global variables (DEFINITIONS)
    R.DEFINITIONS.dimension = 3
    R.DEFINITIONS.units = &#34;$si&#34;
    R.DEFINITIONS.boundary = [&#34;sm&#34;,&#34;sm&#34;,&#34;sm&#34;]
    R.DEFINITIONS.atom_style = &#34;$smd&#34;
    R.DEFINITIONS.atom_modify = [&#34;map&#34;,&#34;array&#34;]
    R.DEFINITIONS.comm_modify = [&#34;vel&#34;,&#34;yes&#34;]
    R.DEFINITIONS.neigh_modify = [&#34;every&#34;,10,&#34;delay&#34;,0,&#34;check&#34;,&#34;yes&#34;]
    R.DEFINITIONS.newton = &#34;$off&#34;

    # Define the script template, with each line identified by a key
    R[0]        = &#34;% ${comment}&#34;
    R[&#34;dim&#34;]    = &#34;dimension    ${dimension}&#34;  # Line identified as &#39;dim&#39;
    R[&#34;unit&#34;]   = &#34;units        ${units}&#34;      # Line identified as &#39;unit&#39;
    R[&#34;bound&#34;]  = &#34;boundary     ${boundary}&#34;
    R[&#34;astyle&#34;] = &#34;atom_style   ${atom_style}&#34;
    R[&#34;amod&#34;]   = &#34;atom_modify  ${atom_modify}&#34;
    R[&#34;cmod&#34;]   = &#34;comm_modify  ${comm_modify}&#34;
    R[&#34;nmod&#34;]   = &#34;neigh_modify ${neigh_modify}&#34;
    R[&#34;newton&#34;] = &#34;newton       ${newton}&#34;

    # Apply a condition to the &#39;astyle&#39; line; it will only be included if ${atom_style} is defined
    R[&#34;astyle&#34;].condition = &#34;${atom_style}&#34;

    # Revise the DEFINITIONS, making ${atom_style} undefined
    R.DEFINITIONS.atom_style = &#34;&#34;

    # Generate a script instance, overwriting the &#39;units&#39; variable and adding a comment
    sR = R.script(units=&#34;$lj&#34;,  # Use &#34;$&#34; to prevent immediate evaluation
                  comment=&#34;$my first dynamic script&#34;)

    # Execute the script to get the final content
    ssR = sR.do()

    # Print the generated script as text
    print(ssR)

    # Save your script
    R.save(&#34;myscript.txt&#34;)

    # Load again your script
    Rcopy = dsave.load(&#34;myscript.txt&#34;)

More Compact Example:
---------------------
    # Initialization
    R2 = dscript(name=&#34;ProductionExample2&#34;)
    # Define global variables (DEFINITIONS) for the script
    R2.DEFINITIONS.dimension = 3
    R2.DEFINITIONS.units = &#34;$si&#34;
    R2.DEFINITIONS.boundary = [&#34;sm&#34;, &#34;sm&#34;, &#34;sm&#34;]
    R2.DEFINITIONS.atom_modify = [&#34;map&#34;, &#34;array&#34;]
    R2.DEFINITIONS.comm_modify = [&#34;vel&#34;, &#34;yes&#34;]
    R2.DEFINITIONS.neigh_modify = [&#34;every&#34;, 10, &#34;delay&#34;, 0, &#34;check&#34;, &#34;yes&#34;]
    R2.DEFINITIONS.newton = &#34;$off&#34;
    R2.DEFINITIONS.atom_style = &#34;$smd&#34;
    # Define the script template with a multiple line syntax
    R2[&#34;code&#34;] = &#34;&#34; &#34;
        % ${comment}
        dimension    ${dimension}
        units        ${units}
        boundary     ${boundary}
        atom_style   ${atom_style}
        atom_modify  ${atom_modify}
        comm_modify  ${comm_modify}
        neigh_modify ${neigh_modify}
        newton       ${newton}
    &#34;&#34; &#34;
    # Generate a script instance, overwriting the &#39;units&#39; variable and adding a comment
    sR2 = R2.script(comment=&#34;$my first compact dscript&#34;)
    ssR2 = sR2.do()
    # Print the generated script
    print(ssR2)

Expected Output:
----------------
    Depending on the conditions and overwritten variables, the output script should
    reflect the updated `DEFINITIONS` and the conditionally included lines.

For instance:
    - The line for `atom_style` will be omitted because `atom_style` is undefined.
    - The script will include the custom units and comment specified at runtime.


Some Comments:
--------------
    pizza.dscript does not not require the definition of modules, submodules and so on.
    For comparison, pizza.script requires managing directly classes

    Usage Example
    -------------
    ```python
    from pizza.script import script

    class scriptexample(script):
        description = &#34;demonstrate commutativity of additions&#34;
        verbose = True

        DEFINITIONS = scriptdata(
            X = 10,
            Y = 20,
            R1 = &#34;${X}+${Y}&#34;,
            R2 = &#34;${Y}+${X}&#34;
        )
        TEMPLATE = &#34;&#34; &#34;
        # Property of the addition
        ${R1} = ${X} + ${Y}
        ${R2} = ${Y} + ${X}
        &#34;&#34; &#34;

    s1 = scriptexample()
    s1.do()
    ```


Load and Save features:
-----------------------
use dscript.load() and dscript.save() methods


DSCRIPT SAVE FILE Syntax:
--------------------------

A DSCRIPT SAVE FILE is a text-based representation of script instances that are dynamically loaded or saved. It consists of key sections that define global parameters, variables (definitions), script templates, and attributes. The file format is structured and flexible, allowing both minimal and extended configurations depending on the level of detail required.

### Minimal DSCRIPT File
A minimal DSCRIPT SAVE FILE includes the template section, which defines the script&#39;s core structure. The template assigns content to variables, which can then be dynamically evaluated and modified during script execution.

Example of a minimal DSCRIPT SAVE FILE:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# DSCRIPT SAVE FILE

0: % ${comment}
dim: dimension    ${dimension}
unit: units        ${units}
bound: boundary     ${boundary}
astyle: atom_style   ${atom_style}
amod: atom_modify  ${atom_modify}
cmod: comm_modify  ${comm_modify}
nmod: neigh_modify ${neigh_modify}
newton: newton       ${newton}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Example of a compact DSCRIPT SAVE FILE:
    Note the position of the []
    Use % to keep comments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# DSCRIPT SAVE FILE

mytemplate: [
    % ${comment}
    dimension    ${dimension}
    units        ${units}
    boundary     ${boundary}
    atom_style   ${atom_style}
    atom_modify  ${atom_modify}
    comm_modify  ${comm_modify}
    neigh_modify ${neigh_modify}
    newton       ${newton}
    ]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- **Required header**: The file must start with the line `# DSCRIPT SAVE FILE`. This is mandatory and serves to authenticate the file as a valid DSCRIPT file.
- **Template section**: Each line contains a variable key followed by the content. Variables (e.g., `${dimension}`) are placeholders that will be replaced during script execution. The format is `key: content`, where `key` is a unique identifier and `content` represents the script logic.

### Extended DSCRIPT File
An extended DSCRIPT file includes additional sections such as global parameters, definitions, templates, and attributes. These provide more control and flexibility over script behavior and configuration.

    Example of an extended DSCRIPT SAVE FILE:
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # DSCRIPT SAVE FILE
    # generated on 20XX-XX-XX on user@localhost

    #   name = &#34;ProductionExample&#34;
    #   path = &#34;/your/path/ProductionExample.txt&#34;

    # GLOBAL PARAMETERS
    {
        SECTIONS = [&#39;DYNAMIC&#39;],
        section = 0,
        position = 0,
        role = &#39;dscript instance&#39;,
        description = &#39;dynamic script&#39;,
        userid = &#39;dscript&#39;,
        version = 0.1,
        verbose = False
    }

    # DEFINITIONS (number of definitions=9)
    dimension=3
    units=$si
    boundary=[&#39;sm&#39;, &#39;sm&#39;, &#39;sm&#39;]
    atom_style=&#34;&#34;
    atom_modify=[&#39;map&#39;, &#39;array&#39;]
    comm_modify=[&#39;vel&#39;, &#39;yes&#39;]
    neigh_modify=[&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
    newton=$off
    comment=${comment}

    # TEMPLATE (number of lines=9)
    0: % ${comment}
    dim: dimension    ${dimension}
    unit: units        ${units}
    bound: boundary     ${boundary}
    astyle: atom_style   ${atom_style}
    amod: atom_modify  ${atom_modify}
    cmod: comm_modify  ${comm_modify}
    nmod: neigh_modify ${neigh_modify}
    newton: newton       ${newton}

    # ATTRIBUTES (number of lines with explicit attributes=9)
    0:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    dim:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    unit:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    bound:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    astyle:{facultative=False, eval=False, readonly=False, condition=&#39;${atom_style}&#39;, condeval=False, detectvar=True}
    amod:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    cmod:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    nmod:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    newton:{facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Detailed Explanation of &#34;DSCRIPT SAVE FILE&#34; Sections:
1. **Global Parameters**:
   - Defined between `{...}` and describe the overall configuration of the script.
   - Common parameters include `SECTIONS`, `section`, `position`, `role`, `description`, `userid`, `version`, and `verbose`.
   - These parameters help control the behavior and structure of the script instance.

2. **Definitions**:
   - The `DEFINITIONS` section lists key-value pairs, where each key is a variable, and its value can be any valid Python data type (e.g., integers, strings, lists).
   - Example: `dimension=3`, `units=$si`, `boundary=[&#39;sm&#39;, &#39;sm&#39;, &#39;sm&#39;]`.
   - Variables starting with a `$` (e.g., `$si`) are typically placeholders or dynamic variables.

3. **Template**:
   - The `TEMPLATE` section defines the actual content of the script. Each line is in the format `key: content`, where `key` is a unique identifier, and `content` includes placeholders for variables (e.g., `${dimension}`).
   - Example: `dim: dimension    ${dimension}`.
   - The template is where variables from the `DEFINITIONS` section are substituted dynamically.

4. **Attributes**:
   - The `ATTRIBUTES` section defines the properties of each template entry. Each line associates a key with a dictionary of attributes (e.g., `facultative`, `eval`, `readonly`).
   - Example: `astyle:{facultative=False, eval=False, readonly=False, condition=&#39;${atom_style}&#39;, condeval=False, detectvar=True}`.
   - The attributes control how each template line behaves (e.g., whether it&#39;s evaluated, whether it depends on a condition, etc.).

### Adding Comments:
- Comments are added by starting a line with `#`. Comments can appear anywhere in the file, and they will be ignored during the loading process.
- Example:
    ```
    # This is a comment
    dim: dimension    ${dimension}  # Another comment
    ```
- Comments are typically used for documentation purposes within the DSCRIPT file, such as describing sections or explaining template logic.

### Imperative Components:
- **Header**: The line `# DSCRIPT SAVE FILE` must be present at the beginning of the file. It authenticates the file as a valid DSCRIPT file.
- **Template**: At least one template entry must be defined, as the template represents the main script content.

### Accessory Components:
- **Variable Substitution**: Variables (e.g., `${dimension}`) must be defined in the `DEFINITIONS` section to be substituted dynamically in the template content.
- **Attributes (Optional)**: Attributes are optional but provide more control over the template behavior when specified.
readonly=False, condition=None, condeval=False, detectvar=True}.

### Flexible structure
- **Global Parameters** can be defined anywhere but in a single block
- **Template** and **Attributes** lines can be mixed together.


Production example (using last features)
------------------
```python
mydscriptfile = &#39;&#39;&#39;
            # GLOBAL DEFINITIONS (number of definitions=4)
            dumpfile = $dump.LAMMPS
            dumpdt = 50
            thermodt = 100
            runtime = 5000


            # TEMPLATES (number of items=24)

            # LOCAL DEFINITIONS for key &#39;0&#39;
            dimension = 3
            units = $si
            boundary = [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
            atom_style = $smd
            atom_modify = [&#39;map&#39;, &#39;array&#39;]
            comm_modify = [&#39;vel&#39;, &#39;yes&#39;]
            neigh_modify = [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
            newton = $off
            name = $SimulationBox

            0: [
                % --------------[ Initialization Header (helper) for &#34;${name}&#34;   ]--------------
                # set a parameter to None or &#34;&#34; to remove the definition
                dimension    ${dimension}
                units        ${units}
                boundary     ${boundary}
                atom_style   ${atom_style}
                atom_modify  ${atom_modify}
                comm_modify  ${comm_modify}
                neigh_modify ${neigh_modify}
                newton       ${newton}
                # ------------------------------------------
             ]

            # LOCAL DEFINITIONS for key &#39;1&#39;
            lattice_style = $sc
            lattice_scale = 0.0008271
            lattice_spacing = [0.0008271, 0.0008271, 0.0008271]

            1: [
                % --------------[ LatticeHeader &#39;helper&#39; for &#34;${name}&#34;   ]--------------
                lattice ${lattice_style} ${lattice_scale} spacing ${lattice_spacing}
                # ------------------------------------------
             ]

            # LOCAL DEFINITIONS for key &#39;2&#39;
            xmin = -0.03
            xmax = 0.03
            ymin = -0.01
            ymax = 0.01
            zmin = -0.03
            zmax = 0.03
            nbeads = 3

            2: [
                % --------------[ Box Header &#39;helper&#39; for &#34;${name}&#34;   ]--------------
                region box block ${xmin} ${xmax} ${ymin} ${ymax} ${zmin} ${zmax}
                create_box      ${nbeads} box
                # ------------------------------------------
             ]

            # LOCAL DEFINITIONS for key &#39;3&#39;
            ID = $LowerCylinder
            style = $cylinder

            3: % variables to be used for ${ID} ${style}             ]

            # LOCAL DEFINITIONS for key &#39;4&#39;
            ID = $CentralCylinder

            4: % variables to be used for ${ID} ${style}

            # LOCAL DEFINITIONS for key &#39;5&#39;
            ID = $UpperCylinder

            5: % variables to be used for ${ID} ${style}

            # LOCAL DEFINITIONS for key &#39;6&#39;
            args = [&#39;z&#39;, 0.0, 0.0, 36.27130939426913, 0.0, 6.045218232378189]
            side = &#34;&#34;
            move = &#34;&#34;
            rotate = &#34;&#34;
            open = &#34;&#34;
            ID = $LowerCylinder
            units = &#34;&#34;

            6: [
                % Create region ${ID} ${style} args ...  (URL: https://docs.lammps.org/region.html)
                # keywords: side, units, move, rotate, open
                # values: in|out, lattice|box, v_x v_y v_z, v_theta Px Py Pz Rx Ry Rz, integer
                region ${ID} ${style} ${args} ${side}${units}${move}${rotate}${open}
             ]

            # LOCAL DEFINITIONS for key &#39;7&#39;
            ID = $CentralCylinder
            args = [&#39;z&#39;, 0.0, 0.0, 36.27130939426913, 6.045218232378189, 18.135654697134566]

            7: [
                % Create region ${ID} ${style} args ...  (URL: https://docs.lammps.org/region.html)
                # keywords: side, units, move, rotate, open
                # values: in|out, lattice|box, v_x v_y v_z, v_theta Px Py Pz Rx Ry Rz, integer
                region ${ID} ${style} ${args} ${side}${units}${move}${rotate}${open}
             ]

            # LOCAL DEFINITIONS for key &#39;8&#39;
            ID = $UpperCylinder
            args = [&#39;z&#39;, 0.0, 0.0, 36.27130939426913, 18.135654697134566, 24.180872929512756]

            8: [
                % Create region ${ID} ${style} args ...  (URL: https://docs.lammps.org/region.html)
                # keywords: side, units, move, rotate, open
                # values: in|out, lattice|box, v_x v_y v_z, v_theta Px Py Pz Rx Ry Rz, integer
                region ${ID} ${style} ${args} ${side}${units}${move}${rotate}${open}
             ]

            # LOCAL DEFINITIONS for key &#39;9&#39;
            ID = $LowerCylinder
            beadtype = 1

            9: [
                % Create atoms of type ${beadtype} for ${ID} ${style} (https://docs.lammps.org/create_atoms.html)
                create_atoms ${beadtype} region ${ID}
             ]

            # LOCAL DEFINITIONS for key &#39;10&#39;
            ID = $CentralCylinder
            beadtype = 2

            10: [
                % Create atoms of type ${beadtype} for ${ID} ${style} (https://docs.lammps.org/create_atoms.html)
                create_atoms ${beadtype} region ${ID}
             ]

            # LOCAL DEFINITIONS for key &#39;11&#39;
            ID = $UpperCylinder
            beadtype = 3

            11: [
                % Create atoms of type ${beadtype} for ${ID} ${style} (https://docs.lammps.org/create_atoms.html)
                create_atoms ${beadtype} region ${ID}
             ]

            12: [
                # ===== [ BEGIN GROUP SECTION ] =====================================================================================
                group    lower  type     1
                group    solid  type     1 2 3
                group    fixed  type     1
                group    middle         type     2
                group    movable        type     2 3
                group    upper  type     3

                # ===== [ END GROUP SECTION ] =======================================================================================


                # [1:b1] PAIR STYLE SMD
                pair_style      hybrid/overlay smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION &amp;
                smd/tlsph smd/hertz 1.5

                # [1:b1 x 1:b1] Diagonal pair coefficient tlsph
                pair_coeff      1 1 smd/tlsph *COMMON 1000 10000.0 0.3 1.0 2.0 10.0 1000.0 &amp;
                *STRENGTH_LINEAR_PLASTIC 1000.0 0 &amp;
                *EOS_LINEAR &amp;
                *END

                # [2:b2 x 2:b2] Diagonal pair coefficient tlsph
                pair_coeff      2 2 smd/tlsph *COMMON 1000 5000.0 0.3 1.0 2.0 10.0 1000.0 &amp;
                *STRENGTH_LINEAR_PLASTIC 500.0 0 &amp;
                *EOS_LINEAR &amp;
                *END

                # [3:b3 x 3:b3] Diagonal pair coefficient tlsph
                pair_coeff      3 3 smd/tlsph *COMMON 1000 40000.0 0.3 1.0 2.0 10.0 1000.0 &amp;
                *STRENGTH_LINEAR_PLASTIC 4000.0 0 &amp;
                *EOS_LINEAR &amp;
                *END

                # [1:b1 x 2:b2] Off-diagonal pair coefficient (generic)
                pair_coeff      1 2 smd/hertz 250.0000000000001

                # [1:b1 x 3:b3] Off-diagonal pair coefficient (generic)
                pair_coeff      1 3 smd/hertz 250.0000000000001

                # [2:b2 x 3:b3] Off-diagonal pair coefficient (generic)
                pair_coeff      2 3 smd/hertz 125.00000000000003

                # ===== [ END FORCEFIELD SECTION ] ==================================================================================
             ]

            13: [
                group all union lower middle upper
                group external subtract all middle
             ]

            14: velocity all set 0.0 0.0 0.0 units box
            15: fix fix_lower lower setforce 0.0 0.0 0.0
            16: fix move_upper upper move wiggle 0.0 0.0 ${amplitude} ${period} units box
            17: fix dtfix tlsph smd/adjust_dt ${dt}
            18: fix integration_fix tlsph smd/integrate_tlsph

            19: [
                compute S all smd/tlsph_stress
                compute E all smd/tlsph_strain
                compute nn all smd/tlsph_num_neighs
             ]

            20: [
                dump dump_id all custom ${dumpdt} ${dumpfile} id type x y z vx vy vz &amp;
                c_S[1] c_S[2] c_S[4] c_nn &amp;
                c_E[1] c_E[2] c_E[4] &amp;
                vx vy vz
             ]

            21: dump_modify dump_id first yes

            22: [
                thermo ${thermodt}
                thermo_style custom step dt f_dtfix v_strain
             ]

            23: run ${runtime}
        &#39;&#39;&#39;
mydscript = dscript.parsesyntax(mydscriptfile,verbose=False,authentification=False)
mydscript[-1].definitions.runtime = 1000 # change local definitions of $runtime at the last step
print(mydscript.do(verbose=True))
```

Note that mydscript[-1].runtime = 1000 would have created the attribute runtime. Use definitions instead.

print(repr(mydscript[-1])) gives all details
--------------------------------------------------
Template Content | id:23        (1 line, 31 defs)   &lt;--- all variables have be created also locally
--------------------------------------------------
run ${runtime}
--------------------------------------------------
Detected Variable                  (1 / +1 / -0)
--------------------------------------------------
[+] runtime                                         &lt;--- this runtime is a variable
--------------------------------------------------
Template Attributes                (7 attributes)
--------------------------------------------------
[ ] facultativ   [x] eval         [ ] readonly
[ ] condition    [ ] condeval     [x] detectvar
[x] runtime                                        &lt;--- this runtime is an attribute


Dependencies
------------
- Python 3.x
- LAMMPS
- Pizza3.pizza

Installation
------------
To use the Pizza3.pizza module, ensure that you have Python 3.x and LAMMPS installed. You can integrate the module into your project by placing the `region.py` file in your working directory or your Python path.

License
-------
This project is licensed under the terms of the GPLv3 license.

Contact
-------
For any queries or contributions, please contact the maintainer:
- Olivier Vitrac, Han Chen
- Email: olivier.vitrac@agroparistech.fr

&#34;&#34;&#34;

__project__ = &#34;Pizza3&#34;
__author__ = &#34;Olivier Vitrac, Han Chen, Joseph Fine&#34;
__copyright__ = &#34;Copyright 2024&#34;
__credits__ = [&#34;Olivier Vitrac&#34;, &#34;Han Chen&#34;, &#34;Joseph Fine&#34;]
__license__ = &#34;GPLv3&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;1.0&#34;



# INRAE\Olivier Vitrac - rev. 2025-01-07 (community)
# contact: olivier.vitrac@agroparistech.fr, han.chen@inrae.fr

# Revision history
# 2024-09-02 alpha version (compatibility issues with pizza.script)
# 2024-09-03 release candidate (fully compatible with pizza.script)
# 2024-09-04 load() and save() methods, improved documentation
# 2024-09-05 several fixes, add dscript.write(), dscript.parsesyntax()
# 2024-09-06 finalization of the block syntax between [], and its examples + documentation
# 2024-10-07 fix example
# 2024-10-09 remove_comments moved to script (to prevent circular reference)
# 2024-10-14 finalization of the integration with scripts
# 2024-10-17 fix __add__, improve repr()
# 2024-10-18 add add_dynamic_script() helper for adding a step to a dscript
# 2024-10-19 better file management
# 2024-10-22 sophistication of ScriptTemplate to recognize defined variables at construction and to parse flags/conditions
# 2024-10-24 management of locl definitions in dscript.save() and dscript.parsesyntax()
# 2024-10-27 caching ScriptTemplate checks, improved dscript.save() methods
# 2024-10-28 less redundancy beyween local and global variables in dscript.save()
# 2024-10-07 new parsesyntax accepting [ ] at any position, improved doc, parsesyntax_legacy holds the old parser method
# 2024-10-08 fix single line templates
# 2024-10-12 several improvements and sophistication in the definition and execution of templates from dscript
# 2024-12-01 standarize scripting features, automatically call script/pscript methods
# 2024-12-02 add dscript.header() and implement it in dscript.save() and dscript.write()
# 2024-12-03 improve the logics of dscript.parse(), dscript.save() on real cases
# 2024-12-04 preparation for major release
# 2024-12-09 get-metadata() use globals()
# 2025-01-01 implement search(), list_values()
# 2025-01-02 add protection to search() to remove $ in output dict, update + and | to handle scriptobjectgroup
# 2025-01-05 consolidation and improve compatibility with pizza.script incl. the use of VariableOccurrences
# 2025-01-06 split dscipt.save() so that it uses var_info() as a standard method to retrive variable information
# 2025-01-07 fine tunning of dscipt.save(), add print dscript.print_var_info() - version 1.0

# Dependencies
import os, getpass, socket, time, datetime
import re, string, random, copy, hashlib
from copy import copy as duplicate
from copy import deepcopy as deepduplicate
from collections import defaultdict
from datetime import datetime
from pizza.private.mstruct import paramauto
from pizza.script import script, scriptdata, pipescript, scriptobjectgroup, remove_comments, span, frame_header, VariableOccurrences

__all__ = [&#39;ScriptTemplate&#39;, &#39;VariableOccurrences&#39;, &#39;autoname&#39;, &#39;dscript&#39;, &#39;frame_header&#39;, &#39;get_metadata&#39;, &#39;lambdaScriptdata&#39;, &#39;lamdaScript&#39;, &#39;paramauto&#39;, &#39;pipescript&#39;, &#39;remove_comments&#39;, &#39;script&#39;, &#39;scriptdata&#39;, &#39;scriptobjectgroup&#39;, &#39;span&#39;]


# %% Private Functions

def autoname(numChars=8):
    &#34;&#34;&#34; generate automatically names &#34;&#34;&#34;
    return &#39;&#39;.join(random.choices(string.ascii_letters, k=numChars))  # Generates a random name of numChars letters


# returns the metadata
def get_metadata():
    &#34;&#34;&#34;Return a dictionary of explicitly defined metadata.&#34;&#34;&#34;
    # Define the desired metadata keys
    metadata_keys = [
        &#34;__project__&#34;,
        &#34;__author__&#34;,
        &#34;__copyright__&#34;,
        &#34;__credits__&#34;,
        &#34;__license__&#34;,
        &#34;__maintainer__&#34;,
        &#34;__email__&#34;,
        &#34;__version__&#34;,
    ]
    # Filter only the desired keys from the current module&#39;s globals
    return {key.strip(&#34;_&#34;): globals()[key] for key in metadata_keys if key in globals()}


# %% Low-level Classes (wrappers for pizza.script)

class lambdaScriptdata(paramauto):
    &#34;&#34;&#34;
    Class to manage lambda script parameters.

    This class holds definitions and variables used within the script templates.
    These parameters are typically set up as global variables that can be accessed
    by script sections for evaluation and substitution.

    Example Usage:
    --------------
    definitions = lambdaScriptdata(var1=10, var2=&#34;value&#34;)

    Attributes:
    -----------
    _type : str
        The type of the data (&#34;LSD&#34; by default).
    _fulltype : str
        Full type description of the lambda script data.
    _ftype : str
        Short description of the type (parameter definition).

    Methods:
    --------
    This class inherits methods from the `paramauto` class, which allows automatic
    handling of parameters and script data.
    &#34;&#34;&#34;

    _type = &#34;LSD&#34;
    _fulltype = &#34;Lambda Script Parameters&#34;
    _ftype = &#34;parameter definition&#34;

    def __init__(self, _protection=False, _evaluation=True, sortdefinitions=False, **kwargs):
        &#34;&#34;&#34;
        Constructor for lambdaScriptdata. It forces the parent&#39;s _returnerror parameter to False.

        Parameters:
        -----------
        _protection : bool, optional
            Whether to enable protection on the parameters (default: False).
        _evaluation : bool, optional
            Whether evaluation is enabled for the parameters (default: True).
        sortdefinitions : bool, optional
            Whether to sort definitions upon initialization (default: False).
        **kwargs : dict
            Additional keyword arguments for the parent class.
        &#34;&#34;&#34;
        # Call the parent class constructor
        super().__init__(_protection=_protection, _evaluation=_evaluation, sortdefinitions=sortdefinitions, **kwargs)
        # Override the _returnerror attribute at the instance level
        self._returnerror = False


class lamdaScript(script):

    &#34;&#34;&#34;
    lamdaScript
    ===========

    The `lamdaScript` class is a specialized subclass of `script` that acts as a wrapper
    for generating script objects from `dscript` instances. It facilitates the creation
    of scripts with persistent storage options and user-defined configurations.

    Attributes
    ----------
    name : str
        The name of the script.
    SECTIONS : list
        Inherited list of script sections from the `script` class.
    position : int
        The position index of the script section.
    role : str
        The role of the script section, derived from its position.
    description : str
        A brief description of the script.
    userid : str
        The user ID associated with the script.
    version : float
        The version of the script.
    verbose : bool
        Flag to enable verbose output.
    DEFINITIONS : scriptdata
        Definitions of variables used in the script.
    USER : lambdaScriptdata
        User-defined variables specific to `lamdaScript`.
    TEMPLATE : dict
        A dictionary of script templates.

    Methods
    -------
    do()
        Generates the complete LAMMPS script by processing all script sections.

    Special Methods
    ----------------
    __contains__(key)
        Allows checking if a specific section exists using the `in` keyword.
    __str__()
        Returns the string representation of the script.

    Usage Example
    -------------
    ```python
    from dscript import lamdaScript, dscript

    # Create an existing dscript instance
    existing_dscript = dscript(name=&#34;ExistingScript&#34;)
    existing_dscript.role = &#34;Custom Role&#34;

    # Create a lamdaScript instance based on the existing dscript
    ls = lamdaScript(existing_dscript)
    print(ls.role)  # Outputs: &#34;Custom Role&#34;
    ```
    &#34;&#34;&#34;
    name = &#34;&#34;

    def __init__(self, dscriptobj, persistentfile=True, persistentfolder=None,
                 printflag = False, verbose = True, softrun = True,
                 **userdefinitions):
        &#34;&#34;&#34;
            Initialize a new `lambdaScript` instance.

            This constructor creates a `lambdaScript` object based on an existing `dscriptobj`,
            providing options for persistent storage, verbose output, and user-defined configurations.
            A `lambdaScript` represents an anonymous or temporary script that can either preserve the
            original script structure or partially evaluate variable definitions based on the `softrun` flag.

            Parameters
            ----------
            dscriptobj : dscript
                An existing `dscript` object to base the new instance on.
            persistentfile : bool, optional
                If `True`, the script will be saved to a persistent file. Defaults to `True`.
            persistentfolder : str or None, optional
                The folder where the persistent file will be saved. If `None`, a temporary location is used.
                Defaults to `None`.
            printflag : bool, optional
                If `True`, enables printing of the script details during execution. Defaults to `False`.
            verbose : bool, optional
                If `True`, provides detailed output during script initialization and execution. Defaults to `True`.
            softrun : bool, optional
                Determines whether a pre-execution run is carried out to partially evaluate and substitute variables.
                - If `True` (default), the variable definitions and original script content are preserved without full
                  evaluation, meaning no substitution is carried out on the `dscript`&#39;s templates or definitions.
                - If `False`, performs an initial evaluation phase that substitutes available variables and captures
                  the local definitions before creating the `lambdaScript` object.
            **userdefinitions
                Additional user-defined variables and configurations to be included in the `lambdaScript`.

            Raises
            ------
            TypeError
                If `dscriptobj` is not an instance of the `dscript` class.

            Example
            -------
            ```python
            existing_dscript = dscript(name=&#34;ExistingScript&#34;)
            ls = lambdaScript(existing_dscript, var3=&#34;3&#34;, softrun=False)
            ```
        &#34;&#34;&#34;
        if not isinstance(dscriptobj, dscript):
            raise TypeError(f&#34;The &#39;dscriptobj&#39; object must be of class dscript not {type(dscriptobj).__name__}.&#34;)
        verbose = dscriptobj.verbose if verbose is None else dscriptobj.verbose
        super().__init__(persistentfile=persistentfile, persistentfolder=persistentfolder, printflag=printflag, verbose=verbose, **userdefinitions)
        self.name = dscriptobj.name
        self.SECTIONS = dscriptobj.SECTIONS
        self.section = dscriptobj.section
        self.position = dscriptobj.position
        self._role = dscriptobj.role  # Initialize an internal storage for the role
        self.description = dscriptobj.description
        self.userid = dscriptobj.userid
        self.version= dscriptobj.version
        self.verbose = verbose
        self.printflag = printflag
        self.DEFINITIONS = dscriptobj.DEFINITIONS
        if softrun:
            self.TEMPLATE,localdefinitions = dscriptobj.do(softrun=softrun,return_definitions=True)
            self.USER = localdefinitions + lambdaScriptdata(**self.USER)
        else:
            self.TEMPLATE = dscriptobj.do(softrun=softrun)
            self.USER = lambdaScriptdata(**self.USER)

    @property
    def role(self):
        &#34;&#34;&#34;Override the role property to include a setter.&#34;&#34;&#34;
        # If _role is set, return it; otherwise, use the inherited logic
        if self._role is not None:
            return self._role
        elif self.section in range(len(self.SECTIONS)):
            return self.SECTIONS[self.section]
        else:
            return &#34;&#34;

    @role.setter
    def role(self, value):
        &#34;&#34;&#34;Allow setting the role.&#34;&#34;&#34;
        self._role = value


# %% Main Classes
class ScriptTemplate:
    &#34;&#34;&#34;
     The `ScriptTemplate` class provides a mechanism to store, process, and dynamically substitute
     variables within script content. This class supports handling flags and conditions, allowing
     for flexible and conditional execution of parts of the script.

     Attributes:
     -----------
     default_attributes : dict (class-level)
         A dictionary containing the default flags for each `ScriptTemplate` object. These attributes
         are applied when initializing the object or when no flags are specified in the content.
         Flags include:
         - facultative (bool): If True, the script line is optional and may be discarded if certain
             conditions are not met. (default: False)
         - eval (bool): If True, the content is evaluated using `formateval`, which allows for variable
             substitution during execution. (default: False)
         - readonly (bool): If True, the content cannot be modified after initialization. (default: False)
         - condition (str or None): A string that specifies a condition for executing the content.
             If the condition is not met, the script line is skipped. (default: None)
         - condeval (bool): If True, the `condition` attribute is evaluated dynamically using variables.
             (default: False)
         - detectvar (bool): If True, any variables in the content (e.g., `${varname}`) are automatically
             detected and registered in the definitions. (default: True)

     Methods:
     --------
     __init__(self, content=&#34;&#34;, definitions=lambdaScriptdata(), userid=None, verbose=False, **kwargs):
         Initializes the `ScriptTemplate` object with script content, optional variable definitions,
         and configurable attributes. Flags like `facultative`, `eval`, `readonly`, `condition`,
         and others are set via content prefixes or passed directly as keyword arguments.

     parse_content(cls, content, verbose=False):
         A class method that parses content to detect special flags and condition tags, returning the
         cleaned content and a dictionary of attributes (flags).

         The method processes the following flags and tags:
         - `!` : Sets `eval=True`, which forces evaluation of the content.
         - `?` : Sets `facultative=True`, marking the content as optional.
         - `^` : Sets `readonly=True`, preventing modifications to the content.
         - `~` : Sets `detectvar=False`, disabling automatic variable detection.
         - `[if:condition]` : Defines a condition for executing the script. If the condition is met,
           the script will be executed. Conditions can include `;eval` to trigger evaluation.

         Parameters:
         -----------
         content : str
             The script content to be parsed. It may contain lines starting with special characters
             that set specific attributes for the script template.

         verbose : bool (default: False)
             If True, preserves comments and does not remove comment lines during parsing.

         Returns:
         --------
         cleaned_content : str
             The cleaned script content, with all flags and conditions removed.

         attributes : dict
             A dictionary of parsed attributes (flags) including:
             - facultative (bool): Indicates if the content is optional.
             - eval (bool): Specifies if the content should be evaluated for variable substitution.
             - readonly (bool): Prevents modifications to the content.
             - condition (str or None): Defines the condition for executing the script.
             - condeval (bool): If True, dynamically evaluates the condition.
             - detectvar (bool): If True, detects and registers variables in the content.

     detect_variables(self):
         Detects variables in the content using the pattern `${varname}`. It returns a list of
         variable names found in the script.

     refreshvar(self):
         Ensures that any detected variables are added to the `definitions` if they are missing.

     __setattr__(self, name, value):
         Sets the value of an attribute. The method performs validation on specific attributes
         (e.g., `eval`, `readonly`, `facultative`, etc.) to ensure the correct data types are assigned.

     __getattr__(self, name):
         Retrieves the value of an attribute. If the attribute is not set, it returns the default
         value from `default_attributes`.


    Example 1:
    ----------
    # Create a ScriptTemplate object with content and optional definitions
    line = ScriptTemplate(&#34;dimension    ${dimension}&#34;)

    # You can also pass in global definitions if needed
    global_definitions = lambdaScriptdata(dimension=3)
    line_with_defs = ScriptTemplate(&#34;dimension    ${dimension}&#34;,
                                    definitions=global_definitions)

    After initialization, you can modify the line&#39;s attributes or use it as
    part of a larger script managed by a `dscript` object.


     Example 2:
     ----------
     # Example of using flags and conditions in content

     line = ScriptTemplate(&#34;!velocity all set 0.0 0.0 0.0 units box&#34;)
     # This will automatically set `eval=True` due to the &#39;!&#39; flag.

     line_with_condition = ScriptTemplate(&#34;[if: ${condition};eval] fix upper move wiggle 0.0 0.0 1.0 1.0&#34;)
     # This content will only execute if `${condition}` is True, and `eval` will be applied to substitute variables.

    &#34;&#34;&#34;

    # Class-level attribute for default flags
    default_attributes = {
        &#39;facultative&#39;: False,
        &#39;eval&#39;: False,
        &#39;readonly&#39;: False,
        &#39;condition&#39;: None,
        &#39;condeval&#39;: False,
        &#39;detectvar&#39;: True
    }

    def __init__(self, content=&#34;&#34;, definitions=lambdaScriptdata(), autorefresh=True, userid=None, verbose=False, comment_chars=&#34;#%&#34;, **kwargs):
        &#34;&#34;&#34;
        Initializes a new `ScriptTemplate` object.

        The constructor sets up a new script template with content, optional variable
        definitions, and a set of configurable attributes. This template is capable
        of dynamically substituting variables using a provided `lambdaScriptdata`
        object or internal definitions. You can also manage attributes like evaluation,
        facultative execution, and variable detection.

        Parameters:
        -----------
        content : str or list of str
            The content of the script template, which can be a single string or a list of strings.
            If a single string is provided, it will automatically be converted to a list of lines.
            This ensures consistent handling of multi-line content.

        definitions : lambdaScriptdata, optional
            A reference to a `lambdaScriptdata` object that contains global variable
            definitions. These definitions will be used to substitute variables within the content.
            If `definitions` is not provided, variable substitution will rely on local
            or inline definitions.

        verbose : flag (default value=True)
            If True the comments are preserved (applied when str is a string).

        autorefresh : flag (default=False)
            If True, new variables are automatically detected when the content is changed

        **kwargs :
            Additional keyword arguments to set specific attributes for the script line.
            These attributes control the behavior of the script template during evaluation
            and execution. Any keyword argument passed here will update the default
            attribute values.

                Default attributes (with default values):
            - facultative (False):
                If True, the script line is optional and may be discarded if certain conditions are not met.
            - eval (False):
                If True, the content will be evaluated using `formateval`, allowing variable
                substitution during the execution.
            - readonly (False):
                If True, the content of the script cannot be modified after initialization.
            - condition (None):
                An optional condition that controls whether the content will be executed.
                If the condition is not met, the script line will not be executed.
            - condeval (False):
                If True, the `condition` attribute will be evaluated, allowing conditional
                logic based on variable values.
            - detectvar (True):
                If True, the content will automatically detect and register any variables
                (such as `${varname}`) within the `definitions` for substitution.
            - comment_chars : str, optional (default: &#34;#%&#34;)
                A string containing characters to identify the start of a comment.
                Any of these characters will mark the beginning of a comment unless within quotes.
        &#34;&#34;&#34;


        # Initialize `_CACHE` with separate entries for each method
        self._CACHE = {
            &#39;variables&#39;: {&#39;result&#39;: None},
            &#39;check_variables&#39;: {&#39;result&#39;: None}
        }
        # Constructor
        self._autorefresh = autorefresh
        self._content = content # # Store initial content
        self.definitions = lambdaScriptdata(**definitions)  # Reference to the DEFINITIONS object
        # Initialize attributes with default values
        self.attributes = self.default_attributes.copy()
        # Convert single string content to a list for consistent processing
        if content == &#34;&#34; or content is None:
            content = &#34;&#34;  # Set to empty string if None
        elif isinstance(content, str):
            # Interpret the content and extract any attribute flags (e.g. !, ?, etc.)
            content, self.attributes = self.parse_content(content, verbose=verbose)
            # Convert content to a list of strings
            if verbose:
                content = content.split(&#39;\n&#39;)  # All comments are preserved during construction
            else:
                content = remove_comments(content, split_lines=True,comment_chars=comment_chars)  # Split string by newlines into list of strings
        elif not isinstance(content, list) or not all(isinstance(item, str) for item in content):
            raise TypeError(&#34;The &#39;content&#39; attribute must be a string or a list of strings.&#34;)
        # Update attributes with any additional keyword arguments passed in
        self.attributes.update(kwargs)
        # Detect variables in the content
        detected_variables = self.detect_variables()
        # Automatically set `eval=True` if any detected variables are defined in `definitions`
        if detected_variables:
            for var in detected_variables:
                if var in self.definitions:
                    self.attributes[&#39;eval&#39;] = True
                    break  # No need to continue checking once we know eval should be set
        # Assign userid (optional)
        self.userid = userid if userid is not None else autoname(3)
        # Assign content to the object
        self.content = content if content != [] else [f&#34;# &lt;empty content&gt; for key {self.userid}&#34;]


    def _calculate_content_hash(self, content):
        &#34;&#34;&#34;Generate hash for content.&#34;&#34;&#34;
        return hashlib.md5(&#34;\n&#34;.join(content).encode()).hexdigest() if isinstance(content, list) else hashlib.md5(content.encode()).hexdigest()

    @property
    def content(self):
        return self._content

    @content.setter
    def content(self, new_content):
        &#34;&#34;&#34;Set content and reinitialize cache if the content has changed.&#34;&#34;&#34;
        new_content_hash = self._calculate_content_hash(new_content)
        if new_content_hash != self._content_hash:
            self._content = new_content
            self._content_hash = new_content_hash
            self._invalidate_cache()  # Reset cache only if content changes


    def _update_content(self, value):
        &#34;&#34;&#34;Helper to set _content and _content_hash, refreshing cache as necessary.&#34;&#34;&#34;
        # Check if content modification is allowed based on readonly attribute
        if getattr(self, &#39;attributes&#39;, {}).get(&#39;readonly&#39;, False):
            raise AttributeError(&#34;Cannot modify content. It is read-only.&#34;)
        # Validate and process content as either a string or list of strings
        if isinstance(value, str):
            value = remove_comments(value, split_lines=True)
        elif not isinstance(value, list) or not all(isinstance(item, str) for item in value):
            raise TypeError(&#34;The &#39;content&#39; attribute must be a string or a list of strings.&#34;)
        # Set _content and calculate hash
        super().__setattr__(&#39;_content&#39;, value)
        new_hash = hash(tuple(value))
        # If hash changes, reset cache
        if new_hash != getattr(self, &#39;_content_hash&#39;, None):
            super().__setattr__(&#39;_content_hash&#39;, new_hash)
            self._invalidate_cache()  # Invalidate cache due to content change
            if self._autorefresh:
                self.refreshvar()  # Refresh variables based on new content

    def _invalidate_cache(self):
        &#34;&#34;&#34;Reset all cache entries.&#34;&#34;&#34;
        # Check if _CACHE is initialized
        if not hasattr(self, &#39;_CACHE&#39;):
            self._CACHE = {
                &#39;variables&#39;: {&#39;result&#39;: None},
                &#39;check_variables&#39;: {&#39;result&#39;: None}
            }
        for entry in self._CACHE.values():
            entry[&#39;result&#39;] = None


    @classmethod
    def parse_content(cls, content, verbose=False):
        &#34;&#34;&#34;
        Parse the content string and return:
        1. Cleaned content (without flags or condition tags).
        2. A dictionary of attributes (flags) initialized with default values.

        Parameters:
        -----------
        content : str
            The content string to be parsed.

        Returns:
        --------
        cleaned_content : str
            The cleaned content with all flag prefixes and condition tags removed.
        attributes : dict
            A dictionary of attributes (flags) set based on the content prefixes.
        &#34;&#34;&#34;
        attributes = cls.default_attributes.copy()

        # Handle empty content
        if not content.strip():  # Empty string or whitespace-only
            return &#34;&#34;, attributes

        idx = 0
        cleaned_content = []

        # If content is a single string, split it into lines
        if isinstance(content, str):
            content = content.split(&#39;\n&#39;)

        # Remove leading and trailing empty lines
        while content and content[0].strip() == &#39;&#39;:
            content.pop(0)
        while content and content[-1].strip() == &#39;&#39;:
            content.pop()

        # Process each remaining line to detect flags and conditions
        for line in content:
            idx = 0
            line = line.strip()  # Trim any leading/trailing whitespace

            # Parse flags and conditions only at the beginning of the line
            while idx &lt; len(line):
                ch = line[idx]
                if ch == &#39;!&#39;:
                    attributes[&#39;eval&#39;] = True
                    idx += 1
                elif ch == &#39;?&#39;:
                    attributes[&#39;facultative&#39;] = True
                    idx += 1
                elif ch == &#39;^&#39;:
                    attributes[&#39;readonly&#39;] = True
                    idx += 1
                elif ch == &#39;~&#39;:
                    attributes[&#39;detectvar&#39;] = False
                    idx += 1
                elif line.startswith(&#39;[if:&#39;, idx):
                    # Parse condition
                    end_idx = line.find(&#39;]&#39;, idx)
                    if end_idx == -1:
                        raise ValueError(&#34;Unclosed &#39;[if:]&#39; tag in content&#34;)
                    cond_str = line[idx + 4:end_idx]
                    if &#39;;eval&#39; in cond_str:
                        attributes[&#39;condeval&#39;] = True
                        cond_str = cond_str.replace(&#39;;eval&#39;, &#39;&#39;)
                    attributes[&#39;condition&#39;] = cond_str.strip()
                    idx = end_idx + 1
                else:
                    break  # No more flags or conditions, process the rest of the line

                # Skip any whitespace after flags or conditions
                while idx &lt; len(line) and line[idx] in (&#39; &#39;, &#39;\t&#39;):
                    idx += 1

            # Append the cleaned line (without flags or condition tags)
            cleaned_content.append(line[idx:].strip())

        # Join the cleaned lines back into a single string
        cleaned_content = &#39;\n&#39;.join(cleaned_content)

        return cleaned_content, attributes



    def __str__(self):
        num_attrs = len(self.attributes)  # All attributes count
        return f&#34;1 line/block, {num_attrs} attributes&#34;


    def __repr__(self):
      # Template content section
      total_lines = len(self.content)
      total_variables = len(self.definitions)
      line_word = &#34;lines&#34; if total_lines &gt; 1 else &#34;line&#34;
      variable_word = &#34;defs&#34; if total_variables &gt; 1 else &#34;def&#34;
      content_label = &#34;Template Content&#34;
      content_label += &#34;&#34; if self.userid == &#34;&#34; else f&#34; | id:{self.userid}&#34;
      available_space = 50 - len(content_label) - 1
      repr_str = &#34;-&#34; * 50 + &#34;\n&#34;
      repr_str += f&#34;{content_label}{(&#39;(&#39; + str(total_lines) + &#39; &#39; + line_word + &#39;, &#39; + str(total_variables) + &#39; &#39; + variable_word + &#39;)&#39;).rjust(available_space)}\n&#34;
      repr_str += &#34;-&#34; * 50 + &#34;\n&#34;

      if total_lines &lt; 1:
          repr_str += &#34;&lt; empty content &gt;\n&#34;
      elif total_lines &lt;= 12:
          # If content has 12 or fewer lines, display all lines
          for line in self.content:
              truncated_line = (line[:18] + &#39;[...]&#39; + line[-18:]) if len(line) &gt; 40 else line
              repr_str += f&#34;{truncated_line:&lt;50}\n&#34;
      else:
          # Display first three lines, middle three lines, and last three lines
          for line in self.content[:3]:
              truncated_line = (line[:18] + &#39;[...]&#39; + line[-18:]) if len(line) &gt; 40 else line
              repr_str += f&#34;{truncated_line:&lt;50}\n&#34;
          repr_str += &#34;\t\t[...]\n&#34;
          mid_start = total_lines // 2 - 1
          mid_end = mid_start + 3
          for line in self.content[mid_start:mid_end]:
              truncated_line = (line[:18] + &#39;[...]&#39; + line[-18:]) if len(line) &gt; 40 else line
              repr_str += f&#34;{truncated_line:&lt;50}\n&#34;
          repr_str += &#34;\t\t[...]\n&#34;
          for line in self.content[-3:]:
              truncated_line = (line[:18] + &#39;[...]&#39; + line[-18:]) if len(line) &gt; 40 else line
              repr_str += f&#34;{truncated_line:&lt;50}\n&#34;

      # Detected Variables section in 3-column format
      detected_variables = self.detect_variables()
      if detected_variables:
          repr_str += &#34;-&#34; * 50 + &#34;\n&#34;
          # Count the number of defined and missing variables
          defined_variables = set(self.definitions.keys()) if self.definitions else set()
          variable_word = &#39;Variables&#39; if len(detected_variables) &gt; 1 else &#39;Variable&#39;
          detected_set = set(detected_variables)
          missing_variables = detected_set - defined_variables
          defined_count = len(detected_set &amp; defined_variables)
          missing_count = len(missing_variables)
          total_variables = len(detected_set)
          repr_str += f&#34;Detected {variable_word}{(&#39;(&#39; + str(total_variables) + &#39; / +&#39; + str(defined_count) + &#39; / -&#39; + str(missing_count) + &#39;)&#39;).rjust(50 - len(&#39;Detected Variables&#39;) - 1)}\n&#34;
          repr_str += &#34;-&#34; * 50 + &#34;\n&#34;

          # Display variables with status:
          # [+] for defined variables with values other than &#34;${varname}&#34;
          # [-] for defined variables with default values &#34;${varname}&#34;
          # [ ] for undefined variables
          for i in range(0, len(detected_variables), 3):
              var_set = detected_variables[i:i+3]
              line = &#34;&#34;
              for var in var_set:
                  var_name = (var[:10] + &#39; &#39;) if len(var) &gt; 10 else var.ljust(11)
                  if var in defined_variables:
                      # Check if it&#39;s set to its default value (i.e., &#34;${varname}&#34;)
                      if self.definitions[var] == f&#34;${{{var}}}&#34;:
                          flag = &#39;[-]&#39;
                      else:
                          flag = &#39;[+]&#39;
                  else:
                      flag = &#39;[ ]&#39;
                  line += f&#34;{flag} {var_name}  &#34;
              repr_str += f&#34;{line}\n&#34;

      # Attribute section in 3 columns
      repr_str += &#34;-&#34; * 50 + &#34;\n&#34;
      repr_str += f&#34;Template Attributes{(&#39;(&#39; + str(len(self.attributes)) + &#39; attributes)&#39;).rjust(50 - len(&#39;Template Attributes&#39;) - 1)}\n&#34;
      repr_str += &#34;-&#34; * 50 + &#34;\n&#34;

      # Create a compact three-column layout for attributes with checkboxes
      attr_items = [(attr, &#39;[x]&#39; if value else &#39;[ ]&#39;) for attr, value in self.attributes.items() if attr != &#39;definitions&#39;]
      for i in range(0, len(attr_items), 3):
          attr_set = attr_items[i:i+3]
          line = &#34;&#34;
          for attr, value in attr_set:
              attr_name = (attr[:10] + &#39; &#39;) if len(attr) &gt; 10 else attr.ljust(11)
              line += f&#34;{value} {attr_name}  &#34;
          repr_str += f&#34;{line}\n&#34;

      return repr_str


    def __setattr__(self, name, value):
        # Handle specific attributes with validation
        if name in [&#39;facultative&#39;, &#39;eval&#39;, &#39;readonly&#39;]:
            if not isinstance(value, bool):
                raise TypeError(f&#34;The &#39;{name}&#39; attribute must be a Boolean, not {type(value).__name__}.&#34;)
        elif name == &#39;condition&#39;:
            if not isinstance(value, str) and value is not None:
                raise TypeError(f&#34;The &#39;condition&#39; attribute must be a string or None, not {type(value).__name__}.&#34;)
        elif name == &#39;content&#39;:
            # Use helper to manage content updates and cache invalidation
            self._update_content(value)
            return  # Exit to avoid further processing since _update_content handles the setting
        elif name == &#39;definitions&#39;:
            if not isinstance(value, (lambdaScriptdata, scriptdata)) and value is not None:
                raise TypeError(f&#34;The &#39;definitions&#39; must be a lambdaScriptdata or scriptdata, not {type(value).__name__}.&#34;)

        # Set attributes directly for key fields and avoid recursion
        if name in [&#39;userid&#39;, &#39;attributes&#39;, &#39;definitions&#39;, &#39;_content&#39;, &#39;_content_hash&#39;, &#39;_autorefresh&#39;]:
            super().__setattr__(name, value)
        else:
            # Ensure &#39;attributes&#39; is initialized before updating
            if not hasattr(self, &#39;attributes&#39;) or self.attributes is None:
                self.attributes = {}
            self.attributes[name] = value


    def __getattr__(self, name):
        &#34;&#34;&#34;
        Handles attribute retrieval, checking the following in order:
        1. If &#39;name&#39; is in default_attributes, return the value from attributes if it exists,
           otherwise return the default value from default_attributes.
        2. If &#39;name&#39; is &#39;content&#39;, return the content (or an empty string if content is not set).
        3. If &#39;name&#39; exists in the attributes dictionary, return its value.
        4. If attributes itself exists in __dict__, return the value from attributes if &#39;name&#39; is found.
        5. If all previous checks fail, raise an AttributeError indicating that &#39;name&#39; is not found.
        &#34;&#34;&#34;
        # Ensure &#39;_CACHE&#39; is always accessible without a KeyError
        if name == &#39;_CACHE&#39;:
            # Initialize _CACHE if it does not exist
            if &#39;_CACHE&#39; not in self.__dict__:
                self.__dict__[&#39;_CACHE&#39;] = {
                    &#39;variables&#39;: {&#39;result&#39;: None},
                    &#39;check_variables&#39;: {&#39;result&#39;: None}
                }
            return self.__dict__[&#39;_CACHE&#39;]  # Access _CACHE directly
        # Step 1: Check if &#39;name&#39; is a valid attribute in default_attributes
        if name in self.default_attributes:
            # Directly access __dict__ to avoid recursive lookup
            attributes = self.__dict__.get(&#39;attributes&#39;, {})
            return attributes.get(name, self.default_attributes[name])
        # Step 2: Special case for &#39;content&#39;
        if name == &#39;content&#39;:
            # Directly access __dict__ to avoid recursion
            return self.__dict__.get(&#39;_content&#39;, &#34;&#34;)
        if name == &#34;_autorefresh&#34;:
            return self.__dict__.get(&#39;_autorefresh&#39;, True)
        # Step 3: Check if &#39;name&#39; exists in &#39;attributes&#39; and return its value directly
        attributes = self.__dict__.get(&#39;attributes&#39;, {})
        if name in attributes:
            return attributes[name]
        # Step 4: Check if &#39;attributes&#39; exists in __dict__ and retrieve &#39;name&#39; if present
        if &#39;attributes&#39; in self.__dict__ and name in self.__dict__[&#39;attributes&#39;]:
            return self.__dict__[&#39;attributes&#39;][name]
        # Step 5: If none of the above conditions are met, raise an AttributeError
        raise AttributeError(f&#34;&#39;{self.__class__.__name__}&#39; object has no attribute &#39;{name}&#39;&#34;)




    def do(self, protected=True, softrun=False,globaldefinitions=lambdaScriptdata(),USER=lambdaScriptdata(),**kwargs):
        &#34;&#34;&#34;
        Executes or prepares the script template content based on its attributes and the `softrun` flag.

        Parameters
        ----------
        protected : bool, optional
            If `True` (default), variable evaluation uses a protected environment, safeguarding global definitions
            and system attributes from modification during execution.
        softrun : bool, optional
            Determines if the script is evaluated in a preliminary mode:
            - If `True`, returns the script content without full evaluation, allowing for a preview or
              an initial capture of local definitions without substituting variables.
            - If `False` (default), processes the script with full evaluation, applying all substitutions
              defined in `definitions`.
        USER : lambdaScriptdata, optional
            A `lambdaScriptdata` instance with user-provided definitions, which supplement or override
            template-level definitions during execution.

        Returns
        -------
        str
            The processed or original script content as a single string.
            - Returns an empty string if `facultative` is set to `True`, or if `condition` is `False`
              and does not meet any specified evaluation requirements.

        Notes
        -----
        - `facultative`: If `True`, the method returns an empty string, effectively skipping execution of the content.
        - `condition`: If specified, this attribute is evaluated to decide whether the content should be processed
          (default `True` if `condition` is `None`). If `condeval` is `True`, the condition itself undergoes
          evaluation using Python&#39;s `eval`.
        - `eval`: If `True` and `softrun` is `False`, performs evaluation for variable substitution on the
          content lines, applying transformations based on both `definitions` and `USER` definitions if provided.
          This allows variables to be dynamically substituted within the script content.

        Processing Workflow
        -------------------
        1. **Facultative Check**: If the `facultative` attribute is `True`, immediately returns an empty string.
        2. **Condition Check**: If a `condition` is specified, it is evaluated:
           - If `condeval` is `True`, the condition undergoes evaluation (using `eval`).
           - If the evaluated `condition` is `False`, returns an empty string, skipping execution.
        3. **Execution Based on `softrun`**:
           - If `softrun` is `True`, returns the original content without variable substitution, providing a preview.
           - If `softrun` is `False`, evaluates the content lines based on `definitions` and `USER` if applicable.
        4. **Variable Formatting**: During evaluation, lists and tuples are formatted into strings with prefixed comments,
           enhancing readability and handling complex data structures directly in the script.

        Example
        -------
        &gt;&gt;&gt; template = ScriptTemplate(
        ...     content=[&#34;variable x equal ${var1}&#34;, &#34;print &#39;Value of x is ${var1}&#39;&#34;],
        ...     definitions=lambdaScriptdata(var1=10)
        ... )
        &gt;&gt;&gt; template.do()
        &#34;variable x equal 10\nprint &#39;Value of x is 10&#39;&#34;

        &#34;&#34;&#34;

        # If &#39;facultative&#39; is set to True, return an empty string immediately
        if self.attributes.get(&#34;facultative&#34;, False):
            return &#34;&#34;

        # Evaluate condition if present
        cond = True
        if self.attributes.get(&#34;condition&#34;) is not None:
            condition_expr = self.definitions.formateval(self.attributes[&#34;condition&#34;], protected)
            cond = eval(condition_expr) if self.attributes.get(&#34;condeval&#34;, False) else condition_expr

        # Process based on softrun flag
        if softrun:
            return &#34;\n&#34;.join(self.content) if cond else &#34;&#34;

        # Perform full processing when softrun is False
        if cond:
            if self.attributes.get(&#34;eval&#34;, True):
                #return &#34;\n&#34;.join([self.definitions.formateval(line, protected) for line in self.content])
                inputs = globaldefinitions + self.definitions + USER + lambdaScriptdata(**kwargs)
                for k in inputs.keys():
                    if isinstance(inputs.getattr(k),list):
                        inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k)))
                    elif isinstance(inputs.getattr(k),tuple):
                        inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k),sep=&#34;,&#34;))
                return &#34;\n&#34;.join([inputs.formateval(line, protected) for line in self.content])

            else:
                return &#34;\n&#34;.join(self.content)

        return &#34;&#34;



    def detect_variables(self):
        &#34;&#34;&#34;
        Detects variables in the content of the template using the pattern r&#39;\$\{(\w+)\}&#39;.

        Returns:
        --------
        list
            A list of unique variable names detected in the content.
        &#34;&#34;&#34;
        # Check cache first
        cache_entry = self._CACHE[&#39;variables&#39;]
        if cache_entry[&#39;result&#39;] is not None:
            return cache_entry[&#39;result&#39;]
        # Detect variables if cache miss or content changed
        variable_pattern = re.compile(r&#39;\$\{(\w+)\}&#39;)
        detected_vars = {variable for line in self.content for variable in variable_pattern.findall(line)}
        # Cache the result and return output
        cache_entry[&#39;result&#39;] = list(detected_vars)
        return cache_entry[&#39;result&#39;]



    def refreshvar(self,globaldefinitions = lambdaScriptdata()):
        &#34;&#34;&#34;
        Detects variables in the content and adds them to definitions if needed.
        This method ensures that variables like ${varname} are correctly detected
        and added to the definitions if they are missing.

        use globaldefinitions to add a list of global variables/definitions

        &#34;&#34;&#34;
        if self.attributes[&#34;detectvar&#34;] and isinstance(self.content, list) and self.definitions and self._autorefresh:
            variables = self.detect_variables()
            for varname in variables:
                if (varname not in self.definitions) and (varname not in globaldefinitions):
                    self.definitions.setattr(varname, &#34;${&#34; + varname + &#34;}&#34;)


    def check_variables(self, verbose=True, seteval=True):
        &#34;&#34;&#34;
        Checks for undefined variables in the ScriptTemplate instance.

        Parameters:
        -----------
        verbose : bool, optional, default=True
            If True, prints information about variables for the template.
            Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.

        seteval : bool, optional, default=True
            If True, sets the `eval` attribute to True if at least one variable is defined or set to its default value.

        Returns:
        --------
        out : dict
            A dictionary with lists of default variables, set variables, and undefined variables:
            - &#34;defaultvalues&#34;: Variables set to their default value (${varname}).
            - &#34;setvalues&#34;: Variables defined with a specific value.
            - &#34;undefined&#34;: Variables that are undefined.
        &#34;&#34;&#34;
        # Check cache first
        cache_entry = self._CACHE[&#39;check_variables&#39;]
        if cache_entry[&#39;result&#39;] is not None:
            return cache_entry[&#39;result&#39;]
        # Main
        out = {&#34;defaultvalues&#34;: [], &#34;setvalues&#34;: [], &#34;undefined&#34;: []}
        detected_vars = self.detect_variables()
        defined_vars = set(self.definitions.keys()) if self.definitions else set()
        set_values, default_values, undefined_vars = [], [], []
        if verbose:
            print(f&#34;\nTEMPLATE {self.userid} variables:&#34;)
        for var in detected_vars:
            if var in defined_vars:
                if self.definitions[var] == f&#34;${{{var}}}&#34;:  # Check for default value
                    default_values.append(var)
                    if verbose:
                        print(f&#34;[-] {var}&#34;)  # Variable is set to its default value
                else:
                    set_values.append(var)
                    if verbose:
                        print(f&#34;[+] {var}&#34;)  # Variable is defined with a specific value
            else:
                undefined_vars.append(var)
                if verbose:
                    print(f&#34;[ ] {var}&#34;)  # Variable is not defined
        # If seteval is True, set eval to True if at least one variable is defined or set to its default
        if seteval and (set_values or default_values):
            self.attributes[&#39;eval&#39;] = True  # Set eval in the attributes dictionary
        # Update the output dictionary
        out[&#34;defaultvalues&#34;].extend(default_values)
        out[&#34;setvalues&#34;].extend(set_values)
        out[&#34;undefined&#34;].extend(undefined_vars)
        # update Cache and return output
        cache_entry[&#39;result&#39;] = out
        return out


    def is_variable_defined(self, var_name):
        &#34;&#34;&#34;
        Checks if a specified variable is defined (either as a default value or a set value).

        Parameters:
        -----------
        var_name : str
            The name of the variable to check.

        Returns:
        --------
        bool
            True if the variable is defined (either as a default or a set value), False if not.

        Raises:
        -------
        ValueError
            If `var_name` is invalid or undefined in the template.
        &#34;&#34;&#34;
        if not isinstance(var_name, str):
            raise ValueError(&#34;Variable name must be a string.&#34;)

        variable_status = self.check_variables(verbose=False, seteval=False)

        # Check if the variable is in default values or set values
        if var_name in variable_status[&#34;defaultvalues&#34;] or var_name in variable_status[&#34;setvalues&#34;]:
            return True
        else:
            raise ValueError(f&#34;Variable &#39;{var_name}&#39; is undefined in the template.&#34;)


    def is_variable_set_value_only(self, var_name):
        &#34;&#34;&#34;
        Checks if a specified variable is defined and set to a specific (non-default) value.

        Parameters:
        -----------
        var_name : str
            The name of the variable to check.

        Returns:
        --------
        bool
            True if the variable is defined with a set (non-default) value, False if not.

        Raises:
        -------
        ValueError
            If `var_name` is invalid or not defined in the template.
        &#34;&#34;&#34;
        if not isinstance(var_name, str):
            raise ValueError(&#34;Variable name must be a string.&#34;)

        variable_status = self.check_variables(verbose=False, seteval=False)

        # Check if the variable is in set values only (not default values)
        if var_name in variable_status[&#34;setvalues&#34;]:
            return True
        elif var_name in variable_status[&#34;defaultvalues&#34;]:
            return False  # Defined but only at its default value
        else:
            raise ValueError(f&#34;Variable &#39;{var_name}&#39; is undefined in the template.&#34;)


class dscript:
    &#34;&#34;&#34;
    dscript: A Dynamic Script Management Class

    The `dscript` class is designed to manage and dynamically generate multiple
    lines/items of a script, typically for use with LAMMPS or similar simulation tools.
    Each line in the script is represented as a `ScriptTemplate` object, and the
    class provides tools to easily manipulate, concatenate, and execute these
    script lines/items.

    Key Features:
    -------------
    - **Dynamic Script Generation**: Define and manage script lines/items dynamically,
      with variables that can be substituted at runtime.
    - **Conditional Execution**: Add conditions to script lines/items so they are only
      included if certain criteria are met.
    - **Script Concatenation**: Combine multiple script objects while maintaining
      control over variable precedence and script structure.
    - **User-Friendly Access**: Easily access and manipulate script lines/items using
      familiar Python constructs like indexing and iteration.

    Practical Use Cases:
    --------------------
    - **Custom LAMMPS Scripts**: Generate complex simulation scripts with varying
      parameters based on dynamic conditions.
    - **Automation**: Automate the creation of scripts for batch processing,
      simulations, or other repetitive tasks.
    - **Script Management**: Manage and version-control different script sections
      and configurations easily.

    Methods:
    --------
    __init__(self, name=None):
        Initializes a new `dscript` object with an optional name.

    __getitem__(self, key):
        Retrieves a script line by its key. If a list of keys is provided,
        returns a new `dscript` object with lines/items reordered accordingly.

    __setitem__(self, key, value):
        Adds or updates a script line. If the value is an empty list, the
        corresponding script line is removed.

    __delitem__(self, key):
        Deletes a script line by its key.

    __contains__(self, key):
        Checks if a key exists in the script. Allows usage of `in` keyword.

    __iter__(self):
        Returns an iterator over the script lines/items, allowing for easy iteration
        through all lines/items in the `TEMPLATE`.

    __len__(self):
        Returns the number of script lines/items currently stored in the `TEMPLATE`.

    keys(self):
        Returns the keys of the `TEMPLATE` dictionary.

    values(self):
        Returns the `ScriptTemplate` objects stored as values in the `TEMPLATE`.

    items(self):
        Returns the keys and `ScriptTemplate` objects from the `TEMPLATE` as pairs.

    __str__(self):
        Returns a human-readable summary of the script, including the number
        of lines/items and total attributes. Shortcut: `str(S)`.

    __repr__(self):
        Provides a detailed string representation of the entire `dscript` object,
        including all script lines/items and their attributes. Useful for debugging.

    reorder(self, order):
        Reorders the script lines/items based on a given list of indices, creating a
        new `dscript` object with the reordered lines/items.

    get_content_by_index(self, index, do=True, protected=True):
        Returns the processed content of the script line at the specified index,
        with variables substituted based on the definitions and conditions applied.

    get_attributes_by_index(self, index):
        Returns the attributes of the script line at the specified index.

    add_dynamic_script(self, key, content=&#34;&#34;, definitions=None, verbose=None, **USER):
        Add a dynamic script step to the `dscript` object.

    createEmptyVariables(self, vars):
        Creates new variables in `DEFINITIONS` if they do not already exist.
        Accepts a single variable name or a list of variable names.

    do(self, printflag=None, verbose=None):
        Executes all script lines/items in the `TEMPLATE`, concatenating the results,
        and handling variable substitution. Returns the full script as a string.

    script(self, **userdefinitions):
        Generates a `lamdaScript` object from the current `dscript` object,
        applying any additional user definitions provided.

    pipescript(self, printflag=None, verbose=None, **USER):
        Returns a `pipescript` object by combining script objects for all keys
        in the `TEMPLATE`. Each key in `TEMPLATE` is handled separately, and
        the resulting scripts are combined using the `|` operator.

    save(self, filename=None, foldername=None, overwrite=False):
        Saves the current script instance to a text file in a structured format.
        Includes metadata, global parameters, definitions, templates, and attributes.

    write(scriptcontent, filename=None, foldername=None, overwrite=False):
        Writes the provided script content to a specified file in a given folder,
        with a header added if necessary, ensuring the correct file format.

    load(cls, filename, foldername=None, numerickeys=True):
        Loads a script instance from a text file, restoring the content, definitions,
        templates, and attributes. Handles parsing and variable substitution based on
        the structure of the file.

    parsesyntax(cls, content, numerickeys=True):
        Parses a script instance from a string input, restoring the content, definitions,
        templates, and attributes. Handles parsing and variable substitution based on the
        structure of the provided string, ensuring the correct format and key conversions
        when necessary.

    search(self, primary_key, value, foreign_key, include_global=True, multiple=&#39;first&#39;, verbose=False):
        Searches for foreign key values associated with given primary key value(s).

    list_values(self, key, include_global=True):
        Lists all unique values taken by a specified key across all steps and optionally
        in global definitions.

    var_info(self):
        Analyzes and gathers comprehensive information about variables used in the script.

    print_var_info(self, what=&#39;all&#39;, output_file=None, overwrite=False):
        Prints or saves a neatly formatted table of variable information based on the analysis from `var_info()`.


    Example:
    --------
    # Create a dscript object
    R = dscript(name=&#34;MyScript&#34;)

    # Define global variables (DEFINITIONS)
    R.DEFINITIONS.dimension = 3
    R.DEFINITIONS.units = &#34;$si&#34;

    # Add script lines
    R[0] = &#34;dimension    ${dimension}&#34;
    R[1] = &#34;units        ${units}&#34;

    # Generate and print the script
    sR = R.script()
    print(sR.do())

    Attributes:
    -----------
    name : str
        The name of the script, useful for identification.
    TEMPLATE : dict
        A dictionary storing script lines/items, with keys to identify each line.
    DEFINITIONS : lambdaScriptdata
        Stores the variables and parameters used within the script lines/items.
    &#34;&#34;&#34;

    # Class variable to list attributes that should not be treated as TEMPLATE entries
    construction_attributes = {&#39;name&#39;, &#39;SECTIONS&#39;, &#39;section&#39;, &#39;position&#39;, &#39;role&#39;, &#39;description&#39;,
                               &#39;userid&#39;, &#39;verbose&#39;, &#39;printflag&#39;, &#39;DEFINITIONS&#39;, &#39;TEMPLATE&#39;,
                               &#39;version&#39;,&#39;license&#39;,&#39;email&#39;
                               }

    def __init__(self,  name=None,
                        SECTIONS = [&#34;DYNAMIC&#34;],
                        section = 0,
                        position = None,
                        role = &#34;dscript instance&#34;,
                        description = &#34;dynamic script&#34;,
                        userid = &#34;dscript&#34;,
                        version = None,
                        license = None,
                        email = None,
                        printflag = False,
                        verbose = False,
                        verbosity = None,
                        **userdefinitions
                        ):
        &#34;&#34;&#34;
        Initializes a new `dscript` object.

        The constructor sets up a new `dscript` object, which allows you to
        define and manage a script composed of multiple lines/items. Each line is
        stored in the `TEMPLATE` dictionary, and variables used in the script
        are stored in `DEFINITIONS`.

        Parameters:
        -----------
        name : str, optional
            The name of the script. If no name is provided, a random name will
            be generated automatically. The name is useful for identifying the
            script, especially when managing multiple scripts.

        Example:
        --------
        # Create a dscript object with a specific name
        R = dscript(name=&#34;ExampleScript&#34;)

        # Or create a dscript object with a random name
        R = dscript()

        After initialization, you can start adding script lines/items and defining variables.
        &#34;&#34;&#34;

        if name is None:
            self.name = autoname()
        else:
            self.name = name

        if (version is None) or (license is None) or (email is None):
            metadata = get_metadata()               # retrieve all metadata
            version = metadata[&#34;version&#34;] if version is None else version
            license = metadata[&#34;license&#34;] if license is None else license
            email = metadata[&#34;email&#34;] if email is None else email
        self.SECTIONS = SECTIONS if isinstance(SECTIONS,(list,tuple)) else [SECTIONS]
        self.section = section
        self.position = position if position is not None else 0
        self.role = role
        self.description = description
        self.userid = userid
        self.version = version
        self.license = license
        self.email = email
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.DEFINITIONS = lambdaScriptdata(**userdefinitions)
        self.TEMPLATE = {}

    def __getattr__(self, attr):
        # During construction phase, we only access the predefined attributes
        if &#39;TEMPLATE&#39; not in self.__dict__:
            if attr in self.__dict__:
                return self.__dict__[attr]
            raise AttributeError(f&#34;&#39;dscript&#39; object has no attribute &#39;{attr}&#39;&#34;)

        # If TEMPLATE is initialized and attr is in TEMPLATE, return the corresponding ScriptTemplate entry
        if attr in self.TEMPLATE:
            return self.TEMPLATE[attr]

        # Fall back to internal __dict__ attributes if not in TEMPLATE
        if attr in self.__dict__:
            return self.__dict__[attr]

        raise AttributeError(f&#34;&#39;dscript&#39; object has no attribute &#39;{attr}&#39;&#34;)


    def __setattr__(self, attr, value):
        # Handle internal attributes during the construction phase
        if &#39;TEMPLATE&#39; not in self.__dict__:
            self.__dict__[attr] = value
            return

        # Handle construction attributes separately (name, TEMPLATE, USER)
        if attr in self.construction_attributes:
            self.__dict__[attr] = value
        # If TEMPLATE exists, and the attribute is intended for it, update TEMPLATE
        elif &#39;TEMPLATE&#39; in self.__dict__:
            # Convert the value to a ScriptTemplate if needed, and update the template
            if attr in self.TEMPLATE:
                # Modify the existing ScriptTemplate object for this attribute
                if isinstance(value, str):
                    self.TEMPLATE[attr].content = value
                elif isinstance(value, dict):
                    self.TEMPLATE[attr].attributes.update(value)
            else:
                # Create a new entry if it does not exist
                self.TEMPLATE[attr] = ScriptTemplate(content=value,definitions=self.DEFINITIONS,verbose=self.verbose,userid=attr)
        else:
            # Default to internal attributes
            self.__dict__[attr] = value


    def __getitem__(self, key):
        &#34;&#34;&#34;
        Implements index-based retrieval, slicing, or reordering for dscript objects.

        Parameters:
        -----------
        key : int, slice, list, or str
            - If `key` is an int, returns the corresponding template at that index.
              Supports negative indices to retrieve templates from the end.
            - If `key` is a slice, returns a new `dscript` object containing the templates in the specified range.
            - If `key` is a list, reorders the TEMPLATE based on the list of indices or keys.
            - If `key` is a string, treats it as a key and returns the corresponding template.

        Returns:
        --------
        dscript or ScriptTemplate : Depending on the type of key, returns either a new dscript object (for slicing or reordering)
                                    or a ScriptTemplate object (for direct key access).
        &#34;&#34;&#34;
        # Handle list-based reordering
        if isinstance(key, list):
            return self.reorder(key)

        # Handle slicing
        elif isinstance(key, slice):
            new_dscript = deepduplicate(self)
            new_dscript.name = f&#34;{self.name}_slice_{key.start}_{key.stop}&#34;
            keys = list(self.TEMPLATE.keys())
            sliced_keys = keys[key]
            new_dscript.TEMPLATE = {k: self.TEMPLATE[k] for k in sliced_keys}
            return new_dscript

        # Handle integer indexing with support for negative indices
        elif isinstance(key, int):
            keys = list(self.TEMPLATE.keys())
            if key in self.TEMPLATE:  # Check if the integer exists as a key
                return self.TEMPLATE[key]
            if key &lt; 0:  # Support negative indices
                key += len(keys)
            if key &lt; 0 or key &gt;= len(keys):  # Check for index out of range
                raise IndexError(f&#34;Index {key - len(keys)} is out of range&#34;)
            # Return the template corresponding to the integer index
            return self.TEMPLATE[keys[key]]

        # Handle key-based access (string keys)
        elif isinstance(key, str):
            if key in self.TEMPLATE:
                return self.TEMPLATE[key]
            raise KeyError(f&#34;Key &#39;{key}&#39; does not exist in TEMPLATE.&#34;)


    def __setitem__(self, key, value):
        if (value == []) or (value is None):
            # If the value is an empty list, delete the corresponding key
            del self.TEMPLATE[key]
        else:
            # Otherwise, set the key to the new ScriptTemplate
            self.TEMPLATE[key] = ScriptTemplate(value, definitions=self.DEFINITIONS, verbose=self.verbose, userid=key)

    def __delitem__(self, key):
        del self.TEMPLATE[key]

    def __iter__(self):
        return iter(self.TEMPLATE.items())

    # def keys(self):
    #     return self.TEMPLATE.keys()

    # def values(self):
    #     return (s.content for s in self.TEMPLATE.values())

    def __contains__(self, key):
        return key in self.TEMPLATE

    def __len__(self):
        return len(self.TEMPLATE)

    def items(self):
        return ((key, s.content) for key, s in self.TEMPLATE.items())

    def __str__(self):
        num_TEMPLATE = len(self.TEMPLATE)
        total_attributes = sum(len(s.attributes) for s in self.TEMPLATE.values())
        return f&#34;{num_TEMPLATE} TEMPLATE, {total_attributes} attributes&#34;

    def __repr__(self):
        &#34;&#34;&#34;Representation of dscript object with additional properties.&#34;&#34;&#34;
        repr_str = f&#34;dscript object ({self.name})\n&#34;
        # Add description, role, and version at the beginning
        repr_str += f&#34;id: {self.userid}\n&#34; if self.userid else &#34;&#34;
        repr_str += f&#34;Descr: {self.description}\n&#34; if self.description else &#34;&#34;
        repr_str += f&#34;Role: {self.role} (v. {self.version})\n&#34;
        repr_str += f&#39;SECTIONS {span(self.SECTIONS,&#34;,&#34;,&#34;[&#34;,&#34;]&#34;)} | index: {self.section} | position: {self.position}\n&#39;
        repr_str += f&#34;\n\n\twith {len(self.TEMPLATE)} TEMPLATE&#34;
        repr_str += &#34;s&#34; if len(self.TEMPLATE)&gt;1 else &#34;&#34;
        repr_str += f&#34; (with {len(self.DEFINITIONS)} DEFINITIONS)\n\n&#34;
        # Add TEMPLATE information
        c = 0
        for k, s in self.TEMPLATE.items():
            head = f&#34;|  idx: {c} |  key: {k}  |&#34;
            dashes = (50 - len(head)) // 2
            repr_str += &#34;-&#34; * 50 + &#34;\n&#34;
            repr_str += f&#34;{&#39;&lt;&#39; * dashes}{head}{&#39;&gt;&#39; * dashes}\n{repr(s)}\n&#34;
            c += 1
        return repr_str

    def keys(self):
        &#34;&#34;&#34;Return the keys of the TEMPLATE.&#34;&#34;&#34;
        return self.TEMPLATE.keys()

    def values(self):
        &#34;&#34;&#34;Return the ScriptTemplate objects in TEMPLATE.&#34;&#34;&#34;
        return self.TEMPLATE.values()

    def reorder(self, order):
        &#34;&#34;&#34;Reorder the TEMPLATE lines according to a list of indices.&#34;&#34;&#34;
        # Get the original items as a list of (key, value) pairs
        original_items = list(self.TEMPLATE.items())
        # Create a new dictionary with reordered scripts, preserving original keys
        new_scripts = {original_items[i][0]: original_items[i][1] for i in order}
        # Create a new dscript object with reordered scripts
        reordered_script = dscript()
        reordered_script.TEMPLATE = new_scripts
        return reordered_script


    def get_content_by_index(self, index, do=True, protected=True):
        &#34;&#34;&#34;
        Returns the content of the ScriptTemplate at the specified index.

        Parameters:
        -----------
        index : int
            The index of the template in the TEMPLATE dictionary.
        do : bool, optional (default=True)
            If True, the content will be processed based on conditions and evaluation flags.
        protected : bool, optional (default=True)
            Controls whether variable evaluation is protected (e.g., prevents overwriting certain definitions).

        Returns:
        --------
        str or list of str
            The content of the template after processing, or an empty string if conditions or evaluation flags block it.
        &#34;&#34;&#34;
        key = list(self.TEMPLATE.keys())[index]
        s = self.TEMPLATE[key].content
        att = self.TEMPLATE[key].attributes
        # Return an empty string if the facultative attribute is True and do is True
        if att[&#34;facultative&#34;] and do:
            return &#34;&#34;
        # Evaluate the condition (if any)
        if att[&#34;condition&#34;] is not None:
            cond = eval(self.DEFINITIONS.formateval(att[&#34;condition&#34;], protected))
        else:
            cond = True
        # If the condition is met, process the content
        if cond:
            # Apply formateval only if the eval attribute is True and do is True
            if att[&#34;eval&#34;] and do:
                if isinstance(s, list):
                    # Apply formateval to each item in the list if s is a list
                    return [self.DEFINITIONS.formateval(line, protected) for line in s]
                else:
                    # Apply formateval to the single string content
                    return self.DEFINITIONS.formateval(s, protected)
            else:
                return s  # Return the raw content if no evaluation is needed
        elif do:
            return &#34;&#34;  # Return an empty string if the condition is not met and do is True
        else:
            return s  # Return the raw content if do is False


    def get_attributes_by_index(self, index):
        &#34;&#34;&#34; Returns the attributes of the ScriptTemplate at the specified index.&#34;&#34;&#34;
        key = list(self.TEMPLATE.keys())[index]
        return self.TEMPLATE[key].attributes


    def __add__(self, other):
        &#34;&#34;&#34;
        Concatenates two dscript objects, creating a new dscript object that combines
        the TEMPLATE and DEFINITIONS of both. This operation avoids deep copying
        of definitions by creating a new lambdaScriptdata instance from the definitions.

        when other is not a dscript, self is converted into a script before being combined with +

        Parameters:
        -----------
        other : dscript, script, scriptobjectgroup, pipescript
            The other dscript object to concatenate with the current one.

        Returns:
        --------
        result : dscript (or a script)
            A new dscript object with the concatenated TEMPLATE and merged DEFINITIONS.
            A script object is returned when other is not a dscript object.

        Raises:
        -------
        TypeError:
            If the other object is not an instance of dscript, script, pipescript
        &#34;&#34;&#34;
        if isinstance(other, dscript):
            # Step 1: Merge global DEFINITIONS from both self and other
            result = dscript(name=self.name+&#34;+&#34;+other.name,**(self.DEFINITIONS + other.DEFINITIONS))
            # Step 2: Start by copying the TEMPLATE from self (no deepcopy for performance reasons)
            result.TEMPLATE = self.TEMPLATE.copy()
            # Step 3: Ensure that the local definitions for `self.TEMPLATE` are properly copied
            for key, value in self.TEMPLATE.items():
                result.TEMPLATE[key].definitions = lambdaScriptdata(**self.TEMPLATE[key].definitions)
            # Step 4: Track the next available index if keys need to be created
            next_index = len(result.TEMPLATE)
            # Step 5: Add items from the other dscript object, updating or generating new keys as needed
            for key, value in other.TEMPLATE.items():
                if key in result.TEMPLATE:
                    # If key already exists in result, assign a new unique index
                    while next_index in result.TEMPLATE:
                        next_index += 1
                    new_key = next_index
                else:
                    # Use the original key if it doesn&#39;t already exist
                    new_key = key
                # Copy the TEMPLATE&#39;s content and definitions from `other`
                result.TEMPLATE[new_key] = value
                # Merge the local TEMPLATE definitions from `other`
                result.TEMPLATE[new_key].definitions = lambdaScriptdata(**other.TEMPLATE[key].definitions)
            return result
        elif isinstance(other,(script,scriptobjectgroup)):
            return self.script() + other
        elif isinstance(other,pipescript):
            return self.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | other
        else:
            raise TypeError(f&#34;Cannot concatenate &#39;dscript&#39; with &#39;{type(other).__name__}&#39;&#34;)


    def __or__(self, other):
        &#34;&#34;&#34;
        Pipes a dscript object with other objects.
        When other is a dscript object, both objects are concatenated (+) before being converted into a pipescript object
        When other is a script, pipescript or scriptobjectgroup, self is converted into a pipescript

        Parameters:
        -----------
        other : dscript, script, scriptobjectgroup, pipescript
            The other dscript object to concatenate with the current one.

        Returns:
        --------
        result : a pipescript

        Raises:
        -------
        TypeError:
            If the other object is not an instance of dscript, script, pipescript
        &#34;&#34;&#34;
        if isinstance(other, dscript):
            tmp = self + other
            return tmp.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(other,(script,pipescript)):
            return self.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | other
        elif isinstance(other,scriptobjectgroup):
            return self.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | other.script()
        else:
            raise TypeError(f&#34;Cannot pipe &#39;dscript&#39; with &#39;{type(other).__name__}&#39;&#34;)



    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extracts subobjects from the dscript based on the provided keys.

        Parameters:
        -----------
        *keys : one or more keys that correspond to the `TEMPLATE` entries.

        Returns:
        --------
        A new `dscript` object that contains only the selected script lines/items, along with
        the relevant definitions and attributes from the original object.
        &#34;&#34;&#34;
        # Create a new dscript object to store the extracted sub-objects
        result = dscript(name=f&#34;{self.name}_subobject&#34;)
        # Copy the TEMPLATE entries corresponding to the provided keys
        for key in keys:
            if key in self.TEMPLATE:
                result.TEMPLATE[key] = self.TEMPLATE[key]
            else:
                raise KeyError(f&#34;Key &#39;{key}&#39; not found in TEMPLATE.&#34;)
        # Copy the DEFINITIONS from the current object
        result.DEFINITIONS = copy.deepcopy(self.DEFINITIONS)
        # Copy other relevant attributes
        result.SECTIONS = self.SECTIONS[:]
        result.section = self.section
        result.position = self.position
        result.role = self.role
        result.description = self.description
        result.userid = self.userid
        result.version = self.version
        result.verbose = self.verbose
        result.printflag = self.printflag

        return result

    def createEmptyVariables(self, vars):
        &#34;&#34;&#34;
        Creates empty variables in DEFINITIONS if they don&#39;t already exist.

        Parameters:
        -----------
        vars : str or list of str
            The variable name or list of variable names to be created in DEFINITIONS.
        &#34;&#34;&#34;
        if isinstance(vars, str):
            vars = [vars]  # Convert single variable name to list for uniform processing
        for varname in vars:
            if varname not in self.DEFINITIONS:
                self.DEFINITIONS.setattr(varname,&#34;${&#34; + varname + &#34;}&#34;)


    def do(self, printflag=None, verbose=None, softrun=False, return_definitions=False,comment_chars=&#34;#%&#34;, **USER):
        &#34;&#34;&#34;
        Executes or previews all `ScriptTemplate` instances in `TEMPLATE`, concatenating their processed content.
        Allows for optional headers and footers based on verbosity settings, and offers a preliminary preview mode with `softrun`.
        Accumulates definitions across all templates if `return_definitions=True`.

        Parameters
        ----------
        printflag : bool, optional
            If `True`, enables print output during execution. Defaults to the instance&#39;s print flag if `None`.
        verbose : bool, optional
            If `True`, includes headers and footers in the output, providing additional detail.
            Defaults to the instance&#39;s verbosity setting if `None`.
        softrun : bool, optional
            If `True`, executes the script in a preliminary mode:
            - Bypasses full variable substitution for a preview of the content, useful for validating structure.
            - If `False` (default), performs full processing, including variable substitutions and evaluations.
        return_definitions : bool, optional
            If `True`, returns a tuple where the second element contains accumulated definitions from all templates.
            If `False` (default), returns only the concatenated output.
        comment_chars : str, optional (default: &#34;#%&#34;)
            A string containing characters to identify the start of a comment.
            Any of these characters will mark the beginning of a comment unless within quotes.
        **USER : keyword arguments
            Allows for the provision of additional user-defined definitions, where each keyword represents a
            definition key and the associated value represents the definition&#39;s content. These definitions
            can override or supplement template-level definitions during execution.

        Returns
        -------
        str or tuple
            - If `return_definitions=False`, returns the concatenated output of all `ScriptTemplate` instances,
              with optional headers, footers, and execution summary based on verbosity.
            - If `return_definitions=True`, returns a tuple of (`output`, `accumulated_definitions`), where
              `accumulated_definitions` contains all definitions used across templates.

        Notes
        -----
        - Each `ScriptTemplate` in `TEMPLATE` is processed individually using its own `do()` method.
        - The `softrun` mode provides a preliminary content preview without full variable substitution,
          helpful for inspecting the script structure or gathering local definitions.
        - When `verbose` is enabled, the method includes detailed headers, footers, and a summary of processed and
          ignored items, providing insight into the script&#39;s construction and variable usage.
        - Accumulated definitions from each `ScriptTemplate` are combined if `return_definitions=True`, which can be
          useful for tracking all variables and definitions applied across the templates.

        Example
        -------
        &gt;&gt;&gt; dscript_instance = dscript(name=&#34;ExampleScript&#34;)
        &gt;&gt;&gt; dscript_instance.TEMPLATE[0] = ScriptTemplate(
        ...     content=[&#34;units ${units}&#34;, &#34;boundary ${boundary}&#34;],
        ...     definitions=lambdaScriptdata(units=&#34;lj&#34;, boundary=&#34;p p p&#34;),
        ...     attributes={&#39;eval&#39;: True}
        ... )
        &gt;&gt;&gt; dscript_instance.do(verbose=True, units=&#34;real&#34;)
        # Output:
        # --------------
        # TEMPLATE &#34;ExampleScript&#34;
        # --------------
        units real
        boundary p p p
        # ---&gt; Total items: 2 - Ignored items: 0
        &#34;&#34;&#34;

        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        header = f&#34;# --------------[ TEMPLATE \&#34;{self.name}\&#34; ]--------------&#34; if verbose else &#34;&#34;
        footer = &#34;# --------------------------------------------&#34; if verbose else &#34;&#34;

        # Initialize output, counters, and optional definitions accumulator
        output = [header]
        non_empty_lines = 0
        ignored_lines = 0
        accumulated_definitions = self.DEFINITIONS if return_definitions else None

        for key, template in self.TEMPLATE.items():
            # Process each template with softrun if enabled, otherwise use full processing
            result = template.do(softrun=softrun,globaldefinitions=self.DEFINITIONS,USER=lambdaScriptdata(**USER))
            if result:
                # Apply comment removal based on verbosity
                final_result = result if verbose else remove_comments(result,comment_chars=comment_chars)
                if final_result or verbose:
                    output.append(final_result)
                    non_empty_lines += 1
                else:
                    ignored_lines += 1
                # Accumulate definitions if return_definitions is enabled
                if return_definitions:
                    accumulated_definitions += template.definitions
            else:
                ignored_lines += 1

        # Add footer summary if verbose
        nel_word = &#39;items&#39; if non_empty_lines &gt; 1 else &#39;item&#39;
        il_word = &#39;items&#39; if ignored_lines &gt; 1 else &#39;item&#39;
        footer += f&#34;\n# ---&gt; Total {nel_word}: {non_empty_lines} - Ignored {il_word}: {ignored_lines}&#34; if verbose else &#34;&#34;
        output.append(footer)

        # Concatenate output and determine return type based on return_definitions
        output_content = &#34;\n&#34;.join(output)
        return (output_content, accumulated_definitions) if return_definitions else output_content



    def script(self,printflag=None, verbose=None, verbosity=None, **USER):
        &#34;&#34;&#34;
        returns the corresponding script
        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        return lamdaScript(self,persistentfile=True, persistentfolder=None,
                           printflag=printflag, verbose=verbose,
                           **USER)

    def pipescript(self, *keys, printflag=None, verbose=None, verbosity=None, **USER):
        &#34;&#34;&#34;
        Returns a pipescript object by combining script objects corresponding to the given keys.

        Parameters:
        -----------
        *keys : one or more keys that correspond to the `TEMPLATE` entries.
        printflag : bool, optional
            Whether to enable printing of additional information.
        verbose : bool, optional
            Whether to run in verbose mode for debugging or detailed output.
        **USER : dict, optional
            Additional user-defined variables to pass into the script.

        Returns:
        --------
        A `pipescript` object that combines the script objects generated from the selected
        dscript subobjects.
        &#34;&#34;&#34;
        # Start with an empty pipescript
        # combined_pipescript = None
        # # Iterate over the provided keys to extract corresponding subobjects
        # for key in keys:
        #     # Extract the dscript subobject for the given key
        #     sub_dscript = self(key)
        #     # Convert the dscript subobject to a script object, passing USER, printflag, and verbose
        #     script_obj = sub_dscript.script(printflag=printflag, verbose=verbose, **USER)
        #     # Combine script objects into a pipescript object
        #     if combined_pipescript is None:
        #         combined_pipescript = pipescript(script_obj)  # Initialize pipescript
        #     else:
        #         combined_pipescript = combined_pipescript | script_obj  # Use pipe operator
        # if combined_pipescript is None:
        #     ValueError(&#39;The conversion to pipescript from {type{self}} falled&#39;)
        # return combined_pipescript
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity

        # Loop over all keys in TEMPLATE and combine them
        combined_pipescript = None
        localvariables = scriptdata()
        for key in self.keys():
            # Create a new dscript object with only the current key in TEMPLATE
            focused_dscript = dscript(name=f&#34;{self.name}:{key}&#34;)
            focused_dscript.TEMPLATE[key] = self.TEMPLATE[key]
            localvariables = localvariables+scriptdata(**self.TEMPLATE[key].definitions)
            focused_dscript.TEMPLATE[key].definitions = localvariables
            focused_dscript.DEFINITIONS = scriptdata(**self.DEFINITIONS)
            focused_dscript.SECTIONS = self.SECTIONS[:]
            focused_dscript.section = self.section
            focused_dscript.position = self.position
            focused_dscript.role = self.role
            focused_dscript.description = self.description
            focused_dscript.userid = self.userid
            focused_dscript.version = self.version
            focused_dscript.verbose = verbose
            focused_dscript.printflag = printflag

            # Convert the focused dscript object to a script object
            script_obj = focused_dscript.script(printflag=printflag, verbose=verbose, **USER)

            # Combine the script objects into a pipescript object using the pipe operator
            if combined_pipescript is None:
                combined_pipescript = pipescript(script_obj)  # Initialize pipescript
            else:
                combined_pipescript = combined_pipescript | pipescript(script_obj)  # Use pipe operator

        if combined_pipescript is None:
            ValueError(&#39;The conversion to pipescript from {type{self}} falled&#39;)
        return combined_pipescript


    @staticmethod
    def header(name=None, verbose=True, verbosity=None, style=2, filepath=None, version=None, license=None, email=None):
        &#34;&#34;&#34;
        Generate a formatted header for the DSCRIPT file.

        ### Parameters:
            name (str, optional): The name of the script. If None, &#34;Unnamed&#34; is used.
            verbose (bool, optional): Whether to include the header. Default is True.
            verbosity (int, optional): Verbosity level. Overrides `verbose` if specified.
            style (int, optional): ASCII style for the header (default=2).
            filepath (str, optional): Full path to the file being saved. If None, the line mentioning the file path is excluded.
            version (str, optional): DSCRIPT version. If None, it is omitted from the header.
            license (str, optional): License type. If None, it is omitted from the header.
            email (str, optional): Contact email. If None, it is omitted from the header.

        ### Returns:
            str: A formatted string representing the script&#39;s metadata and initialization details.
                 Returns an empty string if `verbose` is False.

        ### The header includes:
            - DSCRIPT version, license, and contact email, if provided.
            - The name of the script.
            - Filepath, if provided.
            - Information on where and when the script was generated.

        ### Notes:
            - If `verbosity` is specified, it overrides `verbose`.
            - Omits metadata lines if `version`, `license`, or `email` are not provided.
        &#34;&#34;&#34;
        # Resolve verbosity
        verbose = verbosity &gt; 0 if verbosity is not None else verbose
        if not verbose:
            return &#34;&#34;
        # Validate inputs
        if name is None:
            name = &#34;Unnamed&#34;
        # Prepare metadata line
        metadata = []
        if version:
            metadata.append(f&#34;v{version}&#34;)
        if license:
            metadata.append(f&#34;License: {license}&#34;)
        if email:
            metadata.append(f&#34;Email: {email}&#34;)
        metadata_line = &#34; | &#34;.join(metadata)
        # Prepare the framed header content
        lines = []
        if metadata_line:
            lines.append(f&#34;PIZZA.DSCRIPT FILE {metadata_line}&#34;)
        lines += [
            &#34;&#34;,
            f&#34;Name: {name}&#34;,
        ]
        # Add the filepath line if filepath is not None
        if filepath:
            lines.append(f&#34;Path: {filepath}&#34;)
        lines += [
            &#34;&#34;,
            f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
            f&#34;{datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
        ]
        # Use the shared frame_header function to format the framed content
        return frame_header(lines, style=style)



    # Generator
    # -----------
    def generator(self):
        &#34;&#34;&#34;
        Returns
        -------
        STR
            generated code corresponding to dscript (using dscript syntax/language).

        &#34;&#34;&#34;
        return self.save(generatoronly=True)


    # Information on variables
    # ------------------------
    def var_info(self):
        &#34;&#34;&#34;
        Analyze and gather comprehensive information about variables used in the script.

        This method performs a sophisticated analysis of both global and local variables within
        the script. It identifies variable usage, overrides, defaults, and counts the number of
        different values each variable holds across various templates.

        The analysis considers two scopes:
        - **Global:** Variables defined in the global definitions (`self.DEFINITIONS`).
        - **Local:** Variables defined within each template&#39;s definitions.

        Returns:
            dict: A dictionary named `varnfo` where each key is a variable name and the value is
                  another dictionary containing detailed information about that variable. The structure
                  of `varnfo` is as follows:

                  {
                      &#34;variable_name&#34;: {
                          &#34;value&#34;: &lt;initial_value_from_global&gt;,
                          &#34;updatedvalue&#34;: &lt;current_value_after_overrides&gt;,
                          &#34;is_default&#34;: &lt;bool&gt;,
                          &#34;first_def&#34;: &lt;template_index_or_None&gt;,
                          &#34;first_use&#34;: &lt;template_index&gt;,
                          &#34;first_val&#34;: &lt;value_at_first_use&gt;,
                          &#34;override_index&#34;: &lt;template_index_or_None&gt;,
                          &#34;is_global&#34;: &lt;bool&gt;,
                          &#34;value_counter&#34;: &lt;int&gt;
                          etc.
                      },
                      ...
                  }

                  **Field Descriptions:**
                  - `value`: Initial value of the variable from global definitions (if applicable).
                  - `updatedvalue`: Current value after any overrides in local templates.
                  - `is_default`: Indicates if the variable is set to a default value.
                  - `first_def`: The index of the first template where the variable is defined locally.
                  - `first_use`: The index of the first template where the variable is used.
                  - `first_val`: The value of the variable at its first use.
                  - `override_index`: The index of the template where the variable was overridden (if any).
                  - `is_autodef`: Flag, True if ${variable} is defined automatically as ${variable}
                  - `is_empty`: Flag,  True if the variable is empty (None,&#34;&#34;,[], etc.)
                  - `is_global`: Indicates if the variable originates from global definitions.
                  - `value_counter`: Counts the number of different values the variable has across templates.
                  - `first_use_isglobal` : Flag, True if the global value is used at first use
                  - `set_in`: Lists all template indices values where the variable is assigned/changed,
                  - `set_as`: Lists assigned values as reported in `set_in`,
                  - `values`: Lists variable changes (template index, refvalue),
                  - `used_in`: Lists template indices where the variable is used

        Raises:
            AttributeError: If `self.DEFINITIONS` does not have the specified key.
        &#34;&#34;&#34;

        start_time = time.time()  # Start the timer

        # Initialize definitions with self.DEFINITIONS
        allvars = self.DEFINITIONS

        # Temporary dictionary to track global variable information
        varnfo = {}

        # Loop over each template item to detect and record variable usage and overrides
        for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
            # Detect variables used in this template
            used_variables = script_template.detect_variables()

            # Check each variable used in this template
            for var in used_variables:
                # Get global and local values for the variable
                global_value = getattr(allvars, var, None)
                local_value = getattr(script_template.definitions, var, None)
                is_autodef = global_value == f&#34;${{{var}}}&#34;
                is_global = var in allvars  # Check if the variable originates in global space
                is_empty = global_value in (None,&#34;&#34;,[],[&#34;&#34;])
                is_default = is_global and (is_empty or is_autodef)

                # If the variable is not yet tracked, initialize its info
                if var not in varnfo:
                    initialcounter = 1 if local_value is None or local_value==global_value else 2
                    first_use_isglobal = initialcounter==1
                    refvalue = global_value if first_use_isglobal else local_value
                    override_index = template_index if ((local_value is not None) and not first_use_isglobal and not is_default) else None
                    varnfo[var] = {
                        &#34;value&#34;: refvalue,        # Initial value from allvars if exists
                        &#34;updatedvalue&#34;: refvalue, # Initial value from allvars if exists
                        &#34;is_default&#34;: is_default,     # Check if it’s set to a default value
                        &#34;first_def&#34;: None,            # First definition (to be updated later)
                        &#34;first_use&#34;: template_index,  # First time the variable is used
                        &#34;first_val&#34;: refvalue,        # First value
                        &#34;override_index&#34;: override_index,  # Set override if defined locally
                        &#34;is_autodef&#34;: is_autodef,     # automatic definition ${variable}
                        &#34;is_empty&#34;: is_empty,         # Track if the variable is empty (None,&#34;&#34;,[], etc.)
                        &#34;is_global&#34;: is_global,       # Track if the variable originates as global
                        &#34;value_counter&#34;: initialcounter, # Count the number of different values
                        &#34;first_use_isglobal&#34;: first_use_isglobal, # True if the global value is used at first use
                        &#34;set_in&#34;: [template_index],
                        &#34;set_as&#34;: [refvalue],
                        &#34;values&#34;:[(template_index, refvalue)],
                        &#34;used_in&#34;: [template_index]
                    }
                else:
                    # Update `override_index` if the variable is defined locally and its value changes
                    varnfo[var][&#34;used_in&#34;].append(template_index)
                    if local_value is not None:
                        # Check if the local value differs from the tracked value in varnfo
                        current_value = varnfo[var][&#34;updatedvalue&#34;] # varnfo[var][&#34;value&#34;]
                        if current_value != local_value:
                            varnfo[var][&#34;override_index&#34;] = template_index
                            varnfo[var][&#34;updatedvalue&#34;] = local_value  # Update the tracked value
                            varnfo[var][&#34;value_counter&#34;] += 1
                            varnfo[var][&#34;set_in&#34;].append(template_index)
                            varnfo[var][&#34;set_as&#34;].append(local_value)
                            varnfo[var][&#34;values&#34;].append((template_index, local_value))

        # Second loop: Update `first_def` for all variables
        for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
            local_definitions = script_template.definitions.keys()
            for var in local_definitions:
                if var in varnfo and varnfo[var][&#34;first_def&#34;] is None:
                    varnfo[var][&#34;first_def&#34;] = template_index
                    varnfo[var][&#34;first_val&#34;] = getattr(script_template.definitions, var)

        execution_time = time.time() - start_time  # Calculate the execution time in seconds

        if self.verbose:
            print(f&#34;Variable analysis completed in {execution_time:.4f} seconds.&#34;)

        return varnfo


    def print_var_info(self, what=&#39;all&#39;, output_file=None, overwrite=False):
        &#34;&#34;&#34;
        Print or save a neatly formatted table of variable information based on the analysis from `var_info()`.

        This method retrieves variable information using the `var_info()` method and presents it in a
        Markdown-compatible table or an HTML table. Users can choose to display information for all variables
        or a specific subset by providing a list of variable names. Additionally, users can opt to save the
        table to a file with options to control file extension, path validity, and overwrite behavior.

        Parameters
        ----------
        what : str or list of str, optional
            Specifies which variables&#39; information to print.
            - If set to &#39;all&#39; (default), information for all variables is displayed.
            - If set to a list of variable names, only those variables are displayed.

        output_file : str, optional
            The path to the file where the table will be saved.
            - If set to `None` (default), the table is printed to the console.
            - If a file path is provided, the table is saved to the specified file.

        overwrite : bool, default=False
            Determines whether to overwrite the file if it already exists.
            - If `False` and the file exists, a `FileExistsError` is raised.
            - If `True`, the existing file is overwritten.

        Raises
        ------
        ValueError
            - If `what` is neither `&#39;all&#39;` nor a list of strings.
            - If the file extension is neither `.md`, `.txt`, nor `.html`.
        FileNotFoundError
            If the specified directory in `output_file` does not exist.
        PermissionError
            If the specified path is not writable.
        FileExistsError
            If the file exists and `overwrite` is set to `False`.
        IOError
            If an error occurs during file writing.
        &#34;&#34;&#34;
        # Retrieve the variable information dictionary
        varnfo = self.var_info()

        # Determine which variables to display
        if what == &#39;all&#39;:
            variables_to_print = list(varnfo.keys())
        elif isinstance(what, list):
            # Ensure all items in the list are strings
            if not all(isinstance(var, str) for var in what):
                raise ValueError(&#34;All items in the &#39;what&#39; list must be strings representing variable names.&#34;)
            variables_to_print = what
        else:
            raise ValueError(&#34;Parameter &#39;what&#39; must be either &#39;all&#39; or a list of variable names.&#34;)

        # Filter out variables that are not present in varnfo
        missing_vars = [var for var in variables_to_print if var not in varnfo]
        if missing_vars:
            print(f&#34;Warning: The following variables were not found and will be skipped: {missing_vars}&#34;)
            # Remove missing variables from the list
            variables_to_print = [var for var in variables_to_print if var in varnfo]

        if not variables_to_print:
            print(&#34;No variables to display.&#34;)
            return

        # Define the headers based on varnfo fields
        headers = [
            &#34;Variable Name&#34;,
            &#34;Value&#34;,
            &#34;Updated Value&#34;,
            &#34;Is Default&#34;,
            &#34;First Def&#34;,
            &#34;First Use&#34;,
            &#34;First Val&#34;,
            &#34;Override Index&#34;,
            &#34;Is Autodef&#34;,
            &#34;Is Empty&#34;,
            &#34;Is Global&#34;,
            &#34;Value Counter&#34;,
            &#34;First Use IsGlobal&#34;,
            &#34;Set In&#34;,
            &#34;Set As&#34;,
            &#34;Values&#34;,
            &#34;Used In&#34;
        ]

        # Initialize a list to hold all rows
        table_rows = []

        # Populate the table rows with variable information
        for var in variables_to_print:
            info = varnfo[var]
            row = [
                var,
                self._format_field(info.get(&#34;value&#34;)),
                self._format_field(info.get(&#34;updatedvalue&#34;)),
                self._format_field(info.get(&#34;is_default&#34;)),
                self._format_field(info.get(&#34;first_def&#34;)),
                self._format_field(info.get(&#34;first_use&#34;)),
                self._format_field(info.get(&#34;first_val&#34;)),
                self._format_field(info.get(&#34;override_index&#34;)),
                self._format_field(info.get(&#34;is_autodef&#34;)),
                self._format_field(info.get(&#34;is_empty&#34;)),
                self._format_field(info.get(&#34;is_global&#34;)),
                self._format_field(info.get(&#34;value_counter&#34;)),
                self._format_field(info.get(&#34;first_use_isglobal&#34;)),
                self._format_list(info.get(&#34;set_in&#34;)),
                self._format_list(info.get(&#34;set_as&#34;)),
                self._format_values(info.get(&#34;values&#34;)),
                self._format_list(info.get(&#34;used_in&#34;))
            ]
            table_rows.append(row)

        # Calculate the maximum width for each column
        column_widths = [len(header) for header in headers]
        for row in table_rows:
            for idx, cell in enumerate(row):
                cell_length = len(str(cell))
                if cell_length &gt; column_widths[idx]:
                    column_widths[idx] = cell_length

        # Build the Markdown table
        # Header row
        header_row = &#34;| &#34; + &#34; | &#34;.join(f&#34;{header.ljust(column_widths[idx])}&#34; for idx, header in enumerate(headers)) + &#34; |&#34;
        # Separator row
        separator_row = &#34;|-&#34; + &#34;-|-&#34;.join(&#39;-&#39; * column_widths[idx] for idx in range(len(headers))) + &#34;-|&#34;
        # Data rows
        data_rows = [
            &#34;| &#34; + &#34; | &#34;.join(f&#34;{str(cell).ljust(column_widths[idx])}&#34; for idx, cell in enumerate(row)) + &#34; |&#34;
            for row in table_rows
        ]

        # Combine all parts for Markdown
        markdown_table = &#34;\n&#34;.join([header_row, separator_row] + data_rows)

        # Generate HTML table if needed
        html_table = None
        if output_file:
            _, file_extension = os.path.splitext(output_file)
            file_extension = file_extension.lower()

            if file_extension not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;, &#39;&#39;]:
                raise ValueError(&#34;File extension must be either &#39;.md&#39;, &#39;.txt&#39;, or &#39;.html&#39;.&#34;)

            if file_extension == &#39;&#39;:
                # Default to .md
                output_file += &#39;.md&#39;
                file_extension = &#39;.md&#39;

            # Extract directory from the output_file path
            directory = os.path.dirname(os.path.abspath(output_file))
            if directory and not os.path.exists(directory):
                raise FileNotFoundError(f&#34;The directory &#39;{directory}&#39; does not exist.&#34;)

            if directory and not os.access(directory, os.W_OK):
                raise PermissionError(f&#34;The directory &#39;{directory}&#39; is not writable.&#34;)

            # Check if the file exists
            if os.path.exists(output_file) and not overwrite:
                raise FileExistsError(f&#34;The file &#39;{output_file}&#39; already exists and overwrite is set to False.&#34;)

            # Prepare title and timestamp
            timestamp = datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
            title = f&#34;{self.name} - Variable Information&#34;
            subtitle = f&#34;Generated on {timestamp} by {self.userid}&#34;

            if file_extension == &#39;.html&#39;:
                # Build HTML table with embedded CSS
                html_table = self._build_html_table(headers, table_rows, column_widths, title, subtitle)
            else:
                # For Markdown and TXT, prepare content with title and timestamp
                content = f&#34;# {title}\n\n&#34;
                content += f&#34;**{subtitle}**\n\n&#34;
                content += markdown_table + &#34;\n&#34;

        # If output_file is not specified, print to console
        if output_file is None:
            # Print title and timestamp
            timestamp = datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
            title = f&#34;{self.name} - Variable Information&#34;
            subtitle = f&#34;Generated on {timestamp} by {self.userid}&#34;
            print(f&#34;### {title}\n&#34;)
            print(f&#34;**{subtitle}**\n&#34;)
            # Print the Markdown table
            print(markdown_table)
        else:
            # Save to file based on extension
            try:
                if file_extension in [&#39;.md&#39;, &#39;.txt&#39;]:
                    # Prepare content with title and timestamp
                    content = f&#34;# {title}\n\n&#34;
                    content += f&#34;**{subtitle}**\n\n&#34;
                    content += markdown_table + &#34;\n&#34;

                    # Write to file
                    with open(output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                        f.write(content)
                    print(f&#34;Variable information successfully written to &#39;{output_file}&#39;.&#34;)
                elif file_extension == &#39;.html&#39;:
                    # Write HTML content
                    with open(output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                        f.write(html_table)
                    print(f&#34;Variable information successfully written to &#39;{output_file}&#39;.&#34;)
            except IOError as e:
                raise IOError(f&#34;An error occurred while writing to the file: {e}&#34;)

    def _build_html_table(self, headers, table_rows, column_widths, title, subtitle):
        &#34;&#34;&#34;
        Helper method to build an HTML table with embedded CSS.

        Parameters
        ----------
        headers : list of str
            The table headers.
        table_rows : list of list
            The table data rows.
        column_widths : list of int
            The maximum width for each column.
        title : str
            The title of the table.
        subtitle : str
            The subtitle containing timestamp and user information.

        Returns
        -------
        str
            The complete HTML content as a string.
        &#34;&#34;&#34;
        # Define CSS styles for the HTML table
        css_styles = &#34;&#34;&#34;
        &lt;style&gt;
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
            }
            h1 {
                text-align: center;
            }
            h2 {
                text-align: center;
                color: gray;
            }
            .table-container {
                overflow-x: auto;
                max-height: 2400px;
                overflow-y: auto;
                border: 1px solid #ddd;
                padding: 10px;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                table-layout: fixed;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                word-wrap: break-word;
            }
            tr:nth-child(even){background-color: #f2f2f2;}
            tr:hover {background-color: #ddd;}
            th {
                padding-top: 12px;
                padding-bottom: 12px;
                text-align: left;
                background-color: #4CAF50;
                color: white;
            }
        &lt;/style&gt;
        &#34;&#34;&#34;

        # Start building HTML content
        html_content = f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;{title}&lt;/title&gt;\n{css_styles}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;

        # Add title and subtitle
        html_content += f&#34;&lt;h1&gt;{title}&lt;/h1&gt;\n&#34;
        html_content += f&#34;&lt;h2&gt;{subtitle}&lt;/h2&gt;\n&#34;

        # Add table container
        html_content += &#34;&lt;div class=&#39;table-container&#39;&gt;\n&#34;

        # Start table
        html_content += &#34;&lt;table&gt;\n&#34;

        # Header row
        html_content += &#34;  &lt;tr&gt;\n&#34;
        for header in headers:
            html_content += f&#34;    &lt;th&gt;{header}&lt;/th&gt;\n&#34;
        html_content += &#34;  &lt;/tr&gt;\n&#34;

        # Data rows
        for row in table_rows:
            html_content += &#34;  &lt;tr&gt;\n&#34;
            for cell in row:
                html_content += f&#34;    &lt;td&gt;{self._escape_html(str(cell))}&lt;/td&gt;\n&#34;
            html_content += &#34;  &lt;/tr&gt;\n&#34;

        # End table and container
        html_content += &#34;&lt;/table&gt;\n&lt;/div&gt;\n&#34;

        # End body and html
        html_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

        return html_content

    def _escape_html(self, text):
        &#34;&#34;&#34;
        Helper method to escape HTML special characters in text.

        Parameters
        ----------
        text : str
            The text to escape.

        Returns
        -------
        str
            The escaped text.
        &#34;&#34;&#34;
        import html
        return html.escape(text)

    def _format_field(self, field):
        &#34;&#34;&#34;
        Helper method to format individual fields for the table.

        Parameters
        ----------
        field : Any
            The field value to format.

        Returns
        -------
        str
            The formatted string representation of the field.
        &#34;&#34;&#34;
        if field is None:
            return &#34;None&#34;
        elif isinstance(field, bool):
            return &#34;True&#34; if field else &#34;False&#34;
        else:
            return str(field)

    def _format_list(self, lst):
        &#34;&#34;&#34;
        Helper method to format list-type fields for the table.

        Parameters
        ----------
        lst : list or None
            The list to format.

        Returns
        -------
        str
            Comma-separated string of list items or an empty string if the list is None or empty.
        &#34;&#34;&#34;
        if not lst:
            return &#34;&#34;
        return &#34;, &#34;.join(str(item) for item in lst)

    def _format_values(self, values):
        &#34;&#34;&#34;
        Helper method to format the &#39;values&#39; field, which is a list of tuples.

        Parameters
        ----------
        values : list of tuples or None
            The list of (template_index, value) tuples.

        Returns
        -------
        str
            Comma-separated string of &#34;template_index: value&#34; pairs or an empty string if None or empty.
        &#34;&#34;&#34;
        if not values:
            return &#34;&#34;
        return &#34;, &#34;.join(f&#34;{idx}: {val}&#34; for idx, val in values)

    # ... [Other existing methods] ...



    # Save Method
    # -----------
    def save(self, filename=None, foldername=None, overwrite=False, generatoronly=False, onlyusedvariables=True):
        &#34;&#34;&#34;
        Save the current script instance to a text file.

        Parameters
        ----------
        filename : str, optional
            The name of the file to save the script to. If not provided, `self.name` is used.
            The extension &#34;.txt&#34; is automatically appended if not included.

        foldername : str, optional
            The directory where the file will be saved. If not provided, it defaults to the system&#39;s
            temporary directory. If the filename does not include a full path, this folder will be used.

        overwrite : bool, default=True
            Whether to overwrite the file if it already exists. If set to False, an exception is raised
            if the file exists.

        generatoronly : bool, default=False
            If True, the method returns the generated content string without saving to a file.

        onlyusedvariables : bool, default=True
            If True, local definitions are only saved if they are used within the template content.
            If False, all local definitions are saved, regardless of whether they are referenced in
            the template.

        Raises
        ------
        FileExistsError
            If the file already exists and `overwrite` is set to False.

        Notes
        -----
        - The script is saved in a plain text format, and each section (global parameters, definitions,
          template, and attributes) is written in a structured format with appropriate comments.
        - If `self.name` is used as the filename, it must be a valid string that can serve as a file name.
        - The file structure follows the format:
            # DSCRIPT SAVE FILE
            # generated on YYYY-MM-DD on user@hostname

            # GLOBAL PARAMETERS
            { ... }

            # DEFINITIONS (number of definitions=...)
            key=value

            # TEMPLATES (number of items=...)
            key: template_content

            # ATTRIBUTES (number of items with explicit attributes=...)
            key:{attr1=value1, attr2=value2, ...}
        &#34;&#34;&#34;
        # At the beginning of the save method
        start_time = time.time()  # Start the timer

        if not generatoronly:
            # Use self.name if filename is not provided
            if filename is None:
                filename = span(self.name, sep=&#34;\n&#34;)

            # Ensure the filename ends with &#39;.txt&#39;
            if not filename.endswith(&#39;.txt&#39;):
                filename += &#39;.txt&#39;

            # Construct the full path
            if foldername in [None, &#34;&#34;]:  # Handle cases where foldername is None or an empty string
                filepath = os.path.abspath(filename)
            else:
                filepath = os.path.join(foldername, filename)

            # Check if the file already exists, and raise an exception if it does and overwrite is False
            if os.path.exists(filepath) and not overwrite:
                raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

        # Header with current date, username, and host
        header = &#34;# DSCRIPT SAVE FILE\n&#34;
        header += &#34;\n&#34;*2
        if generatoronly:
            header += dscript.header(verbose=True,filepath=&#39;dynamic code generation (no file)&#39;,
                                     name = self.name, version=self.version, license=self.license, email=self.email)
        else:
            header += dscript.header(verbose=True,filepath=filepath,
                                     name = self.name, version=self.version, license=self.license, email=self.email)
        header += &#34;\n&#34;*2

        # Global parameters in strict Python syntax
        global_params = &#34;# GLOBAL PARAMETERS (8 parameters)\n&#34;
        global_params += &#34;{\n&#34;
        global_params += f&#34;    SECTIONS = {self.SECTIONS},\n&#34;
        global_params += f&#34;    section = {self.section},\n&#34;
        global_params += f&#34;    position = {self.position},\n&#34;
        global_params += f&#34;    role = {self.role!r},\n&#34;
        global_params += f&#34;    description = {self.description!r},\n&#34;
        global_params += f&#34;    userid = {self.userid!r},\n&#34;
        global_params += f&#34;    version = {self.version},\n&#34;
        global_params += f&#34;    verbose = {self.verbose}\n&#34;
        global_params += &#34;}\n&#34;

        # Initialize definitions with self.DEFINITIONS
        #allvars = self.DEFINITIONS

        # Temporary dictionary to track global variable information
        vinfo = self.var_info()

        # Filter global definitions based on usage, overrides, and first_def
        #  and info[&#34;is_default&#34;]
        filtered_globals = {
            var: info for var, info in vinfo.items()
            if ((info[&#34;is_global&#34;]and not info[&#34;is_empty&#34;]) and (info[&#34;first_use_isglobal&#34;]) and (info[&#34;override_index&#34;] is None))
            }

        # Generate the definitions output based on filtered globals
        definitions = f&#34;\n# GLOBAL DEFINITIONS (number of definitions={len(filtered_globals)})\n&#34;
        for var, info in filtered_globals.items():
            if info[&#34;is_default&#34;] and (info[&#34;first_def&#34;]&gt;info[&#34;first_use&#34;] if info[&#34;first_def&#34;] else True):
                definitions += f&#34;{var} = ${{{var}}}  # value assumed to be defined outside this DSCRIPT file\n&#34;
            else:
                value = info[&#34;first_val&#34;]   #info[&#34;value&#34;]
                if info[&#34;is_empty&#34;]:        #value in [&#34;&#34;, None]
                    definitions += f&#39;{var} = &#34;&#34;\n&#39;
                elif isinstance(value, str):
                    safe_value = value.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;\n&#39;, &#39;\\n&#39;)
                    definitions += f&#34;{var} = {safe_value}\n&#34;
                else:
                    definitions += f&#34;{var} = {value}\n&#34;

        # Template (number of lines/items)
        printsinglecontent = False
        template = f&#34;\n# TEMPLATES (number of items={len(self.TEMPLATE)})\n&#34;
        #for key, script_template in self.TEMPLATE.items():
        for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
            # Get local template definitions and detected variables
            template_vars = script_template.definitions
            used_variables = script_template.detect_variables()
            islocal = False
            # Temporary dictionary to accumulate variables to add to allvars
            valid_local_vars = lambdaScriptdata()
            # Write template-specific definitions only if they meet the updated conditions
            for var in template_vars.keys():
                # Conditions for adding a variable to the local template and to `allvars`
                if (var in used_variables or not onlyusedvariables) \
                   and (template_index in vinfo[var][&#34;set_in&#34;]) \
                   and (var not in filtered_globals):
                # if (var in used_variables or not onlyusedvariables) and (
                #    script_template.is_variable_set_value_only(var) and
                #    (var not in allvars or getattr(template_vars, var) != getattr(allvars, var))
                #):
                    # Start local definitions section if this is the first local variable for the template
                    if not islocal:
                        template += f&#34;\n# LOCAL DEFINITIONS for key &#39;{key}&#39;\n&#34;
                        islocal = True
                    # Retrieve and process the variable value
                    # value = getattr(template_vars, var)
                    value = next((ref for idx, ref in vinfo[var][&#34;values&#34;] if idx == template_index), None)
                    if value in [&#34;&#34;, None]:
                        template += f&#39;{var} = &#34;&#34;\n&#39;  # Set empty or None values as &#34;&#34;
                    elif isinstance(value, str):
                        safe_value = value.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;\n&#39;, &#39;\\n&#39;)
                        template += f&#34;{var} = {safe_value}\n&#34;
                    else:
                        template += f&#34;{var} = {value}\n&#34;
                    # Add the variable to valid_local_vars for selective update of allvars
                    valid_local_vars.setattr(var, value)
            # Update allvars only with filtered, valid local variables
            # allvars += valid_local_vars

            # Write the template content
            if isinstance(script_template.content, list):
                if len(script_template.content) == 1:
                    # Single-line template saved as a single line
                    content_str = script_template.content[0].strip()
                    template += &#34;&#34; if printsinglecontent else &#34;\n&#34;
                    template += f&#34;{key}: {content_str}\n&#34;
                    printsinglecontent = True
                else:
                    content_str = &#39;\n    &#39;.join(script_template.content)
                    template += f&#34;\n{key}: [\n    {content_str}\n ]\n&#34;
                    printsinglecontent = False
            else:
                template += &#34;&#34; if printsinglecontent else &#34;\n&#34;
                template += f&#34;{key}: {script_template.content}\n&#34;
                printsinglecontent = True

        # Attributes (number of lines/items with explicit attributes)
        attributes = f&#34;# ATTRIBUTES (number of items with explicit attributes={len(self.TEMPLATE)})\n&#34;
        for key, script_template in self.TEMPLATE.items():
            attr_str = &#34;, &#34;.join(f&#34;{attr_name}={repr(attr_value)}&#34;
                                 for attr_name, attr_value in script_template.attributes.items())
            attributes += f&#34;{key}:{{{attr_str}}}\n&#34;

        # Combine all sections into one content
        content = header + &#34;\n&#34; + global_params + &#34;\n&#34; + definitions + &#34;\n&#34; + template + &#34;\n&#34; + attributes + &#34;\n&#34;


        # Append footer information to the content
        non_empty_lines = sum(1 for line in content.splitlines() if line.strip())  # Count non-empty lines
        execution_time = time.time() - start_time  # Calculate the execution time in seconds
        # Prepare the footer content
        footer_lines = [
            [&#34;Non-empty lines&#34;, str(non_empty_lines)],
            [&#34;Execution time (seconds)&#34;, f&#34;{execution_time:.4f}&#34;],
        ]
        # Format footer into tabular style
        footer_content = [
            f&#34;{row[0]:&lt;25} {row[1]:&lt;15}&#34; for row in footer_lines
        ]
        # Use frame_header to format footer
        footer = frame_header(
            lines=[&#34;DSCRIPT SAVE FILE generator&#34;] + footer_content,
            style=1
        )
        # Append footer to the content
        content += f&#34;\n{footer}&#34;

        if generatoronly:
            return content
        else:
            # Write the content to the file
            with open(filepath, &#39;w&#39;) as f:
                f.write(content)
            print(f&#34;\nScript saved to {filepath}&#34;)
            return filepath



    # Write Method -- added on 2024-09-05
    # ------------
    @staticmethod
    def write(scriptcontent, filename=None, foldername=None, overwrite=False):
        &#34;&#34;&#34;
        Writes the provided script content to a specified file in a given folder, with a header if necessary.

        Parameters
        ----------
        scriptcontent : str
            The content to be written to the file.

        filename : str, optional
            The name of the file. If not provided, a random name will be generated.
            The extension `.txt` will be appended if not already present.

        foldername : str, optional
            The folder where the file will be saved. If not provided, the current working directory is used.

        overwrite : bool, optional
            If False (default), raises a `FileExistsError` if the file already exists. If True, the file will be overwritten if it exists.

        Returns
        -------
        str
            The full path to the written file.

        Raises
        ------
        FileExistsError
            If the file already exists and `overwrite` is set to False.

        Notes
        -----
        - A header is prepended to the content if it does not already exist, using the `header` method.
        - The header includes metadata such as the current date, username, hostname, and file details.
        &#34;&#34;&#34;
        # Generate a random name if filename is not provided
        if filename is None:
            filename = autoname(8)  # Generates a random name of 8 letters

        # Ensure the filename ends with &#39;.txt&#39;
        if not filename.endswith(&#39;.txt&#39;):
            filename += &#39;.txt&#39;

        # Handle foldername and relative paths
        if foldername is None or foldername == &#34;&#34;:
            # If foldername is empty or None, use current working directory for relative paths
            if not os.path.isabs(filename):
                filepath = os.path.join(os.getcwd(), filename)
            else:
                filepath = filename  # If filename is absolute, use it directly
        else:
            # If foldername is provided and filename is not absolute, use foldername
            if not os.path.isabs(filename):
                filepath = os.path.join(foldername, filename)
            else:
                filepath = filename

        # Check if file already exists, raise exception if it does and overwrite is False
        if os.path.exists(filepath) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

        # Count total and non-empty lines in the content
        total_lines = len(scriptcontent.splitlines())
        non_empty_lines = sum(1 for line in scriptcontent.splitlines() if line.strip())

        # Prepare header if not already present
        if not scriptcontent.startswith(&#34;# DSCRIPT SAVE FILE&#34;):
            fname = os.path.basename(filepath)  # Extracts the filename (e.g., &#34;myscript.txt&#34;)
            name, _ = os.path.splitext(fname)   # Removes the extension, e.g., &#34;myscript&#34;
            metadata = get_metadata()           # retrieve all metadata (statically)
            header = dscript.header(name=name, verbosity=True,style=1,filepath=filepath,
                    version = metadata[&#34;version&#34;], license = metadata[&#34;license&#34;], email = metadata[&#34;email&#34;])
            # Add line count information to the header
            footer = frame_header(
                lines=[
                    f&#34;Total lines written: {total_lines}&#34;,
                    f&#34;Non-empty lines: {non_empty_lines}&#34;
                ],
                style=1
            )
            scriptcontent = header + &#34;\n&#34; + scriptcontent + &#34;\n&#34; + footer

        # Write the content to the file
        with open(filepath, &#39;w&#39;) as file:
            file.write(scriptcontent)
        return filepath



    # Load Method and its Parsing Rules -- added on 2024-09-04
    # ---------------------------------
    @classmethod
    def load(cls, filename, foldername=None, numerickeys=True, verbose=True, debug=False):
        &#34;&#34;&#34;
        Load a script instance from a text file.

        Parameters
        ----------
        filename : str
            The name of the file to load the script from. If the filename does not end with &#34;.txt&#34;,
            the extension is automatically appended.

        foldername : str, optional
            The directory where the file is located. If not provided, it defaults to the system&#39;s
            temporary directory. If the filename does not include a full path, this folder will be used.

        numerickeys : bool, default=True
            If True, numeric string keys in the template section are automatically converted into integers.
            For example, the key &#34;0&#34; would be converted into the integer 0.

        verbose : bool, default=True
            If `True`, the parser keep comments inside templates and template blocks.

        debug : bool, default=False
            If True, print parsed lines for refining/tracking the parsing of block and single lines

        Returns
        -------
        dscript
            A new `dscript` instance populated with the content of the loaded file.

        Raises
        ------
        ValueError
            If the file does not start with the correct DSCRIPT header or the file format is invalid.

        FileNotFoundError
            If the specified file does not exist.

        Notes
        -----
        - The file is expected to follow the same structured format as the one produced by the `save()` method.
        - The method processes global parameters, definitions, template lines/items, and attributes. If the file
          includes numeric keys as strings (e.g., &#34;0&#34;, &#34;1&#34;), they can be automatically converted into integers
          if `numerickeys=True`.
        - The script structure is dynamically rebuilt, and each section (global parameters, definitions,
          template, and attributes) is correctly parsed and assigned to the corresponding parts of the `dscript`
          instance.
        &#34;&#34;&#34;

        # Step 0 validate filepath
        if not filename.endswith(&#39;.txt&#39;):
            filename += &#39;.txt&#39;

        # Handle foldername and relative paths
        if foldername is None or foldername == &#34;&#34;:
            # If the foldername is empty or None, use current working directory for relative paths
            if not os.path.isabs(filename):
                filepath = os.path.join(os.getcwd(), filename)
            else:
                filepath = filename  # If filename is absolute, use it directly
        else:
            # If foldername is provided and filename is not absolute, use foldername
            if not os.path.isabs(filename):
                filepath = os.path.join(foldername, filename)
            else:
                filepath = filename

        if not os.path.exists(filepath):
            raise FileExistsError(f&#34;The file &#39;{filepath}&#39; does not exist.&#34;)

        # Read the file contents
        with open(filepath, &#39;r&#39;) as f:
            content = f.read()

        # Call parsesyntax to parse the file content
        fname = os.path.basename(filepath)  # Extracts the filename (e.g., &#34;myscript.txt&#34;)
        name, _ = os.path.splitext(fname)   # Removes the extension, e.g., &#34;myscript
        return cls.parsesyntax(content, name=name, numerickeys=numerickeys, verbose=verbose, debug=debug)



    # Load Method and its Parsing Rules -- added on 2024-09-04
    # ---------------------------------
    @classmethod
    def parsesyntax(cls, content, name=None, numerickeys=True, verbose=False, authentification=True,
                    debug=False, comment_chars=&#34;#%&#34;,continuation_marker=&#34;...&#34;):
        &#34;&#34;&#34;
        Parse a DSCRIPT script from a string content.

        Parameters
        ----------
        content : str
            The string content of the DSCRIPT script to be parsed.

        name : str, optional
            The name of the dscript project. If `None`, a random name is generated.

        numerickeys : bool, default=True
            If `True`, numeric string keys in the template section are automatically converted into integers.

        verbose : bool, default=True
            If `True`, the parser keep comments inside templates and template blocks.

        authentification : bool, default=True
            If `True`, the parser is expected that the first non empty line is # DSCRIPT SAVE FILE

        comment_chars : str, optional (default: &#34;#%&#34;)
            A string containing characters to identify the start of a comment.
            Any of these characters will mark the beginning of a comment unless within quotes.

        continuation_marker : str, optional (default: &#34;...&#34;)
            A string containing characters to indicate line continuation
            Any characters after the continuation marker are considered comment and are theorefore ignored

        debug : bool, default=False
            Print parsed lines for refining the parsing of block lines

        Returns
        -------
        dscript
            A new `dscript` instance populated with the content of the loaded file.

        Raises
        ------
        ValueError
            If content does not start with the correct DSCRIPT header or the file format is invalid.

        Notes
        -----
        **DSCRIPT SAVE FILE FORMAT**

        This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
        and control attributes can be defined in a flexible manner.

        **Mandatory First Line:**

        Every DSCRIPT file must begin with the following line:

        ```plaintext
        # DSCRIPT SAVE FILE
        ```

        **Structure Overview:**

        1. **Global Parameters Section (Optional):**

            - This section defines global script settings, enclosed within curly braces `{}`.
            - Properties include:
                - `SECTIONS`: List of section names to be considered (e.g., `[&#34;DYNAMIC&#34;]`).
                - `section`: Current section index (e.g., `0`).
                - `position`: Current script position in the order.
                - `role`: Defines the role of the script instance (e.g., `&#34;dscript instance&#34;`).
                - `description`: A short description of the script (e.g., `&#34;dynamic script&#34;`).
                - `userid`: Identifier for the user (e.g., `&#34;dscript&#34;`).
                - `version`: Script version (e.g., `0.1`).
                - `verbose`: Verbosity flag, typically a boolean (e.g., `False`).

            **Example:**

            ```plaintext
            {
                SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;]  # Global script parameters
            }
            ```

        2. **Definitions Section:**

            - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
            - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
              to delay execution or substitution.

            **Example:**

            ```plaintext
            d = 3                               # Define a number
            periodic = &#34;$p&#34;                     # &#39;$&#39; prevents immediate evaluation of &#39;p&#39;
            units = &#34;$metal&#34;                    # &#39;$&#39; prevents immediate evaluation of &#39;metal&#39;
            dimension = &#34;${d}&#34;                  # Variable substitution
            boundary = [&#39;p&#39;, &#39;p&#39;, &#39;p&#39;]          # List with a mix of variables and values
            atom_style = &#34;$atomic&#34;              # String variable with delayed evaluation
            ```

        3. **Templates Section:**

            - This section provides a mapping between keys and their corresponding commands or instructions.
            - Each template can reference variables defined in the **Definitions** section or elsewhere, typically using the `${variable}` syntax.
            - **Syntax Variations**:

                Templates can be defined in several ways, including without blocks, with single- or multi-line blocks, and with ellipsis (`...`) as a line continuation marker.

                - **Single-line Template Without Block**:
                    ```plaintext
                    KEY: INSTRUCTION
                    ```
                    - `KEY` is the identifier for the template (numeric or alphanumeric).
                    - `INSTRUCTION` is the command or template text, which may reference variables.

                - **Single-line Template With Block**:
                    ```plaintext
                    KEY: [INSTRUCTION]
                    ```
                    - Uses square brackets (`[ ]`) around the `INSTRUCTION`, indicating that all instructions are part of the block.

                - **Multi-line Template With Block**:
                    ```plaintext
                    KEY: [
                        INSTRUCTION1
                        INSTRUCTION2
                        ...
                        ]
                    ```
                    - Begins with `KEY: [` and ends with a standalone `]` on a new line.
                    - Instructions within the block can span multiple lines, and ellipses (`...`) at the end of a line are used to indicate that the line continues, ignoring any content following the ellipsis as comments.
                    - Comments following ellipses are removed after parsing and do not become part of the block, preserving only the instructions.

                - **Multi-line Template With Continuation Marker (Ellipsis)**:
                    - For templates with complex code containing square brackets (`[ ]`), the ellipsis (`...`) can be used to prevent `]` from prematurely closing the block. The ellipsis will keep the line open across multiple lines, allowing brackets in the instructions.

                    **Example:**
                    ```plaintext
                    example1: command ${value}       # Single-line template without block
                    example2: [command ${value}]     # Single-line template with block

                    # Multi-line template with block
                    example3: [
                        command1 ${var1}
                        command2 ${var2} ...   # Line continues after ellipsis
                        command3 ${var3} ...   # Additional instruction continues
                        ]

                    # Multi-line template with ellipsis (handling square brackets)
                    example4: [
                        A[0][1] ...            # Ellipsis allows [ ] within instructions
                        B[2][3] ...            # Another instruction in the block
                        ]
                    ```

            - **Key Points**:
                - **Blocks** allow grouping of multiple instructions for a single key, enclosed in square brackets.
                - **Ellipsis (`...`)** at the end of a line keeps the line open, preventing premature closing by `]`, especially useful if the template code includes square brackets (`[ ]`).
                - **Comments** placed after the ellipsis are removed after parsing and are not part of the final block content.

            This flexibility supports both simple and complex template structures, allowing instructions to be grouped logically while keeping code and comments distinct.


        4. **Attributes Section:**

            - Each template line can have customizable attributes to control behavior and conditions.
            - Default attributes include:
                - `facultative`: If `True`, the line is optional and can be removed if needed.
                - `eval`: If `True`, the line will be evaluated with Python&#39;s `eval()` function.
                - `readonly`: If `True`, the line cannot be modified later in the script.
                - `condition`: An expression that must be satisfied for the line to be included.
                - `condeval`: If `True`, the condition will be evaluated using `eval()`.
                - `detectvar`: If `True`, this creates variables in the **Definitions** section if they do not exist.

            **Example:**

            ```plaintext
            units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
            dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
            ```

        **Note on Multiple Definitions**

        This example demonstrates how variables defined in the **Definitions** section are handled for each template.
        Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
        can use different values for the same variable if redefined.

        **Example:**

        ```plaintext
        # DSCRIPT SAVE FILE

        # Definitions
        var = 10

        # Template key1
        key1: Template content with ${var}

        # Definitions
        var = 20

        # Template key2
        key2: Template content with ${var}

        # Template key3
        key3:[
            this is an undefined variable ${var31}
            this is another undefined variable ${var32}
            this variable is defined  ${var}
        ]
        ```

        **Parsing and Usage:**

        ```python
        # Parse content using parsesyntax()
        ds = dscript.parsesyntax(content)

        # Accessing templates and their variables
        print(ds.TEMPLATE[&#39;key1&#39;].text)  # Output: Template content with 10
        print(ds.TEMPLATE[&#39;key2&#39;].text)  # Output: Template content with 20
        ```

        **Handling Undefined Variables:**

        Variables like `${var31}` and `${var32}` in `key3` are undefined. The parser will handle them based on your substitution logic or raise an error if they are required.

        **Important Notes:**

        - The parser processes the script sequentially. Definitions must appear before the templates that use them.
        - Templates capture the variable definitions at the time they are parsed. Redefining a variable affects only subsequent templates.
        - Comments outside of blocks are allowed and ignored by the parser.
        - Content within templates is treated as-is, allowing for any syntax required by the target system (e.g., LAMMPS commands).


    **Advanced Example**

        Here&#39;s a more advanced example demonstrating the use of global definitions, local definitions, templates, and how to parse and render the template content.

        ```python
        content = &#39;&#39;&#39;
            # GLOBAL DEFINITIONS
            dumpfile = $dump.LAMMPS
            dumpdt = 50
            thermodt = 100
            runtime = 5000

            # LOCAL DEFINITIONS for step &#39;0&#39;
            dimension = 3
            units = $si
            boundary = [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
            atom_style = $smd
            atom_modify = [&#39;map&#39;, &#39;array&#39;]
            comm_modify = [&#39;vel&#39;, &#39;yes&#39;]
            neigh_modify = [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
            newton = $off
            name = $SimulationBox

            # This is a comment line outside of blocks
            # ------------------------------------------

            0: [    % --------------[ Initialization Header (helper) for &#34;${name}&#34; ]--------------
                # set a parameter to None or &#34;&#34; to remove the definition
                dimension    ${dimension}
                units        ${units}
                boundary     ${boundary}
                atom_style   ${atom_style}
                atom_modify  ${atom_modify}
                comm_modify  ${comm_modify}
                neigh_modify ${neigh_modify}
                newton       ${newton}
                # ------------------------------------------
             ]
        &#39;&#39;&#39;
        # Parse the content
        ds = dscript.parsesyntax(content, verbose=True, authentification=False)

        # Access and print the rendered template
        print(&#34;Template 0 content:&#34;)
        print(ds.TEMPLATE[0].do())
        ```

        **Explanation:**

        - **Global Definitions:** Define variables that are accessible throughout the script.
        - **Local Definitions for Step &#39;0&#39;:** Define variables specific to a particular step or template.
        - **Template Block:** Identified by `0: [ ... ]`, it contains the content where variables will be substituted.
        - **Comments:** Lines starting with `#` are comments and are ignored by the parser outside of template blocks.

        **Expected Output:**

        ```
        Template 0 content:
        # --------------[ Initialization Header (helper) for &#34;SimulationBox&#34; ]--------------
        # set a parameter to None or &#34;&#34; to remove the definition
        dimension    3
        units        si
        boundary     [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
        atom_style   smd
        atom_modify  [&#39;map&#39;, &#39;array&#39;]
        comm_modify  [&#39;vel&#39;, &#39;yes&#39;]
        neigh_modify [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
        newton       off
        # ------------------------------------------
        ```

        **Notes:**

        - The `do()` method renders the template, substituting variables with their defined values.
        - Variables like `${dimension}` are replaced with their corresponding values defined in the local or global definitions.
        - The parser handles comments and blank lines appropriately, ensuring they don&#39;t interfere with the parsing logic.


        &#34;&#34;&#34;
        # Split the content into lines
        lines = content.splitlines()
        if not lines:
            raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

        # Initialize containers
        global_params = {}
        GLOBALdefinitions = lambdaScriptdata()
        LOCALdefinitions = lambdaScriptdata()
        template = {}
        attributes = {}

        # State variables
        inside_global_params = False
        global_params_content = &#34;&#34;
        inside_template_block = False
        current_template_key = None
        current_template_content = []
        current_var_value = lambdaScriptdata()

        # Initialize line number
        line_number = 0
        last_successful_line = 0

        # Step 1: Authenticate the file
        if authentification:
            auth_line_found = False
            max_header_lines = 10
            header_end_idx = -1
            for idx, line in enumerate(lines[:max_header_lines]):
                stripped_line = line.strip()
                if not stripped_line:
                    continue
                if stripped_line.startswith(&#34;# DSCRIPT SAVE FILE&#34;):
                    auth_line_found = True
                    header_end_idx = idx
                    break
                elif stripped_line.startswith(&#34;#&#34;) or stripped_line.startswith(&#34;%&#34;):
                    continue
                else:
                    raise ValueError(f&#34;Unexpected content before authentication line (# DSCRIPT SAVE FILE) at line {idx + 1}:\n{line}&#34;)
            if not auth_line_found:
                raise ValueError(&#34;File/Content is not a valid DSCRIPT file.&#34;)

            # Remove header lines
            lines = lines[header_end_idx + 1:]
            line_number = header_end_idx + 1
            last_successful_line = line_number - 1
        else:
            line_number = 0
            last_successful_line = 0

        # Process each line
        for idx, line in enumerate(lines):
            line_number += 1
            line_content = line.rstrip(&#39;\n&#39;)
            if debug: print(f&#34;RAW L{line_number}    :{line_content}\n&#34;)

            # Determine if we&#39;re inside a template block
            if inside_template_block:
                # Extract the code with its eventual continuation_marker
                code_line = remove_comments(
                        line_content,
                        comment_chars=comment_chars,
                        continuation_marker=continuation_marker,
                        remove_continuation_marker=False,
                        ).rstrip()

                # Check if line should continue
                if code_line.endswith(continuation_marker):
                    # Append line up to the continuation marker
                    endofline_index = line_content.rindex(continuation_marker)
                    trimmed_content = line_content[:endofline_index].rstrip()
                    if trimmed_content:
                        current_template_content.append(trimmed_content)
                        if debug:print(f&#34;A|DEBUG L{line_number}:{trimmed_content}\n&#34;)
                    continue
                elif code_line.endswith(&#34;]&#34;):  # End of multi-line block
                    closing_index = code_line.rindex(&#39;]&#39;)
                    trimmed_content = code_line[:closing_index].rstrip()

                    # Append any valid content before `]`, if non-empty
                    if trimmed_content:
                        current_template_content.append(trimmed_content)
                        if debug:print(f&#34;B|DEBUG L{line_number}:{trimmed_content}\n&#34;)

                    # End of template block
                    content = &#39;\n&#39;.join(current_template_content)
                    template[current_template_key] = ScriptTemplate(
                        content=content,
                        autorefresh=False,
                        definitions=LOCALdefinitions,
                        verbose=verbose,
                        userid=current_template_key)
                    # Refresh variables definitions
                    template[current_template_key].refreshvar(globaldefinitions=GLOBALdefinitions)
                    LOCALdefinitions = lambdaScriptdata()
                    # Reset state for next block
                    inside_template_block = False
                    current_template_key = None
                    current_template_content = []
                    last_successful_line = line_number
                    continue
                else:
                    # Append the entire original line content if not ending with `...` or `]`
                    current_template_content.append(line_content)
                    if debug:print(f&#34;C|DEBUG L{line_number}:{line_content}\n&#34;)

                continue

            # Not inside a template block
            stripped_no_comments = remove_comments(line_content)

            # Ignore empty lines after removing comments
            if not stripped_no_comments.strip():
                continue

            # If the original line is a comment line, skip it
            if line_content.strip().startswith(&#34;#&#34;) or line_content.strip().startswith(&#34;%&#34;):
                continue

            stripped = stripped_no_comments.strip()

            # Handle start of a new template block
            template_block_match = re.match(r&#39;^(\w+)\s*:\s*\[&#39;, stripped)
            if template_block_match:
                current_template_key = template_block_match.group(1)
                if inside_template_block:
                    # Collect error context
                    context_start = max(0, last_successful_line - 3)
                    context_end = min(len(lines), line_number + 2)
                    error_context_lines = lines[context_start:context_end]
                    error_context = &#34;&#34;
                    for i, error_line in enumerate(error_context_lines):
                        line_num = context_start + i + 1
                        indicator = &#34;&gt;&#34; if line_num == line_number else &#34;*&#34; if line_num == last_successful_line else &#34; &#34;
                        error_context += f&#34;{indicator} {line_num}: {error_line}\n&#34;

                    raise ValueError(
                        f&#34;Template block &#39;{current_template_key}&#39; starting at line {last_successful_line} (*) was not properly closed before starting a new one at line {line_number} (&gt;).\n\n&#34;
                        f&#34;Error context:\n{error_context}&#34;
                    )
                else:
                    inside_template_block = True
                    idx_open_bracket = line_content.index(&#39;[&#39;)
                    remainder = line_content[idx_open_bracket + 1:].strip()
                    if remainder:
                        remainder_code = remove_comments(remainder, comment_chars=comment_chars).rstrip()
                        if remainder_code.endswith(&#34;]&#34;):
                            closing_index = remainder_code.rindex(&#39;]&#39;)
                            content_line = remainder_code[:closing_index].strip()
                            if content_line:
                                current_template_content.append(content_line)
                                if debug:print(f&#34;D|DEBUG L{line_number}:{content_line}\n&#34;)
                            content = &#39;\n&#39;.join(current_template_content)
                            template[current_template_key] = ScriptTemplate(
                                content=content,
                                autorefresh=False,
                                definitions=LOCALdefinitions,
                                verbose=verbose,
                                userid=current_template_key)
                            template[current_template_key].refreshvar(globaldefinitions=GLOBALdefinitions)
                            LOCALdefinitions = lambdaScriptdata()
                            inside_template_block = False
                            current_template_key = None
                            current_template_content = []
                            last_successful_line = line_number
                            continue
                        else:
                            current_template_content.append(remainder)
                            if debug:print(f&#34;E|DEBUG L{line_number}:{remainder}\n&#34;)
                    last_successful_line = line_number
                continue

            # Handle start of global parameters
            if stripped.startswith(&#39;{&#39;) and not inside_global_params:
                if &#39;}&#39; in stripped:
                    global_params_content = stripped
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;
                    last_successful_line = line_number
                else:
                    inside_global_params = True
                    global_params_content = stripped
                continue

            # Handle global parameters inside {...}
            if inside_global_params:
                global_params_content += &#39; &#39; + stripped
                if &#39;}&#39; in stripped:
                    inside_global_params = False
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;
                    last_successful_line = line_number
                continue

            # Handle attributes
            attribute_match = re.match(r&#39;^(\w+)\s*:\s*\{(.+)\}&#39;, stripped)
            if attribute_match:
                key, attr_content = attribute_match.groups()
                attributes[key] = {}
                cls._parse_attributes(attributes[key], attr_content.strip())
                last_successful_line = line_number
                continue

            # Handle definitions
            definition_match = re.match(r&#39;^(\w+)\s*=\s*(.+)&#39;, stripped)
            if definition_match:
                key, value = definition_match.groups()
                convertedvalue = cls._convert_value(value)
                if key in GLOBALdefinitions:
                    if (GLOBALdefinitions.getattr(key) != convertedvalue) or \
                        (getattr(current_var_value, key) != convertedvalue):
                        LOCALdefinitions.setattr(key, convertedvalue)
                else:
                    GLOBALdefinitions.setattr(key, convertedvalue)
                last_successful_line = line_number
                setattr(current_var_value, key, convertedvalue)
                continue

            # Handle single-line templates (updated on 20250104 to handle empty content)
            template_match = re.match(r&#39;^(\w+)\s*:\s*(.*)&#39;, stripped)
            if template_match:
                key, content = template_match.groups()
                content = content.strip()  # Strip whitespace for consistency
                if not content:
                    content = f&#34;# empty &lt;step {key}&gt;&#34;
                    if debug: print(f&#34;F|DEBUG L{line_number}:Empty content detected for key: {key}, default value assigned\n&#34;)
                if debug: print(f&#34;F|DEBUG L{line_number}:{content}\n&#34;)
                template[key] = ScriptTemplate(
                    content = content,
                    autorefresh = False,
                    definitions=LOCALdefinitions,
                    verbose=verbose,
                    userid=key)
                template[key].refreshvar(globaldefinitions=GLOBALdefinitions)
                if debug:print(f&#34;G|DEBUG L{line_number}:{template[key].content}\n&#34;)
                LOCALdefinitions = lambdaScriptdata()
                last_successful_line = line_number
                continue

            # Unrecognized line
            if verbose:
                print(f&#34;Warning: Unrecognized line at {line_number}: {line_content}&#34;)
                if debug:
                    raise ValueError(f&#39;ERROR: stripped content &#34;{stripped}&#34;&#39;)
            last_successful_line = line_number
            continue

        # At the end, check if any template block was left unclosed
        if inside_template_block:
            # Collect error context
            context_start = max(0, last_successful_line - 3)
            context_end = min(len(lines), last_successful_line + 3)
            error_context_lines = lines[context_start:context_end]
            error_context = &#34;&#34;
            for i, error_line in enumerate(error_context_lines):
                line_num = context_start + i
                indicator = &#34;&gt;&#34; if line_num == last_successful_line else &#34; &#34;
                error_context += f&#34;{indicator} {line_num}: {error_line}\n&#34;

            raise ValueError(
                f&#34;Template block &#39;{current_template_key}&#39; starting at line {last_successful_line} was not properly closed.\n\n&#34;
                f&#34;Error context:\n{error_context}&#34;
            )

        # Apply attributes to templates
        for key in attributes:
            if key in template:
                for attr_name, attr_value in attributes[key].items():
                    setattr(template[key], attr_name, attr_value)
                template[key]._autorefresh = True # restore the default behavior for the end-user
            else:
                raise ValueError(f&#34;Attributes found for undefined template key: {key}&#34;)

        # Create and return new instance
        if name is None:
            name = autoname(8)
        instance = cls(
            name=name,
            SECTIONS=global_params.get(&#39;SECTIONS&#39;, [&#39;DYNAMIC&#39;]),
            section=global_params.get(&#39;section&#39;, 0),
            position=global_params.get(&#39;position&#39;, 0),
            role=global_params.get(&#39;role&#39;, &#39;dscript instance&#39;),
            description=global_params.get(&#39;description&#39;, &#39;dynamic script&#39;),
            userid=global_params.get(&#39;userid&#39;, &#39;dscript&#39;),
            version=global_params.get(&#39;version&#39;, 0.1),
            verbose=global_params.get(&#39;verbose&#39;, False)
        )

        # Convert numeric string keys to integers if numerickeys is True
        if numerickeys:
            numeric_template = {}
            for key, value in template.items():
                if key.isdigit():
                    numeric_template[int(key)] = value
                else:
                    numeric_template[key] = value
            template = numeric_template

        # Set definitions and template
        instance.DEFINITIONS = GLOBALdefinitions
        instance.TEMPLATE = template

        # Refresh variables
        instance.set_all_variables()

        # Check variables
        instance.check_all_variables(verbose=False)

        return instance




    @classmethod
    def parsesyntax_legacy(cls, content, name=None, numerickeys=True):
        &#34;&#34;&#34;
        Parse a script from a string content.
        [ ------------------------------------------------------]
        [ Legacy parsesyntax method for backward compatibility. ]
        [ ------------------------------------------------------]

        Parameters
        ----------
        content : str
            The string content of the script to be parsed.

        name : str
            The name of the dscript project (if None, it is set randomly)

        numerickeys : bool, default=True
            If True, numeric string keys in the template section are automatically converted into integers.

        Returns
        -------
        dscript
            A new `dscript` instance populated with the content of the loaded file.

        Raises
        ------
        ValueError
            If content does not start with the correct DSCRIPT header or the file format is invalid.

        Notes
        -----
        - The file is expected to follow the same structured format as the one produced by the `save()` method.
        - The method processes global parameters, definitions, template lines/items, and attributes. If the file
          includes numeric keys as strings (e.g., &#34;0&#34;, &#34;1&#34;), they can be automatically converted into integers
          if `numerickeys=True`.
        - The script structure is dynamically rebuilt, and each section (global parameters, definitions,
          template, and attributes) is correctly parsed and assigned to the corresponding parts of the `dscript`
          instance.


        PIZZA.DSCRIPT SAVE FILE FORMAT
        -------------------------------
        This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
        and control attributes can be defined in a flexible manner.

        ### Mandatory First Line:
        Every DSCRIPT file must begin with the following line:
            # DSCRIPT SAVE FILE

        ### Structure Overview:

        1. **Global Parameters Section (Optional):**
            - This section defines global script settings, enclosed within curly braces `{ }`.
            - Properties include:
                - `SECTIONS`: List of section names to be considered (e.g., `[&#34;DYNAMIC&#34;]`).
                - `section`: Current section index (e.g., `0`).
                - `position`: Current script position in the order.
                - `role`: Defines the role of the script instance (e.g., `&#34;dscript instance&#34;`).
                - `description`: A short description of the script (e.g., `&#34;dynamic script&#34;`).
                - `userid`: Identifier for the user (e.g., `&#34;dscript&#34;`).
                - `version`: Script version (e.g., `0.1`).
                - `verbose`: Verbosity flag, typically a boolean (e.g., `False`).

            Example:
            ```
            {
                SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;]  # Global script parameters
            }
            ```

        2. **Definitions Section:**
            - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
            - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
              to delay execution or substitution.

            Example:
            ```
            d = 3                               # Define a number
            periodic = &#34;$p&#34;                     # &#39;$&#39; prevents immediate evaluation of &#39;p&#39;
            units = &#34;$metal&#34;                    # &#39;$&#39; prevents immediate evaluation of &#39;metal&#39;
            dimension = &#34;${d}&#34;                  # Variable substitution
            boundary = [&#39;p&#39;, &#39;p&#39;, &#39;p&#39;]  # List with a mix of variables and values
            atom_style = &#34;$atomic&#34;              # String variable with delayed evaluation
            ```

        3. **Templates Section:**
            - This section provides a mapping between keys and their corresponding commands or instructions.
            - The templates reference variables defined in the **Definitions** section or elsewhere.
            - Syntax:
                ```
                KEY: INSTRUCTION
                ```
                where:
                - `KEY` can be numeric or alphanumeric.
                - `INSTRUCTION` represents a command template, often referring to variables using `${variable}` notation.

            Example:
            ```
            units: units ${units}               # Template uses the &#39;units&#39; variable
            dim: dimension ${dimension}         # Template for setting the dimension
            bound: boundary ${boundary}         # Template for boundary settings
            lattice: lattice ${lattice}         # Lattice template
            ```

        4. **Attributes Section:**
            - Each template line can have customizable attributes to control behavior and conditions.
            - Default attributes include:
                - `facultative`: If `True`, the line is optional and can be removed if needed.
                - `eval`: If `True`, the line will be evaluated with Python&#39;s `eval()` function.
                - `readonly`: If `True`, the line cannot be modified later in the script.
                - `condition`: An expression that must be satisfied for the line to be included.
                - `condeval`: If `True`, the condition will be evaluated using `eval()`.
                - `detectvar`: If `True`, this creates variables in the **Definitions** section if they do not exist.

            Example:
            ```
            units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
            dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
            ```

        Note on multiple definitions
        -----------------------------
        This example demonstrates how variables defined in the `Definitions` section are handled for each template.
        Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
        can use different values for the same variable if redefined.

        content = &#34;&#34; &#34;
        # DSCRIPT SAVE FILE

        # Definitions
        var = 10

        # Template ky1
        key1: Template content with ${var}

        # Definitions
        var = 20

        # Template key2
        key2: Template content with ${var}

        # Template key3
        key3:[
            this is an underfined variable ${var31}
            this is an another underfined variable ${var32}
            this variables is defined  ${var}
            ]

        &#34;&#34; &#34;

        # Parse content using parsesyntax()
        ds = dscript.parsesyntax(content)

        # Key1 should use the first definition of &#39;var&#39; (10)
        print(ds.key1.definitions.var)  # Output: Template content with 10

        # Key2 should use the updated definition of &#39;var&#39; (20)
        print(ds.key2.definitions.var)  # Output: Template content with 10


        &#34;&#34;&#34;

        # Split the content into lines
        lines = content.splitlines()
        lines = [line for line in lines if line.strip()]  # Remove blank or empty lines
        # Raise an error if no content is left after removing blank lines
        if not lines:
            raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

        # Initialize containers for global parameters, definitions, templates, and attributes
        global_params = {}
        definitions = lambdaScriptdata()
        template = {}
        attributes = {}

        # State variables to handle multi-line global parameters and attributes
        inside_global_params = False
        inside_attributes = False
        current_attr_key = None  # Ensure this is properly initialized
        global_params_content = &#34;&#34;
        inside_template_block = False  # Track if we are inside a multi-line template
        current_template_key = None    # Track the current template key
        current_template_content = []  # Store lines for the current template content

        # Step 1: Authenticate the file
        if not lines[0].strip().startswith(&#34;# DSCRIPT SAVE FILE&#34;):
            raise ValueError(&#34;File/Content is not a valid DSCRIPT file.&#34;)

        # Step 2: Process each line dynamically
        for line in lines[1:]:
            stripped = line.strip()

            # Ignore empty lines and comments
            if not stripped or stripped.startswith(&#34;#&#34;):
                continue

            # Remove trailing comments
            stripped = remove_comments(stripped)

            # Step 3: Handle global parameters inside {...}
            if stripped.startswith(&#34;{&#34;):
                # Found the opening {, start accumulating global parameters
                inside_global_params = True
                # Remove the opening { and accumulate the remaining content
                global_params_content = stripped[stripped.index(&#39;{&#39;) + 1:].strip()

                # Check if the closing } is also on the same line
                if &#39;}&#39; in global_params_content:
                    global_params_content = global_params_content[:global_params_content.index(&#39;}&#39;)].strip()
                    inside_global_params = False  # We found the closing } on the same line
                    # Now parse the global parameters block
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;  # Reset for the next block
                continue

            if inside_global_params:
                # Accumulate content until the closing } is found
                if stripped.endswith(&#34;}&#34;):
                    # Found the closing }, accumulate and process the entire block
                    global_params_content += &#34; &#34; + stripped[:stripped.index(&#39;}&#39;)].strip()
                    inside_global_params = False  # Finished reading global parameters block

                    # Now parse the entire global parameters block
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;  # Reset for the next block if necessary
                else:
                    # Continue accumulating if } is not found
                    global_params_content += &#34; &#34; + stripped
                continue

            # Step 4: Detect the start of a multi-line template block inside [...]
            if not inside_template_block:
                template_match = re.match(r&#39;(\w+)\s*:\s*\[&#39;, stripped)
                if template_match:
                    current_template_key = template_match.group(1)  # Capture the key
                    inside_template_block = True
                    current_template_content = []  # Reset content list
                    continue

            # If inside a template block, accumulate lines until we find the closing ]
            if inside_template_block:
                if stripped == &#34;]&#34;:
                    # End of the template block, join the content and store it
                    template[current_template_key] = ScriptTemplate(
                        current_template_content,
                        definitions=lambdaScriptdata(**definitions),  # Clone current global definitions
                        verbose=True,
                        userid=current_template_key
                        )
                    template[current_template_key].refreshvar()
                    inside_template_block = False
                    current_template_key = None
                    current_template_content = []
                else:
                    # Accumulate the current line (without surrounding spaces)
                    current_template_content.append(stripped)
                continue

            # Step 5: Handle attributes inside {...}
            if inside_attributes and stripped.endswith(&#34;}&#34;):
                # Finish processing attributes for the current key
                cls._parse_attributes(attributes[current_attr_key], stripped[:-1])  # Remove trailing }
                inside_attributes = False
                current_attr_key = None
                continue

            if inside_attributes:
                # Continue accumulating attributes
                cls._parse_attributes(attributes[current_attr_key], stripped)
                continue

            # Step 6: Determine if the line is a definition, template, or attribute
            definition_match = re.match(r&#39;(\w+)\s*=\s*(.+)&#39;, stripped)
            template_match = re.match(r&#39;(\w+)\s*:\s*(?!\s*\{.*\}\s*$)(.+)&#39;, stripped) # template_match = re.match(r&#39;(\w+)\s*:\s*(?!\{)(.+)&#39;, stripped)
            attribute_match = re.match(r&#39;(\w+)\s*:\s*\{\s*(.+)\s*\}&#39;, stripped)       # attribute_match = re.match(r&#39;(\w+)\s*:\s*\{(.+)\}&#39;, stripped)

            if definition_match:
                # Line is a definition (key=value)
                key, value = definition_match.groups()
                definitions.setattr(key,cls._convert_value(value))

            elif template_match and not inside_template_block:
                # Line is a template (key: content)
                key, content = template_match.groups()
                template[key] = ScriptTemplate(
                    content,
                    definitions=lambdaScriptdata(**definitions),  # Clone current definitions
                    verbose=True,
                    userid=current_template_key)
                template[key].refreshvar()

            elif attribute_match:
                # Line is an attribute (key:{attributes...})
                current_attr_key, attr_content = attribute_match.groups()
                attributes[current_attr_key] = {}
                cls._parse_attributes(attributes[current_attr_key], attr_content)
                inside_attributes = not stripped.endswith(&#34;}&#34;)

        # Step 7: Validation and Reconstruction
        # Make sure there are no attributes without a template entry
        for key in attributes:
            if key not in template:
                raise ValueError(f&#34;Attributes found for undefined template key: {key}&#34;)
            # Apply attributes to the corresponding template object
            for attr_name, attr_value in attributes[key].items():
                setattr(template[key], attr_name, attr_value)

        # Step 7: Create and return a new dscript instance
        if name is None:
            name = autoname(8)
        instance = cls(
            name = name,
            SECTIONS=global_params.get(&#39;SECTIONS&#39;, [&#39;DYNAMIC&#39;]),
            section=global_params.get(&#39;section&#39;, 0),
            position=global_params.get(&#39;position&#39;, 0),
            role=global_params.get(&#39;role&#39;, &#39;dscript instance&#39;),
            description=global_params.get(&#39;description&#39;, &#39;dynamic script&#39;),
            userid=global_params.get(&#39;userid&#39;, &#39;dscript&#39;),
            version=global_params.get(&#39;version&#39;, 0.1),
            verbose=global_params.get(&#39;verbose&#39;, False)
        )


        # Convert numeric string keys to integers if numerickeys is True
        if numerickeys:
            numeric_template = {}
            for key, value in template.items():
                # Check if the key is a numeric string
                if key.isdigit():
                    numeric_template[int(key)] = value
                else:
                    numeric_template[key] = value
            template = numeric_template

        # Set definitions and template
        instance.DEFINITIONS = definitions
        instance.TEMPLATE = template

        # Refresh variables (ensure that variables are detected and added to definitions)
        instance.set_all_variables()

        # Check eval
        instance.check_all_variables(verbose=False)

        # return the new instance
        return instance


    @classmethod
    def _parse_global_params(cls, content, global_params):
        &#34;&#34;&#34;
        Parses global parameters from the accumulated content enclosed in `{}`.

        ### Parameters:
            content (str): The content string containing global parameters.
            global_params (dict): A dictionary to populate with parsed parameters.

        ### Raises:
            ValueError: If invalid lines or key-value pairs are encountered.
        &#34;&#34;&#34;
        # Remove braces from the content
        content = content.strip().strip(&#34;{}&#34;)

        # Split the content into lines by commas
        lines = re.split(r&#39;,(?![^(){}\[\]]*[\)\}\]])&#39;, content.strip())

        for line in lines:
            line = line.strip()
            # Match key-value pairs
            match = re.match(r&#39;([\w_]+)\s*=\s*(.+)&#39;, line)
            if match:
                key, value = match.groups()
                key = key.strip()
                value = value.strip()
                # Convert the value to the appropriate Python type and store it
                global_params[key] = cls._convert_value(value)
            else:
                raise ValueError(f&#34;Invalid parameter line: &#39;{line}&#39;&#34;)


    @classmethod
    def _parse_attributes(cls, attr_dict, content):
        &#34;&#34;&#34;Parses attributes from the content inside {attribute=value,...}.&#34;&#34;&#34;
        attr_pairs = re.findall(r&#39;(\w+)\s*=\s*([^,]+)&#39;, content)
        for attr_name, attr_value in attr_pairs:
            attr_dict[attr_name] = cls._convert_value(attr_value)

    @classmethod
    def _convert_value(cls, value):
        &#34;&#34;&#34;Converts a string representation of a value to the appropriate Python type.&#34;&#34;&#34;
        value = value.strip()
        # Boolean and None conversion
        if value.lower() == &#39;true&#39;:
            return True
        elif value.lower() == &#39;false&#39;:
            return False
        elif value.lower() == &#39;none&#39;:
            return None
        # Handle quoted strings
        if (value.startswith(&#39;&#34;&#39;) and value.endswith(&#39;&#34;&#39;)) or (value.startswith(&#34;&#39;&#34;) and value.endswith(&#34;&#39;&#34;)):
            return value[1:-1]
        # Handle lists (Python syntax inside the file)
        if value.startswith(&#39;[&#39;) and value.endswith(&#39;]&#39;):
            return eval(value)  # Using eval to parse lists safely in this controlled scenario
        # Handle numbers
        try:
            if &#39;.&#39; in value:
                return float(value)
            return int(value)
        except ValueError:
            # Return the value as-is if it doesn&#39;t match other types
            return value

    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, copy.deepcopy(v, memo))
        return copie

    def detect_all_variables(self):
        &#34;&#34;&#34;
        Detects all variables across all templates in the dscript object.

        This method iterates through all ScriptTemplate objects in the dscript and
        collects variables from each template using the detect_variables method.

        Returns:
        --------
        list
            A sorted list of unique variables detected in all templates.
        &#34;&#34;&#34;
        all_variables = set()  # Use a set to avoid duplicates
        # Iterate through all templates in the dscript object
        for template_key, template in self.TEMPLATE.items():
            # Ensure the template is a ScriptTemplate and has the detect_variables method
            if isinstance(template, ScriptTemplate):
                detected_vars = template.detect_variables()
                all_variables.update(detected_vars)  # Add the detected variables to the set
        return sorted(all_variables)  # Return a sorted list of unique variables



    def add_dynamic_script(self, key, content=&#34;&#34;, userid=None, definitions=None, verbose=None, autorefresh=True, **USER):
        &#34;&#34;&#34;
        Add a dynamic script step to the dscript object.

        Parameters:
        -----------
        key : str
            The key for the dynamic script (usually an index or step identifier).
        content : str or list of str, optional
            The content (template) of the script step.
        definitions : lambdaScriptdata, optional
            The merged variable space (STATIC + GLOBAL + LOCAL).
        verbose : bool, optional
            If None, self.verbose will be used. Controls verbosity of the template.
        autorefresh : bool, optional
            If True, detected variables (e.g., var) and undefined are assiged to their default value (e.g., ${var})
            Default = True
        USER : dict
            Additional user variables that override the definitions for this step.
        &#34;&#34;&#34;
        if definitions is None:
            definitions = lambdaScriptdata()
        if verbose is None:
            verbose = self.verbose
        # Create a new ScriptTemplate and add it to the TEMPLATE
        self.TEMPLATE[key] = ScriptTemplate(
            content=content,
            definitions=self.DEFINITIONS+definitions,
            verbose=verbose,
            userid = key if userid is None else userid,
            autorefresh=autorefresh,
            **USER
        )



    def check_all_variables(self, verbose=True, seteval=True, output=False):
        &#34;&#34;&#34;
        Checks for undefined variables for each TEMPLATE key in the dscript object.

        Parameters:
        -----------
        verbose : bool, optional, default=True
            If True, prints information about variables for each TEMPLATE key.
            Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.

        seteval : bool, optional, default=True
            If True, sets the `eval` attribute to True if at least one variable is defined or set to its default value.

        output : bool, optional, default=False
            If True, returns a dictionary with lists of default variables, set variables, and undefined variables.

        Returns:
        --------
        out : dict, optional
            If `output=True`, returns a dictionary with the following structure:
            - &#34;defaultvalues&#34;: List of variables set to their default value (${varname}).
            - &#34;setvalues&#34;: List of variables defined with values other than their default.
            - &#34;undefined&#34;: List of variables that are undefined.
        &#34;&#34;&#34;
        out = {&#34;defaultvalues&#34;: [], &#34;setvalues&#34;: [], &#34;undefined&#34;: []}

        for key in self.TEMPLATE:
            template = self.TEMPLATE[key]
            # Call the check_variables method of ScriptTemplate for each TEMPLATE key
            result = template.check_variables(verbose=verbose, seteval=seteval)

            # Update the output dictionary if needed
            out[&#34;defaultvalues&#34;].extend(result[&#34;defaultvalues&#34;])
            out[&#34;setvalues&#34;].extend(result[&#34;setvalues&#34;])
            out[&#34;undefined&#34;].extend(result[&#34;undefined&#34;])

        if output:
            return out


    def set_all_variables(self):
        &#34;&#34;&#34;
        Ensures that all variables in the templates are added to the global definitions
        with default values if they are not already defined.
        &#34;&#34;&#34;
        for key, script_template in self.TEMPLATE.items():
            # Check and update the global definitions with template-specific variables
            for var in script_template.detect_variables():
                if var not in self.DEFINITIONS:
                    # Add undefined variables with their default value
                    self.DEFINITIONS.setattr(var, f&#34;${{{var}}}&#34;)  # Set default as ${varname}




    def search(self, primary_key, value, foreign_key, include_global=True, multiple=&#39;all&#39;, protection=False, verbose=False):
        &#34;&#34;&#34;
        Search for foreign/definition key values associated with given primary key/definition value(s).

        This method searches through the global definitions first and then traverses local steps in sequential order
        to find matches for the specified primary key and retrieves the corresponding foreign key values.
        It also identifies available foreign keys in steps where the primary key exists but the desired foreign key is missing.

        Parameters:
            primary_key (str):
                The primary key to search for in the definitions.
            value (str, int, float, or list of these types):
                The value(s) associated with the primary key.
            foreign_key (str):
                The foreign key whose value is to be retrieved.
            include_global (bool, optional):
                If True, include global definitions in the search.
                Defaults to True.
            multiple (str, optional):
                Strategy for handling multiple matches. Options are:
                - &#39;first&#39;: Return the first match found.
                - &#39;last&#39;: Return the last match found.
                - &#39;all&#39;: Return all matches in a list.
                Defaults to &#39;all&#39;.
            protection (bool, optional):
                If False (default), removes the &#39;$&#39; prefix from the keys in the returned dictionary.
                If True, retains the &#39;$&#39; prefix.
                Defaults to False.
            verbose (bool, optional):
                If True, prints warnings about missing foreign keys and available alternative keys.
                Defaults to False.

        Returns:
            dict or scalar or None:
                - If multiple values are provided, returns a dictionary mapping each value to its foreign key value(s).
                - If a single value is provided:
                    - Returns a single foreign key value if &#39;multiple&#39; is &#39;first&#39; or &#39;last&#39;.
                    - Returns a list of all matching foreign key values if &#39;multiple&#39; is &#39;all&#39;.
                - Returns None if no matches are found.

        Raises:
            TypeError:
                If the provided value is not of type str, int, or float, or if value list contains invalid types.
            ValueError:
                If an invalid option is provided for &#39;multiple&#39;.
        &#34;&#34;&#34;
        # Validate &#39;multiple&#39; parameter
        if multiple not in {&#39;first&#39;, &#39;last&#39;, &#39;all&#39;}:
            raise ValueError(&#34;Parameter &#39;multiple&#39; must be one of &#39;first&#39;, &#39;last&#39;, or &#39;all&#39;.&#34;)

        # Normalize &#39;value&#39; to a list for uniform processing
        if isinstance(value, (str, int, float)):
            values = [value]
            single_value = True
        elif isinstance(value, list):
            if not all(isinstance(v, (str, int, float)) for v in value):
                raise TypeError(&#34;All elements in &#39;value&#39; list must be of type str, int, or float.&#34;)
            values = value
            single_value = False
        else:
            raise TypeError(f&#34;&#39;value&#39; must be of type str, int, float, or list of these types, got {type(value).__name__}&#34;)

        # Initialize the result containers
        matched_foreign_keys = {}  # key: value, value: single or list of foreign_key values
        available_foreign_keys_set = set()  # set of foreign keys available where primary exists but desired foreign_key missing

        # Keys to exclude when listing available foreign keys
        excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

        # Function to add a match to the results based on the &#39;multiple&#39; strategy
        def add_match(val, rvalue):
            if multiple == &#39;all&#39;:
                if val in matched_foreign_keys:
                    if isinstance(matched_foreign_keys[val], list):
                        matched_foreign_keys[val].append(rvalue)
                    else:
                        matched_foreign_keys[val] = [matched_foreign_keys[val], rvalue]
                else:
                    matched_foreign_keys[val] = [rvalue]
            elif multiple == &#39;first&#39;:
                if val not in matched_foreign_keys:
                    matched_foreign_keys[val] = rvalue
            elif multiple == &#39;last&#39;:
                matched_foreign_keys[val] = rvalue

        # Start with global definitions if included
        if include_global:
            global_definitions = self.DEFINITIONS
            if hasattr(global_definitions, primary_key):
                primary_value = getattr(global_definitions, primary_key)

                # Handle multiple primary key values within the global definitions
                if isinstance(primary_value, (list, tuple, set)):
                    primary_values = primary_value
                else:
                    primary_values = [primary_value]

                for pv in primary_values:
                    for val in values:
                        if pv == val:
                            # Check if the foreign key exists in global definitions
                            if hasattr(global_definitions, foreign_key):
                                rvalue = getattr(global_definitions, foreign_key)
                                add_match(val, rvalue)
                            else:
                                # Collect available foreign keys in global definitions, excluding specified keys
                                available_keys = [
                                    k for k in global_definitions.__dict__
                                    if k != primary_key and k not in excluded_keys
                                ]
                                available_foreign_keys_set.update(available_keys)

        # Then, traverse through local steps in sequential order
        for istep in range(len(self)):
            step_definitions = self[istep].definitions

            # Check if the primary key exists in the local definitions
            if hasattr(step_definitions, primary_key):
                primary_value = getattr(step_definitions, primary_key)

                # Handle multiple primary key values within the definition
                if isinstance(primary_value, (list, tuple, set)):
                    primary_values = primary_value
                else:
                    primary_values = [primary_value]

                for pv in primary_values:
                    for val in values:
                        if pv == val:
                            # Check if the foreign key exists
                            if hasattr(step_definitions, foreign_key):
                                rvalue = getattr(step_definitions, foreign_key)
                                add_match(val, rvalue)
                            else:
                                # Collect available foreign keys in this step, excluding specified keys
                                available_keys = [
                                    k for k in step_definitions.__dict__
                                    if k != primary_key and k not in excluded_keys
                                ]
                                available_foreign_keys_set.update(available_keys)

        # Process the matched_foreign_keys based on &#39;multiple&#39; strategy
        if single_value:
            if values[0] in matched_foreign_keys:
                if multiple == &#39;all&#39;:
                    # If only one match, return scalar; else, list
                    matches = matched_foreign_keys[values[0]]
                    if len(matches) == 1:
                        matches = matches[0]
                else:
                    matches = matched_foreign_keys[values[0]]
            else:
                matches = None
        else:
            matches = {}
            for val in values:
                if val in matched_foreign_keys:
                    if multiple == &#39;all&#39;:
                        if len(matched_foreign_keys[val]) == 1:
                            matches[val] = matched_foreign_keys[val][0]
                        else:
                            matches[val] = matched_foreign_keys[val]
                    else:
                        matches[val] = matched_foreign_keys[val]
                else:
                    matches[val] = None  # Or handle differently if needed

        # If there are available foreign keys, report them as an error message
        if available_foreign_keys_set and verbose:
            available_keys_sorted = sorted(list(available_foreign_keys_set))
            print(f&#34;Warning: In some steps, the foreign key &#39;{foreign_key}&#39; is missing where the primary key &#39;{primary_key}&#39; exists.&#34;)
            print(f&#34;Available foreign keys in those steps: {available_keys_sorted}&#34;)

        # If no matches found, print a message
        if (single_value and matches is None) or (not single_value and all(v is None for v in matches.values())):
            if verbose:
                print(f&#34;No matches found for primary key &#39;{primary_key}&#39; with value(s) &#39;{value}&#39;.&#34;)
            return None

        # Handle protection flag: remove &#39;$&#39; prefix from keys if protection=False
        if not single_value and isinstance(matches, dict):
            processed_matches = {}
            for k, v in matches.items():
                if not protection and isinstance(k, str):
                    # Remove any leading &#39;$&#39; and surrounding spaces
                    new_key = k.lstrip(&#39;$&#39;).strip()
                else:
                    new_key = k
                processed_matches[new_key] = v
            return processed_matches
        else:
            # For single value searches, return matches as-is
            return matches




    def list_values(self, key, include_global=True, verbose=False, order=&#39;stable&#39;, details=False):
        &#34;&#34;&#34;
        List all unique values taken by a specified key across global definitions and all steps in sequential order.

        Parameters:
            key (str): The key whose values are to be listed.
            include_global (bool, optional): If True, include global definitions in the search. Defaults to True.
            verbose (bool, optional): If True, print warnings about steps where the key is missing and list available keys. Defaults to False.
            order (str, optional): The order in which to list the unique values. Options are &#39;stable&#39;, &#39;ascend&#39;, &#39;descend&#39;. Defaults to &#39;stable&#39;.
            details (bool, optional): If True, return a VariableOccurrences object containing detailed occurrence information. If False, return a list or scalar as before. Defaults to False.

        Returns:
            list or scalar or VariableOccurrences or None:
                - If `details=False`:
                    - Returns a list of unique values associated with the key, ordered as specified.
                    - If only one unique value exists, returns it as a scalar.
                    - Returns None if the key is not found in any global or step definitions.
                - If `details=True`:
                    - Returns a VariableOccurrences object containing detailed occurrence information across scopes.
        &#34;&#34;&#34;
        # Validate &#39;order&#39; parameter
        if order not in {&#39;stable&#39;, &#39;ascend&#39;, &#39;descend&#39;}:
            raise ValueError(&#34;Parameter &#39;order&#39; must be one of &#39;stable&#39;, &#39;ascend&#39;, or &#39;descend&#39;.&#34;)

        excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

        unique_values = []
        seen_values = set()

        available_keys_set = set()

        # Helper function to compare lists
        def lists_are_equal(list1, list2):
            return list1 == list2

        # Function to add a key_value to unique_values
        def add_value(kv):
            if isinstance(kv, list):
                # Convert list to tuple for hashability
                try:
                    kv_tuple = tuple(kv)
                    if kv_tuple not in seen_values:
                        unique_values.append(kv.copy())  # Append a copy to preserve the list
                        seen_values.add(kv_tuple)
                except TypeError:
                    # If list contains unhashable items, compare manually
                    if not any(lists_are_equal(kv, existing) for existing in unique_values if isinstance(existing, list)):
                        unique_values.append(kv.copy())
            else:
                if kv not in seen_values:
                    unique_values.append(kv)
                    seen_values.add(kv)

        # Data structures for detailed occurrences
        occurrences_data = defaultdict(list)  # {&#39;global&#39;: [value], &#39;local&#39;: [(step, value), ...]}

        # Include global definitions
        if include_global and hasattr(self.DEFINITIONS, key):
            key_value = getattr(self.DEFINITIONS, key)
            if isinstance(key_value, list):
                add_value(key_value)
                if details:
                    occurrences_data[&#39;global&#39;] = key_value.copy()
            else:
                add_value(key_value)
                if details:
                    occurrences_data[&#39;global&#39;] = key_value
        elif include_global and verbose:
            # Collect available keys in global definitions, excluding specified keys
            available_keys = [
                k for k in self.DEFINITIONS.__dict__
                if k != key and k not in excluded_keys
            ]
            available_keys_set.update(available_keys)

        # Traverse through steps
        for step_key, step in self.TEMPLATE.items():
            if hasattr(step.definitions, key):
                key_value = getattr(step.definitions, key)
                if isinstance(key_value, list):
                    add_value(key_value)
                    if details:
                        occurrences_data[&#39;local&#39;].append((step_key, key_value.copy()))
                else:
                    add_value(key_value)
                    if details:
                        occurrences_data[&#39;local&#39;].append((step_key, key_value))
            else:
                if verbose:
                    # Collect available keys in this step, excluding specified keys
                    available_keys = [
                        k for k in step.definitions.__dict__
                        if k != key and k not in excluded_keys
                    ]
                    available_keys_set.update(available_keys)

        # Verbose warnings
        if verbose and available_keys_set:
            available_keys_sorted = sorted(list(available_keys_set))
            print(f&#34;Warning: The key &#39;{key}&#39; is missing in some steps or global definitions.&#34;)
            print(f&#34;Available keys in those contexts: {available_keys_sorted}&#34;)

        # Ordering
        if order == &#39;stable&#39;:
            ordered_values = unique_values
        else:
            # To sort, ensure all elements are of the same type
            try:
                if all(isinstance(v, list) for v in unique_values):
                    if order == &#39;ascend&#39;:
                        ordered_values = sorted(unique_values)
                    else:
                        ordered_values = sorted(unique_values, reverse=True)
                elif all(isinstance(v, type(unique_values[0])) for v in unique_values):
                    if order == &#39;ascend&#39;:
                        ordered_values = sorted(unique_values)
                    else:
                        ordered_values = sorted(unique_values, reverse=True)
                else:
                    raise TypeError
            except TypeError:
                if verbose:
                    print(&#34;Warning: Cannot sort values due to mixed or non-comparable types. Returning values in their original order.&#34;)
                ordered_values = unique_values

        if details:
            # Prepare data for VariableOccurrences
            # Convert defaultdict to regular dict
            occurrences_dict = dict(occurrences_data)

            if key.lower() == &#34;all&#34;:
                # Collect all keys and their occurrences
                all_keys = set()
                # Include global definitions if specified
                if include_global:
                    global_keys = set(self.DEFINITIONS.__dict__.keys()) - excluded_keys
                    all_keys.update(global_keys)
                # Include keys from all steps
                for step in self.TEMPLATE.values():
                    step_keys = set(step.definitions.__dict__.keys()) - excluded_keys
                    all_keys.update(step_keys)

                # Remove the &#39;all&#39; key itself if present
                all_keys.discard(&#34;all&#34;)

                variables_data = {}
                for var in all_keys:
                    var_data = defaultdict(list)
                    # Include global definitions
                    if include_global and hasattr(self.DEFINITIONS, var):
                        var_value = getattr(self.DEFINITIONS, var)
                        if isinstance(var_value, list):
                            var_data[&#39;global&#39;].append(var_value.copy())  # Directly append the value
                        else:
                            var_data[&#39;global&#39;].append(var_value)
                    # Traverse through steps
                    for step_key, step in self.TEMPLATE.items():
                        if hasattr(step.definitions, var):
                            var_value = getattr(step.definitions, var)
                            if isinstance(var_value, list):
                                var_data[&#39;local&#39;].append((step_key, var_value.copy()))
                            else:
                                var_data[&#39;local&#39;].append((step_key, var_value))
                    variables_data[var] = dict(var_data)
                return VariableOccurrences(variables_data, variables=None)  # variables=None implies multiple variables

            else:
                # Single variable case
                return VariableOccurrences(occurrences_dict, variables=key)

        # Determine return value
        if not unique_values:
            if verbose:
                print(f&#34;No values found for key &#39;{key}&#39; in any step or global definitions.&#34;)
            return None
        elif len(unique_values) == 1:
            return unique_values[0]
        else:
            return ordered_values



    def flattenvariables(self):
        &#34;&#34;&#34;
        Flatten the variable definitions for each step based on usage and precedence.

        This method ensures that for each step:
            - Only the variables used in the template are present in `self[i].definitions`.
            - The value of each variable is determined based on the following precedence:
                1. Global Definitions (`self.DEFINITIONS`)
                2. Current Step Definitions (`self[i].definitions`)
                3. Previous Step Definitions (`self[i-1].definitions`, etc.)
                4. Protected Variables (`&#34;$variable_name&#34;`)

        The method updates `self[i].definitions` to include only the necessary variables with their resolved values.
        Unused variables are removed from each step&#39;s definitions after resolution, **excluding** protected attributes.

        Raises:
            AttributeError: If a step or global definitions lack the necessary attributes.
        &#34;&#34;&#34;
        # Define the set of protected attributes that must never be removed
        excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

        # Initialize local_definitions with a copy of global definitions to prevent mutation
        local_definitions = lambdaScriptdata(**self.DEFINITIONS.__dict__)

        # Iterate through each step in order
        for i in range(len(self)):
            step = self[i]
            step_definitions = step.definitions

            # Detect variables used in the current step&#39;s template
            variables_used = step.detect_variables()

            # Temporary dictionary to store resolved variable values
            resolved_vars = {}

            # Resolve each variable&#39;s value based on precedence
            for var in variables_used:
                if hasattr(step_definitions, var):
                    # Variable defined in the current step&#39;s definitions
                    resolved_vars[var] = getattr(step_definitions, var)
                elif hasattr(local_definitions, var):
                    # Variable inherited from previous definitions (global or prior steps)
                    resolved_vars[var] = getattr(local_definitions, var)
                else:
                    # Variable not found; assign protected format
                    resolved_vars[var] = f&#34;${var}&#34;

            # Remove any variables in step_definitions not in variables_used and not in excluded_keys
            existing_vars = list(step_definitions.__dict__.keys())
            for var in existing_vars:
                if var not in variables_used and var not in excluded_keys:
                    delattr(step_definitions, var)

            # Assign resolved variables to step_definitions
            for var, value in resolved_vars.items():
                setattr(step_definitions, var, value)

            # Update local_definitions by merging with step_definitions
            # Only variables used in this step are updated in local_definitions
            local_definitions = local_definitions + step_definitions



    def clean(self, behavior=&#39;fixing&#39;, verbose=False):
        &#34;&#34;&#34;
        Clean the TEMPLATE by removing or fixing empty steps.

        An empty step is defined as one where its content is [], &#34;&#34;, or None.

        Parameters:
            behavior (str, optional):
                Determines the action to perform on empty steps.
                - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
                - &#39;fixing&#39;: Replace the content of the empty step with a comment.
                Defaults to &#39;fixing&#39;.
            verbose (bool, optional):
                If True, prints informational messages about the actions taken.
                If False, operates silently.
                Defaults to False.

        Raises:
            ValueError:
                If the provided behavior is not &#39;removing&#39; or &#39;fixing&#39;.
        &#34;&#34;&#34;
        # Validate the &#39;behavior&#39; parameter
        if behavior not in {&#39;removing&#39;, &#39;fixing&#39;}:
            raise ValueError(&#34;Parameter &#39;behavior&#39; must be either &#39;removing&#39; or &#39;fixing&#39;.&#34;)

        # Iterate over a list of keys to avoid RuntimeError due to dict size change during iteration
        for key in list(self.TEMPLATE.keys()):
            step = self.TEMPLATE[key]
            content = step.content

            # Check if the step is empty
            if content in [[], &#34;&#34;, None,[&#34;&#34;],[None],[[]]]:
                if behavior == &#39;removing&#39;:
                    # Remove the step entirely from TEMPLATE
                    del self.TEMPLATE[key]
                    if verbose:
                        print(f&#34;Removed empty step: {key}&#34;)
                elif behavior == &#39;fixing&#39;:
                    # Replace the content with a default comment
                    step.content = [f&#34;# empty &lt;step {key}&gt;&#34;]
                    if verbose:
                        print(f&#34;Fixed empty step: {key} by adding a comment.&#34;)




# %% debug section - generic code to test methods (press F5)
# ===================================================
# main()
# ===================================================
# for debugging purposes (code called as a script)
# the code is called from here
# ===================================================
if __name__ == &#39;__main__&#39;:

    # Usage example
    # -------------
    # Initialize a dscript object
    S = dscript()

    # Add script lines/items with placeholders for variables
    S[3] = &#34;instruction .... with substitution rules ${v1}+${var2}&#34;
    S[&#39;alpha&#39;] = &#34;another script template ${v3}&#34;

    # Set a custom attribute for a specific line
    S[3].attribute1 = True

    # Reorder script lines/items
    T = S[[1,0]]

    # Define global variables in DEFINITIONS
    S.DEFINITIONS.a = 1
    S.DEFINITIONS.b = 2

    # Update a script line and enable evaluation of its content
    S[0] = &#34;$a+$b&#34;
    S[0].eval = True

    # Set a line as mandatory (not facultative)
    S[3].facultative = False

    # Access and print the content of specific script lines/items
    print(S[3])       # Outputs: instruction .... with substitution rules ${v1}+${var2}
    print(S[&#39;alpha&#39;]) # Outputs: another script template ${v3}

    # Access and print custom attributes
    print(S[3].attribute1)  # Outputs: True

    # Iterate through all script lines, printing their keys and content
    for key, content in S.items():
        print(f&#34;Key: {key}, Content: {content}&#34;)

    # Retrieve and evaluate the content of a script line by its index
    S.get_content_by_index(0, False)  # Retrieve without evaluation
    S.get_content_by_index(0)         # Retrieve with evaluation

    # Access attributes of a specific script line by index
    S.get_attributes_by_index(0)

    # Apply conditions to the execution of a script line
    S[0].condition = &#34;$a&gt;1&#34;
    S[0].condeval = True
    S.get_content_by_index(2)  # Condition not met, may result in an empty string

    # Update the condition and evaluate again
    S[0].condition = &#34;$a&gt;0&#34;
    S[0].do()  # Executes and evaluates the line content

    # Create multiple variables in DEFINITIONS if they don&#39;t already exist
    S.createEmptyVariables([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;, &#34;e&#34;])

    # Access and print all current definitions
    S.DEFINITIONS


    # =====================================================
    # Production Example: LAMMPS Header Initialization
    #   closely related to pizza.region.LammpsHeaderInit
    # =====================================================
    # Initialize a dscript object with a custom name
    R = dscript(name=&#34;ProductionExample&#34;)

    # Define global variables (DEFINITIONS) for the script
    R.DEFINITIONS.dimension = 3
    R.DEFINITIONS.units = &#34;$si&#34;
    R.DEFINITIONS.boundary = [&#34;sm&#34;, &#34;sm&#34;, &#34;sm&#34;]
    R.DEFINITIONS.atom_style = &#34;$smd&#34;
    R.DEFINITIONS.atom_modify = [&#34;map&#34;, &#34;array&#34;]
    R.DEFINITIONS.comm_modify = [&#34;vel&#34;, &#34;yes&#34;]
    R.DEFINITIONS.neigh_modify = [&#34;every&#34;, 10, &#34;delay&#34;, 0, &#34;check&#34;, &#34;yes&#34;]
    R.DEFINITIONS.newton = &#34;$off&#34;

    # Define the script template, associating each line with a key
    R[0]        = &#34;% ${comment}&#34;               # line/item can be identied by numbers/names
    R[&#34;dim&#34;]    = &#34;dimension    ${dimension}&#34;  # line/item identified as &#39;dim&#39;
    R[&#34;unit&#34;]   = &#34;units        ${units}&#34;      # line/item identified as &#39;unit&#39;
    R[&#34;bound&#34;]  = &#34;boundary     ${boundary}&#34;
    R[&#34;astyle&#34;] = &#34;atom_style   ${atom_style}&#34;
    R[&#34;amod&#34;]   = &#34;atom_modify  ${atom_modify}&#34;
    R[&#34;cmod&#34;]   = &#34;comm_modify  ${comm_modify}&#34;
    R[&#34;nmod&#34;]   = &#34;neigh_modify ${neigh_modify}&#34;
    R[&#34;newton&#34;] = &#34;newton       ${newton}&#34;

    # Apply a condition to the &#39;astyle&#39; line
    # it will only be included if ${atom_style} is defined
    R[&#34;astyle&#34;].condition = &#34;${atom_style}&#34;

    # Update DEFINITIONS to unset the atom_style variable
    R.DEFINITIONS.atom_style = &#34;&#34;

    # Generate a script instance, overwriting the &#39;units&#39; variable and adding a comment
    sR = R.script(units=&#34;$lj&#34;,  # Use &#34;$&#34; to prevent immediate evaluation
                  comment=&#34;$my first dynamic script&#34;)

    # Execute the script to generate the final content
    ssR = sR.do()

    # Print the generated script
    print(ssR)

    # Save the current script
    R.save(overwrite=True)

    # Load again the same script and show the script
    T = dscript.load(R.name)
    print(repr(T))
    ssT = R.script(units=&#34;$lj&#34;,  # Use &#34;$&#34; to prevent immediate evaluation
                  comment=&#34;$my second dynamic script&#34;).do()
    print(ssT)

    # ========================================================
    # DSCRIPT SAVE FILE: Example: LAMMPS generic code
    #   This example is intended to illustrate the syntax
    #   Note that the script below does not include the header.
    #   It will be added with the write method
    # ========================================================

    # The script is defined here within a string
    # note that the first line should be: # DSCRIPT SAVE FILE
    myscript = &#34;&#34;&#34;# DSCRIPT SAVE FILE
# Global Parameters:
# ------------------
# Define general settings for the script class.
# This section is not mandatory.
# Properties are defined within { }
# They include
#       SECTIONS = [&#34;DYNAMIC&#34;] # the considered section names
#       section = 0            # the current section index,
#       position = 0           # the script  position order,
#       role = &#34;dscript instance&#34;,
#       description = &#34;dynamic script&#34;,
#       userid = &#34;dscript&#34;,
#       version = 0.1,
#       verbose = False
{ # a line starting with { indicates the begining of the section
    SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;], # this is a comment
    section=0, position=0 } # note the closing } is mandatory

# DEFINITIONS (Define general settings for the script.)
# -----------
# All variables are defined in a Python way

d = 3                        # d is a number and equals 3
units = &#34;$lj&#34;                # $ is used to block immediate execution in a string
periodic = &#34;$p&#34;              # $ is used to block immediate execution in a string
dimension = &#34;${d}&#34;           # d is a variable
boundary = [&#34;p&#34;, &#34;p&#34;, &#34;p&#34;]   # this a list (Python syntax)
atom_style = &#34;$atomic&#34;
lattice = [&#34;fcc&#34;, 3.52]       # this a list (Python syntax)
region = [&#34;box&#34;, &#34;block&#34;, 0, 10, 0, 10, 0, 10] # this a list (Python syntax)
create_box = [1, &#34;box&#34;]
create_atoms = [1, &#34;box&#34;]
mass = 1.0
pair_style = [&#34;lj/cut&#34;, 2.5]
pair_coeff = [1, 1, 1.0, 1.0, 2.5]
velocity = [&#34;all&#34;, &#34;create&#34;, 300.0, 12345]
fix = [1, &#34;all&#34;, &#34;nve&#34;]
run = 1000
timestep = 0.001
thermo = 100

# TEMPLATE:
# ---------
# Provide a template for how these parameters should be formatted or used in the script.
#  The general syntax is:
#      KEY: INSTRUCTION
#      KEY can be numeric, alphanumeric
#      INSTRUCTION can be any LAMMPS command involving variables defined in the DEFINITION section or elsewhere
units: units ${units}     # key = units, template = units ${units}
dim: dimension ${dimension}
bound: boundary ${boundary}
astyle: atom_style ${atom_style}
lattice: lattice ${lattice}
region: region ${region}
create_box: create_box ${create_box}
create_atoms: create_atoms ${create_atoms}
mass: mass ${mass}
pair_style: pair_style ${pair_style}
pair_coeff: pair_coeff ${pair_coeff}
velocity: velocity ${velocity}
fix: fix ${fix}
run: run ${run}
timestep: timestep ${timestep}
thermo: thermo ${thermo}

# Attributes:
# -----------
# Each template line can have attributes (here default attributes, but the user can add more)
# Default value between ()
#   facultative = True or (False) (remove the template line if True)
#   eval = True or (False) (evaluate the template line with eval() if True)
#   readonly True or (False) (prevent any subsequent modification() if True)
#   condition = any expression with variables
#   condeval = True or (False) (evaluate the condition with eval() if True)
#   detectvar = (True) or False (create variables in DEFINITIONS if True)
units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    &#34;&#34;&#34;

    # write myscript to disk
    myscriptfile = dscript.write(myscript)
    print(f&#34;DSCRIPT SAVE FILE: {myscriptfile}&#34;)

    # load the script as a dscript object
    myS = dscript.load(myscriptfile)

    # generate the corresponding script
    myS.units.do()
    smyS = myS.script()

    # Ececute the script and print it
    ssmyS = smyS.do()
    print(ssmyS)

    # The conversion of a string into a script
    # can be mediated via dscript.parsesyntax()
    # without using a temporary file
    mytemplate = dscript.parsesyntax(myscript).script()
    mytemplatetxt = mytemplate.do()
    print(mytemplatetxt)


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#       Beyond this line, the previous examples are tested with the new compact syntax
#       enabling to define a template-block with a single key/tag.
#       The intent is to accelerate scripting and readability.
#
#       IMPORTANT
#           In DSCRIPT SAVE FILE, a block uses a new syntax between square brackets &#34;[]&#34;
#               # TEMPLATE (number of items=1)
#               code: [
#               % ${comment}
#               dimension    ${dimension}
#               units        ${units}
#               boundary     ${boundary}
#               atom_style   ${atom_style}
#               atom_modify  ${atom_modify}
#               comm_modify  ${comm_modify}
#               neigh_modify ${neigh_modify}
#               newton       ${newton}
#     ]
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#
    # =====================================================
    # Production Example version 2: compact version
    #   using multiple lines/items template
    # =====================================================

    R2 = dscript(name=&#34;ProductionExample2&#34;)

    # Define global variables (DEFINITIONS) for the script
    R2.DEFINITIONS.dimension = 3
    R2.DEFINITIONS.units = &#34;$si&#34;
    R2.DEFINITIONS.boundary = [&#34;sm&#34;, &#34;sm&#34;, &#34;sm&#34;]
    R2.DEFINITIONS.atom_modify = [&#34;map&#34;, &#34;array&#34;]
    R2.DEFINITIONS.comm_modify = [&#34;vel&#34;, &#34;yes&#34;]
    R2.DEFINITIONS.neigh_modify = [&#34;every&#34;, 10, &#34;delay&#34;, 0, &#34;check&#34;, &#34;yes&#34;]
    R2.DEFINITIONS.newton = &#34;$off&#34;

    # Define the script template, associating each line with a key
    R2[&#34;code&#34;] = &#34;&#34;&#34;
    % ${comment}               # this comment will be preserved as it starts with %
    dimension    ${dimension}  # this comment will be deleted
    units        ${units}
    boundary     ${boundary}
    atom_style   ${atom_style}
    atom_modify  ${atom_modify}
    comm_modify  ${comm_modify}
    neigh_modify ${neigh_modify}
    newton       ${newton}
    &#34;&#34;&#34;

    # Add missing defintion
    R2.DEFINITIONS.atom_style = &#34;$smd&#34;

    # Generate a script instance, overwriting the &#39;units&#39; variable and adding a comment
    sR2 = R2.script(units=&#34;$lj&#34;,  # Use &#34;$&#34; to prevent immediate evaluation
                   comment=&#34;$my first dynamic script&#34;)
    ssR2 = sR2.do()

    # Print the generated script
    print(ssR2)

    # Save the current script
    R2.save(overwrite=True)

    # Load again the same script and show the script
    T2 = dscript.load(R2.name)
    print(repr(T2))
    ssT2 = R2.script(units=&#34;$lj&#34;,  # Use &#34;$&#34; to prevent immediate evaluation
                  comment=&#34;$my second dynamic script&#34;).do()
    print(ssT2)

    # ========================================================
    # DSCRIPT SAVE FILE: compact version
    # ========================================================

    # The script is defined here within a string
    # note that the first line should be: # DSCRIPT SAVE FILE

    myscript2 = &#34;&#34;&#34;# DSCRIPT SAVE FILE

# Global Parameters:
# ------------------
{ # a line starting with { indicates the begining of the section
    SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;], # this is a comment
    section=0, position=0 } # note the closing } is mandatory

# DEFINITIONS (Define general settings for the script.)
# -----------
d = 3                        # d is a number and equals 3
units = &#34;$lj&#34;                # $ is used to block immediate execution in a string
periodic = &#34;$p&#34;              # $ is used to block immediate execution in a string
dimension = &#34;${d}&#34;           # d is a variable
boundary = [&#34;p&#34;, &#34;p&#34;, &#34;p&#34;]   # this a list (Python syntax)
atom_style = &#34;$atomic&#34;
lattice = [&#34;fcc&#34;, 3.52]       # this a list (Python syntax)
region = [&#34;box&#34;, &#34;block&#34;, 0, 10, 0, 10, 0, 10] # this a list (Python syntax)
create_box = [1, &#34;box&#34;]
create_atoms = [1, &#34;box&#34;]
mass = 1.0
pair_style = [&#34;lj/cut&#34;, 2.5]
pair_coeff = [1, 1, 1.0, 1.0, 2.5]
velocity = [&#34;all&#34;, &#34;create&#34;, 300.0, 12345]
fix = [1, &#34;all&#34;, &#34;nve&#34;]
run = 1000
timestep = 0.001
thermo = 100

# TEMPLATE:
# ---------
mytemplate1: [
    # you can add comments inside templates
    units ${units}     # whereever you need
    dimension ${dimension}
    boundary ${boundary}
    atom_style ${atom_style}
    lattice ${lattice}
    region ${region}
    create_box ${create_box}
    create_atoms ${create_atoms}
    mass ${mass}
    pair_style ${pair_style}
    pair_coeff ${pair_coeff}
    ]

mytemplate2: [
    velocity ${velocity}
    fix ${fix}
    run ${run}
    timestep ${timestep}
    thermo ${thermo}
    ]

# Attributes:
# -----------
mytemplate1: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
mytemplate2: {facultative=False, eval=False, readonly=False, condition=&#34;&#34;, condeval=False, detectvar=True}
    &#34;&#34;&#34;

    # write myscript to disk
    myscriptfile2 = dscript.write(myscript2)
    print(f&#34;DSCRIPT SAVE FILE: {myscriptfile2}&#34;)

    # load the script as a dscript object
    myS2 = dscript.load(myscriptfile2)

    # generate the corresponding script
    smyS2 = myS2.script()

    # Ececute the script and print it
    ssmyS2 = smyS2.do()
    print(ssmyS2)

    # The conversion of a string into a script
    # can be mediated via dscript.parsesyntax()
    # without using a temporary file
    mytemplate2 = dscript.parsesyntax(myscript2).script()
    mytemplatetxt2 = mytemplate2.do()
    print(mytemplatetxt2)


    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #                                        ADVANCED EXAMPLE
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        ################################################################################
        # This Python script demonstrates the conversion of a LAMMPS input script
        # for a TLSPH (Total Lagrangian Smoothed Particle Hydrodynamics) simulation
        # into a `dscript` object. The `dscript` format allows for flexible manipulation
        # of variables, templates, and simulation parameters using Python.
        #
        # Example use case:
        # - The script simulates elongation of a 2D strip of a linear elastic material
        #   by pulling its ends apart, using LAMMPS USER.SMD package.
        # - The units are set to GPa / mm / ms, and material properties such as
        #   Young’s modulus, Poisson’s ratio, and density are defined.
        # - The geometry, boundary conditions, material model, and output settings
        #   are set up dynamically.
        #
        # Sections in the script:
        # 1. **INITIALIZE**: Initializes the LAMMPS environment and sets simulation settings.
        # 2. **CREATE_GEOMETRY**: Defines the initial particle geometry and region.
        # 3. **DISCRETIZATION**: Defines parameters for discretization and particle properties.
        # 4. **BOUNDARY_CONDITIONS**: Sets velocity conditions to pull the strip&#39;s top and bottom edges.
        # 5. **PHYSICS**: Specifies the interaction physics and material model using the USER.SMD package.
        # 6. **OUTPUT**: Configures stress, strain, and neighbor computations for output.
        # 7. **STATUS_OUTPUT**: Defines how stress and strain are calculated and output.
        # 8. **RUN**: Executes the simulation for a specified number of steps.
        #
        # The main variables such as Young’s modulus (E), Poisson’s ratio (nu), and density (rho)
        # are added to the `DEFINITIONS` section for dynamic use in the script.
        #
        # The `TEMPLATE` section organizes each block of the LAMMPS script under different keys
        # (e.g., &#34;initialize&#34;, &#34;create&#34;, &#34;discretization&#34;), allowing easy manipulation or modification
        # of individual parts of the script through Python code.
        #
        # This approach facilitates parameter sweeps, automatic adjustments of simulation inputs,
        # and easy reconfiguration of simulation settings, making it suitable for high-throughput
        # or iterative simulations in LAMMPS.
        #
        # The script can be saved, loaded, or executed in Python as a `dscript` object, providing
        # a robust tool for dynamic LAMMPS input file generation and manipulation.
        ################################################################################
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    # This flexible approach enables dynamic manipulation of simulation parameters.
    # The full TLSPH template is defined as a multi-line script in DSCRIPT format.
    # The following template was automatically generated by ChatGPT based on the
    # original LAMMPS TLSPH simulation script for elongating a 2D strip of linear
    # elastic material by pulling its ends apart.
    #
    # Key variables (such as Young&#39;s modulus, Poisson&#39;s ratio, and mass density)
    # have been added to the DEFINITIONS section for dynamic substitution in the
    # template.
    #
    # Read the synopsis of this module to learn how to instruct ChatGPT to generate
    # such templates.

    TLSPH_template = &#34;&#34;&#34;# DSCRIPT SAVE FILE
# TENSILE SUMULATION
####################################################################################################
#
# TLSPH example: elongate a 2d strip of a linear elastic material py pulling its ends apart
#
# unit sytem: GPa / mm / ms
#
####################################################################################################
# Source:
# GLOBAL PARAMETERS
{
    SECTIONS = [&#39;INITIALIZE&#39;, &#39;CREATE_GEOMETRY&#39;, &#39;DISCRETIZATION&#39;, &#39;BOUNDARY_CONDITIONS&#39;, &#39;PHYSICS&#39;, &#39;OUTPUT&#39;, &#39;RUN&#39;],
    section = 0,
    position = 0,
    role = &#34;dscript instance&#34;,
    description = &#34;Advanced example based on ChatGPT translation&#34;,
    userid = &#34;ChatGPT&#34;,
    version = 1.0,
    verbose = False
}

# DEFINITIONS (number of definitions=12)
E=1.0              # Young&#39;s modulus
nu=0.3             # Poisson ratio
rho=1.0            # Initial mass density
q1=0.06            # Artificial viscosity linear coefficient
q2=0.0             # Artificial viscosity quadratic coefficient
hg=10.0            # Hourglass control coefficient
cp=1.0             # Heat capacity
l0=1.0             # Lattice spacing
h=2.01 * ${l0}     # SPH smoothing kernel radius
vol_one=${l0}**2   # Volume of one particle (unit thickness)
vel0=0.005         # Pull velocity
skin=${h}          # Verlet list range

# TEMPLATE (number of lines=8)
initialize: [
    dimension 2
    units si
    boundary sm sm p
    atom_style smd
    atom_modify map array
    comm_modify vel yes
    neigh_modify every 10 delay 0 check yes
    newton off ]

# set region dimensions
boxlength = 10  # variables can be defined and changed any time (only the last definition is retained)
boxdepth =  0.1 # variables can be defined and changed any time (only the last definition is retained)

create: [
    lattice sq ${l0}
    region box block ${boxlength} ${boxlength} ${boxlength} ${boxlength} ${boxdepth} ${boxdepth} units box
    create_box 1 box
    create_atoms 1 box
    group tlsph type 1 ]

discretization: [
    neighbor ${skin} bin
    set group all volume ${vol_one}
    set group all smd_mass_density ${rho}
    set group all diameter ${h} ]

boundary_conditions: [
    region top block EDGE EDGE 9.0 EDGE EDGE EDGE units box
    region bot block EDGE EDGE EDGE 9.1 EDGE EDGE units box
    group top region top
    group bot region bot
    variable vel_up equal ${vel0} * (1.0 exp(0.01 * time))
    variable vel_down equal v_vel_up
    fix veltop_fix top smd/setvelocity 0 v_vel_up 0
    fix velbot_fix bot smd/setvelocity 0 v_vel_down 0 ]

physics: [
    pair_style smd/tlsph
    pair_coeff 1 1 *COMMON ${rho} ${E} ${nu} ${q1} ${q2} ${hg} ${cp} &amp;
    *STRENGTH_LINEAR &amp;
    *EOS_LINEAR &amp;
    *END ]

output: [
    compute S all smd/tlsph_stress
    compute E all smd/tlsph_strain
    compute nn all smd/tlsph_num_neighs
    dump dump_id all custom 10 dump.LAMMPS id type x y z vx vy vz &amp;
    c_S[1] c_S[2] c_S[4] c_nn &amp;
    c_E[1] c_E[2] c_E[4] &amp;
    vx vy vz
    dump_modify dump_id first yes ]

# add filename
outputfilename = &#34;$stress_strain.dat&#34; # variables can be defined and changed any time

status_output: [
    variable stress equal 0.5 * (f_velbot_fix[2] - f_veltop_fix[2]) / 20
    variable length equal xcm(top,y) - xcm(bot,y)
    variable strain equal (v_length - ${length}) / ${length}
    fix stress_curve all print 10 &#34;${strain} ${stress}&#34; file ${outputfilename} screen no
    thermo 100
    thermo_style custom step dt f_dtfix v_strain ]

# add runtime
runtime = 2000  # variables can be defined and changed any time

# single liner template
run_simulation: run ${runtime}

# change runtime
runtime = 2500  # variables can be defined and changed any time (only the last definition is retained)


# ATTRIBUTES (number of lines with explicit attributes=0)

    &#34;&#34;&#34;

    TLSPH = dscript.parsesyntax(TLSPH_template)  # this is a dscript instance
    TLSPH_script = TLSPH.script()                # this is a script instance
    TLSPH.code = TLSPH_script.do()               # this is the corresponding LAMMPS code
    print(TLSPH.code)
    # Note that some definitions are missing since they are calculated by LAMMPS during the simulation
    # It includes: stress, strain, length
    repr(TLSPH.DEFINITIONS)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dscript.autoname"><code class="name flex">
<span>def <span class="ident">autoname</span></span>(<span>numChars=8)</span>
</code></dt>
<dd>
<div class="desc"><p>generate automatically names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autoname(numChars=8):
    &#34;&#34;&#34; generate automatically names &#34;&#34;&#34;
    return &#39;&#39;.join(random.choices(string.ascii_letters, k=numChars))  # Generates a random name of numChars letters</code></pre>
</details>
</dd>
<dt id="dscript.frame_header"><code class="name flex">
<span>def <span class="ident">frame_header</span></span>(<span>lines, padding=2, style=1, corner_symbols=None, horizontal_symbol=None, vertical_symbol=None, empty_line_symbol=None, line_fill_symbol=None, comment='#')</span>
</code></dt>
<dd>
<div class="desc"><p>Format the header content into an ASCII framed box with customizable properties.</p>
<h2 id="parameters">Parameters</h2>
<p>lines (list or tuple): The lines to include in the header.
- Empty strings "" are replaced with lines of <code>line_fill_symbol</code>.
- None values are treated as empty lines.</p>
<p>padding (int, optional): Number of spaces to pad on each side of the content. Default is 2.
style (int, optional): Style index (1 to 6) for predefined frame styles. Default is 1.
corner_symbols (str or tuple, optional): Symbols for the corners (top-left, top-right, bottom-left, bottom-right).
Can be a string (e.g., "+") for uniform corners.
horizontal_symbol (str, optional): Symbol to use for horizontal lines.
vertical_symbol (str, optional): Symbol to use for vertical lines.
empty_line_symbol (str, optional): Symbol to use for empty lines inside the frame.
line_fill_symbol (str, optional): Symbol to fill lines that replace empty strings.
comment (str, optional): Comment symbol to prefix each line. Can be multiple characters. Default is "#".</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted header as a string.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the specified style is undefined or <code>corner_symbols</code> is invalid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frame_header(
    lines,
    padding=2,
    style=1,
    corner_symbols=None,  # Can be a string or a tuple
    horizontal_symbol=None,
    vertical_symbol=None,
    empty_line_symbol=None,
    line_fill_symbol=None,
    comment=&#34;#&#34;
):
    &#34;&#34;&#34;
    Format the header content into an ASCII framed box with customizable properties.

    Parameters:
        lines (list or tuple): The lines to include in the header.
            - Empty strings &#34;&#34; are replaced with lines of `line_fill_symbol`.
            - None values are treated as empty lines.

        padding (int, optional): Number of spaces to pad on each side of the content. Default is 2.
        style (int, optional): Style index (1 to 6) for predefined frame styles. Default is 1.
        corner_symbols (str or tuple, optional): Symbols for the corners (top-left, top-right, bottom-left, bottom-right).
                                                 Can be a string (e.g., &#34;+&#34;) for uniform corners.
        horizontal_symbol (str, optional): Symbol to use for horizontal lines.
        vertical_symbol (str, optional): Symbol to use for vertical lines.
        empty_line_symbol (str, optional): Symbol to use for empty lines inside the frame.
        line_fill_symbol (str, optional): Symbol to fill lines that replace empty strings.
        comment (str, optional): Comment symbol to prefix each line. Can be multiple characters. Default is &#34;#&#34;.

    Returns:
        str: The formatted header as a string.

    Raises:
        ValueError: If the specified style is undefined or `corner_symbols` is invalid.
    &#34;&#34;&#34;
    # Predefined styles
    styles = {
        1: {
            &#34;corner_symbols&#34;: (&#34;+&#34;, &#34;+&#34;, &#34;+&#34;, &#34;+&#34;),
            &#34;horizontal_symbol&#34;: &#34;-&#34;,
            &#34;vertical_symbol&#34;: &#34;|&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;-&#34;
        },
        2: {
            &#34;corner_symbols&#34;: (&#34;╔&#34;, &#34;╗&#34;, &#34;╚&#34;, &#34;╝&#34;),
            &#34;horizontal_symbol&#34;: &#34;═&#34;,
            &#34;vertical_symbol&#34;: &#34;║&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;═&#34;
        },
        3: {
            &#34;corner_symbols&#34;: (&#34;.&#34;, &#34;.&#34;, &#34;&#39;&#34;, &#34;&#39;&#34;),
            &#34;horizontal_symbol&#34;: &#34;-&#34;,
            &#34;vertical_symbol&#34;: &#34;|&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;-&#34;
        },
        4: {
            &#34;corner_symbols&#34;: (&#34;#&#34;, &#34;#&#34;, &#34;#&#34;, &#34;#&#34;),
            &#34;horizontal_symbol&#34;: &#34;=&#34;,
            &#34;vertical_symbol&#34;: &#34;#&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;=&#34;
        },
        5: {
            &#34;corner_symbols&#34;: (&#34;┌&#34;, &#34;┐&#34;, &#34;└&#34;, &#34;┘&#34;),
            &#34;horizontal_symbol&#34;: &#34;─&#34;,
            &#34;vertical_symbol&#34;: &#34;│&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;─&#34;
        },
        6: {
            &#34;corner_symbols&#34;: (&#34;.&#34;, &#34;.&#34;, &#34;.&#34;, &#34;.&#34;),
            &#34;horizontal_symbol&#34;: &#34;.&#34;,
            &#34;vertical_symbol&#34;: &#34;:&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;.&#34;
        }
    }

    # Validate style and set defaults
    if style not in styles:
        raise ValueError(f&#34;Undefined style {style}. Valid styles are {list(styles.keys())}.&#34;)

    selected_style = styles[style]

    # Convert corner_symbols to a tuple of 4 values
    if isinstance(corner_symbols, str):
        corner_symbols = (corner_symbols,) * 4
    elif isinstance(corner_symbols, (list, tuple)) and len(corner_symbols) == 1:
        corner_symbols = tuple(corner_symbols * 4)
    elif isinstance(corner_symbols, (list, tuple)) and len(corner_symbols) == 2:
        corner_symbols = (corner_symbols[0], corner_symbols[1], corner_symbols[0], corner_symbols[1])
    elif corner_symbols is None:
        corner_symbols = selected_style[&#34;corner_symbols&#34;]
    elif not isinstance(corner_symbols, (list, tuple)) or len(corner_symbols) != 4:
        raise ValueError(&#34;corner_symbols must be a string or a tuple/list of 1, 2, or 4 elements.&#34;)

    # Apply overrides or defaults
    horizontal_symbol = horizontal_symbol or selected_style[&#34;horizontal_symbol&#34;]
    vertical_symbol = vertical_symbol or selected_style[&#34;vertical_symbol&#34;]
    empty_line_symbol = empty_line_symbol or selected_style[&#34;empty_line_symbol&#34;]
    line_fill_symbol = line_fill_symbol or selected_style[&#34;line_fill_symbol&#34;]

    # Process lines: Replace &#34;&#34; with line_fill placeholders, None with empty lines
    processed_lines = []
    max_content_width = 0
    for line in lines:
        if line == &#34;&#34;:
            processed_lines.append(&#34;&lt;LINE_FILL&gt;&#34;)
        elif line is None:
            processed_lines.append(None)
        else:
            processed_lines.append(line)
            max_content_width = max(max_content_width, len(line))

    # Adjust width for padding
    frame_width = max_content_width + padding * 2

    # Build the top border
    top_border = f&#34;{corner_symbols[0]}{horizontal_symbol * frame_width}{corner_symbols[1]}&#34;

    # Build content lines with vertical borders
    framed_lines = [top_border]
    for line in processed_lines:
        if line is None:
            empty_line = f&#34;{vertical_symbol}{empty_line_symbol * frame_width}{vertical_symbol}&#34;
            framed_lines.append(empty_line)
        elif line == &#34;&lt;LINE_FILL&gt;&#34;:
            fill_line = f&#34;{vertical_symbol}{line_fill_symbol * frame_width}{vertical_symbol}&#34;
            framed_lines.append(fill_line)
        else:
            content = line.center(frame_width)
            framed_line = f&#34;{vertical_symbol}{content}{vertical_symbol}&#34;
            framed_lines.append(framed_line)

    # Build the bottom border
    bottom_border = f&#34;{corner_symbols[2]}{horizontal_symbol * frame_width}{corner_symbols[3]}&#34;
    framed_lines.append(bottom_border)

    # Ensure all lines start with the comment symbol
    commented_lines = [
        line if line.startswith(comment) else f&#34;{comment} {line}&#34; for line in framed_lines
    ]

    return &#34;\n&#34;.join(commented_lines)+&#34;\n&#34;</code></pre>
</details>
</dd>
<dt id="dscript.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary of explicitly defined metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata():
    &#34;&#34;&#34;Return a dictionary of explicitly defined metadata.&#34;&#34;&#34;
    # Define the desired metadata keys
    metadata_keys = [
        &#34;__project__&#34;,
        &#34;__author__&#34;,
        &#34;__copyright__&#34;,
        &#34;__credits__&#34;,
        &#34;__license__&#34;,
        &#34;__maintainer__&#34;,
        &#34;__email__&#34;,
        &#34;__version__&#34;,
    ]
    # Filter only the desired keys from the current module&#39;s globals
    return {key.strip(&#34;_&#34;): globals()[key] for key in metadata_keys if key in globals()}</code></pre>
</details>
</dd>
<dt id="dscript.remove_comments"><code class="name flex">
<span>def <span class="ident">remove_comments</span></span>(<span>content, split_lines=False, emptylines=False, comment_chars='#', continuation_marker='\\\\', remove_continuation_marker=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes comments from a single or multi-line string, handling quotes, escaped characters, and line continuation.</p>
<h2 id="parameters">Parameters:</h2>
<p>content : str
The input string, which may contain multiple lines. Each line will be processed
individually to remove comments, while preserving content inside quotes.
split_lines : bool, optional (default: False)
If True, the function will return a list of processed lines. If False, it will
return a single string with all lines joined by newlines.
emptylines : bool, optional (default: False)
If True, empty lines will be preserved in the output. If False, empty lines
will be removed from the output.
comment_chars : str, optional (default: "#")
A string containing characters to identify the start of a comment.
Any of these characters will mark the beginning of a comment unless within quotes.
continuation_marker : str or None, optional (default: "\")
A string containing characters to indicate line continuation (use <code>\</code> to specify).
Any characters after the continuation marker are ignored as a comment. If set to <code>None</code>
or an empty string, line continuation will not be processed.
remove_continuation_marker : bool, optional (default: False)
If True, the continuation marker itself is removed from the processed line, keeping
only the characters before it. If False, the marker is retained as part of the line.</p>
<h2 id="returns">Returns:</h2>
<p>str or list of str
The processed content with comments removed. Returns a list of lines if
<code>split_lines</code> is True, or a single string if False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_comments(content, split_lines=False, emptylines=False, comment_chars=&#34;#&#34;, continuation_marker=&#34;\\\\&#34;, remove_continuation_marker=False):
    &#34;&#34;&#34;
    Removes comments from a single or multi-line string, handling quotes, escaped characters, and line continuation.

    Parameters:
    -----------
    content : str
        The input string, which may contain multiple lines. Each line will be processed
        individually to remove comments, while preserving content inside quotes.
    split_lines : bool, optional (default: False)
        If True, the function will return a list of processed lines. If False, it will
        return a single string with all lines joined by newlines.
    emptylines : bool, optional (default: False)
        If True, empty lines will be preserved in the output. If False, empty lines
        will be removed from the output.
    comment_chars : str, optional (default: &#34;#&#34;)
        A string containing characters to identify the start of a comment.
        Any of these characters will mark the beginning of a comment unless within quotes.
    continuation_marker : str or None, optional (default: &#34;\\\\&#34;)
        A string containing characters to indicate line continuation (use `\\` to specify).
        Any characters after the continuation marker are ignored as a comment. If set to `None`
        or an empty string, line continuation will not be processed.
    remove_continuation_marker : bool, optional (default: False)
        If True, the continuation marker itself is removed from the processed line, keeping
        only the characters before it. If False, the marker is retained as part of the line.

    Returns:
    --------
    str or list of str
        The processed content with comments removed. Returns a list of lines if
        `split_lines` is True, or a single string if False.
    &#34;&#34;&#34;
    def process_line(line):
        &#34;&#34;&#34;Remove comments and handle line continuation within a single line while managing quotes and escapes.&#34;&#34;&#34;
        in_single_quote = False
        in_double_quote = False
        escaped = False
        result = []

        i = 0
        while i &lt; len(line):
            char = line[i]

            if escaped:
                result.append(char)
                escaped = False
                i += 1
                continue

            # Handle escape character within quoted strings
            if char == &#39;\\&#39; and (in_single_quote or in_double_quote):
                escaped = True
                result.append(char)
                i += 1
                continue

            # Toggle state for single and double quotes
            if char == &#34;&#39;&#34; and not in_double_quote:
                in_single_quote = not in_single_quote
            elif char == &#39;&#34;&#39; and not in_single_quote:
                in_double_quote = not in_double_quote

            # Check for line continuation marker if it&#39;s set and outside of quotes
            if continuation_marker and not in_single_quote and not in_double_quote:
                # Check if the remaining part of the line matches the continuation marker
                if line[i:].startswith(continuation_marker):
                    # Optionally remove the continuation marker
                    if remove_continuation_marker:
                        result.append(line[:i].rstrip())  # Keep everything before the marker
                    else:
                        result.append(line[:i + len(continuation_marker)].rstrip())  # Include the marker itself
                    return &#39;&#39;.join(result).strip()

            # Check for comment start characters outside of quotes
            if char in comment_chars and not in_single_quote and not in_double_quote:
                break  # Stop processing the line when a comment is found

            result.append(char)
            i += 1

        return &#39;&#39;.join(result).strip()

    # Split the input content into lines
    lines = content.split(&#39;\n&#39;)

    # Process each line, considering the emptylines flag
    processed_lines = []
    for line in lines:
        stripped_line = line.strip()
        if not stripped_line and not emptylines:
            continue  # Skip empty lines if emptylines is False
        if any(stripped_line.startswith(c) for c in comment_chars):
            continue  # Skip lines that are pure comments
        processed_line = process_line(line)
        if processed_line or emptylines:  # Only add non-empty lines if emptylines is False
            processed_lines.append(processed_line)

    if split_lines:
        return processed_lines  # Return list of processed lines
    else:
        return &#39;\n&#39;.join(processed_lines)  # Join lines back into a single string</code></pre>
</details>
</dd>
<dt id="dscript.span"><code class="name flex">
<span>def <span class="ident">span</span></span>(<span>vector, sep=' ', left='', right='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def span(vector,sep=&#34; &#34;,left=&#34;&#34;,right=&#34;&#34;):
    return left + (vector if isinstance(vector, str) else sep.join(map(str, vector))) + right if vector is not None else &#34;&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dscript.ScriptTemplate"><code class="flex name class">
<span>class <span class="ident">ScriptTemplate</span></span>
<span>(</span><span>content='', definitions=Lambda Script Parameters (LSD object) with 0 parameter definitions, autorefresh=True, userid=None, verbose=False, comment_chars='#%', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> class provides a mechanism to store, process, and dynamically substitute
variables within script content. This class supports handling flags and conditions, allowing
for flexible and conditional execution of parts of the script.</p>
<p>Attributes:</p>
<hr>
<p>default_attributes : dict (class-level)
A dictionary containing the default flags for each <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> object. These attributes
are applied when initializing the object or when no flags are specified in the content.
Flags include:
- facultative (bool): If True, the script line is optional and may be discarded if certain
conditions are not met. (default: False)
- eval (bool): If True, the content is evaluated using <code>formateval</code>, which allows for variable
substitution during execution. (default: False)
- readonly (bool): If True, the content cannot be modified after initialization. (default: False)
- condition (str or None): A string that specifies a condition for executing the content.
If the condition is not met, the script line is skipped. (default: None)
- condeval (bool): If True, the <code>condition</code> attribute is evaluated dynamically using variables.
(default: False)
- detectvar (bool): If True, any variables in the content (e.g., <code>${varname}</code>) are automatically
detected and registered in the definitions. (default: True)</p>
<p>Methods:</p>
<hr>
<p><strong>init</strong>(self, content="", definitions=lambdaScriptdata(), userid=None, verbose=False, **kwargs):
Initializes the <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> object with script content, optional variable definitions,
and configurable attributes. Flags like <code>facultative</code>, <code>eval</code>, <code>readonly</code>, <code>condition</code>,
and others are set via content prefixes or passed directly as keyword arguments.</p>
<p>parse_content(cls, content, verbose=False):
A class method that parses content to detect special flags and condition tags, returning the
cleaned content and a dictionary of attributes (flags).</p>
<pre><code> The method processes the following flags and tags:
 - `!` : Sets `eval=True`, which forces evaluation of the content.
 - `?` : Sets `facultative=True`, marking the content as optional.
 - `^` : Sets `readonly=True`, preventing modifications to the content.
 - `~` : Sets `detectvar=False`, disabling automatic variable detection.
 - `[if:condition]` : Defines a condition for executing the script. If the condition is met,
   the script will be executed. Conditions can include `;eval` to trigger evaluation.

 Parameters:
 -----------
 content : str
     The script content to be parsed. It may contain lines starting with special characters
     that set specific attributes for the script template.

 verbose : bool (default: False)
     If True, preserves comments and does not remove comment lines during parsing.

 Returns:
 --------
 cleaned_content : str
     The cleaned script content, with all flags and conditions removed.

 attributes : dict
     A dictionary of parsed attributes (flags) including:
     - facultative (bool): Indicates if the content is optional.
     - eval (bool): Specifies if the content should be evaluated for variable substitution.
     - readonly (bool): Prevents modifications to the content.
     - condition (str or None): Defines the condition for executing the script.
     - condeval (bool): If True, dynamically evaluates the condition.
     - detectvar (bool): If True, detects and registers variables in the content.
</code></pre>
<p>detect_variables(self):
Detects variables in the content using the pattern <code>${varname}</code>. It returns a list of
variable names found in the script.</p>
<p>refreshvar(self):
Ensures that any detected variables are added to the <code>definitions</code> if they are missing.</p>
<p><strong>setattr</strong>(self, name, value):
Sets the value of an attribute. The method performs validation on specific attributes
(e.g., <code>eval</code>, <code>readonly</code>, <code>facultative</code>, etc.) to ensure the correct data types are assigned.</p>
<p><strong>getattr</strong>(self, name):
Retrieves the value of an attribute. If the attribute is not set, it returns the default
value from <code>default_attributes</code>.</p>
<h2 id="example-1">Example 1:</h2>
<h1 id="create-a-scripttemplate-object-with-content-and-optional-definitions">Create a ScriptTemplate object with content and optional definitions</h1>
<p>line = ScriptTemplate("dimension
${dimension}")</p>
<h1 id="you-can-also-pass-in-global-definitions-if-needed">You can also pass in global definitions if needed</h1>
<p>global_definitions = lambdaScriptdata(dimension=3)
line_with_defs = ScriptTemplate("dimension
${dimension}",
definitions=global_definitions)</p>
<p>After initialization, you can modify the line's attributes or use it as
part of a larger script managed by a <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object.</p>
<p>Example 2:</p>
<hr>
<p># Example of using flags and conditions in content</p>
<p>line = ScriptTemplate("!velocity all set 0.0 0.0 0.0 units box")
# This will automatically set <code>eval=True</code> due to the '!' flag.</p>
<p>line_with_condition = ScriptTemplate("[if: ${condition};eval] fix upper move wiggle 0.0 0.0 1.0 1.0")
# This content will only execute if <code>${condition}</code> is True, and <code>eval</code> will be applied to substitute variables.</p>
<p>Initializes a new <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> object.</p>
<p>The constructor sets up a new script template with content, optional variable
definitions, and a set of configurable attributes. This template is capable
of dynamically substituting variables using a provided <code><a title="dscript.lambdaScriptdata" href="#dscript.lambdaScriptdata">lambdaScriptdata</a></code>
object or internal definitions. You can also manage attributes like evaluation,
facultative execution, and variable detection.</p>
<h2 id="parameters">Parameters:</h2>
<p>content : str or list of str
The content of the script template, which can be a single string or a list of strings.
If a single string is provided, it will automatically be converted to a list of lines.
This ensures consistent handling of multi-line content.</p>
<p>definitions : lambdaScriptdata, optional
A reference to a <code><a title="dscript.lambdaScriptdata" href="#dscript.lambdaScriptdata">lambdaScriptdata</a></code> object that contains global variable
definitions. These definitions will be used to substitute variables within the content.
If <code>definitions</code> is not provided, variable substitution will rely on local
or inline definitions.</p>
<p>verbose : flag (default value=True)
If True the comments are preserved (applied when str is a string).</p>
<p>autorefresh : flag (default=False)
If True, new variables are automatically detected when the content is changed</p>
<p>**kwargs :
Additional keyword arguments to set specific attributes for the script line.
These attributes control the behavior of the script template during evaluation
and execution. Any keyword argument passed here will update the default
attribute values.</p>
<pre><code>    Default attributes (with default values):
- facultative (False):
    If True, the script line is optional and may be discarded if certain conditions are not met.
- eval (False):
    If True, the content will be evaluated using &lt;code&gt;formateval&lt;/code&gt;, allowing variable
    substitution during the execution.
- readonly (False):
    If True, the content of the script cannot be modified after initialization.
- condition (None):
    An optional condition that controls whether the content will be executed.
    If the condition is not met, the script line will not be executed.
- condeval (False):
    If True, the &lt;code&gt;condition&lt;/code&gt; attribute will be evaluated, allowing conditional
    logic based on variable values.
- detectvar (True):
    If True, the content will automatically detect and register any variables
    (such as `${varname}`) within the &lt;code&gt;definitions&lt;/code&gt; for substitution.
- comment_chars : str, optional (default: "#%")
    A string containing characters to identify the start of a comment.
    Any of these characters will mark the beginning of a comment unless within quotes.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScriptTemplate:
    &#34;&#34;&#34;
     The `ScriptTemplate` class provides a mechanism to store, process, and dynamically substitute
     variables within script content. This class supports handling flags and conditions, allowing
     for flexible and conditional execution of parts of the script.

     Attributes:
     -----------
     default_attributes : dict (class-level)
         A dictionary containing the default flags for each `ScriptTemplate` object. These attributes
         are applied when initializing the object or when no flags are specified in the content.
         Flags include:
         - facultative (bool): If True, the script line is optional and may be discarded if certain
             conditions are not met. (default: False)
         - eval (bool): If True, the content is evaluated using `formateval`, which allows for variable
             substitution during execution. (default: False)
         - readonly (bool): If True, the content cannot be modified after initialization. (default: False)
         - condition (str or None): A string that specifies a condition for executing the content.
             If the condition is not met, the script line is skipped. (default: None)
         - condeval (bool): If True, the `condition` attribute is evaluated dynamically using variables.
             (default: False)
         - detectvar (bool): If True, any variables in the content (e.g., `${varname}`) are automatically
             detected and registered in the definitions. (default: True)

     Methods:
     --------
     __init__(self, content=&#34;&#34;, definitions=lambdaScriptdata(), userid=None, verbose=False, **kwargs):
         Initializes the `ScriptTemplate` object with script content, optional variable definitions,
         and configurable attributes. Flags like `facultative`, `eval`, `readonly`, `condition`,
         and others are set via content prefixes or passed directly as keyword arguments.

     parse_content(cls, content, verbose=False):
         A class method that parses content to detect special flags and condition tags, returning the
         cleaned content and a dictionary of attributes (flags).

         The method processes the following flags and tags:
         - `!` : Sets `eval=True`, which forces evaluation of the content.
         - `?` : Sets `facultative=True`, marking the content as optional.
         - `^` : Sets `readonly=True`, preventing modifications to the content.
         - `~` : Sets `detectvar=False`, disabling automatic variable detection.
         - `[if:condition]` : Defines a condition for executing the script. If the condition is met,
           the script will be executed. Conditions can include `;eval` to trigger evaluation.

         Parameters:
         -----------
         content : str
             The script content to be parsed. It may contain lines starting with special characters
             that set specific attributes for the script template.

         verbose : bool (default: False)
             If True, preserves comments and does not remove comment lines during parsing.

         Returns:
         --------
         cleaned_content : str
             The cleaned script content, with all flags and conditions removed.

         attributes : dict
             A dictionary of parsed attributes (flags) including:
             - facultative (bool): Indicates if the content is optional.
             - eval (bool): Specifies if the content should be evaluated for variable substitution.
             - readonly (bool): Prevents modifications to the content.
             - condition (str or None): Defines the condition for executing the script.
             - condeval (bool): If True, dynamically evaluates the condition.
             - detectvar (bool): If True, detects and registers variables in the content.

     detect_variables(self):
         Detects variables in the content using the pattern `${varname}`. It returns a list of
         variable names found in the script.

     refreshvar(self):
         Ensures that any detected variables are added to the `definitions` if they are missing.

     __setattr__(self, name, value):
         Sets the value of an attribute. The method performs validation on specific attributes
         (e.g., `eval`, `readonly`, `facultative`, etc.) to ensure the correct data types are assigned.

     __getattr__(self, name):
         Retrieves the value of an attribute. If the attribute is not set, it returns the default
         value from `default_attributes`.


    Example 1:
    ----------
    # Create a ScriptTemplate object with content and optional definitions
    line = ScriptTemplate(&#34;dimension    ${dimension}&#34;)

    # You can also pass in global definitions if needed
    global_definitions = lambdaScriptdata(dimension=3)
    line_with_defs = ScriptTemplate(&#34;dimension    ${dimension}&#34;,
                                    definitions=global_definitions)

    After initialization, you can modify the line&#39;s attributes or use it as
    part of a larger script managed by a `dscript` object.


     Example 2:
     ----------
     # Example of using flags and conditions in content

     line = ScriptTemplate(&#34;!velocity all set 0.0 0.0 0.0 units box&#34;)
     # This will automatically set `eval=True` due to the &#39;!&#39; flag.

     line_with_condition = ScriptTemplate(&#34;[if: ${condition};eval] fix upper move wiggle 0.0 0.0 1.0 1.0&#34;)
     # This content will only execute if `${condition}` is True, and `eval` will be applied to substitute variables.

    &#34;&#34;&#34;

    # Class-level attribute for default flags
    default_attributes = {
        &#39;facultative&#39;: False,
        &#39;eval&#39;: False,
        &#39;readonly&#39;: False,
        &#39;condition&#39;: None,
        &#39;condeval&#39;: False,
        &#39;detectvar&#39;: True
    }

    def __init__(self, content=&#34;&#34;, definitions=lambdaScriptdata(), autorefresh=True, userid=None, verbose=False, comment_chars=&#34;#%&#34;, **kwargs):
        &#34;&#34;&#34;
        Initializes a new `ScriptTemplate` object.

        The constructor sets up a new script template with content, optional variable
        definitions, and a set of configurable attributes. This template is capable
        of dynamically substituting variables using a provided `lambdaScriptdata`
        object or internal definitions. You can also manage attributes like evaluation,
        facultative execution, and variable detection.

        Parameters:
        -----------
        content : str or list of str
            The content of the script template, which can be a single string or a list of strings.
            If a single string is provided, it will automatically be converted to a list of lines.
            This ensures consistent handling of multi-line content.

        definitions : lambdaScriptdata, optional
            A reference to a `lambdaScriptdata` object that contains global variable
            definitions. These definitions will be used to substitute variables within the content.
            If `definitions` is not provided, variable substitution will rely on local
            or inline definitions.

        verbose : flag (default value=True)
            If True the comments are preserved (applied when str is a string).

        autorefresh : flag (default=False)
            If True, new variables are automatically detected when the content is changed

        **kwargs :
            Additional keyword arguments to set specific attributes for the script line.
            These attributes control the behavior of the script template during evaluation
            and execution. Any keyword argument passed here will update the default
            attribute values.

                Default attributes (with default values):
            - facultative (False):
                If True, the script line is optional and may be discarded if certain conditions are not met.
            - eval (False):
                If True, the content will be evaluated using `formateval`, allowing variable
                substitution during the execution.
            - readonly (False):
                If True, the content of the script cannot be modified after initialization.
            - condition (None):
                An optional condition that controls whether the content will be executed.
                If the condition is not met, the script line will not be executed.
            - condeval (False):
                If True, the `condition` attribute will be evaluated, allowing conditional
                logic based on variable values.
            - detectvar (True):
                If True, the content will automatically detect and register any variables
                (such as `${varname}`) within the `definitions` for substitution.
            - comment_chars : str, optional (default: &#34;#%&#34;)
                A string containing characters to identify the start of a comment.
                Any of these characters will mark the beginning of a comment unless within quotes.
        &#34;&#34;&#34;


        # Initialize `_CACHE` with separate entries for each method
        self._CACHE = {
            &#39;variables&#39;: {&#39;result&#39;: None},
            &#39;check_variables&#39;: {&#39;result&#39;: None}
        }
        # Constructor
        self._autorefresh = autorefresh
        self._content = content # # Store initial content
        self.definitions = lambdaScriptdata(**definitions)  # Reference to the DEFINITIONS object
        # Initialize attributes with default values
        self.attributes = self.default_attributes.copy()
        # Convert single string content to a list for consistent processing
        if content == &#34;&#34; or content is None:
            content = &#34;&#34;  # Set to empty string if None
        elif isinstance(content, str):
            # Interpret the content and extract any attribute flags (e.g. !, ?, etc.)
            content, self.attributes = self.parse_content(content, verbose=verbose)
            # Convert content to a list of strings
            if verbose:
                content = content.split(&#39;\n&#39;)  # All comments are preserved during construction
            else:
                content = remove_comments(content, split_lines=True,comment_chars=comment_chars)  # Split string by newlines into list of strings
        elif not isinstance(content, list) or not all(isinstance(item, str) for item in content):
            raise TypeError(&#34;The &#39;content&#39; attribute must be a string or a list of strings.&#34;)
        # Update attributes with any additional keyword arguments passed in
        self.attributes.update(kwargs)
        # Detect variables in the content
        detected_variables = self.detect_variables()
        # Automatically set `eval=True` if any detected variables are defined in `definitions`
        if detected_variables:
            for var in detected_variables:
                if var in self.definitions:
                    self.attributes[&#39;eval&#39;] = True
                    break  # No need to continue checking once we know eval should be set
        # Assign userid (optional)
        self.userid = userid if userid is not None else autoname(3)
        # Assign content to the object
        self.content = content if content != [] else [f&#34;# &lt;empty content&gt; for key {self.userid}&#34;]


    def _calculate_content_hash(self, content):
        &#34;&#34;&#34;Generate hash for content.&#34;&#34;&#34;
        return hashlib.md5(&#34;\n&#34;.join(content).encode()).hexdigest() if isinstance(content, list) else hashlib.md5(content.encode()).hexdigest()

    @property
    def content(self):
        return self._content

    @content.setter
    def content(self, new_content):
        &#34;&#34;&#34;Set content and reinitialize cache if the content has changed.&#34;&#34;&#34;
        new_content_hash = self._calculate_content_hash(new_content)
        if new_content_hash != self._content_hash:
            self._content = new_content
            self._content_hash = new_content_hash
            self._invalidate_cache()  # Reset cache only if content changes


    def _update_content(self, value):
        &#34;&#34;&#34;Helper to set _content and _content_hash, refreshing cache as necessary.&#34;&#34;&#34;
        # Check if content modification is allowed based on readonly attribute
        if getattr(self, &#39;attributes&#39;, {}).get(&#39;readonly&#39;, False):
            raise AttributeError(&#34;Cannot modify content. It is read-only.&#34;)
        # Validate and process content as either a string or list of strings
        if isinstance(value, str):
            value = remove_comments(value, split_lines=True)
        elif not isinstance(value, list) or not all(isinstance(item, str) for item in value):
            raise TypeError(&#34;The &#39;content&#39; attribute must be a string or a list of strings.&#34;)
        # Set _content and calculate hash
        super().__setattr__(&#39;_content&#39;, value)
        new_hash = hash(tuple(value))
        # If hash changes, reset cache
        if new_hash != getattr(self, &#39;_content_hash&#39;, None):
            super().__setattr__(&#39;_content_hash&#39;, new_hash)
            self._invalidate_cache()  # Invalidate cache due to content change
            if self._autorefresh:
                self.refreshvar()  # Refresh variables based on new content

    def _invalidate_cache(self):
        &#34;&#34;&#34;Reset all cache entries.&#34;&#34;&#34;
        # Check if _CACHE is initialized
        if not hasattr(self, &#39;_CACHE&#39;):
            self._CACHE = {
                &#39;variables&#39;: {&#39;result&#39;: None},
                &#39;check_variables&#39;: {&#39;result&#39;: None}
            }
        for entry in self._CACHE.values():
            entry[&#39;result&#39;] = None


    @classmethod
    def parse_content(cls, content, verbose=False):
        &#34;&#34;&#34;
        Parse the content string and return:
        1. Cleaned content (without flags or condition tags).
        2. A dictionary of attributes (flags) initialized with default values.

        Parameters:
        -----------
        content : str
            The content string to be parsed.

        Returns:
        --------
        cleaned_content : str
            The cleaned content with all flag prefixes and condition tags removed.
        attributes : dict
            A dictionary of attributes (flags) set based on the content prefixes.
        &#34;&#34;&#34;
        attributes = cls.default_attributes.copy()

        # Handle empty content
        if not content.strip():  # Empty string or whitespace-only
            return &#34;&#34;, attributes

        idx = 0
        cleaned_content = []

        # If content is a single string, split it into lines
        if isinstance(content, str):
            content = content.split(&#39;\n&#39;)

        # Remove leading and trailing empty lines
        while content and content[0].strip() == &#39;&#39;:
            content.pop(0)
        while content and content[-1].strip() == &#39;&#39;:
            content.pop()

        # Process each remaining line to detect flags and conditions
        for line in content:
            idx = 0
            line = line.strip()  # Trim any leading/trailing whitespace

            # Parse flags and conditions only at the beginning of the line
            while idx &lt; len(line):
                ch = line[idx]
                if ch == &#39;!&#39;:
                    attributes[&#39;eval&#39;] = True
                    idx += 1
                elif ch == &#39;?&#39;:
                    attributes[&#39;facultative&#39;] = True
                    idx += 1
                elif ch == &#39;^&#39;:
                    attributes[&#39;readonly&#39;] = True
                    idx += 1
                elif ch == &#39;~&#39;:
                    attributes[&#39;detectvar&#39;] = False
                    idx += 1
                elif line.startswith(&#39;[if:&#39;, idx):
                    # Parse condition
                    end_idx = line.find(&#39;]&#39;, idx)
                    if end_idx == -1:
                        raise ValueError(&#34;Unclosed &#39;[if:]&#39; tag in content&#34;)
                    cond_str = line[idx + 4:end_idx]
                    if &#39;;eval&#39; in cond_str:
                        attributes[&#39;condeval&#39;] = True
                        cond_str = cond_str.replace(&#39;;eval&#39;, &#39;&#39;)
                    attributes[&#39;condition&#39;] = cond_str.strip()
                    idx = end_idx + 1
                else:
                    break  # No more flags or conditions, process the rest of the line

                # Skip any whitespace after flags or conditions
                while idx &lt; len(line) and line[idx] in (&#39; &#39;, &#39;\t&#39;):
                    idx += 1

            # Append the cleaned line (without flags or condition tags)
            cleaned_content.append(line[idx:].strip())

        # Join the cleaned lines back into a single string
        cleaned_content = &#39;\n&#39;.join(cleaned_content)

        return cleaned_content, attributes



    def __str__(self):
        num_attrs = len(self.attributes)  # All attributes count
        return f&#34;1 line/block, {num_attrs} attributes&#34;


    def __repr__(self):
      # Template content section
      total_lines = len(self.content)
      total_variables = len(self.definitions)
      line_word = &#34;lines&#34; if total_lines &gt; 1 else &#34;line&#34;
      variable_word = &#34;defs&#34; if total_variables &gt; 1 else &#34;def&#34;
      content_label = &#34;Template Content&#34;
      content_label += &#34;&#34; if self.userid == &#34;&#34; else f&#34; | id:{self.userid}&#34;
      available_space = 50 - len(content_label) - 1
      repr_str = &#34;-&#34; * 50 + &#34;\n&#34;
      repr_str += f&#34;{content_label}{(&#39;(&#39; + str(total_lines) + &#39; &#39; + line_word + &#39;, &#39; + str(total_variables) + &#39; &#39; + variable_word + &#39;)&#39;).rjust(available_space)}\n&#34;
      repr_str += &#34;-&#34; * 50 + &#34;\n&#34;

      if total_lines &lt; 1:
          repr_str += &#34;&lt; empty content &gt;\n&#34;
      elif total_lines &lt;= 12:
          # If content has 12 or fewer lines, display all lines
          for line in self.content:
              truncated_line = (line[:18] + &#39;[...]&#39; + line[-18:]) if len(line) &gt; 40 else line
              repr_str += f&#34;{truncated_line:&lt;50}\n&#34;
      else:
          # Display first three lines, middle three lines, and last three lines
          for line in self.content[:3]:
              truncated_line = (line[:18] + &#39;[...]&#39; + line[-18:]) if len(line) &gt; 40 else line
              repr_str += f&#34;{truncated_line:&lt;50}\n&#34;
          repr_str += &#34;\t\t[...]\n&#34;
          mid_start = total_lines // 2 - 1
          mid_end = mid_start + 3
          for line in self.content[mid_start:mid_end]:
              truncated_line = (line[:18] + &#39;[...]&#39; + line[-18:]) if len(line) &gt; 40 else line
              repr_str += f&#34;{truncated_line:&lt;50}\n&#34;
          repr_str += &#34;\t\t[...]\n&#34;
          for line in self.content[-3:]:
              truncated_line = (line[:18] + &#39;[...]&#39; + line[-18:]) if len(line) &gt; 40 else line
              repr_str += f&#34;{truncated_line:&lt;50}\n&#34;

      # Detected Variables section in 3-column format
      detected_variables = self.detect_variables()
      if detected_variables:
          repr_str += &#34;-&#34; * 50 + &#34;\n&#34;
          # Count the number of defined and missing variables
          defined_variables = set(self.definitions.keys()) if self.definitions else set()
          variable_word = &#39;Variables&#39; if len(detected_variables) &gt; 1 else &#39;Variable&#39;
          detected_set = set(detected_variables)
          missing_variables = detected_set - defined_variables
          defined_count = len(detected_set &amp; defined_variables)
          missing_count = len(missing_variables)
          total_variables = len(detected_set)
          repr_str += f&#34;Detected {variable_word}{(&#39;(&#39; + str(total_variables) + &#39; / +&#39; + str(defined_count) + &#39; / -&#39; + str(missing_count) + &#39;)&#39;).rjust(50 - len(&#39;Detected Variables&#39;) - 1)}\n&#34;
          repr_str += &#34;-&#34; * 50 + &#34;\n&#34;

          # Display variables with status:
          # [+] for defined variables with values other than &#34;${varname}&#34;
          # [-] for defined variables with default values &#34;${varname}&#34;
          # [ ] for undefined variables
          for i in range(0, len(detected_variables), 3):
              var_set = detected_variables[i:i+3]
              line = &#34;&#34;
              for var in var_set:
                  var_name = (var[:10] + &#39; &#39;) if len(var) &gt; 10 else var.ljust(11)
                  if var in defined_variables:
                      # Check if it&#39;s set to its default value (i.e., &#34;${varname}&#34;)
                      if self.definitions[var] == f&#34;${{{var}}}&#34;:
                          flag = &#39;[-]&#39;
                      else:
                          flag = &#39;[+]&#39;
                  else:
                      flag = &#39;[ ]&#39;
                  line += f&#34;{flag} {var_name}  &#34;
              repr_str += f&#34;{line}\n&#34;

      # Attribute section in 3 columns
      repr_str += &#34;-&#34; * 50 + &#34;\n&#34;
      repr_str += f&#34;Template Attributes{(&#39;(&#39; + str(len(self.attributes)) + &#39; attributes)&#39;).rjust(50 - len(&#39;Template Attributes&#39;) - 1)}\n&#34;
      repr_str += &#34;-&#34; * 50 + &#34;\n&#34;

      # Create a compact three-column layout for attributes with checkboxes
      attr_items = [(attr, &#39;[x]&#39; if value else &#39;[ ]&#39;) for attr, value in self.attributes.items() if attr != &#39;definitions&#39;]
      for i in range(0, len(attr_items), 3):
          attr_set = attr_items[i:i+3]
          line = &#34;&#34;
          for attr, value in attr_set:
              attr_name = (attr[:10] + &#39; &#39;) if len(attr) &gt; 10 else attr.ljust(11)
              line += f&#34;{value} {attr_name}  &#34;
          repr_str += f&#34;{line}\n&#34;

      return repr_str


    def __setattr__(self, name, value):
        # Handle specific attributes with validation
        if name in [&#39;facultative&#39;, &#39;eval&#39;, &#39;readonly&#39;]:
            if not isinstance(value, bool):
                raise TypeError(f&#34;The &#39;{name}&#39; attribute must be a Boolean, not {type(value).__name__}.&#34;)
        elif name == &#39;condition&#39;:
            if not isinstance(value, str) and value is not None:
                raise TypeError(f&#34;The &#39;condition&#39; attribute must be a string or None, not {type(value).__name__}.&#34;)
        elif name == &#39;content&#39;:
            # Use helper to manage content updates and cache invalidation
            self._update_content(value)
            return  # Exit to avoid further processing since _update_content handles the setting
        elif name == &#39;definitions&#39;:
            if not isinstance(value, (lambdaScriptdata, scriptdata)) and value is not None:
                raise TypeError(f&#34;The &#39;definitions&#39; must be a lambdaScriptdata or scriptdata, not {type(value).__name__}.&#34;)

        # Set attributes directly for key fields and avoid recursion
        if name in [&#39;userid&#39;, &#39;attributes&#39;, &#39;definitions&#39;, &#39;_content&#39;, &#39;_content_hash&#39;, &#39;_autorefresh&#39;]:
            super().__setattr__(name, value)
        else:
            # Ensure &#39;attributes&#39; is initialized before updating
            if not hasattr(self, &#39;attributes&#39;) or self.attributes is None:
                self.attributes = {}
            self.attributes[name] = value


    def __getattr__(self, name):
        &#34;&#34;&#34;
        Handles attribute retrieval, checking the following in order:
        1. If &#39;name&#39; is in default_attributes, return the value from attributes if it exists,
           otherwise return the default value from default_attributes.
        2. If &#39;name&#39; is &#39;content&#39;, return the content (or an empty string if content is not set).
        3. If &#39;name&#39; exists in the attributes dictionary, return its value.
        4. If attributes itself exists in __dict__, return the value from attributes if &#39;name&#39; is found.
        5. If all previous checks fail, raise an AttributeError indicating that &#39;name&#39; is not found.
        &#34;&#34;&#34;
        # Ensure &#39;_CACHE&#39; is always accessible without a KeyError
        if name == &#39;_CACHE&#39;:
            # Initialize _CACHE if it does not exist
            if &#39;_CACHE&#39; not in self.__dict__:
                self.__dict__[&#39;_CACHE&#39;] = {
                    &#39;variables&#39;: {&#39;result&#39;: None},
                    &#39;check_variables&#39;: {&#39;result&#39;: None}
                }
            return self.__dict__[&#39;_CACHE&#39;]  # Access _CACHE directly
        # Step 1: Check if &#39;name&#39; is a valid attribute in default_attributes
        if name in self.default_attributes:
            # Directly access __dict__ to avoid recursive lookup
            attributes = self.__dict__.get(&#39;attributes&#39;, {})
            return attributes.get(name, self.default_attributes[name])
        # Step 2: Special case for &#39;content&#39;
        if name == &#39;content&#39;:
            # Directly access __dict__ to avoid recursion
            return self.__dict__.get(&#39;_content&#39;, &#34;&#34;)
        if name == &#34;_autorefresh&#34;:
            return self.__dict__.get(&#39;_autorefresh&#39;, True)
        # Step 3: Check if &#39;name&#39; exists in &#39;attributes&#39; and return its value directly
        attributes = self.__dict__.get(&#39;attributes&#39;, {})
        if name in attributes:
            return attributes[name]
        # Step 4: Check if &#39;attributes&#39; exists in __dict__ and retrieve &#39;name&#39; if present
        if &#39;attributes&#39; in self.__dict__ and name in self.__dict__[&#39;attributes&#39;]:
            return self.__dict__[&#39;attributes&#39;][name]
        # Step 5: If none of the above conditions are met, raise an AttributeError
        raise AttributeError(f&#34;&#39;{self.__class__.__name__}&#39; object has no attribute &#39;{name}&#39;&#34;)




    def do(self, protected=True, softrun=False,globaldefinitions=lambdaScriptdata(),USER=lambdaScriptdata(),**kwargs):
        &#34;&#34;&#34;
        Executes or prepares the script template content based on its attributes and the `softrun` flag.

        Parameters
        ----------
        protected : bool, optional
            If `True` (default), variable evaluation uses a protected environment, safeguarding global definitions
            and system attributes from modification during execution.
        softrun : bool, optional
            Determines if the script is evaluated in a preliminary mode:
            - If `True`, returns the script content without full evaluation, allowing for a preview or
              an initial capture of local definitions without substituting variables.
            - If `False` (default), processes the script with full evaluation, applying all substitutions
              defined in `definitions`.
        USER : lambdaScriptdata, optional
            A `lambdaScriptdata` instance with user-provided definitions, which supplement or override
            template-level definitions during execution.

        Returns
        -------
        str
            The processed or original script content as a single string.
            - Returns an empty string if `facultative` is set to `True`, or if `condition` is `False`
              and does not meet any specified evaluation requirements.

        Notes
        -----
        - `facultative`: If `True`, the method returns an empty string, effectively skipping execution of the content.
        - `condition`: If specified, this attribute is evaluated to decide whether the content should be processed
          (default `True` if `condition` is `None`). If `condeval` is `True`, the condition itself undergoes
          evaluation using Python&#39;s `eval`.
        - `eval`: If `True` and `softrun` is `False`, performs evaluation for variable substitution on the
          content lines, applying transformations based on both `definitions` and `USER` definitions if provided.
          This allows variables to be dynamically substituted within the script content.

        Processing Workflow
        -------------------
        1. **Facultative Check**: If the `facultative` attribute is `True`, immediately returns an empty string.
        2. **Condition Check**: If a `condition` is specified, it is evaluated:
           - If `condeval` is `True`, the condition undergoes evaluation (using `eval`).
           - If the evaluated `condition` is `False`, returns an empty string, skipping execution.
        3. **Execution Based on `softrun`**:
           - If `softrun` is `True`, returns the original content without variable substitution, providing a preview.
           - If `softrun` is `False`, evaluates the content lines based on `definitions` and `USER` if applicable.
        4. **Variable Formatting**: During evaluation, lists and tuples are formatted into strings with prefixed comments,
           enhancing readability and handling complex data structures directly in the script.

        Example
        -------
        &gt;&gt;&gt; template = ScriptTemplate(
        ...     content=[&#34;variable x equal ${var1}&#34;, &#34;print &#39;Value of x is ${var1}&#39;&#34;],
        ...     definitions=lambdaScriptdata(var1=10)
        ... )
        &gt;&gt;&gt; template.do()
        &#34;variable x equal 10\nprint &#39;Value of x is 10&#39;&#34;

        &#34;&#34;&#34;

        # If &#39;facultative&#39; is set to True, return an empty string immediately
        if self.attributes.get(&#34;facultative&#34;, False):
            return &#34;&#34;

        # Evaluate condition if present
        cond = True
        if self.attributes.get(&#34;condition&#34;) is not None:
            condition_expr = self.definitions.formateval(self.attributes[&#34;condition&#34;], protected)
            cond = eval(condition_expr) if self.attributes.get(&#34;condeval&#34;, False) else condition_expr

        # Process based on softrun flag
        if softrun:
            return &#34;\n&#34;.join(self.content) if cond else &#34;&#34;

        # Perform full processing when softrun is False
        if cond:
            if self.attributes.get(&#34;eval&#34;, True):
                #return &#34;\n&#34;.join([self.definitions.formateval(line, protected) for line in self.content])
                inputs = globaldefinitions + self.definitions + USER + lambdaScriptdata(**kwargs)
                for k in inputs.keys():
                    if isinstance(inputs.getattr(k),list):
                        inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k)))
                    elif isinstance(inputs.getattr(k),tuple):
                        inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k),sep=&#34;,&#34;))
                return &#34;\n&#34;.join([inputs.formateval(line, protected) for line in self.content])

            else:
                return &#34;\n&#34;.join(self.content)

        return &#34;&#34;



    def detect_variables(self):
        &#34;&#34;&#34;
        Detects variables in the content of the template using the pattern r&#39;\$\{(\w+)\}&#39;.

        Returns:
        --------
        list
            A list of unique variable names detected in the content.
        &#34;&#34;&#34;
        # Check cache first
        cache_entry = self._CACHE[&#39;variables&#39;]
        if cache_entry[&#39;result&#39;] is not None:
            return cache_entry[&#39;result&#39;]
        # Detect variables if cache miss or content changed
        variable_pattern = re.compile(r&#39;\$\{(\w+)\}&#39;)
        detected_vars = {variable for line in self.content for variable in variable_pattern.findall(line)}
        # Cache the result and return output
        cache_entry[&#39;result&#39;] = list(detected_vars)
        return cache_entry[&#39;result&#39;]



    def refreshvar(self,globaldefinitions = lambdaScriptdata()):
        &#34;&#34;&#34;
        Detects variables in the content and adds them to definitions if needed.
        This method ensures that variables like ${varname} are correctly detected
        and added to the definitions if they are missing.

        use globaldefinitions to add a list of global variables/definitions

        &#34;&#34;&#34;
        if self.attributes[&#34;detectvar&#34;] and isinstance(self.content, list) and self.definitions and self._autorefresh:
            variables = self.detect_variables()
            for varname in variables:
                if (varname not in self.definitions) and (varname not in globaldefinitions):
                    self.definitions.setattr(varname, &#34;${&#34; + varname + &#34;}&#34;)


    def check_variables(self, verbose=True, seteval=True):
        &#34;&#34;&#34;
        Checks for undefined variables in the ScriptTemplate instance.

        Parameters:
        -----------
        verbose : bool, optional, default=True
            If True, prints information about variables for the template.
            Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.

        seteval : bool, optional, default=True
            If True, sets the `eval` attribute to True if at least one variable is defined or set to its default value.

        Returns:
        --------
        out : dict
            A dictionary with lists of default variables, set variables, and undefined variables:
            - &#34;defaultvalues&#34;: Variables set to their default value (${varname}).
            - &#34;setvalues&#34;: Variables defined with a specific value.
            - &#34;undefined&#34;: Variables that are undefined.
        &#34;&#34;&#34;
        # Check cache first
        cache_entry = self._CACHE[&#39;check_variables&#39;]
        if cache_entry[&#39;result&#39;] is not None:
            return cache_entry[&#39;result&#39;]
        # Main
        out = {&#34;defaultvalues&#34;: [], &#34;setvalues&#34;: [], &#34;undefined&#34;: []}
        detected_vars = self.detect_variables()
        defined_vars = set(self.definitions.keys()) if self.definitions else set()
        set_values, default_values, undefined_vars = [], [], []
        if verbose:
            print(f&#34;\nTEMPLATE {self.userid} variables:&#34;)
        for var in detected_vars:
            if var in defined_vars:
                if self.definitions[var] == f&#34;${{{var}}}&#34;:  # Check for default value
                    default_values.append(var)
                    if verbose:
                        print(f&#34;[-] {var}&#34;)  # Variable is set to its default value
                else:
                    set_values.append(var)
                    if verbose:
                        print(f&#34;[+] {var}&#34;)  # Variable is defined with a specific value
            else:
                undefined_vars.append(var)
                if verbose:
                    print(f&#34;[ ] {var}&#34;)  # Variable is not defined
        # If seteval is True, set eval to True if at least one variable is defined or set to its default
        if seteval and (set_values or default_values):
            self.attributes[&#39;eval&#39;] = True  # Set eval in the attributes dictionary
        # Update the output dictionary
        out[&#34;defaultvalues&#34;].extend(default_values)
        out[&#34;setvalues&#34;].extend(set_values)
        out[&#34;undefined&#34;].extend(undefined_vars)
        # update Cache and return output
        cache_entry[&#39;result&#39;] = out
        return out


    def is_variable_defined(self, var_name):
        &#34;&#34;&#34;
        Checks if a specified variable is defined (either as a default value or a set value).

        Parameters:
        -----------
        var_name : str
            The name of the variable to check.

        Returns:
        --------
        bool
            True if the variable is defined (either as a default or a set value), False if not.

        Raises:
        -------
        ValueError
            If `var_name` is invalid or undefined in the template.
        &#34;&#34;&#34;
        if not isinstance(var_name, str):
            raise ValueError(&#34;Variable name must be a string.&#34;)

        variable_status = self.check_variables(verbose=False, seteval=False)

        # Check if the variable is in default values or set values
        if var_name in variable_status[&#34;defaultvalues&#34;] or var_name in variable_status[&#34;setvalues&#34;]:
            return True
        else:
            raise ValueError(f&#34;Variable &#39;{var_name}&#39; is undefined in the template.&#34;)


    def is_variable_set_value_only(self, var_name):
        &#34;&#34;&#34;
        Checks if a specified variable is defined and set to a specific (non-default) value.

        Parameters:
        -----------
        var_name : str
            The name of the variable to check.

        Returns:
        --------
        bool
            True if the variable is defined with a set (non-default) value, False if not.

        Raises:
        -------
        ValueError
            If `var_name` is invalid or not defined in the template.
        &#34;&#34;&#34;
        if not isinstance(var_name, str):
            raise ValueError(&#34;Variable name must be a string.&#34;)

        variable_status = self.check_variables(verbose=False, seteval=False)

        # Check if the variable is in set values only (not default values)
        if var_name in variable_status[&#34;setvalues&#34;]:
            return True
        elif var_name in variable_status[&#34;defaultvalues&#34;]:
            return False  # Defined but only at its default value
        else:
            raise ValueError(f&#34;Variable &#39;{var_name}&#39; is undefined in the template.&#34;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dscript.ScriptTemplate.default_attributes"><code class="name">var <span class="ident">default_attributes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dscript.ScriptTemplate.parse_content"><code class="name flex">
<span>def <span class="ident">parse_content</span></span>(<span>content, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the content string and return:
1. Cleaned content (without flags or condition tags).
2. A dictionary of attributes (flags) initialized with default values.</p>
<h2 id="parameters">Parameters:</h2>
<p>content : str
The content string to be parsed.</p>
<h2 id="returns">Returns:</h2>
<p>cleaned_content : str
The cleaned content with all flag prefixes and condition tags removed.
attributes : dict
A dictionary of attributes (flags) set based on the content prefixes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_content(cls, content, verbose=False):
    &#34;&#34;&#34;
    Parse the content string and return:
    1. Cleaned content (without flags or condition tags).
    2. A dictionary of attributes (flags) initialized with default values.

    Parameters:
    -----------
    content : str
        The content string to be parsed.

    Returns:
    --------
    cleaned_content : str
        The cleaned content with all flag prefixes and condition tags removed.
    attributes : dict
        A dictionary of attributes (flags) set based on the content prefixes.
    &#34;&#34;&#34;
    attributes = cls.default_attributes.copy()

    # Handle empty content
    if not content.strip():  # Empty string or whitespace-only
        return &#34;&#34;, attributes

    idx = 0
    cleaned_content = []

    # If content is a single string, split it into lines
    if isinstance(content, str):
        content = content.split(&#39;\n&#39;)

    # Remove leading and trailing empty lines
    while content and content[0].strip() == &#39;&#39;:
        content.pop(0)
    while content and content[-1].strip() == &#39;&#39;:
        content.pop()

    # Process each remaining line to detect flags and conditions
    for line in content:
        idx = 0
        line = line.strip()  # Trim any leading/trailing whitespace

        # Parse flags and conditions only at the beginning of the line
        while idx &lt; len(line):
            ch = line[idx]
            if ch == &#39;!&#39;:
                attributes[&#39;eval&#39;] = True
                idx += 1
            elif ch == &#39;?&#39;:
                attributes[&#39;facultative&#39;] = True
                idx += 1
            elif ch == &#39;^&#39;:
                attributes[&#39;readonly&#39;] = True
                idx += 1
            elif ch == &#39;~&#39;:
                attributes[&#39;detectvar&#39;] = False
                idx += 1
            elif line.startswith(&#39;[if:&#39;, idx):
                # Parse condition
                end_idx = line.find(&#39;]&#39;, idx)
                if end_idx == -1:
                    raise ValueError(&#34;Unclosed &#39;[if:]&#39; tag in content&#34;)
                cond_str = line[idx + 4:end_idx]
                if &#39;;eval&#39; in cond_str:
                    attributes[&#39;condeval&#39;] = True
                    cond_str = cond_str.replace(&#39;;eval&#39;, &#39;&#39;)
                attributes[&#39;condition&#39;] = cond_str.strip()
                idx = end_idx + 1
            else:
                break  # No more flags or conditions, process the rest of the line

            # Skip any whitespace after flags or conditions
            while idx &lt; len(line) and line[idx] in (&#39; &#39;, &#39;\t&#39;):
                idx += 1

        # Append the cleaned line (without flags or condition tags)
        cleaned_content.append(line[idx:].strip())

    # Join the cleaned lines back into a single string
    cleaned_content = &#39;\n&#39;.join(cleaned_content)

    return cleaned_content, attributes</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dscript.ScriptTemplate.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content(self):
    return self._content</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dscript.ScriptTemplate.check_variables"><code class="name flex">
<span>def <span class="ident">check_variables</span></span>(<span>self, verbose=True, seteval=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks for undefined variables in the ScriptTemplate instance.</p>
<h2 id="parameters">Parameters:</h2>
<p>verbose : bool, optional, default=True
If True, prints information about variables for the template.
Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.</p>
<p>seteval : bool, optional, default=True
If True, sets the <code>eval</code> attribute to True if at least one variable is defined or set to its default value.</p>
<h2 id="returns">Returns:</h2>
<p>out : dict
A dictionary with lists of default variables, set variables, and undefined variables:
- "defaultvalues": Variables set to their default value (${varname}).
- "setvalues": Variables defined with a specific value.
- "undefined": Variables that are undefined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_variables(self, verbose=True, seteval=True):
    &#34;&#34;&#34;
    Checks for undefined variables in the ScriptTemplate instance.

    Parameters:
    -----------
    verbose : bool, optional, default=True
        If True, prints information about variables for the template.
        Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.

    seteval : bool, optional, default=True
        If True, sets the `eval` attribute to True if at least one variable is defined or set to its default value.

    Returns:
    --------
    out : dict
        A dictionary with lists of default variables, set variables, and undefined variables:
        - &#34;defaultvalues&#34;: Variables set to their default value (${varname}).
        - &#34;setvalues&#34;: Variables defined with a specific value.
        - &#34;undefined&#34;: Variables that are undefined.
    &#34;&#34;&#34;
    # Check cache first
    cache_entry = self._CACHE[&#39;check_variables&#39;]
    if cache_entry[&#39;result&#39;] is not None:
        return cache_entry[&#39;result&#39;]
    # Main
    out = {&#34;defaultvalues&#34;: [], &#34;setvalues&#34;: [], &#34;undefined&#34;: []}
    detected_vars = self.detect_variables()
    defined_vars = set(self.definitions.keys()) if self.definitions else set()
    set_values, default_values, undefined_vars = [], [], []
    if verbose:
        print(f&#34;\nTEMPLATE {self.userid} variables:&#34;)
    for var in detected_vars:
        if var in defined_vars:
            if self.definitions[var] == f&#34;${{{var}}}&#34;:  # Check for default value
                default_values.append(var)
                if verbose:
                    print(f&#34;[-] {var}&#34;)  # Variable is set to its default value
            else:
                set_values.append(var)
                if verbose:
                    print(f&#34;[+] {var}&#34;)  # Variable is defined with a specific value
        else:
            undefined_vars.append(var)
            if verbose:
                print(f&#34;[ ] {var}&#34;)  # Variable is not defined
    # If seteval is True, set eval to True if at least one variable is defined or set to its default
    if seteval and (set_values or default_values):
        self.attributes[&#39;eval&#39;] = True  # Set eval in the attributes dictionary
    # Update the output dictionary
    out[&#34;defaultvalues&#34;].extend(default_values)
    out[&#34;setvalues&#34;].extend(set_values)
    out[&#34;undefined&#34;].extend(undefined_vars)
    # update Cache and return output
    cache_entry[&#39;result&#39;] = out
    return out</code></pre>
</details>
</dd>
<dt id="dscript.ScriptTemplate.detect_variables"><code class="name flex">
<span>def <span class="ident">detect_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects variables in the content of the template using the pattern r'\${(\w+)}'.</p>
<h2 id="returns">Returns:</h2>
<p>list
A list of unique variable names detected in the content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_variables(self):
    &#34;&#34;&#34;
    Detects variables in the content of the template using the pattern r&#39;\$\{(\w+)\}&#39;.

    Returns:
    --------
    list
        A list of unique variable names detected in the content.
    &#34;&#34;&#34;
    # Check cache first
    cache_entry = self._CACHE[&#39;variables&#39;]
    if cache_entry[&#39;result&#39;] is not None:
        return cache_entry[&#39;result&#39;]
    # Detect variables if cache miss or content changed
    variable_pattern = re.compile(r&#39;\$\{(\w+)\}&#39;)
    detected_vars = {variable for line in self.content for variable in variable_pattern.findall(line)}
    # Cache the result and return output
    cache_entry[&#39;result&#39;] = list(detected_vars)
    return cache_entry[&#39;result&#39;]</code></pre>
</details>
</dd>
<dt id="dscript.ScriptTemplate.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, protected=True, softrun=False, globaldefinitions=Lambda Script Parameters (LSD object) with 0 parameter definitions, USER=Lambda Script Parameters (LSD object) with 0 parameter definitions, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes or prepares the script template content based on its attributes and the <code>softrun</code> flag.</p>
<pre><code>    Parameters
    ----------
    protected : bool, optional
        If &lt;code&gt;True&lt;/code&gt; (default), variable evaluation uses a protected environment, safeguarding global definitions
        and system attributes from modification during execution.
    softrun : bool, optional
        Determines if the script is evaluated in a preliminary mode:
        - If &lt;code&gt;True&lt;/code&gt;, returns the script content without full evaluation, allowing for a preview or
          an initial capture of local definitions without substituting variables.
        - If &lt;code&gt;False&lt;/code&gt; (default), processes the script with full evaluation, applying all substitutions
          defined in &lt;code&gt;definitions&lt;/code&gt;.
    USER : lambdaScriptdata, optional
        A &lt;code&gt;&lt;a title="dscript.lambdaScriptdata" href="#dscript.lambdaScriptdata"&gt;lambdaScriptdata&lt;/a&gt;&lt;/code&gt; instance with user-provided definitions, which supplement or override
        template-level definitions during execution.

    Returns
    -------
    str
        The processed or original script content as a single string.
        - Returns an empty string if &lt;code&gt;facultative&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt;, or if &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;
          and does not meet any specified evaluation requirements.

    Notes
    -----
    - &lt;code&gt;facultative&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, the method returns an empty string, effectively skipping execution of the content.
    - &lt;code&gt;condition&lt;/code&gt;: If specified, this attribute is evaluated to decide whether the content should be processed
      (default &lt;code&gt;True&lt;/code&gt; if &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;). If &lt;code&gt;condeval&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, the condition itself undergoes
      evaluation using Python's &lt;code&gt;eval&lt;/code&gt;.
    - &lt;code&gt;eval&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;softrun&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, performs evaluation for variable substitution on the
      content lines, applying transformations based on both &lt;code&gt;definitions&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; definitions if provided.
      This allows variables to be dynamically substituted within the script content.

    Processing Workflow
    -------------------
    1. **Facultative Check**: If the &lt;code&gt;facultative&lt;/code&gt; attribute is &lt;code&gt;True&lt;/code&gt;, immediately returns an empty string.
    2. **Condition Check**: If a &lt;code&gt;condition&lt;/code&gt; is specified, it is evaluated:
       - If &lt;code&gt;condeval&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, the condition undergoes evaluation (using &lt;code&gt;eval&lt;/code&gt;).
       - If the evaluated &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, returns an empty string, skipping execution.
    3. **Execution Based on &lt;code&gt;softrun&lt;/code&gt;**:
       - If &lt;code&gt;softrun&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, returns the original content without variable substitution, providing a preview.
       - If &lt;code&gt;softrun&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, evaluates the content lines based on &lt;code&gt;definitions&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; if applicable.
    4. **Variable Formatting**: During evaluation, lists and tuples are formatted into strings with prefixed comments,
       enhancing readability and handling complex data structures directly in the script.

    Example
    -------
    &gt;&gt;&gt; template = ScriptTemplate(
    ...     content=["variable x equal ${var1}", "print 'Value of x is ${var1}'"],
    ...     definitions=lambdaScriptdata(var1=10)
    ... )
    &gt;&gt;&gt; template.do()
    "variable x equal 10
</code></pre>
<p>print 'Value of x is 10'"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, protected=True, softrun=False,globaldefinitions=lambdaScriptdata(),USER=lambdaScriptdata(),**kwargs):
    &#34;&#34;&#34;
    Executes or prepares the script template content based on its attributes and the `softrun` flag.

    Parameters
    ----------
    protected : bool, optional
        If `True` (default), variable evaluation uses a protected environment, safeguarding global definitions
        and system attributes from modification during execution.
    softrun : bool, optional
        Determines if the script is evaluated in a preliminary mode:
        - If `True`, returns the script content without full evaluation, allowing for a preview or
          an initial capture of local definitions without substituting variables.
        - If `False` (default), processes the script with full evaluation, applying all substitutions
          defined in `definitions`.
    USER : lambdaScriptdata, optional
        A `lambdaScriptdata` instance with user-provided definitions, which supplement or override
        template-level definitions during execution.

    Returns
    -------
    str
        The processed or original script content as a single string.
        - Returns an empty string if `facultative` is set to `True`, or if `condition` is `False`
          and does not meet any specified evaluation requirements.

    Notes
    -----
    - `facultative`: If `True`, the method returns an empty string, effectively skipping execution of the content.
    - `condition`: If specified, this attribute is evaluated to decide whether the content should be processed
      (default `True` if `condition` is `None`). If `condeval` is `True`, the condition itself undergoes
      evaluation using Python&#39;s `eval`.
    - `eval`: If `True` and `softrun` is `False`, performs evaluation for variable substitution on the
      content lines, applying transformations based on both `definitions` and `USER` definitions if provided.
      This allows variables to be dynamically substituted within the script content.

    Processing Workflow
    -------------------
    1. **Facultative Check**: If the `facultative` attribute is `True`, immediately returns an empty string.
    2. **Condition Check**: If a `condition` is specified, it is evaluated:
       - If `condeval` is `True`, the condition undergoes evaluation (using `eval`).
       - If the evaluated `condition` is `False`, returns an empty string, skipping execution.
    3. **Execution Based on `softrun`**:
       - If `softrun` is `True`, returns the original content without variable substitution, providing a preview.
       - If `softrun` is `False`, evaluates the content lines based on `definitions` and `USER` if applicable.
    4. **Variable Formatting**: During evaluation, lists and tuples are formatted into strings with prefixed comments,
       enhancing readability and handling complex data structures directly in the script.

    Example
    -------
    &gt;&gt;&gt; template = ScriptTemplate(
    ...     content=[&#34;variable x equal ${var1}&#34;, &#34;print &#39;Value of x is ${var1}&#39;&#34;],
    ...     definitions=lambdaScriptdata(var1=10)
    ... )
    &gt;&gt;&gt; template.do()
    &#34;variable x equal 10\nprint &#39;Value of x is 10&#39;&#34;

    &#34;&#34;&#34;

    # If &#39;facultative&#39; is set to True, return an empty string immediately
    if self.attributes.get(&#34;facultative&#34;, False):
        return &#34;&#34;

    # Evaluate condition if present
    cond = True
    if self.attributes.get(&#34;condition&#34;) is not None:
        condition_expr = self.definitions.formateval(self.attributes[&#34;condition&#34;], protected)
        cond = eval(condition_expr) if self.attributes.get(&#34;condeval&#34;, False) else condition_expr

    # Process based on softrun flag
    if softrun:
        return &#34;\n&#34;.join(self.content) if cond else &#34;&#34;

    # Perform full processing when softrun is False
    if cond:
        if self.attributes.get(&#34;eval&#34;, True):
            #return &#34;\n&#34;.join([self.definitions.formateval(line, protected) for line in self.content])
            inputs = globaldefinitions + self.definitions + USER + lambdaScriptdata(**kwargs)
            for k in inputs.keys():
                if isinstance(inputs.getattr(k),list):
                    inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k)))
                elif isinstance(inputs.getattr(k),tuple):
                    inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k),sep=&#34;,&#34;))
            return &#34;\n&#34;.join([inputs.formateval(line, protected) for line in self.content])

        else:
            return &#34;\n&#34;.join(self.content)

    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="dscript.ScriptTemplate.is_variable_defined"><code class="name flex">
<span>def <span class="ident">is_variable_defined</span></span>(<span>self, var_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a specified variable is defined (either as a default value or a set value).</p>
<h2 id="parameters">Parameters:</h2>
<p>var_name : str
The name of the variable to check.</p>
<h2 id="returns">Returns:</h2>
<p>bool
True if the variable is defined (either as a default or a set value), False if not.</p>
<h2 id="raises">Raises:</h2>
<p>ValueError
If <code>var_name</code> is invalid or undefined in the template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_variable_defined(self, var_name):
    &#34;&#34;&#34;
    Checks if a specified variable is defined (either as a default value or a set value).

    Parameters:
    -----------
    var_name : str
        The name of the variable to check.

    Returns:
    --------
    bool
        True if the variable is defined (either as a default or a set value), False if not.

    Raises:
    -------
    ValueError
        If `var_name` is invalid or undefined in the template.
    &#34;&#34;&#34;
    if not isinstance(var_name, str):
        raise ValueError(&#34;Variable name must be a string.&#34;)

    variable_status = self.check_variables(verbose=False, seteval=False)

    # Check if the variable is in default values or set values
    if var_name in variable_status[&#34;defaultvalues&#34;] or var_name in variable_status[&#34;setvalues&#34;]:
        return True
    else:
        raise ValueError(f&#34;Variable &#39;{var_name}&#39; is undefined in the template.&#34;)</code></pre>
</details>
</dd>
<dt id="dscript.ScriptTemplate.is_variable_set_value_only"><code class="name flex">
<span>def <span class="ident">is_variable_set_value_only</span></span>(<span>self, var_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a specified variable is defined and set to a specific (non-default) value.</p>
<h2 id="parameters">Parameters:</h2>
<p>var_name : str
The name of the variable to check.</p>
<h2 id="returns">Returns:</h2>
<p>bool
True if the variable is defined with a set (non-default) value, False if not.</p>
<h2 id="raises">Raises:</h2>
<p>ValueError
If <code>var_name</code> is invalid or not defined in the template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_variable_set_value_only(self, var_name):
    &#34;&#34;&#34;
    Checks if a specified variable is defined and set to a specific (non-default) value.

    Parameters:
    -----------
    var_name : str
        The name of the variable to check.

    Returns:
    --------
    bool
        True if the variable is defined with a set (non-default) value, False if not.

    Raises:
    -------
    ValueError
        If `var_name` is invalid or not defined in the template.
    &#34;&#34;&#34;
    if not isinstance(var_name, str):
        raise ValueError(&#34;Variable name must be a string.&#34;)

    variable_status = self.check_variables(verbose=False, seteval=False)

    # Check if the variable is in set values only (not default values)
    if var_name in variable_status[&#34;setvalues&#34;]:
        return True
    elif var_name in variable_status[&#34;defaultvalues&#34;]:
        return False  # Defined but only at its default value
    else:
        raise ValueError(f&#34;Variable &#39;{var_name}&#39; is undefined in the template.&#34;)</code></pre>
</details>
</dd>
<dt id="dscript.ScriptTemplate.refreshvar"><code class="name flex">
<span>def <span class="ident">refreshvar</span></span>(<span>self, globaldefinitions=Lambda Script Parameters (LSD object) with 0 parameter definitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects variables in the content and adds them to definitions if needed.
This method ensures that variables like ${varname} are correctly detected
and added to the definitions if they are missing.</p>
<p>use globaldefinitions to add a list of global variables/definitions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refreshvar(self,globaldefinitions = lambdaScriptdata()):
    &#34;&#34;&#34;
    Detects variables in the content and adds them to definitions if needed.
    This method ensures that variables like ${varname} are correctly detected
    and added to the definitions if they are missing.

    use globaldefinitions to add a list of global variables/definitions

    &#34;&#34;&#34;
    if self.attributes[&#34;detectvar&#34;] and isinstance(self.content, list) and self.definitions and self._autorefresh:
        variables = self.detect_variables()
        for varname in variables:
            if (varname not in self.definitions) and (varname not in globaldefinitions):
                self.definitions.setattr(varname, &#34;${&#34; + varname + &#34;}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dscript.VariableOccurrences"><code class="flex name class">
<span>class <span class="ident">VariableOccurrences</span></span>
<span>(</span><span>data, variables=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="dscript.VariableOccurrences" href="#dscript.VariableOccurrences">VariableOccurrences</a></code> class encapsulates raw data and provides utility methods for analyzing variable occurrences
across various scopes. It is designed to handle both single and multiple variables, supporting flexible data structures
and analysis operations.</p>
<h2 id="class-methods">Class Methods:</h2>
<ul>
<li><code>__init__(data, variables=None)</code>: Initializes the class with raw data and optional variable names.</li>
<li><code>_determine_scopes()</code>: Determines the unique scopes present across all variables.</li>
<li><code>get_raw_data()</code>: Returns the raw data as provided during initialization.</li>
<li><code>get_steps_with_value(value, within_list=False)</code>: Retrieves steps where the variable equals the specified value.</li>
<li><code>get_all_values()</code>: Retrieves all unique values of the variable(s).</li>
<li><code>get_all_elements_in_lists()</code>: Retrieves all unique elements within list-type variable values.</li>
<li><code>get_usage_count(value, within_list=False)</code>: Counts occurrences of a specific value.</li>
<li><code>get_steps_with_value_in_scope(variable, scope, value, within_list=False)</code>: Retrieves steps where a variable equals a value within a specific scope.</li>
<li><code>summarize()</code>: Summarizes the occurrences of variables, including counts and unique elements.</li>
<li><code>export(filename=None, scopes='all', variables='all', include_headers=True, return_content=False)</code>:
Exports variable occurrences as Markdown, plain text, or HTML.</li>
</ul>
<h2 id="attributes">Attributes:</h2>
<ul>
<li><code>data</code>: Dictionary containing the raw variable data.</li>
<li>Single variable: <code>{'scope1': [...], 'scope2': [...]}</code>.</li>
<li>Multiple variables: <code>{'var1': {...}, 'var2': {...}, ...}</code>.</li>
<li><code>variables</code>: List of variable names managed by the instance.</li>
<li><code>scopes</code>: List of unique scopes across all variables.</li>
</ul>
<h2 id="usage">Usage:</h2>
<p>The class is useful for tracking and analyzing variable values across different contexts, such as configuration files,
programming environments, or simulation data. It supports advanced querying, summary generation, and export functionality.</p>
<h2 id="example">Example:</h2>
<h1 id="initialize-with-single-variable">Initialize with single variable</h1>
<p>data = {'global': [(0, 1), (1, 2)], 'local': [(0, 3), (1, 4)]}
vo = VariableOccurrences(data, variables="var1")</p>
<h1 id="initialize-with-multiple-variables">Initialize with multiple variables</h1>
<p>data = {
"var1": {"global": [(0, 1), (1, 2)], "local": [(0, 3), (1, 4)]},
"var2": {"global": [1, 2], "local": [3, 4]},
}
vo = VariableOccurrences(data)</p>
<h1 id="query-steps-where-a-value-is-present">Query steps where a value is present</h1>
<p>steps = vo.get_steps_with_value(2)</p>
<h1 id="export-data-to-a-markdown-file">Export data to a Markdown file</h1>
<p>vo.export("output.md")</p>
<p>Initializes the VariableOccurrences object.</p>
<p>Parameters:
- data:
- For single variable: dict with scopes as keys and lists of values or a single value.
- For multiple variables: dict mapping variable names to their respective scope data.
- variables (str or list/tuple, optional):
- If single variable: string representing the variable name.
- If multiple variables: list or tuple of variable names.
- If None: assumes data is for multiple variables without specifying names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariableOccurrences:
    &#34;&#34;&#34;
    The `VariableOccurrences` class encapsulates raw data and provides utility methods for analyzing variable occurrences
    across various scopes. It is designed to handle both single and multiple variables, supporting flexible data structures
    and analysis operations.

    Class Methods:
    --------------
    - `__init__(data, variables=None)`: Initializes the class with raw data and optional variable names.
    - `_determine_scopes()`: Determines the unique scopes present across all variables.
    - `get_raw_data()`: Returns the raw data as provided during initialization.
    - `get_steps_with_value(value, within_list=False)`: Retrieves steps where the variable equals the specified value.
    - `get_all_values()`: Retrieves all unique values of the variable(s).
    - `get_all_elements_in_lists()`: Retrieves all unique elements within list-type variable values.
    - `get_usage_count(value, within_list=False)`: Counts occurrences of a specific value.
    - `get_steps_with_value_in_scope(variable, scope, value, within_list=False)`: Retrieves steps where a variable equals a value within a specific scope.
    - `summarize()`: Summarizes the occurrences of variables, including counts and unique elements.
    - `export(filename=None, scopes=&#39;all&#39;, variables=&#39;all&#39;, include_headers=True, return_content=False)`:
      Exports variable occurrences as Markdown, plain text, or HTML.

    Attributes:
    -----------
    - `data`: Dictionary containing the raw variable data.
      - Single variable: `{&#39;scope1&#39;: [...], &#39;scope2&#39;: [...]}`.
      - Multiple variables: `{&#39;var1&#39;: {...}, &#39;var2&#39;: {...}, ...}`.
    - `variables`: List of variable names managed by the instance.
    - `scopes`: List of unique scopes across all variables.

    Usage:
    ------
    The class is useful for tracking and analyzing variable values across different contexts, such as configuration files,
    programming environments, or simulation data. It supports advanced querying, summary generation, and export functionality.

    Example:
    --------
    # Initialize with single variable
    data = {&#39;global&#39;: [(0, 1), (1, 2)], &#39;local&#39;: [(0, 3), (1, 4)]}
    vo = VariableOccurrences(data, variables=&#34;var1&#34;)

    # Initialize with multiple variables
    data = {
        &#34;var1&#34;: {&#34;global&#34;: [(0, 1), (1, 2)], &#34;local&#34;: [(0, 3), (1, 4)]},
        &#34;var2&#34;: {&#34;global&#34;: [1, 2], &#34;local&#34;: [3, 4]},
    }
    vo = VariableOccurrences(data)

    # Query steps where a value is present
    steps = vo.get_steps_with_value(2)

    # Export data to a Markdown file
    vo.export(&#34;output.md&#34;)
    &#34;&#34;&#34;

    def __init__(self, data, variables=None):
        &#34;&#34;&#34;
        Initializes the VariableOccurrences object.

        Parameters:
        - data:
            - For single variable: dict with scopes as keys and lists of values or a single value.
            - For multiple variables: dict mapping variable names to their respective scope data.
        - variables (str or list/tuple, optional):
            - If single variable: string representing the variable name.
            - If multiple variables: list or tuple of variable names.
            - If None: assumes data is for multiple variables without specifying names.
        &#34;&#34;&#34;
        if variables is None:
            # Assume data is a dict mapping variable names to their scope data
            if not isinstance(data, dict):
                raise ValueError(&#34;For multiple variables, data must be a dict mapping variable names to their scope data.&#34;)
            self.variables = list(data.keys())
            self.data = data  # {var1: {scope1: [...], scope2: [...]}, var2: {...}, ...}
        elif isinstance(variables, str):
            # Single variable case
            self.variables = [variables]
            if not isinstance(data, dict):
                raise ValueError(&#34;For single variable, data must be a dict with scopes as keys and lists of values or single values as values.&#34;)
            self.data = {variables: data}  # {var: {scope1: [...], scope2: [...], ...}}
        elif isinstance(variables, (list, tuple)):
            # Multiple variables specified
            if not isinstance(data, dict):
                raise ValueError(&#34;For multiple variables, data must be a dict mapping variable names to their scope data.&#34;)
            if set(variables) &gt; set(data.keys()):
                missing_vars = set(variables) - set(data.keys())
                raise ValueError(f&#34;Data does not contain entries for variables: {&#39;, &#39;.join(missing_vars)}&#34;)
            self.variables = list(variables)
            self.data = {var: data[var] for var in variables}  # {var1: {...}, var2: {...}, ...}
        else:
            raise ValueError(&#34;Parameter &#39;variables&#39; must be a string, list, tuple, or None.&#34;)

        self.scopes = self._determine_scopes()

    def _determine_scopes(self):
        &#34;&#34;&#34;Determines the unique scopes present across all variables.&#34;&#34;&#34;
        scopes = set()
        for var in self.variables:
            var_scopes = self.data[var].keys()
            scopes.update(scope.lower() for scope in var_scopes)
        return sorted(list(scopes))

    def get_raw_data(self):
        &#34;&#34;&#34;
        Returns the raw data.

        Returns:
        - The raw data as provided during initialization.
        &#34;&#34;&#34;
        return self.data

    def get_steps_with_value(self, value, within_list=False):
        &#34;&#34;&#34;
        Retrieves the steps where the variable equals the specified value.

        Parameters:
        - value: The value to search for.
        - within_list (bool): If True, searches for the value within list-type variable values.

        Returns:
        - If single variable:
            - A dict with scopes as keys and lists of step indices or values as values.
        - If multiple variables:
            - A dict mapping each variable name to their respective scope-step/value mappings.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_result = {}
            for scope, occurrences in self.data[var].items():
                if is_scalar(occurrences):
                    # Scalar value
                    if within_list:
                        continue  # Cannot search within a scalar
                    if occurrences == value:
                        var_result[scope] = occurrences
                elif isinstance(occurrences, list):
                    # List of values or list of tuples
                    steps = []
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            step, val = item
                            if within_list:
                                if isinstance(val, list) and value in val:
                                    steps.append(step)
                            else:
                                if val == value:
                                    steps.append(step)
                        else:
                            # List of values
                            if within_list:
                                if isinstance(item, list) and value in item:
                                    steps.append(item)
                            else:
                                if item == value:
                                    steps.append(item)
                    if steps:
                        var_result[scope] = steps
                else:
                    # Other types (e.g., dict), can be extended as needed
                    pass
            if var_result:
                result[var] = var_result
        return result

    def get_all_values(self):
        &#34;&#34;&#34;
        Retrieves all unique values of the variable(s).

        Returns:
        - A dict mapping each variable to its set of unique values per scope.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_unique = {}
            for scope, occurrences in self.data[var].items():
                unique_vals = set()
                if is_scalar(occurrences):
                    unique_vals.add(occurrences)
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            _, val = item
                            hashable_val = make_hashable(val)
                            unique_vals.add(hashable_val)
                        else:
                            hashable_val = make_hashable(item)
                            unique_vals.add(hashable_val)
                var_unique[scope] = unique_vals
            result[var] = var_unique
        return result

    def get_all_elements_in_lists(self):
        &#34;&#34;&#34;
        Retrieves all unique elements within list-type variable values.

        Returns:
        - A dict mapping each variable to its set of unique elements in lists per scope.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_elements = {}
            for scope, occurrences in self.data[var].items():
                unique_elems = set()
                if is_scalar(occurrences):
                    if isinstance(occurrences, list):
                        unique_elems.update(occurrences)
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            _, val = item
                            if isinstance(val, list):
                                unique_elems.update(val)
                        elif isinstance(item, list):
                            unique_elems.update(item)
                var_elements[scope] = unique_elems
            result[var] = var_elements
        return result

    def get_usage_count(self, value, within_list=False):
        &#34;&#34;&#34;
        Counts how many times a specific value is used.

        Parameters:
        - value: The value to count.
        - within_list (bool): If True, counts occurrences within list-type variable values.

        Returns:
        - If single variable:
            - A dict with scopes as keys and integer counts or counts of values as values.
        - If multiple variables:
            - A dict mapping each variable name to their respective scope-count/value mappings.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_count = {}
            for scope, occurrences in self.data[var].items():
                count = 0
                if is_scalar(occurrences):
                    if within_list:
                        if isinstance(occurrences, list) and value in occurrences:
                            count += 1
                    else:
                        if occurrences == value:
                            count += 1
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            _, val = item
                            if within_list:
                                if isinstance(val, list) and value in val:
                                    count += 1
                            else:
                                if val == value:
                                    count += 1
                        else:
                            if within_list:
                                if isinstance(item, list) and value in item:
                                    count += 1
                            else:
                                if item == value:
                                    count += 1
                if count &gt; 0:
                    var_count[scope] = count
            if var_count:
                result[var] = var_count
        return result

    def get_steps_with_value_in_scope(self, variable, scope, value, within_list=False):
        &#34;&#34;&#34;
        Retrieves the steps within a specific scope where the variable equals the specified value.

        Parameters:
        - variable (str): The variable name.
        - scope (str): The scope to search within (&#34;static&#34;, &#34;global&#34;, &#34;local&#34;).
        - value: The value to search for.
        - within_list (bool): If True, searches for the value within list-type variable values.

        Returns:
        - A list of step indices or values where the variable equals the value within the specified scope.
        &#34;&#34;&#34;
        if variable not in self.variables:
            raise ValueError(f&#34;Variable &#39;{variable}&#39; is not managed by this instance.&#34;)

        scope = scope.lower()
        occurrences = self.data[variable].get(scope, [])
        steps = []

        if is_scalar(occurrences):
            if within_list:
                if isinstance(occurrences, list) and value in occurrences:
                    steps.append(occurrences)
            else:
                if occurrences == value:
                    steps.append(occurrences)
        elif isinstance(occurrences, list):
            for item in occurrences:
                if isinstance(item, tuple) and len(item) == 2:
                    step, val = item
                    if within_list:
                        if isinstance(val, list) and value in val:
                            steps.append(step)
                    else:
                        if val == value:
                            steps.append(step)
                else:
                    if within_list:
                        if isinstance(item, list) and value in item:
                            steps.append(item)
                    else:
                        if item == value:
                            steps.append(item)
        return steps

    def summarize(self):
        &#34;&#34;&#34;
        Provides a summary of the variable occurrences.

        Returns:
        - A dict mapping each variable to their respective summaries per scope.
        &#34;&#34;&#34;
        summary = {}
        for var in self.variables:
            var_summary = {}
            for scope, occurrences in self.data[var].items():
                unique_vals = set()
                unique_elements = set()
                value_counts = defaultdict(int)
                element_counts = defaultdict(int)

                if is_scalar(occurrences):
                    # Scalar value
                    hashable_val = make_hashable(occurrences)
                    unique_vals.add(hashable_val)
                    value_counts[hashable_val] += 1
                    if isinstance(occurrences, list):
                        unique_elements.update(occurrences)
                        for elem in occurrences:
                            element_counts[elem] += 1
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            # Tuple: (step, value)
                            step, val = item
                            hashable_val = make_hashable(val)
                            unique_vals.add(hashable_val)
                            value_counts[hashable_val] += 1
                            if isinstance(val, list):
                                unique_elements.update(val)
                                for elem in val:
                                    element_counts[elem] += 1
                            elif isinstance(val, dict):
                                # Handle nested dictionaries if necessary
                                for sub_val in val.values():
                                    if isinstance(sub_val, list):
                                        unique_elements.update(sub_val)
                                        for elem in sub_val:
                                            element_counts[elem] += 1
                        else:
                            # Direct value
                            hashable_val = make_hashable(item)
                            unique_vals.add(hashable_val)
                            value_counts[hashable_val] += 1
                            if isinstance(item, list):
                                unique_elements.update(item)
                                for elem in item:
                                    element_counts[elem] += 1
                            elif isinstance(item, dict):
                                for sub_val in item.values():
                                    if isinstance(sub_val, list):
                                        unique_elements.update(sub_val)
                                        for elem in sub_val:
                                            element_counts[elem] += 1
                else:
                    # Other types can be handled here if needed
                    pass

                var_summary[scope] = {
                    &#34;total_occurrences&#34;: len(occurrences),
                    &#34;unique_values&#34;: unique_vals,
                    &#34;unique_elements_in_lists&#34;: unique_elements,
                    &#34;value_counts&#34;: dict(value_counts),
                    &#34;element_counts_in_lists&#34;: dict(element_counts)
                }
            summary[var] = var_summary
        return summary

    def export(self, filename=None, scopes=&#39;all&#39;, variables=&#39;all&#39;, include_headers=True, return_content=False):
        &#34;&#34;&#34;
        Exports the variable occurrences to a file or returns the content as a string.

        Parameters:
        - filename (str, optional): Path to the output file. Must end with .md, .txt, or .html. Required if return_content is False.
        - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.
        - variables (str or list/tuple, optional): &#39;all&#39;, a single variable string, or a list of variable strings. Defaults to &#39;all&#39;.
        - include_headers (bool, optional): If True, includes headers in the exported content. Defaults to True.
        - return_content (bool, optional): If True, returns the content as a string instead of writing to a file. Defaults to False.

        Returns:
        - str: The exported content as a string if return_content is True.
        - None: Writes to file if return_content is False.

        Raises:
        - ValueError: If &#39;filename&#39; is not provided when return_content is False.
        - ValueError: If &#39;scopes&#39; or &#39;variables&#39; are of incorrect types.
        &#34;&#34;&#34;
        # Determine file extension if filename is provided
        if filename:
            _, ext = os.path.splitext(filename)
            ext = ext.lower()

            if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
                export_format = &#39;markdown&#39;
            elif ext == &#39;.html&#39;:
                export_format = &#39;html&#39;
            else:
                raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)
        elif not return_content:
            raise ValueError(&#34;Filename must be provided if return_content is False.&#34;)

        # Determine scopes
        if isinstance(scopes, str):
            if scopes.lower() == &#39;all&#39;:
                selected_scopes = self.scopes
            else:
                selected_scopes = [scopes.lower()]
        elif isinstance(scopes, (list, tuple)):
            scopes_lower = [s.lower() for s in scopes]
            if &#39;all&#39; in scopes_lower:
                selected_scopes = self.scopes
            else:
                selected_scopes = scopes_lower
        else:
            raise ValueError(&#34;Parameter &#39;scopes&#39; must be a string or a list/tuple of strings.&#34;)

        # Determine variables
        if isinstance(variables, str):
            if variables.lower() == &#39;all&#39;:
                selected_variables = self.variables
            else:
                if variables not in self.variables:
                    print(f&#34;Warning: Variable &#39;{variables}&#39; not managed by this instance.&#34;)
                    selected_variables = []
                else:
                    selected_variables = [variables]
        elif isinstance(variables, (list, tuple)):
            variables_lower = [v for v in variables]
            selected_variables = [v for v in variables_lower if v in self.variables]
            missing_vars = set(variables_lower) - set(selected_variables)
            if missing_vars:
                print(f&#34;Warning: Variables &#39;{&#39;, &#39;.join(missing_vars)}&#39; not managed by this instance.&#34;)
        else:
            raise ValueError(&#34;Parameter &#39;variables&#39; must be a string or a list/tuple of strings.&#34;)

        # Generate content
        content = &#34;&#34;
        if include_headers:
            if export_format == &#39;markdown&#39;:
                content += f&#34;## Variable: `{self.variables[0]}`\n\n&#34; if len(self.variables) == 1 else &#34;&#34;
            elif export_format == &#39;html&#39;:
                content += f&#34;&lt;h2&gt;Variable: {self.variables[0]}&lt;/h2&gt;\n&#34; if len(self.variables) == 1 else &#34;&#34;

        summary = self.summarize()
        for var in selected_variables:
            if include_headers:
                if export_format == &#39;markdown&#39;:
                    content += f&#34;### Variable: `{var}`\n\n&#34;
                elif export_format == &#39;html&#39;:
                    content += f&#34;&lt;h3&gt;Variable: {var}&lt;/h3&gt;\n&#34;
            var_summary = summary[var]
            for scope, details in var_summary.items():
                if scope not in selected_scopes:
                    continue
                if include_headers or True:
                    if export_format == &#39;markdown&#39;:
                        content += f&#34;#### Scope: {scope.capitalize()}\n\n&#34;
                    elif export_format == &#39;html&#39;:
                        content += f&#34;&lt;h4&gt;Scope: {scope.capitalize()}&lt;/h4&gt;\n&#34;
                # Add content based on format
                if export_format == &#39;markdown&#39;:
                    content += f&#34;- **Total Occurrences**: {details[&#39;total_occurrences&#39;]}\n&#34;
                    unique_vals_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_values&#39;]))
                    content += f&#34;- **Unique Values**: {unique_vals_formatted}\n&#34;
                    if details[&#39;unique_elements_in_lists&#39;]:
                        unique_elems_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_elements_in_lists&#39;]))
                        content += f&#34;- **Unique Elements in Lists**: {unique_elems_formatted}\n\n&#34;
                        # Element Counts Table
                        content += &#34;**Element Counts in Lists:**\n\n&#34;
                        content += &#34;| Element | Count |\n&#34;
                        content += &#34;|---------|-------|\n&#34;
                        for elem, count in details[&#39;element_counts_in_lists&#39;].items():
                            content += f&#34;| {elem} | {count} |\n&#34;
                        content += &#34;\n&#34;
                elif export_format == &#39;html&#39;:
                    content += &#34;&lt;ul&gt;&#34;
                    content += f&#34;&lt;li&gt;&lt;strong&gt;Total Occurrences&lt;/strong&gt;: {details[&#39;total_occurrences&#39;]}&lt;/li&gt;&#34;
                    unique_vals_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_values&#39;]))
                    content += f&#34;&lt;li&gt;&lt;strong&gt;Unique Values&lt;/strong&gt;: {unique_vals_formatted}&lt;/li&gt;&#34;
                    if details[&#39;unique_elements_in_lists&#39;]:
                        unique_elems_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_elements_in_lists&#39;]))
                        content += f&#34;&lt;li&gt;&lt;strong&gt;Unique Elements in Lists&lt;/strong&gt;: {unique_elems_formatted}&lt;/li&gt;&#34;
                    content += &#34;&lt;/ul&gt;\n&#34;

                    if details[&#39;element_counts_in_lists&#39;]:
                        content += &#34;&lt;h5&gt;Element Counts in Lists:&lt;/h5&gt;\n&#34;
                        content += &#34;&lt;table&gt;\n&lt;tr&gt;&lt;th&gt;Element&lt;/th&gt;&lt;th&gt;Count&lt;/th&gt;&lt;/tr&gt;\n&#34;
                        for elem, count in details[&#39;element_counts_in_lists&#39;].items():
                            content += f&#34;&lt;tr&gt;&lt;td&gt;{elem}&lt;/td&gt;&lt;td&gt;{count}&lt;/td&gt;&lt;/tr&gt;\n&#34;
                        content += &#34;&lt;/table&gt;\n&#34;

            # Add a horizontal line between variables
            if include_headers and len(selected_variables) &gt; 1:
                if export_format == &#39;markdown&#39;:
                    content += &#34;\n---\n\n&#34;
                elif export_format == &#39;html&#39;:
                    content += &#34;&lt;hr/&gt;\n&#34;

        # Handle format-specific headers
        if return_content:
            if export_format == &#39;markdown&#39;:
                return content
            elif export_format == &#39;html&#39;:
                return f&#34;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#39;UTF-8&#39;&gt;&lt;title&gt;Variable Report&lt;/title&gt;&lt;/head&gt;&lt;body&gt;{content}&lt;/body&gt;&lt;/html&gt;&#34;
        else:
            if not filename:
                raise ValueError(&#34;Filename must be provided if return_content is False.&#34;)

            # Determine export format based on file extension
            if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
                export_format = &#39;markdown&#39;
            elif ext == &#39;.html&#39;:
                export_format = &#39;html&#39;
            else:
                raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

            # Prepare full content for HTML
            if export_format == &#39;html&#39; and not include_headers:
                full_content = f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Variable Report&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n{content}\n&lt;/body&gt;\n&lt;/html&gt;&#34;
            else:
                full_content = content

            # Write to file
            try:
                with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                    file.write(full_content)
                print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
            except Exception as e:
                raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dscript.VariableOccurrences.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, filename=None, scopes='all', variables='all', include_headers=True, return_content=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Exports the variable occurrences to a file or returns the content as a string.</p>
<p>Parameters:
- filename (str, optional): Path to the output file. Must end with .md, .txt, or .html. Required if return_content is False.
- scopes (str or list/tuple, optional): 'all', a single scope string, or a list of scope strings. Defaults to 'all'.
- variables (str or list/tuple, optional): 'all', a single variable string, or a list of variable strings. Defaults to 'all'.
- include_headers (bool, optional): If True, includes headers in the exported content. Defaults to True.
- return_content (bool, optional): If True, returns the content as a string instead of writing to a file. Defaults to False.</p>
<p>Returns:
- str: The exported content as a string if return_content is True.
- None: Writes to file if return_content is False.</p>
<p>Raises:
- ValueError: If 'filename' is not provided when return_content is False.
- ValueError: If 'scopes' or 'variables' are of incorrect types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, filename=None, scopes=&#39;all&#39;, variables=&#39;all&#39;, include_headers=True, return_content=False):
    &#34;&#34;&#34;
    Exports the variable occurrences to a file or returns the content as a string.

    Parameters:
    - filename (str, optional): Path to the output file. Must end with .md, .txt, or .html. Required if return_content is False.
    - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.
    - variables (str or list/tuple, optional): &#39;all&#39;, a single variable string, or a list of variable strings. Defaults to &#39;all&#39;.
    - include_headers (bool, optional): If True, includes headers in the exported content. Defaults to True.
    - return_content (bool, optional): If True, returns the content as a string instead of writing to a file. Defaults to False.

    Returns:
    - str: The exported content as a string if return_content is True.
    - None: Writes to file if return_content is False.

    Raises:
    - ValueError: If &#39;filename&#39; is not provided when return_content is False.
    - ValueError: If &#39;scopes&#39; or &#39;variables&#39; are of incorrect types.
    &#34;&#34;&#34;
    # Determine file extension if filename is provided
    if filename:
        _, ext = os.path.splitext(filename)
        ext = ext.lower()

        if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
            export_format = &#39;markdown&#39;
        elif ext == &#39;.html&#39;:
            export_format = &#39;html&#39;
        else:
            raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)
    elif not return_content:
        raise ValueError(&#34;Filename must be provided if return_content is False.&#34;)

    # Determine scopes
    if isinstance(scopes, str):
        if scopes.lower() == &#39;all&#39;:
            selected_scopes = self.scopes
        else:
            selected_scopes = [scopes.lower()]
    elif isinstance(scopes, (list, tuple)):
        scopes_lower = [s.lower() for s in scopes]
        if &#39;all&#39; in scopes_lower:
            selected_scopes = self.scopes
        else:
            selected_scopes = scopes_lower
    else:
        raise ValueError(&#34;Parameter &#39;scopes&#39; must be a string or a list/tuple of strings.&#34;)

    # Determine variables
    if isinstance(variables, str):
        if variables.lower() == &#39;all&#39;:
            selected_variables = self.variables
        else:
            if variables not in self.variables:
                print(f&#34;Warning: Variable &#39;{variables}&#39; not managed by this instance.&#34;)
                selected_variables = []
            else:
                selected_variables = [variables]
    elif isinstance(variables, (list, tuple)):
        variables_lower = [v for v in variables]
        selected_variables = [v for v in variables_lower if v in self.variables]
        missing_vars = set(variables_lower) - set(selected_variables)
        if missing_vars:
            print(f&#34;Warning: Variables &#39;{&#39;, &#39;.join(missing_vars)}&#39; not managed by this instance.&#34;)
    else:
        raise ValueError(&#34;Parameter &#39;variables&#39; must be a string or a list/tuple of strings.&#34;)

    # Generate content
    content = &#34;&#34;
    if include_headers:
        if export_format == &#39;markdown&#39;:
            content += f&#34;## Variable: `{self.variables[0]}`\n\n&#34; if len(self.variables) == 1 else &#34;&#34;
        elif export_format == &#39;html&#39;:
            content += f&#34;&lt;h2&gt;Variable: {self.variables[0]}&lt;/h2&gt;\n&#34; if len(self.variables) == 1 else &#34;&#34;

    summary = self.summarize()
    for var in selected_variables:
        if include_headers:
            if export_format == &#39;markdown&#39;:
                content += f&#34;### Variable: `{var}`\n\n&#34;
            elif export_format == &#39;html&#39;:
                content += f&#34;&lt;h3&gt;Variable: {var}&lt;/h3&gt;\n&#34;
        var_summary = summary[var]
        for scope, details in var_summary.items():
            if scope not in selected_scopes:
                continue
            if include_headers or True:
                if export_format == &#39;markdown&#39;:
                    content += f&#34;#### Scope: {scope.capitalize()}\n\n&#34;
                elif export_format == &#39;html&#39;:
                    content += f&#34;&lt;h4&gt;Scope: {scope.capitalize()}&lt;/h4&gt;\n&#34;
            # Add content based on format
            if export_format == &#39;markdown&#39;:
                content += f&#34;- **Total Occurrences**: {details[&#39;total_occurrences&#39;]}\n&#34;
                unique_vals_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_values&#39;]))
                content += f&#34;- **Unique Values**: {unique_vals_formatted}\n&#34;
                if details[&#39;unique_elements_in_lists&#39;]:
                    unique_elems_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_elements_in_lists&#39;]))
                    content += f&#34;- **Unique Elements in Lists**: {unique_elems_formatted}\n\n&#34;
                    # Element Counts Table
                    content += &#34;**Element Counts in Lists:**\n\n&#34;
                    content += &#34;| Element | Count |\n&#34;
                    content += &#34;|---------|-------|\n&#34;
                    for elem, count in details[&#39;element_counts_in_lists&#39;].items():
                        content += f&#34;| {elem} | {count} |\n&#34;
                    content += &#34;\n&#34;
            elif export_format == &#39;html&#39;:
                content += &#34;&lt;ul&gt;&#34;
                content += f&#34;&lt;li&gt;&lt;strong&gt;Total Occurrences&lt;/strong&gt;: {details[&#39;total_occurrences&#39;]}&lt;/li&gt;&#34;
                unique_vals_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_values&#39;]))
                content += f&#34;&lt;li&gt;&lt;strong&gt;Unique Values&lt;/strong&gt;: {unique_vals_formatted}&lt;/li&gt;&#34;
                if details[&#39;unique_elements_in_lists&#39;]:
                    unique_elems_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_elements_in_lists&#39;]))
                    content += f&#34;&lt;li&gt;&lt;strong&gt;Unique Elements in Lists&lt;/strong&gt;: {unique_elems_formatted}&lt;/li&gt;&#34;
                content += &#34;&lt;/ul&gt;\n&#34;

                if details[&#39;element_counts_in_lists&#39;]:
                    content += &#34;&lt;h5&gt;Element Counts in Lists:&lt;/h5&gt;\n&#34;
                    content += &#34;&lt;table&gt;\n&lt;tr&gt;&lt;th&gt;Element&lt;/th&gt;&lt;th&gt;Count&lt;/th&gt;&lt;/tr&gt;\n&#34;
                    for elem, count in details[&#39;element_counts_in_lists&#39;].items():
                        content += f&#34;&lt;tr&gt;&lt;td&gt;{elem}&lt;/td&gt;&lt;td&gt;{count}&lt;/td&gt;&lt;/tr&gt;\n&#34;
                    content += &#34;&lt;/table&gt;\n&#34;

        # Add a horizontal line between variables
        if include_headers and len(selected_variables) &gt; 1:
            if export_format == &#39;markdown&#39;:
                content += &#34;\n---\n\n&#34;
            elif export_format == &#39;html&#39;:
                content += &#34;&lt;hr/&gt;\n&#34;

    # Handle format-specific headers
    if return_content:
        if export_format == &#39;markdown&#39;:
            return content
        elif export_format == &#39;html&#39;:
            return f&#34;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#39;UTF-8&#39;&gt;&lt;title&gt;Variable Report&lt;/title&gt;&lt;/head&gt;&lt;body&gt;{content}&lt;/body&gt;&lt;/html&gt;&#34;
    else:
        if not filename:
            raise ValueError(&#34;Filename must be provided if return_content is False.&#34;)

        # Determine export format based on file extension
        if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
            export_format = &#39;markdown&#39;
        elif ext == &#39;.html&#39;:
            export_format = &#39;html&#39;
        else:
            raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

        # Prepare full content for HTML
        if export_format == &#39;html&#39; and not include_headers:
            full_content = f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Variable Report&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n{content}\n&lt;/body&gt;\n&lt;/html&gt;&#34;
        else:
            full_content = content

        # Write to file
        try:
            with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                file.write(full_content)
            print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
        except Exception as e:
            raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="dscript.VariableOccurrences.get_all_elements_in_lists"><code class="name flex">
<span>def <span class="ident">get_all_elements_in_lists</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves all unique elements within list-type variable values.</p>
<p>Returns:
- A dict mapping each variable to its set of unique elements in lists per scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_elements_in_lists(self):
    &#34;&#34;&#34;
    Retrieves all unique elements within list-type variable values.

    Returns:
    - A dict mapping each variable to its set of unique elements in lists per scope.
    &#34;&#34;&#34;
    result = {}
    for var in self.variables:
        var_elements = {}
        for scope, occurrences in self.data[var].items():
            unique_elems = set()
            if is_scalar(occurrences):
                if isinstance(occurrences, list):
                    unique_elems.update(occurrences)
            elif isinstance(occurrences, list):
                for item in occurrences:
                    if isinstance(item, tuple) and len(item) == 2:
                        _, val = item
                        if isinstance(val, list):
                            unique_elems.update(val)
                    elif isinstance(item, list):
                        unique_elems.update(item)
            var_elements[scope] = unique_elems
        result[var] = var_elements
    return result</code></pre>
</details>
</dd>
<dt id="dscript.VariableOccurrences.get_all_values"><code class="name flex">
<span>def <span class="ident">get_all_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves all unique values of the variable(s).</p>
<p>Returns:
- A dict mapping each variable to its set of unique values per scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_values(self):
    &#34;&#34;&#34;
    Retrieves all unique values of the variable(s).

    Returns:
    - A dict mapping each variable to its set of unique values per scope.
    &#34;&#34;&#34;
    result = {}
    for var in self.variables:
        var_unique = {}
        for scope, occurrences in self.data[var].items():
            unique_vals = set()
            if is_scalar(occurrences):
                unique_vals.add(occurrences)
            elif isinstance(occurrences, list):
                for item in occurrences:
                    if isinstance(item, tuple) and len(item) == 2:
                        _, val = item
                        hashable_val = make_hashable(val)
                        unique_vals.add(hashable_val)
                    else:
                        hashable_val = make_hashable(item)
                        unique_vals.add(hashable_val)
            var_unique[scope] = unique_vals
        result[var] = var_unique
    return result</code></pre>
</details>
</dd>
<dt id="dscript.VariableOccurrences.get_raw_data"><code class="name flex">
<span>def <span class="ident">get_raw_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the raw data.</p>
<p>Returns:
- The raw data as provided during initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_data(self):
    &#34;&#34;&#34;
    Returns the raw data.

    Returns:
    - The raw data as provided during initialization.
    &#34;&#34;&#34;
    return self.data</code></pre>
</details>
</dd>
<dt id="dscript.VariableOccurrences.get_steps_with_value"><code class="name flex">
<span>def <span class="ident">get_steps_with_value</span></span>(<span>self, value, within_list=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the steps where the variable equals the specified value.</p>
<p>Parameters:
- value: The value to search for.
- within_list (bool): If True, searches for the value within list-type variable values.</p>
<p>Returns:
- If single variable:
- A dict with scopes as keys and lists of step indices or values as values.
- If multiple variables:
- A dict mapping each variable name to their respective scope-step/value mappings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_steps_with_value(self, value, within_list=False):
    &#34;&#34;&#34;
    Retrieves the steps where the variable equals the specified value.

    Parameters:
    - value: The value to search for.
    - within_list (bool): If True, searches for the value within list-type variable values.

    Returns:
    - If single variable:
        - A dict with scopes as keys and lists of step indices or values as values.
    - If multiple variables:
        - A dict mapping each variable name to their respective scope-step/value mappings.
    &#34;&#34;&#34;
    result = {}
    for var in self.variables:
        var_result = {}
        for scope, occurrences in self.data[var].items():
            if is_scalar(occurrences):
                # Scalar value
                if within_list:
                    continue  # Cannot search within a scalar
                if occurrences == value:
                    var_result[scope] = occurrences
            elif isinstance(occurrences, list):
                # List of values or list of tuples
                steps = []
                for item in occurrences:
                    if isinstance(item, tuple) and len(item) == 2:
                        step, val = item
                        if within_list:
                            if isinstance(val, list) and value in val:
                                steps.append(step)
                        else:
                            if val == value:
                                steps.append(step)
                    else:
                        # List of values
                        if within_list:
                            if isinstance(item, list) and value in item:
                                steps.append(item)
                        else:
                            if item == value:
                                steps.append(item)
                if steps:
                    var_result[scope] = steps
            else:
                # Other types (e.g., dict), can be extended as needed
                pass
        if var_result:
            result[var] = var_result
    return result</code></pre>
</details>
</dd>
<dt id="dscript.VariableOccurrences.get_steps_with_value_in_scope"><code class="name flex">
<span>def <span class="ident">get_steps_with_value_in_scope</span></span>(<span>self, variable, scope, value, within_list=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the steps within a specific scope where the variable equals the specified value.</p>
<p>Parameters:
- variable (str): The variable name.
- scope (str): The scope to search within ("static", "global", "local").
- value: The value to search for.
- within_list (bool): If True, searches for the value within list-type variable values.</p>
<p>Returns:
- A list of step indices or values where the variable equals the value within the specified scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_steps_with_value_in_scope(self, variable, scope, value, within_list=False):
    &#34;&#34;&#34;
    Retrieves the steps within a specific scope where the variable equals the specified value.

    Parameters:
    - variable (str): The variable name.
    - scope (str): The scope to search within (&#34;static&#34;, &#34;global&#34;, &#34;local&#34;).
    - value: The value to search for.
    - within_list (bool): If True, searches for the value within list-type variable values.

    Returns:
    - A list of step indices or values where the variable equals the value within the specified scope.
    &#34;&#34;&#34;
    if variable not in self.variables:
        raise ValueError(f&#34;Variable &#39;{variable}&#39; is not managed by this instance.&#34;)

    scope = scope.lower()
    occurrences = self.data[variable].get(scope, [])
    steps = []

    if is_scalar(occurrences):
        if within_list:
            if isinstance(occurrences, list) and value in occurrences:
                steps.append(occurrences)
        else:
            if occurrences == value:
                steps.append(occurrences)
    elif isinstance(occurrences, list):
        for item in occurrences:
            if isinstance(item, tuple) and len(item) == 2:
                step, val = item
                if within_list:
                    if isinstance(val, list) and value in val:
                        steps.append(step)
                else:
                    if val == value:
                        steps.append(step)
            else:
                if within_list:
                    if isinstance(item, list) and value in item:
                        steps.append(item)
                else:
                    if item == value:
                        steps.append(item)
    return steps</code></pre>
</details>
</dd>
<dt id="dscript.VariableOccurrences.get_usage_count"><code class="name flex">
<span>def <span class="ident">get_usage_count</span></span>(<span>self, value, within_list=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Counts how many times a specific value is used.</p>
<p>Parameters:
- value: The value to count.
- within_list (bool): If True, counts occurrences within list-type variable values.</p>
<p>Returns:
- If single variable:
- A dict with scopes as keys and integer counts or counts of values as values.
- If multiple variables:
- A dict mapping each variable name to their respective scope-count/value mappings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_usage_count(self, value, within_list=False):
    &#34;&#34;&#34;
    Counts how many times a specific value is used.

    Parameters:
    - value: The value to count.
    - within_list (bool): If True, counts occurrences within list-type variable values.

    Returns:
    - If single variable:
        - A dict with scopes as keys and integer counts or counts of values as values.
    - If multiple variables:
        - A dict mapping each variable name to their respective scope-count/value mappings.
    &#34;&#34;&#34;
    result = {}
    for var in self.variables:
        var_count = {}
        for scope, occurrences in self.data[var].items():
            count = 0
            if is_scalar(occurrences):
                if within_list:
                    if isinstance(occurrences, list) and value in occurrences:
                        count += 1
                else:
                    if occurrences == value:
                        count += 1
            elif isinstance(occurrences, list):
                for item in occurrences:
                    if isinstance(item, tuple) and len(item) == 2:
                        _, val = item
                        if within_list:
                            if isinstance(val, list) and value in val:
                                count += 1
                        else:
                            if val == value:
                                count += 1
                    else:
                        if within_list:
                            if isinstance(item, list) and value in item:
                                count += 1
                        else:
                            if item == value:
                                count += 1
            if count &gt; 0:
                var_count[scope] = count
        if var_count:
            result[var] = var_count
    return result</code></pre>
</details>
</dd>
<dt id="dscript.VariableOccurrences.summarize"><code class="name flex">
<span>def <span class="ident">summarize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides a summary of the variable occurrences.</p>
<p>Returns:
- A dict mapping each variable to their respective summaries per scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize(self):
    &#34;&#34;&#34;
    Provides a summary of the variable occurrences.

    Returns:
    - A dict mapping each variable to their respective summaries per scope.
    &#34;&#34;&#34;
    summary = {}
    for var in self.variables:
        var_summary = {}
        for scope, occurrences in self.data[var].items():
            unique_vals = set()
            unique_elements = set()
            value_counts = defaultdict(int)
            element_counts = defaultdict(int)

            if is_scalar(occurrences):
                # Scalar value
                hashable_val = make_hashable(occurrences)
                unique_vals.add(hashable_val)
                value_counts[hashable_val] += 1
                if isinstance(occurrences, list):
                    unique_elements.update(occurrences)
                    for elem in occurrences:
                        element_counts[elem] += 1
            elif isinstance(occurrences, list):
                for item in occurrences:
                    if isinstance(item, tuple) and len(item) == 2:
                        # Tuple: (step, value)
                        step, val = item
                        hashable_val = make_hashable(val)
                        unique_vals.add(hashable_val)
                        value_counts[hashable_val] += 1
                        if isinstance(val, list):
                            unique_elements.update(val)
                            for elem in val:
                                element_counts[elem] += 1
                        elif isinstance(val, dict):
                            # Handle nested dictionaries if necessary
                            for sub_val in val.values():
                                if isinstance(sub_val, list):
                                    unique_elements.update(sub_val)
                                    for elem in sub_val:
                                        element_counts[elem] += 1
                    else:
                        # Direct value
                        hashable_val = make_hashable(item)
                        unique_vals.add(hashable_val)
                        value_counts[hashable_val] += 1
                        if isinstance(item, list):
                            unique_elements.update(item)
                            for elem in item:
                                element_counts[elem] += 1
                        elif isinstance(item, dict):
                            for sub_val in item.values():
                                if isinstance(sub_val, list):
                                    unique_elements.update(sub_val)
                                    for elem in sub_val:
                                        element_counts[elem] += 1
            else:
                # Other types can be handled here if needed
                pass

            var_summary[scope] = {
                &#34;total_occurrences&#34;: len(occurrences),
                &#34;unique_values&#34;: unique_vals,
                &#34;unique_elements_in_lists&#34;: unique_elements,
                &#34;value_counts&#34;: dict(value_counts),
                &#34;element_counts_in_lists&#34;: dict(element_counts)
            }
        summary[var] = var_summary
    return summary</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dscript.dscript"><code class="flex name class">
<span>class <span class="ident">dscript</span></span>
<span>(</span><span>name=None, SECTIONS=['DYNAMIC'], section=0, position=None, role='dscript instance', description='dynamic script', userid='dscript', version=None, license=None, email=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>dscript: A Dynamic Script Management Class</p>
<p>The <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> class is designed to manage and dynamically generate multiple
lines/items of a script, typically for use with LAMMPS or similar simulation tools.
Each line in the script is represented as a <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> object, and the
class provides tools to easily manipulate, concatenate, and execute these
script lines/items.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Dynamic Script Generation</strong>: Define and manage script lines/items dynamically,
with variables that can be substituted at runtime.</li>
<li><strong>Conditional Execution</strong>: Add conditions to script lines/items so they are only
included if certain criteria are met.</li>
<li><strong>Script Concatenation</strong>: Combine multiple script objects while maintaining
control over variable precedence and script structure.</li>
<li><strong>User-Friendly Access</strong>: Easily access and manipulate script lines/items using
familiar Python constructs like indexing and iteration.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>Custom LAMMPS Scripts</strong>: Generate complex simulation scripts with varying
parameters based on dynamic conditions.</li>
<li><strong>Automation</strong>: Automate the creation of scripts for batch processing,
simulations, or other repetitive tasks.</li>
<li><strong>Script Management</strong>: Manage and version-control different script sections
and configurations easily.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, name=None):
Initializes a new <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object with an optional name.</p>
<p><strong>getitem</strong>(self, key):
Retrieves a script line by its key. If a list of keys is provided,
returns a new <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object with lines/items reordered accordingly.</p>
<p><strong>setitem</strong>(self, key, value):
Adds or updates a script line. If the value is an empty list, the
corresponding script line is removed.</p>
<p><strong>delitem</strong>(self, key):
Deletes a script line by its key.</p>
<p><strong>contains</strong>(self, key):
Checks if a key exists in the script. Allows usage of <code>in</code> keyword.</p>
<p><strong>iter</strong>(self):
Returns an iterator over the script lines/items, allowing for easy iteration
through all lines/items in the <code>TEMPLATE</code>.</p>
<p><strong>len</strong>(self):
Returns the number of script lines/items currently stored in the <code>TEMPLATE</code>.</p>
<p>keys(self):
Returns the keys of the <code>TEMPLATE</code> dictionary.</p>
<p>values(self):
Returns the <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> objects stored as values in the <code>TEMPLATE</code>.</p>
<p>items(self):
Returns the keys and <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> objects from the <code>TEMPLATE</code> as pairs.</p>
<p><strong>str</strong>(self):
Returns a human-readable summary of the script, including the number
of lines/items and total attributes. Shortcut: <code>str(S)</code>.</p>
<p><strong>repr</strong>(self):
Provides a detailed string representation of the entire <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object,
including all script lines/items and their attributes. Useful for debugging.</p>
<p>reorder(self, order):
Reorders the script lines/items based on a given list of indices, creating a
new <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object with the reordered lines/items.</p>
<p>get_content_by_index(self, index, do=True, protected=True):
Returns the processed content of the script line at the specified index,
with variables substituted based on the definitions and conditions applied.</p>
<p>get_attributes_by_index(self, index):
Returns the attributes of the script line at the specified index.</p>
<p>add_dynamic_script(self, key, content="", definitions=None, verbose=None, **USER):
Add a dynamic script step to the <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object.</p>
<p>createEmptyVariables(self, vars):
Creates new variables in <code>DEFINITIONS</code> if they do not already exist.
Accepts a single variable name or a list of variable names.</p>
<p>do(self, printflag=None, verbose=None):
Executes all script lines/items in the <code>TEMPLATE</code>, concatenating the results,
and handling variable substitution. Returns the full script as a string.</p>
<p>script(self, **userdefinitions):
Generates a <code><a title="dscript.lamdaScript" href="#dscript.lamdaScript">lamdaScript</a></code> object from the current <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object,
applying any additional user definitions provided.</p>
<p>pipescript(self, printflag=None, verbose=None, **USER):
Returns a <code><a title="dscript.pipescript" href="#dscript.pipescript">pipescript</a></code> object by combining script objects for all keys
in the <code>TEMPLATE</code>. Each key in <code>TEMPLATE</code> is handled separately, and
the resulting scripts are combined using the <code>|</code> operator.</p>
<p>save(self, filename=None, foldername=None, overwrite=False):
Saves the current script instance to a text file in a structured format.
Includes metadata, global parameters, definitions, templates, and attributes.</p>
<p>write(scriptcontent, filename=None, foldername=None, overwrite=False):
Writes the provided script content to a specified file in a given folder,
with a header added if necessary, ensuring the correct file format.</p>
<p>load(cls, filename, foldername=None, numerickeys=True):
Loads a script instance from a text file, restoring the content, definitions,
templates, and attributes. Handles parsing and variable substitution based on
the structure of the file.</p>
<p>parsesyntax(cls, content, numerickeys=True):
Parses a script instance from a string input, restoring the content, definitions,
templates, and attributes. Handles parsing and variable substitution based on the
structure of the provided string, ensuring the correct format and key conversions
when necessary.</p>
<p>search(self, primary_key, value, foreign_key, include_global=True, multiple='first', verbose=False):
Searches for foreign key values associated with given primary key value(s).</p>
<p>list_values(self, key, include_global=True):
Lists all unique values taken by a specified key across all steps and optionally
in global definitions.</p>
<p>var_info(self):
Analyzes and gathers comprehensive information about variables used in the script.</p>
<p>print_var_info(self, what='all', output_file=None, overwrite=False):
Prints or saves a neatly formatted table of variable information based on the analysis from <code>var_info()</code>.</p>
<h2 id="example">Example:</h2>
<h1 id="create-a-dscript-object">Create a dscript object</h1>
<p>R = dscript(name="MyScript")</p>
<h1 id="define-global-variables-definitions">Define global variables (DEFINITIONS)</h1>
<p>R.DEFINITIONS.dimension = 3
R.DEFINITIONS.units = "$si"</p>
<h1 id="add-script-lines">Add script lines</h1>
<p>R[0] = "dimension
${dimension}"
R[1] = "units
${units}"</p>
<h1 id="generate-and-print-the-script">Generate and print the script</h1>
<p>sR = R.script()
print(sR.do())</p>
<h2 id="attributes">Attributes:</h2>
<p>name : str
The name of the script, useful for identification.
TEMPLATE : dict
A dictionary storing script lines/items, with keys to identify each line.
DEFINITIONS : lambdaScriptdata
Stores the variables and parameters used within the script lines/items.</p>
<p>Initializes a new <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object.</p>
<p>The constructor sets up a new <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object, which allows you to
define and manage a script composed of multiple lines/items. Each line is
stored in the <code>TEMPLATE</code> dictionary, and variables used in the script
are stored in <code>DEFINITIONS</code>.</p>
<h2 id="parameters">Parameters:</h2>
<p>name : str, optional
The name of the script. If no name is provided, a random name will
be generated automatically. The name is useful for identifying the
script, especially when managing multiple scripts.</p>
<h2 id="example_1">Example:</h2>
<h1 id="create-a-dscript-object-with-a-specific-name">Create a dscript object with a specific name</h1>
<p>R = dscript(name="ExampleScript")</p>
<h1 id="or-create-a-dscript-object-with-a-random-name">Or create a dscript object with a random name</h1>
<p>R = dscript()</p>
<p>After initialization, you can start adding script lines/items and defining variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dscript:
    &#34;&#34;&#34;
    dscript: A Dynamic Script Management Class

    The `dscript` class is designed to manage and dynamically generate multiple
    lines/items of a script, typically for use with LAMMPS or similar simulation tools.
    Each line in the script is represented as a `ScriptTemplate` object, and the
    class provides tools to easily manipulate, concatenate, and execute these
    script lines/items.

    Key Features:
    -------------
    - **Dynamic Script Generation**: Define and manage script lines/items dynamically,
      with variables that can be substituted at runtime.
    - **Conditional Execution**: Add conditions to script lines/items so they are only
      included if certain criteria are met.
    - **Script Concatenation**: Combine multiple script objects while maintaining
      control over variable precedence and script structure.
    - **User-Friendly Access**: Easily access and manipulate script lines/items using
      familiar Python constructs like indexing and iteration.

    Practical Use Cases:
    --------------------
    - **Custom LAMMPS Scripts**: Generate complex simulation scripts with varying
      parameters based on dynamic conditions.
    - **Automation**: Automate the creation of scripts for batch processing,
      simulations, or other repetitive tasks.
    - **Script Management**: Manage and version-control different script sections
      and configurations easily.

    Methods:
    --------
    __init__(self, name=None):
        Initializes a new `dscript` object with an optional name.

    __getitem__(self, key):
        Retrieves a script line by its key. If a list of keys is provided,
        returns a new `dscript` object with lines/items reordered accordingly.

    __setitem__(self, key, value):
        Adds or updates a script line. If the value is an empty list, the
        corresponding script line is removed.

    __delitem__(self, key):
        Deletes a script line by its key.

    __contains__(self, key):
        Checks if a key exists in the script. Allows usage of `in` keyword.

    __iter__(self):
        Returns an iterator over the script lines/items, allowing for easy iteration
        through all lines/items in the `TEMPLATE`.

    __len__(self):
        Returns the number of script lines/items currently stored in the `TEMPLATE`.

    keys(self):
        Returns the keys of the `TEMPLATE` dictionary.

    values(self):
        Returns the `ScriptTemplate` objects stored as values in the `TEMPLATE`.

    items(self):
        Returns the keys and `ScriptTemplate` objects from the `TEMPLATE` as pairs.

    __str__(self):
        Returns a human-readable summary of the script, including the number
        of lines/items and total attributes. Shortcut: `str(S)`.

    __repr__(self):
        Provides a detailed string representation of the entire `dscript` object,
        including all script lines/items and their attributes. Useful for debugging.

    reorder(self, order):
        Reorders the script lines/items based on a given list of indices, creating a
        new `dscript` object with the reordered lines/items.

    get_content_by_index(self, index, do=True, protected=True):
        Returns the processed content of the script line at the specified index,
        with variables substituted based on the definitions and conditions applied.

    get_attributes_by_index(self, index):
        Returns the attributes of the script line at the specified index.

    add_dynamic_script(self, key, content=&#34;&#34;, definitions=None, verbose=None, **USER):
        Add a dynamic script step to the `dscript` object.

    createEmptyVariables(self, vars):
        Creates new variables in `DEFINITIONS` if they do not already exist.
        Accepts a single variable name or a list of variable names.

    do(self, printflag=None, verbose=None):
        Executes all script lines/items in the `TEMPLATE`, concatenating the results,
        and handling variable substitution. Returns the full script as a string.

    script(self, **userdefinitions):
        Generates a `lamdaScript` object from the current `dscript` object,
        applying any additional user definitions provided.

    pipescript(self, printflag=None, verbose=None, **USER):
        Returns a `pipescript` object by combining script objects for all keys
        in the `TEMPLATE`. Each key in `TEMPLATE` is handled separately, and
        the resulting scripts are combined using the `|` operator.

    save(self, filename=None, foldername=None, overwrite=False):
        Saves the current script instance to a text file in a structured format.
        Includes metadata, global parameters, definitions, templates, and attributes.

    write(scriptcontent, filename=None, foldername=None, overwrite=False):
        Writes the provided script content to a specified file in a given folder,
        with a header added if necessary, ensuring the correct file format.

    load(cls, filename, foldername=None, numerickeys=True):
        Loads a script instance from a text file, restoring the content, definitions,
        templates, and attributes. Handles parsing and variable substitution based on
        the structure of the file.

    parsesyntax(cls, content, numerickeys=True):
        Parses a script instance from a string input, restoring the content, definitions,
        templates, and attributes. Handles parsing and variable substitution based on the
        structure of the provided string, ensuring the correct format and key conversions
        when necessary.

    search(self, primary_key, value, foreign_key, include_global=True, multiple=&#39;first&#39;, verbose=False):
        Searches for foreign key values associated with given primary key value(s).

    list_values(self, key, include_global=True):
        Lists all unique values taken by a specified key across all steps and optionally
        in global definitions.

    var_info(self):
        Analyzes and gathers comprehensive information about variables used in the script.

    print_var_info(self, what=&#39;all&#39;, output_file=None, overwrite=False):
        Prints or saves a neatly formatted table of variable information based on the analysis from `var_info()`.


    Example:
    --------
    # Create a dscript object
    R = dscript(name=&#34;MyScript&#34;)

    # Define global variables (DEFINITIONS)
    R.DEFINITIONS.dimension = 3
    R.DEFINITIONS.units = &#34;$si&#34;

    # Add script lines
    R[0] = &#34;dimension    ${dimension}&#34;
    R[1] = &#34;units        ${units}&#34;

    # Generate and print the script
    sR = R.script()
    print(sR.do())

    Attributes:
    -----------
    name : str
        The name of the script, useful for identification.
    TEMPLATE : dict
        A dictionary storing script lines/items, with keys to identify each line.
    DEFINITIONS : lambdaScriptdata
        Stores the variables and parameters used within the script lines/items.
    &#34;&#34;&#34;

    # Class variable to list attributes that should not be treated as TEMPLATE entries
    construction_attributes = {&#39;name&#39;, &#39;SECTIONS&#39;, &#39;section&#39;, &#39;position&#39;, &#39;role&#39;, &#39;description&#39;,
                               &#39;userid&#39;, &#39;verbose&#39;, &#39;printflag&#39;, &#39;DEFINITIONS&#39;, &#39;TEMPLATE&#39;,
                               &#39;version&#39;,&#39;license&#39;,&#39;email&#39;
                               }

    def __init__(self,  name=None,
                        SECTIONS = [&#34;DYNAMIC&#34;],
                        section = 0,
                        position = None,
                        role = &#34;dscript instance&#34;,
                        description = &#34;dynamic script&#34;,
                        userid = &#34;dscript&#34;,
                        version = None,
                        license = None,
                        email = None,
                        printflag = False,
                        verbose = False,
                        verbosity = None,
                        **userdefinitions
                        ):
        &#34;&#34;&#34;
        Initializes a new `dscript` object.

        The constructor sets up a new `dscript` object, which allows you to
        define and manage a script composed of multiple lines/items. Each line is
        stored in the `TEMPLATE` dictionary, and variables used in the script
        are stored in `DEFINITIONS`.

        Parameters:
        -----------
        name : str, optional
            The name of the script. If no name is provided, a random name will
            be generated automatically. The name is useful for identifying the
            script, especially when managing multiple scripts.

        Example:
        --------
        # Create a dscript object with a specific name
        R = dscript(name=&#34;ExampleScript&#34;)

        # Or create a dscript object with a random name
        R = dscript()

        After initialization, you can start adding script lines/items and defining variables.
        &#34;&#34;&#34;

        if name is None:
            self.name = autoname()
        else:
            self.name = name

        if (version is None) or (license is None) or (email is None):
            metadata = get_metadata()               # retrieve all metadata
            version = metadata[&#34;version&#34;] if version is None else version
            license = metadata[&#34;license&#34;] if license is None else license
            email = metadata[&#34;email&#34;] if email is None else email
        self.SECTIONS = SECTIONS if isinstance(SECTIONS,(list,tuple)) else [SECTIONS]
        self.section = section
        self.position = position if position is not None else 0
        self.role = role
        self.description = description
        self.userid = userid
        self.version = version
        self.license = license
        self.email = email
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.DEFINITIONS = lambdaScriptdata(**userdefinitions)
        self.TEMPLATE = {}

    def __getattr__(self, attr):
        # During construction phase, we only access the predefined attributes
        if &#39;TEMPLATE&#39; not in self.__dict__:
            if attr in self.__dict__:
                return self.__dict__[attr]
            raise AttributeError(f&#34;&#39;dscript&#39; object has no attribute &#39;{attr}&#39;&#34;)

        # If TEMPLATE is initialized and attr is in TEMPLATE, return the corresponding ScriptTemplate entry
        if attr in self.TEMPLATE:
            return self.TEMPLATE[attr]

        # Fall back to internal __dict__ attributes if not in TEMPLATE
        if attr in self.__dict__:
            return self.__dict__[attr]

        raise AttributeError(f&#34;&#39;dscript&#39; object has no attribute &#39;{attr}&#39;&#34;)


    def __setattr__(self, attr, value):
        # Handle internal attributes during the construction phase
        if &#39;TEMPLATE&#39; not in self.__dict__:
            self.__dict__[attr] = value
            return

        # Handle construction attributes separately (name, TEMPLATE, USER)
        if attr in self.construction_attributes:
            self.__dict__[attr] = value
        # If TEMPLATE exists, and the attribute is intended for it, update TEMPLATE
        elif &#39;TEMPLATE&#39; in self.__dict__:
            # Convert the value to a ScriptTemplate if needed, and update the template
            if attr in self.TEMPLATE:
                # Modify the existing ScriptTemplate object for this attribute
                if isinstance(value, str):
                    self.TEMPLATE[attr].content = value
                elif isinstance(value, dict):
                    self.TEMPLATE[attr].attributes.update(value)
            else:
                # Create a new entry if it does not exist
                self.TEMPLATE[attr] = ScriptTemplate(content=value,definitions=self.DEFINITIONS,verbose=self.verbose,userid=attr)
        else:
            # Default to internal attributes
            self.__dict__[attr] = value


    def __getitem__(self, key):
        &#34;&#34;&#34;
        Implements index-based retrieval, slicing, or reordering for dscript objects.

        Parameters:
        -----------
        key : int, slice, list, or str
            - If `key` is an int, returns the corresponding template at that index.
              Supports negative indices to retrieve templates from the end.
            - If `key` is a slice, returns a new `dscript` object containing the templates in the specified range.
            - If `key` is a list, reorders the TEMPLATE based on the list of indices or keys.
            - If `key` is a string, treats it as a key and returns the corresponding template.

        Returns:
        --------
        dscript or ScriptTemplate : Depending on the type of key, returns either a new dscript object (for slicing or reordering)
                                    or a ScriptTemplate object (for direct key access).
        &#34;&#34;&#34;
        # Handle list-based reordering
        if isinstance(key, list):
            return self.reorder(key)

        # Handle slicing
        elif isinstance(key, slice):
            new_dscript = deepduplicate(self)
            new_dscript.name = f&#34;{self.name}_slice_{key.start}_{key.stop}&#34;
            keys = list(self.TEMPLATE.keys())
            sliced_keys = keys[key]
            new_dscript.TEMPLATE = {k: self.TEMPLATE[k] for k in sliced_keys}
            return new_dscript

        # Handle integer indexing with support for negative indices
        elif isinstance(key, int):
            keys = list(self.TEMPLATE.keys())
            if key in self.TEMPLATE:  # Check if the integer exists as a key
                return self.TEMPLATE[key]
            if key &lt; 0:  # Support negative indices
                key += len(keys)
            if key &lt; 0 or key &gt;= len(keys):  # Check for index out of range
                raise IndexError(f&#34;Index {key - len(keys)} is out of range&#34;)
            # Return the template corresponding to the integer index
            return self.TEMPLATE[keys[key]]

        # Handle key-based access (string keys)
        elif isinstance(key, str):
            if key in self.TEMPLATE:
                return self.TEMPLATE[key]
            raise KeyError(f&#34;Key &#39;{key}&#39; does not exist in TEMPLATE.&#34;)


    def __setitem__(self, key, value):
        if (value == []) or (value is None):
            # If the value is an empty list, delete the corresponding key
            del self.TEMPLATE[key]
        else:
            # Otherwise, set the key to the new ScriptTemplate
            self.TEMPLATE[key] = ScriptTemplate(value, definitions=self.DEFINITIONS, verbose=self.verbose, userid=key)

    def __delitem__(self, key):
        del self.TEMPLATE[key]

    def __iter__(self):
        return iter(self.TEMPLATE.items())

    # def keys(self):
    #     return self.TEMPLATE.keys()

    # def values(self):
    #     return (s.content for s in self.TEMPLATE.values())

    def __contains__(self, key):
        return key in self.TEMPLATE

    def __len__(self):
        return len(self.TEMPLATE)

    def items(self):
        return ((key, s.content) for key, s in self.TEMPLATE.items())

    def __str__(self):
        num_TEMPLATE = len(self.TEMPLATE)
        total_attributes = sum(len(s.attributes) for s in self.TEMPLATE.values())
        return f&#34;{num_TEMPLATE} TEMPLATE, {total_attributes} attributes&#34;

    def __repr__(self):
        &#34;&#34;&#34;Representation of dscript object with additional properties.&#34;&#34;&#34;
        repr_str = f&#34;dscript object ({self.name})\n&#34;
        # Add description, role, and version at the beginning
        repr_str += f&#34;id: {self.userid}\n&#34; if self.userid else &#34;&#34;
        repr_str += f&#34;Descr: {self.description}\n&#34; if self.description else &#34;&#34;
        repr_str += f&#34;Role: {self.role} (v. {self.version})\n&#34;
        repr_str += f&#39;SECTIONS {span(self.SECTIONS,&#34;,&#34;,&#34;[&#34;,&#34;]&#34;)} | index: {self.section} | position: {self.position}\n&#39;
        repr_str += f&#34;\n\n\twith {len(self.TEMPLATE)} TEMPLATE&#34;
        repr_str += &#34;s&#34; if len(self.TEMPLATE)&gt;1 else &#34;&#34;
        repr_str += f&#34; (with {len(self.DEFINITIONS)} DEFINITIONS)\n\n&#34;
        # Add TEMPLATE information
        c = 0
        for k, s in self.TEMPLATE.items():
            head = f&#34;|  idx: {c} |  key: {k}  |&#34;
            dashes = (50 - len(head)) // 2
            repr_str += &#34;-&#34; * 50 + &#34;\n&#34;
            repr_str += f&#34;{&#39;&lt;&#39; * dashes}{head}{&#39;&gt;&#39; * dashes}\n{repr(s)}\n&#34;
            c += 1
        return repr_str

    def keys(self):
        &#34;&#34;&#34;Return the keys of the TEMPLATE.&#34;&#34;&#34;
        return self.TEMPLATE.keys()

    def values(self):
        &#34;&#34;&#34;Return the ScriptTemplate objects in TEMPLATE.&#34;&#34;&#34;
        return self.TEMPLATE.values()

    def reorder(self, order):
        &#34;&#34;&#34;Reorder the TEMPLATE lines according to a list of indices.&#34;&#34;&#34;
        # Get the original items as a list of (key, value) pairs
        original_items = list(self.TEMPLATE.items())
        # Create a new dictionary with reordered scripts, preserving original keys
        new_scripts = {original_items[i][0]: original_items[i][1] for i in order}
        # Create a new dscript object with reordered scripts
        reordered_script = dscript()
        reordered_script.TEMPLATE = new_scripts
        return reordered_script


    def get_content_by_index(self, index, do=True, protected=True):
        &#34;&#34;&#34;
        Returns the content of the ScriptTemplate at the specified index.

        Parameters:
        -----------
        index : int
            The index of the template in the TEMPLATE dictionary.
        do : bool, optional (default=True)
            If True, the content will be processed based on conditions and evaluation flags.
        protected : bool, optional (default=True)
            Controls whether variable evaluation is protected (e.g., prevents overwriting certain definitions).

        Returns:
        --------
        str or list of str
            The content of the template after processing, or an empty string if conditions or evaluation flags block it.
        &#34;&#34;&#34;
        key = list(self.TEMPLATE.keys())[index]
        s = self.TEMPLATE[key].content
        att = self.TEMPLATE[key].attributes
        # Return an empty string if the facultative attribute is True and do is True
        if att[&#34;facultative&#34;] and do:
            return &#34;&#34;
        # Evaluate the condition (if any)
        if att[&#34;condition&#34;] is not None:
            cond = eval(self.DEFINITIONS.formateval(att[&#34;condition&#34;], protected))
        else:
            cond = True
        # If the condition is met, process the content
        if cond:
            # Apply formateval only if the eval attribute is True and do is True
            if att[&#34;eval&#34;] and do:
                if isinstance(s, list):
                    # Apply formateval to each item in the list if s is a list
                    return [self.DEFINITIONS.formateval(line, protected) for line in s]
                else:
                    # Apply formateval to the single string content
                    return self.DEFINITIONS.formateval(s, protected)
            else:
                return s  # Return the raw content if no evaluation is needed
        elif do:
            return &#34;&#34;  # Return an empty string if the condition is not met and do is True
        else:
            return s  # Return the raw content if do is False


    def get_attributes_by_index(self, index):
        &#34;&#34;&#34; Returns the attributes of the ScriptTemplate at the specified index.&#34;&#34;&#34;
        key = list(self.TEMPLATE.keys())[index]
        return self.TEMPLATE[key].attributes


    def __add__(self, other):
        &#34;&#34;&#34;
        Concatenates two dscript objects, creating a new dscript object that combines
        the TEMPLATE and DEFINITIONS of both. This operation avoids deep copying
        of definitions by creating a new lambdaScriptdata instance from the definitions.

        when other is not a dscript, self is converted into a script before being combined with +

        Parameters:
        -----------
        other : dscript, script, scriptobjectgroup, pipescript
            The other dscript object to concatenate with the current one.

        Returns:
        --------
        result : dscript (or a script)
            A new dscript object with the concatenated TEMPLATE and merged DEFINITIONS.
            A script object is returned when other is not a dscript object.

        Raises:
        -------
        TypeError:
            If the other object is not an instance of dscript, script, pipescript
        &#34;&#34;&#34;
        if isinstance(other, dscript):
            # Step 1: Merge global DEFINITIONS from both self and other
            result = dscript(name=self.name+&#34;+&#34;+other.name,**(self.DEFINITIONS + other.DEFINITIONS))
            # Step 2: Start by copying the TEMPLATE from self (no deepcopy for performance reasons)
            result.TEMPLATE = self.TEMPLATE.copy()
            # Step 3: Ensure that the local definitions for `self.TEMPLATE` are properly copied
            for key, value in self.TEMPLATE.items():
                result.TEMPLATE[key].definitions = lambdaScriptdata(**self.TEMPLATE[key].definitions)
            # Step 4: Track the next available index if keys need to be created
            next_index = len(result.TEMPLATE)
            # Step 5: Add items from the other dscript object, updating or generating new keys as needed
            for key, value in other.TEMPLATE.items():
                if key in result.TEMPLATE:
                    # If key already exists in result, assign a new unique index
                    while next_index in result.TEMPLATE:
                        next_index += 1
                    new_key = next_index
                else:
                    # Use the original key if it doesn&#39;t already exist
                    new_key = key
                # Copy the TEMPLATE&#39;s content and definitions from `other`
                result.TEMPLATE[new_key] = value
                # Merge the local TEMPLATE definitions from `other`
                result.TEMPLATE[new_key].definitions = lambdaScriptdata(**other.TEMPLATE[key].definitions)
            return result
        elif isinstance(other,(script,scriptobjectgroup)):
            return self.script() + other
        elif isinstance(other,pipescript):
            return self.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | other
        else:
            raise TypeError(f&#34;Cannot concatenate &#39;dscript&#39; with &#39;{type(other).__name__}&#39;&#34;)


    def __or__(self, other):
        &#34;&#34;&#34;
        Pipes a dscript object with other objects.
        When other is a dscript object, both objects are concatenated (+) before being converted into a pipescript object
        When other is a script, pipescript or scriptobjectgroup, self is converted into a pipescript

        Parameters:
        -----------
        other : dscript, script, scriptobjectgroup, pipescript
            The other dscript object to concatenate with the current one.

        Returns:
        --------
        result : a pipescript

        Raises:
        -------
        TypeError:
            If the other object is not an instance of dscript, script, pipescript
        &#34;&#34;&#34;
        if isinstance(other, dscript):
            tmp = self + other
            return tmp.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(other,(script,pipescript)):
            return self.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | other
        elif isinstance(other,scriptobjectgroup):
            return self.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | other.script()
        else:
            raise TypeError(f&#34;Cannot pipe &#39;dscript&#39; with &#39;{type(other).__name__}&#39;&#34;)



    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extracts subobjects from the dscript based on the provided keys.

        Parameters:
        -----------
        *keys : one or more keys that correspond to the `TEMPLATE` entries.

        Returns:
        --------
        A new `dscript` object that contains only the selected script lines/items, along with
        the relevant definitions and attributes from the original object.
        &#34;&#34;&#34;
        # Create a new dscript object to store the extracted sub-objects
        result = dscript(name=f&#34;{self.name}_subobject&#34;)
        # Copy the TEMPLATE entries corresponding to the provided keys
        for key in keys:
            if key in self.TEMPLATE:
                result.TEMPLATE[key] = self.TEMPLATE[key]
            else:
                raise KeyError(f&#34;Key &#39;{key}&#39; not found in TEMPLATE.&#34;)
        # Copy the DEFINITIONS from the current object
        result.DEFINITIONS = copy.deepcopy(self.DEFINITIONS)
        # Copy other relevant attributes
        result.SECTIONS = self.SECTIONS[:]
        result.section = self.section
        result.position = self.position
        result.role = self.role
        result.description = self.description
        result.userid = self.userid
        result.version = self.version
        result.verbose = self.verbose
        result.printflag = self.printflag

        return result

    def createEmptyVariables(self, vars):
        &#34;&#34;&#34;
        Creates empty variables in DEFINITIONS if they don&#39;t already exist.

        Parameters:
        -----------
        vars : str or list of str
            The variable name or list of variable names to be created in DEFINITIONS.
        &#34;&#34;&#34;
        if isinstance(vars, str):
            vars = [vars]  # Convert single variable name to list for uniform processing
        for varname in vars:
            if varname not in self.DEFINITIONS:
                self.DEFINITIONS.setattr(varname,&#34;${&#34; + varname + &#34;}&#34;)


    def do(self, printflag=None, verbose=None, softrun=False, return_definitions=False,comment_chars=&#34;#%&#34;, **USER):
        &#34;&#34;&#34;
        Executes or previews all `ScriptTemplate` instances in `TEMPLATE`, concatenating their processed content.
        Allows for optional headers and footers based on verbosity settings, and offers a preliminary preview mode with `softrun`.
        Accumulates definitions across all templates if `return_definitions=True`.

        Parameters
        ----------
        printflag : bool, optional
            If `True`, enables print output during execution. Defaults to the instance&#39;s print flag if `None`.
        verbose : bool, optional
            If `True`, includes headers and footers in the output, providing additional detail.
            Defaults to the instance&#39;s verbosity setting if `None`.
        softrun : bool, optional
            If `True`, executes the script in a preliminary mode:
            - Bypasses full variable substitution for a preview of the content, useful for validating structure.
            - If `False` (default), performs full processing, including variable substitutions and evaluations.
        return_definitions : bool, optional
            If `True`, returns a tuple where the second element contains accumulated definitions from all templates.
            If `False` (default), returns only the concatenated output.
        comment_chars : str, optional (default: &#34;#%&#34;)
            A string containing characters to identify the start of a comment.
            Any of these characters will mark the beginning of a comment unless within quotes.
        **USER : keyword arguments
            Allows for the provision of additional user-defined definitions, where each keyword represents a
            definition key and the associated value represents the definition&#39;s content. These definitions
            can override or supplement template-level definitions during execution.

        Returns
        -------
        str or tuple
            - If `return_definitions=False`, returns the concatenated output of all `ScriptTemplate` instances,
              with optional headers, footers, and execution summary based on verbosity.
            - If `return_definitions=True`, returns a tuple of (`output`, `accumulated_definitions`), where
              `accumulated_definitions` contains all definitions used across templates.

        Notes
        -----
        - Each `ScriptTemplate` in `TEMPLATE` is processed individually using its own `do()` method.
        - The `softrun` mode provides a preliminary content preview without full variable substitution,
          helpful for inspecting the script structure or gathering local definitions.
        - When `verbose` is enabled, the method includes detailed headers, footers, and a summary of processed and
          ignored items, providing insight into the script&#39;s construction and variable usage.
        - Accumulated definitions from each `ScriptTemplate` are combined if `return_definitions=True`, which can be
          useful for tracking all variables and definitions applied across the templates.

        Example
        -------
        &gt;&gt;&gt; dscript_instance = dscript(name=&#34;ExampleScript&#34;)
        &gt;&gt;&gt; dscript_instance.TEMPLATE[0] = ScriptTemplate(
        ...     content=[&#34;units ${units}&#34;, &#34;boundary ${boundary}&#34;],
        ...     definitions=lambdaScriptdata(units=&#34;lj&#34;, boundary=&#34;p p p&#34;),
        ...     attributes={&#39;eval&#39;: True}
        ... )
        &gt;&gt;&gt; dscript_instance.do(verbose=True, units=&#34;real&#34;)
        # Output:
        # --------------
        # TEMPLATE &#34;ExampleScript&#34;
        # --------------
        units real
        boundary p p p
        # ---&gt; Total items: 2 - Ignored items: 0
        &#34;&#34;&#34;

        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        header = f&#34;# --------------[ TEMPLATE \&#34;{self.name}\&#34; ]--------------&#34; if verbose else &#34;&#34;
        footer = &#34;# --------------------------------------------&#34; if verbose else &#34;&#34;

        # Initialize output, counters, and optional definitions accumulator
        output = [header]
        non_empty_lines = 0
        ignored_lines = 0
        accumulated_definitions = self.DEFINITIONS if return_definitions else None

        for key, template in self.TEMPLATE.items():
            # Process each template with softrun if enabled, otherwise use full processing
            result = template.do(softrun=softrun,globaldefinitions=self.DEFINITIONS,USER=lambdaScriptdata(**USER))
            if result:
                # Apply comment removal based on verbosity
                final_result = result if verbose else remove_comments(result,comment_chars=comment_chars)
                if final_result or verbose:
                    output.append(final_result)
                    non_empty_lines += 1
                else:
                    ignored_lines += 1
                # Accumulate definitions if return_definitions is enabled
                if return_definitions:
                    accumulated_definitions += template.definitions
            else:
                ignored_lines += 1

        # Add footer summary if verbose
        nel_word = &#39;items&#39; if non_empty_lines &gt; 1 else &#39;item&#39;
        il_word = &#39;items&#39; if ignored_lines &gt; 1 else &#39;item&#39;
        footer += f&#34;\n# ---&gt; Total {nel_word}: {non_empty_lines} - Ignored {il_word}: {ignored_lines}&#34; if verbose else &#34;&#34;
        output.append(footer)

        # Concatenate output and determine return type based on return_definitions
        output_content = &#34;\n&#34;.join(output)
        return (output_content, accumulated_definitions) if return_definitions else output_content



    def script(self,printflag=None, verbose=None, verbosity=None, **USER):
        &#34;&#34;&#34;
        returns the corresponding script
        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        return lamdaScript(self,persistentfile=True, persistentfolder=None,
                           printflag=printflag, verbose=verbose,
                           **USER)

    def pipescript(self, *keys, printflag=None, verbose=None, verbosity=None, **USER):
        &#34;&#34;&#34;
        Returns a pipescript object by combining script objects corresponding to the given keys.

        Parameters:
        -----------
        *keys : one or more keys that correspond to the `TEMPLATE` entries.
        printflag : bool, optional
            Whether to enable printing of additional information.
        verbose : bool, optional
            Whether to run in verbose mode for debugging or detailed output.
        **USER : dict, optional
            Additional user-defined variables to pass into the script.

        Returns:
        --------
        A `pipescript` object that combines the script objects generated from the selected
        dscript subobjects.
        &#34;&#34;&#34;
        # Start with an empty pipescript
        # combined_pipescript = None
        # # Iterate over the provided keys to extract corresponding subobjects
        # for key in keys:
        #     # Extract the dscript subobject for the given key
        #     sub_dscript = self(key)
        #     # Convert the dscript subobject to a script object, passing USER, printflag, and verbose
        #     script_obj = sub_dscript.script(printflag=printflag, verbose=verbose, **USER)
        #     # Combine script objects into a pipescript object
        #     if combined_pipescript is None:
        #         combined_pipescript = pipescript(script_obj)  # Initialize pipescript
        #     else:
        #         combined_pipescript = combined_pipescript | script_obj  # Use pipe operator
        # if combined_pipescript is None:
        #     ValueError(&#39;The conversion to pipescript from {type{self}} falled&#39;)
        # return combined_pipescript
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity

        # Loop over all keys in TEMPLATE and combine them
        combined_pipescript = None
        localvariables = scriptdata()
        for key in self.keys():
            # Create a new dscript object with only the current key in TEMPLATE
            focused_dscript = dscript(name=f&#34;{self.name}:{key}&#34;)
            focused_dscript.TEMPLATE[key] = self.TEMPLATE[key]
            localvariables = localvariables+scriptdata(**self.TEMPLATE[key].definitions)
            focused_dscript.TEMPLATE[key].definitions = localvariables
            focused_dscript.DEFINITIONS = scriptdata(**self.DEFINITIONS)
            focused_dscript.SECTIONS = self.SECTIONS[:]
            focused_dscript.section = self.section
            focused_dscript.position = self.position
            focused_dscript.role = self.role
            focused_dscript.description = self.description
            focused_dscript.userid = self.userid
            focused_dscript.version = self.version
            focused_dscript.verbose = verbose
            focused_dscript.printflag = printflag

            # Convert the focused dscript object to a script object
            script_obj = focused_dscript.script(printflag=printflag, verbose=verbose, **USER)

            # Combine the script objects into a pipescript object using the pipe operator
            if combined_pipescript is None:
                combined_pipescript = pipescript(script_obj)  # Initialize pipescript
            else:
                combined_pipescript = combined_pipescript | pipescript(script_obj)  # Use pipe operator

        if combined_pipescript is None:
            ValueError(&#39;The conversion to pipescript from {type{self}} falled&#39;)
        return combined_pipescript


    @staticmethod
    def header(name=None, verbose=True, verbosity=None, style=2, filepath=None, version=None, license=None, email=None):
        &#34;&#34;&#34;
        Generate a formatted header for the DSCRIPT file.

        ### Parameters:
            name (str, optional): The name of the script. If None, &#34;Unnamed&#34; is used.
            verbose (bool, optional): Whether to include the header. Default is True.
            verbosity (int, optional): Verbosity level. Overrides `verbose` if specified.
            style (int, optional): ASCII style for the header (default=2).
            filepath (str, optional): Full path to the file being saved. If None, the line mentioning the file path is excluded.
            version (str, optional): DSCRIPT version. If None, it is omitted from the header.
            license (str, optional): License type. If None, it is omitted from the header.
            email (str, optional): Contact email. If None, it is omitted from the header.

        ### Returns:
            str: A formatted string representing the script&#39;s metadata and initialization details.
                 Returns an empty string if `verbose` is False.

        ### The header includes:
            - DSCRIPT version, license, and contact email, if provided.
            - The name of the script.
            - Filepath, if provided.
            - Information on where and when the script was generated.

        ### Notes:
            - If `verbosity` is specified, it overrides `verbose`.
            - Omits metadata lines if `version`, `license`, or `email` are not provided.
        &#34;&#34;&#34;
        # Resolve verbosity
        verbose = verbosity &gt; 0 if verbosity is not None else verbose
        if not verbose:
            return &#34;&#34;
        # Validate inputs
        if name is None:
            name = &#34;Unnamed&#34;
        # Prepare metadata line
        metadata = []
        if version:
            metadata.append(f&#34;v{version}&#34;)
        if license:
            metadata.append(f&#34;License: {license}&#34;)
        if email:
            metadata.append(f&#34;Email: {email}&#34;)
        metadata_line = &#34; | &#34;.join(metadata)
        # Prepare the framed header content
        lines = []
        if metadata_line:
            lines.append(f&#34;PIZZA.DSCRIPT FILE {metadata_line}&#34;)
        lines += [
            &#34;&#34;,
            f&#34;Name: {name}&#34;,
        ]
        # Add the filepath line if filepath is not None
        if filepath:
            lines.append(f&#34;Path: {filepath}&#34;)
        lines += [
            &#34;&#34;,
            f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
            f&#34;{datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
        ]
        # Use the shared frame_header function to format the framed content
        return frame_header(lines, style=style)



    # Generator
    # -----------
    def generator(self):
        &#34;&#34;&#34;
        Returns
        -------
        STR
            generated code corresponding to dscript (using dscript syntax/language).

        &#34;&#34;&#34;
        return self.save(generatoronly=True)


    # Information on variables
    # ------------------------
    def var_info(self):
        &#34;&#34;&#34;
        Analyze and gather comprehensive information about variables used in the script.

        This method performs a sophisticated analysis of both global and local variables within
        the script. It identifies variable usage, overrides, defaults, and counts the number of
        different values each variable holds across various templates.

        The analysis considers two scopes:
        - **Global:** Variables defined in the global definitions (`self.DEFINITIONS`).
        - **Local:** Variables defined within each template&#39;s definitions.

        Returns:
            dict: A dictionary named `varnfo` where each key is a variable name and the value is
                  another dictionary containing detailed information about that variable. The structure
                  of `varnfo` is as follows:

                  {
                      &#34;variable_name&#34;: {
                          &#34;value&#34;: &lt;initial_value_from_global&gt;,
                          &#34;updatedvalue&#34;: &lt;current_value_after_overrides&gt;,
                          &#34;is_default&#34;: &lt;bool&gt;,
                          &#34;first_def&#34;: &lt;template_index_or_None&gt;,
                          &#34;first_use&#34;: &lt;template_index&gt;,
                          &#34;first_val&#34;: &lt;value_at_first_use&gt;,
                          &#34;override_index&#34;: &lt;template_index_or_None&gt;,
                          &#34;is_global&#34;: &lt;bool&gt;,
                          &#34;value_counter&#34;: &lt;int&gt;
                          etc.
                      },
                      ...
                  }

                  **Field Descriptions:**
                  - `value`: Initial value of the variable from global definitions (if applicable).
                  - `updatedvalue`: Current value after any overrides in local templates.
                  - `is_default`: Indicates if the variable is set to a default value.
                  - `first_def`: The index of the first template where the variable is defined locally.
                  - `first_use`: The index of the first template where the variable is used.
                  - `first_val`: The value of the variable at its first use.
                  - `override_index`: The index of the template where the variable was overridden (if any).
                  - `is_autodef`: Flag, True if ${variable} is defined automatically as ${variable}
                  - `is_empty`: Flag,  True if the variable is empty (None,&#34;&#34;,[], etc.)
                  - `is_global`: Indicates if the variable originates from global definitions.
                  - `value_counter`: Counts the number of different values the variable has across templates.
                  - `first_use_isglobal` : Flag, True if the global value is used at first use
                  - `set_in`: Lists all template indices values where the variable is assigned/changed,
                  - `set_as`: Lists assigned values as reported in `set_in`,
                  - `values`: Lists variable changes (template index, refvalue),
                  - `used_in`: Lists template indices where the variable is used

        Raises:
            AttributeError: If `self.DEFINITIONS` does not have the specified key.
        &#34;&#34;&#34;

        start_time = time.time()  # Start the timer

        # Initialize definitions with self.DEFINITIONS
        allvars = self.DEFINITIONS

        # Temporary dictionary to track global variable information
        varnfo = {}

        # Loop over each template item to detect and record variable usage and overrides
        for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
            # Detect variables used in this template
            used_variables = script_template.detect_variables()

            # Check each variable used in this template
            for var in used_variables:
                # Get global and local values for the variable
                global_value = getattr(allvars, var, None)
                local_value = getattr(script_template.definitions, var, None)
                is_autodef = global_value == f&#34;${{{var}}}&#34;
                is_global = var in allvars  # Check if the variable originates in global space
                is_empty = global_value in (None,&#34;&#34;,[],[&#34;&#34;])
                is_default = is_global and (is_empty or is_autodef)

                # If the variable is not yet tracked, initialize its info
                if var not in varnfo:
                    initialcounter = 1 if local_value is None or local_value==global_value else 2
                    first_use_isglobal = initialcounter==1
                    refvalue = global_value if first_use_isglobal else local_value
                    override_index = template_index if ((local_value is not None) and not first_use_isglobal and not is_default) else None
                    varnfo[var] = {
                        &#34;value&#34;: refvalue,        # Initial value from allvars if exists
                        &#34;updatedvalue&#34;: refvalue, # Initial value from allvars if exists
                        &#34;is_default&#34;: is_default,     # Check if it’s set to a default value
                        &#34;first_def&#34;: None,            # First definition (to be updated later)
                        &#34;first_use&#34;: template_index,  # First time the variable is used
                        &#34;first_val&#34;: refvalue,        # First value
                        &#34;override_index&#34;: override_index,  # Set override if defined locally
                        &#34;is_autodef&#34;: is_autodef,     # automatic definition ${variable}
                        &#34;is_empty&#34;: is_empty,         # Track if the variable is empty (None,&#34;&#34;,[], etc.)
                        &#34;is_global&#34;: is_global,       # Track if the variable originates as global
                        &#34;value_counter&#34;: initialcounter, # Count the number of different values
                        &#34;first_use_isglobal&#34;: first_use_isglobal, # True if the global value is used at first use
                        &#34;set_in&#34;: [template_index],
                        &#34;set_as&#34;: [refvalue],
                        &#34;values&#34;:[(template_index, refvalue)],
                        &#34;used_in&#34;: [template_index]
                    }
                else:
                    # Update `override_index` if the variable is defined locally and its value changes
                    varnfo[var][&#34;used_in&#34;].append(template_index)
                    if local_value is not None:
                        # Check if the local value differs from the tracked value in varnfo
                        current_value = varnfo[var][&#34;updatedvalue&#34;] # varnfo[var][&#34;value&#34;]
                        if current_value != local_value:
                            varnfo[var][&#34;override_index&#34;] = template_index
                            varnfo[var][&#34;updatedvalue&#34;] = local_value  # Update the tracked value
                            varnfo[var][&#34;value_counter&#34;] += 1
                            varnfo[var][&#34;set_in&#34;].append(template_index)
                            varnfo[var][&#34;set_as&#34;].append(local_value)
                            varnfo[var][&#34;values&#34;].append((template_index, local_value))

        # Second loop: Update `first_def` for all variables
        for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
            local_definitions = script_template.definitions.keys()
            for var in local_definitions:
                if var in varnfo and varnfo[var][&#34;first_def&#34;] is None:
                    varnfo[var][&#34;first_def&#34;] = template_index
                    varnfo[var][&#34;first_val&#34;] = getattr(script_template.definitions, var)

        execution_time = time.time() - start_time  # Calculate the execution time in seconds

        if self.verbose:
            print(f&#34;Variable analysis completed in {execution_time:.4f} seconds.&#34;)

        return varnfo


    def print_var_info(self, what=&#39;all&#39;, output_file=None, overwrite=False):
        &#34;&#34;&#34;
        Print or save a neatly formatted table of variable information based on the analysis from `var_info()`.

        This method retrieves variable information using the `var_info()` method and presents it in a
        Markdown-compatible table or an HTML table. Users can choose to display information for all variables
        or a specific subset by providing a list of variable names. Additionally, users can opt to save the
        table to a file with options to control file extension, path validity, and overwrite behavior.

        Parameters
        ----------
        what : str or list of str, optional
            Specifies which variables&#39; information to print.
            - If set to &#39;all&#39; (default), information for all variables is displayed.
            - If set to a list of variable names, only those variables are displayed.

        output_file : str, optional
            The path to the file where the table will be saved.
            - If set to `None` (default), the table is printed to the console.
            - If a file path is provided, the table is saved to the specified file.

        overwrite : bool, default=False
            Determines whether to overwrite the file if it already exists.
            - If `False` and the file exists, a `FileExistsError` is raised.
            - If `True`, the existing file is overwritten.

        Raises
        ------
        ValueError
            - If `what` is neither `&#39;all&#39;` nor a list of strings.
            - If the file extension is neither `.md`, `.txt`, nor `.html`.
        FileNotFoundError
            If the specified directory in `output_file` does not exist.
        PermissionError
            If the specified path is not writable.
        FileExistsError
            If the file exists and `overwrite` is set to `False`.
        IOError
            If an error occurs during file writing.
        &#34;&#34;&#34;
        # Retrieve the variable information dictionary
        varnfo = self.var_info()

        # Determine which variables to display
        if what == &#39;all&#39;:
            variables_to_print = list(varnfo.keys())
        elif isinstance(what, list):
            # Ensure all items in the list are strings
            if not all(isinstance(var, str) for var in what):
                raise ValueError(&#34;All items in the &#39;what&#39; list must be strings representing variable names.&#34;)
            variables_to_print = what
        else:
            raise ValueError(&#34;Parameter &#39;what&#39; must be either &#39;all&#39; or a list of variable names.&#34;)

        # Filter out variables that are not present in varnfo
        missing_vars = [var for var in variables_to_print if var not in varnfo]
        if missing_vars:
            print(f&#34;Warning: The following variables were not found and will be skipped: {missing_vars}&#34;)
            # Remove missing variables from the list
            variables_to_print = [var for var in variables_to_print if var in varnfo]

        if not variables_to_print:
            print(&#34;No variables to display.&#34;)
            return

        # Define the headers based on varnfo fields
        headers = [
            &#34;Variable Name&#34;,
            &#34;Value&#34;,
            &#34;Updated Value&#34;,
            &#34;Is Default&#34;,
            &#34;First Def&#34;,
            &#34;First Use&#34;,
            &#34;First Val&#34;,
            &#34;Override Index&#34;,
            &#34;Is Autodef&#34;,
            &#34;Is Empty&#34;,
            &#34;Is Global&#34;,
            &#34;Value Counter&#34;,
            &#34;First Use IsGlobal&#34;,
            &#34;Set In&#34;,
            &#34;Set As&#34;,
            &#34;Values&#34;,
            &#34;Used In&#34;
        ]

        # Initialize a list to hold all rows
        table_rows = []

        # Populate the table rows with variable information
        for var in variables_to_print:
            info = varnfo[var]
            row = [
                var,
                self._format_field(info.get(&#34;value&#34;)),
                self._format_field(info.get(&#34;updatedvalue&#34;)),
                self._format_field(info.get(&#34;is_default&#34;)),
                self._format_field(info.get(&#34;first_def&#34;)),
                self._format_field(info.get(&#34;first_use&#34;)),
                self._format_field(info.get(&#34;first_val&#34;)),
                self._format_field(info.get(&#34;override_index&#34;)),
                self._format_field(info.get(&#34;is_autodef&#34;)),
                self._format_field(info.get(&#34;is_empty&#34;)),
                self._format_field(info.get(&#34;is_global&#34;)),
                self._format_field(info.get(&#34;value_counter&#34;)),
                self._format_field(info.get(&#34;first_use_isglobal&#34;)),
                self._format_list(info.get(&#34;set_in&#34;)),
                self._format_list(info.get(&#34;set_as&#34;)),
                self._format_values(info.get(&#34;values&#34;)),
                self._format_list(info.get(&#34;used_in&#34;))
            ]
            table_rows.append(row)

        # Calculate the maximum width for each column
        column_widths = [len(header) for header in headers]
        for row in table_rows:
            for idx, cell in enumerate(row):
                cell_length = len(str(cell))
                if cell_length &gt; column_widths[idx]:
                    column_widths[idx] = cell_length

        # Build the Markdown table
        # Header row
        header_row = &#34;| &#34; + &#34; | &#34;.join(f&#34;{header.ljust(column_widths[idx])}&#34; for idx, header in enumerate(headers)) + &#34; |&#34;
        # Separator row
        separator_row = &#34;|-&#34; + &#34;-|-&#34;.join(&#39;-&#39; * column_widths[idx] for idx in range(len(headers))) + &#34;-|&#34;
        # Data rows
        data_rows = [
            &#34;| &#34; + &#34; | &#34;.join(f&#34;{str(cell).ljust(column_widths[idx])}&#34; for idx, cell in enumerate(row)) + &#34; |&#34;
            for row in table_rows
        ]

        # Combine all parts for Markdown
        markdown_table = &#34;\n&#34;.join([header_row, separator_row] + data_rows)

        # Generate HTML table if needed
        html_table = None
        if output_file:
            _, file_extension = os.path.splitext(output_file)
            file_extension = file_extension.lower()

            if file_extension not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;, &#39;&#39;]:
                raise ValueError(&#34;File extension must be either &#39;.md&#39;, &#39;.txt&#39;, or &#39;.html&#39;.&#34;)

            if file_extension == &#39;&#39;:
                # Default to .md
                output_file += &#39;.md&#39;
                file_extension = &#39;.md&#39;

            # Extract directory from the output_file path
            directory = os.path.dirname(os.path.abspath(output_file))
            if directory and not os.path.exists(directory):
                raise FileNotFoundError(f&#34;The directory &#39;{directory}&#39; does not exist.&#34;)

            if directory and not os.access(directory, os.W_OK):
                raise PermissionError(f&#34;The directory &#39;{directory}&#39; is not writable.&#34;)

            # Check if the file exists
            if os.path.exists(output_file) and not overwrite:
                raise FileExistsError(f&#34;The file &#39;{output_file}&#39; already exists and overwrite is set to False.&#34;)

            # Prepare title and timestamp
            timestamp = datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
            title = f&#34;{self.name} - Variable Information&#34;
            subtitle = f&#34;Generated on {timestamp} by {self.userid}&#34;

            if file_extension == &#39;.html&#39;:
                # Build HTML table with embedded CSS
                html_table = self._build_html_table(headers, table_rows, column_widths, title, subtitle)
            else:
                # For Markdown and TXT, prepare content with title and timestamp
                content = f&#34;# {title}\n\n&#34;
                content += f&#34;**{subtitle}**\n\n&#34;
                content += markdown_table + &#34;\n&#34;

        # If output_file is not specified, print to console
        if output_file is None:
            # Print title and timestamp
            timestamp = datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
            title = f&#34;{self.name} - Variable Information&#34;
            subtitle = f&#34;Generated on {timestamp} by {self.userid}&#34;
            print(f&#34;### {title}\n&#34;)
            print(f&#34;**{subtitle}**\n&#34;)
            # Print the Markdown table
            print(markdown_table)
        else:
            # Save to file based on extension
            try:
                if file_extension in [&#39;.md&#39;, &#39;.txt&#39;]:
                    # Prepare content with title and timestamp
                    content = f&#34;# {title}\n\n&#34;
                    content += f&#34;**{subtitle}**\n\n&#34;
                    content += markdown_table + &#34;\n&#34;

                    # Write to file
                    with open(output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                        f.write(content)
                    print(f&#34;Variable information successfully written to &#39;{output_file}&#39;.&#34;)
                elif file_extension == &#39;.html&#39;:
                    # Write HTML content
                    with open(output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                        f.write(html_table)
                    print(f&#34;Variable information successfully written to &#39;{output_file}&#39;.&#34;)
            except IOError as e:
                raise IOError(f&#34;An error occurred while writing to the file: {e}&#34;)

    def _build_html_table(self, headers, table_rows, column_widths, title, subtitle):
        &#34;&#34;&#34;
        Helper method to build an HTML table with embedded CSS.

        Parameters
        ----------
        headers : list of str
            The table headers.
        table_rows : list of list
            The table data rows.
        column_widths : list of int
            The maximum width for each column.
        title : str
            The title of the table.
        subtitle : str
            The subtitle containing timestamp and user information.

        Returns
        -------
        str
            The complete HTML content as a string.
        &#34;&#34;&#34;
        # Define CSS styles for the HTML table
        css_styles = &#34;&#34;&#34;
        &lt;style&gt;
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
            }
            h1 {
                text-align: center;
            }
            h2 {
                text-align: center;
                color: gray;
            }
            .table-container {
                overflow-x: auto;
                max-height: 2400px;
                overflow-y: auto;
                border: 1px solid #ddd;
                padding: 10px;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                table-layout: fixed;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                word-wrap: break-word;
            }
            tr:nth-child(even){background-color: #f2f2f2;}
            tr:hover {background-color: #ddd;}
            th {
                padding-top: 12px;
                padding-bottom: 12px;
                text-align: left;
                background-color: #4CAF50;
                color: white;
            }
        &lt;/style&gt;
        &#34;&#34;&#34;

        # Start building HTML content
        html_content = f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;{title}&lt;/title&gt;\n{css_styles}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;

        # Add title and subtitle
        html_content += f&#34;&lt;h1&gt;{title}&lt;/h1&gt;\n&#34;
        html_content += f&#34;&lt;h2&gt;{subtitle}&lt;/h2&gt;\n&#34;

        # Add table container
        html_content += &#34;&lt;div class=&#39;table-container&#39;&gt;\n&#34;

        # Start table
        html_content += &#34;&lt;table&gt;\n&#34;

        # Header row
        html_content += &#34;  &lt;tr&gt;\n&#34;
        for header in headers:
            html_content += f&#34;    &lt;th&gt;{header}&lt;/th&gt;\n&#34;
        html_content += &#34;  &lt;/tr&gt;\n&#34;

        # Data rows
        for row in table_rows:
            html_content += &#34;  &lt;tr&gt;\n&#34;
            for cell in row:
                html_content += f&#34;    &lt;td&gt;{self._escape_html(str(cell))}&lt;/td&gt;\n&#34;
            html_content += &#34;  &lt;/tr&gt;\n&#34;

        # End table and container
        html_content += &#34;&lt;/table&gt;\n&lt;/div&gt;\n&#34;

        # End body and html
        html_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

        return html_content

    def _escape_html(self, text):
        &#34;&#34;&#34;
        Helper method to escape HTML special characters in text.

        Parameters
        ----------
        text : str
            The text to escape.

        Returns
        -------
        str
            The escaped text.
        &#34;&#34;&#34;
        import html
        return html.escape(text)

    def _format_field(self, field):
        &#34;&#34;&#34;
        Helper method to format individual fields for the table.

        Parameters
        ----------
        field : Any
            The field value to format.

        Returns
        -------
        str
            The formatted string representation of the field.
        &#34;&#34;&#34;
        if field is None:
            return &#34;None&#34;
        elif isinstance(field, bool):
            return &#34;True&#34; if field else &#34;False&#34;
        else:
            return str(field)

    def _format_list(self, lst):
        &#34;&#34;&#34;
        Helper method to format list-type fields for the table.

        Parameters
        ----------
        lst : list or None
            The list to format.

        Returns
        -------
        str
            Comma-separated string of list items or an empty string if the list is None or empty.
        &#34;&#34;&#34;
        if not lst:
            return &#34;&#34;
        return &#34;, &#34;.join(str(item) for item in lst)

    def _format_values(self, values):
        &#34;&#34;&#34;
        Helper method to format the &#39;values&#39; field, which is a list of tuples.

        Parameters
        ----------
        values : list of tuples or None
            The list of (template_index, value) tuples.

        Returns
        -------
        str
            Comma-separated string of &#34;template_index: value&#34; pairs or an empty string if None or empty.
        &#34;&#34;&#34;
        if not values:
            return &#34;&#34;
        return &#34;, &#34;.join(f&#34;{idx}: {val}&#34; for idx, val in values)

    # ... [Other existing methods] ...



    # Save Method
    # -----------
    def save(self, filename=None, foldername=None, overwrite=False, generatoronly=False, onlyusedvariables=True):
        &#34;&#34;&#34;
        Save the current script instance to a text file.

        Parameters
        ----------
        filename : str, optional
            The name of the file to save the script to. If not provided, `self.name` is used.
            The extension &#34;.txt&#34; is automatically appended if not included.

        foldername : str, optional
            The directory where the file will be saved. If not provided, it defaults to the system&#39;s
            temporary directory. If the filename does not include a full path, this folder will be used.

        overwrite : bool, default=True
            Whether to overwrite the file if it already exists. If set to False, an exception is raised
            if the file exists.

        generatoronly : bool, default=False
            If True, the method returns the generated content string without saving to a file.

        onlyusedvariables : bool, default=True
            If True, local definitions are only saved if they are used within the template content.
            If False, all local definitions are saved, regardless of whether they are referenced in
            the template.

        Raises
        ------
        FileExistsError
            If the file already exists and `overwrite` is set to False.

        Notes
        -----
        - The script is saved in a plain text format, and each section (global parameters, definitions,
          template, and attributes) is written in a structured format with appropriate comments.
        - If `self.name` is used as the filename, it must be a valid string that can serve as a file name.
        - The file structure follows the format:
            # DSCRIPT SAVE FILE
            # generated on YYYY-MM-DD on user@hostname

            # GLOBAL PARAMETERS
            { ... }

            # DEFINITIONS (number of definitions=...)
            key=value

            # TEMPLATES (number of items=...)
            key: template_content

            # ATTRIBUTES (number of items with explicit attributes=...)
            key:{attr1=value1, attr2=value2, ...}
        &#34;&#34;&#34;
        # At the beginning of the save method
        start_time = time.time()  # Start the timer

        if not generatoronly:
            # Use self.name if filename is not provided
            if filename is None:
                filename = span(self.name, sep=&#34;\n&#34;)

            # Ensure the filename ends with &#39;.txt&#39;
            if not filename.endswith(&#39;.txt&#39;):
                filename += &#39;.txt&#39;

            # Construct the full path
            if foldername in [None, &#34;&#34;]:  # Handle cases where foldername is None or an empty string
                filepath = os.path.abspath(filename)
            else:
                filepath = os.path.join(foldername, filename)

            # Check if the file already exists, and raise an exception if it does and overwrite is False
            if os.path.exists(filepath) and not overwrite:
                raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

        # Header with current date, username, and host
        header = &#34;# DSCRIPT SAVE FILE\n&#34;
        header += &#34;\n&#34;*2
        if generatoronly:
            header += dscript.header(verbose=True,filepath=&#39;dynamic code generation (no file)&#39;,
                                     name = self.name, version=self.version, license=self.license, email=self.email)
        else:
            header += dscript.header(verbose=True,filepath=filepath,
                                     name = self.name, version=self.version, license=self.license, email=self.email)
        header += &#34;\n&#34;*2

        # Global parameters in strict Python syntax
        global_params = &#34;# GLOBAL PARAMETERS (8 parameters)\n&#34;
        global_params += &#34;{\n&#34;
        global_params += f&#34;    SECTIONS = {self.SECTIONS},\n&#34;
        global_params += f&#34;    section = {self.section},\n&#34;
        global_params += f&#34;    position = {self.position},\n&#34;
        global_params += f&#34;    role = {self.role!r},\n&#34;
        global_params += f&#34;    description = {self.description!r},\n&#34;
        global_params += f&#34;    userid = {self.userid!r},\n&#34;
        global_params += f&#34;    version = {self.version},\n&#34;
        global_params += f&#34;    verbose = {self.verbose}\n&#34;
        global_params += &#34;}\n&#34;

        # Initialize definitions with self.DEFINITIONS
        #allvars = self.DEFINITIONS

        # Temporary dictionary to track global variable information
        vinfo = self.var_info()

        # Filter global definitions based on usage, overrides, and first_def
        #  and info[&#34;is_default&#34;]
        filtered_globals = {
            var: info for var, info in vinfo.items()
            if ((info[&#34;is_global&#34;]and not info[&#34;is_empty&#34;]) and (info[&#34;first_use_isglobal&#34;]) and (info[&#34;override_index&#34;] is None))
            }

        # Generate the definitions output based on filtered globals
        definitions = f&#34;\n# GLOBAL DEFINITIONS (number of definitions={len(filtered_globals)})\n&#34;
        for var, info in filtered_globals.items():
            if info[&#34;is_default&#34;] and (info[&#34;first_def&#34;]&gt;info[&#34;first_use&#34;] if info[&#34;first_def&#34;] else True):
                definitions += f&#34;{var} = ${{{var}}}  # value assumed to be defined outside this DSCRIPT file\n&#34;
            else:
                value = info[&#34;first_val&#34;]   #info[&#34;value&#34;]
                if info[&#34;is_empty&#34;]:        #value in [&#34;&#34;, None]
                    definitions += f&#39;{var} = &#34;&#34;\n&#39;
                elif isinstance(value, str):
                    safe_value = value.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;\n&#39;, &#39;\\n&#39;)
                    definitions += f&#34;{var} = {safe_value}\n&#34;
                else:
                    definitions += f&#34;{var} = {value}\n&#34;

        # Template (number of lines/items)
        printsinglecontent = False
        template = f&#34;\n# TEMPLATES (number of items={len(self.TEMPLATE)})\n&#34;
        #for key, script_template in self.TEMPLATE.items():
        for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
            # Get local template definitions and detected variables
            template_vars = script_template.definitions
            used_variables = script_template.detect_variables()
            islocal = False
            # Temporary dictionary to accumulate variables to add to allvars
            valid_local_vars = lambdaScriptdata()
            # Write template-specific definitions only if they meet the updated conditions
            for var in template_vars.keys():
                # Conditions for adding a variable to the local template and to `allvars`
                if (var in used_variables or not onlyusedvariables) \
                   and (template_index in vinfo[var][&#34;set_in&#34;]) \
                   and (var not in filtered_globals):
                # if (var in used_variables or not onlyusedvariables) and (
                #    script_template.is_variable_set_value_only(var) and
                #    (var not in allvars or getattr(template_vars, var) != getattr(allvars, var))
                #):
                    # Start local definitions section if this is the first local variable for the template
                    if not islocal:
                        template += f&#34;\n# LOCAL DEFINITIONS for key &#39;{key}&#39;\n&#34;
                        islocal = True
                    # Retrieve and process the variable value
                    # value = getattr(template_vars, var)
                    value = next((ref for idx, ref in vinfo[var][&#34;values&#34;] if idx == template_index), None)
                    if value in [&#34;&#34;, None]:
                        template += f&#39;{var} = &#34;&#34;\n&#39;  # Set empty or None values as &#34;&#34;
                    elif isinstance(value, str):
                        safe_value = value.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;\n&#39;, &#39;\\n&#39;)
                        template += f&#34;{var} = {safe_value}\n&#34;
                    else:
                        template += f&#34;{var} = {value}\n&#34;
                    # Add the variable to valid_local_vars for selective update of allvars
                    valid_local_vars.setattr(var, value)
            # Update allvars only with filtered, valid local variables
            # allvars += valid_local_vars

            # Write the template content
            if isinstance(script_template.content, list):
                if len(script_template.content) == 1:
                    # Single-line template saved as a single line
                    content_str = script_template.content[0].strip()
                    template += &#34;&#34; if printsinglecontent else &#34;\n&#34;
                    template += f&#34;{key}: {content_str}\n&#34;
                    printsinglecontent = True
                else:
                    content_str = &#39;\n    &#39;.join(script_template.content)
                    template += f&#34;\n{key}: [\n    {content_str}\n ]\n&#34;
                    printsinglecontent = False
            else:
                template += &#34;&#34; if printsinglecontent else &#34;\n&#34;
                template += f&#34;{key}: {script_template.content}\n&#34;
                printsinglecontent = True

        # Attributes (number of lines/items with explicit attributes)
        attributes = f&#34;# ATTRIBUTES (number of items with explicit attributes={len(self.TEMPLATE)})\n&#34;
        for key, script_template in self.TEMPLATE.items():
            attr_str = &#34;, &#34;.join(f&#34;{attr_name}={repr(attr_value)}&#34;
                                 for attr_name, attr_value in script_template.attributes.items())
            attributes += f&#34;{key}:{{{attr_str}}}\n&#34;

        # Combine all sections into one content
        content = header + &#34;\n&#34; + global_params + &#34;\n&#34; + definitions + &#34;\n&#34; + template + &#34;\n&#34; + attributes + &#34;\n&#34;


        # Append footer information to the content
        non_empty_lines = sum(1 for line in content.splitlines() if line.strip())  # Count non-empty lines
        execution_time = time.time() - start_time  # Calculate the execution time in seconds
        # Prepare the footer content
        footer_lines = [
            [&#34;Non-empty lines&#34;, str(non_empty_lines)],
            [&#34;Execution time (seconds)&#34;, f&#34;{execution_time:.4f}&#34;],
        ]
        # Format footer into tabular style
        footer_content = [
            f&#34;{row[0]:&lt;25} {row[1]:&lt;15}&#34; for row in footer_lines
        ]
        # Use frame_header to format footer
        footer = frame_header(
            lines=[&#34;DSCRIPT SAVE FILE generator&#34;] + footer_content,
            style=1
        )
        # Append footer to the content
        content += f&#34;\n{footer}&#34;

        if generatoronly:
            return content
        else:
            # Write the content to the file
            with open(filepath, &#39;w&#39;) as f:
                f.write(content)
            print(f&#34;\nScript saved to {filepath}&#34;)
            return filepath



    # Write Method -- added on 2024-09-05
    # ------------
    @staticmethod
    def write(scriptcontent, filename=None, foldername=None, overwrite=False):
        &#34;&#34;&#34;
        Writes the provided script content to a specified file in a given folder, with a header if necessary.

        Parameters
        ----------
        scriptcontent : str
            The content to be written to the file.

        filename : str, optional
            The name of the file. If not provided, a random name will be generated.
            The extension `.txt` will be appended if not already present.

        foldername : str, optional
            The folder where the file will be saved. If not provided, the current working directory is used.

        overwrite : bool, optional
            If False (default), raises a `FileExistsError` if the file already exists. If True, the file will be overwritten if it exists.

        Returns
        -------
        str
            The full path to the written file.

        Raises
        ------
        FileExistsError
            If the file already exists and `overwrite` is set to False.

        Notes
        -----
        - A header is prepended to the content if it does not already exist, using the `header` method.
        - The header includes metadata such as the current date, username, hostname, and file details.
        &#34;&#34;&#34;
        # Generate a random name if filename is not provided
        if filename is None:
            filename = autoname(8)  # Generates a random name of 8 letters

        # Ensure the filename ends with &#39;.txt&#39;
        if not filename.endswith(&#39;.txt&#39;):
            filename += &#39;.txt&#39;

        # Handle foldername and relative paths
        if foldername is None or foldername == &#34;&#34;:
            # If foldername is empty or None, use current working directory for relative paths
            if not os.path.isabs(filename):
                filepath = os.path.join(os.getcwd(), filename)
            else:
                filepath = filename  # If filename is absolute, use it directly
        else:
            # If foldername is provided and filename is not absolute, use foldername
            if not os.path.isabs(filename):
                filepath = os.path.join(foldername, filename)
            else:
                filepath = filename

        # Check if file already exists, raise exception if it does and overwrite is False
        if os.path.exists(filepath) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

        # Count total and non-empty lines in the content
        total_lines = len(scriptcontent.splitlines())
        non_empty_lines = sum(1 for line in scriptcontent.splitlines() if line.strip())

        # Prepare header if not already present
        if not scriptcontent.startswith(&#34;# DSCRIPT SAVE FILE&#34;):
            fname = os.path.basename(filepath)  # Extracts the filename (e.g., &#34;myscript.txt&#34;)
            name, _ = os.path.splitext(fname)   # Removes the extension, e.g., &#34;myscript&#34;
            metadata = get_metadata()           # retrieve all metadata (statically)
            header = dscript.header(name=name, verbosity=True,style=1,filepath=filepath,
                    version = metadata[&#34;version&#34;], license = metadata[&#34;license&#34;], email = metadata[&#34;email&#34;])
            # Add line count information to the header
            footer = frame_header(
                lines=[
                    f&#34;Total lines written: {total_lines}&#34;,
                    f&#34;Non-empty lines: {non_empty_lines}&#34;
                ],
                style=1
            )
            scriptcontent = header + &#34;\n&#34; + scriptcontent + &#34;\n&#34; + footer

        # Write the content to the file
        with open(filepath, &#39;w&#39;) as file:
            file.write(scriptcontent)
        return filepath



    # Load Method and its Parsing Rules -- added on 2024-09-04
    # ---------------------------------
    @classmethod
    def load(cls, filename, foldername=None, numerickeys=True, verbose=True, debug=False):
        &#34;&#34;&#34;
        Load a script instance from a text file.

        Parameters
        ----------
        filename : str
            The name of the file to load the script from. If the filename does not end with &#34;.txt&#34;,
            the extension is automatically appended.

        foldername : str, optional
            The directory where the file is located. If not provided, it defaults to the system&#39;s
            temporary directory. If the filename does not include a full path, this folder will be used.

        numerickeys : bool, default=True
            If True, numeric string keys in the template section are automatically converted into integers.
            For example, the key &#34;0&#34; would be converted into the integer 0.

        verbose : bool, default=True
            If `True`, the parser keep comments inside templates and template blocks.

        debug : bool, default=False
            If True, print parsed lines for refining/tracking the parsing of block and single lines

        Returns
        -------
        dscript
            A new `dscript` instance populated with the content of the loaded file.

        Raises
        ------
        ValueError
            If the file does not start with the correct DSCRIPT header or the file format is invalid.

        FileNotFoundError
            If the specified file does not exist.

        Notes
        -----
        - The file is expected to follow the same structured format as the one produced by the `save()` method.
        - The method processes global parameters, definitions, template lines/items, and attributes. If the file
          includes numeric keys as strings (e.g., &#34;0&#34;, &#34;1&#34;), they can be automatically converted into integers
          if `numerickeys=True`.
        - The script structure is dynamically rebuilt, and each section (global parameters, definitions,
          template, and attributes) is correctly parsed and assigned to the corresponding parts of the `dscript`
          instance.
        &#34;&#34;&#34;

        # Step 0 validate filepath
        if not filename.endswith(&#39;.txt&#39;):
            filename += &#39;.txt&#39;

        # Handle foldername and relative paths
        if foldername is None or foldername == &#34;&#34;:
            # If the foldername is empty or None, use current working directory for relative paths
            if not os.path.isabs(filename):
                filepath = os.path.join(os.getcwd(), filename)
            else:
                filepath = filename  # If filename is absolute, use it directly
        else:
            # If foldername is provided and filename is not absolute, use foldername
            if not os.path.isabs(filename):
                filepath = os.path.join(foldername, filename)
            else:
                filepath = filename

        if not os.path.exists(filepath):
            raise FileExistsError(f&#34;The file &#39;{filepath}&#39; does not exist.&#34;)

        # Read the file contents
        with open(filepath, &#39;r&#39;) as f:
            content = f.read()

        # Call parsesyntax to parse the file content
        fname = os.path.basename(filepath)  # Extracts the filename (e.g., &#34;myscript.txt&#34;)
        name, _ = os.path.splitext(fname)   # Removes the extension, e.g., &#34;myscript
        return cls.parsesyntax(content, name=name, numerickeys=numerickeys, verbose=verbose, debug=debug)



    # Load Method and its Parsing Rules -- added on 2024-09-04
    # ---------------------------------
    @classmethod
    def parsesyntax(cls, content, name=None, numerickeys=True, verbose=False, authentification=True,
                    debug=False, comment_chars=&#34;#%&#34;,continuation_marker=&#34;...&#34;):
        &#34;&#34;&#34;
        Parse a DSCRIPT script from a string content.

        Parameters
        ----------
        content : str
            The string content of the DSCRIPT script to be parsed.

        name : str, optional
            The name of the dscript project. If `None`, a random name is generated.

        numerickeys : bool, default=True
            If `True`, numeric string keys in the template section are automatically converted into integers.

        verbose : bool, default=True
            If `True`, the parser keep comments inside templates and template blocks.

        authentification : bool, default=True
            If `True`, the parser is expected that the first non empty line is # DSCRIPT SAVE FILE

        comment_chars : str, optional (default: &#34;#%&#34;)
            A string containing characters to identify the start of a comment.
            Any of these characters will mark the beginning of a comment unless within quotes.

        continuation_marker : str, optional (default: &#34;...&#34;)
            A string containing characters to indicate line continuation
            Any characters after the continuation marker are considered comment and are theorefore ignored

        debug : bool, default=False
            Print parsed lines for refining the parsing of block lines

        Returns
        -------
        dscript
            A new `dscript` instance populated with the content of the loaded file.

        Raises
        ------
        ValueError
            If content does not start with the correct DSCRIPT header or the file format is invalid.

        Notes
        -----
        **DSCRIPT SAVE FILE FORMAT**

        This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
        and control attributes can be defined in a flexible manner.

        **Mandatory First Line:**

        Every DSCRIPT file must begin with the following line:

        ```plaintext
        # DSCRIPT SAVE FILE
        ```

        **Structure Overview:**

        1. **Global Parameters Section (Optional):**

            - This section defines global script settings, enclosed within curly braces `{}`.
            - Properties include:
                - `SECTIONS`: List of section names to be considered (e.g., `[&#34;DYNAMIC&#34;]`).
                - `section`: Current section index (e.g., `0`).
                - `position`: Current script position in the order.
                - `role`: Defines the role of the script instance (e.g., `&#34;dscript instance&#34;`).
                - `description`: A short description of the script (e.g., `&#34;dynamic script&#34;`).
                - `userid`: Identifier for the user (e.g., `&#34;dscript&#34;`).
                - `version`: Script version (e.g., `0.1`).
                - `verbose`: Verbosity flag, typically a boolean (e.g., `False`).

            **Example:**

            ```plaintext
            {
                SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;]  # Global script parameters
            }
            ```

        2. **Definitions Section:**

            - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
            - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
              to delay execution or substitution.

            **Example:**

            ```plaintext
            d = 3                               # Define a number
            periodic = &#34;$p&#34;                     # &#39;$&#39; prevents immediate evaluation of &#39;p&#39;
            units = &#34;$metal&#34;                    # &#39;$&#39; prevents immediate evaluation of &#39;metal&#39;
            dimension = &#34;${d}&#34;                  # Variable substitution
            boundary = [&#39;p&#39;, &#39;p&#39;, &#39;p&#39;]          # List with a mix of variables and values
            atom_style = &#34;$atomic&#34;              # String variable with delayed evaluation
            ```

        3. **Templates Section:**

            - This section provides a mapping between keys and their corresponding commands or instructions.
            - Each template can reference variables defined in the **Definitions** section or elsewhere, typically using the `${variable}` syntax.
            - **Syntax Variations**:

                Templates can be defined in several ways, including without blocks, with single- or multi-line blocks, and with ellipsis (`...`) as a line continuation marker.

                - **Single-line Template Without Block**:
                    ```plaintext
                    KEY: INSTRUCTION
                    ```
                    - `KEY` is the identifier for the template (numeric or alphanumeric).
                    - `INSTRUCTION` is the command or template text, which may reference variables.

                - **Single-line Template With Block**:
                    ```plaintext
                    KEY: [INSTRUCTION]
                    ```
                    - Uses square brackets (`[ ]`) around the `INSTRUCTION`, indicating that all instructions are part of the block.

                - **Multi-line Template With Block**:
                    ```plaintext
                    KEY: [
                        INSTRUCTION1
                        INSTRUCTION2
                        ...
                        ]
                    ```
                    - Begins with `KEY: [` and ends with a standalone `]` on a new line.
                    - Instructions within the block can span multiple lines, and ellipses (`...`) at the end of a line are used to indicate that the line continues, ignoring any content following the ellipsis as comments.
                    - Comments following ellipses are removed after parsing and do not become part of the block, preserving only the instructions.

                - **Multi-line Template With Continuation Marker (Ellipsis)**:
                    - For templates with complex code containing square brackets (`[ ]`), the ellipsis (`...`) can be used to prevent `]` from prematurely closing the block. The ellipsis will keep the line open across multiple lines, allowing brackets in the instructions.

                    **Example:**
                    ```plaintext
                    example1: command ${value}       # Single-line template without block
                    example2: [command ${value}]     # Single-line template with block

                    # Multi-line template with block
                    example3: [
                        command1 ${var1}
                        command2 ${var2} ...   # Line continues after ellipsis
                        command3 ${var3} ...   # Additional instruction continues
                        ]

                    # Multi-line template with ellipsis (handling square brackets)
                    example4: [
                        A[0][1] ...            # Ellipsis allows [ ] within instructions
                        B[2][3] ...            # Another instruction in the block
                        ]
                    ```

            - **Key Points**:
                - **Blocks** allow grouping of multiple instructions for a single key, enclosed in square brackets.
                - **Ellipsis (`...`)** at the end of a line keeps the line open, preventing premature closing by `]`, especially useful if the template code includes square brackets (`[ ]`).
                - **Comments** placed after the ellipsis are removed after parsing and are not part of the final block content.

            This flexibility supports both simple and complex template structures, allowing instructions to be grouped logically while keeping code and comments distinct.


        4. **Attributes Section:**

            - Each template line can have customizable attributes to control behavior and conditions.
            - Default attributes include:
                - `facultative`: If `True`, the line is optional and can be removed if needed.
                - `eval`: If `True`, the line will be evaluated with Python&#39;s `eval()` function.
                - `readonly`: If `True`, the line cannot be modified later in the script.
                - `condition`: An expression that must be satisfied for the line to be included.
                - `condeval`: If `True`, the condition will be evaluated using `eval()`.
                - `detectvar`: If `True`, this creates variables in the **Definitions** section if they do not exist.

            **Example:**

            ```plaintext
            units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
            dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
            ```

        **Note on Multiple Definitions**

        This example demonstrates how variables defined in the **Definitions** section are handled for each template.
        Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
        can use different values for the same variable if redefined.

        **Example:**

        ```plaintext
        # DSCRIPT SAVE FILE

        # Definitions
        var = 10

        # Template key1
        key1: Template content with ${var}

        # Definitions
        var = 20

        # Template key2
        key2: Template content with ${var}

        # Template key3
        key3:[
            this is an undefined variable ${var31}
            this is another undefined variable ${var32}
            this variable is defined  ${var}
        ]
        ```

        **Parsing and Usage:**

        ```python
        # Parse content using parsesyntax()
        ds = dscript.parsesyntax(content)

        # Accessing templates and their variables
        print(ds.TEMPLATE[&#39;key1&#39;].text)  # Output: Template content with 10
        print(ds.TEMPLATE[&#39;key2&#39;].text)  # Output: Template content with 20
        ```

        **Handling Undefined Variables:**

        Variables like `${var31}` and `${var32}` in `key3` are undefined. The parser will handle them based on your substitution logic or raise an error if they are required.

        **Important Notes:**

        - The parser processes the script sequentially. Definitions must appear before the templates that use them.
        - Templates capture the variable definitions at the time they are parsed. Redefining a variable affects only subsequent templates.
        - Comments outside of blocks are allowed and ignored by the parser.
        - Content within templates is treated as-is, allowing for any syntax required by the target system (e.g., LAMMPS commands).


    **Advanced Example**

        Here&#39;s a more advanced example demonstrating the use of global definitions, local definitions, templates, and how to parse and render the template content.

        ```python
        content = &#39;&#39;&#39;
            # GLOBAL DEFINITIONS
            dumpfile = $dump.LAMMPS
            dumpdt = 50
            thermodt = 100
            runtime = 5000

            # LOCAL DEFINITIONS for step &#39;0&#39;
            dimension = 3
            units = $si
            boundary = [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
            atom_style = $smd
            atom_modify = [&#39;map&#39;, &#39;array&#39;]
            comm_modify = [&#39;vel&#39;, &#39;yes&#39;]
            neigh_modify = [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
            newton = $off
            name = $SimulationBox

            # This is a comment line outside of blocks
            # ------------------------------------------

            0: [    % --------------[ Initialization Header (helper) for &#34;${name}&#34; ]--------------
                # set a parameter to None or &#34;&#34; to remove the definition
                dimension    ${dimension}
                units        ${units}
                boundary     ${boundary}
                atom_style   ${atom_style}
                atom_modify  ${atom_modify}
                comm_modify  ${comm_modify}
                neigh_modify ${neigh_modify}
                newton       ${newton}
                # ------------------------------------------
             ]
        &#39;&#39;&#39;
        # Parse the content
        ds = dscript.parsesyntax(content, verbose=True, authentification=False)

        # Access and print the rendered template
        print(&#34;Template 0 content:&#34;)
        print(ds.TEMPLATE[0].do())
        ```

        **Explanation:**

        - **Global Definitions:** Define variables that are accessible throughout the script.
        - **Local Definitions for Step &#39;0&#39;:** Define variables specific to a particular step or template.
        - **Template Block:** Identified by `0: [ ... ]`, it contains the content where variables will be substituted.
        - **Comments:** Lines starting with `#` are comments and are ignored by the parser outside of template blocks.

        **Expected Output:**

        ```
        Template 0 content:
        # --------------[ Initialization Header (helper) for &#34;SimulationBox&#34; ]--------------
        # set a parameter to None or &#34;&#34; to remove the definition
        dimension    3
        units        si
        boundary     [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
        atom_style   smd
        atom_modify  [&#39;map&#39;, &#39;array&#39;]
        comm_modify  [&#39;vel&#39;, &#39;yes&#39;]
        neigh_modify [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
        newton       off
        # ------------------------------------------
        ```

        **Notes:**

        - The `do()` method renders the template, substituting variables with their defined values.
        - Variables like `${dimension}` are replaced with their corresponding values defined in the local or global definitions.
        - The parser handles comments and blank lines appropriately, ensuring they don&#39;t interfere with the parsing logic.


        &#34;&#34;&#34;
        # Split the content into lines
        lines = content.splitlines()
        if not lines:
            raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

        # Initialize containers
        global_params = {}
        GLOBALdefinitions = lambdaScriptdata()
        LOCALdefinitions = lambdaScriptdata()
        template = {}
        attributes = {}

        # State variables
        inside_global_params = False
        global_params_content = &#34;&#34;
        inside_template_block = False
        current_template_key = None
        current_template_content = []
        current_var_value = lambdaScriptdata()

        # Initialize line number
        line_number = 0
        last_successful_line = 0

        # Step 1: Authenticate the file
        if authentification:
            auth_line_found = False
            max_header_lines = 10
            header_end_idx = -1
            for idx, line in enumerate(lines[:max_header_lines]):
                stripped_line = line.strip()
                if not stripped_line:
                    continue
                if stripped_line.startswith(&#34;# DSCRIPT SAVE FILE&#34;):
                    auth_line_found = True
                    header_end_idx = idx
                    break
                elif stripped_line.startswith(&#34;#&#34;) or stripped_line.startswith(&#34;%&#34;):
                    continue
                else:
                    raise ValueError(f&#34;Unexpected content before authentication line (# DSCRIPT SAVE FILE) at line {idx + 1}:\n{line}&#34;)
            if not auth_line_found:
                raise ValueError(&#34;File/Content is not a valid DSCRIPT file.&#34;)

            # Remove header lines
            lines = lines[header_end_idx + 1:]
            line_number = header_end_idx + 1
            last_successful_line = line_number - 1
        else:
            line_number = 0
            last_successful_line = 0

        # Process each line
        for idx, line in enumerate(lines):
            line_number += 1
            line_content = line.rstrip(&#39;\n&#39;)
            if debug: print(f&#34;RAW L{line_number}    :{line_content}\n&#34;)

            # Determine if we&#39;re inside a template block
            if inside_template_block:
                # Extract the code with its eventual continuation_marker
                code_line = remove_comments(
                        line_content,
                        comment_chars=comment_chars,
                        continuation_marker=continuation_marker,
                        remove_continuation_marker=False,
                        ).rstrip()

                # Check if line should continue
                if code_line.endswith(continuation_marker):
                    # Append line up to the continuation marker
                    endofline_index = line_content.rindex(continuation_marker)
                    trimmed_content = line_content[:endofline_index].rstrip()
                    if trimmed_content:
                        current_template_content.append(trimmed_content)
                        if debug:print(f&#34;A|DEBUG L{line_number}:{trimmed_content}\n&#34;)
                    continue
                elif code_line.endswith(&#34;]&#34;):  # End of multi-line block
                    closing_index = code_line.rindex(&#39;]&#39;)
                    trimmed_content = code_line[:closing_index].rstrip()

                    # Append any valid content before `]`, if non-empty
                    if trimmed_content:
                        current_template_content.append(trimmed_content)
                        if debug:print(f&#34;B|DEBUG L{line_number}:{trimmed_content}\n&#34;)

                    # End of template block
                    content = &#39;\n&#39;.join(current_template_content)
                    template[current_template_key] = ScriptTemplate(
                        content=content,
                        autorefresh=False,
                        definitions=LOCALdefinitions,
                        verbose=verbose,
                        userid=current_template_key)
                    # Refresh variables definitions
                    template[current_template_key].refreshvar(globaldefinitions=GLOBALdefinitions)
                    LOCALdefinitions = lambdaScriptdata()
                    # Reset state for next block
                    inside_template_block = False
                    current_template_key = None
                    current_template_content = []
                    last_successful_line = line_number
                    continue
                else:
                    # Append the entire original line content if not ending with `...` or `]`
                    current_template_content.append(line_content)
                    if debug:print(f&#34;C|DEBUG L{line_number}:{line_content}\n&#34;)

                continue

            # Not inside a template block
            stripped_no_comments = remove_comments(line_content)

            # Ignore empty lines after removing comments
            if not stripped_no_comments.strip():
                continue

            # If the original line is a comment line, skip it
            if line_content.strip().startswith(&#34;#&#34;) or line_content.strip().startswith(&#34;%&#34;):
                continue

            stripped = stripped_no_comments.strip()

            # Handle start of a new template block
            template_block_match = re.match(r&#39;^(\w+)\s*:\s*\[&#39;, stripped)
            if template_block_match:
                current_template_key = template_block_match.group(1)
                if inside_template_block:
                    # Collect error context
                    context_start = max(0, last_successful_line - 3)
                    context_end = min(len(lines), line_number + 2)
                    error_context_lines = lines[context_start:context_end]
                    error_context = &#34;&#34;
                    for i, error_line in enumerate(error_context_lines):
                        line_num = context_start + i + 1
                        indicator = &#34;&gt;&#34; if line_num == line_number else &#34;*&#34; if line_num == last_successful_line else &#34; &#34;
                        error_context += f&#34;{indicator} {line_num}: {error_line}\n&#34;

                    raise ValueError(
                        f&#34;Template block &#39;{current_template_key}&#39; starting at line {last_successful_line} (*) was not properly closed before starting a new one at line {line_number} (&gt;).\n\n&#34;
                        f&#34;Error context:\n{error_context}&#34;
                    )
                else:
                    inside_template_block = True
                    idx_open_bracket = line_content.index(&#39;[&#39;)
                    remainder = line_content[idx_open_bracket + 1:].strip()
                    if remainder:
                        remainder_code = remove_comments(remainder, comment_chars=comment_chars).rstrip()
                        if remainder_code.endswith(&#34;]&#34;):
                            closing_index = remainder_code.rindex(&#39;]&#39;)
                            content_line = remainder_code[:closing_index].strip()
                            if content_line:
                                current_template_content.append(content_line)
                                if debug:print(f&#34;D|DEBUG L{line_number}:{content_line}\n&#34;)
                            content = &#39;\n&#39;.join(current_template_content)
                            template[current_template_key] = ScriptTemplate(
                                content=content,
                                autorefresh=False,
                                definitions=LOCALdefinitions,
                                verbose=verbose,
                                userid=current_template_key)
                            template[current_template_key].refreshvar(globaldefinitions=GLOBALdefinitions)
                            LOCALdefinitions = lambdaScriptdata()
                            inside_template_block = False
                            current_template_key = None
                            current_template_content = []
                            last_successful_line = line_number
                            continue
                        else:
                            current_template_content.append(remainder)
                            if debug:print(f&#34;E|DEBUG L{line_number}:{remainder}\n&#34;)
                    last_successful_line = line_number
                continue

            # Handle start of global parameters
            if stripped.startswith(&#39;{&#39;) and not inside_global_params:
                if &#39;}&#39; in stripped:
                    global_params_content = stripped
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;
                    last_successful_line = line_number
                else:
                    inside_global_params = True
                    global_params_content = stripped
                continue

            # Handle global parameters inside {...}
            if inside_global_params:
                global_params_content += &#39; &#39; + stripped
                if &#39;}&#39; in stripped:
                    inside_global_params = False
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;
                    last_successful_line = line_number
                continue

            # Handle attributes
            attribute_match = re.match(r&#39;^(\w+)\s*:\s*\{(.+)\}&#39;, stripped)
            if attribute_match:
                key, attr_content = attribute_match.groups()
                attributes[key] = {}
                cls._parse_attributes(attributes[key], attr_content.strip())
                last_successful_line = line_number
                continue

            # Handle definitions
            definition_match = re.match(r&#39;^(\w+)\s*=\s*(.+)&#39;, stripped)
            if definition_match:
                key, value = definition_match.groups()
                convertedvalue = cls._convert_value(value)
                if key in GLOBALdefinitions:
                    if (GLOBALdefinitions.getattr(key) != convertedvalue) or \
                        (getattr(current_var_value, key) != convertedvalue):
                        LOCALdefinitions.setattr(key, convertedvalue)
                else:
                    GLOBALdefinitions.setattr(key, convertedvalue)
                last_successful_line = line_number
                setattr(current_var_value, key, convertedvalue)
                continue

            # Handle single-line templates (updated on 20250104 to handle empty content)
            template_match = re.match(r&#39;^(\w+)\s*:\s*(.*)&#39;, stripped)
            if template_match:
                key, content = template_match.groups()
                content = content.strip()  # Strip whitespace for consistency
                if not content:
                    content = f&#34;# empty &lt;step {key}&gt;&#34;
                    if debug: print(f&#34;F|DEBUG L{line_number}:Empty content detected for key: {key}, default value assigned\n&#34;)
                if debug: print(f&#34;F|DEBUG L{line_number}:{content}\n&#34;)
                template[key] = ScriptTemplate(
                    content = content,
                    autorefresh = False,
                    definitions=LOCALdefinitions,
                    verbose=verbose,
                    userid=key)
                template[key].refreshvar(globaldefinitions=GLOBALdefinitions)
                if debug:print(f&#34;G|DEBUG L{line_number}:{template[key].content}\n&#34;)
                LOCALdefinitions = lambdaScriptdata()
                last_successful_line = line_number
                continue

            # Unrecognized line
            if verbose:
                print(f&#34;Warning: Unrecognized line at {line_number}: {line_content}&#34;)
                if debug:
                    raise ValueError(f&#39;ERROR: stripped content &#34;{stripped}&#34;&#39;)
            last_successful_line = line_number
            continue

        # At the end, check if any template block was left unclosed
        if inside_template_block:
            # Collect error context
            context_start = max(0, last_successful_line - 3)
            context_end = min(len(lines), last_successful_line + 3)
            error_context_lines = lines[context_start:context_end]
            error_context = &#34;&#34;
            for i, error_line in enumerate(error_context_lines):
                line_num = context_start + i
                indicator = &#34;&gt;&#34; if line_num == last_successful_line else &#34; &#34;
                error_context += f&#34;{indicator} {line_num}: {error_line}\n&#34;

            raise ValueError(
                f&#34;Template block &#39;{current_template_key}&#39; starting at line {last_successful_line} was not properly closed.\n\n&#34;
                f&#34;Error context:\n{error_context}&#34;
            )

        # Apply attributes to templates
        for key in attributes:
            if key in template:
                for attr_name, attr_value in attributes[key].items():
                    setattr(template[key], attr_name, attr_value)
                template[key]._autorefresh = True # restore the default behavior for the end-user
            else:
                raise ValueError(f&#34;Attributes found for undefined template key: {key}&#34;)

        # Create and return new instance
        if name is None:
            name = autoname(8)
        instance = cls(
            name=name,
            SECTIONS=global_params.get(&#39;SECTIONS&#39;, [&#39;DYNAMIC&#39;]),
            section=global_params.get(&#39;section&#39;, 0),
            position=global_params.get(&#39;position&#39;, 0),
            role=global_params.get(&#39;role&#39;, &#39;dscript instance&#39;),
            description=global_params.get(&#39;description&#39;, &#39;dynamic script&#39;),
            userid=global_params.get(&#39;userid&#39;, &#39;dscript&#39;),
            version=global_params.get(&#39;version&#39;, 0.1),
            verbose=global_params.get(&#39;verbose&#39;, False)
        )

        # Convert numeric string keys to integers if numerickeys is True
        if numerickeys:
            numeric_template = {}
            for key, value in template.items():
                if key.isdigit():
                    numeric_template[int(key)] = value
                else:
                    numeric_template[key] = value
            template = numeric_template

        # Set definitions and template
        instance.DEFINITIONS = GLOBALdefinitions
        instance.TEMPLATE = template

        # Refresh variables
        instance.set_all_variables()

        # Check variables
        instance.check_all_variables(verbose=False)

        return instance




    @classmethod
    def parsesyntax_legacy(cls, content, name=None, numerickeys=True):
        &#34;&#34;&#34;
        Parse a script from a string content.
        [ ------------------------------------------------------]
        [ Legacy parsesyntax method for backward compatibility. ]
        [ ------------------------------------------------------]

        Parameters
        ----------
        content : str
            The string content of the script to be parsed.

        name : str
            The name of the dscript project (if None, it is set randomly)

        numerickeys : bool, default=True
            If True, numeric string keys in the template section are automatically converted into integers.

        Returns
        -------
        dscript
            A new `dscript` instance populated with the content of the loaded file.

        Raises
        ------
        ValueError
            If content does not start with the correct DSCRIPT header or the file format is invalid.

        Notes
        -----
        - The file is expected to follow the same structured format as the one produced by the `save()` method.
        - The method processes global parameters, definitions, template lines/items, and attributes. If the file
          includes numeric keys as strings (e.g., &#34;0&#34;, &#34;1&#34;), they can be automatically converted into integers
          if `numerickeys=True`.
        - The script structure is dynamically rebuilt, and each section (global parameters, definitions,
          template, and attributes) is correctly parsed and assigned to the corresponding parts of the `dscript`
          instance.


        PIZZA.DSCRIPT SAVE FILE FORMAT
        -------------------------------
        This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
        and control attributes can be defined in a flexible manner.

        ### Mandatory First Line:
        Every DSCRIPT file must begin with the following line:
            # DSCRIPT SAVE FILE

        ### Structure Overview:

        1. **Global Parameters Section (Optional):**
            - This section defines global script settings, enclosed within curly braces `{ }`.
            - Properties include:
                - `SECTIONS`: List of section names to be considered (e.g., `[&#34;DYNAMIC&#34;]`).
                - `section`: Current section index (e.g., `0`).
                - `position`: Current script position in the order.
                - `role`: Defines the role of the script instance (e.g., `&#34;dscript instance&#34;`).
                - `description`: A short description of the script (e.g., `&#34;dynamic script&#34;`).
                - `userid`: Identifier for the user (e.g., `&#34;dscript&#34;`).
                - `version`: Script version (e.g., `0.1`).
                - `verbose`: Verbosity flag, typically a boolean (e.g., `False`).

            Example:
            ```
            {
                SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;]  # Global script parameters
            }
            ```

        2. **Definitions Section:**
            - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
            - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
              to delay execution or substitution.

            Example:
            ```
            d = 3                               # Define a number
            periodic = &#34;$p&#34;                     # &#39;$&#39; prevents immediate evaluation of &#39;p&#39;
            units = &#34;$metal&#34;                    # &#39;$&#39; prevents immediate evaluation of &#39;metal&#39;
            dimension = &#34;${d}&#34;                  # Variable substitution
            boundary = [&#39;p&#39;, &#39;p&#39;, &#39;p&#39;]  # List with a mix of variables and values
            atom_style = &#34;$atomic&#34;              # String variable with delayed evaluation
            ```

        3. **Templates Section:**
            - This section provides a mapping between keys and their corresponding commands or instructions.
            - The templates reference variables defined in the **Definitions** section or elsewhere.
            - Syntax:
                ```
                KEY: INSTRUCTION
                ```
                where:
                - `KEY` can be numeric or alphanumeric.
                - `INSTRUCTION` represents a command template, often referring to variables using `${variable}` notation.

            Example:
            ```
            units: units ${units}               # Template uses the &#39;units&#39; variable
            dim: dimension ${dimension}         # Template for setting the dimension
            bound: boundary ${boundary}         # Template for boundary settings
            lattice: lattice ${lattice}         # Lattice template
            ```

        4. **Attributes Section:**
            - Each template line can have customizable attributes to control behavior and conditions.
            - Default attributes include:
                - `facultative`: If `True`, the line is optional and can be removed if needed.
                - `eval`: If `True`, the line will be evaluated with Python&#39;s `eval()` function.
                - `readonly`: If `True`, the line cannot be modified later in the script.
                - `condition`: An expression that must be satisfied for the line to be included.
                - `condeval`: If `True`, the condition will be evaluated using `eval()`.
                - `detectvar`: If `True`, this creates variables in the **Definitions** section if they do not exist.

            Example:
            ```
            units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
            dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
            ```

        Note on multiple definitions
        -----------------------------
        This example demonstrates how variables defined in the `Definitions` section are handled for each template.
        Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
        can use different values for the same variable if redefined.

        content = &#34;&#34; &#34;
        # DSCRIPT SAVE FILE

        # Definitions
        var = 10

        # Template ky1
        key1: Template content with ${var}

        # Definitions
        var = 20

        # Template key2
        key2: Template content with ${var}

        # Template key3
        key3:[
            this is an underfined variable ${var31}
            this is an another underfined variable ${var32}
            this variables is defined  ${var}
            ]

        &#34;&#34; &#34;

        # Parse content using parsesyntax()
        ds = dscript.parsesyntax(content)

        # Key1 should use the first definition of &#39;var&#39; (10)
        print(ds.key1.definitions.var)  # Output: Template content with 10

        # Key2 should use the updated definition of &#39;var&#39; (20)
        print(ds.key2.definitions.var)  # Output: Template content with 10


        &#34;&#34;&#34;

        # Split the content into lines
        lines = content.splitlines()
        lines = [line for line in lines if line.strip()]  # Remove blank or empty lines
        # Raise an error if no content is left after removing blank lines
        if not lines:
            raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

        # Initialize containers for global parameters, definitions, templates, and attributes
        global_params = {}
        definitions = lambdaScriptdata()
        template = {}
        attributes = {}

        # State variables to handle multi-line global parameters and attributes
        inside_global_params = False
        inside_attributes = False
        current_attr_key = None  # Ensure this is properly initialized
        global_params_content = &#34;&#34;
        inside_template_block = False  # Track if we are inside a multi-line template
        current_template_key = None    # Track the current template key
        current_template_content = []  # Store lines for the current template content

        # Step 1: Authenticate the file
        if not lines[0].strip().startswith(&#34;# DSCRIPT SAVE FILE&#34;):
            raise ValueError(&#34;File/Content is not a valid DSCRIPT file.&#34;)

        # Step 2: Process each line dynamically
        for line in lines[1:]:
            stripped = line.strip()

            # Ignore empty lines and comments
            if not stripped or stripped.startswith(&#34;#&#34;):
                continue

            # Remove trailing comments
            stripped = remove_comments(stripped)

            # Step 3: Handle global parameters inside {...}
            if stripped.startswith(&#34;{&#34;):
                # Found the opening {, start accumulating global parameters
                inside_global_params = True
                # Remove the opening { and accumulate the remaining content
                global_params_content = stripped[stripped.index(&#39;{&#39;) + 1:].strip()

                # Check if the closing } is also on the same line
                if &#39;}&#39; in global_params_content:
                    global_params_content = global_params_content[:global_params_content.index(&#39;}&#39;)].strip()
                    inside_global_params = False  # We found the closing } on the same line
                    # Now parse the global parameters block
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;  # Reset for the next block
                continue

            if inside_global_params:
                # Accumulate content until the closing } is found
                if stripped.endswith(&#34;}&#34;):
                    # Found the closing }, accumulate and process the entire block
                    global_params_content += &#34; &#34; + stripped[:stripped.index(&#39;}&#39;)].strip()
                    inside_global_params = False  # Finished reading global parameters block

                    # Now parse the entire global parameters block
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;  # Reset for the next block if necessary
                else:
                    # Continue accumulating if } is not found
                    global_params_content += &#34; &#34; + stripped
                continue

            # Step 4: Detect the start of a multi-line template block inside [...]
            if not inside_template_block:
                template_match = re.match(r&#39;(\w+)\s*:\s*\[&#39;, stripped)
                if template_match:
                    current_template_key = template_match.group(1)  # Capture the key
                    inside_template_block = True
                    current_template_content = []  # Reset content list
                    continue

            # If inside a template block, accumulate lines until we find the closing ]
            if inside_template_block:
                if stripped == &#34;]&#34;:
                    # End of the template block, join the content and store it
                    template[current_template_key] = ScriptTemplate(
                        current_template_content,
                        definitions=lambdaScriptdata(**definitions),  # Clone current global definitions
                        verbose=True,
                        userid=current_template_key
                        )
                    template[current_template_key].refreshvar()
                    inside_template_block = False
                    current_template_key = None
                    current_template_content = []
                else:
                    # Accumulate the current line (without surrounding spaces)
                    current_template_content.append(stripped)
                continue

            # Step 5: Handle attributes inside {...}
            if inside_attributes and stripped.endswith(&#34;}&#34;):
                # Finish processing attributes for the current key
                cls._parse_attributes(attributes[current_attr_key], stripped[:-1])  # Remove trailing }
                inside_attributes = False
                current_attr_key = None
                continue

            if inside_attributes:
                # Continue accumulating attributes
                cls._parse_attributes(attributes[current_attr_key], stripped)
                continue

            # Step 6: Determine if the line is a definition, template, or attribute
            definition_match = re.match(r&#39;(\w+)\s*=\s*(.+)&#39;, stripped)
            template_match = re.match(r&#39;(\w+)\s*:\s*(?!\s*\{.*\}\s*$)(.+)&#39;, stripped) # template_match = re.match(r&#39;(\w+)\s*:\s*(?!\{)(.+)&#39;, stripped)
            attribute_match = re.match(r&#39;(\w+)\s*:\s*\{\s*(.+)\s*\}&#39;, stripped)       # attribute_match = re.match(r&#39;(\w+)\s*:\s*\{(.+)\}&#39;, stripped)

            if definition_match:
                # Line is a definition (key=value)
                key, value = definition_match.groups()
                definitions.setattr(key,cls._convert_value(value))

            elif template_match and not inside_template_block:
                # Line is a template (key: content)
                key, content = template_match.groups()
                template[key] = ScriptTemplate(
                    content,
                    definitions=lambdaScriptdata(**definitions),  # Clone current definitions
                    verbose=True,
                    userid=current_template_key)
                template[key].refreshvar()

            elif attribute_match:
                # Line is an attribute (key:{attributes...})
                current_attr_key, attr_content = attribute_match.groups()
                attributes[current_attr_key] = {}
                cls._parse_attributes(attributes[current_attr_key], attr_content)
                inside_attributes = not stripped.endswith(&#34;}&#34;)

        # Step 7: Validation and Reconstruction
        # Make sure there are no attributes without a template entry
        for key in attributes:
            if key not in template:
                raise ValueError(f&#34;Attributes found for undefined template key: {key}&#34;)
            # Apply attributes to the corresponding template object
            for attr_name, attr_value in attributes[key].items():
                setattr(template[key], attr_name, attr_value)

        # Step 7: Create and return a new dscript instance
        if name is None:
            name = autoname(8)
        instance = cls(
            name = name,
            SECTIONS=global_params.get(&#39;SECTIONS&#39;, [&#39;DYNAMIC&#39;]),
            section=global_params.get(&#39;section&#39;, 0),
            position=global_params.get(&#39;position&#39;, 0),
            role=global_params.get(&#39;role&#39;, &#39;dscript instance&#39;),
            description=global_params.get(&#39;description&#39;, &#39;dynamic script&#39;),
            userid=global_params.get(&#39;userid&#39;, &#39;dscript&#39;),
            version=global_params.get(&#39;version&#39;, 0.1),
            verbose=global_params.get(&#39;verbose&#39;, False)
        )


        # Convert numeric string keys to integers if numerickeys is True
        if numerickeys:
            numeric_template = {}
            for key, value in template.items():
                # Check if the key is a numeric string
                if key.isdigit():
                    numeric_template[int(key)] = value
                else:
                    numeric_template[key] = value
            template = numeric_template

        # Set definitions and template
        instance.DEFINITIONS = definitions
        instance.TEMPLATE = template

        # Refresh variables (ensure that variables are detected and added to definitions)
        instance.set_all_variables()

        # Check eval
        instance.check_all_variables(verbose=False)

        # return the new instance
        return instance


    @classmethod
    def _parse_global_params(cls, content, global_params):
        &#34;&#34;&#34;
        Parses global parameters from the accumulated content enclosed in `{}`.

        ### Parameters:
            content (str): The content string containing global parameters.
            global_params (dict): A dictionary to populate with parsed parameters.

        ### Raises:
            ValueError: If invalid lines or key-value pairs are encountered.
        &#34;&#34;&#34;
        # Remove braces from the content
        content = content.strip().strip(&#34;{}&#34;)

        # Split the content into lines by commas
        lines = re.split(r&#39;,(?![^(){}\[\]]*[\)\}\]])&#39;, content.strip())

        for line in lines:
            line = line.strip()
            # Match key-value pairs
            match = re.match(r&#39;([\w_]+)\s*=\s*(.+)&#39;, line)
            if match:
                key, value = match.groups()
                key = key.strip()
                value = value.strip()
                # Convert the value to the appropriate Python type and store it
                global_params[key] = cls._convert_value(value)
            else:
                raise ValueError(f&#34;Invalid parameter line: &#39;{line}&#39;&#34;)


    @classmethod
    def _parse_attributes(cls, attr_dict, content):
        &#34;&#34;&#34;Parses attributes from the content inside {attribute=value,...}.&#34;&#34;&#34;
        attr_pairs = re.findall(r&#39;(\w+)\s*=\s*([^,]+)&#39;, content)
        for attr_name, attr_value in attr_pairs:
            attr_dict[attr_name] = cls._convert_value(attr_value)

    @classmethod
    def _convert_value(cls, value):
        &#34;&#34;&#34;Converts a string representation of a value to the appropriate Python type.&#34;&#34;&#34;
        value = value.strip()
        # Boolean and None conversion
        if value.lower() == &#39;true&#39;:
            return True
        elif value.lower() == &#39;false&#39;:
            return False
        elif value.lower() == &#39;none&#39;:
            return None
        # Handle quoted strings
        if (value.startswith(&#39;&#34;&#39;) and value.endswith(&#39;&#34;&#39;)) or (value.startswith(&#34;&#39;&#34;) and value.endswith(&#34;&#39;&#34;)):
            return value[1:-1]
        # Handle lists (Python syntax inside the file)
        if value.startswith(&#39;[&#39;) and value.endswith(&#39;]&#39;):
            return eval(value)  # Using eval to parse lists safely in this controlled scenario
        # Handle numbers
        try:
            if &#39;.&#39; in value:
                return float(value)
            return int(value)
        except ValueError:
            # Return the value as-is if it doesn&#39;t match other types
            return value

    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, copy.deepcopy(v, memo))
        return copie

    def detect_all_variables(self):
        &#34;&#34;&#34;
        Detects all variables across all templates in the dscript object.

        This method iterates through all ScriptTemplate objects in the dscript and
        collects variables from each template using the detect_variables method.

        Returns:
        --------
        list
            A sorted list of unique variables detected in all templates.
        &#34;&#34;&#34;
        all_variables = set()  # Use a set to avoid duplicates
        # Iterate through all templates in the dscript object
        for template_key, template in self.TEMPLATE.items():
            # Ensure the template is a ScriptTemplate and has the detect_variables method
            if isinstance(template, ScriptTemplate):
                detected_vars = template.detect_variables()
                all_variables.update(detected_vars)  # Add the detected variables to the set
        return sorted(all_variables)  # Return a sorted list of unique variables



    def add_dynamic_script(self, key, content=&#34;&#34;, userid=None, definitions=None, verbose=None, autorefresh=True, **USER):
        &#34;&#34;&#34;
        Add a dynamic script step to the dscript object.

        Parameters:
        -----------
        key : str
            The key for the dynamic script (usually an index or step identifier).
        content : str or list of str, optional
            The content (template) of the script step.
        definitions : lambdaScriptdata, optional
            The merged variable space (STATIC + GLOBAL + LOCAL).
        verbose : bool, optional
            If None, self.verbose will be used. Controls verbosity of the template.
        autorefresh : bool, optional
            If True, detected variables (e.g., var) and undefined are assiged to their default value (e.g., ${var})
            Default = True
        USER : dict
            Additional user variables that override the definitions for this step.
        &#34;&#34;&#34;
        if definitions is None:
            definitions = lambdaScriptdata()
        if verbose is None:
            verbose = self.verbose
        # Create a new ScriptTemplate and add it to the TEMPLATE
        self.TEMPLATE[key] = ScriptTemplate(
            content=content,
            definitions=self.DEFINITIONS+definitions,
            verbose=verbose,
            userid = key if userid is None else userid,
            autorefresh=autorefresh,
            **USER
        )



    def check_all_variables(self, verbose=True, seteval=True, output=False):
        &#34;&#34;&#34;
        Checks for undefined variables for each TEMPLATE key in the dscript object.

        Parameters:
        -----------
        verbose : bool, optional, default=True
            If True, prints information about variables for each TEMPLATE key.
            Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.

        seteval : bool, optional, default=True
            If True, sets the `eval` attribute to True if at least one variable is defined or set to its default value.

        output : bool, optional, default=False
            If True, returns a dictionary with lists of default variables, set variables, and undefined variables.

        Returns:
        --------
        out : dict, optional
            If `output=True`, returns a dictionary with the following structure:
            - &#34;defaultvalues&#34;: List of variables set to their default value (${varname}).
            - &#34;setvalues&#34;: List of variables defined with values other than their default.
            - &#34;undefined&#34;: List of variables that are undefined.
        &#34;&#34;&#34;
        out = {&#34;defaultvalues&#34;: [], &#34;setvalues&#34;: [], &#34;undefined&#34;: []}

        for key in self.TEMPLATE:
            template = self.TEMPLATE[key]
            # Call the check_variables method of ScriptTemplate for each TEMPLATE key
            result = template.check_variables(verbose=verbose, seteval=seteval)

            # Update the output dictionary if needed
            out[&#34;defaultvalues&#34;].extend(result[&#34;defaultvalues&#34;])
            out[&#34;setvalues&#34;].extend(result[&#34;setvalues&#34;])
            out[&#34;undefined&#34;].extend(result[&#34;undefined&#34;])

        if output:
            return out


    def set_all_variables(self):
        &#34;&#34;&#34;
        Ensures that all variables in the templates are added to the global definitions
        with default values if they are not already defined.
        &#34;&#34;&#34;
        for key, script_template in self.TEMPLATE.items():
            # Check and update the global definitions with template-specific variables
            for var in script_template.detect_variables():
                if var not in self.DEFINITIONS:
                    # Add undefined variables with their default value
                    self.DEFINITIONS.setattr(var, f&#34;${{{var}}}&#34;)  # Set default as ${varname}




    def search(self, primary_key, value, foreign_key, include_global=True, multiple=&#39;all&#39;, protection=False, verbose=False):
        &#34;&#34;&#34;
        Search for foreign/definition key values associated with given primary key/definition value(s).

        This method searches through the global definitions first and then traverses local steps in sequential order
        to find matches for the specified primary key and retrieves the corresponding foreign key values.
        It also identifies available foreign keys in steps where the primary key exists but the desired foreign key is missing.

        Parameters:
            primary_key (str):
                The primary key to search for in the definitions.
            value (str, int, float, or list of these types):
                The value(s) associated with the primary key.
            foreign_key (str):
                The foreign key whose value is to be retrieved.
            include_global (bool, optional):
                If True, include global definitions in the search.
                Defaults to True.
            multiple (str, optional):
                Strategy for handling multiple matches. Options are:
                - &#39;first&#39;: Return the first match found.
                - &#39;last&#39;: Return the last match found.
                - &#39;all&#39;: Return all matches in a list.
                Defaults to &#39;all&#39;.
            protection (bool, optional):
                If False (default), removes the &#39;$&#39; prefix from the keys in the returned dictionary.
                If True, retains the &#39;$&#39; prefix.
                Defaults to False.
            verbose (bool, optional):
                If True, prints warnings about missing foreign keys and available alternative keys.
                Defaults to False.

        Returns:
            dict or scalar or None:
                - If multiple values are provided, returns a dictionary mapping each value to its foreign key value(s).
                - If a single value is provided:
                    - Returns a single foreign key value if &#39;multiple&#39; is &#39;first&#39; or &#39;last&#39;.
                    - Returns a list of all matching foreign key values if &#39;multiple&#39; is &#39;all&#39;.
                - Returns None if no matches are found.

        Raises:
            TypeError:
                If the provided value is not of type str, int, or float, or if value list contains invalid types.
            ValueError:
                If an invalid option is provided for &#39;multiple&#39;.
        &#34;&#34;&#34;
        # Validate &#39;multiple&#39; parameter
        if multiple not in {&#39;first&#39;, &#39;last&#39;, &#39;all&#39;}:
            raise ValueError(&#34;Parameter &#39;multiple&#39; must be one of &#39;first&#39;, &#39;last&#39;, or &#39;all&#39;.&#34;)

        # Normalize &#39;value&#39; to a list for uniform processing
        if isinstance(value, (str, int, float)):
            values = [value]
            single_value = True
        elif isinstance(value, list):
            if not all(isinstance(v, (str, int, float)) for v in value):
                raise TypeError(&#34;All elements in &#39;value&#39; list must be of type str, int, or float.&#34;)
            values = value
            single_value = False
        else:
            raise TypeError(f&#34;&#39;value&#39; must be of type str, int, float, or list of these types, got {type(value).__name__}&#34;)

        # Initialize the result containers
        matched_foreign_keys = {}  # key: value, value: single or list of foreign_key values
        available_foreign_keys_set = set()  # set of foreign keys available where primary exists but desired foreign_key missing

        # Keys to exclude when listing available foreign keys
        excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

        # Function to add a match to the results based on the &#39;multiple&#39; strategy
        def add_match(val, rvalue):
            if multiple == &#39;all&#39;:
                if val in matched_foreign_keys:
                    if isinstance(matched_foreign_keys[val], list):
                        matched_foreign_keys[val].append(rvalue)
                    else:
                        matched_foreign_keys[val] = [matched_foreign_keys[val], rvalue]
                else:
                    matched_foreign_keys[val] = [rvalue]
            elif multiple == &#39;first&#39;:
                if val not in matched_foreign_keys:
                    matched_foreign_keys[val] = rvalue
            elif multiple == &#39;last&#39;:
                matched_foreign_keys[val] = rvalue

        # Start with global definitions if included
        if include_global:
            global_definitions = self.DEFINITIONS
            if hasattr(global_definitions, primary_key):
                primary_value = getattr(global_definitions, primary_key)

                # Handle multiple primary key values within the global definitions
                if isinstance(primary_value, (list, tuple, set)):
                    primary_values = primary_value
                else:
                    primary_values = [primary_value]

                for pv in primary_values:
                    for val in values:
                        if pv == val:
                            # Check if the foreign key exists in global definitions
                            if hasattr(global_definitions, foreign_key):
                                rvalue = getattr(global_definitions, foreign_key)
                                add_match(val, rvalue)
                            else:
                                # Collect available foreign keys in global definitions, excluding specified keys
                                available_keys = [
                                    k for k in global_definitions.__dict__
                                    if k != primary_key and k not in excluded_keys
                                ]
                                available_foreign_keys_set.update(available_keys)

        # Then, traverse through local steps in sequential order
        for istep in range(len(self)):
            step_definitions = self[istep].definitions

            # Check if the primary key exists in the local definitions
            if hasattr(step_definitions, primary_key):
                primary_value = getattr(step_definitions, primary_key)

                # Handle multiple primary key values within the definition
                if isinstance(primary_value, (list, tuple, set)):
                    primary_values = primary_value
                else:
                    primary_values = [primary_value]

                for pv in primary_values:
                    for val in values:
                        if pv == val:
                            # Check if the foreign key exists
                            if hasattr(step_definitions, foreign_key):
                                rvalue = getattr(step_definitions, foreign_key)
                                add_match(val, rvalue)
                            else:
                                # Collect available foreign keys in this step, excluding specified keys
                                available_keys = [
                                    k for k in step_definitions.__dict__
                                    if k != primary_key and k not in excluded_keys
                                ]
                                available_foreign_keys_set.update(available_keys)

        # Process the matched_foreign_keys based on &#39;multiple&#39; strategy
        if single_value:
            if values[0] in matched_foreign_keys:
                if multiple == &#39;all&#39;:
                    # If only one match, return scalar; else, list
                    matches = matched_foreign_keys[values[0]]
                    if len(matches) == 1:
                        matches = matches[0]
                else:
                    matches = matched_foreign_keys[values[0]]
            else:
                matches = None
        else:
            matches = {}
            for val in values:
                if val in matched_foreign_keys:
                    if multiple == &#39;all&#39;:
                        if len(matched_foreign_keys[val]) == 1:
                            matches[val] = matched_foreign_keys[val][0]
                        else:
                            matches[val] = matched_foreign_keys[val]
                    else:
                        matches[val] = matched_foreign_keys[val]
                else:
                    matches[val] = None  # Or handle differently if needed

        # If there are available foreign keys, report them as an error message
        if available_foreign_keys_set and verbose:
            available_keys_sorted = sorted(list(available_foreign_keys_set))
            print(f&#34;Warning: In some steps, the foreign key &#39;{foreign_key}&#39; is missing where the primary key &#39;{primary_key}&#39; exists.&#34;)
            print(f&#34;Available foreign keys in those steps: {available_keys_sorted}&#34;)

        # If no matches found, print a message
        if (single_value and matches is None) or (not single_value and all(v is None for v in matches.values())):
            if verbose:
                print(f&#34;No matches found for primary key &#39;{primary_key}&#39; with value(s) &#39;{value}&#39;.&#34;)
            return None

        # Handle protection flag: remove &#39;$&#39; prefix from keys if protection=False
        if not single_value and isinstance(matches, dict):
            processed_matches = {}
            for k, v in matches.items():
                if not protection and isinstance(k, str):
                    # Remove any leading &#39;$&#39; and surrounding spaces
                    new_key = k.lstrip(&#39;$&#39;).strip()
                else:
                    new_key = k
                processed_matches[new_key] = v
            return processed_matches
        else:
            # For single value searches, return matches as-is
            return matches




    def list_values(self, key, include_global=True, verbose=False, order=&#39;stable&#39;, details=False):
        &#34;&#34;&#34;
        List all unique values taken by a specified key across global definitions and all steps in sequential order.

        Parameters:
            key (str): The key whose values are to be listed.
            include_global (bool, optional): If True, include global definitions in the search. Defaults to True.
            verbose (bool, optional): If True, print warnings about steps where the key is missing and list available keys. Defaults to False.
            order (str, optional): The order in which to list the unique values. Options are &#39;stable&#39;, &#39;ascend&#39;, &#39;descend&#39;. Defaults to &#39;stable&#39;.
            details (bool, optional): If True, return a VariableOccurrences object containing detailed occurrence information. If False, return a list or scalar as before. Defaults to False.

        Returns:
            list or scalar or VariableOccurrences or None:
                - If `details=False`:
                    - Returns a list of unique values associated with the key, ordered as specified.
                    - If only one unique value exists, returns it as a scalar.
                    - Returns None if the key is not found in any global or step definitions.
                - If `details=True`:
                    - Returns a VariableOccurrences object containing detailed occurrence information across scopes.
        &#34;&#34;&#34;
        # Validate &#39;order&#39; parameter
        if order not in {&#39;stable&#39;, &#39;ascend&#39;, &#39;descend&#39;}:
            raise ValueError(&#34;Parameter &#39;order&#39; must be one of &#39;stable&#39;, &#39;ascend&#39;, or &#39;descend&#39;.&#34;)

        excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

        unique_values = []
        seen_values = set()

        available_keys_set = set()

        # Helper function to compare lists
        def lists_are_equal(list1, list2):
            return list1 == list2

        # Function to add a key_value to unique_values
        def add_value(kv):
            if isinstance(kv, list):
                # Convert list to tuple for hashability
                try:
                    kv_tuple = tuple(kv)
                    if kv_tuple not in seen_values:
                        unique_values.append(kv.copy())  # Append a copy to preserve the list
                        seen_values.add(kv_tuple)
                except TypeError:
                    # If list contains unhashable items, compare manually
                    if not any(lists_are_equal(kv, existing) for existing in unique_values if isinstance(existing, list)):
                        unique_values.append(kv.copy())
            else:
                if kv not in seen_values:
                    unique_values.append(kv)
                    seen_values.add(kv)

        # Data structures for detailed occurrences
        occurrences_data = defaultdict(list)  # {&#39;global&#39;: [value], &#39;local&#39;: [(step, value), ...]}

        # Include global definitions
        if include_global and hasattr(self.DEFINITIONS, key):
            key_value = getattr(self.DEFINITIONS, key)
            if isinstance(key_value, list):
                add_value(key_value)
                if details:
                    occurrences_data[&#39;global&#39;] = key_value.copy()
            else:
                add_value(key_value)
                if details:
                    occurrences_data[&#39;global&#39;] = key_value
        elif include_global and verbose:
            # Collect available keys in global definitions, excluding specified keys
            available_keys = [
                k for k in self.DEFINITIONS.__dict__
                if k != key and k not in excluded_keys
            ]
            available_keys_set.update(available_keys)

        # Traverse through steps
        for step_key, step in self.TEMPLATE.items():
            if hasattr(step.definitions, key):
                key_value = getattr(step.definitions, key)
                if isinstance(key_value, list):
                    add_value(key_value)
                    if details:
                        occurrences_data[&#39;local&#39;].append((step_key, key_value.copy()))
                else:
                    add_value(key_value)
                    if details:
                        occurrences_data[&#39;local&#39;].append((step_key, key_value))
            else:
                if verbose:
                    # Collect available keys in this step, excluding specified keys
                    available_keys = [
                        k for k in step.definitions.__dict__
                        if k != key and k not in excluded_keys
                    ]
                    available_keys_set.update(available_keys)

        # Verbose warnings
        if verbose and available_keys_set:
            available_keys_sorted = sorted(list(available_keys_set))
            print(f&#34;Warning: The key &#39;{key}&#39; is missing in some steps or global definitions.&#34;)
            print(f&#34;Available keys in those contexts: {available_keys_sorted}&#34;)

        # Ordering
        if order == &#39;stable&#39;:
            ordered_values = unique_values
        else:
            # To sort, ensure all elements are of the same type
            try:
                if all(isinstance(v, list) for v in unique_values):
                    if order == &#39;ascend&#39;:
                        ordered_values = sorted(unique_values)
                    else:
                        ordered_values = sorted(unique_values, reverse=True)
                elif all(isinstance(v, type(unique_values[0])) for v in unique_values):
                    if order == &#39;ascend&#39;:
                        ordered_values = sorted(unique_values)
                    else:
                        ordered_values = sorted(unique_values, reverse=True)
                else:
                    raise TypeError
            except TypeError:
                if verbose:
                    print(&#34;Warning: Cannot sort values due to mixed or non-comparable types. Returning values in their original order.&#34;)
                ordered_values = unique_values

        if details:
            # Prepare data for VariableOccurrences
            # Convert defaultdict to regular dict
            occurrences_dict = dict(occurrences_data)

            if key.lower() == &#34;all&#34;:
                # Collect all keys and their occurrences
                all_keys = set()
                # Include global definitions if specified
                if include_global:
                    global_keys = set(self.DEFINITIONS.__dict__.keys()) - excluded_keys
                    all_keys.update(global_keys)
                # Include keys from all steps
                for step in self.TEMPLATE.values():
                    step_keys = set(step.definitions.__dict__.keys()) - excluded_keys
                    all_keys.update(step_keys)

                # Remove the &#39;all&#39; key itself if present
                all_keys.discard(&#34;all&#34;)

                variables_data = {}
                for var in all_keys:
                    var_data = defaultdict(list)
                    # Include global definitions
                    if include_global and hasattr(self.DEFINITIONS, var):
                        var_value = getattr(self.DEFINITIONS, var)
                        if isinstance(var_value, list):
                            var_data[&#39;global&#39;].append(var_value.copy())  # Directly append the value
                        else:
                            var_data[&#39;global&#39;].append(var_value)
                    # Traverse through steps
                    for step_key, step in self.TEMPLATE.items():
                        if hasattr(step.definitions, var):
                            var_value = getattr(step.definitions, var)
                            if isinstance(var_value, list):
                                var_data[&#39;local&#39;].append((step_key, var_value.copy()))
                            else:
                                var_data[&#39;local&#39;].append((step_key, var_value))
                    variables_data[var] = dict(var_data)
                return VariableOccurrences(variables_data, variables=None)  # variables=None implies multiple variables

            else:
                # Single variable case
                return VariableOccurrences(occurrences_dict, variables=key)

        # Determine return value
        if not unique_values:
            if verbose:
                print(f&#34;No values found for key &#39;{key}&#39; in any step or global definitions.&#34;)
            return None
        elif len(unique_values) == 1:
            return unique_values[0]
        else:
            return ordered_values



    def flattenvariables(self):
        &#34;&#34;&#34;
        Flatten the variable definitions for each step based on usage and precedence.

        This method ensures that for each step:
            - Only the variables used in the template are present in `self[i].definitions`.
            - The value of each variable is determined based on the following precedence:
                1. Global Definitions (`self.DEFINITIONS`)
                2. Current Step Definitions (`self[i].definitions`)
                3. Previous Step Definitions (`self[i-1].definitions`, etc.)
                4. Protected Variables (`&#34;$variable_name&#34;`)

        The method updates `self[i].definitions` to include only the necessary variables with their resolved values.
        Unused variables are removed from each step&#39;s definitions after resolution, **excluding** protected attributes.

        Raises:
            AttributeError: If a step or global definitions lack the necessary attributes.
        &#34;&#34;&#34;
        # Define the set of protected attributes that must never be removed
        excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

        # Initialize local_definitions with a copy of global definitions to prevent mutation
        local_definitions = lambdaScriptdata(**self.DEFINITIONS.__dict__)

        # Iterate through each step in order
        for i in range(len(self)):
            step = self[i]
            step_definitions = step.definitions

            # Detect variables used in the current step&#39;s template
            variables_used = step.detect_variables()

            # Temporary dictionary to store resolved variable values
            resolved_vars = {}

            # Resolve each variable&#39;s value based on precedence
            for var in variables_used:
                if hasattr(step_definitions, var):
                    # Variable defined in the current step&#39;s definitions
                    resolved_vars[var] = getattr(step_definitions, var)
                elif hasattr(local_definitions, var):
                    # Variable inherited from previous definitions (global or prior steps)
                    resolved_vars[var] = getattr(local_definitions, var)
                else:
                    # Variable not found; assign protected format
                    resolved_vars[var] = f&#34;${var}&#34;

            # Remove any variables in step_definitions not in variables_used and not in excluded_keys
            existing_vars = list(step_definitions.__dict__.keys())
            for var in existing_vars:
                if var not in variables_used and var not in excluded_keys:
                    delattr(step_definitions, var)

            # Assign resolved variables to step_definitions
            for var, value in resolved_vars.items():
                setattr(step_definitions, var, value)

            # Update local_definitions by merging with step_definitions
            # Only variables used in this step are updated in local_definitions
            local_definitions = local_definitions + step_definitions



    def clean(self, behavior=&#39;fixing&#39;, verbose=False):
        &#34;&#34;&#34;
        Clean the TEMPLATE by removing or fixing empty steps.

        An empty step is defined as one where its content is [], &#34;&#34;, or None.

        Parameters:
            behavior (str, optional):
                Determines the action to perform on empty steps.
                - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
                - &#39;fixing&#39;: Replace the content of the empty step with a comment.
                Defaults to &#39;fixing&#39;.
            verbose (bool, optional):
                If True, prints informational messages about the actions taken.
                If False, operates silently.
                Defaults to False.

        Raises:
            ValueError:
                If the provided behavior is not &#39;removing&#39; or &#39;fixing&#39;.
        &#34;&#34;&#34;
        # Validate the &#39;behavior&#39; parameter
        if behavior not in {&#39;removing&#39;, &#39;fixing&#39;}:
            raise ValueError(&#34;Parameter &#39;behavior&#39; must be either &#39;removing&#39; or &#39;fixing&#39;.&#34;)

        # Iterate over a list of keys to avoid RuntimeError due to dict size change during iteration
        for key in list(self.TEMPLATE.keys()):
            step = self.TEMPLATE[key]
            content = step.content

            # Check if the step is empty
            if content in [[], &#34;&#34;, None,[&#34;&#34;],[None],[[]]]:
                if behavior == &#39;removing&#39;:
                    # Remove the step entirely from TEMPLATE
                    del self.TEMPLATE[key]
                    if verbose:
                        print(f&#34;Removed empty step: {key}&#34;)
                elif behavior == &#39;fixing&#39;:
                    # Replace the content with a default comment
                    step.content = [f&#34;# empty &lt;step {key}&gt;&#34;]
                    if verbose:
                        print(f&#34;Fixed empty step: {key} by adding a comment.&#34;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dscript.dscript.construction_attributes"><code class="name">var <span class="ident">construction_attributes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dscript.dscript.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>name=None, verbose=True, verbosity=None, style=2, filepath=None, version=None, license=None, email=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a formatted header for the DSCRIPT file.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>name (str, optional): The name of the script. If None, "Unnamed" is used.
verbose (bool, optional): Whether to include the header. Default is True.
verbosity (int, optional): Verbosity level. Overrides &lt;code&gt;verbose&lt;/code&gt; if specified.
style (int, optional): ASCII style for the header (default=2).
filepath (str, optional): Full path to the file being saved. If None, the line mentioning the file path is excluded.
version (str, optional): DSCRIPT version. If None, it is omitted from the header.
license (str, optional): License type. If None, it is omitted from the header.
email (str, optional): Contact email. If None, it is omitted from the header.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>str: A formatted string representing the script's metadata and initialization details.
     Returns an empty string if &lt;code&gt;verbose&lt;/code&gt; is False.
</code></pre>
<h3 id="the-header-includes">The header includes:</h3>
<pre><code>- DSCRIPT version, license, and contact email, if provided.
- The name of the script.
- Filepath, if provided.
- Information on where and when the script was generated.
</code></pre>
<h3 id="notes">Notes:</h3>
<pre><code>- If &lt;code&gt;verbosity&lt;/code&gt; is specified, it overrides &lt;code&gt;verbose&lt;/code&gt;.
- Omits metadata lines if &lt;code&gt;version&lt;/code&gt;, &lt;code&gt;license&lt;/code&gt;, or &lt;code&gt;email&lt;/code&gt; are not provided.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def header(name=None, verbose=True, verbosity=None, style=2, filepath=None, version=None, license=None, email=None):
    &#34;&#34;&#34;
    Generate a formatted header for the DSCRIPT file.

    ### Parameters:
        name (str, optional): The name of the script. If None, &#34;Unnamed&#34; is used.
        verbose (bool, optional): Whether to include the header. Default is True.
        verbosity (int, optional): Verbosity level. Overrides `verbose` if specified.
        style (int, optional): ASCII style for the header (default=2).
        filepath (str, optional): Full path to the file being saved. If None, the line mentioning the file path is excluded.
        version (str, optional): DSCRIPT version. If None, it is omitted from the header.
        license (str, optional): License type. If None, it is omitted from the header.
        email (str, optional): Contact email. If None, it is omitted from the header.

    ### Returns:
        str: A formatted string representing the script&#39;s metadata and initialization details.
             Returns an empty string if `verbose` is False.

    ### The header includes:
        - DSCRIPT version, license, and contact email, if provided.
        - The name of the script.
        - Filepath, if provided.
        - Information on where and when the script was generated.

    ### Notes:
        - If `verbosity` is specified, it overrides `verbose`.
        - Omits metadata lines if `version`, `license`, or `email` are not provided.
    &#34;&#34;&#34;
    # Resolve verbosity
    verbose = verbosity &gt; 0 if verbosity is not None else verbose
    if not verbose:
        return &#34;&#34;
    # Validate inputs
    if name is None:
        name = &#34;Unnamed&#34;
    # Prepare metadata line
    metadata = []
    if version:
        metadata.append(f&#34;v{version}&#34;)
    if license:
        metadata.append(f&#34;License: {license}&#34;)
    if email:
        metadata.append(f&#34;Email: {email}&#34;)
    metadata_line = &#34; | &#34;.join(metadata)
    # Prepare the framed header content
    lines = []
    if metadata_line:
        lines.append(f&#34;PIZZA.DSCRIPT FILE {metadata_line}&#34;)
    lines += [
        &#34;&#34;,
        f&#34;Name: {name}&#34;,
    ]
    # Add the filepath line if filepath is not None
    if filepath:
        lines.append(f&#34;Path: {filepath}&#34;)
    lines += [
        &#34;&#34;,
        f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
        f&#34;{datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
    ]
    # Use the shared frame_header function to format the framed content
    return frame_header(lines, style=style)</code></pre>
</details>
</dd>
<dt id="dscript.dscript.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filename, foldername=None, numerickeys=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a script instance from a text file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file to load the script from. If the filename does not end with ".txt",
the extension is automatically appended.</dd>
<dt><strong><code>foldername</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The directory where the file is located. If not provided, it defaults to the system's
temporary directory. If the filename does not include a full path, this folder will be used.</dd>
<dt><strong><code>numerickeys</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>If True, numeric string keys in the template section are automatically converted into integers.
For example, the key "0" would be converted into the integer 0.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>If <code>True</code>, the parser keep comments inside templates and template blocks.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If True, print parsed lines for refining/tracking the parsing of block and single lines</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code></dt>
<dd>A new <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> instance populated with the content of the loaded file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the file does not start with the correct DSCRIPT header or the file format is invalid.</dd>
<dt><code>FileNotFoundError</code></dt>
<dd>If the specified file does not exist.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>The file is expected to follow the same structured format as the one produced by the <code>save()</code> method.</li>
<li>The method processes global parameters, definitions, template lines/items, and attributes. If the file
includes numeric keys as strings (e.g., "0", "1"), they can be automatically converted into integers
if <code>numerickeys=True</code>.</li>
<li>The script structure is dynamically rebuilt, and each section (global parameters, definitions,
template, and attributes) is correctly parsed and assigned to the corresponding parts of the <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code>
instance.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, filename, foldername=None, numerickeys=True, verbose=True, debug=False):
    &#34;&#34;&#34;
    Load a script instance from a text file.

    Parameters
    ----------
    filename : str
        The name of the file to load the script from. If the filename does not end with &#34;.txt&#34;,
        the extension is automatically appended.

    foldername : str, optional
        The directory where the file is located. If not provided, it defaults to the system&#39;s
        temporary directory. If the filename does not include a full path, this folder will be used.

    numerickeys : bool, default=True
        If True, numeric string keys in the template section are automatically converted into integers.
        For example, the key &#34;0&#34; would be converted into the integer 0.

    verbose : bool, default=True
        If `True`, the parser keep comments inside templates and template blocks.

    debug : bool, default=False
        If True, print parsed lines for refining/tracking the parsing of block and single lines

    Returns
    -------
    dscript
        A new `dscript` instance populated with the content of the loaded file.

    Raises
    ------
    ValueError
        If the file does not start with the correct DSCRIPT header or the file format is invalid.

    FileNotFoundError
        If the specified file does not exist.

    Notes
    -----
    - The file is expected to follow the same structured format as the one produced by the `save()` method.
    - The method processes global parameters, definitions, template lines/items, and attributes. If the file
      includes numeric keys as strings (e.g., &#34;0&#34;, &#34;1&#34;), they can be automatically converted into integers
      if `numerickeys=True`.
    - The script structure is dynamically rebuilt, and each section (global parameters, definitions,
      template, and attributes) is correctly parsed and assigned to the corresponding parts of the `dscript`
      instance.
    &#34;&#34;&#34;

    # Step 0 validate filepath
    if not filename.endswith(&#39;.txt&#39;):
        filename += &#39;.txt&#39;

    # Handle foldername and relative paths
    if foldername is None or foldername == &#34;&#34;:
        # If the foldername is empty or None, use current working directory for relative paths
        if not os.path.isabs(filename):
            filepath = os.path.join(os.getcwd(), filename)
        else:
            filepath = filename  # If filename is absolute, use it directly
    else:
        # If foldername is provided and filename is not absolute, use foldername
        if not os.path.isabs(filename):
            filepath = os.path.join(foldername, filename)
        else:
            filepath = filename

    if not os.path.exists(filepath):
        raise FileExistsError(f&#34;The file &#39;{filepath}&#39; does not exist.&#34;)

    # Read the file contents
    with open(filepath, &#39;r&#39;) as f:
        content = f.read()

    # Call parsesyntax to parse the file content
    fname = os.path.basename(filepath)  # Extracts the filename (e.g., &#34;myscript.txt&#34;)
    name, _ = os.path.splitext(fname)   # Removes the extension, e.g., &#34;myscript
    return cls.parsesyntax(content, name=name, numerickeys=numerickeys, verbose=verbose, debug=debug)</code></pre>
</details>
</dd>
<dt id="dscript.dscript.parsesyntax"><code class="name flex">
<span>def <span class="ident">parsesyntax</span></span>(<span>content, name=None, numerickeys=True, verbose=False, authentification=True, debug=False, comment_chars='#%', continuation_marker='...')</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a DSCRIPT script from a string content.</p>
<pre><code>Parameters
----------
content : str
    The string content of the DSCRIPT script to be parsed.

name : str, optional
    The name of the dscript project. If &lt;code&gt;None&lt;/code&gt;, a random name is generated.

numerickeys : bool, default=True
    If &lt;code&gt;True&lt;/code&gt;, numeric string keys in the template section are automatically converted into integers.

verbose : bool, default=True
    If &lt;code&gt;True&lt;/code&gt;, the parser keep comments inside templates and template blocks.

authentification : bool, default=True
    If &lt;code&gt;True&lt;/code&gt;, the parser is expected that the first non empty line is # DSCRIPT SAVE FILE

comment_chars : str, optional (default: "#%")
    A string containing characters to identify the start of a comment.
    Any of these characters will mark the beginning of a comment unless within quotes.

continuation_marker : str, optional (default: "...")
    A string containing characters to indicate line continuation
    Any characters after the continuation marker are considered comment and are theorefore ignored

debug : bool, default=False
    Print parsed lines for refining the parsing of block lines

Returns
-------
dscript
    A new &lt;code&gt;&lt;a title="dscript.dscript" href="#dscript.dscript"&gt;dscript&lt;/a&gt;&lt;/code&gt; instance populated with the content of the loaded file.

Raises
------
ValueError
    If content does not start with the correct DSCRIPT header or the file format is invalid.

Notes
-----
**DSCRIPT SAVE FILE FORMAT**

This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
and control attributes can be defined in a flexible manner.

**Mandatory First Line:**

Every DSCRIPT file must begin with the following line:

```plaintext
# DSCRIPT SAVE FILE
```

**Structure Overview:**

1. **Global Parameters Section (Optional):**

    - This section defines global script settings, enclosed within curly braces `{}`.
    - Properties include:
        - &lt;code&gt;SECTIONS&lt;/code&gt;: List of section names to be considered (e.g., `["DYNAMIC"]`).
        - &lt;code&gt;section&lt;/code&gt;: Current section index (e.g., &lt;code&gt;0&lt;/code&gt;).
        - &lt;code&gt;position&lt;/code&gt;: Current script position in the order.
        - &lt;code&gt;role&lt;/code&gt;: Defines the role of the script instance (e.g., `"dscript instance"`).
        - &lt;code&gt;description&lt;/code&gt;: A short description of the script (e.g., `"dynamic script"`).
        - &lt;code&gt;userid&lt;/code&gt;: Identifier for the user (e.g., `"dscript"`).
        - &lt;code&gt;version&lt;/code&gt;: Script version (e.g., &lt;code&gt;0.1&lt;/code&gt;).
        - &lt;code&gt;verbose&lt;/code&gt;: Verbosity flag, typically a boolean (e.g., &lt;code&gt;False&lt;/code&gt;).

    **Example:**

    ```plaintext
    {
        SECTIONS = ['INITIALIZATION', 'SIMULATION']  # Global script parameters
    }
    ```

2. **Definitions Section:**

    - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
    - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
      to delay execution or substitution.

    **Example:**

    ```plaintext
    d = 3                               # Define a number
    periodic = "$p"                     # '$' prevents immediate evaluation of 'p'
    units = "$metal"                    # '$' prevents immediate evaluation of 'metal'
    dimension = "${d}"                  # Variable substitution
    boundary = ['p', 'p', 'p']          # List with a mix of variables and values
    atom_style = "$atomic"              # String variable with delayed evaluation
    ```

3. **Templates Section:**

    - This section provides a mapping between keys and their corresponding commands or instructions.
    - Each template can reference variables defined in the **Definitions** section or elsewhere, typically using the `${variable}` syntax.
    - **Syntax Variations**:

        Templates can be defined in several ways, including without blocks, with single- or multi-line blocks, and with ellipsis (&lt;code&gt;...&lt;/code&gt;) as a line continuation marker.

        - **Single-line Template Without Block**:
            ```plaintext
            KEY: INSTRUCTION
            ```
            - &lt;code&gt;KEY&lt;/code&gt; is the identifier for the template (numeric or alphanumeric).
            - &lt;code&gt;INSTRUCTION&lt;/code&gt; is the command or template text, which may reference variables.

        - **Single-line Template With Block**:
            ```plaintext
            KEY: [INSTRUCTION]
            ```
            - Uses square brackets (&lt;code&gt;\[ ]&lt;/code&gt;) around the &lt;code&gt;INSTRUCTION&lt;/code&gt;, indicating that all instructions are part of the block.

        - **Multi-line Template With Block**:
            ```plaintext
            KEY: [
                INSTRUCTION1
                INSTRUCTION2
                ...
                ]
            ```
            - Begins with `KEY: [` and ends with a standalone &lt;code&gt;]&lt;/code&gt; on a new line.
            - Instructions within the block can span multiple lines, and ellipses (&lt;code&gt;...&lt;/code&gt;) at the end of a line are used to indicate that the line continues, ignoring any content following the ellipsis as comments.
            - Comments following ellipses are removed after parsing and do not become part of the block, preserving only the instructions.

        - **Multi-line Template With Continuation Marker (Ellipsis)**:
            - For templates with complex code containing square brackets (&lt;code&gt;\[ ]&lt;/code&gt;), the ellipsis (&lt;code&gt;...&lt;/code&gt;) can be used to prevent &lt;code&gt;]&lt;/code&gt; from prematurely closing the block. The ellipsis will keep the line open across multiple lines, allowing brackets in the instructions.

            **Example:**
            ```plaintext
            example1: command ${value}       # Single-line template without block
            example2: [command ${value}]     # Single-line template with block

            # Multi-line template with block
            example3: [
                command1 ${var1}
                command2 ${var2} ...   # Line continues after ellipsis
                command3 ${var3} ...   # Additional instruction continues
                ]

            # Multi-line template with ellipsis (handling square brackets)
            example4: [
                A[0][1] ...            # Ellipsis allows [ ] within instructions
                B[2][3] ...            # Another instruction in the block
                ]
            ```

    - **Key Points**:
        - **Blocks** allow grouping of multiple instructions for a single key, enclosed in square brackets.
        - **Ellipsis (&lt;code&gt;...&lt;/code&gt;)** at the end of a line keeps the line open, preventing premature closing by &lt;code&gt;]&lt;/code&gt;, especially useful if the template code includes square brackets (&lt;code&gt;\[ ]&lt;/code&gt;).
        - **Comments** placed after the ellipsis are removed after parsing and are not part of the final block content.

    This flexibility supports both simple and complex template structures, allowing instructions to be grouped logically while keeping code and comments distinct.


4. **Attributes Section:**

    - Each template line can have customizable attributes to control behavior and conditions.
    - Default attributes include:
        - &lt;code&gt;facultative&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, the line is optional and can be removed if needed.
        - &lt;code&gt;eval&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, the line will be evaluated with Python's &lt;code&gt;eval()&lt;/code&gt; function.
        - &lt;code&gt;readonly&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, the line cannot be modified later in the script.
        - &lt;code&gt;condition&lt;/code&gt;: An expression that must be satisfied for the line to be included.
        - &lt;code&gt;condeval&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, the condition will be evaluated using &lt;code&gt;eval()&lt;/code&gt;.
        - &lt;code&gt;detectvar&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, this creates variables in the **Definitions** section if they do not exist.

    **Example:**

    ```plaintext
    units: {facultative=False, eval=False, readonly=False, condition="${units}", condeval=False, detectvar=True}
    dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    ```

**Note on Multiple Definitions**

This example demonstrates how variables defined in the **Definitions** section are handled for each template.
Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
can use different values for the same variable if redefined.

**Example:**

```plaintext
# DSCRIPT SAVE FILE

# Definitions
var = 10

# Template key1
key1: Template content with ${var}

# Definitions
var = 20

# Template key2
key2: Template content with ${var}

# Template key3
key3:[
    this is an undefined variable ${var31}
    this is another undefined variable ${var32}
    this variable is defined  ${var}
]
```

**Parsing and Usage:**

```python
# Parse content using parsesyntax()
ds = dscript.parsesyntax(content)

# Accessing templates and their variables
print(ds.TEMPLATE['key1'].text)  # Output: Template content with 10
print(ds.TEMPLATE['key2'].text)  # Output: Template content with 20
```

**Handling Undefined Variables:**

Variables like `${var31}` and `${var32}` in &lt;code&gt;key3&lt;/code&gt; are undefined. The parser will handle them based on your substitution logic or raise an error if they are required.

**Important Notes:**

- The parser processes the script sequentially. Definitions must appear before the templates that use them.
- Templates capture the variable definitions at the time they are parsed. Redefining a variable affects only subsequent templates.
- Comments outside of blocks are allowed and ignored by the parser.
- Content within templates is treated as-is, allowing for any syntax required by the target system (e.g., LAMMPS commands).
</code></pre>
<p><strong>Advanced Example</strong></p>
<pre><code>Here's a more advanced example demonstrating the use of global definitions, local definitions, templates, and how to parse and render the template content.

```python
content = '''
    # GLOBAL DEFINITIONS
    dumpfile = $dump.LAMMPS
    dumpdt = 50
    thermodt = 100
    runtime = 5000

    # LOCAL DEFINITIONS for step '0'
    dimension = 3
    units = $si
    boundary = ['f', 'f', 'f']
    atom_style = $smd
    atom_modify = ['map', 'array']
    comm_modify = ['vel', 'yes']
    neigh_modify = ['every', 10, 'delay', 0, 'check', 'yes']
    newton = $off
    name = $SimulationBox

    # This is a comment line outside of blocks
    # ------------------------------------------

    0: [    % --------------[ Initialization Header (helper) for "${name}" ]--------------
        # set a parameter to None or "" to remove the definition
        dimension    ${dimension}
        units        ${units}
        boundary     ${boundary}
        atom_style   ${atom_style}
        atom_modify  ${atom_modify}
        comm_modify  ${comm_modify}
        neigh_modify ${neigh_modify}
        newton       ${newton}
        # ------------------------------------------
     ]
'''
# Parse the content
ds = dscript.parsesyntax(content, verbose=True, authentification=False)

# Access and print the rendered template
print("Template 0 content:")
print(ds.TEMPLATE[0].do())
```

**Explanation:**

- **Global Definitions:** Define variables that are accessible throughout the script.
- **Local Definitions for Step '0':** Define variables specific to a particular step or template.
- **Template Block:** Identified by `0: [ ... ]`, it contains the content where variables will be substituted.
- **Comments:** Lines starting with `#` are comments and are ignored by the parser outside of template blocks.

**Expected Output:**

```
Template 0 content:
# --------------[ Initialization Header (helper) for "SimulationBox" ]--------------
# set a parameter to None or "" to remove the definition
dimension    3
units        si
boundary     ['f', 'f', 'f']
atom_style   smd
atom_modify  ['map', 'array']
comm_modify  ['vel', 'yes']
neigh_modify ['every', 10, 'delay', 0, 'check', 'yes']
newton       off
# ------------------------------------------
```

**Notes:**

- The &lt;code&gt;do()&lt;/code&gt; method renders the template, substituting variables with their defined values.
- Variables like `${dimension}` are replaced with their corresponding values defined in the local or global definitions.
- The parser handles comments and blank lines appropriately, ensuring they don't interfere with the parsing logic.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parsesyntax(cls, content, name=None, numerickeys=True, verbose=False, authentification=True,
                debug=False, comment_chars=&#34;#%&#34;,continuation_marker=&#34;...&#34;):
    &#34;&#34;&#34;
    Parse a DSCRIPT script from a string content.

    Parameters
    ----------
    content : str
        The string content of the DSCRIPT script to be parsed.

    name : str, optional
        The name of the dscript project. If `None`, a random name is generated.

    numerickeys : bool, default=True
        If `True`, numeric string keys in the template section are automatically converted into integers.

    verbose : bool, default=True
        If `True`, the parser keep comments inside templates and template blocks.

    authentification : bool, default=True
        If `True`, the parser is expected that the first non empty line is # DSCRIPT SAVE FILE

    comment_chars : str, optional (default: &#34;#%&#34;)
        A string containing characters to identify the start of a comment.
        Any of these characters will mark the beginning of a comment unless within quotes.

    continuation_marker : str, optional (default: &#34;...&#34;)
        A string containing characters to indicate line continuation
        Any characters after the continuation marker are considered comment and are theorefore ignored

    debug : bool, default=False
        Print parsed lines for refining the parsing of block lines

    Returns
    -------
    dscript
        A new `dscript` instance populated with the content of the loaded file.

    Raises
    ------
    ValueError
        If content does not start with the correct DSCRIPT header or the file format is invalid.

    Notes
    -----
    **DSCRIPT SAVE FILE FORMAT**

    This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
    and control attributes can be defined in a flexible manner.

    **Mandatory First Line:**

    Every DSCRIPT file must begin with the following line:

    ```plaintext
    # DSCRIPT SAVE FILE
    ```

    **Structure Overview:**

    1. **Global Parameters Section (Optional):**

        - This section defines global script settings, enclosed within curly braces `{}`.
        - Properties include:
            - `SECTIONS`: List of section names to be considered (e.g., `[&#34;DYNAMIC&#34;]`).
            - `section`: Current section index (e.g., `0`).
            - `position`: Current script position in the order.
            - `role`: Defines the role of the script instance (e.g., `&#34;dscript instance&#34;`).
            - `description`: A short description of the script (e.g., `&#34;dynamic script&#34;`).
            - `userid`: Identifier for the user (e.g., `&#34;dscript&#34;`).
            - `version`: Script version (e.g., `0.1`).
            - `verbose`: Verbosity flag, typically a boolean (e.g., `False`).

        **Example:**

        ```plaintext
        {
            SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;]  # Global script parameters
        }
        ```

    2. **Definitions Section:**

        - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
        - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
          to delay execution or substitution.

        **Example:**

        ```plaintext
        d = 3                               # Define a number
        periodic = &#34;$p&#34;                     # &#39;$&#39; prevents immediate evaluation of &#39;p&#39;
        units = &#34;$metal&#34;                    # &#39;$&#39; prevents immediate evaluation of &#39;metal&#39;
        dimension = &#34;${d}&#34;                  # Variable substitution
        boundary = [&#39;p&#39;, &#39;p&#39;, &#39;p&#39;]          # List with a mix of variables and values
        atom_style = &#34;$atomic&#34;              # String variable with delayed evaluation
        ```

    3. **Templates Section:**

        - This section provides a mapping between keys and their corresponding commands or instructions.
        - Each template can reference variables defined in the **Definitions** section or elsewhere, typically using the `${variable}` syntax.
        - **Syntax Variations**:

            Templates can be defined in several ways, including without blocks, with single- or multi-line blocks, and with ellipsis (`...`) as a line continuation marker.

            - **Single-line Template Without Block**:
                ```plaintext
                KEY: INSTRUCTION
                ```
                - `KEY` is the identifier for the template (numeric or alphanumeric).
                - `INSTRUCTION` is the command or template text, which may reference variables.

            - **Single-line Template With Block**:
                ```plaintext
                KEY: [INSTRUCTION]
                ```
                - Uses square brackets (`[ ]`) around the `INSTRUCTION`, indicating that all instructions are part of the block.

            - **Multi-line Template With Block**:
                ```plaintext
                KEY: [
                    INSTRUCTION1
                    INSTRUCTION2
                    ...
                    ]
                ```
                - Begins with `KEY: [` and ends with a standalone `]` on a new line.
                - Instructions within the block can span multiple lines, and ellipses (`...`) at the end of a line are used to indicate that the line continues, ignoring any content following the ellipsis as comments.
                - Comments following ellipses are removed after parsing and do not become part of the block, preserving only the instructions.

            - **Multi-line Template With Continuation Marker (Ellipsis)**:
                - For templates with complex code containing square brackets (`[ ]`), the ellipsis (`...`) can be used to prevent `]` from prematurely closing the block. The ellipsis will keep the line open across multiple lines, allowing brackets in the instructions.

                **Example:**
                ```plaintext
                example1: command ${value}       # Single-line template without block
                example2: [command ${value}]     # Single-line template with block

                # Multi-line template with block
                example3: [
                    command1 ${var1}
                    command2 ${var2} ...   # Line continues after ellipsis
                    command3 ${var3} ...   # Additional instruction continues
                    ]

                # Multi-line template with ellipsis (handling square brackets)
                example4: [
                    A[0][1] ...            # Ellipsis allows [ ] within instructions
                    B[2][3] ...            # Another instruction in the block
                    ]
                ```

        - **Key Points**:
            - **Blocks** allow grouping of multiple instructions for a single key, enclosed in square brackets.
            - **Ellipsis (`...`)** at the end of a line keeps the line open, preventing premature closing by `]`, especially useful if the template code includes square brackets (`[ ]`).
            - **Comments** placed after the ellipsis are removed after parsing and are not part of the final block content.

        This flexibility supports both simple and complex template structures, allowing instructions to be grouped logically while keeping code and comments distinct.


    4. **Attributes Section:**

        - Each template line can have customizable attributes to control behavior and conditions.
        - Default attributes include:
            - `facultative`: If `True`, the line is optional and can be removed if needed.
            - `eval`: If `True`, the line will be evaluated with Python&#39;s `eval()` function.
            - `readonly`: If `True`, the line cannot be modified later in the script.
            - `condition`: An expression that must be satisfied for the line to be included.
            - `condeval`: If `True`, the condition will be evaluated using `eval()`.
            - `detectvar`: If `True`, this creates variables in the **Definitions** section if they do not exist.

        **Example:**

        ```plaintext
        units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
        dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
        ```

    **Note on Multiple Definitions**

    This example demonstrates how variables defined in the **Definitions** section are handled for each template.
    Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
    can use different values for the same variable if redefined.

    **Example:**

    ```plaintext
    # DSCRIPT SAVE FILE

    # Definitions
    var = 10

    # Template key1
    key1: Template content with ${var}

    # Definitions
    var = 20

    # Template key2
    key2: Template content with ${var}

    # Template key3
    key3:[
        this is an undefined variable ${var31}
        this is another undefined variable ${var32}
        this variable is defined  ${var}
    ]
    ```

    **Parsing and Usage:**

    ```python
    # Parse content using parsesyntax()
    ds = dscript.parsesyntax(content)

    # Accessing templates and their variables
    print(ds.TEMPLATE[&#39;key1&#39;].text)  # Output: Template content with 10
    print(ds.TEMPLATE[&#39;key2&#39;].text)  # Output: Template content with 20
    ```

    **Handling Undefined Variables:**

    Variables like `${var31}` and `${var32}` in `key3` are undefined. The parser will handle them based on your substitution logic or raise an error if they are required.

    **Important Notes:**

    - The parser processes the script sequentially. Definitions must appear before the templates that use them.
    - Templates capture the variable definitions at the time they are parsed. Redefining a variable affects only subsequent templates.
    - Comments outside of blocks are allowed and ignored by the parser.
    - Content within templates is treated as-is, allowing for any syntax required by the target system (e.g., LAMMPS commands).


**Advanced Example**

    Here&#39;s a more advanced example demonstrating the use of global definitions, local definitions, templates, and how to parse and render the template content.

    ```python
    content = &#39;&#39;&#39;
        # GLOBAL DEFINITIONS
        dumpfile = $dump.LAMMPS
        dumpdt = 50
        thermodt = 100
        runtime = 5000

        # LOCAL DEFINITIONS for step &#39;0&#39;
        dimension = 3
        units = $si
        boundary = [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
        atom_style = $smd
        atom_modify = [&#39;map&#39;, &#39;array&#39;]
        comm_modify = [&#39;vel&#39;, &#39;yes&#39;]
        neigh_modify = [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
        newton = $off
        name = $SimulationBox

        # This is a comment line outside of blocks
        # ------------------------------------------

        0: [    % --------------[ Initialization Header (helper) for &#34;${name}&#34; ]--------------
            # set a parameter to None or &#34;&#34; to remove the definition
            dimension    ${dimension}
            units        ${units}
            boundary     ${boundary}
            atom_style   ${atom_style}
            atom_modify  ${atom_modify}
            comm_modify  ${comm_modify}
            neigh_modify ${neigh_modify}
            newton       ${newton}
            # ------------------------------------------
         ]
    &#39;&#39;&#39;
    # Parse the content
    ds = dscript.parsesyntax(content, verbose=True, authentification=False)

    # Access and print the rendered template
    print(&#34;Template 0 content:&#34;)
    print(ds.TEMPLATE[0].do())
    ```

    **Explanation:**

    - **Global Definitions:** Define variables that are accessible throughout the script.
    - **Local Definitions for Step &#39;0&#39;:** Define variables specific to a particular step or template.
    - **Template Block:** Identified by `0: [ ... ]`, it contains the content where variables will be substituted.
    - **Comments:** Lines starting with `#` are comments and are ignored by the parser outside of template blocks.

    **Expected Output:**

    ```
    Template 0 content:
    # --------------[ Initialization Header (helper) for &#34;SimulationBox&#34; ]--------------
    # set a parameter to None or &#34;&#34; to remove the definition
    dimension    3
    units        si
    boundary     [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
    atom_style   smd
    atom_modify  [&#39;map&#39;, &#39;array&#39;]
    comm_modify  [&#39;vel&#39;, &#39;yes&#39;]
    neigh_modify [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
    newton       off
    # ------------------------------------------
    ```

    **Notes:**

    - The `do()` method renders the template, substituting variables with their defined values.
    - Variables like `${dimension}` are replaced with their corresponding values defined in the local or global definitions.
    - The parser handles comments and blank lines appropriately, ensuring they don&#39;t interfere with the parsing logic.


    &#34;&#34;&#34;
    # Split the content into lines
    lines = content.splitlines()
    if not lines:
        raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

    # Initialize containers
    global_params = {}
    GLOBALdefinitions = lambdaScriptdata()
    LOCALdefinitions = lambdaScriptdata()
    template = {}
    attributes = {}

    # State variables
    inside_global_params = False
    global_params_content = &#34;&#34;
    inside_template_block = False
    current_template_key = None
    current_template_content = []
    current_var_value = lambdaScriptdata()

    # Initialize line number
    line_number = 0
    last_successful_line = 0

    # Step 1: Authenticate the file
    if authentification:
        auth_line_found = False
        max_header_lines = 10
        header_end_idx = -1
        for idx, line in enumerate(lines[:max_header_lines]):
            stripped_line = line.strip()
            if not stripped_line:
                continue
            if stripped_line.startswith(&#34;# DSCRIPT SAVE FILE&#34;):
                auth_line_found = True
                header_end_idx = idx
                break
            elif stripped_line.startswith(&#34;#&#34;) or stripped_line.startswith(&#34;%&#34;):
                continue
            else:
                raise ValueError(f&#34;Unexpected content before authentication line (# DSCRIPT SAVE FILE) at line {idx + 1}:\n{line}&#34;)
        if not auth_line_found:
            raise ValueError(&#34;File/Content is not a valid DSCRIPT file.&#34;)

        # Remove header lines
        lines = lines[header_end_idx + 1:]
        line_number = header_end_idx + 1
        last_successful_line = line_number - 1
    else:
        line_number = 0
        last_successful_line = 0

    # Process each line
    for idx, line in enumerate(lines):
        line_number += 1
        line_content = line.rstrip(&#39;\n&#39;)
        if debug: print(f&#34;RAW L{line_number}    :{line_content}\n&#34;)

        # Determine if we&#39;re inside a template block
        if inside_template_block:
            # Extract the code with its eventual continuation_marker
            code_line = remove_comments(
                    line_content,
                    comment_chars=comment_chars,
                    continuation_marker=continuation_marker,
                    remove_continuation_marker=False,
                    ).rstrip()

            # Check if line should continue
            if code_line.endswith(continuation_marker):
                # Append line up to the continuation marker
                endofline_index = line_content.rindex(continuation_marker)
                trimmed_content = line_content[:endofline_index].rstrip()
                if trimmed_content:
                    current_template_content.append(trimmed_content)
                    if debug:print(f&#34;A|DEBUG L{line_number}:{trimmed_content}\n&#34;)
                continue
            elif code_line.endswith(&#34;]&#34;):  # End of multi-line block
                closing_index = code_line.rindex(&#39;]&#39;)
                trimmed_content = code_line[:closing_index].rstrip()

                # Append any valid content before `]`, if non-empty
                if trimmed_content:
                    current_template_content.append(trimmed_content)
                    if debug:print(f&#34;B|DEBUG L{line_number}:{trimmed_content}\n&#34;)

                # End of template block
                content = &#39;\n&#39;.join(current_template_content)
                template[current_template_key] = ScriptTemplate(
                    content=content,
                    autorefresh=False,
                    definitions=LOCALdefinitions,
                    verbose=verbose,
                    userid=current_template_key)
                # Refresh variables definitions
                template[current_template_key].refreshvar(globaldefinitions=GLOBALdefinitions)
                LOCALdefinitions = lambdaScriptdata()
                # Reset state for next block
                inside_template_block = False
                current_template_key = None
                current_template_content = []
                last_successful_line = line_number
                continue
            else:
                # Append the entire original line content if not ending with `...` or `]`
                current_template_content.append(line_content)
                if debug:print(f&#34;C|DEBUG L{line_number}:{line_content}\n&#34;)

            continue

        # Not inside a template block
        stripped_no_comments = remove_comments(line_content)

        # Ignore empty lines after removing comments
        if not stripped_no_comments.strip():
            continue

        # If the original line is a comment line, skip it
        if line_content.strip().startswith(&#34;#&#34;) or line_content.strip().startswith(&#34;%&#34;):
            continue

        stripped = stripped_no_comments.strip()

        # Handle start of a new template block
        template_block_match = re.match(r&#39;^(\w+)\s*:\s*\[&#39;, stripped)
        if template_block_match:
            current_template_key = template_block_match.group(1)
            if inside_template_block:
                # Collect error context
                context_start = max(0, last_successful_line - 3)
                context_end = min(len(lines), line_number + 2)
                error_context_lines = lines[context_start:context_end]
                error_context = &#34;&#34;
                for i, error_line in enumerate(error_context_lines):
                    line_num = context_start + i + 1
                    indicator = &#34;&gt;&#34; if line_num == line_number else &#34;*&#34; if line_num == last_successful_line else &#34; &#34;
                    error_context += f&#34;{indicator} {line_num}: {error_line}\n&#34;

                raise ValueError(
                    f&#34;Template block &#39;{current_template_key}&#39; starting at line {last_successful_line} (*) was not properly closed before starting a new one at line {line_number} (&gt;).\n\n&#34;
                    f&#34;Error context:\n{error_context}&#34;
                )
            else:
                inside_template_block = True
                idx_open_bracket = line_content.index(&#39;[&#39;)
                remainder = line_content[idx_open_bracket + 1:].strip()
                if remainder:
                    remainder_code = remove_comments(remainder, comment_chars=comment_chars).rstrip()
                    if remainder_code.endswith(&#34;]&#34;):
                        closing_index = remainder_code.rindex(&#39;]&#39;)
                        content_line = remainder_code[:closing_index].strip()
                        if content_line:
                            current_template_content.append(content_line)
                            if debug:print(f&#34;D|DEBUG L{line_number}:{content_line}\n&#34;)
                        content = &#39;\n&#39;.join(current_template_content)
                        template[current_template_key] = ScriptTemplate(
                            content=content,
                            autorefresh=False,
                            definitions=LOCALdefinitions,
                            verbose=verbose,
                            userid=current_template_key)
                        template[current_template_key].refreshvar(globaldefinitions=GLOBALdefinitions)
                        LOCALdefinitions = lambdaScriptdata()
                        inside_template_block = False
                        current_template_key = None
                        current_template_content = []
                        last_successful_line = line_number
                        continue
                    else:
                        current_template_content.append(remainder)
                        if debug:print(f&#34;E|DEBUG L{line_number}:{remainder}\n&#34;)
                last_successful_line = line_number
            continue

        # Handle start of global parameters
        if stripped.startswith(&#39;{&#39;) and not inside_global_params:
            if &#39;}&#39; in stripped:
                global_params_content = stripped
                cls._parse_global_params(global_params_content.strip(), global_params)
                global_params_content = &#34;&#34;
                last_successful_line = line_number
            else:
                inside_global_params = True
                global_params_content = stripped
            continue

        # Handle global parameters inside {...}
        if inside_global_params:
            global_params_content += &#39; &#39; + stripped
            if &#39;}&#39; in stripped:
                inside_global_params = False
                cls._parse_global_params(global_params_content.strip(), global_params)
                global_params_content = &#34;&#34;
                last_successful_line = line_number
            continue

        # Handle attributes
        attribute_match = re.match(r&#39;^(\w+)\s*:\s*\{(.+)\}&#39;, stripped)
        if attribute_match:
            key, attr_content = attribute_match.groups()
            attributes[key] = {}
            cls._parse_attributes(attributes[key], attr_content.strip())
            last_successful_line = line_number
            continue

        # Handle definitions
        definition_match = re.match(r&#39;^(\w+)\s*=\s*(.+)&#39;, stripped)
        if definition_match:
            key, value = definition_match.groups()
            convertedvalue = cls._convert_value(value)
            if key in GLOBALdefinitions:
                if (GLOBALdefinitions.getattr(key) != convertedvalue) or \
                    (getattr(current_var_value, key) != convertedvalue):
                    LOCALdefinitions.setattr(key, convertedvalue)
            else:
                GLOBALdefinitions.setattr(key, convertedvalue)
            last_successful_line = line_number
            setattr(current_var_value, key, convertedvalue)
            continue

        # Handle single-line templates (updated on 20250104 to handle empty content)
        template_match = re.match(r&#39;^(\w+)\s*:\s*(.*)&#39;, stripped)
        if template_match:
            key, content = template_match.groups()
            content = content.strip()  # Strip whitespace for consistency
            if not content:
                content = f&#34;# empty &lt;step {key}&gt;&#34;
                if debug: print(f&#34;F|DEBUG L{line_number}:Empty content detected for key: {key}, default value assigned\n&#34;)
            if debug: print(f&#34;F|DEBUG L{line_number}:{content}\n&#34;)
            template[key] = ScriptTemplate(
                content = content,
                autorefresh = False,
                definitions=LOCALdefinitions,
                verbose=verbose,
                userid=key)
            template[key].refreshvar(globaldefinitions=GLOBALdefinitions)
            if debug:print(f&#34;G|DEBUG L{line_number}:{template[key].content}\n&#34;)
            LOCALdefinitions = lambdaScriptdata()
            last_successful_line = line_number
            continue

        # Unrecognized line
        if verbose:
            print(f&#34;Warning: Unrecognized line at {line_number}: {line_content}&#34;)
            if debug:
                raise ValueError(f&#39;ERROR: stripped content &#34;{stripped}&#34;&#39;)
        last_successful_line = line_number
        continue

    # At the end, check if any template block was left unclosed
    if inside_template_block:
        # Collect error context
        context_start = max(0, last_successful_line - 3)
        context_end = min(len(lines), last_successful_line + 3)
        error_context_lines = lines[context_start:context_end]
        error_context = &#34;&#34;
        for i, error_line in enumerate(error_context_lines):
            line_num = context_start + i
            indicator = &#34;&gt;&#34; if line_num == last_successful_line else &#34; &#34;
            error_context += f&#34;{indicator} {line_num}: {error_line}\n&#34;

        raise ValueError(
            f&#34;Template block &#39;{current_template_key}&#39; starting at line {last_successful_line} was not properly closed.\n\n&#34;
            f&#34;Error context:\n{error_context}&#34;
        )

    # Apply attributes to templates
    for key in attributes:
        if key in template:
            for attr_name, attr_value in attributes[key].items():
                setattr(template[key], attr_name, attr_value)
            template[key]._autorefresh = True # restore the default behavior for the end-user
        else:
            raise ValueError(f&#34;Attributes found for undefined template key: {key}&#34;)

    # Create and return new instance
    if name is None:
        name = autoname(8)
    instance = cls(
        name=name,
        SECTIONS=global_params.get(&#39;SECTIONS&#39;, [&#39;DYNAMIC&#39;]),
        section=global_params.get(&#39;section&#39;, 0),
        position=global_params.get(&#39;position&#39;, 0),
        role=global_params.get(&#39;role&#39;, &#39;dscript instance&#39;),
        description=global_params.get(&#39;description&#39;, &#39;dynamic script&#39;),
        userid=global_params.get(&#39;userid&#39;, &#39;dscript&#39;),
        version=global_params.get(&#39;version&#39;, 0.1),
        verbose=global_params.get(&#39;verbose&#39;, False)
    )

    # Convert numeric string keys to integers if numerickeys is True
    if numerickeys:
        numeric_template = {}
        for key, value in template.items():
            if key.isdigit():
                numeric_template[int(key)] = value
            else:
                numeric_template[key] = value
        template = numeric_template

    # Set definitions and template
    instance.DEFINITIONS = GLOBALdefinitions
    instance.TEMPLATE = template

    # Refresh variables
    instance.set_all_variables()

    # Check variables
    instance.check_all_variables(verbose=False)

    return instance</code></pre>
</details>
</dd>
<dt id="dscript.dscript.parsesyntax_legacy"><code class="name flex">
<span>def <span class="ident">parsesyntax_legacy</span></span>(<span>content, name=None, numerickeys=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a script from a string content.
[ ------------------------------------------------------]
[ Legacy parsesyntax method for backward compatibility. ]
[ ------------------------------------------------------]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>content</code></strong> :&ensp;<code>str</code></dt>
<dd>The string content of the script to be parsed.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the dscript project (if None, it is set randomly)</dd>
<dt><strong><code>numerickeys</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>If True, numeric string keys in the template section are automatically converted into integers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code></dt>
<dd>A new <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> instance populated with the content of the loaded file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If content does not start with the correct DSCRIPT header or the file format is invalid.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>The file is expected to follow the same structured format as the one produced by the <code>save()</code> method.</li>
<li>The method processes global parameters, definitions, template lines/items, and attributes. If the file
includes numeric keys as strings (e.g., "0", "1"), they can be automatically converted into integers
if <code>numerickeys=True</code>.</li>
<li>The script structure is dynamically rebuilt, and each section (global parameters, definitions,
template, and attributes) is correctly parsed and assigned to the corresponding parts of the <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code>
instance.</li>
</ul>
<h2 id="pizzadscript-save-file-format">PIZZA.DSCRIPT SAVE FILE FORMAT</h2>
<p>This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
and control attributes can be defined in a flexible manner.</p>
<h3 id="mandatory-first-line">Mandatory First Line:</h3>
<p>Every DSCRIPT file must begin with the following line:
# DSCRIPT SAVE FILE</p>
<h3 id="structure-overview">Structure Overview:</h3>
<ol>
<li>
<p><strong>Global Parameters Section (Optional):</strong></p>
<ul>
<li>This section defines global script settings, enclosed within curly braces <code>{ }</code>.</li>
<li>Properties include:<ul>
<li><code>SECTIONS</code>: List of section names to be considered (e.g., <code>["DYNAMIC"]</code>).</li>
<li><code>section</code>: Current section index (e.g., <code>0</code>).</li>
<li><code>position</code>: Current script position in the order.</li>
<li><code>role</code>: Defines the role of the script instance (e.g., <code>"dscript instance"</code>).</li>
<li><code>description</code>: A short description of the script (e.g., <code>"dynamic script"</code>).</li>
<li><code>userid</code>: Identifier for the user (e.g., <code>"dscript"</code>).</li>
<li><code>version</code>: Script version (e.g., <code>0.1</code>).</li>
<li><code>verbose</code>: Verbosity flag, typically a boolean (e.g., <code>False</code>).</li>
</ul>
</li>
</ul>
<p>Example:
<code>{
SECTIONS = ['INITIALIZATION', 'SIMULATION']
# Global script parameters
}</code></p>
</li>
<li>
<p><strong>Definitions Section:</strong></p>
<ul>
<li>Variables are defined in Python-like syntax, allowing for dynamic variable substitution.</li>
<li>Variables can be numbers, strings, or lists, and they can include placeholders using <code>$</code>
to delay execution or substitution.</li>
</ul>
<p>Example:
<code>d = 3
# Define a number
periodic = "$p"
# '$' prevents immediate evaluation of 'p'
units = "$metal"
# '$' prevents immediate evaluation of 'metal'
dimension = "${d}"
# Variable substitution
boundary = ['p', 'p', 'p']
# List with a mix of variables and values
atom_style = "$atomic"
# String variable with delayed evaluation</code></p>
</li>
<li>
<p><strong>Templates Section:</strong></p>
<ul>
<li>This section provides a mapping between keys and their corresponding commands or instructions.</li>
<li>The templates reference variables defined in the <strong>Definitions</strong> section or elsewhere.</li>
<li>Syntax:
<code>KEY: INSTRUCTION</code>
where:<ul>
<li><code>KEY</code> can be numeric or alphanumeric.</li>
<li><code>INSTRUCTION</code> represents a command template, often referring to variables using <code>${variable}</code> notation.</li>
</ul>
</li>
</ul>
<p>Example:
<code>units: units ${units}
# Template uses the 'units' variable
dim: dimension ${dimension}
# Template for setting the dimension
bound: boundary ${boundary}
# Template for boundary settings
lattice: lattice ${lattice}
# Lattice template</code></p>
</li>
<li>
<p><strong>Attributes Section:</strong></p>
<ul>
<li>Each template line can have customizable attributes to control behavior and conditions.</li>
<li>Default attributes include:<ul>
<li><code>facultative</code>: If <code>True</code>, the line is optional and can be removed if needed.</li>
<li><code>eval</code>: If <code>True</code>, the line will be evaluated with Python's <code>eval()</code> function.</li>
<li><code>readonly</code>: If <code>True</code>, the line cannot be modified later in the script.</li>
<li><code>condition</code>: An expression that must be satisfied for the line to be included.</li>
<li><code>condeval</code>: If <code>True</code>, the condition will be evaluated using <code>eval()</code>.</li>
<li><code>detectvar</code>: If <code>True</code>, this creates variables in the <strong>Definitions</strong> section if they do not exist.</li>
</ul>
</li>
</ul>
<p>Example:
<code>units: {facultative=False, eval=False, readonly=False, condition="${units}", condeval=False, detectvar=True}
dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}</code></p>
</li>
</ol>
<h2 id="note-on-multiple-definitions">Note On Multiple Definitions</h2>
<p>This example demonstrates how variables defined in the <code>Definitions</code> section are handled for each template.
Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
can use different values for the same variable if redefined.</p>
<p>content = "" "</p>
<h1 id="dscript-save-file">DSCRIPT SAVE FILE</h1>
<h1 id="definitions">Definitions</h1>
<p>var = 10</p>
<h1 id="template-ky1">Template ky1</h1>
<p>key1: Template content with ${var}</p>
<h1 id="definitions_1">Definitions</h1>
<p>var = 20</p>
<h1 id="template-key2">Template key2</h1>
<p>key2: Template content with ${var}</p>
<h1 id="template-key3">Template key3</h1>
<p>key3:[
this is an underfined variable ${var31}
this is an another underfined variable ${var32}
this variables is defined
${var}
]</p>
<p>"" "</p>
<h1 id="parse-content-using-parsesyntax">Parse content using parsesyntax()</h1>
<p>ds = dscript.parsesyntax(content)</p>
<h1 id="key1-should-use-the-first-definition-of-var-10">Key1 should use the first definition of 'var' (10)</h1>
<p>print(ds.key1.definitions.var)
# Output: Template content with 10</p>
<h1 id="key2-should-use-the-updated-definition-of-var-20">Key2 should use the updated definition of 'var' (20)</h1>
<p>print(ds.key2.definitions.var)
# Output: Template content with 10</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parsesyntax_legacy(cls, content, name=None, numerickeys=True):
    &#34;&#34;&#34;
    Parse a script from a string content.
    [ ------------------------------------------------------]
    [ Legacy parsesyntax method for backward compatibility. ]
    [ ------------------------------------------------------]

    Parameters
    ----------
    content : str
        The string content of the script to be parsed.

    name : str
        The name of the dscript project (if None, it is set randomly)

    numerickeys : bool, default=True
        If True, numeric string keys in the template section are automatically converted into integers.

    Returns
    -------
    dscript
        A new `dscript` instance populated with the content of the loaded file.

    Raises
    ------
    ValueError
        If content does not start with the correct DSCRIPT header or the file format is invalid.

    Notes
    -----
    - The file is expected to follow the same structured format as the one produced by the `save()` method.
    - The method processes global parameters, definitions, template lines/items, and attributes. If the file
      includes numeric keys as strings (e.g., &#34;0&#34;, &#34;1&#34;), they can be automatically converted into integers
      if `numerickeys=True`.
    - The script structure is dynamically rebuilt, and each section (global parameters, definitions,
      template, and attributes) is correctly parsed and assigned to the corresponding parts of the `dscript`
      instance.


    PIZZA.DSCRIPT SAVE FILE FORMAT
    -------------------------------
    This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
    and control attributes can be defined in a flexible manner.

    ### Mandatory First Line:
    Every DSCRIPT file must begin with the following line:
        # DSCRIPT SAVE FILE

    ### Structure Overview:

    1. **Global Parameters Section (Optional):**
        - This section defines global script settings, enclosed within curly braces `{ }`.
        - Properties include:
            - `SECTIONS`: List of section names to be considered (e.g., `[&#34;DYNAMIC&#34;]`).
            - `section`: Current section index (e.g., `0`).
            - `position`: Current script position in the order.
            - `role`: Defines the role of the script instance (e.g., `&#34;dscript instance&#34;`).
            - `description`: A short description of the script (e.g., `&#34;dynamic script&#34;`).
            - `userid`: Identifier for the user (e.g., `&#34;dscript&#34;`).
            - `version`: Script version (e.g., `0.1`).
            - `verbose`: Verbosity flag, typically a boolean (e.g., `False`).

        Example:
        ```
        {
            SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;]  # Global script parameters
        }
        ```

    2. **Definitions Section:**
        - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
        - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
          to delay execution or substitution.

        Example:
        ```
        d = 3                               # Define a number
        periodic = &#34;$p&#34;                     # &#39;$&#39; prevents immediate evaluation of &#39;p&#39;
        units = &#34;$metal&#34;                    # &#39;$&#39; prevents immediate evaluation of &#39;metal&#39;
        dimension = &#34;${d}&#34;                  # Variable substitution
        boundary = [&#39;p&#39;, &#39;p&#39;, &#39;p&#39;]  # List with a mix of variables and values
        atom_style = &#34;$atomic&#34;              # String variable with delayed evaluation
        ```

    3. **Templates Section:**
        - This section provides a mapping between keys and their corresponding commands or instructions.
        - The templates reference variables defined in the **Definitions** section or elsewhere.
        - Syntax:
            ```
            KEY: INSTRUCTION
            ```
            where:
            - `KEY` can be numeric or alphanumeric.
            - `INSTRUCTION` represents a command template, often referring to variables using `${variable}` notation.

        Example:
        ```
        units: units ${units}               # Template uses the &#39;units&#39; variable
        dim: dimension ${dimension}         # Template for setting the dimension
        bound: boundary ${boundary}         # Template for boundary settings
        lattice: lattice ${lattice}         # Lattice template
        ```

    4. **Attributes Section:**
        - Each template line can have customizable attributes to control behavior and conditions.
        - Default attributes include:
            - `facultative`: If `True`, the line is optional and can be removed if needed.
            - `eval`: If `True`, the line will be evaluated with Python&#39;s `eval()` function.
            - `readonly`: If `True`, the line cannot be modified later in the script.
            - `condition`: An expression that must be satisfied for the line to be included.
            - `condeval`: If `True`, the condition will be evaluated using `eval()`.
            - `detectvar`: If `True`, this creates variables in the **Definitions** section if they do not exist.

        Example:
        ```
        units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
        dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
        ```

    Note on multiple definitions
    -----------------------------
    This example demonstrates how variables defined in the `Definitions` section are handled for each template.
    Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
    can use different values for the same variable if redefined.

    content = &#34;&#34; &#34;
    # DSCRIPT SAVE FILE

    # Definitions
    var = 10

    # Template ky1
    key1: Template content with ${var}

    # Definitions
    var = 20

    # Template key2
    key2: Template content with ${var}

    # Template key3
    key3:[
        this is an underfined variable ${var31}
        this is an another underfined variable ${var32}
        this variables is defined  ${var}
        ]

    &#34;&#34; &#34;

    # Parse content using parsesyntax()
    ds = dscript.parsesyntax(content)

    # Key1 should use the first definition of &#39;var&#39; (10)
    print(ds.key1.definitions.var)  # Output: Template content with 10

    # Key2 should use the updated definition of &#39;var&#39; (20)
    print(ds.key2.definitions.var)  # Output: Template content with 10


    &#34;&#34;&#34;

    # Split the content into lines
    lines = content.splitlines()
    lines = [line for line in lines if line.strip()]  # Remove blank or empty lines
    # Raise an error if no content is left after removing blank lines
    if not lines:
        raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

    # Initialize containers for global parameters, definitions, templates, and attributes
    global_params = {}
    definitions = lambdaScriptdata()
    template = {}
    attributes = {}

    # State variables to handle multi-line global parameters and attributes
    inside_global_params = False
    inside_attributes = False
    current_attr_key = None  # Ensure this is properly initialized
    global_params_content = &#34;&#34;
    inside_template_block = False  # Track if we are inside a multi-line template
    current_template_key = None    # Track the current template key
    current_template_content = []  # Store lines for the current template content

    # Step 1: Authenticate the file
    if not lines[0].strip().startswith(&#34;# DSCRIPT SAVE FILE&#34;):
        raise ValueError(&#34;File/Content is not a valid DSCRIPT file.&#34;)

    # Step 2: Process each line dynamically
    for line in lines[1:]:
        stripped = line.strip()

        # Ignore empty lines and comments
        if not stripped or stripped.startswith(&#34;#&#34;):
            continue

        # Remove trailing comments
        stripped = remove_comments(stripped)

        # Step 3: Handle global parameters inside {...}
        if stripped.startswith(&#34;{&#34;):
            # Found the opening {, start accumulating global parameters
            inside_global_params = True
            # Remove the opening { and accumulate the remaining content
            global_params_content = stripped[stripped.index(&#39;{&#39;) + 1:].strip()

            # Check if the closing } is also on the same line
            if &#39;}&#39; in global_params_content:
                global_params_content = global_params_content[:global_params_content.index(&#39;}&#39;)].strip()
                inside_global_params = False  # We found the closing } on the same line
                # Now parse the global parameters block
                cls._parse_global_params(global_params_content.strip(), global_params)
                global_params_content = &#34;&#34;  # Reset for the next block
            continue

        if inside_global_params:
            # Accumulate content until the closing } is found
            if stripped.endswith(&#34;}&#34;):
                # Found the closing }, accumulate and process the entire block
                global_params_content += &#34; &#34; + stripped[:stripped.index(&#39;}&#39;)].strip()
                inside_global_params = False  # Finished reading global parameters block

                # Now parse the entire global parameters block
                cls._parse_global_params(global_params_content.strip(), global_params)
                global_params_content = &#34;&#34;  # Reset for the next block if necessary
            else:
                # Continue accumulating if } is not found
                global_params_content += &#34; &#34; + stripped
            continue

        # Step 4: Detect the start of a multi-line template block inside [...]
        if not inside_template_block:
            template_match = re.match(r&#39;(\w+)\s*:\s*\[&#39;, stripped)
            if template_match:
                current_template_key = template_match.group(1)  # Capture the key
                inside_template_block = True
                current_template_content = []  # Reset content list
                continue

        # If inside a template block, accumulate lines until we find the closing ]
        if inside_template_block:
            if stripped == &#34;]&#34;:
                # End of the template block, join the content and store it
                template[current_template_key] = ScriptTemplate(
                    current_template_content,
                    definitions=lambdaScriptdata(**definitions),  # Clone current global definitions
                    verbose=True,
                    userid=current_template_key
                    )
                template[current_template_key].refreshvar()
                inside_template_block = False
                current_template_key = None
                current_template_content = []
            else:
                # Accumulate the current line (without surrounding spaces)
                current_template_content.append(stripped)
            continue

        # Step 5: Handle attributes inside {...}
        if inside_attributes and stripped.endswith(&#34;}&#34;):
            # Finish processing attributes for the current key
            cls._parse_attributes(attributes[current_attr_key], stripped[:-1])  # Remove trailing }
            inside_attributes = False
            current_attr_key = None
            continue

        if inside_attributes:
            # Continue accumulating attributes
            cls._parse_attributes(attributes[current_attr_key], stripped)
            continue

        # Step 6: Determine if the line is a definition, template, or attribute
        definition_match = re.match(r&#39;(\w+)\s*=\s*(.+)&#39;, stripped)
        template_match = re.match(r&#39;(\w+)\s*:\s*(?!\s*\{.*\}\s*$)(.+)&#39;, stripped) # template_match = re.match(r&#39;(\w+)\s*:\s*(?!\{)(.+)&#39;, stripped)
        attribute_match = re.match(r&#39;(\w+)\s*:\s*\{\s*(.+)\s*\}&#39;, stripped)       # attribute_match = re.match(r&#39;(\w+)\s*:\s*\{(.+)\}&#39;, stripped)

        if definition_match:
            # Line is a definition (key=value)
            key, value = definition_match.groups()
            definitions.setattr(key,cls._convert_value(value))

        elif template_match and not inside_template_block:
            # Line is a template (key: content)
            key, content = template_match.groups()
            template[key] = ScriptTemplate(
                content,
                definitions=lambdaScriptdata(**definitions),  # Clone current definitions
                verbose=True,
                userid=current_template_key)
            template[key].refreshvar()

        elif attribute_match:
            # Line is an attribute (key:{attributes...})
            current_attr_key, attr_content = attribute_match.groups()
            attributes[current_attr_key] = {}
            cls._parse_attributes(attributes[current_attr_key], attr_content)
            inside_attributes = not stripped.endswith(&#34;}&#34;)

    # Step 7: Validation and Reconstruction
    # Make sure there are no attributes without a template entry
    for key in attributes:
        if key not in template:
            raise ValueError(f&#34;Attributes found for undefined template key: {key}&#34;)
        # Apply attributes to the corresponding template object
        for attr_name, attr_value in attributes[key].items():
            setattr(template[key], attr_name, attr_value)

    # Step 7: Create and return a new dscript instance
    if name is None:
        name = autoname(8)
    instance = cls(
        name = name,
        SECTIONS=global_params.get(&#39;SECTIONS&#39;, [&#39;DYNAMIC&#39;]),
        section=global_params.get(&#39;section&#39;, 0),
        position=global_params.get(&#39;position&#39;, 0),
        role=global_params.get(&#39;role&#39;, &#39;dscript instance&#39;),
        description=global_params.get(&#39;description&#39;, &#39;dynamic script&#39;),
        userid=global_params.get(&#39;userid&#39;, &#39;dscript&#39;),
        version=global_params.get(&#39;version&#39;, 0.1),
        verbose=global_params.get(&#39;verbose&#39;, False)
    )


    # Convert numeric string keys to integers if numerickeys is True
    if numerickeys:
        numeric_template = {}
        for key, value in template.items():
            # Check if the key is a numeric string
            if key.isdigit():
                numeric_template[int(key)] = value
            else:
                numeric_template[key] = value
        template = numeric_template

    # Set definitions and template
    instance.DEFINITIONS = definitions
    instance.TEMPLATE = template

    # Refresh variables (ensure that variables are detected and added to definitions)
    instance.set_all_variables()

    # Check eval
    instance.check_all_variables(verbose=False)

    # return the new instance
    return instance</code></pre>
</details>
</dd>
<dt id="dscript.dscript.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>scriptcontent, filename=None, foldername=None, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the provided script content to a specified file in a given folder, with a header if necessary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scriptcontent</code></strong> :&ensp;<code>str</code></dt>
<dd>The content to be written to the file.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the file. If not provided, a random name will be generated.
The extension <code>.txt</code> will be appended if not already present.</dd>
<dt><strong><code>foldername</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The folder where the file will be saved. If not provided, the current working directory is used.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If False (default), raises a <code>FileExistsError</code> if the file already exists. If True, the file will be overwritten if it exists.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The full path to the written file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and <code>overwrite</code> is set to False.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>A header is prepended to the content if it does not already exist, using the <code>header</code> method.</li>
<li>The header includes metadata such as the current date, username, hostname, and file details.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write(scriptcontent, filename=None, foldername=None, overwrite=False):
    &#34;&#34;&#34;
    Writes the provided script content to a specified file in a given folder, with a header if necessary.

    Parameters
    ----------
    scriptcontent : str
        The content to be written to the file.

    filename : str, optional
        The name of the file. If not provided, a random name will be generated.
        The extension `.txt` will be appended if not already present.

    foldername : str, optional
        The folder where the file will be saved. If not provided, the current working directory is used.

    overwrite : bool, optional
        If False (default), raises a `FileExistsError` if the file already exists. If True, the file will be overwritten if it exists.

    Returns
    -------
    str
        The full path to the written file.

    Raises
    ------
    FileExistsError
        If the file already exists and `overwrite` is set to False.

    Notes
    -----
    - A header is prepended to the content if it does not already exist, using the `header` method.
    - The header includes metadata such as the current date, username, hostname, and file details.
    &#34;&#34;&#34;
    # Generate a random name if filename is not provided
    if filename is None:
        filename = autoname(8)  # Generates a random name of 8 letters

    # Ensure the filename ends with &#39;.txt&#39;
    if not filename.endswith(&#39;.txt&#39;):
        filename += &#39;.txt&#39;

    # Handle foldername and relative paths
    if foldername is None or foldername == &#34;&#34;:
        # If foldername is empty or None, use current working directory for relative paths
        if not os.path.isabs(filename):
            filepath = os.path.join(os.getcwd(), filename)
        else:
            filepath = filename  # If filename is absolute, use it directly
    else:
        # If foldername is provided and filename is not absolute, use foldername
        if not os.path.isabs(filename):
            filepath = os.path.join(foldername, filename)
        else:
            filepath = filename

    # Check if file already exists, raise exception if it does and overwrite is False
    if os.path.exists(filepath) and not overwrite:
        raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

    # Count total and non-empty lines in the content
    total_lines = len(scriptcontent.splitlines())
    non_empty_lines = sum(1 for line in scriptcontent.splitlines() if line.strip())

    # Prepare header if not already present
    if not scriptcontent.startswith(&#34;# DSCRIPT SAVE FILE&#34;):
        fname = os.path.basename(filepath)  # Extracts the filename (e.g., &#34;myscript.txt&#34;)
        name, _ = os.path.splitext(fname)   # Removes the extension, e.g., &#34;myscript&#34;
        metadata = get_metadata()           # retrieve all metadata (statically)
        header = dscript.header(name=name, verbosity=True,style=1,filepath=filepath,
                version = metadata[&#34;version&#34;], license = metadata[&#34;license&#34;], email = metadata[&#34;email&#34;])
        # Add line count information to the header
        footer = frame_header(
            lines=[
                f&#34;Total lines written: {total_lines}&#34;,
                f&#34;Non-empty lines: {non_empty_lines}&#34;
            ],
            style=1
        )
        scriptcontent = header + &#34;\n&#34; + scriptcontent + &#34;\n&#34; + footer

    # Write the content to the file
    with open(filepath, &#39;w&#39;) as file:
        file.write(scriptcontent)
    return filepath</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dscript.dscript.add_dynamic_script"><code class="name flex">
<span>def <span class="ident">add_dynamic_script</span></span>(<span>self, key, content='', userid=None, definitions=None, verbose=None, autorefresh=True, **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a dynamic script step to the dscript object.</p>
<h2 id="parameters">Parameters:</h2>
<p>key : str
The key for the dynamic script (usually an index or step identifier).
content : str or list of str, optional
The content (template) of the script step.
definitions : lambdaScriptdata, optional
The merged variable space (STATIC + GLOBAL + LOCAL).
verbose : bool, optional
If None, self.verbose will be used. Controls verbosity of the template.
autorefresh : bool, optional
If True, detected variables (e.g., var) and undefined are assiged to their default value (e.g., ${var})
Default = True
USER : dict
Additional user variables that override the definitions for this step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dynamic_script(self, key, content=&#34;&#34;, userid=None, definitions=None, verbose=None, autorefresh=True, **USER):
    &#34;&#34;&#34;
    Add a dynamic script step to the dscript object.

    Parameters:
    -----------
    key : str
        The key for the dynamic script (usually an index or step identifier).
    content : str or list of str, optional
        The content (template) of the script step.
    definitions : lambdaScriptdata, optional
        The merged variable space (STATIC + GLOBAL + LOCAL).
    verbose : bool, optional
        If None, self.verbose will be used. Controls verbosity of the template.
    autorefresh : bool, optional
        If True, detected variables (e.g., var) and undefined are assiged to their default value (e.g., ${var})
        Default = True
    USER : dict
        Additional user variables that override the definitions for this step.
    &#34;&#34;&#34;
    if definitions is None:
        definitions = lambdaScriptdata()
    if verbose is None:
        verbose = self.verbose
    # Create a new ScriptTemplate and add it to the TEMPLATE
    self.TEMPLATE[key] = ScriptTemplate(
        content=content,
        definitions=self.DEFINITIONS+definitions,
        verbose=verbose,
        userid = key if userid is None else userid,
        autorefresh=autorefresh,
        **USER
    )</code></pre>
</details>
</dd>
<dt id="dscript.dscript.check_all_variables"><code class="name flex">
<span>def <span class="ident">check_all_variables</span></span>(<span>self, verbose=True, seteval=True, output=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks for undefined variables for each TEMPLATE key in the dscript object.</p>
<h2 id="parameters">Parameters:</h2>
<p>verbose : bool, optional, default=True
If True, prints information about variables for each TEMPLATE key.
Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.</p>
<p>seteval : bool, optional, default=True
If True, sets the <code>eval</code> attribute to True if at least one variable is defined or set to its default value.</p>
<p>output : bool, optional, default=False
If True, returns a dictionary with lists of default variables, set variables, and undefined variables.</p>
<h2 id="returns">Returns:</h2>
<p>out : dict, optional
If <code>output=True</code>, returns a dictionary with the following structure:
- "defaultvalues": List of variables set to their default value (${varname}).
- "setvalues": List of variables defined with values other than their default.
- "undefined": List of variables that are undefined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_all_variables(self, verbose=True, seteval=True, output=False):
    &#34;&#34;&#34;
    Checks for undefined variables for each TEMPLATE key in the dscript object.

    Parameters:
    -----------
    verbose : bool, optional, default=True
        If True, prints information about variables for each TEMPLATE key.
        Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.

    seteval : bool, optional, default=True
        If True, sets the `eval` attribute to True if at least one variable is defined or set to its default value.

    output : bool, optional, default=False
        If True, returns a dictionary with lists of default variables, set variables, and undefined variables.

    Returns:
    --------
    out : dict, optional
        If `output=True`, returns a dictionary with the following structure:
        - &#34;defaultvalues&#34;: List of variables set to their default value (${varname}).
        - &#34;setvalues&#34;: List of variables defined with values other than their default.
        - &#34;undefined&#34;: List of variables that are undefined.
    &#34;&#34;&#34;
    out = {&#34;defaultvalues&#34;: [], &#34;setvalues&#34;: [], &#34;undefined&#34;: []}

    for key in self.TEMPLATE:
        template = self.TEMPLATE[key]
        # Call the check_variables method of ScriptTemplate for each TEMPLATE key
        result = template.check_variables(verbose=verbose, seteval=seteval)

        # Update the output dictionary if needed
        out[&#34;defaultvalues&#34;].extend(result[&#34;defaultvalues&#34;])
        out[&#34;setvalues&#34;].extend(result[&#34;setvalues&#34;])
        out[&#34;undefined&#34;].extend(result[&#34;undefined&#34;])

    if output:
        return out</code></pre>
</details>
</dd>
<dt id="dscript.dscript.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, behavior='fixing', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean the TEMPLATE by removing or fixing empty steps.</p>
<p>An empty step is defined as one where its content is [], "", or None.</p>
<h2 id="parameters">Parameters</h2>
<p>behavior (str, optional):
Determines the action to perform on empty steps.
- 'removing': Completely remove the empty step from TEMPLATE.
- 'fixing': Replace the content of the empty step with a comment.
Defaults to 'fixing'.
verbose (bool, optional):
If True, prints informational messages about the actions taken.
If False, operates silently.
Defaults to False.</p>
<h2 id="raises">Raises</h2>
<p>ValueError:
If the provided behavior is not 'removing' or 'fixing'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, behavior=&#39;fixing&#39;, verbose=False):
    &#34;&#34;&#34;
    Clean the TEMPLATE by removing or fixing empty steps.

    An empty step is defined as one where its content is [], &#34;&#34;, or None.

    Parameters:
        behavior (str, optional):
            Determines the action to perform on empty steps.
            - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
            - &#39;fixing&#39;: Replace the content of the empty step with a comment.
            Defaults to &#39;fixing&#39;.
        verbose (bool, optional):
            If True, prints informational messages about the actions taken.
            If False, operates silently.
            Defaults to False.

    Raises:
        ValueError:
            If the provided behavior is not &#39;removing&#39; or &#39;fixing&#39;.
    &#34;&#34;&#34;
    # Validate the &#39;behavior&#39; parameter
    if behavior not in {&#39;removing&#39;, &#39;fixing&#39;}:
        raise ValueError(&#34;Parameter &#39;behavior&#39; must be either &#39;removing&#39; or &#39;fixing&#39;.&#34;)

    # Iterate over a list of keys to avoid RuntimeError due to dict size change during iteration
    for key in list(self.TEMPLATE.keys()):
        step = self.TEMPLATE[key]
        content = step.content

        # Check if the step is empty
        if content in [[], &#34;&#34;, None,[&#34;&#34;],[None],[[]]]:
            if behavior == &#39;removing&#39;:
                # Remove the step entirely from TEMPLATE
                del self.TEMPLATE[key]
                if verbose:
                    print(f&#34;Removed empty step: {key}&#34;)
            elif behavior == &#39;fixing&#39;:
                # Replace the content with a default comment
                step.content = [f&#34;# empty &lt;step {key}&gt;&#34;]
                if verbose:
                    print(f&#34;Fixed empty step: {key} by adding a comment.&#34;)</code></pre>
</details>
</dd>
<dt id="dscript.dscript.createEmptyVariables"><code class="name flex">
<span>def <span class="ident">createEmptyVariables</span></span>(<span>self, vars)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates empty variables in DEFINITIONS if they don't already exist.</p>
<h2 id="parameters">Parameters:</h2>
<p>vars : str or list of str
The variable name or list of variable names to be created in DEFINITIONS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createEmptyVariables(self, vars):
    &#34;&#34;&#34;
    Creates empty variables in DEFINITIONS if they don&#39;t already exist.

    Parameters:
    -----------
    vars : str or list of str
        The variable name or list of variable names to be created in DEFINITIONS.
    &#34;&#34;&#34;
    if isinstance(vars, str):
        vars = [vars]  # Convert single variable name to list for uniform processing
    for varname in vars:
        if varname not in self.DEFINITIONS:
            self.DEFINITIONS.setattr(varname,&#34;${&#34; + varname + &#34;}&#34;)</code></pre>
</details>
</dd>
<dt id="dscript.dscript.detect_all_variables"><code class="name flex">
<span>def <span class="ident">detect_all_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects all variables across all templates in the dscript object.</p>
<p>This method iterates through all ScriptTemplate objects in the dscript and
collects variables from each template using the detect_variables method.</p>
<h2 id="returns">Returns:</h2>
<p>list
A sorted list of unique variables detected in all templates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_all_variables(self):
    &#34;&#34;&#34;
    Detects all variables across all templates in the dscript object.

    This method iterates through all ScriptTemplate objects in the dscript and
    collects variables from each template using the detect_variables method.

    Returns:
    --------
    list
        A sorted list of unique variables detected in all templates.
    &#34;&#34;&#34;
    all_variables = set()  # Use a set to avoid duplicates
    # Iterate through all templates in the dscript object
    for template_key, template in self.TEMPLATE.items():
        # Ensure the template is a ScriptTemplate and has the detect_variables method
        if isinstance(template, ScriptTemplate):
            detected_vars = template.detect_variables()
            all_variables.update(detected_vars)  # Add the detected variables to the set
    return sorted(all_variables)  # Return a sorted list of unique variables</code></pre>
</details>
</dd>
<dt id="dscript.dscript.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, printflag=None, verbose=None, softrun=False, return_definitions=False, comment_chars='#%', **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes or previews all <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> instances in <code>TEMPLATE</code>, concatenating their processed content.
Allows for optional headers and footers based on verbosity settings, and offers a preliminary preview mode with <code>softrun</code>.
Accumulates definitions across all templates if <code>return_definitions=True</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>printflag</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, enables print output during execution. Defaults to the instance's print flag if <code>None</code>.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, includes headers and footers in the output, providing additional detail.
Defaults to the instance's verbosity setting if <code>None</code>.</dd>
<dt><strong><code>softrun</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, executes the script in a preliminary mode:
- Bypasses full variable substitution for a preview of the content, useful for validating structure.
- If <code>False</code> (default), performs full processing, including variable substitutions and evaluations.</dd>
<dt><strong><code>return_definitions</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, returns a tuple where the second element contains accumulated definitions from all templates.
If <code>False</code> (default), returns only the concatenated output.</dd>
<dt><strong><code>comment_chars</code></strong> :&ensp;<code>str</code>, optional <code>(default: "#%")</code></dt>
<dd>A string containing characters to identify the start of a comment.
Any of these characters will mark the beginning of a comment unless within quotes.</dd>
<dt><strong><code>**USER</code></strong> :&ensp;<code>keyword arguments</code></dt>
<dd>Allows for the provision of additional user-defined definitions, where each keyword represents a
definition key and the associated value represents the definition's content. These definitions
can override or supplement template-level definitions during execution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>tuple</code></dt>
<dd>
<ul>
<li>If <code>return_definitions=False</code>, returns the concatenated output of all <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> instances,
with optional headers, footers, and execution summary based on verbosity.</li>
<li>If <code>return_definitions=True</code>, returns a tuple of (<code>output</code>, <code>accumulated_definitions</code>), where
<code>accumulated_definitions</code> contains all definitions used across templates.</li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Each <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> in <code>TEMPLATE</code> is processed individually using its own <code>do()</code> method.</li>
<li>The <code>softrun</code> mode provides a preliminary content preview without full variable substitution,
helpful for inspecting the script structure or gathering local definitions.</li>
<li>When <code>verbose</code> is enabled, the method includes detailed headers, footers, and a summary of processed and
ignored items, providing insight into the script's construction and variable usage.</li>
<li>Accumulated definitions from each <code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code> are combined if <code>return_definitions=True</code>, which can be
useful for tracking all variables and definitions applied across the templates.</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; dscript_instance = dscript(name=&quot;ExampleScript&quot;)
&gt;&gt;&gt; dscript_instance.TEMPLATE[0] = ScriptTemplate(
...     content=[&quot;units ${units}&quot;, &quot;boundary ${boundary}&quot;],
...     definitions=lambdaScriptdata(units=&quot;lj&quot;, boundary=&quot;p p p&quot;),
...     attributes={'eval': True}
... )
&gt;&gt;&gt; dscript_instance.do(verbose=True, units=&quot;real&quot;)
# Output:
# --------------
# TEMPLATE &quot;ExampleScript&quot;
# --------------
units real
boundary p p p
# ---&gt; Total items: 2 - Ignored items: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, printflag=None, verbose=None, softrun=False, return_definitions=False,comment_chars=&#34;#%&#34;, **USER):
    &#34;&#34;&#34;
    Executes or previews all `ScriptTemplate` instances in `TEMPLATE`, concatenating their processed content.
    Allows for optional headers and footers based on verbosity settings, and offers a preliminary preview mode with `softrun`.
    Accumulates definitions across all templates if `return_definitions=True`.

    Parameters
    ----------
    printflag : bool, optional
        If `True`, enables print output during execution. Defaults to the instance&#39;s print flag if `None`.
    verbose : bool, optional
        If `True`, includes headers and footers in the output, providing additional detail.
        Defaults to the instance&#39;s verbosity setting if `None`.
    softrun : bool, optional
        If `True`, executes the script in a preliminary mode:
        - Bypasses full variable substitution for a preview of the content, useful for validating structure.
        - If `False` (default), performs full processing, including variable substitutions and evaluations.
    return_definitions : bool, optional
        If `True`, returns a tuple where the second element contains accumulated definitions from all templates.
        If `False` (default), returns only the concatenated output.
    comment_chars : str, optional (default: &#34;#%&#34;)
        A string containing characters to identify the start of a comment.
        Any of these characters will mark the beginning of a comment unless within quotes.
    **USER : keyword arguments
        Allows for the provision of additional user-defined definitions, where each keyword represents a
        definition key and the associated value represents the definition&#39;s content. These definitions
        can override or supplement template-level definitions during execution.

    Returns
    -------
    str or tuple
        - If `return_definitions=False`, returns the concatenated output of all `ScriptTemplate` instances,
          with optional headers, footers, and execution summary based on verbosity.
        - If `return_definitions=True`, returns a tuple of (`output`, `accumulated_definitions`), where
          `accumulated_definitions` contains all definitions used across templates.

    Notes
    -----
    - Each `ScriptTemplate` in `TEMPLATE` is processed individually using its own `do()` method.
    - The `softrun` mode provides a preliminary content preview without full variable substitution,
      helpful for inspecting the script structure or gathering local definitions.
    - When `verbose` is enabled, the method includes detailed headers, footers, and a summary of processed and
      ignored items, providing insight into the script&#39;s construction and variable usage.
    - Accumulated definitions from each `ScriptTemplate` are combined if `return_definitions=True`, which can be
      useful for tracking all variables and definitions applied across the templates.

    Example
    -------
    &gt;&gt;&gt; dscript_instance = dscript(name=&#34;ExampleScript&#34;)
    &gt;&gt;&gt; dscript_instance.TEMPLATE[0] = ScriptTemplate(
    ...     content=[&#34;units ${units}&#34;, &#34;boundary ${boundary}&#34;],
    ...     definitions=lambdaScriptdata(units=&#34;lj&#34;, boundary=&#34;p p p&#34;),
    ...     attributes={&#39;eval&#39;: True}
    ... )
    &gt;&gt;&gt; dscript_instance.do(verbose=True, units=&#34;real&#34;)
    # Output:
    # --------------
    # TEMPLATE &#34;ExampleScript&#34;
    # --------------
    units real
    boundary p p p
    # ---&gt; Total items: 2 - Ignored items: 0
    &#34;&#34;&#34;

    printflag = self.printflag if printflag is None else printflag
    verbose = self.verbose if verbose is None else verbose
    header = f&#34;# --------------[ TEMPLATE \&#34;{self.name}\&#34; ]--------------&#34; if verbose else &#34;&#34;
    footer = &#34;# --------------------------------------------&#34; if verbose else &#34;&#34;

    # Initialize output, counters, and optional definitions accumulator
    output = [header]
    non_empty_lines = 0
    ignored_lines = 0
    accumulated_definitions = self.DEFINITIONS if return_definitions else None

    for key, template in self.TEMPLATE.items():
        # Process each template with softrun if enabled, otherwise use full processing
        result = template.do(softrun=softrun,globaldefinitions=self.DEFINITIONS,USER=lambdaScriptdata(**USER))
        if result:
            # Apply comment removal based on verbosity
            final_result = result if verbose else remove_comments(result,comment_chars=comment_chars)
            if final_result or verbose:
                output.append(final_result)
                non_empty_lines += 1
            else:
                ignored_lines += 1
            # Accumulate definitions if return_definitions is enabled
            if return_definitions:
                accumulated_definitions += template.definitions
        else:
            ignored_lines += 1

    # Add footer summary if verbose
    nel_word = &#39;items&#39; if non_empty_lines &gt; 1 else &#39;item&#39;
    il_word = &#39;items&#39; if ignored_lines &gt; 1 else &#39;item&#39;
    footer += f&#34;\n# ---&gt; Total {nel_word}: {non_empty_lines} - Ignored {il_word}: {ignored_lines}&#34; if verbose else &#34;&#34;
    output.append(footer)

    # Concatenate output and determine return type based on return_definitions
    output_content = &#34;\n&#34;.join(output)
    return (output_content, accumulated_definitions) if return_definitions else output_content</code></pre>
</details>
</dd>
<dt id="dscript.dscript.flattenvariables"><code class="name flex">
<span>def <span class="ident">flattenvariables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flatten the variable definitions for each step based on usage and precedence.</p>
<p>This method ensures that for each step:
- Only the variables used in the template are present in <code>self[i].definitions</code>.
- The value of each variable is determined based on the following precedence:
1. Global Definitions (<code>self.DEFINITIONS</code>)
2. Current Step Definitions (<code>self[i].definitions</code>)
3. Previous Step Definitions (<code>self[i-1].definitions</code>, etc.)
4. Protected Variables (<code>"$variable_name"</code>)</p>
<p>The method updates <code>self[i].definitions</code> to include only the necessary variables with their resolved values.
Unused variables are removed from each step's definitions after resolution, <strong>excluding</strong> protected attributes.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If a step or global definitions lack the necessary attributes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flattenvariables(self):
    &#34;&#34;&#34;
    Flatten the variable definitions for each step based on usage and precedence.

    This method ensures that for each step:
        - Only the variables used in the template are present in `self[i].definitions`.
        - The value of each variable is determined based on the following precedence:
            1. Global Definitions (`self.DEFINITIONS`)
            2. Current Step Definitions (`self[i].definitions`)
            3. Previous Step Definitions (`self[i-1].definitions`, etc.)
            4. Protected Variables (`&#34;$variable_name&#34;`)

    The method updates `self[i].definitions` to include only the necessary variables with their resolved values.
    Unused variables are removed from each step&#39;s definitions after resolution, **excluding** protected attributes.

    Raises:
        AttributeError: If a step or global definitions lack the necessary attributes.
    &#34;&#34;&#34;
    # Define the set of protected attributes that must never be removed
    excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

    # Initialize local_definitions with a copy of global definitions to prevent mutation
    local_definitions = lambdaScriptdata(**self.DEFINITIONS.__dict__)

    # Iterate through each step in order
    for i in range(len(self)):
        step = self[i]
        step_definitions = step.definitions

        # Detect variables used in the current step&#39;s template
        variables_used = step.detect_variables()

        # Temporary dictionary to store resolved variable values
        resolved_vars = {}

        # Resolve each variable&#39;s value based on precedence
        for var in variables_used:
            if hasattr(step_definitions, var):
                # Variable defined in the current step&#39;s definitions
                resolved_vars[var] = getattr(step_definitions, var)
            elif hasattr(local_definitions, var):
                # Variable inherited from previous definitions (global or prior steps)
                resolved_vars[var] = getattr(local_definitions, var)
            else:
                # Variable not found; assign protected format
                resolved_vars[var] = f&#34;${var}&#34;

        # Remove any variables in step_definitions not in variables_used and not in excluded_keys
        existing_vars = list(step_definitions.__dict__.keys())
        for var in existing_vars:
            if var not in variables_used and var not in excluded_keys:
                delattr(step_definitions, var)

        # Assign resolved variables to step_definitions
        for var, value in resolved_vars.items():
            setattr(step_definitions, var, value)

        # Update local_definitions by merging with step_definitions
        # Only variables used in this step are updated in local_definitions
        local_definitions = local_definitions + step_definitions</code></pre>
</details>
</dd>
<dt id="dscript.dscript.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>STR</code></dt>
<dd>generated code corresponding to dscript (using dscript syntax/language).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self):
    &#34;&#34;&#34;
    Returns
    -------
    STR
        generated code corresponding to dscript (using dscript syntax/language).

    &#34;&#34;&#34;
    return self.save(generatoronly=True)</code></pre>
</details>
</dd>
<dt id="dscript.dscript.get_attributes_by_index"><code class="name flex">
<span>def <span class="ident">get_attributes_by_index</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the attributes of the ScriptTemplate at the specified index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes_by_index(self, index):
    &#34;&#34;&#34; Returns the attributes of the ScriptTemplate at the specified index.&#34;&#34;&#34;
    key = list(self.TEMPLATE.keys())[index]
    return self.TEMPLATE[key].attributes</code></pre>
</details>
</dd>
<dt id="dscript.dscript.get_content_by_index"><code class="name flex">
<span>def <span class="ident">get_content_by_index</span></span>(<span>self, index, do=True, protected=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the content of the ScriptTemplate at the specified index.</p>
<h2 id="parameters">Parameters:</h2>
<p>index : int
The index of the template in the TEMPLATE dictionary.
do : bool, optional (default=True)
If True, the content will be processed based on conditions and evaluation flags.
protected : bool, optional (default=True)
Controls whether variable evaluation is protected (e.g., prevents overwriting certain definitions).</p>
<h2 id="returns">Returns:</h2>
<p>str or list of str
The content of the template after processing, or an empty string if conditions or evaluation flags block it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content_by_index(self, index, do=True, protected=True):
    &#34;&#34;&#34;
    Returns the content of the ScriptTemplate at the specified index.

    Parameters:
    -----------
    index : int
        The index of the template in the TEMPLATE dictionary.
    do : bool, optional (default=True)
        If True, the content will be processed based on conditions and evaluation flags.
    protected : bool, optional (default=True)
        Controls whether variable evaluation is protected (e.g., prevents overwriting certain definitions).

    Returns:
    --------
    str or list of str
        The content of the template after processing, or an empty string if conditions or evaluation flags block it.
    &#34;&#34;&#34;
    key = list(self.TEMPLATE.keys())[index]
    s = self.TEMPLATE[key].content
    att = self.TEMPLATE[key].attributes
    # Return an empty string if the facultative attribute is True and do is True
    if att[&#34;facultative&#34;] and do:
        return &#34;&#34;
    # Evaluate the condition (if any)
    if att[&#34;condition&#34;] is not None:
        cond = eval(self.DEFINITIONS.formateval(att[&#34;condition&#34;], protected))
    else:
        cond = True
    # If the condition is met, process the content
    if cond:
        # Apply formateval only if the eval attribute is True and do is True
        if att[&#34;eval&#34;] and do:
            if isinstance(s, list):
                # Apply formateval to each item in the list if s is a list
                return [self.DEFINITIONS.formateval(line, protected) for line in s]
            else:
                # Apply formateval to the single string content
                return self.DEFINITIONS.formateval(s, protected)
        else:
            return s  # Return the raw content if no evaluation is needed
    elif do:
        return &#34;&#34;  # Return an empty string if the condition is not met and do is True
    else:
        return s  # Return the raw content if do is False</code></pre>
</details>
</dd>
<dt id="dscript.dscript.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    return ((key, s.content) for key, s in self.TEMPLATE.items())</code></pre>
</details>
</dd>
<dt id="dscript.dscript.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the keys of the TEMPLATE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34;Return the keys of the TEMPLATE.&#34;&#34;&#34;
    return self.TEMPLATE.keys()</code></pre>
</details>
</dd>
<dt id="dscript.dscript.list_values"><code class="name flex">
<span>def <span class="ident">list_values</span></span>(<span>self, key, include_global=True, verbose=False, order='stable', details=False)</span>
</code></dt>
<dd>
<div class="desc"><p>List all unique values taken by a specified key across global definitions and all steps in sequential order.</p>
<h2 id="parameters">Parameters</h2>
<p>key (str): The key whose values are to be listed.
include_global (bool, optional): If True, include global definitions in the search. Defaults to True.
verbose (bool, optional): If True, print warnings about steps where the key is missing and list available keys. Defaults to False.
order (str, optional): The order in which to list the unique values. Options are 'stable', 'ascend', 'descend'. Defaults to 'stable'.
details (bool, optional): If True, return a VariableOccurrences object containing detailed occurrence information. If False, return a list or scalar as before. Defaults to False.</p>
<h2 id="returns">Returns</h2>
<p>list or scalar or VariableOccurrences or None:
- If <code>details=False</code>:
- Returns a list of unique values associated with the key, ordered as specified.
- If only one unique value exists, returns it as a scalar.
- Returns None if the key is not found in any global or step definitions.
- If <code>details=True</code>:
- Returns a VariableOccurrences object containing detailed occurrence information across scopes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_values(self, key, include_global=True, verbose=False, order=&#39;stable&#39;, details=False):
    &#34;&#34;&#34;
    List all unique values taken by a specified key across global definitions and all steps in sequential order.

    Parameters:
        key (str): The key whose values are to be listed.
        include_global (bool, optional): If True, include global definitions in the search. Defaults to True.
        verbose (bool, optional): If True, print warnings about steps where the key is missing and list available keys. Defaults to False.
        order (str, optional): The order in which to list the unique values. Options are &#39;stable&#39;, &#39;ascend&#39;, &#39;descend&#39;. Defaults to &#39;stable&#39;.
        details (bool, optional): If True, return a VariableOccurrences object containing detailed occurrence information. If False, return a list or scalar as before. Defaults to False.

    Returns:
        list or scalar or VariableOccurrences or None:
            - If `details=False`:
                - Returns a list of unique values associated with the key, ordered as specified.
                - If only one unique value exists, returns it as a scalar.
                - Returns None if the key is not found in any global or step definitions.
            - If `details=True`:
                - Returns a VariableOccurrences object containing detailed occurrence information across scopes.
    &#34;&#34;&#34;
    # Validate &#39;order&#39; parameter
    if order not in {&#39;stable&#39;, &#39;ascend&#39;, &#39;descend&#39;}:
        raise ValueError(&#34;Parameter &#39;order&#39; must be one of &#39;stable&#39;, &#39;ascend&#39;, or &#39;descend&#39;.&#34;)

    excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

    unique_values = []
    seen_values = set()

    available_keys_set = set()

    # Helper function to compare lists
    def lists_are_equal(list1, list2):
        return list1 == list2

    # Function to add a key_value to unique_values
    def add_value(kv):
        if isinstance(kv, list):
            # Convert list to tuple for hashability
            try:
                kv_tuple = tuple(kv)
                if kv_tuple not in seen_values:
                    unique_values.append(kv.copy())  # Append a copy to preserve the list
                    seen_values.add(kv_tuple)
            except TypeError:
                # If list contains unhashable items, compare manually
                if not any(lists_are_equal(kv, existing) for existing in unique_values if isinstance(existing, list)):
                    unique_values.append(kv.copy())
        else:
            if kv not in seen_values:
                unique_values.append(kv)
                seen_values.add(kv)

    # Data structures for detailed occurrences
    occurrences_data = defaultdict(list)  # {&#39;global&#39;: [value], &#39;local&#39;: [(step, value), ...]}

    # Include global definitions
    if include_global and hasattr(self.DEFINITIONS, key):
        key_value = getattr(self.DEFINITIONS, key)
        if isinstance(key_value, list):
            add_value(key_value)
            if details:
                occurrences_data[&#39;global&#39;] = key_value.copy()
        else:
            add_value(key_value)
            if details:
                occurrences_data[&#39;global&#39;] = key_value
    elif include_global and verbose:
        # Collect available keys in global definitions, excluding specified keys
        available_keys = [
            k for k in self.DEFINITIONS.__dict__
            if k != key and k not in excluded_keys
        ]
        available_keys_set.update(available_keys)

    # Traverse through steps
    for step_key, step in self.TEMPLATE.items():
        if hasattr(step.definitions, key):
            key_value = getattr(step.definitions, key)
            if isinstance(key_value, list):
                add_value(key_value)
                if details:
                    occurrences_data[&#39;local&#39;].append((step_key, key_value.copy()))
            else:
                add_value(key_value)
                if details:
                    occurrences_data[&#39;local&#39;].append((step_key, key_value))
        else:
            if verbose:
                # Collect available keys in this step, excluding specified keys
                available_keys = [
                    k for k in step.definitions.__dict__
                    if k != key and k not in excluded_keys
                ]
                available_keys_set.update(available_keys)

    # Verbose warnings
    if verbose and available_keys_set:
        available_keys_sorted = sorted(list(available_keys_set))
        print(f&#34;Warning: The key &#39;{key}&#39; is missing in some steps or global definitions.&#34;)
        print(f&#34;Available keys in those contexts: {available_keys_sorted}&#34;)

    # Ordering
    if order == &#39;stable&#39;:
        ordered_values = unique_values
    else:
        # To sort, ensure all elements are of the same type
        try:
            if all(isinstance(v, list) for v in unique_values):
                if order == &#39;ascend&#39;:
                    ordered_values = sorted(unique_values)
                else:
                    ordered_values = sorted(unique_values, reverse=True)
            elif all(isinstance(v, type(unique_values[0])) for v in unique_values):
                if order == &#39;ascend&#39;:
                    ordered_values = sorted(unique_values)
                else:
                    ordered_values = sorted(unique_values, reverse=True)
            else:
                raise TypeError
        except TypeError:
            if verbose:
                print(&#34;Warning: Cannot sort values due to mixed or non-comparable types. Returning values in their original order.&#34;)
            ordered_values = unique_values

    if details:
        # Prepare data for VariableOccurrences
        # Convert defaultdict to regular dict
        occurrences_dict = dict(occurrences_data)

        if key.lower() == &#34;all&#34;:
            # Collect all keys and their occurrences
            all_keys = set()
            # Include global definitions if specified
            if include_global:
                global_keys = set(self.DEFINITIONS.__dict__.keys()) - excluded_keys
                all_keys.update(global_keys)
            # Include keys from all steps
            for step in self.TEMPLATE.values():
                step_keys = set(step.definitions.__dict__.keys()) - excluded_keys
                all_keys.update(step_keys)

            # Remove the &#39;all&#39; key itself if present
            all_keys.discard(&#34;all&#34;)

            variables_data = {}
            for var in all_keys:
                var_data = defaultdict(list)
                # Include global definitions
                if include_global and hasattr(self.DEFINITIONS, var):
                    var_value = getattr(self.DEFINITIONS, var)
                    if isinstance(var_value, list):
                        var_data[&#39;global&#39;].append(var_value.copy())  # Directly append the value
                    else:
                        var_data[&#39;global&#39;].append(var_value)
                # Traverse through steps
                for step_key, step in self.TEMPLATE.items():
                    if hasattr(step.definitions, var):
                        var_value = getattr(step.definitions, var)
                        if isinstance(var_value, list):
                            var_data[&#39;local&#39;].append((step_key, var_value.copy()))
                        else:
                            var_data[&#39;local&#39;].append((step_key, var_value))
                variables_data[var] = dict(var_data)
            return VariableOccurrences(variables_data, variables=None)  # variables=None implies multiple variables

        else:
            # Single variable case
            return VariableOccurrences(occurrences_dict, variables=key)

    # Determine return value
    if not unique_values:
        if verbose:
            print(f&#34;No values found for key &#39;{key}&#39; in any step or global definitions.&#34;)
        return None
    elif len(unique_values) == 1:
        return unique_values[0]
    else:
        return ordered_values</code></pre>
</details>
</dd>
<dt id="dscript.dscript.pipescript"><code class="name flex">
<span>def <span class="ident">pipescript</span></span>(<span>self, *keys, printflag=None, verbose=None, verbosity=None, **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a pipescript object by combining script objects corresponding to the given keys.</p>
<h2 id="parameters">Parameters:</h2>
<p><em>keys : one or more keys that correspond to the <code>TEMPLATE</code> entries.
printflag : bool, optional
Whether to enable printing of additional information.
verbose : bool, optional
Whether to run in verbose mode for debugging or detailed output.
</em>*USER : dict, optional
Additional user-defined variables to pass into the script.</p>
<h2 id="returns">Returns:</h2>
<p>A <code><a title="dscript.pipescript" href="#dscript.pipescript">pipescript</a></code> object that combines the script objects generated from the selected
dscript subobjects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipescript(self, *keys, printflag=None, verbose=None, verbosity=None, **USER):
    &#34;&#34;&#34;
    Returns a pipescript object by combining script objects corresponding to the given keys.

    Parameters:
    -----------
    *keys : one or more keys that correspond to the `TEMPLATE` entries.
    printflag : bool, optional
        Whether to enable printing of additional information.
    verbose : bool, optional
        Whether to run in verbose mode for debugging or detailed output.
    **USER : dict, optional
        Additional user-defined variables to pass into the script.

    Returns:
    --------
    A `pipescript` object that combines the script objects generated from the selected
    dscript subobjects.
    &#34;&#34;&#34;
    # Start with an empty pipescript
    # combined_pipescript = None
    # # Iterate over the provided keys to extract corresponding subobjects
    # for key in keys:
    #     # Extract the dscript subobject for the given key
    #     sub_dscript = self(key)
    #     # Convert the dscript subobject to a script object, passing USER, printflag, and verbose
    #     script_obj = sub_dscript.script(printflag=printflag, verbose=verbose, **USER)
    #     # Combine script objects into a pipescript object
    #     if combined_pipescript is None:
    #         combined_pipescript = pipescript(script_obj)  # Initialize pipescript
    #     else:
    #         combined_pipescript = combined_pipescript | script_obj  # Use pipe operator
    # if combined_pipescript is None:
    #     ValueError(&#39;The conversion to pipescript from {type{self}} falled&#39;)
    # return combined_pipescript
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity

    # Loop over all keys in TEMPLATE and combine them
    combined_pipescript = None
    localvariables = scriptdata()
    for key in self.keys():
        # Create a new dscript object with only the current key in TEMPLATE
        focused_dscript = dscript(name=f&#34;{self.name}:{key}&#34;)
        focused_dscript.TEMPLATE[key] = self.TEMPLATE[key]
        localvariables = localvariables+scriptdata(**self.TEMPLATE[key].definitions)
        focused_dscript.TEMPLATE[key].definitions = localvariables
        focused_dscript.DEFINITIONS = scriptdata(**self.DEFINITIONS)
        focused_dscript.SECTIONS = self.SECTIONS[:]
        focused_dscript.section = self.section
        focused_dscript.position = self.position
        focused_dscript.role = self.role
        focused_dscript.description = self.description
        focused_dscript.userid = self.userid
        focused_dscript.version = self.version
        focused_dscript.verbose = verbose
        focused_dscript.printflag = printflag

        # Convert the focused dscript object to a script object
        script_obj = focused_dscript.script(printflag=printflag, verbose=verbose, **USER)

        # Combine the script objects into a pipescript object using the pipe operator
        if combined_pipescript is None:
            combined_pipescript = pipescript(script_obj)  # Initialize pipescript
        else:
            combined_pipescript = combined_pipescript | pipescript(script_obj)  # Use pipe operator

    if combined_pipescript is None:
        ValueError(&#39;The conversion to pipescript from {type{self}} falled&#39;)
    return combined_pipescript</code></pre>
</details>
</dd>
<dt id="dscript.dscript.print_var_info"><code class="name flex">
<span>def <span class="ident">print_var_info</span></span>(<span>self, what='all', output_file=None, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Print or save a neatly formatted table of variable information based on the analysis from <code>var_info()</code>.</p>
<p>This method retrieves variable information using the <code>var_info()</code> method and presents it in a
Markdown-compatible table or an HTML table. Users can choose to display information for all variables
or a specific subset by providing a list of variable names. Additionally, users can opt to save the
table to a file with options to control file extension, path validity, and overwrite behavior.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>what</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code>, optional</dt>
<dd>Specifies which variables' information to print.
- If set to 'all' (default), information for all variables is displayed.
- If set to a list of variable names, only those variables are displayed.</dd>
<dt><strong><code>output_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The path to the file where the table will be saved.
- If set to <code>None</code> (default), the table is printed to the console.
- If a file path is provided, the table is saved to the specified file.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Determines whether to overwrite the file if it already exists.
- If <code>False</code> and the file exists, a <code>FileExistsError</code> is raised.
- If <code>True</code>, the existing file is overwritten.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>
<ul>
<li>If <code>what</code> is neither <code>'all'</code> nor a list of strings.</li>
<li>If the file extension is neither <code>.md</code>, <code>.txt</code>, nor <code>.html</code>.</li>
</ul>
</dd>
<dt><code>FileNotFoundError</code></dt>
<dd>If the specified directory in <code>output_file</code> does not exist.</dd>
<dt><code>PermissionError</code></dt>
<dd>If the specified path is not writable.</dd>
<dt><code>FileExistsError</code></dt>
<dd>If the file exists and <code>overwrite</code> is set to <code>False</code>.</dd>
<dt><code>IOError</code></dt>
<dd>If an error occurs during file writing.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_var_info(self, what=&#39;all&#39;, output_file=None, overwrite=False):
    &#34;&#34;&#34;
    Print or save a neatly formatted table of variable information based on the analysis from `var_info()`.

    This method retrieves variable information using the `var_info()` method and presents it in a
    Markdown-compatible table or an HTML table. Users can choose to display information for all variables
    or a specific subset by providing a list of variable names. Additionally, users can opt to save the
    table to a file with options to control file extension, path validity, and overwrite behavior.

    Parameters
    ----------
    what : str or list of str, optional
        Specifies which variables&#39; information to print.
        - If set to &#39;all&#39; (default), information for all variables is displayed.
        - If set to a list of variable names, only those variables are displayed.

    output_file : str, optional
        The path to the file where the table will be saved.
        - If set to `None` (default), the table is printed to the console.
        - If a file path is provided, the table is saved to the specified file.

    overwrite : bool, default=False
        Determines whether to overwrite the file if it already exists.
        - If `False` and the file exists, a `FileExistsError` is raised.
        - If `True`, the existing file is overwritten.

    Raises
    ------
    ValueError
        - If `what` is neither `&#39;all&#39;` nor a list of strings.
        - If the file extension is neither `.md`, `.txt`, nor `.html`.
    FileNotFoundError
        If the specified directory in `output_file` does not exist.
    PermissionError
        If the specified path is not writable.
    FileExistsError
        If the file exists and `overwrite` is set to `False`.
    IOError
        If an error occurs during file writing.
    &#34;&#34;&#34;
    # Retrieve the variable information dictionary
    varnfo = self.var_info()

    # Determine which variables to display
    if what == &#39;all&#39;:
        variables_to_print = list(varnfo.keys())
    elif isinstance(what, list):
        # Ensure all items in the list are strings
        if not all(isinstance(var, str) for var in what):
            raise ValueError(&#34;All items in the &#39;what&#39; list must be strings representing variable names.&#34;)
        variables_to_print = what
    else:
        raise ValueError(&#34;Parameter &#39;what&#39; must be either &#39;all&#39; or a list of variable names.&#34;)

    # Filter out variables that are not present in varnfo
    missing_vars = [var for var in variables_to_print if var not in varnfo]
    if missing_vars:
        print(f&#34;Warning: The following variables were not found and will be skipped: {missing_vars}&#34;)
        # Remove missing variables from the list
        variables_to_print = [var for var in variables_to_print if var in varnfo]

    if not variables_to_print:
        print(&#34;No variables to display.&#34;)
        return

    # Define the headers based on varnfo fields
    headers = [
        &#34;Variable Name&#34;,
        &#34;Value&#34;,
        &#34;Updated Value&#34;,
        &#34;Is Default&#34;,
        &#34;First Def&#34;,
        &#34;First Use&#34;,
        &#34;First Val&#34;,
        &#34;Override Index&#34;,
        &#34;Is Autodef&#34;,
        &#34;Is Empty&#34;,
        &#34;Is Global&#34;,
        &#34;Value Counter&#34;,
        &#34;First Use IsGlobal&#34;,
        &#34;Set In&#34;,
        &#34;Set As&#34;,
        &#34;Values&#34;,
        &#34;Used In&#34;
    ]

    # Initialize a list to hold all rows
    table_rows = []

    # Populate the table rows with variable information
    for var in variables_to_print:
        info = varnfo[var]
        row = [
            var,
            self._format_field(info.get(&#34;value&#34;)),
            self._format_field(info.get(&#34;updatedvalue&#34;)),
            self._format_field(info.get(&#34;is_default&#34;)),
            self._format_field(info.get(&#34;first_def&#34;)),
            self._format_field(info.get(&#34;first_use&#34;)),
            self._format_field(info.get(&#34;first_val&#34;)),
            self._format_field(info.get(&#34;override_index&#34;)),
            self._format_field(info.get(&#34;is_autodef&#34;)),
            self._format_field(info.get(&#34;is_empty&#34;)),
            self._format_field(info.get(&#34;is_global&#34;)),
            self._format_field(info.get(&#34;value_counter&#34;)),
            self._format_field(info.get(&#34;first_use_isglobal&#34;)),
            self._format_list(info.get(&#34;set_in&#34;)),
            self._format_list(info.get(&#34;set_as&#34;)),
            self._format_values(info.get(&#34;values&#34;)),
            self._format_list(info.get(&#34;used_in&#34;))
        ]
        table_rows.append(row)

    # Calculate the maximum width for each column
    column_widths = [len(header) for header in headers]
    for row in table_rows:
        for idx, cell in enumerate(row):
            cell_length = len(str(cell))
            if cell_length &gt; column_widths[idx]:
                column_widths[idx] = cell_length

    # Build the Markdown table
    # Header row
    header_row = &#34;| &#34; + &#34; | &#34;.join(f&#34;{header.ljust(column_widths[idx])}&#34; for idx, header in enumerate(headers)) + &#34; |&#34;
    # Separator row
    separator_row = &#34;|-&#34; + &#34;-|-&#34;.join(&#39;-&#39; * column_widths[idx] for idx in range(len(headers))) + &#34;-|&#34;
    # Data rows
    data_rows = [
        &#34;| &#34; + &#34; | &#34;.join(f&#34;{str(cell).ljust(column_widths[idx])}&#34; for idx, cell in enumerate(row)) + &#34; |&#34;
        for row in table_rows
    ]

    # Combine all parts for Markdown
    markdown_table = &#34;\n&#34;.join([header_row, separator_row] + data_rows)

    # Generate HTML table if needed
    html_table = None
    if output_file:
        _, file_extension = os.path.splitext(output_file)
        file_extension = file_extension.lower()

        if file_extension not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;, &#39;&#39;]:
            raise ValueError(&#34;File extension must be either &#39;.md&#39;, &#39;.txt&#39;, or &#39;.html&#39;.&#34;)

        if file_extension == &#39;&#39;:
            # Default to .md
            output_file += &#39;.md&#39;
            file_extension = &#39;.md&#39;

        # Extract directory from the output_file path
        directory = os.path.dirname(os.path.abspath(output_file))
        if directory and not os.path.exists(directory):
            raise FileNotFoundError(f&#34;The directory &#39;{directory}&#39; does not exist.&#34;)

        if directory and not os.access(directory, os.W_OK):
            raise PermissionError(f&#34;The directory &#39;{directory}&#39; is not writable.&#34;)

        # Check if the file exists
        if os.path.exists(output_file) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{output_file}&#39; already exists and overwrite is set to False.&#34;)

        # Prepare title and timestamp
        timestamp = datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        title = f&#34;{self.name} - Variable Information&#34;
        subtitle = f&#34;Generated on {timestamp} by {self.userid}&#34;

        if file_extension == &#39;.html&#39;:
            # Build HTML table with embedded CSS
            html_table = self._build_html_table(headers, table_rows, column_widths, title, subtitle)
        else:
            # For Markdown and TXT, prepare content with title and timestamp
            content = f&#34;# {title}\n\n&#34;
            content += f&#34;**{subtitle}**\n\n&#34;
            content += markdown_table + &#34;\n&#34;

    # If output_file is not specified, print to console
    if output_file is None:
        # Print title and timestamp
        timestamp = datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        title = f&#34;{self.name} - Variable Information&#34;
        subtitle = f&#34;Generated on {timestamp} by {self.userid}&#34;
        print(f&#34;### {title}\n&#34;)
        print(f&#34;**{subtitle}**\n&#34;)
        # Print the Markdown table
        print(markdown_table)
    else:
        # Save to file based on extension
        try:
            if file_extension in [&#39;.md&#39;, &#39;.txt&#39;]:
                # Prepare content with title and timestamp
                content = f&#34;# {title}\n\n&#34;
                content += f&#34;**{subtitle}**\n\n&#34;
                content += markdown_table + &#34;\n&#34;

                # Write to file
                with open(output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                    f.write(content)
                print(f&#34;Variable information successfully written to &#39;{output_file}&#39;.&#34;)
            elif file_extension == &#39;.html&#39;:
                # Write HTML content
                with open(output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                    f.write(html_table)
                print(f&#34;Variable information successfully written to &#39;{output_file}&#39;.&#34;)
        except IOError as e:
            raise IOError(f&#34;An error occurred while writing to the file: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="dscript.dscript.reorder"><code class="name flex">
<span>def <span class="ident">reorder</span></span>(<span>self, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Reorder the TEMPLATE lines according to a list of indices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reorder(self, order):
    &#34;&#34;&#34;Reorder the TEMPLATE lines according to a list of indices.&#34;&#34;&#34;
    # Get the original items as a list of (key, value) pairs
    original_items = list(self.TEMPLATE.items())
    # Create a new dictionary with reordered scripts, preserving original keys
    new_scripts = {original_items[i][0]: original_items[i][1] for i in order}
    # Create a new dscript object with reordered scripts
    reordered_script = dscript()
    reordered_script.TEMPLATE = new_scripts
    return reordered_script</code></pre>
</details>
</dd>
<dt id="dscript.dscript.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename=None, foldername=None, overwrite=False, generatoronly=False, onlyusedvariables=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the current script instance to a text file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the file to save the script to. If not provided, <code>self.name</code> is used.
The extension ".txt" is automatically appended if not included.</dd>
<dt><strong><code>foldername</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The directory where the file will be saved. If not provided, it defaults to the system's
temporary directory. If the filename does not include a full path, this folder will be used.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to overwrite the file if it already exists. If set to False, an exception is raised
if the file exists.</dd>
<dt><strong><code>generatoronly</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If True, the method returns the generated content string without saving to a file.</dd>
<dt><strong><code>onlyusedvariables</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>If True, local definitions are only saved if they are used within the template content.
If False, all local definitions are saved, regardless of whether they are referenced in
the template.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and <code>overwrite</code> is set to False.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>The script is saved in a plain text format, and each section (global parameters, definitions,
template, and attributes) is written in a structured format with appropriate comments.</li>
<li>If <code>self.name</code> is used as the filename, it must be a valid string that can serve as a file name.</li>
<li>
<p>The file structure follows the format:
# DSCRIPT SAVE FILE
# generated on YYYY-MM-DD on user@hostname</p>
<h1 id="global-parameters">GLOBAL PARAMETERS</h1>
<p>{ &hellip; }</p>
<h1 id="definitions-number-of-definitions">DEFINITIONS (number of definitions=&hellip;)</h1>
<p>key=value</p>
<h1 id="templates-number-of-items">TEMPLATES (number of items=&hellip;)</h1>
<p>key: template_content</p>
<h1 id="attributes-number-of-items-with-explicit-attributes">ATTRIBUTES (number of items with explicit attributes=&hellip;)</h1>
<p>key:{attr1=value1, attr2=value2, &hellip;}</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename=None, foldername=None, overwrite=False, generatoronly=False, onlyusedvariables=True):
    &#34;&#34;&#34;
    Save the current script instance to a text file.

    Parameters
    ----------
    filename : str, optional
        The name of the file to save the script to. If not provided, `self.name` is used.
        The extension &#34;.txt&#34; is automatically appended if not included.

    foldername : str, optional
        The directory where the file will be saved. If not provided, it defaults to the system&#39;s
        temporary directory. If the filename does not include a full path, this folder will be used.

    overwrite : bool, default=True
        Whether to overwrite the file if it already exists. If set to False, an exception is raised
        if the file exists.

    generatoronly : bool, default=False
        If True, the method returns the generated content string without saving to a file.

    onlyusedvariables : bool, default=True
        If True, local definitions are only saved if they are used within the template content.
        If False, all local definitions are saved, regardless of whether they are referenced in
        the template.

    Raises
    ------
    FileExistsError
        If the file already exists and `overwrite` is set to False.

    Notes
    -----
    - The script is saved in a plain text format, and each section (global parameters, definitions,
      template, and attributes) is written in a structured format with appropriate comments.
    - If `self.name` is used as the filename, it must be a valid string that can serve as a file name.
    - The file structure follows the format:
        # DSCRIPT SAVE FILE
        # generated on YYYY-MM-DD on user@hostname

        # GLOBAL PARAMETERS
        { ... }

        # DEFINITIONS (number of definitions=...)
        key=value

        # TEMPLATES (number of items=...)
        key: template_content

        # ATTRIBUTES (number of items with explicit attributes=...)
        key:{attr1=value1, attr2=value2, ...}
    &#34;&#34;&#34;
    # At the beginning of the save method
    start_time = time.time()  # Start the timer

    if not generatoronly:
        # Use self.name if filename is not provided
        if filename is None:
            filename = span(self.name, sep=&#34;\n&#34;)

        # Ensure the filename ends with &#39;.txt&#39;
        if not filename.endswith(&#39;.txt&#39;):
            filename += &#39;.txt&#39;

        # Construct the full path
        if foldername in [None, &#34;&#34;]:  # Handle cases where foldername is None or an empty string
            filepath = os.path.abspath(filename)
        else:
            filepath = os.path.join(foldername, filename)

        # Check if the file already exists, and raise an exception if it does and overwrite is False
        if os.path.exists(filepath) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

    # Header with current date, username, and host
    header = &#34;# DSCRIPT SAVE FILE\n&#34;
    header += &#34;\n&#34;*2
    if generatoronly:
        header += dscript.header(verbose=True,filepath=&#39;dynamic code generation (no file)&#39;,
                                 name = self.name, version=self.version, license=self.license, email=self.email)
    else:
        header += dscript.header(verbose=True,filepath=filepath,
                                 name = self.name, version=self.version, license=self.license, email=self.email)
    header += &#34;\n&#34;*2

    # Global parameters in strict Python syntax
    global_params = &#34;# GLOBAL PARAMETERS (8 parameters)\n&#34;
    global_params += &#34;{\n&#34;
    global_params += f&#34;    SECTIONS = {self.SECTIONS},\n&#34;
    global_params += f&#34;    section = {self.section},\n&#34;
    global_params += f&#34;    position = {self.position},\n&#34;
    global_params += f&#34;    role = {self.role!r},\n&#34;
    global_params += f&#34;    description = {self.description!r},\n&#34;
    global_params += f&#34;    userid = {self.userid!r},\n&#34;
    global_params += f&#34;    version = {self.version},\n&#34;
    global_params += f&#34;    verbose = {self.verbose}\n&#34;
    global_params += &#34;}\n&#34;

    # Initialize definitions with self.DEFINITIONS
    #allvars = self.DEFINITIONS

    # Temporary dictionary to track global variable information
    vinfo = self.var_info()

    # Filter global definitions based on usage, overrides, and first_def
    #  and info[&#34;is_default&#34;]
    filtered_globals = {
        var: info for var, info in vinfo.items()
        if ((info[&#34;is_global&#34;]and not info[&#34;is_empty&#34;]) and (info[&#34;first_use_isglobal&#34;]) and (info[&#34;override_index&#34;] is None))
        }

    # Generate the definitions output based on filtered globals
    definitions = f&#34;\n# GLOBAL DEFINITIONS (number of definitions={len(filtered_globals)})\n&#34;
    for var, info in filtered_globals.items():
        if info[&#34;is_default&#34;] and (info[&#34;first_def&#34;]&gt;info[&#34;first_use&#34;] if info[&#34;first_def&#34;] else True):
            definitions += f&#34;{var} = ${{{var}}}  # value assumed to be defined outside this DSCRIPT file\n&#34;
        else:
            value = info[&#34;first_val&#34;]   #info[&#34;value&#34;]
            if info[&#34;is_empty&#34;]:        #value in [&#34;&#34;, None]
                definitions += f&#39;{var} = &#34;&#34;\n&#39;
            elif isinstance(value, str):
                safe_value = value.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;\n&#39;, &#39;\\n&#39;)
                definitions += f&#34;{var} = {safe_value}\n&#34;
            else:
                definitions += f&#34;{var} = {value}\n&#34;

    # Template (number of lines/items)
    printsinglecontent = False
    template = f&#34;\n# TEMPLATES (number of items={len(self.TEMPLATE)})\n&#34;
    #for key, script_template in self.TEMPLATE.items():
    for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
        # Get local template definitions and detected variables
        template_vars = script_template.definitions
        used_variables = script_template.detect_variables()
        islocal = False
        # Temporary dictionary to accumulate variables to add to allvars
        valid_local_vars = lambdaScriptdata()
        # Write template-specific definitions only if they meet the updated conditions
        for var in template_vars.keys():
            # Conditions for adding a variable to the local template and to `allvars`
            if (var in used_variables or not onlyusedvariables) \
               and (template_index in vinfo[var][&#34;set_in&#34;]) \
               and (var not in filtered_globals):
            # if (var in used_variables or not onlyusedvariables) and (
            #    script_template.is_variable_set_value_only(var) and
            #    (var not in allvars or getattr(template_vars, var) != getattr(allvars, var))
            #):
                # Start local definitions section if this is the first local variable for the template
                if not islocal:
                    template += f&#34;\n# LOCAL DEFINITIONS for key &#39;{key}&#39;\n&#34;
                    islocal = True
                # Retrieve and process the variable value
                # value = getattr(template_vars, var)
                value = next((ref for idx, ref in vinfo[var][&#34;values&#34;] if idx == template_index), None)
                if value in [&#34;&#34;, None]:
                    template += f&#39;{var} = &#34;&#34;\n&#39;  # Set empty or None values as &#34;&#34;
                elif isinstance(value, str):
                    safe_value = value.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;\n&#39;, &#39;\\n&#39;)
                    template += f&#34;{var} = {safe_value}\n&#34;
                else:
                    template += f&#34;{var} = {value}\n&#34;
                # Add the variable to valid_local_vars for selective update of allvars
                valid_local_vars.setattr(var, value)
        # Update allvars only with filtered, valid local variables
        # allvars += valid_local_vars

        # Write the template content
        if isinstance(script_template.content, list):
            if len(script_template.content) == 1:
                # Single-line template saved as a single line
                content_str = script_template.content[0].strip()
                template += &#34;&#34; if printsinglecontent else &#34;\n&#34;
                template += f&#34;{key}: {content_str}\n&#34;
                printsinglecontent = True
            else:
                content_str = &#39;\n    &#39;.join(script_template.content)
                template += f&#34;\n{key}: [\n    {content_str}\n ]\n&#34;
                printsinglecontent = False
        else:
            template += &#34;&#34; if printsinglecontent else &#34;\n&#34;
            template += f&#34;{key}: {script_template.content}\n&#34;
            printsinglecontent = True

    # Attributes (number of lines/items with explicit attributes)
    attributes = f&#34;# ATTRIBUTES (number of items with explicit attributes={len(self.TEMPLATE)})\n&#34;
    for key, script_template in self.TEMPLATE.items():
        attr_str = &#34;, &#34;.join(f&#34;{attr_name}={repr(attr_value)}&#34;
                             for attr_name, attr_value in script_template.attributes.items())
        attributes += f&#34;{key}:{{{attr_str}}}\n&#34;

    # Combine all sections into one content
    content = header + &#34;\n&#34; + global_params + &#34;\n&#34; + definitions + &#34;\n&#34; + template + &#34;\n&#34; + attributes + &#34;\n&#34;


    # Append footer information to the content
    non_empty_lines = sum(1 for line in content.splitlines() if line.strip())  # Count non-empty lines
    execution_time = time.time() - start_time  # Calculate the execution time in seconds
    # Prepare the footer content
    footer_lines = [
        [&#34;Non-empty lines&#34;, str(non_empty_lines)],
        [&#34;Execution time (seconds)&#34;, f&#34;{execution_time:.4f}&#34;],
    ]
    # Format footer into tabular style
    footer_content = [
        f&#34;{row[0]:&lt;25} {row[1]:&lt;15}&#34; for row in footer_lines
    ]
    # Use frame_header to format footer
    footer = frame_header(
        lines=[&#34;DSCRIPT SAVE FILE generator&#34;] + footer_content,
        style=1
    )
    # Append footer to the content
    content += f&#34;\n{footer}&#34;

    if generatoronly:
        return content
    else:
        # Write the content to the file
        with open(filepath, &#39;w&#39;) as f:
            f.write(content)
        print(f&#34;\nScript saved to {filepath}&#34;)
        return filepath</code></pre>
</details>
</dd>
<dt id="dscript.dscript.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>self, printflag=None, verbose=None, verbosity=None, **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the corresponding script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def script(self,printflag=None, verbose=None, verbosity=None, **USER):
    &#34;&#34;&#34;
    returns the corresponding script
    &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    return lamdaScript(self,persistentfile=True, persistentfolder=None,
                       printflag=printflag, verbose=verbose,
                       **USER)</code></pre>
</details>
</dd>
<dt id="dscript.dscript.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, primary_key, value, foreign_key, include_global=True, multiple='all', protection=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for foreign/definition key values associated with given primary key/definition value(s).</p>
<p>This method searches through the global definitions first and then traverses local steps in sequential order
to find matches for the specified primary key and retrieves the corresponding foreign key values.
It also identifies available foreign keys in steps where the primary key exists but the desired foreign key is missing.</p>
<h2 id="parameters">Parameters</h2>
<p>primary_key (str):
The primary key to search for in the definitions.
value (str, int, float, or list of these types):
The value(s) associated with the primary key.
foreign_key (str):
The foreign key whose value is to be retrieved.
include_global (bool, optional):
If True, include global definitions in the search.
Defaults to True.
multiple (str, optional):
Strategy for handling multiple matches. Options are:
- 'first': Return the first match found.
- 'last': Return the last match found.
- 'all': Return all matches in a list.
Defaults to 'all'.
protection (bool, optional):
If False (default), removes the '$' prefix from the keys in the returned dictionary.
If True, retains the '$' prefix.
Defaults to False.
verbose (bool, optional):
If True, prints warnings about missing foreign keys and available alternative keys.
Defaults to False.</p>
<h2 id="returns">Returns</h2>
<p>dict or scalar or None:
- If multiple values are provided, returns a dictionary mapping each value to its foreign key value(s).
- If a single value is provided:
- Returns a single foreign key value if 'multiple' is 'first' or 'last'.
- Returns a list of all matching foreign key values if 'multiple' is 'all'.
- Returns None if no matches are found.</p>
<h2 id="raises">Raises</h2>
<p>TypeError:
If the provided value is not of type str, int, or float, or if value list contains invalid types.
ValueError:
If an invalid option is provided for 'multiple'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self, primary_key, value, foreign_key, include_global=True, multiple=&#39;all&#39;, protection=False, verbose=False):
    &#34;&#34;&#34;
    Search for foreign/definition key values associated with given primary key/definition value(s).

    This method searches through the global definitions first and then traverses local steps in sequential order
    to find matches for the specified primary key and retrieves the corresponding foreign key values.
    It also identifies available foreign keys in steps where the primary key exists but the desired foreign key is missing.

    Parameters:
        primary_key (str):
            The primary key to search for in the definitions.
        value (str, int, float, or list of these types):
            The value(s) associated with the primary key.
        foreign_key (str):
            The foreign key whose value is to be retrieved.
        include_global (bool, optional):
            If True, include global definitions in the search.
            Defaults to True.
        multiple (str, optional):
            Strategy for handling multiple matches. Options are:
            - &#39;first&#39;: Return the first match found.
            - &#39;last&#39;: Return the last match found.
            - &#39;all&#39;: Return all matches in a list.
            Defaults to &#39;all&#39;.
        protection (bool, optional):
            If False (default), removes the &#39;$&#39; prefix from the keys in the returned dictionary.
            If True, retains the &#39;$&#39; prefix.
            Defaults to False.
        verbose (bool, optional):
            If True, prints warnings about missing foreign keys and available alternative keys.
            Defaults to False.

    Returns:
        dict or scalar or None:
            - If multiple values are provided, returns a dictionary mapping each value to its foreign key value(s).
            - If a single value is provided:
                - Returns a single foreign key value if &#39;multiple&#39; is &#39;first&#39; or &#39;last&#39;.
                - Returns a list of all matching foreign key values if &#39;multiple&#39; is &#39;all&#39;.
            - Returns None if no matches are found.

    Raises:
        TypeError:
            If the provided value is not of type str, int, or float, or if value list contains invalid types.
        ValueError:
            If an invalid option is provided for &#39;multiple&#39;.
    &#34;&#34;&#34;
    # Validate &#39;multiple&#39; parameter
    if multiple not in {&#39;first&#39;, &#39;last&#39;, &#39;all&#39;}:
        raise ValueError(&#34;Parameter &#39;multiple&#39; must be one of &#39;first&#39;, &#39;last&#39;, or &#39;all&#39;.&#34;)

    # Normalize &#39;value&#39; to a list for uniform processing
    if isinstance(value, (str, int, float)):
        values = [value]
        single_value = True
    elif isinstance(value, list):
        if not all(isinstance(v, (str, int, float)) for v in value):
            raise TypeError(&#34;All elements in &#39;value&#39; list must be of type str, int, or float.&#34;)
        values = value
        single_value = False
    else:
        raise TypeError(f&#34;&#39;value&#39; must be of type str, int, float, or list of these types, got {type(value).__name__}&#34;)

    # Initialize the result containers
    matched_foreign_keys = {}  # key: value, value: single or list of foreign_key values
    available_foreign_keys_set = set()  # set of foreign keys available where primary exists but desired foreign_key missing

    # Keys to exclude when listing available foreign keys
    excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

    # Function to add a match to the results based on the &#39;multiple&#39; strategy
    def add_match(val, rvalue):
        if multiple == &#39;all&#39;:
            if val in matched_foreign_keys:
                if isinstance(matched_foreign_keys[val], list):
                    matched_foreign_keys[val].append(rvalue)
                else:
                    matched_foreign_keys[val] = [matched_foreign_keys[val], rvalue]
            else:
                matched_foreign_keys[val] = [rvalue]
        elif multiple == &#39;first&#39;:
            if val not in matched_foreign_keys:
                matched_foreign_keys[val] = rvalue
        elif multiple == &#39;last&#39;:
            matched_foreign_keys[val] = rvalue

    # Start with global definitions if included
    if include_global:
        global_definitions = self.DEFINITIONS
        if hasattr(global_definitions, primary_key):
            primary_value = getattr(global_definitions, primary_key)

            # Handle multiple primary key values within the global definitions
            if isinstance(primary_value, (list, tuple, set)):
                primary_values = primary_value
            else:
                primary_values = [primary_value]

            for pv in primary_values:
                for val in values:
                    if pv == val:
                        # Check if the foreign key exists in global definitions
                        if hasattr(global_definitions, foreign_key):
                            rvalue = getattr(global_definitions, foreign_key)
                            add_match(val, rvalue)
                        else:
                            # Collect available foreign keys in global definitions, excluding specified keys
                            available_keys = [
                                k for k in global_definitions.__dict__
                                if k != primary_key and k not in excluded_keys
                            ]
                            available_foreign_keys_set.update(available_keys)

    # Then, traverse through local steps in sequential order
    for istep in range(len(self)):
        step_definitions = self[istep].definitions

        # Check if the primary key exists in the local definitions
        if hasattr(step_definitions, primary_key):
            primary_value = getattr(step_definitions, primary_key)

            # Handle multiple primary key values within the definition
            if isinstance(primary_value, (list, tuple, set)):
                primary_values = primary_value
            else:
                primary_values = [primary_value]

            for pv in primary_values:
                for val in values:
                    if pv == val:
                        # Check if the foreign key exists
                        if hasattr(step_definitions, foreign_key):
                            rvalue = getattr(step_definitions, foreign_key)
                            add_match(val, rvalue)
                        else:
                            # Collect available foreign keys in this step, excluding specified keys
                            available_keys = [
                                k for k in step_definitions.__dict__
                                if k != primary_key and k not in excluded_keys
                            ]
                            available_foreign_keys_set.update(available_keys)

    # Process the matched_foreign_keys based on &#39;multiple&#39; strategy
    if single_value:
        if values[0] in matched_foreign_keys:
            if multiple == &#39;all&#39;:
                # If only one match, return scalar; else, list
                matches = matched_foreign_keys[values[0]]
                if len(matches) == 1:
                    matches = matches[0]
            else:
                matches = matched_foreign_keys[values[0]]
        else:
            matches = None
    else:
        matches = {}
        for val in values:
            if val in matched_foreign_keys:
                if multiple == &#39;all&#39;:
                    if len(matched_foreign_keys[val]) == 1:
                        matches[val] = matched_foreign_keys[val][0]
                    else:
                        matches[val] = matched_foreign_keys[val]
                else:
                    matches[val] = matched_foreign_keys[val]
            else:
                matches[val] = None  # Or handle differently if needed

    # If there are available foreign keys, report them as an error message
    if available_foreign_keys_set and verbose:
        available_keys_sorted = sorted(list(available_foreign_keys_set))
        print(f&#34;Warning: In some steps, the foreign key &#39;{foreign_key}&#39; is missing where the primary key &#39;{primary_key}&#39; exists.&#34;)
        print(f&#34;Available foreign keys in those steps: {available_keys_sorted}&#34;)

    # If no matches found, print a message
    if (single_value and matches is None) or (not single_value and all(v is None for v in matches.values())):
        if verbose:
            print(f&#34;No matches found for primary key &#39;{primary_key}&#39; with value(s) &#39;{value}&#39;.&#34;)
        return None

    # Handle protection flag: remove &#39;$&#39; prefix from keys if protection=False
    if not single_value and isinstance(matches, dict):
        processed_matches = {}
        for k, v in matches.items():
            if not protection and isinstance(k, str):
                # Remove any leading &#39;$&#39; and surrounding spaces
                new_key = k.lstrip(&#39;$&#39;).strip()
            else:
                new_key = k
            processed_matches[new_key] = v
        return processed_matches
    else:
        # For single value searches, return matches as-is
        return matches</code></pre>
</details>
</dd>
<dt id="dscript.dscript.set_all_variables"><code class="name flex">
<span>def <span class="ident">set_all_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensures that all variables in the templates are added to the global definitions
with default values if they are not already defined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_all_variables(self):
    &#34;&#34;&#34;
    Ensures that all variables in the templates are added to the global definitions
    with default values if they are not already defined.
    &#34;&#34;&#34;
    for key, script_template in self.TEMPLATE.items():
        # Check and update the global definitions with template-specific variables
        for var in script_template.detect_variables():
            if var not in self.DEFINITIONS:
                # Add undefined variables with their default value
                self.DEFINITIONS.setattr(var, f&#34;${{{var}}}&#34;)  # Set default as ${varname}</code></pre>
</details>
</dd>
<dt id="dscript.dscript.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the ScriptTemplate objects in TEMPLATE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34;Return the ScriptTemplate objects in TEMPLATE.&#34;&#34;&#34;
    return self.TEMPLATE.values()</code></pre>
</details>
</dd>
<dt id="dscript.dscript.var_info"><code class="name flex">
<span>def <span class="ident">var_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyze and gather comprehensive information about variables used in the script.</p>
<p>This method performs a sophisticated analysis of both global and local variables within
the script. It identifies variable usage, overrides, defaults, and counts the number of
different values each variable holds across various templates.</p>
<p>The analysis considers two scopes:
- <strong>Global:</strong> Variables defined in the global definitions (<code>self.DEFINITIONS</code>).
- <strong>Local:</strong> Variables defined within each template's definitions.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>A dictionary named <code>varnfo</code> where each key is a variable name and the value is
another dictionary containing detailed information about that variable. The structure
of <code>varnfo</code> is as follows:</p>
<p>{
"variable_name": {
"value": <initial_value_from_global>,
"updatedvalue": <current_value_after_overrides>,
"is_default": <bool>,
"first_def": <template_index_or_None>,
"first_use": <template_index>,
"first_val": <value_at_first_use>,
"override_index": <template_index_or_None>,
"is_global": <bool>,
"value_counter": <int>
etc.
},
&hellip;
}</p>
<p><strong>Field Descriptions:</strong>
- <code>value</code>: Initial value of the variable from global definitions (if applicable).
- <code>updatedvalue</code>: Current value after any overrides in local templates.
- <code>is_default</code>: Indicates if the variable is set to a default value.
- <code>first_def</code>: The index of the first template where the variable is defined locally.
- <code>first_use</code>: The index of the first template where the variable is used.
- <code>first_val</code>: The value of the variable at its first use.
- <code>override_index</code>: The index of the template where the variable was overridden (if any).
- <code>is_autodef</code>: Flag, True if ${variable} is defined automatically as ${variable}
- <code>is_empty</code>: Flag,
True if the variable is empty (None,"",[], etc.)
- <code>is_global</code>: Indicates if the variable originates from global definitions.
- <code>value_counter</code>: Counts the number of different values the variable has across templates.
- <code>first_use_isglobal</code> : Flag, True if the global value is used at first use
- <code>set_in</code>: Lists all template indices values where the variable is assigned/changed,
- <code>set_as</code>: Lists assigned values as reported in <code>set_in</code>,
- <code>values</code>: Lists variable changes (template index, refvalue),
- <code>used_in</code>: Lists template indices where the variable is used</p>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If <code>self.DEFINITIONS</code> does not have the specified key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def var_info(self):
    &#34;&#34;&#34;
    Analyze and gather comprehensive information about variables used in the script.

    This method performs a sophisticated analysis of both global and local variables within
    the script. It identifies variable usage, overrides, defaults, and counts the number of
    different values each variable holds across various templates.

    The analysis considers two scopes:
    - **Global:** Variables defined in the global definitions (`self.DEFINITIONS`).
    - **Local:** Variables defined within each template&#39;s definitions.

    Returns:
        dict: A dictionary named `varnfo` where each key is a variable name and the value is
              another dictionary containing detailed information about that variable. The structure
              of `varnfo` is as follows:

              {
                  &#34;variable_name&#34;: {
                      &#34;value&#34;: &lt;initial_value_from_global&gt;,
                      &#34;updatedvalue&#34;: &lt;current_value_after_overrides&gt;,
                      &#34;is_default&#34;: &lt;bool&gt;,
                      &#34;first_def&#34;: &lt;template_index_or_None&gt;,
                      &#34;first_use&#34;: &lt;template_index&gt;,
                      &#34;first_val&#34;: &lt;value_at_first_use&gt;,
                      &#34;override_index&#34;: &lt;template_index_or_None&gt;,
                      &#34;is_global&#34;: &lt;bool&gt;,
                      &#34;value_counter&#34;: &lt;int&gt;
                      etc.
                  },
                  ...
              }

              **Field Descriptions:**
              - `value`: Initial value of the variable from global definitions (if applicable).
              - `updatedvalue`: Current value after any overrides in local templates.
              - `is_default`: Indicates if the variable is set to a default value.
              - `first_def`: The index of the first template where the variable is defined locally.
              - `first_use`: The index of the first template where the variable is used.
              - `first_val`: The value of the variable at its first use.
              - `override_index`: The index of the template where the variable was overridden (if any).
              - `is_autodef`: Flag, True if ${variable} is defined automatically as ${variable}
              - `is_empty`: Flag,  True if the variable is empty (None,&#34;&#34;,[], etc.)
              - `is_global`: Indicates if the variable originates from global definitions.
              - `value_counter`: Counts the number of different values the variable has across templates.
              - `first_use_isglobal` : Flag, True if the global value is used at first use
              - `set_in`: Lists all template indices values where the variable is assigned/changed,
              - `set_as`: Lists assigned values as reported in `set_in`,
              - `values`: Lists variable changes (template index, refvalue),
              - `used_in`: Lists template indices where the variable is used

    Raises:
        AttributeError: If `self.DEFINITIONS` does not have the specified key.
    &#34;&#34;&#34;

    start_time = time.time()  # Start the timer

    # Initialize definitions with self.DEFINITIONS
    allvars = self.DEFINITIONS

    # Temporary dictionary to track global variable information
    varnfo = {}

    # Loop over each template item to detect and record variable usage and overrides
    for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
        # Detect variables used in this template
        used_variables = script_template.detect_variables()

        # Check each variable used in this template
        for var in used_variables:
            # Get global and local values for the variable
            global_value = getattr(allvars, var, None)
            local_value = getattr(script_template.definitions, var, None)
            is_autodef = global_value == f&#34;${{{var}}}&#34;
            is_global = var in allvars  # Check if the variable originates in global space
            is_empty = global_value in (None,&#34;&#34;,[],[&#34;&#34;])
            is_default = is_global and (is_empty or is_autodef)

            # If the variable is not yet tracked, initialize its info
            if var not in varnfo:
                initialcounter = 1 if local_value is None or local_value==global_value else 2
                first_use_isglobal = initialcounter==1
                refvalue = global_value if first_use_isglobal else local_value
                override_index = template_index if ((local_value is not None) and not first_use_isglobal and not is_default) else None
                varnfo[var] = {
                    &#34;value&#34;: refvalue,        # Initial value from allvars if exists
                    &#34;updatedvalue&#34;: refvalue, # Initial value from allvars if exists
                    &#34;is_default&#34;: is_default,     # Check if it’s set to a default value
                    &#34;first_def&#34;: None,            # First definition (to be updated later)
                    &#34;first_use&#34;: template_index,  # First time the variable is used
                    &#34;first_val&#34;: refvalue,        # First value
                    &#34;override_index&#34;: override_index,  # Set override if defined locally
                    &#34;is_autodef&#34;: is_autodef,     # automatic definition ${variable}
                    &#34;is_empty&#34;: is_empty,         # Track if the variable is empty (None,&#34;&#34;,[], etc.)
                    &#34;is_global&#34;: is_global,       # Track if the variable originates as global
                    &#34;value_counter&#34;: initialcounter, # Count the number of different values
                    &#34;first_use_isglobal&#34;: first_use_isglobal, # True if the global value is used at first use
                    &#34;set_in&#34;: [template_index],
                    &#34;set_as&#34;: [refvalue],
                    &#34;values&#34;:[(template_index, refvalue)],
                    &#34;used_in&#34;: [template_index]
                }
            else:
                # Update `override_index` if the variable is defined locally and its value changes
                varnfo[var][&#34;used_in&#34;].append(template_index)
                if local_value is not None:
                    # Check if the local value differs from the tracked value in varnfo
                    current_value = varnfo[var][&#34;updatedvalue&#34;] # varnfo[var][&#34;value&#34;]
                    if current_value != local_value:
                        varnfo[var][&#34;override_index&#34;] = template_index
                        varnfo[var][&#34;updatedvalue&#34;] = local_value  # Update the tracked value
                        varnfo[var][&#34;value_counter&#34;] += 1
                        varnfo[var][&#34;set_in&#34;].append(template_index)
                        varnfo[var][&#34;set_as&#34;].append(local_value)
                        varnfo[var][&#34;values&#34;].append((template_index, local_value))

    # Second loop: Update `first_def` for all variables
    for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
        local_definitions = script_template.definitions.keys()
        for var in local_definitions:
            if var in varnfo and varnfo[var][&#34;first_def&#34;] is None:
                varnfo[var][&#34;first_def&#34;] = template_index
                varnfo[var][&#34;first_val&#34;] = getattr(script_template.definitions, var)

    execution_time = time.time() - start_time  # Calculate the execution time in seconds

    if self.verbose:
        print(f&#34;Variable analysis completed in {execution_time:.4f} seconds.&#34;)

    return varnfo</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dscript.lambdaScriptdata"><code class="flex name class">
<span>class <span class="ident">lambdaScriptdata</span></span>
<span>(</span><span>sortdefinitions=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to manage lambda script parameters.</p>
<p>This class holds definitions and variables used within the script templates.
These parameters are typically set up as global variables that can be accessed
by script sections for evaluation and substitution.</p>
<h2 id="example-usage">Example Usage:</h2>
<p>definitions = lambdaScriptdata(var1=10, var2="value")</p>
<h2 id="attributes">Attributes:</h2>
<p>_type : str
The type of the data ("LSD" by default).
_fulltype : str
Full type description of the lambda script data.
_ftype : str
Short description of the type (parameter definition).</p>
<h2 id="methods">Methods:</h2>
<p>This class inherits methods from the <code><a title="dscript.paramauto" href="#dscript.paramauto">paramauto</a></code> class, which allows automatic
handling of parameters and script data.</p>
<p>Constructor for lambdaScriptdata. It forces the parent's _returnerror parameter to False.</p>
<h2 id="parameters">Parameters:</h2>
<p>_protection : bool, optional
Whether to enable protection on the parameters (default: False).
_evaluation : bool, optional
Whether evaluation is enabled for the parameters (default: True).
sortdefinitions : bool, optional
Whether to sort definitions upon initialization (default: False).
**kwargs : dict
Additional keyword arguments for the parent class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class lambdaScriptdata(paramauto):
    &#34;&#34;&#34;
    Class to manage lambda script parameters.

    This class holds definitions and variables used within the script templates.
    These parameters are typically set up as global variables that can be accessed
    by script sections for evaluation and substitution.

    Example Usage:
    --------------
    definitions = lambdaScriptdata(var1=10, var2=&#34;value&#34;)

    Attributes:
    -----------
    _type : str
        The type of the data (&#34;LSD&#34; by default).
    _fulltype : str
        Full type description of the lambda script data.
    _ftype : str
        Short description of the type (parameter definition).

    Methods:
    --------
    This class inherits methods from the `paramauto` class, which allows automatic
    handling of parameters and script data.
    &#34;&#34;&#34;

    _type = &#34;LSD&#34;
    _fulltype = &#34;Lambda Script Parameters&#34;
    _ftype = &#34;parameter definition&#34;

    def __init__(self, _protection=False, _evaluation=True, sortdefinitions=False, **kwargs):
        &#34;&#34;&#34;
        Constructor for lambdaScriptdata. It forces the parent&#39;s _returnerror parameter to False.

        Parameters:
        -----------
        _protection : bool, optional
            Whether to enable protection on the parameters (default: False).
        _evaluation : bool, optional
            Whether evaluation is enabled for the parameters (default: True).
        sortdefinitions : bool, optional
            Whether to sort definitions upon initialization (default: False).
        **kwargs : dict
            Additional keyword arguments for the parent class.
        &#34;&#34;&#34;
        # Call the parent class constructor
        super().__init__(_protection=_protection, _evaluation=_evaluation, sortdefinitions=sortdefinitions, **kwargs)
        # Override the _returnerror attribute at the instance level
        self._returnerror = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.paramauto</li>
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="dscript.lamdaScript"><code class="flex name class">
<span>class <span class="ident">lamdaScript</span></span>
<span>(</span><span>dscriptobj, persistentfile=True, persistentfolder=None, printflag=False, verbose=True, softrun=True, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="lamdascript">lamdaScript</h1>
<p>The <code><a title="dscript.lamdaScript" href="#dscript.lamdaScript">lamdaScript</a></code> class is a specialized subclass of <code><a title="dscript.script" href="#dscript.script">script</a></code> that acts as a wrapper
for generating script objects from <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> instances. It facilitates the creation
of scripts with persistent storage options and user-defined configurations.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the script.</dd>
<dt><strong><code>SECTIONS</code></strong> :&ensp;<code>list</code></dt>
<dd>Inherited list of script sections from the <code><a title="dscript.script" href="#dscript.script">script</a></code> class.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>int</code></dt>
<dd>The position index of the script section.</dd>
<dt><strong><code>role</code></strong> :&ensp;<code>str</code></dt>
<dd>The role of the script section, derived from its position.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>A brief description of the script.</dd>
<dt><strong><code>userid</code></strong> :&ensp;<code>str</code></dt>
<dd>The user ID associated with the script.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>float</code></dt>
<dd>The version of the script.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to enable verbose output.</dd>
<dt><strong><code>DEFINITIONS</code></strong> :&ensp;<code><a title="dscript.scriptdata" href="#dscript.scriptdata">scriptdata</a></code></dt>
<dd>Definitions of variables used in the script.</dd>
<dt><strong><code>USER</code></strong> :&ensp;<code><a title="dscript.lambdaScriptdata" href="#dscript.lambdaScriptdata">lambdaScriptdata</a></code></dt>
<dd>User-defined variables specific to <code><a title="dscript.lamdaScript" href="#dscript.lamdaScript">lamdaScript</a></code>.</dd>
<dt><strong><code>TEMPLATE</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of script templates.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>do()
Generates the complete LAMMPS script by processing all script sections.</p>
<h2 id="special-methods">Special Methods</h2>
<p><strong>contains</strong>(key)
Allows checking if a specific section exists using the <code>in</code> keyword.
<strong>str</strong>()
Returns the string representation of the script.</p>
<h2 id="usage-example">Usage Example</h2>
<pre><code class="language-python">from dscript import lamdaScript, dscript

# Create an existing dscript instance
existing_dscript = dscript(name=&quot;ExistingScript&quot;)
existing_dscript.role = &quot;Custom Role&quot;

# Create a lamdaScript instance based on the existing dscript
ls = lamdaScript(existing_dscript)
print(ls.role)  # Outputs: &quot;Custom Role&quot;
</code></pre>
<p>Initialize a new <code>lambdaScript</code> instance.</p>
<p>This constructor creates a <code>lambdaScript</code> object based on an existing <code>dscriptobj</code>,
providing options for persistent storage, verbose output, and user-defined configurations.
A <code>lambdaScript</code> represents an anonymous or temporary script that can either preserve the
original script structure or partially evaluate variable definitions based on the <code>softrun</code> flag.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dscriptobj</code></strong> :&ensp;<code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code></dt>
<dd>An existing <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> object to base the new instance on.</dd>
<dt><strong><code>persistentfile</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, the script will be saved to a persistent file. Defaults to <code>True</code>.</dd>
<dt><strong><code>persistentfolder</code></strong> :&ensp;<code>str</code> or <code>None</code>, optional</dt>
<dd>The folder where the persistent file will be saved. If <code>None</code>, a temporary location is used.
Defaults to <code>None</code>.</dd>
<dt><strong><code>printflag</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, enables printing of the script details during execution. Defaults to <code>False</code>.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, provides detailed output during script initialization and execution. Defaults to <code>True</code>.</dd>
<dt><strong><code>softrun</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Determines whether a pre-execution run is carried out to partially evaluate and substitute variables.
- If <code>True</code> (default), the variable definitions and original script content are preserved without full
evaluation, meaning no substitution is carried out on the <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code>'s templates or definitions.
- If <code>False</code>, performs an initial evaluation phase that substitutes available variables and captures
the local definitions before creating the <code>lambdaScript</code> object.</dd>
<dt><strong><code>**userdefinitions</code></strong></dt>
<dd>Additional user-defined variables and configurations to be included in the <code>lambdaScript</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>dscriptobj</code> is not an instance of the <code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code> class.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">existing_dscript = dscript(name=&quot;ExistingScript&quot;)
ls = lambdaScript(existing_dscript, var3=&quot;3&quot;, softrun=False)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class lamdaScript(script):

    &#34;&#34;&#34;
    lamdaScript
    ===========

    The `lamdaScript` class is a specialized subclass of `script` that acts as a wrapper
    for generating script objects from `dscript` instances. It facilitates the creation
    of scripts with persistent storage options and user-defined configurations.

    Attributes
    ----------
    name : str
        The name of the script.
    SECTIONS : list
        Inherited list of script sections from the `script` class.
    position : int
        The position index of the script section.
    role : str
        The role of the script section, derived from its position.
    description : str
        A brief description of the script.
    userid : str
        The user ID associated with the script.
    version : float
        The version of the script.
    verbose : bool
        Flag to enable verbose output.
    DEFINITIONS : scriptdata
        Definitions of variables used in the script.
    USER : lambdaScriptdata
        User-defined variables specific to `lamdaScript`.
    TEMPLATE : dict
        A dictionary of script templates.

    Methods
    -------
    do()
        Generates the complete LAMMPS script by processing all script sections.

    Special Methods
    ----------------
    __contains__(key)
        Allows checking if a specific section exists using the `in` keyword.
    __str__()
        Returns the string representation of the script.

    Usage Example
    -------------
    ```python
    from dscript import lamdaScript, dscript

    # Create an existing dscript instance
    existing_dscript = dscript(name=&#34;ExistingScript&#34;)
    existing_dscript.role = &#34;Custom Role&#34;

    # Create a lamdaScript instance based on the existing dscript
    ls = lamdaScript(existing_dscript)
    print(ls.role)  # Outputs: &#34;Custom Role&#34;
    ```
    &#34;&#34;&#34;
    name = &#34;&#34;

    def __init__(self, dscriptobj, persistentfile=True, persistentfolder=None,
                 printflag = False, verbose = True, softrun = True,
                 **userdefinitions):
        &#34;&#34;&#34;
            Initialize a new `lambdaScript` instance.

            This constructor creates a `lambdaScript` object based on an existing `dscriptobj`,
            providing options for persistent storage, verbose output, and user-defined configurations.
            A `lambdaScript` represents an anonymous or temporary script that can either preserve the
            original script structure or partially evaluate variable definitions based on the `softrun` flag.

            Parameters
            ----------
            dscriptobj : dscript
                An existing `dscript` object to base the new instance on.
            persistentfile : bool, optional
                If `True`, the script will be saved to a persistent file. Defaults to `True`.
            persistentfolder : str or None, optional
                The folder where the persistent file will be saved. If `None`, a temporary location is used.
                Defaults to `None`.
            printflag : bool, optional
                If `True`, enables printing of the script details during execution. Defaults to `False`.
            verbose : bool, optional
                If `True`, provides detailed output during script initialization and execution. Defaults to `True`.
            softrun : bool, optional
                Determines whether a pre-execution run is carried out to partially evaluate and substitute variables.
                - If `True` (default), the variable definitions and original script content are preserved without full
                  evaluation, meaning no substitution is carried out on the `dscript`&#39;s templates or definitions.
                - If `False`, performs an initial evaluation phase that substitutes available variables and captures
                  the local definitions before creating the `lambdaScript` object.
            **userdefinitions
                Additional user-defined variables and configurations to be included in the `lambdaScript`.

            Raises
            ------
            TypeError
                If `dscriptobj` is not an instance of the `dscript` class.

            Example
            -------
            ```python
            existing_dscript = dscript(name=&#34;ExistingScript&#34;)
            ls = lambdaScript(existing_dscript, var3=&#34;3&#34;, softrun=False)
            ```
        &#34;&#34;&#34;
        if not isinstance(dscriptobj, dscript):
            raise TypeError(f&#34;The &#39;dscriptobj&#39; object must be of class dscript not {type(dscriptobj).__name__}.&#34;)
        verbose = dscriptobj.verbose if verbose is None else dscriptobj.verbose
        super().__init__(persistentfile=persistentfile, persistentfolder=persistentfolder, printflag=printflag, verbose=verbose, **userdefinitions)
        self.name = dscriptobj.name
        self.SECTIONS = dscriptobj.SECTIONS
        self.section = dscriptobj.section
        self.position = dscriptobj.position
        self._role = dscriptobj.role  # Initialize an internal storage for the role
        self.description = dscriptobj.description
        self.userid = dscriptobj.userid
        self.version= dscriptobj.version
        self.verbose = verbose
        self.printflag = printflag
        self.DEFINITIONS = dscriptobj.DEFINITIONS
        if softrun:
            self.TEMPLATE,localdefinitions = dscriptobj.do(softrun=softrun,return_definitions=True)
            self.USER = localdefinitions + lambdaScriptdata(**self.USER)
        else:
            self.TEMPLATE = dscriptobj.do(softrun=softrun)
            self.USER = lambdaScriptdata(**self.USER)

    @property
    def role(self):
        &#34;&#34;&#34;Override the role property to include a setter.&#34;&#34;&#34;
        # If _role is set, return it; otherwise, use the inherited logic
        if self._role is not None:
            return self._role
        elif self.section in range(len(self.SECTIONS)):
            return self.SECTIONS[self.section]
        else:
            return &#34;&#34;

    @role.setter
    def role(self, value):
        &#34;&#34;&#34;Allow setting the role.&#34;&#34;&#34;
        self._role = value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dscript.lamdaScript.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dscript.lamdaScript.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"><p>Override the role property to include a setter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def role(self):
    &#34;&#34;&#34;Override the role property to include a setter.&#34;&#34;&#34;
    # If _role is set, return it; otherwise, use the inherited logic
    if self._role is not None:
        return self._role
    elif self.section in range(len(self.SECTIONS)):
        return self.SECTIONS[self.section]
    else:
        return &#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dscript.paramauto"><code class="flex name class">
<span>class <span class="ident">paramauto</span></span>
<span>(</span><span>sortdefinitions=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-paramauto">Class: <code><a title="dscript.paramauto" href="#dscript.paramauto">paramauto</a></code></h1>
<p>A subclass of <code>param</code> with enhanced handling for automatic sorting and evaluation
of definitions. The <code><a title="dscript.paramauto" href="#dscript.paramauto">paramauto</a></code> class ensures that all fields are sorted to resolve
dependencies, allowing seamless stacking of partially defined objects.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Inherits all functionalities of <code>param</code>.</li>
<li>Automatically sorts definitions for dependency resolution.</li>
<li>Simplifies handling of partial definitions in dynamic structures.</li>
<li>Supports safe concatenation of definitions.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="automatic-dependency-sorting">Automatic Dependency Sorting</h4>
<p>Definitions are automatically sorted to resolve dependencies:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${b}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${b} (= 3)
# --------
</code></pre>
<h4 id="handling-missing-definitions">Handling Missing Definitions</h4>
<p>Unresolved dependencies raise warnings but do not block execution:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${d}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-inheritance">Concatenation and Inheritance</h3>
<p>Concatenating <code><a title="dscript.paramauto" href="#dscript.paramauto">paramauto</a></code> objects resolves definitions:</p>
<pre><code class="language-python">p1 = paramauto(a=1, b=&quot;${a}+2&quot;)
p2 = paramauto(c=&quot;${b}*3&quot;)
p3 = p1 + p2
p3.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 2 (= 3)
#      c: ${b} * 3 (= 9)
# --------
</code></pre>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Automatically sorts fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate all fields, resolving dependencies.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display all fields with their resolved values.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="overloaded-operators">Overloaded Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenates two <code><a title="dscript.paramauto" href="#dscript.paramauto">paramauto</a></code> objects, resolving dependencies.</li>
<li><code>+=</code>: Updates the current object with another, resolving dependencies.</li>
<li><code>len()</code>: Number of fields.</li>
<li><code>in</code>: Check for field existence.</li>
</ul>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="partial-definitions">Partial Definitions</h4>
<p>The <code><a title="dscript.paramauto" href="#dscript.paramauto">paramauto</a></code> class simplifies handling of partially defined fields:</p>
<pre><code class="language-python">p = paramauto(a=&quot;${d}&quot;, b=&quot;${a}+1&quot;)
p.disp()
# Warning: Unable to resolve dependencies.
# --------
#      a: ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
#      b: ${a} + 1 (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------

p.d = 10
p.disp()
# Dependencies are resolved:
# --------
#      d: 10
#      a: ${d} (= 10)
#      b: ${a} + 1 (= 11)
# --------
</code></pre>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>The <code><a title="dscript.paramauto" href="#dscript.paramauto">paramauto</a></code> class is computationally more intensive than <code>param</code> due to automatic sorting.</li>
<li>It is ideal for managing dynamic systems with complex interdependencies.</li>
</ul>
<h3 id="examples_1">Examples</h3>
<pre><code>            p = paramauto()
            p.b = "${aa}"
            p.disp()
        yields
            WARNING: unable to interpret 1/1 expressions in "definitions"
              -----------:----------------------------------------
                        b: ${aa}
                         = &lt; undef definition "${aa}" &gt;
              -----------:----------------------------------------
              p.aa = 2
              p.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
            -----------:----------------------------------------
            q = paramauto(c="${aa}+${b}")+p
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
                      c: ${aa}+${b}
                       = 4
            -----------:----------------------------------------
            q.aa = 30
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 30
                      b: ${aa}
                       = 30
                      c: ${aa}+${b}
                       = 60
            -----------:----------------------------------------
            q.aa = "${d}"
            q.disp()
        yields multiple errors (recursion)
        WARNING: unable to interpret 3/3 expressions in "definitions"
          -----------:----------------------------------------
                   aa: ${d}
                     = &lt; undef definition "${d}" &gt;
                    b: ${aa}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                    c: ${aa}+${b}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
          -----------:----------------------------------------
            q.d = 100
            q.disp()
        yields
          -----------:----------------------------------------
                    d: 100
                   aa: ${d}
                     = 100
                    b: ${aa}
                     = 100
                    c: ${aa}+${b}
                     = 200
          -----------:----------------------------------------


    Example:

        p = paramauto(b="${a}+1",c="${a}+${d}",a=1)
        p.disp()
    generates:
        WARNING: unable to interpret 1/3 expressions in "definitions"
          -----------:----------------------------------------
                    a: 1
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = &lt; undef definition "${d}" &gt;
          -----------:----------------------------------------
    setting p.d
        p.d = 2
        p.disp()
    produces
          -----------:----------------------------------------
                    a: 1
                    d: 2
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = 3
          -----------:----------------------------------------
</code></pre>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class paramauto(param):
    &#34;&#34;&#34;
    Class: `paramauto`
    ==================

    A subclass of `param` with enhanced handling for automatic sorting and evaluation
    of definitions. The `paramauto` class ensures that all fields are sorted to resolve
    dependencies, allowing seamless stacking of partially defined objects.

    ---

    ### Features
    - Inherits all functionalities of `param`.
    - Automatically sorts definitions for dependency resolution.
    - Simplifies handling of partial definitions in dynamic structures.
    - Supports safe concatenation of definitions.

    ---

    ### Examples

    #### Automatic Dependency Sorting
    Definitions are automatically sorted to resolve dependencies:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${b}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${b} (= 3)
    # --------
    ```

    #### Handling Missing Definitions
    Unresolved dependencies raise warnings but do not block execution:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------
    ```

    ---

    ### Concatenation and Inheritance
    Concatenating `paramauto` objects resolves definitions:
    ```python
    p1 = paramauto(a=1, b=&#34;${a}+2&#34;)
    p2 = paramauto(c=&#34;${b}*3&#34;)
    p3 = p1 + p2
    p3.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 2 (= 3)
    #      c: ${b} * 3 (= 9)
    # --------
    ```

    ---

    ### Utility Methods

    | Method                | Description                                            |
    |-----------------------|--------------------------------------------------------|
    | `sortdefinitions()`   | Automatically sorts fields to resolve dependencies.    |
    | `eval()`              | Evaluate all fields, resolving dependencies.           |
    | `disp()`              | Display all fields with their resolved values.         |

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `+`: Concatenates two `paramauto` objects, resolving dependencies.
    - `+=`: Updates the current object with another, resolving dependencies.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Advanced Usage

    #### Partial Definitions
    The `paramauto` class simplifies handling of partially defined fields:
    ```python
    p = paramauto(a=&#34;${d}&#34;, b=&#34;${a}+1&#34;)
    p.disp()
    # Warning: Unable to resolve dependencies.
    # --------
    #      a: ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      b: ${a} + 1 (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------

    p.d = 10
    p.disp()
    # Dependencies are resolved:
    # --------
    #      d: 10
    #      a: ${d} (= 10)
    #      b: ${a} + 1 (= 11)
    # --------
    ```

    ---

    ### Notes
    - The `paramauto` class is computationally more intensive than `param` due to automatic sorting.
    - It is ideal for managing dynamic systems with complex interdependencies.

    ### Examples
                    p = paramauto()
                    p.b = &#34;${aa}&#34;
                    p.disp()
                yields
                    WARNING: unable to interpret 1/1 expressions in &#34;definitions&#34;
                      -----------:----------------------------------------
                                b: ${aa}
                                 = &lt; undef definition &#34;${aa}&#34; &gt;
                      -----------:----------------------------------------
                      p.aa = 2
                      p.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                    -----------:----------------------------------------
                    q = paramauto(c=&#34;${aa}+${b}&#34;)+p
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                              c: ${aa}+${b}
                               = 4
                    -----------:----------------------------------------
                    q.aa = 30
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 30
                              b: ${aa}
                               = 30
                              c: ${aa}+${b}
                               = 60
                    -----------:----------------------------------------
                    q.aa = &#34;${d}&#34;
                    q.disp()
                yields multiple errors (recursion)
                WARNING: unable to interpret 3/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                           aa: ${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                            b: ${aa}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                            c: ${aa}+${b}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                  -----------:----------------------------------------
                    q.d = 100
                    q.disp()
                yields
                  -----------:----------------------------------------
                            d: 100
                           aa: ${d}
                             = 100
                            b: ${aa}
                             = 100
                            c: ${aa}+${b}
                             = 200
                  -----------:----------------------------------------


            Example:

                p = paramauto(b=&#34;${a}+1&#34;,c=&#34;${a}+${d}&#34;,a=1)
                p.disp()
            generates:
                WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                            a: 1
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                  -----------:----------------------------------------
            setting p.d
                p.d = 2
                p.disp()
            produces
                  -----------:----------------------------------------
                            a: 1
                            d: 2
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = 3
                  -----------:----------------------------------------

    &#34;&#34;&#34;

    def __add__(self,p):
        return super(param,self).__add__(p,sortdefinitions=True,raiseerror=False)

    def __iadd__(self,p):
        return super(param,self).__iadd__(p,sortdefinitions=True,raiseerror=False)

    def __repr__(self):
        self.sortdefinitions(raiseerror=False)
        #super(param,self).__repr__()
        super().__repr__()
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dscript.lambdaScriptdata" href="#dscript.lambdaScriptdata">lambdaScriptdata</a></li>
<li>pizza.dscript.lambdaScriptdata</li>
<li>pizza.forcefield.parameterforcefield</li>
<li>pizza.region.regiondata</li>
</ul>
</dd>
<dt id="dscript.pipescript"><code class="flex name class">
<span>class <span class="ident">pipescript</span></span>
<span>(</span><span>s=None, name=None, printflag=False, verbose=True, verbosity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>pipescript: A Class for Managing Script Pipelines</p>
<p>The <code><a title="dscript.pipescript" href="#dscript.pipescript">pipescript</a></code> class stores scripts in a pipeline where multiple scripts,
script objects, or script object groups can be combined and executed
sequentially. Scripts in the pipeline are executed using the pipe (<code>|</code>) operator,
allowing for dynamic control over execution order, script concatenation, and
variable management.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Pipeline Construction</strong>: Create pipelines of scripts, combining multiple
script objects, <code><a title="dscript.script" href="#dscript.script">script</a></code>, <code>scriptobject</code>, or <code><a title="dscript.scriptobjectgroup" href="#dscript.scriptobjectgroup">scriptobjectgroup</a></code> instances.
The pipe operator (<code>|</code>) is overloaded to concatenate scripts.</li>
<li><strong>Sequential Execution</strong>: Execute all scripts in the pipeline in the order
they were added, with support for reordering, selective execution, and
clearing of individual steps.</li>
<li><strong>User and Definition Spaces</strong>: Manage local and global user-defined variables
(<code>USER</code> space) and static definitions for each script in the pipeline.
Global definitions apply to all scripts in the pipeline, while local variables
apply to specific steps.</li>
<li><strong>Flexible Script Handling</strong>: Indexing, slicing, reordering, and renaming
scripts in the pipeline are supported. Scripts can be accessed, replaced,
and modified like array elements.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>LAMMPS Script Automation</strong>: Automate the generation of multi-step simulation
scripts for LAMMPS, combining different simulation setups into a single pipeline.</li>
<li><strong>Script Management</strong>: Combine and manage multiple scripts, tracking user
variables and ensuring that execution order can be adjusted easily.</li>
<li><strong>Advanced Script Execution</strong>: Perform partial pipeline execution, reorder
steps, or clear completed steps while maintaining the original pipeline structure.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, s=None):
Initializes a new <code><a title="dscript.pipescript" href="#dscript.pipescript">pipescript</a></code> object, optionally starting with a script
or script-like object (<code><a title="dscript.script" href="#dscript.script">script</a></code>, <code>scriptobject</code>, <code><a title="dscript.scriptobjectgroup" href="#dscript.scriptobjectgroup">scriptobjectgroup</a></code>).</p>
<p>setUSER(self, idx, key, value):
Set a user-defined variable (<code>USER</code>) for the script at the specified index.</p>
<p>getUSER(self, idx, key):
Get the value of a user-defined variable (<code>USER</code>) for the script at the
specified index.</p>
<p>clear(self, idx=None):
Clear the execution status of scripts in the pipeline, allowing them to
be executed again.</p>
<p>do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Execute the pipeline or a subset of the pipeline, generating a combined
LAMMPS-compatible script.</p>
<p>script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Generate the final LAMMPS script from the pipeline or a subset of the pipeline.</p>
<p>rename(self, name="", idx=None):
Rename the scripts in the pipeline, assigning new names to specific
indices or all scripts.</p>
<p>write(self, file, printflag=True, verbosity=2, verbose=None):
Write the generated script to a file.</p>
<p>dscript(self, verbose=None, **USER)
Convert the current pipescript into a dscript object</p>
<p>header(self, verbose=True,verbosity=None, style=4):
Generate a formatted header for the pipescript file.</p>
<p>list_values(self, varname, what="all"):
List all occurrences and values of a variable across the pipeline scripts.</p>
<p>list_multiple_values(self, varnames, what="all"):
List all occurrences and values of multiple variables across the pipeline scripts.</p>
<p>plot_value_distribution(self, varname, what="all"):
Plot the distribution of values for a given variable across specified scopes.</p>
<p>generate_report(self, filename, varnames=None, scopes="all"):
Generate a comprehensive report for specified variables and writes it to a file.</p>
<h2 id="static-methods">Static Methods:</h2>
<p>join(liste):
Combine a list of <code><a title="dscript.script" href="#dscript.script">script</a></code> and <code><a title="dscript.pipescript" href="#dscript.pipescript">pipescript</a></code> objects into a single pipeline.</p>
<h2 id="additional-features">Additional Features:</h2>
<ul>
<li><strong>Indexing and Slicing</strong>: Use array-like indexing (<code>p[0]</code>, <code>p[1:3]</code>) to access
and manipulate scripts in the pipeline.</li>
<li><strong>Deep Copy Support</strong>: The pipeline supports deep copying, preserving the
entire pipeline structure and its scripts.</li>
<li><strong>Verbose and Print Options</strong>: Control verbosity and printing behavior for
generated scripts, allowing for detailed output or minimal script generation.</li>
</ul>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="dscript.pipescript" href="#dscript.pipescript">pipescript</a></code> class supports a variety of pipeline operations, including:
- Sequential execution with <code>cmd = p.do()</code>.
- Reordering pipelines with <code>p[[2, 0, 1]]</code>.
- Deleting steps with <code>p[[0, 1]] = []</code>.
- Accessing local and global user space variables via <code>p.USER[idx].var</code> and
<code>p.scripts[idx].USER.var</code>.
- Managing static definitions for each script in the pipeline.
- Example usage:
<code>p = pipescript()
p | i
p = G | c | g | d | b | i | t | d | s | r
p.rename(["G", "c", "g", "d", "b", "i", "t", "d", "s", "r"])
cmd = p.do([0, 1, 4, 7])
sp = p.script([0, 1, 4, 7])</code>
- Scripts in the pipeline are executed sequentially, and definitions propagate
from left to right. The <code>USER</code> space and <code>DEFINITIONS</code> are managed separately
for each script in the pipeline.</p>
<h2 id="overview">Overview</h2>
<pre><code>Pipescript class stores scripts in pipelines
    By assuming: s0, s1, s2... scripts, scriptobject or scriptobjectgroup
    p = s0 | s1 | s2 generates a pipe script

    Example of pipeline:
  ------------:----------------------------------------
  [-]  00: G with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  01: c with (0&gt;&gt;0&gt;&gt;10) DEFINITIONS
  [-]  02: g with (0&gt;&gt;0&gt;&gt;26) DEFINITIONS
  [-]  03: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  04: b with (0&gt;&gt;0&gt;&gt;28) DEFINITIONS
  [-]  05: i with (0&gt;&gt;0&gt;&gt;49) DEFINITIONS
  [-]  06: t with (0&gt;&gt;0&gt;&gt;2) DEFINITIONS
  [-]  07: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  08: s with (0&gt;&gt;0&gt;&gt;1) DEFINITIONS
  [-]  09: r with (0&gt;&gt;0&gt;&gt;20) DEFINITIONS
  ------------:----------------------------------------
Out[35]: pipescript containing 11 scripts with 8 executed[*]

note: XX&gt;&gt;YY&gt;&gt;ZZ represents the number of stored variables
     and the direction of propagation (inheritance from left)
     XX: number of definitions in the pipeline USER space
     YY: number of definitions in the script instance (frozen in the pipeline)
     ZZ: number of definitions in the script (frozen space)

    pipelines are executed sequentially (i.e. parameters can be multivalued)
        cmd = p.do()
        fullscript = p.script()

    pipelines are indexed
        cmd = p[[0,2]].do()
        cmd = p[0:2].do()
        cmd = p.do([0,2])

    pipelines can be reordered
        q = p[[2,0,1]]

    steps can be deleted
        p[[0,1]] = []

    clear all executions with
        p.clear()
        p.clear(idx=1,2)

    local USER space can be accessed via
    (affects only the considered step)
        p.USER[0].a = 1
        p.USER[0].b = [1 2]
        p.USER[0].c = "$ hello world"

    global USER space can accessed via
    (affects all steps onward)
        p.scripts[0].USER.a = 10
        p.scripts[0].USER.b = [10 20]
        p.scripts[0].USER.c = "$ bye bye"

    static definitions
        p.scripts[0].DEFINITIONS

    steps can be renamed with the method rename()

    syntaxes are à la Matlab:
        p = pipescript()
        p | i
        p = collection | G
        p[0]
        q = p | p
        q[0] = []
        p[0:1] = q[0:1]
        p = G | c | g | d | b | i | t | d | s | r
        p.rename(["G","c","g","d","b","i","t","d","s","r"])
        cmd = p.do([0,1,4,7])
        sp = p.script([0,1,4,7])
        r = collection | p

    join joins a list (static method)
        p = pipescript.join([p1,p2,s3,s4])


    Pending: mechanism to store LAMMPS results (dump3) in the pipeline
</code></pre>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pipescript:
    &#34;&#34;&#34;
    pipescript: A Class for Managing Script Pipelines

    The `pipescript` class stores scripts in a pipeline where multiple scripts,
    script objects, or script object groups can be combined and executed
    sequentially. Scripts in the pipeline are executed using the pipe (`|`) operator,
    allowing for dynamic control over execution order, script concatenation, and
    variable management.

    Key Features:
    -------------
    - **Pipeline Construction**: Create pipelines of scripts, combining multiple
      script objects, `script`, `scriptobject`, or `scriptobjectgroup` instances.
      The pipe operator (`|`) is overloaded to concatenate scripts.
    - **Sequential Execution**: Execute all scripts in the pipeline in the order
      they were added, with support for reordering, selective execution, and
      clearing of individual steps.
    - **User and Definition Spaces**: Manage local and global user-defined variables
      (`USER` space) and static definitions for each script in the pipeline.
      Global definitions apply to all scripts in the pipeline, while local variables
      apply to specific steps.
    - **Flexible Script Handling**: Indexing, slicing, reordering, and renaming
      scripts in the pipeline are supported. Scripts can be accessed, replaced,
      and modified like array elements.

    Practical Use Cases:
    --------------------
    - **LAMMPS Script Automation**: Automate the generation of multi-step simulation
      scripts for LAMMPS, combining different simulation setups into a single pipeline.
    - **Script Management**: Combine and manage multiple scripts, tracking user
      variables and ensuring that execution order can be adjusted easily.
    - **Advanced Script Execution**: Perform partial pipeline execution, reorder
      steps, or clear completed steps while maintaining the original pipeline structure.

    Methods:
    --------
    __init__(self, s=None):
        Initializes a new `pipescript` object, optionally starting with a script
        or script-like object (`script`, `scriptobject`, `scriptobjectgroup`).

    setUSER(self, idx, key, value):
        Set a user-defined variable (`USER`) for the script at the specified index.

    getUSER(self, idx, key):
        Get the value of a user-defined variable (`USER`) for the script at the
        specified index.

    clear(self, idx=None):
        Clear the execution status of scripts in the pipeline, allowing them to
        be executed again.

    do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Execute the pipeline or a subset of the pipeline, generating a combined
        LAMMPS-compatible script.

    script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Generate the final LAMMPS script from the pipeline or a subset of the pipeline.

    rename(self, name=&#34;&#34;, idx=None):
        Rename the scripts in the pipeline, assigning new names to specific
        indices or all scripts.

    write(self, file, printflag=True, verbosity=2, verbose=None):
        Write the generated script to a file.

    dscript(self, verbose=None, **USER)
        Convert the current pipescript into a dscript object

    header(self, verbose=True,verbosity=None, style=4):
        Generate a formatted header for the pipescript file.

    list_values(self, varname, what=&#34;all&#34;):
        List all occurrences and values of a variable across the pipeline scripts.

    list_multiple_values(self, varnames, what=&#34;all&#34;):
        List all occurrences and values of multiple variables across the pipeline scripts.

    plot_value_distribution(self, varname, what=&#34;all&#34;):
        Plot the distribution of values for a given variable across specified scopes.

    generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
        Generate a comprehensive report for specified variables and writes it to a file.


    Static Methods:
    ---------------
    join(liste):
        Combine a list of `script` and `pipescript` objects into a single pipeline.

    Additional Features:
    --------------------
    - **Indexing and Slicing**: Use array-like indexing (`p[0]`, `p[1:3]`) to access
      and manipulate scripts in the pipeline.
    - **Deep Copy Support**: The pipeline supports deep copying, preserving the
      entire pipeline structure and its scripts.
    - **Verbose and Print Options**: Control verbosity and printing behavior for
      generated scripts, allowing for detailed output or minimal script generation.

    Original Content:
    -----------------
    The `pipescript` class supports a variety of pipeline operations, including:
    - Sequential execution with `cmd = p.do()`.
    - Reordering pipelines with `p[[2, 0, 1]]`.
    - Deleting steps with `p[[0, 1]] = []`.
    - Accessing local and global user space variables via `p.USER[idx].var` and
      `p.scripts[idx].USER.var`.
    - Managing static definitions for each script in the pipeline.
    - Example usage:
      ```
      p = pipescript()
      p | i
      p = G | c | g | d | b | i | t | d | s | r
      p.rename([&#34;G&#34;, &#34;c&#34;, &#34;g&#34;, &#34;d&#34;, &#34;b&#34;, &#34;i&#34;, &#34;t&#34;, &#34;d&#34;, &#34;s&#34;, &#34;r&#34;])
      cmd = p.do([0, 1, 4, 7])
      sp = p.script([0, 1, 4, 7])
      ```
    - Scripts in the pipeline are executed sequentially, and definitions propagate
      from left to right. The `USER` space and `DEFINITIONS` are managed separately
      for each script in the pipeline.

    OVERVIEW
    -----------------
        Pipescript class stores scripts in pipelines
            By assuming: s0, s1, s2... scripts, scriptobject or scriptobjectgroup
            p = s0 | s1 | s2 generates a pipe script

            Example of pipeline:
          ------------:----------------------------------------
          [-]  00: G with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  01: c with (0&gt;&gt;0&gt;&gt;10) DEFINITIONS
          [-]  02: g with (0&gt;&gt;0&gt;&gt;26) DEFINITIONS
          [-]  03: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  04: b with (0&gt;&gt;0&gt;&gt;28) DEFINITIONS
          [-]  05: i with (0&gt;&gt;0&gt;&gt;49) DEFINITIONS
          [-]  06: t with (0&gt;&gt;0&gt;&gt;2) DEFINITIONS
          [-]  07: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  08: s with (0&gt;&gt;0&gt;&gt;1) DEFINITIONS
          [-]  09: r with (0&gt;&gt;0&gt;&gt;20) DEFINITIONS
          ------------:----------------------------------------
        Out[35]: pipescript containing 11 scripts with 8 executed[*]

        note: XX&gt;&gt;YY&gt;&gt;ZZ represents the number of stored variables
             and the direction of propagation (inheritance from left)
             XX: number of definitions in the pipeline USER space
             YY: number of definitions in the script instance (frozen in the pipeline)
             ZZ: number of definitions in the script (frozen space)

            pipelines are executed sequentially (i.e. parameters can be multivalued)
                cmd = p.do()
                fullscript = p.script()

            pipelines are indexed
                cmd = p[[0,2]].do()
                cmd = p[0:2].do()
                cmd = p.do([0,2])

            pipelines can be reordered
                q = p[[2,0,1]]

            steps can be deleted
                p[[0,1]] = []

            clear all executions with
                p.clear()
                p.clear(idx=1,2)

            local USER space can be accessed via
            (affects only the considered step)
                p.USER[0].a = 1
                p.USER[0].b = [1 2]
                p.USER[0].c = &#34;$ hello world&#34;

            global USER space can accessed via
            (affects all steps onward)
                p.scripts[0].USER.a = 10
                p.scripts[0].USER.b = [10 20]
                p.scripts[0].USER.c = &#34;$ bye bye&#34;

            static definitions
                p.scripts[0].DEFINITIONS

            steps can be renamed with the method rename()

            syntaxes are à la Matlab:
                p = pipescript()
                p | i
                p = collection | G
                p[0]
                q = p | p
                q[0] = []
                p[0:1] = q[0:1]
                p = G | c | g | d | b | i | t | d | s | r
                p.rename([&#34;G&#34;,&#34;c&#34;,&#34;g&#34;,&#34;d&#34;,&#34;b&#34;,&#34;i&#34;,&#34;t&#34;,&#34;d&#34;,&#34;s&#34;,&#34;r&#34;])
                cmd = p.do([0,1,4,7])
                sp = p.script([0,1,4,7])
                r = collection | p

            join joins a list (static method)
                p = pipescript.join([p1,p2,s3,s4])


            Pending: mechanism to store LAMMPS results (dump3) in the pipeline
    &#34;&#34;&#34;

    def __init__(self,s=None, name=None, printflag=False, verbose=True, verbosity = None):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        self.globalscript = None
        self.listscript = []
        self.listUSER = []
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.cmd = &#34;&#34;
        if isinstance(s,script):
            self.listscript = [duplicate(s)]
            self.listUSER = [scriptdata()]
        elif isinstance(s,scriptobject):
            self.listscript = [scriptobjectgroup(s).script]
            self.listUSER = [scriptdata()]
        elif isinstance(s,scriptobjectgroup):
            self.listscript = [s.script]
            self.listUSER = [scriptdata()]
        else:
            ValueError(&#34;the argument should be a scriptobject or scriptobjectgroup&#34;)
        if s != None:
            self.name = [str(s)]
            self.executed = [False]
        else:
            self.name = []
            self.executed = []

    def setUSER(self,idx,key,value):
        &#34;&#34;&#34;
            setUSER sets USER variables
            setUSER(idx,varname,varvalue)
        &#34;&#34;&#34;
        if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
            self.listUSER[idx].setattr(key,value)
        else:
            raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)

    def getUSER(self,idx,key):
        &#34;&#34;&#34;
            getUSER get USER variable
            getUSER(idx,varname)
        &#34;&#34;&#34;
        if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
            self.listUSER[idx].getattr(key)
        else:
            raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)

    @property
    def USER(self):
        &#34;&#34;&#34;
            p.USER[idx].var returns the value of the USER variable var
            p.USER[idx].var = val assigns the value val to the USER variable var
        &#34;&#34;&#34;
        return self.listUSER  # override listuser

    @property
    def scripts(self):
        &#34;&#34;&#34;
            p.scripts[idx].USER.var returns the value of the USER variable var
            p.scripts[idx].USER.var = val assigns the value val to the USER variable var
        &#34;&#34;&#34;
        return self.listscript # override listuser

    def __add__(self,s):
        &#34;&#34;&#34; overload + as pipe with copy &#34;&#34;&#34;
        from pizza.dscript import dscript
        if isinstance(s,(pipescript,script)):
            dup = deepduplicate(self)
            return dup | s      # + or | are synonyms
        elif isinstance(s,scriptobject):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s,dscript):
            return self + s.pipescript(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        else:
            raise TypeError(f&#34;The operand should be a pipescript/script/dscript/scriptobjectgroup and not &#39;{type(s).__name__}&#39;&#34;)

    def __iadd__(self,s):
        &#34;&#34;&#34; overload += as pipe without copy &#34;&#34;&#34;
        if isinstance(s,pipescript):
            return self | s      # + or | are synonyms
        else:
            raise TypeError(f&#34;The operand should be a pipescript and not &#39;{type(s).__name__}&#39;&#34;)

    def __mul__(self,ntimes):
        &#34;&#34;&#34; overload * as multiple pipes with copy &#34;&#34;&#34;
        if isinstance(self,pipescript):
            res = deepduplicate(self)
            if ntimes&gt;1:
                for n in range(1,ntimes): res += self
            return res
        else:
            raise TypeError(f&#34;The operand should be a pipescript and not &#39;{type(s).__name__}&#39;&#34;)



    def __or__(self, s):
        &#34;&#34;&#34; Overload | pipe operator in pipescript &#34;&#34;&#34;
        leftarg = deepduplicate(self)  # Make a deep copy of the current object
        # Local import only when dscript type needs to be checked
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        # Convert rightarg to pipescript if needed
        if isinstance(s, dscript):
            rightarg = s.pipescript(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the dscript object to a pipescript
            native = False
        elif isinstance(s,script):
            rightarg = pipescript(s,printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s,(scriptobject,scriptobjectgroup)):
            rightarg = pipescript(s,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, group):
            stmp = s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
            rightarg = pipescript(stmp,printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, groupcollection):
            stmp = s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
            rightarg = pipescript(stmp,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, region):
            rightarg = s.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s,pipescript):
            rightarg = s
            native = True
        else:
            raise TypeError(f&#34;The operand should be a pipescript, dscript, script, scriptobject, scriptobjectgroup, group or groupcollection not {type(s)}&#34;)
        # Native piping
        if native:
            leftarg.listscript = leftarg.listscript + rightarg.listscript
            leftarg.listUSER = leftarg.listUSER + rightarg.listUSER
            leftarg.name = leftarg.name + rightarg.name
            for i in range(len(rightarg)):
                rightarg.executed[i] = False
            leftarg.executed = leftarg.executed + rightarg.executed
            return leftarg
        # Piping for non-native objects (dscript or script-like objects)
        else:
            # Loop through all items in rightarg and concatenate them
            for i in range(rightarg.n):
                leftarg.listscript.append(rightarg.listscript[i])
                leftarg.listUSER.append(rightarg.listUSER[i])
                leftarg.name.append(rightarg.name[i])
                leftarg.executed.append(False)
            return leftarg



    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;pipescript containing {self.n} scripts with {self.nrun} executed[*]&#34;


    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        line = &#34;  &#34;+&#34;-&#34;*12+&#34;:&#34;+&#34;-&#34;*40
        if self.verbose:
            print(&#34;&#34;,&#34;Pipeline with %d scripts and&#34; % self.n,
                  &#34;D(STATIC:GLOBAL:LOCAL) DEFINITIONS&#34;,line,sep=&#34;\n&#34;)
        else:
            print(line)
        for i in range(len(self)):
            if self.executed[i]:
                state = &#34;*&#34;
            else:
                state = &#34;-&#34;
            print(&#34;%10s&#34; % (&#34;[%s]  %02d:&#34; % (state,i)),
                  self.name[i],&#34;with D(%2d:%2d:%2d)&#34; % (
                       len(self.listscript[i].DEFINITIONS),
                       len(self.listscript[i].USER),
                       len(self.listUSER[i])                 )
                  )
        if self.verbose:
            print(line,&#34;::: notes :::&#34;,&#34;p[i], p[i:j], p[[i,j]] copy pipeline segments&#34;,
                  &#34;LOCAL: p.USER[i],p.USER[i].variable modify the user space of only p[i]&#34;,
                  &#34;GLOBAL: p.scripts[i].USER.var to modify the user space from p[i] and onwards&#34;,
                  &#34;STATIC: p.scripts[i].DEFINITIONS&#34;,
                  &#39;p.rename(idx=range(2),name=[&#34;A&#34;,&#34;B&#34;]), p.clear(idx=[0,3,4])&#39;,
                  &#34;p.script(), p.script(idx=range(5)), p[0:5].script()&#34;,&#34;&#34;,sep=&#34;\n&#34;)
        else:
             print(line)
        return str(self)

    def __len__(self):
        &#34;&#34;&#34; len() method &#34;&#34;&#34;
        return len(self.listscript)

    @property
    def n(self):
        &#34;&#34;&#34; number of scripts &#34;&#34;&#34;
        return len(self)

    @property
    def nrun(self):
        &#34;&#34;&#34; number of scripts executed continuously from origin &#34;&#34;&#34;
        n, nmax  = 0, len(self)
        while n&lt;nmax and self.executed[n]: n+=1
        return n

    def __getitem__(self,idx):
        &#34;&#34;&#34; return the ith or slice element(s) of the pipe  &#34;&#34;&#34;
        dup = deepduplicate(self)
        if isinstance(idx,slice):
            dup.listscript = dup.listscript[idx]
            dup.listUSER = dup.listUSER[idx]
            dup.name = dup.name[idx]
            dup.executed = dup.executed[idx]
        elif isinstance(idx,int):
            if idx&lt;len(self):
                dup.listscript = dup.listscript[idx:idx+1]
                dup.listUSER = dup.listUSER[idx:idx+1]
                dup.name = dup.name[idx:idx+1]
                dup.executed = dup.executed[idx:idx+1]
            else:
                raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,list):
            dup.listscript = picker(dup.listscript,idx)
            dup.listUSER = picker(dup.listUSER,idx)
            dup.name = picker(dup.name,idx)
            dup.executed = picker(dup.executed,idx)
        else:
            raise IndexError(&#34;the index needs to be a slice or an integer&#34;)
        return dup

    def __setitem__(self,idx,s):
        &#34;&#34;&#34;
            modify the ith element of the pipe
                p[4] = [] removes the 4th element
                p[4:7] = [] removes the elements from position 4 to 6
                p[2:4] = p[0:2] copy the elements 0 and 1 in positions 2 and 3
                p[[3,4]]=p[0]
        &#34;&#34;&#34;
        if isinstance(s,(script,scriptobject,scriptobjectgroup)):
            dup = pipescript(s)
        elif isinstance(s,pipescript):
            dup = s
        elif s==[]:
            dup = []
        else:
            raise ValueError(&#34;the value must be a pipescript, script, scriptobject, scriptobjectgroup&#34;)
        if len(s)&lt;1: # remove (delete)
            if isinstance(idx,slice) or idx&lt;len(self):
                del self.listscript[idx]
                del self.listUSER[idx]
                del self.name[idx]
                del self.executed[idx]
            else:
                raise IndexError(&#34;the index must be a slice or an integer&#34;)
        elif len(s)==1: # scalar
            if isinstance(idx,int):
                if idx&lt;len(self):
                    self.listscript[idx] = dup.listscript[0]
                    self.listUSER[idx] = dup.listUSER[0]
                    self.name[idx] = dup.name[0]
                    self.executed[idx] = False
                elif idx==len(self):
                    self.listscript.append(dup.listscript[0])
                    self.listUSER.append(dup.listUSER[0])
                    self.name.append(dup.name[0])
                    self.executed.append(False)
                else:
                    raise IndexError(f&#34;the index must be ranged between 0 and {self.n}&#34;)
            elif isinstance(idx,list):
                for i in range(len(idx)):
                    self.__setitem__(idx[i], s) # call as a scalar
            elif isinstance(idx,slice):
                for i in range(*idx.indices(len(self)+1)):
                    self.__setitem__(i, s)
            else:
                raise IndexError(&#34;unrocognized index value, the index should be an integer or a slice&#34;)
        else: # many values
            if isinstance(idx,list): # list call à la Matlab
                if len(idx)==len(s):
                    for i in range(len(s)):
                        self.__setitem__(idx[i], s[i]) # call as a scalar
                else:
                    raise IndexError(f&#34;the number of indices {len(list)} does not match the number of values {len(s)}&#34;)
            elif isinstance(idx,slice):
                ilist = list(range(*idx.indices(len(self)+len(s))))
                self.__setitem__(ilist, s) # call as a list
            else:
                raise IndexError(&#34;unrocognized index value, the index should be an integer or a slice&#34;)

    def rename(self,name=&#34;&#34;,idx=None):
        &#34;&#34;&#34;
            rename scripts in the pipe
                p.rename(idx=[0,2,3],name=[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;])
        &#34;&#34;&#34;
        if isinstance(name,list):
            if len(name)==len(self) and idx==None:
                self.name = name
            elif len(name) == len(idx):
                for i in range(len(idx)):
                    self.rename(name[i],idx[i])
            else:
                IndexError(f&#34;the number of indices {len(idx)} does not match the number of names {len(name)}&#34;)
        elif idx !=None and idx&lt;len(self) and name!=&#34;&#34;:
            self.name[idx] = name
        else:
            raise ValueError(&#34;provide a non empty name and valid index&#34;)

    def clear(self,idx=None):
        if len(self)&gt;0:
            if idx==None:
                for i in range(len(self)):
                    self.clear(i)
            else:
                if isinstance(idx,(range,list)):
                    for i in idx:
                        self.clear(idx=i)
                elif isinstance(idx,int) and idx&lt;len(self):
                    self.executed[idx] = False
                else:
                    raise IndexError(f&#34;the index should be ranged between 0 and {self.n-1}&#34;)
            if not self.executed[0]:
                self.globalscript = None
                self.cmd = &#34;&#34;



    def do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        &#34;&#34;&#34;
        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        Parameters:
            idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
            printflag (bool, optional): Whether to print the script for each step. Default is True.
            verbosity (int, optional): Level of verbosity for the output.
            verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
            forced (bool, optional): If True, forces the pipeline to regenerate all scripts.

        Returns:
            str: Combined LAMMPS script for the specified pipeline steps.

            Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

            This method processes the pipeline of script objects, executing each step to generate
            a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
            or for a specified range of indices. The generated script can include comments and
            metadata based on the verbosity level.


        Method Workflow:
            - The method first checks if there are any script objects in the pipeline.
              If the pipeline is empty, it returns a message indicating that there is nothing to execute.
            - It determines the start and stop indices for the range of steps to execute.
              If idx is not provided, it defaults to executing all steps from the last executed position.
            - If a specific index or list of indices is provided, it executes only those steps.
            - The pipeline steps are executed in order, combining the scripts using the
              &gt;&gt; operator for sequential execution.
            - The generated script includes comments indicating the current run step and pipeline range,
              based on the specified verbosity level.
            - The final combined script is returned as a string.

        Example Usage:
        --------------
            &gt;&gt;&gt; p = pipescript()
            &gt;&gt;&gt; # Execute the entire pipeline
            &gt;&gt;&gt; full_script = p.do()
            &gt;&gt;&gt; # Execute steps 0 and 2 only
            &gt;&gt;&gt; partial_script = p.do([0, 2])
            &gt;&gt;&gt; # Execute step 1 with minimal verbosity
            &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

            Notes:
            - The method uses modular arithmetic to handle index wrapping, allowing
              for cyclic execution of pipeline steps.
            - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
            - The globalscript is initialized or updated with each step&#39;s script,
              and the USER definitions are accumulated across the steps.
            - The command string self.cmd is updated with the generated script for
              each step in the specified range.

            Raises:
            - None: The method does not raise exceptions directly, but an empty pipeline will
                    result in the return of &#34;# empty pipe - nothing to do&#34;.
        &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        if len(self) == 0:
            return &#34;# empty pipe - nothing to do&#34;

        # Check if not all steps are executed or if there are gaps
        not_all_executed = not all(self.executed[:self.nrun])  # Check up to the last executed step

        # Determine pipeline range
        total_steps = len(self)
        if self.globalscript is None or forced or not_all_executed:
            start = 0
            self.cmd = &#34;&#34;
        else:
            start = self.nrun
            self.cmd = self.cmd.rstrip(&#34;\n&#34;) + &#34;\n\n&#34;

        if idx is None:
            idx = range(start, total_steps)
        if isinstance(idx, int):
            idx = [idx]
        if isinstance(idx, range):
            idx = list(idx)

        idx = [i % total_steps for i in idx]
        start, stop = min(idx), max(idx)

        # Prevent re-executing already completed steps
        if not forced:
            idx = [step for step in idx if not self.executed[step]]

        # Execute pipeline steps
        for step in idx:
            step_wrapped = step % total_steps

            # Combine scripts
            if step_wrapped == 0:
                self.globalscript = self.listscript[step_wrapped]
            else:
                self.globalscript = self.globalscript &gt;&gt; self.listscript[step_wrapped]

            # Step label
            step_name = f&#34;&lt;{self.name[step]}&gt;&#34;
            step_label = f&#34;# [{step+1} of {total_steps} from {start}:{stop}] {step_name}&#34;

            # Get script content for the step
            step_output = self.globalscript.do(printflag=printflag, verbose=verbosity &gt; 1)

            # Add comments and content
            if step_output.strip():
                self.cmd += f&#34;{step_label}\n{step_output.strip()}\n\n&#34;
            elif verbosity &gt; 0:
                self.cmd += f&#34;{step_label} :: no content\n\n&#34;

            # Update USER definitions
            self.globalscript.USER += self.listUSER[step]
            self.executed[step] = True

        # Clean up and finalize script
        self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;).strip()  # Remove literal \\n and extra spaces
        self.cmd += &#34;\n&#34;  # Ensure trailing newline
        return remove_comments(self.cmd) if verbosity == 0 else self.cmd


    def do_legacy(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        &#34;&#34;&#34;
        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        This method processes the pipeline of script objects, executing each step to generate
        a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
        or for a specified range of indices. The generated script can include comments and
        metadata based on the verbosity level.

        Parameters:
        - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                               If None, all steps from the current position to
                                               the end are executed. A list of indices can be
                                               provided to execute specific steps, or a single
                                               integer can be passed to execute a specific step.
                                               Default is None.
        - printflag (bool, optional): If True, the generated script for each step is printed
                                      to the console. Default is True.
        - verbosity (int, optional): Controls the level of detail in the generated script.
                                     - 0: Minimal output, no comments.
                                     - 1: Basic comments for run steps.
                                     - 2: Detailed comments with additional information.
                                     Default is 2.
        - forced (bool, optional): If True, all scripts are regenerated

        Returns:
        - str: The combined LAMMPS script generated from the specified steps of the pipeline.

        Method Workflow:
        - The method first checks if there are any script objects in the pipeline.
          If the pipeline is empty, it returns a message indicating that there is nothing to execute.
        - It determines the start and stop indices for the range of steps to execute.
          If idx is not provided, it defaults to executing all steps from the last executed position.
        - If a specific index or list of indices is provided, it executes only those steps.
        - The pipeline steps are executed in order, combining the scripts using the
          &gt;&gt; operator for sequential execution.
        - The generated script includes comments indicating the current run step and pipeline range,
          based on the specified verbosity level.
        - The final combined script is returned as a string.

        Example Usage:
        --------------
        &gt;&gt;&gt; p = pipescript()
        &gt;&gt;&gt; # Execute the entire pipeline
        &gt;&gt;&gt; full_script = p.do()
        &gt;&gt;&gt; # Execute steps 0 and 2 only
        &gt;&gt;&gt; partial_script = p.do([0, 2])
        &gt;&gt;&gt; # Execute step 1 with minimal verbosity
        &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

        Notes:
        - The method uses modular arithmetic to handle index wrapping, allowing
          for cyclic execution of pipeline steps.
        - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
        - The globalscript is initialized or updated with each step&#39;s script,
          and the USER definitions are accumulated across the steps.
        - The command string self.cmd is updated with the generated script for
          each step in the specified range.

        Raises:
        - None: The method does not raise exceptions directly, but an empty pipeline will
                result in the return of &#34;# empty pipe - nothing to do&#34;.
        &#34;&#34;&#34;

        verbosity = 0 if verbose is False else verbosity
        if len(self)&gt;0:
            # ranges
            ntot = len(self)
            stop = ntot-1
            if (self.globalscript == None) or (self.globalscript == []) or not self.executed[0] or forced:
                start = 0
                self.cmd = &#34;&#34;
            else:
                start = self.nrun
            if start&gt;stop: return self.cmd
            if idx is None: idx = range(start,stop+1)
            if isinstance(idx,range): idx = list(idx)
            if isinstance(idx,int): idx = [idx]
            start,stop = min(idx),max(idx)
            # do
            for i in idx:
                j = i % ntot
                if j==0:
                    self.globalscript = self.listscript[j]
                else:
                    self.globalscript = self.globalscript &gt;&gt; self.listscript[j]
                name = &#34;  &#34;+self.name[i]+&#34;  &#34;
                if verbosity&gt;0:
                    self.cmd += &#34;\n\n#\t --- run step [%d/%d] --- [%s]  %20s\n&#34; % \
                            (j,ntot-1,name.center(50,&#34;=&#34;),&#34;pipeline [%d]--&gt;[%d]&#34; %(start,stop))
                else:
                    self.cmd +=&#34;\n&#34;
                self.globalscript.USER = self.globalscript.USER + self.listUSER[j]
                self.cmd += self.globalscript.do(printflag=printflag,verbose=verbosity&gt;1)
                self.executed[i] = True
            self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;) # remove literal \\n if any (dscript.save add \\n)
            return remove_comments(self.cmd) if verbosity==0 else self.cmd
        else:
            return &#34;# empty pipe - nothing to do&#34;


    def script(self,idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4):
        &#34;&#34;&#34;
            script the pipeline or parts of the pipeline
                s = p.script()
                s = p.script([0,2])

        Parameters:
        - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                               If None, all steps from the current position to
                                               the end are executed. A list of indices can be
                                               provided to execute specific steps, or a single
                                               integer can be passed to execute a specific step.
                                               Default is None.
        - printflag (bool, optional): If True, the generated script for each step is printed
                                      to the console. Default is True.
        - verbosity (int, optional): Controls the level of detail in the generated script.
                                     - 0: Minimal output, no comments.
                                     - 1: Basic comments for run steps.
                                     - 2: Detailed comments with additional information.
                                     Default is 2.
        - forced (bool, optional): If True, all scripts are regenerated
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with `╔`, `═`, and `║`
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with `┌`, `─`, and `│`
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `4` (thick outer frame).

        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity=0 if verbose is False else verbosity
        s = script(printflag=printflag, verbose=verbosity&gt;0)
        s.name = &#34;pipescript&#34;
        s.description = &#34;pipeline with %d scripts&#34; % len(self)
        if len(self)&gt;1:
            s.userid = self.name[0]+&#34;-&gt;&#34;+self.name[-1]
        elif len(self)==1:
            s.userid = self.name[0]
        else:
            s.userid = &#34;empty pipeline&#34;
        s.TEMPLATE = self.header(verbosity=verbosity, style=style) + &#34;\n&#34; +\
            self.do(idx, printflag=printflag, verbosity=verbosity, verbose=verbose, forced=forced)
        s.DEFINITIONS = duplicate(self.globalscript.DEFINITIONS)
        s.USER = duplicate(self.globalscript.USER)
        return s

    @staticmethod
    def join(liste):
        &#34;&#34;&#34;
            join a combination scripts and pipescripts within a pipescript
                p = pipescript.join([s1,s2,p3,p4,p5...])
        &#34;&#34;&#34;
        if not isinstance(liste,list):
            raise ValueError(&#34;the argument should be a list&#34;)
        ok = True
        for i in range(len(liste)):
            ok = ok and isinstance(liste[i],(script,pipescript))
            if not ok:
                raise ValueError(f&#34;the entry [{i}] should be a script or pipescript&#34;)
        if len(liste)&lt;1:
            return liste
        out = liste[0]
        for i in range(1,len(liste)):
            out = out | liste[i]
        return out

    # Note that it was not the original intent to copy pipescripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo))
        return copie

    # write file
    def write(self, file, printflag=False, verbosity=2, verbose=None, overwrite=False):
       &#34;&#34;&#34;
       Write the combined script to a file.

       Parameters:
           file (str): The file path where the script will be saved.
           printflag (bool): Flag to enable/disable printing of details.
           verbosity (int): Level of verbosity for the script generation.
           verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance&#39;s verbosity.
           overwrite (bool): Whether to overwrite the file if it already exists. Default is False.

        Returns:
            str: The full absolute path of the file written.

       Raises:
           FileExistsError: If the file already exists and overwrite is False.

       Notes:
           - This method combines the individual scripts within the `pipescript` object
             and saves the resulting script to the specified file.
           - If `overwrite` is False and the file exists, an error is raised.
           - If `verbose` is True and the file is overwritten, a warning is displayed.
       &#34;&#34;&#34;
       # Generate the combined script
       myscript = self.script(printflag=printflag, verbosity=verbosity, verbose=verbose, forced=True)
       # Call the script&#39;s write method with the overwrite parameter
       return myscript.write(file, printflag=printflag, verbose=verbose, overwrite=overwrite)


    def dscript(self, name=None, printflag=None, verbose=None, verbosity=None, clean=&#34;fixing&#34;, **USER):
        &#34;&#34;&#34;
        Convert the current pipescript object to a dscript object.

        This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
        in the pipescript into a single dynamic script per step in the dscript.
        Each step in the pipescript is transformed into a dynamic script in the dscript,
        where variable spaces are combined using the following order:

        1. STATIC: Definitions specific to each script in the pipescript.
        2. GLOBAL: User variables shared across steps from a specific point onwards.
        3. LOCAL: User variables for each individual step.

        Parameters:
        -----------
        verbose : bool, optional
            Controls verbosity of the dynamic scripts in the resulting dscript object.
            If None, the verbosity setting of the pipescript will be used.

        clean : &#34;fixing&#34; or &#34;removing&#34;
            - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
            - &#39;fixing&#39;: Replace the content of the empty step with a comment.

        **USER : scriptobjectdata(), optional
            Additional user-defined variables that can override existing static variables
            in the dscript object or be added to it.

        Returns:
        --------
        outd : dscript
            A dscript object that contains all steps of the pipescript as dynamic scripts.
            Each step from the pipescript is added as a dynamic script with the same content
            and combined variable spaces.
        &#34;&#34;&#34;
        # Local imports
        from pizza.dscript import dscript, ScriptTemplate, lambdaScriptdata

        # verbosity
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity

        # Adjust name
        if name is None:
            if isinstance(self.name, str):
                name = self.name
            elif isinstance(self.name, list):
                name = (
                    self.name[0] if len(self.name) == 1 else self.name[0] + &#34;...&#34; + self.name[-1]
                )

        # Create the dscript container with the pipescript name as the userid
        outd = dscript(userid=name, verbose=self.verbose, **USER)

        # Initialize static merged definitions
        staticmerged_definitions = lambdaScriptdata()

        # Track used variables per step
        step_used_variables = []

        # Loop over each step in the pipescript
        for i, script in enumerate(self.listscript):
            # Merge STATIC, GLOBAL, and LOCAL variables for the current step
            static_vars = self.listUSER[i] # script.DEFINITIONS
            global_vars = script.DEFINITIONS # self.scripts[i].USER
            local_vars = script.USER # self.USER[i]
            refreshed_globalvars = static_vars + global_vars

            # Detect variables used in the current template
            used_variables = set(script.detect_variables())
            step_used_variables.append(used_variables)  # Track used variables for this step

            # Copy all current variables to local_static_updates and remove matching variables from staticmerged_definitions
            local_static_updates = lambdaScriptdata(**local_vars)

            for var, value in refreshed_globalvars.items():
                if var in staticmerged_definitions:
                    if (getattr(staticmerged_definitions, var) != value) and (var not in local_vars):
                        setattr(local_static_updates, var, value)
                else:
                    setattr(staticmerged_definitions, var, value)

           # Create the dynamic script for this step using the method in dscript
            key_name = i  # Use the index &#39;i&#39; as the key in TEMPLATE
            content = script.TEMPLATE

            # Use the helper method in dscript to add this dynamic script
            outd.add_dynamic_script(
                key=key_name,
                content=content,
                definitions = lambdaScriptdata(**local_static_updates),
                verbose=self.verbose if verbose is None else verbose,
                userid=self.name[i],
                autorefresh=False # prevent the replacement by default values ${}
            )

            # Set eval=True only if variables are detected in the template
            if outd.TEMPLATE[key_name].detect_variables():
                outd.TEMPLATE[key_name].eval = True

        # Compute the union of all used variables across all steps
        global_used_variables = set().union(*step_used_variables)

        # Filter staticmerged_definitions to keep only variables that are used
        filtered_definitions = {
            var: value for var, value in staticmerged_definitions.items() if var in global_used_variables
        }

        # Assign the filtered definitions along with USER variables to outd.DEFINITIONS
        outd.DEFINITIONS = lambdaScriptdata(**filtered_definitions)

        # Clean the entries for empty templates
        outd.clean(verbose=verbose,behavior=clean)

        return outd



    def header(self, verbose=True,verbosity=None, style=4):
        &#34;&#34;&#34;
        Generate a formatted header for the pipescript file.

        Parameters:
            verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                        Defaults to the instance&#39;s `verbose`.
            style (int from 1 to 6, optional): ASCII style to frame the header (default=4)

        Returns:
            str: A formatted string representing the pipescript object.
                 Returns an empty string if verbosity is False.

        The header includes:
            - Total number of scripts in the pipeline.
            - The verbosity setting.
            - The range of scripts from the first to the last script.
            - All enclosed within an ASCII frame that adjusts to the content.
        &#34;&#34;&#34;
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        if not verbosity:
            return &#34;&#34;

        # Prepare the header content
        lines = [
            f&#34;PIPESCRIPT with {self.n} scripts | Verbosity: {verbosity}&#34;,
            &#34;&#34;,
            f&#34;From: &lt;{str(self.scripts[0])}&gt; To: &lt;{str(self.scripts[-1])}&gt;&#34;,
        ]

        # Use the shared method to format the header
        return frame_header(lines,style=style)



    def list_values(self, varname=None, what=&#34;all&#34;):
        &#34;&#34;&#34;
        Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.

        Parameters:
        - varname (str, optional): The name of the variable to search for. If None, all variables are listed.
        - what (str or list/tuple, optional): Specifies the scopes to search in.
                                             Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                             or a list/tuple of any combination of these.

        Returns:
        - VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
        - dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.
        &#34;&#34;&#34;
        # Normalize &#39;what&#39; to a list for uniform processing
        if isinstance(what, str):
            if what.lower() == &#34;all&#34;:
                scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
            else:
                scopes = [what.lower()]
        elif isinstance(what, (list, tuple)):
            scopes_lower = [s.lower() for s in what]
            if &#39;all&#39; in scopes_lower:
                scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
            else:
                scopes = scopes_lower
        else:
            raise ValueError(&#34;Parameter &#39;what&#39; must be a string or a list/tuple of strings.&#34;)

        # Initialize data structures
        if varname:
            # Single variable case
            if len(scopes) == 1:
                data = []
            else:
                data = {}
                for scope in scopes:
                    data[scope] = []

            # Iterate over each script in the pipeline
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                # Check each requested scope
                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    if varname in vars_dict.keys():
                        value = getattr(vars_dict,varname)
                        if len(scopes) == 1:
                            data.append((i, value))
                        else:
                            data[scope].append((i, value))

            # Return a VariableOccurrences instance for the specified variable
            return VariableOccurrences(data, variables=varname)

        else:
            # All variables case
            all_vars = set()

            # First, collect all variable names across specified scopes and scripts
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    all_vars.update(vars_dict.keys())

            # Initialize a dictionary to hold VariableOccurrences for each variable
            variables_data = {}
            for var in all_vars:
                var_data = {}
                for scope in scopes:
                    var_data[scope] = []
                variables_data[var] = var_data

            # Iterate again to populate the data for each variable
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    for var, value in vars_dict.items():
                        variables_data[var][scope].append((i, value))

            # Convert each variable&#39;s data into a VariableOccurrences instance
            variables_occurrences = {}
            for var, data in variables_data.items():
                variables_occurrences[var] = VariableOccurrences(data, variables=var)

            return variables_occurrences



    def list_multiple_values(self, varnames, what=&#34;all&#34;):
        &#34;&#34;&#34;
        Lists all occurrences and values of multiple variables across the pipeline scripts.

        Parameters:
        - varnames (list): A list of variable names to search for.
        - what (str or list/tuple): Specifies the scopes to search in.
                                     Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                     or a list/tuple of any combination of these.

        Returns:
        - dict: A dictionary mapping each variable name to its VariableOccurrences object.
        &#34;&#34;&#34;
        if not isinstance(varnames, (list, tuple)):
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

        return self.list_values(varname=varnames, what=what)



    def plot_multiple_value_distributions(self, varnames, what=&#34;all&#34;, separate_plots=True):
        &#34;&#34;&#34;
        Plots the distribution of elements for multiple variables across specified scopes.

        Parameters:
        - varnames (list): A list of variable names to plot.
        - what (str or list/tuple): Specifies the scopes to include in the plot.
                                     Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                     or a list/tuple of any combination of these.
        - separate_plots (bool): If True, plots each variable in a separate subplot.
                                 If False, combines all variables in a single plot for comparison.
        &#34;&#34;&#34;
        if not isinstance(varnames, (list, tuple)):
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

        # Retrieve VariableOccurrences instances
        multiple_vars = self.list_multiple_values(varnames, what=what)

        if separate_plots:
            num_vars = len(multiple_vars)
            fig, axes = plt.subplots(num_vars, 1, figsize=(10, 5 * num_vars))
            if num_vars == 1:
                axes = [axes]  # Make it iterable

            for ax, (var, vo) in zip(axes, multiple_vars.items()):
                summary = vo.summarize()[var]
                for scope, details in summary.items():
                    elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                    counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                    ax.bar(elements, counts, label=scope)
                ax.set_xlabel(&#39;Element&#39;)
                ax.set_ylabel(&#39;Count&#39;)
                ax.set_title(f&#34;Distribution of elements in &#39;{var}&#39;&#34;)
                ax.legend()

            plt.tight_layout()
            plt.show()

        else:
            plt.figure(figsize=(12, 8))
            for var, vo in multiple_vars.items():
                summary = vo.summarize()[var]
                for scope, details in summary.items():
                    elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                    counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                    plt.bar([f&#34;{var}_{elem}&#34; for elem in elements], counts, label=f&#34;{var} - {scope}&#34;)

            plt.xlabel(&#39;Element&#39;)
            plt.ylabel(&#39;Count&#39;)
            plt.title(&#34;Distribution of elements in multiple variables&#34;)
            plt.legend()
            plt.xticks(rotation=45, ha=&#39;right&#39;)
            plt.tight_layout()
            plt.show()


    def generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
        &#34;&#34;&#34;
        Generates a comprehensive report for specified variables and writes it to a file.

        Parameters:
        - filename (str): Path to the output report file. Must end with .md, .txt, or .html.
        - varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to &#39;all&#39;.
        - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.

        Raises:
        - ValueError: If &#39;filename&#39; has an unsupported extension.
        - Exception: For other unforeseen errors.
        &#34;&#34;&#34;
        # Validate filename extension
        _, ext = os.path.splitext(filename)
        ext = ext.lower()

        if ext not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;]:
            raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

        # Determine format based on extension
        if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
            export_format = &#39;markdown&#39;
        elif ext == &#39;.html&#39;:
            export_format = &#39;html&#39;

        # Determine variables to include
        if varnames is None or (isinstance(varnames, (list, tuple)) and len(varnames) == 0):
            variables = &#39;all&#39;
        else:
            variables = varnames  # Can be a string or a list/tuple

        # Retrieve VariableOccurrences instances
        if variables == &#39;all&#39;:
            variables_occurrences = self.list_values(varname=None, what=scopes)
        else:
            # Normalize varnames to a list
            if isinstance(variables, str):
                variables = [variables]
            elif isinstance(variables, (list, tuple)):
                variables = list(variables)
            else:
                raise ValueError(&#34;Parameter &#39;varnames&#39; must be a string or a list/tuple of strings.&#34;)

            variables_occurrences = {}
            for var in variables:
                vo = self.list_values(varname=var, what=scopes)
                if vo and var in vo.variables:
                    variables_occurrences[var] = vo
                else:
                    print(f&#34;Warning: Variable &#39;{var}&#39; not found in the specified scopes.&#34;)

        # Initialize report content
        report_content = &#34;&#34;
        timestamp = datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        caller = &#34;generate_report&#34;

        # Add report header
        if export_format == &#39;markdown&#39;:
            report_content += f&#34;# Comprehensive Variable Report\n\n&#34;
            report_content += f&#34;**Generated on {timestamp} by {caller}**\n\n&#34;
        elif export_format == &#39;html&#39;:
            # Define CSS for HTML
            css = &#34;&#34;&#34;
            &lt;style&gt;
                body {
                    font-family: Arial, sans-serif;
                    margin: 20px;
                }
                h1, h2, h3, h4, h5 {
                    color: #333;
                }
                table {
                    border-collapse: collapse;
                    width: 100%;
                    margin-bottom: 40px;
                }
                th, td {
                    border: 1px solid #ddd;
                    padding: 8px;
                    text-align: left;
                }
                th {
                    background-color: #4CAF50;
                    color: white;
                }
                tr:nth-child(even){background-color: #f2f2f2;}
                tr:hover {background-color: #ddd;}
            &lt;/style&gt;
            &#34;&#34;&#34;
            report_content += f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Comprehensive Variable Report&lt;/title&gt;\n{css}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;
            report_content += f&#34;&lt;h1&gt;Comprehensive Variable Report&lt;/h1&gt;\n&#34;
            report_content += f&#34;&lt;h2&gt;Generated on {timestamp} by {caller}&lt;/h2&gt;\n&#34;

        # Assemble report content using VariableOccurrences.export()
        for var, vo in variables_occurrences.items():
            # Export content without headers and get as string
            var_content = vo.export(filename=filename, # use to identify the format based on its extension
                                    scopes=scopes,
                                    variables=var,
                                    include_headers=False,
                                    return_content=True)

            if export_format == &#39;markdown&#39;:
                # Add variable header
                report_content += f&#34;## Variable: `{var}`\n\n&#34;
                report_content += var_content + &#34;\n\n&#34;
                report_content += &#34;---\n\n&#34;  # Horizontal line between variables
            elif export_format == &#39;html&#39;:
                # Add variable header
                report_content += f&#34;&lt;h2&gt;Variable: {var}&lt;/h2&gt;\n&#34;
                report_content += var_content + &#34;\n&lt;hr/&gt;\n&#34;  # Horizontal line between variables

        # Finalize HTML content
        if export_format == &#39;html&#39;:
            report_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

        # Write report to file
        try:
            with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                file.write(report_content)
            print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
        except Exception as e:
            raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="dscript.pipescript.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>liste)</span>
</code></dt>
<dd>
<div class="desc"><p>join a combination scripts and pipescripts within a pipescript
p = pipescript.join([s1,s2,p3,p4,p5&hellip;])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def join(liste):
    &#34;&#34;&#34;
        join a combination scripts and pipescripts within a pipescript
            p = pipescript.join([s1,s2,p3,p4,p5...])
    &#34;&#34;&#34;
    if not isinstance(liste,list):
        raise ValueError(&#34;the argument should be a list&#34;)
    ok = True
    for i in range(len(liste)):
        ok = ok and isinstance(liste[i],(script,pipescript))
        if not ok:
            raise ValueError(f&#34;the entry [{i}] should be a script or pipescript&#34;)
    if len(liste)&lt;1:
        return liste
    out = liste[0]
    for i in range(1,len(liste)):
        out = out | liste[i]
    return out</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dscript.pipescript.USER"><code class="name">var <span class="ident">USER</span></code></dt>
<dd>
<div class="desc"><p>p.USER[idx].var returns the value of the USER variable var
p.USER[idx].var = val assigns the value val to the USER variable var</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def USER(self):
    &#34;&#34;&#34;
        p.USER[idx].var returns the value of the USER variable var
        p.USER[idx].var = val assigns the value val to the USER variable var
    &#34;&#34;&#34;
    return self.listUSER  # override listuser</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>number of scripts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34; number of scripts &#34;&#34;&#34;
    return len(self)</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.nrun"><code class="name">var <span class="ident">nrun</span></code></dt>
<dd>
<div class="desc"><p>number of scripts executed continuously from origin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nrun(self):
    &#34;&#34;&#34; number of scripts executed continuously from origin &#34;&#34;&#34;
    n, nmax  = 0, len(self)
    while n&lt;nmax and self.executed[n]: n+=1
    return n</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.scripts"><code class="name">var <span class="ident">scripts</span></code></dt>
<dd>
<div class="desc"><p>p.scripts[idx].USER.var returns the value of the USER variable var
p.scripts[idx].USER.var = val assigns the value val to the USER variable var</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scripts(self):
    &#34;&#34;&#34;
        p.scripts[idx].USER.var returns the value of the USER variable var
        p.scripts[idx].USER.var = val assigns the value val to the USER variable var
    &#34;&#34;&#34;
    return self.listscript # override listuser</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dscript.pipescript.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, idx=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self,idx=None):
    if len(self)&gt;0:
        if idx==None:
            for i in range(len(self)):
                self.clear(i)
        else:
            if isinstance(idx,(range,list)):
                for i in idx:
                    self.clear(idx=i)
            elif isinstance(idx,int) and idx&lt;len(self):
                self.executed[idx] = False
            else:
                raise IndexError(f&#34;the index should be ranged between 0 and {self.n-1}&#34;)
        if not self.executed[0]:
            self.globalscript = None
            self.cmd = &#34;&#34;</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<h2 id="parameters">Parameters</h2>
<p>idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
printflag (bool, optional): Whether to print the script for each step. Default is True.
verbosity (int, optional): Level of verbosity for the output.
verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
forced (bool, optional): If True, forces the pipeline to regenerate all scripts.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Combined LAMMPS script for the specified pipeline steps.</dd>
</dl>
<p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<p>This method processes the pipeline of script objects, executing each step to generate
a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
or for a specified range of indices. The generated script can include comments and
metadata based on the verbosity level.
Method Workflow:
- The method first checks if there are any script objects in the pipeline.
If the pipeline is empty, it returns a message indicating that there is nothing to execute.
- It determines the start and stop indices for the range of steps to execute.
If idx is not provided, it defaults to executing all steps from the last executed position.
- If a specific index or list of indices is provided, it executes only those steps.
- The pipeline steps are executed in order, combining the scripts using the
&gt;&gt; operator for sequential execution.
- The generated script includes comments indicating the current run step and pipeline range,
based on the specified verbosity level.
- The final combined script is returned as a string.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>&gt;&gt;&gt; p = pipescript()
&gt;&gt;&gt; # Execute the entire pipeline
&gt;&gt;&gt; full_script = p.do()
&gt;&gt;&gt; # Execute steps 0 and 2 only
&gt;&gt;&gt; partial_script = p.do([0, 2])
&gt;&gt;&gt; # Execute step 1 with minimal verbosity
&gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

Notes:
- The method uses modular arithmetic to handle index wrapping, allowing
  for cyclic execution of pipeline steps.
- If the pipeline is empty, the method returns the string "# empty pipe - nothing to do".
- The globalscript is initialized or updated with each step's script,
  and the USER definitions are accumulated across the steps.
- The command string self.cmd is updated with the generated script for
  each step in the specified range.

Raises:
- None: The method does not raise exceptions directly, but an empty pipeline will
        result in the return of "# empty pipe - nothing to do".
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
    &#34;&#34;&#34;
    Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

    Parameters:
        idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
        printflag (bool, optional): Whether to print the script for each step. Default is True.
        verbosity (int, optional): Level of verbosity for the output.
        verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
        forced (bool, optional): If True, forces the pipeline to regenerate all scripts.

    Returns:
        str: Combined LAMMPS script for the specified pipeline steps.

        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        This method processes the pipeline of script objects, executing each step to generate
        a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
        or for a specified range of indices. The generated script can include comments and
        metadata based on the verbosity level.


    Method Workflow:
        - The method first checks if there are any script objects in the pipeline.
          If the pipeline is empty, it returns a message indicating that there is nothing to execute.
        - It determines the start and stop indices for the range of steps to execute.
          If idx is not provided, it defaults to executing all steps from the last executed position.
        - If a specific index or list of indices is provided, it executes only those steps.
        - The pipeline steps are executed in order, combining the scripts using the
          &gt;&gt; operator for sequential execution.
        - The generated script includes comments indicating the current run step and pipeline range,
          based on the specified verbosity level.
        - The final combined script is returned as a string.

    Example Usage:
    --------------
        &gt;&gt;&gt; p = pipescript()
        &gt;&gt;&gt; # Execute the entire pipeline
        &gt;&gt;&gt; full_script = p.do()
        &gt;&gt;&gt; # Execute steps 0 and 2 only
        &gt;&gt;&gt; partial_script = p.do([0, 2])
        &gt;&gt;&gt; # Execute step 1 with minimal verbosity
        &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

        Notes:
        - The method uses modular arithmetic to handle index wrapping, allowing
          for cyclic execution of pipeline steps.
        - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
        - The globalscript is initialized or updated with each step&#39;s script,
          and the USER definitions are accumulated across the steps.
        - The command string self.cmd is updated with the generated script for
          each step in the specified range.

        Raises:
        - None: The method does not raise exceptions directly, but an empty pipeline will
                result in the return of &#34;# empty pipe - nothing to do&#34;.
    &#34;&#34;&#34;
    verbosity = 0 if verbose is False else verbosity
    if len(self) == 0:
        return &#34;# empty pipe - nothing to do&#34;

    # Check if not all steps are executed or if there are gaps
    not_all_executed = not all(self.executed[:self.nrun])  # Check up to the last executed step

    # Determine pipeline range
    total_steps = len(self)
    if self.globalscript is None or forced or not_all_executed:
        start = 0
        self.cmd = &#34;&#34;
    else:
        start = self.nrun
        self.cmd = self.cmd.rstrip(&#34;\n&#34;) + &#34;\n\n&#34;

    if idx is None:
        idx = range(start, total_steps)
    if isinstance(idx, int):
        idx = [idx]
    if isinstance(idx, range):
        idx = list(idx)

    idx = [i % total_steps for i in idx]
    start, stop = min(idx), max(idx)

    # Prevent re-executing already completed steps
    if not forced:
        idx = [step for step in idx if not self.executed[step]]

    # Execute pipeline steps
    for step in idx:
        step_wrapped = step % total_steps

        # Combine scripts
        if step_wrapped == 0:
            self.globalscript = self.listscript[step_wrapped]
        else:
            self.globalscript = self.globalscript &gt;&gt; self.listscript[step_wrapped]

        # Step label
        step_name = f&#34;&lt;{self.name[step]}&gt;&#34;
        step_label = f&#34;# [{step+1} of {total_steps} from {start}:{stop}] {step_name}&#34;

        # Get script content for the step
        step_output = self.globalscript.do(printflag=printflag, verbose=verbosity &gt; 1)

        # Add comments and content
        if step_output.strip():
            self.cmd += f&#34;{step_label}\n{step_output.strip()}\n\n&#34;
        elif verbosity &gt; 0:
            self.cmd += f&#34;{step_label} :: no content\n\n&#34;

        # Update USER definitions
        self.globalscript.USER += self.listUSER[step]
        self.executed[step] = True

    # Clean up and finalize script
    self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;).strip()  # Remove literal \\n and extra spaces
    self.cmd += &#34;\n&#34;  # Ensure trailing newline
    return remove_comments(self.cmd) if verbosity == 0 else self.cmd</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.do_legacy"><code class="name flex">
<span>def <span class="ident">do_legacy</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<p>This method processes the pipeline of script objects, executing each step to generate
a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
or for a specified range of indices. The generated script can include comments and
metadata based on the verbosity level.</p>
<p>Parameters:
- idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
If None, all steps from the current position to
the end are executed. A list of indices can be
provided to execute specific steps, or a single
integer can be passed to execute a specific step.
Default is None.
- printflag (bool, optional): If True, the generated script for each step is printed
to the console. Default is True.
- verbosity (int, optional): Controls the level of detail in the generated script.
- 0: Minimal output, no comments.
- 1: Basic comments for run steps.
- 2: Detailed comments with additional information.
Default is 2.
- forced (bool, optional): If True, all scripts are regenerated</p>
<p>Returns:
- str: The combined LAMMPS script generated from the specified steps of the pipeline.</p>
<p>Method Workflow:
- The method first checks if there are any script objects in the pipeline.
If the pipeline is empty, it returns a message indicating that there is nothing to execute.
- It determines the start and stop indices for the range of steps to execute.
If idx is not provided, it defaults to executing all steps from the last executed position.
- If a specific index or list of indices is provided, it executes only those steps.
- The pipeline steps are executed in order, combining the scripts using the</p>
<blockquote>
<blockquote>
<p>operator for sequential execution.
- The generated script includes comments indicating the current run step and pipeline range,
based on the specified verbosity level.
- The final combined script is returned as a string.</p>
</blockquote>
</blockquote>
<h2 id="example-usage">Example Usage:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = pipescript()
&gt;&gt;&gt; # Execute the entire pipeline
&gt;&gt;&gt; full_script = p.do()
&gt;&gt;&gt; # Execute steps 0 and 2 only
&gt;&gt;&gt; partial_script = p.do([0, 2])
&gt;&gt;&gt; # Execute step 1 with minimal verbosity
&gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)
</code></pre>
<p>Notes:
- The method uses modular arithmetic to handle index wrapping, allowing
for cyclic execution of pipeline steps.
- If the pipeline is empty, the method returns the string "# empty pipe - nothing to do".
- The globalscript is initialized or updated with each step's script,
and the USER definitions are accumulated across the steps.
- The command string self.cmd is updated with the generated script for
each step in the specified range.</p>
<p>Raises:
- None: The method does not raise exceptions directly, but an empty pipeline will
result in the return of "# empty pipe - nothing to do".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_legacy(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
    &#34;&#34;&#34;
    Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

    This method processes the pipeline of script objects, executing each step to generate
    a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
    or for a specified range of indices. The generated script can include comments and
    metadata based on the verbosity level.

    Parameters:
    - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                           If None, all steps from the current position to
                                           the end are executed. A list of indices can be
                                           provided to execute specific steps, or a single
                                           integer can be passed to execute a specific step.
                                           Default is None.
    - printflag (bool, optional): If True, the generated script for each step is printed
                                  to the console. Default is True.
    - verbosity (int, optional): Controls the level of detail in the generated script.
                                 - 0: Minimal output, no comments.
                                 - 1: Basic comments for run steps.
                                 - 2: Detailed comments with additional information.
                                 Default is 2.
    - forced (bool, optional): If True, all scripts are regenerated

    Returns:
    - str: The combined LAMMPS script generated from the specified steps of the pipeline.

    Method Workflow:
    - The method first checks if there are any script objects in the pipeline.
      If the pipeline is empty, it returns a message indicating that there is nothing to execute.
    - It determines the start and stop indices for the range of steps to execute.
      If idx is not provided, it defaults to executing all steps from the last executed position.
    - If a specific index or list of indices is provided, it executes only those steps.
    - The pipeline steps are executed in order, combining the scripts using the
      &gt;&gt; operator for sequential execution.
    - The generated script includes comments indicating the current run step and pipeline range,
      based on the specified verbosity level.
    - The final combined script is returned as a string.

    Example Usage:
    --------------
    &gt;&gt;&gt; p = pipescript()
    &gt;&gt;&gt; # Execute the entire pipeline
    &gt;&gt;&gt; full_script = p.do()
    &gt;&gt;&gt; # Execute steps 0 and 2 only
    &gt;&gt;&gt; partial_script = p.do([0, 2])
    &gt;&gt;&gt; # Execute step 1 with minimal verbosity
    &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

    Notes:
    - The method uses modular arithmetic to handle index wrapping, allowing
      for cyclic execution of pipeline steps.
    - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
    - The globalscript is initialized or updated with each step&#39;s script,
      and the USER definitions are accumulated across the steps.
    - The command string self.cmd is updated with the generated script for
      each step in the specified range.

    Raises:
    - None: The method does not raise exceptions directly, but an empty pipeline will
            result in the return of &#34;# empty pipe - nothing to do&#34;.
    &#34;&#34;&#34;

    verbosity = 0 if verbose is False else verbosity
    if len(self)&gt;0:
        # ranges
        ntot = len(self)
        stop = ntot-1
        if (self.globalscript == None) or (self.globalscript == []) or not self.executed[0] or forced:
            start = 0
            self.cmd = &#34;&#34;
        else:
            start = self.nrun
        if start&gt;stop: return self.cmd
        if idx is None: idx = range(start,stop+1)
        if isinstance(idx,range): idx = list(idx)
        if isinstance(idx,int): idx = [idx]
        start,stop = min(idx),max(idx)
        # do
        for i in idx:
            j = i % ntot
            if j==0:
                self.globalscript = self.listscript[j]
            else:
                self.globalscript = self.globalscript &gt;&gt; self.listscript[j]
            name = &#34;  &#34;+self.name[i]+&#34;  &#34;
            if verbosity&gt;0:
                self.cmd += &#34;\n\n#\t --- run step [%d/%d] --- [%s]  %20s\n&#34; % \
                        (j,ntot-1,name.center(50,&#34;=&#34;),&#34;pipeline [%d]--&gt;[%d]&#34; %(start,stop))
            else:
                self.cmd +=&#34;\n&#34;
            self.globalscript.USER = self.globalscript.USER + self.listUSER[j]
            self.cmd += self.globalscript.do(printflag=printflag,verbose=verbosity&gt;1)
            self.executed[i] = True
        self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;) # remove literal \\n if any (dscript.save add \\n)
        return remove_comments(self.cmd) if verbosity==0 else self.cmd
    else:
        return &#34;# empty pipe - nothing to do&#34;</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.dscript"><code class="name flex">
<span>def <span class="ident">dscript</span></span>(<span>self, name=None, printflag=None, verbose=None, verbosity=None, clean='fixing', **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the current pipescript object to a dscript object.</p>
<p>This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
in the pipescript into a single dynamic script per step in the dscript.
Each step in the pipescript is transformed into a dynamic script in the dscript,
where variable spaces are combined using the following order:</p>
<ol>
<li>STATIC: Definitions specific to each script in the pipescript.</li>
<li>GLOBAL: User variables shared across steps from a specific point onwards.</li>
<li>LOCAL: User variables for each individual step.</li>
</ol>
<h2 id="parameters">Parameters:</h2>
<p>verbose : bool, optional
Controls verbosity of the dynamic scripts in the resulting dscript object.
If None, the verbosity setting of the pipescript will be used.</p>
<p>clean : "fixing" or "removing"
- 'removing': Completely remove the empty step from TEMPLATE.
- 'fixing': Replace the content of the empty step with a comment.</p>
<p>**USER : scriptobjectdata(), optional
Additional user-defined variables that can override existing static variables
in the dscript object or be added to it.</p>
<h2 id="returns">Returns:</h2>
<p>outd : dscript
A dscript object that contains all steps of the pipescript as dynamic scripts.
Each step from the pipescript is added as a dynamic script with the same content
and combined variable spaces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dscript(self, name=None, printflag=None, verbose=None, verbosity=None, clean=&#34;fixing&#34;, **USER):
    &#34;&#34;&#34;
    Convert the current pipescript object to a dscript object.

    This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
    in the pipescript into a single dynamic script per step in the dscript.
    Each step in the pipescript is transformed into a dynamic script in the dscript,
    where variable spaces are combined using the following order:

    1. STATIC: Definitions specific to each script in the pipescript.
    2. GLOBAL: User variables shared across steps from a specific point onwards.
    3. LOCAL: User variables for each individual step.

    Parameters:
    -----------
    verbose : bool, optional
        Controls verbosity of the dynamic scripts in the resulting dscript object.
        If None, the verbosity setting of the pipescript will be used.

    clean : &#34;fixing&#34; or &#34;removing&#34;
        - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
        - &#39;fixing&#39;: Replace the content of the empty step with a comment.

    **USER : scriptobjectdata(), optional
        Additional user-defined variables that can override existing static variables
        in the dscript object or be added to it.

    Returns:
    --------
    outd : dscript
        A dscript object that contains all steps of the pipescript as dynamic scripts.
        Each step from the pipescript is added as a dynamic script with the same content
        and combined variable spaces.
    &#34;&#34;&#34;
    # Local imports
    from pizza.dscript import dscript, ScriptTemplate, lambdaScriptdata

    # verbosity
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity

    # Adjust name
    if name is None:
        if isinstance(self.name, str):
            name = self.name
        elif isinstance(self.name, list):
            name = (
                self.name[0] if len(self.name) == 1 else self.name[0] + &#34;...&#34; + self.name[-1]
            )

    # Create the dscript container with the pipescript name as the userid
    outd = dscript(userid=name, verbose=self.verbose, **USER)

    # Initialize static merged definitions
    staticmerged_definitions = lambdaScriptdata()

    # Track used variables per step
    step_used_variables = []

    # Loop over each step in the pipescript
    for i, script in enumerate(self.listscript):
        # Merge STATIC, GLOBAL, and LOCAL variables for the current step
        static_vars = self.listUSER[i] # script.DEFINITIONS
        global_vars = script.DEFINITIONS # self.scripts[i].USER
        local_vars = script.USER # self.USER[i]
        refreshed_globalvars = static_vars + global_vars

        # Detect variables used in the current template
        used_variables = set(script.detect_variables())
        step_used_variables.append(used_variables)  # Track used variables for this step

        # Copy all current variables to local_static_updates and remove matching variables from staticmerged_definitions
        local_static_updates = lambdaScriptdata(**local_vars)

        for var, value in refreshed_globalvars.items():
            if var in staticmerged_definitions:
                if (getattr(staticmerged_definitions, var) != value) and (var not in local_vars):
                    setattr(local_static_updates, var, value)
            else:
                setattr(staticmerged_definitions, var, value)

       # Create the dynamic script for this step using the method in dscript
        key_name = i  # Use the index &#39;i&#39; as the key in TEMPLATE
        content = script.TEMPLATE

        # Use the helper method in dscript to add this dynamic script
        outd.add_dynamic_script(
            key=key_name,
            content=content,
            definitions = lambdaScriptdata(**local_static_updates),
            verbose=self.verbose if verbose is None else verbose,
            userid=self.name[i],
            autorefresh=False # prevent the replacement by default values ${}
        )

        # Set eval=True only if variables are detected in the template
        if outd.TEMPLATE[key_name].detect_variables():
            outd.TEMPLATE[key_name].eval = True

    # Compute the union of all used variables across all steps
    global_used_variables = set().union(*step_used_variables)

    # Filter staticmerged_definitions to keep only variables that are used
    filtered_definitions = {
        var: value for var, value in staticmerged_definitions.items() if var in global_used_variables
    }

    # Assign the filtered definitions along with USER variables to outd.DEFINITIONS
    outd.DEFINITIONS = lambdaScriptdata(**filtered_definitions)

    # Clean the entries for empty templates
    outd.clean(verbose=verbose,behavior=clean)

    return outd</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.generate_report"><code class="name flex">
<span>def <span class="ident">generate_report</span></span>(<span>self, filename, varnames=None, scopes='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a comprehensive report for specified variables and writes it to a file.</p>
<p>Parameters:
- filename (str): Path to the output report file. Must end with .md, .txt, or .html.
- varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to 'all'.
- scopes (str or list/tuple, optional): 'all', a single scope string, or a list of scope strings. Defaults to 'all'.</p>
<p>Raises:
- ValueError: If 'filename' has an unsupported extension.
- Exception: For other unforeseen errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
    &#34;&#34;&#34;
    Generates a comprehensive report for specified variables and writes it to a file.

    Parameters:
    - filename (str): Path to the output report file. Must end with .md, .txt, or .html.
    - varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to &#39;all&#39;.
    - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.

    Raises:
    - ValueError: If &#39;filename&#39; has an unsupported extension.
    - Exception: For other unforeseen errors.
    &#34;&#34;&#34;
    # Validate filename extension
    _, ext = os.path.splitext(filename)
    ext = ext.lower()

    if ext not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;]:
        raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

    # Determine format based on extension
    if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
        export_format = &#39;markdown&#39;
    elif ext == &#39;.html&#39;:
        export_format = &#39;html&#39;

    # Determine variables to include
    if varnames is None or (isinstance(varnames, (list, tuple)) and len(varnames) == 0):
        variables = &#39;all&#39;
    else:
        variables = varnames  # Can be a string or a list/tuple

    # Retrieve VariableOccurrences instances
    if variables == &#39;all&#39;:
        variables_occurrences = self.list_values(varname=None, what=scopes)
    else:
        # Normalize varnames to a list
        if isinstance(variables, str):
            variables = [variables]
        elif isinstance(variables, (list, tuple)):
            variables = list(variables)
        else:
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a string or a list/tuple of strings.&#34;)

        variables_occurrences = {}
        for var in variables:
            vo = self.list_values(varname=var, what=scopes)
            if vo and var in vo.variables:
                variables_occurrences[var] = vo
            else:
                print(f&#34;Warning: Variable &#39;{var}&#39; not found in the specified scopes.&#34;)

    # Initialize report content
    report_content = &#34;&#34;
    timestamp = datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
    caller = &#34;generate_report&#34;

    # Add report header
    if export_format == &#39;markdown&#39;:
        report_content += f&#34;# Comprehensive Variable Report\n\n&#34;
        report_content += f&#34;**Generated on {timestamp} by {caller}**\n\n&#34;
    elif export_format == &#39;html&#39;:
        # Define CSS for HTML
        css = &#34;&#34;&#34;
        &lt;style&gt;
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
            }
            h1, h2, h3, h4, h5 {
                color: #333;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                margin-bottom: 40px;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            th {
                background-color: #4CAF50;
                color: white;
            }
            tr:nth-child(even){background-color: #f2f2f2;}
            tr:hover {background-color: #ddd;}
        &lt;/style&gt;
        &#34;&#34;&#34;
        report_content += f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Comprehensive Variable Report&lt;/title&gt;\n{css}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;
        report_content += f&#34;&lt;h1&gt;Comprehensive Variable Report&lt;/h1&gt;\n&#34;
        report_content += f&#34;&lt;h2&gt;Generated on {timestamp} by {caller}&lt;/h2&gt;\n&#34;

    # Assemble report content using VariableOccurrences.export()
    for var, vo in variables_occurrences.items():
        # Export content without headers and get as string
        var_content = vo.export(filename=filename, # use to identify the format based on its extension
                                scopes=scopes,
                                variables=var,
                                include_headers=False,
                                return_content=True)

        if export_format == &#39;markdown&#39;:
            # Add variable header
            report_content += f&#34;## Variable: `{var}`\n\n&#34;
            report_content += var_content + &#34;\n\n&#34;
            report_content += &#34;---\n\n&#34;  # Horizontal line between variables
        elif export_format == &#39;html&#39;:
            # Add variable header
            report_content += f&#34;&lt;h2&gt;Variable: {var}&lt;/h2&gt;\n&#34;
            report_content += var_content + &#34;\n&lt;hr/&gt;\n&#34;  # Horizontal line between variables

    # Finalize HTML content
    if export_format == &#39;html&#39;:
        report_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

    # Write report to file
    try:
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            file.write(report_content)
        print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
    except Exception as e:
        raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.getUSER"><code class="name flex">
<span>def <span class="ident">getUSER</span></span>(<span>self, idx, key)</span>
</code></dt>
<dd>
<div class="desc"><p>getUSER get USER variable
getUSER(idx,varname)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUSER(self,idx,key):
    &#34;&#34;&#34;
        getUSER get USER variable
        getUSER(idx,varname)
    &#34;&#34;&#34;
    if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
        self.listUSER[idx].getattr(key)
    else:
        raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self, verbose=True, verbosity=None, style=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a formatted header for the pipescript file.</p>
<h2 id="parameters">Parameters</h2>
<p>verbosity (bool, optional): If specified, overrides the instance's <code>verbose</code> setting.
Defaults to the instance's <code>verbose</code>.
style (int from 1 to 6, optional): ASCII style to frame the header (default=4)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representing the pipescript object.
Returns an empty string if verbosity is False.</dd>
</dl>
<p>The header includes:
- Total number of scripts in the pipeline.
- The verbosity setting.
- The range of scripts from the first to the last script.
- All enclosed within an ASCII frame that adjusts to the content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self, verbose=True,verbosity=None, style=4):
    &#34;&#34;&#34;
    Generate a formatted header for the pipescript file.

    Parameters:
        verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                    Defaults to the instance&#39;s `verbose`.
        style (int from 1 to 6, optional): ASCII style to frame the header (default=4)

    Returns:
        str: A formatted string representing the pipescript object.
             Returns an empty string if verbosity is False.

    The header includes:
        - Total number of scripts in the pipeline.
        - The verbosity setting.
        - The range of scripts from the first to the last script.
        - All enclosed within an ASCII frame that adjusts to the content.
    &#34;&#34;&#34;
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    if not verbosity:
        return &#34;&#34;

    # Prepare the header content
    lines = [
        f&#34;PIPESCRIPT with {self.n} scripts | Verbosity: {verbosity}&#34;,
        &#34;&#34;,
        f&#34;From: &lt;{str(self.scripts[0])}&gt; To: &lt;{str(self.scripts[-1])}&gt;&#34;,
    ]

    # Use the shared method to format the header
    return frame_header(lines,style=style)</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.list_multiple_values"><code class="name flex">
<span>def <span class="ident">list_multiple_values</span></span>(<span>self, varnames, what='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all occurrences and values of multiple variables across the pipeline scripts.</p>
<p>Parameters:
- varnames (list): A list of variable names to search for.
- what (str or list/tuple): Specifies the scopes to search in.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.</p>
<p>Returns:
- dict: A dictionary mapping each variable name to its VariableOccurrences object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_multiple_values(self, varnames, what=&#34;all&#34;):
    &#34;&#34;&#34;
    Lists all occurrences and values of multiple variables across the pipeline scripts.

    Parameters:
    - varnames (list): A list of variable names to search for.
    - what (str or list/tuple): Specifies the scopes to search in.
                                 Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                 or a list/tuple of any combination of these.

    Returns:
    - dict: A dictionary mapping each variable name to its VariableOccurrences object.
    &#34;&#34;&#34;
    if not isinstance(varnames, (list, tuple)):
        raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

    return self.list_values(varname=varnames, what=what)</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.list_values"><code class="name flex">
<span>def <span class="ident">list_values</span></span>(<span>self, varname=None, what='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.</p>
<p>Parameters:
- varname (str, optional): The name of the variable to search for. If None, all variables are listed.
- what (str or list/tuple, optional): Specifies the scopes to search in.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.</p>
<p>Returns:
- VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
- dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_values(self, varname=None, what=&#34;all&#34;):
    &#34;&#34;&#34;
    Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.

    Parameters:
    - varname (str, optional): The name of the variable to search for. If None, all variables are listed.
    - what (str or list/tuple, optional): Specifies the scopes to search in.
                                         Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                         or a list/tuple of any combination of these.

    Returns:
    - VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
    - dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.
    &#34;&#34;&#34;
    # Normalize &#39;what&#39; to a list for uniform processing
    if isinstance(what, str):
        if what.lower() == &#34;all&#34;:
            scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
        else:
            scopes = [what.lower()]
    elif isinstance(what, (list, tuple)):
        scopes_lower = [s.lower() for s in what]
        if &#39;all&#39; in scopes_lower:
            scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
        else:
            scopes = scopes_lower
    else:
        raise ValueError(&#34;Parameter &#39;what&#39; must be a string or a list/tuple of strings.&#34;)

    # Initialize data structures
    if varname:
        # Single variable case
        if len(scopes) == 1:
            data = []
        else:
            data = {}
            for scope in scopes:
                data[scope] = []

        # Iterate over each script in the pipeline
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            # Check each requested scope
            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                if varname in vars_dict.keys():
                    value = getattr(vars_dict,varname)
                    if len(scopes) == 1:
                        data.append((i, value))
                    else:
                        data[scope].append((i, value))

        # Return a VariableOccurrences instance for the specified variable
        return VariableOccurrences(data, variables=varname)

    else:
        # All variables case
        all_vars = set()

        # First, collect all variable names across specified scopes and scripts
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                all_vars.update(vars_dict.keys())

        # Initialize a dictionary to hold VariableOccurrences for each variable
        variables_data = {}
        for var in all_vars:
            var_data = {}
            for scope in scopes:
                var_data[scope] = []
            variables_data[var] = var_data

        # Iterate again to populate the data for each variable
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                for var, value in vars_dict.items():
                    variables_data[var][scope].append((i, value))

        # Convert each variable&#39;s data into a VariableOccurrences instance
        variables_occurrences = {}
        for var, data in variables_data.items():
            variables_occurrences[var] = VariableOccurrences(data, variables=var)

        return variables_occurrences</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.plot_multiple_value_distributions"><code class="name flex">
<span>def <span class="ident">plot_multiple_value_distributions</span></span>(<span>self, varnames, what='all', separate_plots=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the distribution of elements for multiple variables across specified scopes.</p>
<p>Parameters:
- varnames (list): A list of variable names to plot.
- what (str or list/tuple): Specifies the scopes to include in the plot.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.
- separate_plots (bool): If True, plots each variable in a separate subplot.
If False, combines all variables in a single plot for comparison.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_multiple_value_distributions(self, varnames, what=&#34;all&#34;, separate_plots=True):
    &#34;&#34;&#34;
    Plots the distribution of elements for multiple variables across specified scopes.

    Parameters:
    - varnames (list): A list of variable names to plot.
    - what (str or list/tuple): Specifies the scopes to include in the plot.
                                 Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                 or a list/tuple of any combination of these.
    - separate_plots (bool): If True, plots each variable in a separate subplot.
                             If False, combines all variables in a single plot for comparison.
    &#34;&#34;&#34;
    if not isinstance(varnames, (list, tuple)):
        raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

    # Retrieve VariableOccurrences instances
    multiple_vars = self.list_multiple_values(varnames, what=what)

    if separate_plots:
        num_vars = len(multiple_vars)
        fig, axes = plt.subplots(num_vars, 1, figsize=(10, 5 * num_vars))
        if num_vars == 1:
            axes = [axes]  # Make it iterable

        for ax, (var, vo) in zip(axes, multiple_vars.items()):
            summary = vo.summarize()[var]
            for scope, details in summary.items():
                elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                ax.bar(elements, counts, label=scope)
            ax.set_xlabel(&#39;Element&#39;)
            ax.set_ylabel(&#39;Count&#39;)
            ax.set_title(f&#34;Distribution of elements in &#39;{var}&#39;&#34;)
            ax.legend()

        plt.tight_layout()
        plt.show()

    else:
        plt.figure(figsize=(12, 8))
        for var, vo in multiple_vars.items():
            summary = vo.summarize()[var]
            for scope, details in summary.items():
                elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                plt.bar([f&#34;{var}_{elem}&#34; for elem in elements], counts, label=f&#34;{var} - {scope}&#34;)

        plt.xlabel(&#39;Element&#39;)
        plt.ylabel(&#39;Count&#39;)
        plt.title(&#34;Distribution of elements in multiple variables&#34;)
        plt.legend()
        plt.xticks(rotation=45, ha=&#39;right&#39;)
        plt.tight_layout()
        plt.show()</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, name='', idx=None)</span>
</code></dt>
<dd>
<div class="desc"><p>rename scripts in the pipe
p.rename(idx=[0,2,3],name=["A","B","C"])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(self,name=&#34;&#34;,idx=None):
    &#34;&#34;&#34;
        rename scripts in the pipe
            p.rename(idx=[0,2,3],name=[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;])
    &#34;&#34;&#34;
    if isinstance(name,list):
        if len(name)==len(self) and idx==None:
            self.name = name
        elif len(name) == len(idx):
            for i in range(len(idx)):
                self.rename(name[i],idx[i])
        else:
            IndexError(f&#34;the number of indices {len(idx)} does not match the number of names {len(name)}&#34;)
    elif idx !=None and idx&lt;len(self) and name!=&#34;&#34;:
        self.name[idx] = name
    else:
        raise ValueError(&#34;provide a non empty name and valid index&#34;)</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4)</span>
</code></dt>
<dd>
<div class="desc"><p>script the pipeline or parts of the pipeline
s = p.script()
s = p.script([0,2])</p>
<p>Parameters:
- idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
If None, all steps from the current position to
the end are executed. A list of indices can be
provided to execute specific steps, or a single
integer can be passed to execute a specific step.
Default is None.
- printflag (bool, optional): If True, the generated script for each step is printed
to the console. Default is True.
- verbosity (int, optional): Controls the level of detail in the generated script.
- 0: Minimal output, no comments.
- 1: Basic comments for run steps.
- 2: Detailed comments with additional information.
Default is 2.
- forced (bool, optional): If True, all scripts are regenerated
- style (int, optional):
Defines the ASCII frame style for the header.
Valid values are integers from 1 to 6, corresponding to predefined styles:
1. Basic box with <code>+</code>, <code>-</code>, and <code>|</code>
2. Double-line frame with <code>╔</code>, <code>═</code>, and <code>║</code>
3. Rounded corners with <code>.</code>, <code>'</code>, <code>-</code>, and <code>|</code>
4. Thick outer frame with <code>#</code>, <code>=</code>, and <code>#</code>
5. Box drawing characters with <code>┌</code>, <code>─</code>, and <code>│</code>
6. Minimalist dotted frame with <code>.</code>, <code>:</code>, and <code>.</code>
Default is <code>4</code> (thick outer frame).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def script(self,idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4):
    &#34;&#34;&#34;
        script the pipeline or parts of the pipeline
            s = p.script()
            s = p.script([0,2])

    Parameters:
    - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                           If None, all steps from the current position to
                                           the end are executed. A list of indices can be
                                           provided to execute specific steps, or a single
                                           integer can be passed to execute a specific step.
                                           Default is None.
    - printflag (bool, optional): If True, the generated script for each step is printed
                                  to the console. Default is True.
    - verbosity (int, optional): Controls the level of detail in the generated script.
                                 - 0: Minimal output, no comments.
                                 - 1: Basic comments for run steps.
                                 - 2: Detailed comments with additional information.
                                 Default is 2.
    - forced (bool, optional): If True, all scripts are regenerated
    - style (int, optional):
        Defines the ASCII frame style for the header.
        Valid values are integers from 1 to 6, corresponding to predefined styles:
            1. Basic box with `+`, `-`, and `|`
            2. Double-line frame with `╔`, `═`, and `║`
            3. Rounded corners with `.`, `&#39;`, `-`, and `|`
            4. Thick outer frame with `#`, `=`, and `#`
            5. Box drawing characters with `┌`, `─`, and `│`
            6. Minimalist dotted frame with `.`, `:`, and `.`
        Default is `4` (thick outer frame).

    &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity=0 if verbose is False else verbosity
    s = script(printflag=printflag, verbose=verbosity&gt;0)
    s.name = &#34;pipescript&#34;
    s.description = &#34;pipeline with %d scripts&#34; % len(self)
    if len(self)&gt;1:
        s.userid = self.name[0]+&#34;-&gt;&#34;+self.name[-1]
    elif len(self)==1:
        s.userid = self.name[0]
    else:
        s.userid = &#34;empty pipeline&#34;
    s.TEMPLATE = self.header(verbosity=verbosity, style=style) + &#34;\n&#34; +\
        self.do(idx, printflag=printflag, verbosity=verbosity, verbose=verbose, forced=forced)
    s.DEFINITIONS = duplicate(self.globalscript.DEFINITIONS)
    s.USER = duplicate(self.globalscript.USER)
    return s</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.setUSER"><code class="name flex">
<span>def <span class="ident">setUSER</span></span>(<span>self, idx, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>setUSER sets USER variables
setUSER(idx,varname,varvalue)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUSER(self,idx,key,value):
    &#34;&#34;&#34;
        setUSER sets USER variables
        setUSER(idx,varname,varvalue)
    &#34;&#34;&#34;
    if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
        self.listUSER[idx].setattr(key,value)
    else:
        raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)</code></pre>
</details>
</dd>
<dt id="dscript.pipescript.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, printflag=False, verbosity=2, verbose=None, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the combined script to a file.</p>
<h2 id="parameters">Parameters</h2>
<p>file (str): The file path where the script will be saved.
printflag (bool): Flag to enable/disable printing of details.
verbosity (int): Level of verbosity for the script generation.
verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance's verbosity.
overwrite (bool): Whether to overwrite the file if it already exists. Default is False.</p>
<p>Returns:
str: The full absolute path of the file written.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and overwrite is False.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>This method combines the individual scripts within the <code><a title="dscript.pipescript" href="#dscript.pipescript">pipescript</a></code> object
and saves the resulting script to the specified file.</li>
<li>If <code>overwrite</code> is False and the file exists, an error is raised.</li>
<li>If <code>verbose</code> is True and the file is overwritten, a warning is displayed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, printflag=False, verbosity=2, verbose=None, overwrite=False):
   &#34;&#34;&#34;
   Write the combined script to a file.

   Parameters:
       file (str): The file path where the script will be saved.
       printflag (bool): Flag to enable/disable printing of details.
       verbosity (int): Level of verbosity for the script generation.
       verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance&#39;s verbosity.
       overwrite (bool): Whether to overwrite the file if it already exists. Default is False.

    Returns:
        str: The full absolute path of the file written.

   Raises:
       FileExistsError: If the file already exists and overwrite is False.

   Notes:
       - This method combines the individual scripts within the `pipescript` object
         and saves the resulting script to the specified file.
       - If `overwrite` is False and the file exists, an error is raised.
       - If `verbose` is True and the file is overwritten, a warning is displayed.
   &#34;&#34;&#34;
   # Generate the combined script
   myscript = self.script(printflag=printflag, verbosity=verbosity, verbose=verbose, forced=True)
   # Call the script&#39;s write method with the overwrite parameter
   return myscript.write(file, printflag=printflag, verbose=verbose, overwrite=overwrite)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dscript.script"><code class="flex name class">
<span>class <span class="ident">script</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>script: A Core Class for Flexible LAMMPS Script Generation</p>
<p>The <code><a title="dscript.script" href="#dscript.script">script</a></code> class provides a flexible framework for generating dynamic LAMMPS
script sections. It supports various LAMMPS sections such as "GLOBAL", "INITIALIZE",
"GEOMETRY", "INTERACTIONS", and more, while allowing users to define custom sections
with variable definitions, templates, and dynamic evaluation of script content.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Dynamic Script Generation</strong>: Easily define and manage script sections,
using templates and definitions to dynamically generate LAMMPS-compatible scripts.</li>
<li><strong>Script Concatenation</strong>: Combine multiple script sections while managing
variable precedence and ensuring that definitions propagate as expected.</li>
<li><strong>Flexible Variable Management</strong>: Separate <code>DEFINITIONS</code> for static variables and
<code>USER</code> for user-defined variables, with clear rules for inheritance and precedence.</li>
<li><strong>Operators for Advanced Script Handling</strong>: Use <code>+</code>, <code>&amp;</code>, <code>&gt;&gt;</code>, <code>|</code>, and <code>**</code> operators
for script merging, static execution, right-shifting of definitions, and more.</li>
<li><strong>Pipeline Support</strong>: Integrate scripts into pipelines, with full support for
staged execution, variable inheritance, and reordering of script sections.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>LAMMPS Automation</strong>: Automate the generation of complex LAMMPS scripts by defining
reusable script sections with variables and templates.</li>
<li><strong>Multi-Step Simulations</strong>: Manage multi-step simulations by splitting large scripts
into smaller, manageable sections and combining them as needed.</li>
<li><strong>Advanced Script Control</strong>: Dynamically modify script behavior by overriding variables
or using advanced operators to concatenate, pipe, or merge scripts.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, persistentfile=True, persistentfolder=None, printflag=False, verbose=False, **userdefinitions):
Initializes a new <code><a title="dscript.script" href="#dscript.script">script</a></code> object, with optional user-defined variables
passed as <code>userdefinitions</code>.</p>
<p>do(self, printflag=None, verbose=None):
Generates the LAMMPS script based on the current configuration, evaluating
templates and definitions to produce the final output.</p>
<p>script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Generate the final LAMMPS script from the pipeline or a subset of the pipeline.</p>
<p>add(self, s):
Overloads the <code>+</code> operator to concatenate script objects, merging definitions
and templates while maintaining variable precedence.</p>
<p>and(self, s):
Overloads the <code>&amp;</code> operator for static execution, combining the generated scripts
of two script objects without merging their definitions.</p>
<p><strong>mul</strong>(self, ntimes):
Overloads the <code>*</code> operator to repeat the script <code>ntimes</code>, returning a new script
object with repeated sections.</p>
<p><strong>pow</strong>(self, ntimes):
Overloads the <code>**</code> operator to concatenate the script with itself <code>ntimes</code>,
similar to the <code>&amp;</code> operator, but repeated.</p>
<p><strong>or</strong>(self, pipe):
Overloads the pipe (<code>|</code>) operator to integrate the script into a pipeline,
returning a <code><a title="dscript.pipescript" href="#dscript.pipescript">pipescript</a></code> object.</p>
<p>write(self, file, printflag=True, verbose=False):
Writes the generated script to a file, including headers with metadata.</p>
<p>tmpwrite(self):
Writes the script to a temporary file, creating both a full version and a clean
version without comments.</p>
<p>printheader(txt, align="^", width=80, filler="~"):
Static method to print formatted headers, useful for organizing output.</p>
<p><strong>copy</strong>(self):
Creates a shallow copy of the script object.</p>
<p><strong>deepcopy</strong>(self, memo):
Creates a deep copy of the script object, duplicating all internal variables.</p>
<h2 id="additional-features">Additional Features:</h2>
<ul>
<li><strong>Customizable Templates</strong>: Use string templates with variable placeholders
(e.g., <code>${value}</code>) to dynamically generate script lines.</li>
<li><strong>Static and User-Defined Variables</strong>: Manage global <code>DEFINITIONS</code> for static
variables and <code>USER</code> variables for dynamic, user-defined settings.</li>
<li><strong>Advanced Operators</strong>: Leverage a range of operators (<code>+</code>, <code>&gt;&gt;</code>, <code>|</code>, <code>&amp;</code>) to
manipulate script content, inherit definitions, and control variable precedence.</li>
<li><strong>Verbose Output</strong>: Control verbosity to include detailed comments and debugging
information in generated scripts.</li>
</ul>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="dscript.script" href="#dscript.script">script</a></code> class supports LAMMPS section generation and variable management with
features such as:
- <strong>Dynamic Evaluation of Scripts</strong>: Definitions and templates are evaluated at runtime,
allowing for flexible and reusable scripts.
- <strong>Inheritance of Definitions</strong>: Variable definitions can be inherited from previous
sections, allowing for modular script construction.
- <strong>Precedence Rules for Variables</strong>: When scripts are concatenated, definitions from
the left take precedence, ensuring that the first defined values are preserved.
- <strong>Instance and Global Variables</strong>: Instance variables are set via the <code>USER</code> object,
while global variables (shared across instances) are managed in <code>DEFINITIONS</code>.
- <strong>Script Pipelines</strong>: Scripts can be integrated into pipelines for sequential execution
and dynamic variable propagation.
- <strong>Flexible Output Formats</strong>: Lists are expanded into space-separated strings, while
tuples are expanded with commas, making the output more readable.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>from pizza.script import script, scriptdata

class example_section(script):
    DEFINITIONS = scriptdata(
        X = 10,
        Y = 20,
        result = &quot;${X} + ${Y}&quot;
    )
    TEMPLATE = &quot;${result} = ${X} + ${Y}&quot;

s1 = example_section()
s1.USER.X = 5
s1.do()
</code></pre>
<p>The output for <code>s1.do()</code> will be:</p>
<pre><code>25 = 5 + 20
</code></pre>
<p>With additional sections, scripts can be concatenated and executed as a single
entity, with inheritance of variables and customizable behavior.</p>
<pre><code>--------------------------------------
   OVERVIEW ANDE DETAILED FEATURES
--------------------------------------

The class script enables to generate dynamically LAMMPS sections
"NONE","GLOBAL","INITIALIZE","GEOMETRY","DISCRETIZATION",
"BOUNDARY","INTERACTIONS","INTEGRATION","DUMP","STATUS","RUN"


# %% This the typical construction for a class
class XXXXsection(script):
    "" " LAMMPS script: XXXX session "" "
    name = "XXXXXX"
    description = name+" section"
    position = 0
    section = 0
    userid = "example"
    version = 0.1

    DEFINITIONS = scriptdata(
         value= 1,
    expression= "${value+1}",
          text= "$my text"
        )

    TEMPLATE = "" "
# :UNDEF SECTION:
#   to be defined
LAMMPS code with ${value}, ${expression}, ${text}
    "" "

DEFINTIONS can be inherited from a previous section
DEFINITIONS = previousection.DEFINTIONS + scriptdata(
         value= 1,
    expression= "${value+1}",
          text= "$my text"
    )


Recommandation: Split a large script into a small classes or actions
An example of use could be:
    move1 = translation(displacement=10)+rotation(angle=30)
    move2 = shear(rate=0.1)+rotation(angle=20)
    bigmove = move1+move2+move1
    script = bigmove.do() generates the script

NOTE1: Use the print() and the method do() to get the script interpreted

NOTE2: DEFINITIONS can be pretified using DEFINITIONS.generator()

NOTE3: Variables can extracted from a template using TEMPLATE.scan()

NOTE4: Scripts can be joined (from top down to bottom).
The first definitions keep higher precedence. Please do not use
a variable twice with different contents.

myscript = s1 + s2 + s3 will propagate the definitions
without overwritting previous values). myscript will be
defined as s1 (same name, position, userid, etc.)

myscript += s appends the script section s to myscript

NOTE5: rules of precedence when script are concatenated
The attributes from the class (name, description...) are kept from the left
The values of the right overwrite all DEFINITIONS

NOTE6: user variables (instance variables) can set with USER or at the construction
myclass_instance = myclass(myvariable = myvalue)
myclass_instance.USER.myvariable = myvalue

NOTE7: how to change variables for all instances at once?
In the example below, let x is a global variable (instance independent)
and y a local variable (instance dependent)
instance1 = myclass(y=1) --&gt; y=1 in instance1
instance2 = myclass(y=2) --&gt; y=2 in instance2
instance3.USER.y=3 --&gt; y=3 in instance3
instance1.DEFINITIONS.x = 10 --&gt; x=10 in all instances (1,2,3)

If x is also defined in the USER section, its value will be used
Setting instance3.USER.x = 30 will assign x=30 only in instance3

NOTE8: if a the script is used with different values for a same parameter
use the operator &amp; to concatenate the results instead of the script
example: load(file="myfile1") &amp; load(file="myfile2) &amp; load(file="myfile3")+...

NOTE9: lists (e.g., [1,2,'a',3] are expanded ("1 2 a 3")
       tuples (e.g. (1,2)) are expanded ("1,2")
       It is easier to read ["lost","ignore"] than "$ lost ignore"

NOTE 10: New operators &gt;&gt; and || extend properties
    + merge all scripts but overwrite definitions
    &amp; execute statically script content
    &gt;&gt; pass only DEFINITIONS but not TEMPLATE to the right
    | pipe execution such as in Bash, the result is a pipeline

NOTE 11: Scripts in pipelines are very flexible, they support
full indexing à la Matlab, including staged executions
    method do(idx) generates the script corresponding to indices idx
    method script(idx) generates the corresponding script object

--------------------------[ FULL EXAMPLE ]-----------------------------

# Import the class
from pizza.script import *

# Override the class globalsection
class scriptexample(globalsection):
    description = "demonstrate commutativity of additions"
    verbose = True

    DEFINITIONS = scriptdata(
        X = 10,
        Y = 20,
        R1 = "${X}+${Y}",
        R2 = "${Y}+${X}"
        )
    TEMPLATE = "" "
    # Property of the addition
    ${R1} = ${X} + ${Y}
    ${R2} = ${Y} + ${X}
 "" "

# derived from scriptexample, X and Y are reused
class scriptexample2(scriptexample):
    description = "demonstrate commutativity of multiplications"
    verbose = True
    DEFINITIONS = scriptexample.DEFINITIONS + scriptdata(
        R3 = "${X} * ${Y}",
        R4 = "${Y} * ${X}",
        )
    TEMPLATE = "" "
    # Property of the multiplication
    ${R3} = ${X} * ${Y}
    ${R4} = ${Y} * ${X}
 "" "

# call the first class and override the values X and Y
s1 = scriptexample()
s1.USER.X = 1  # method 1 of override
s1.USER.Y = 2
s1.do()
# call the second class and override the values X and Y
s2 = scriptexample2(X=1000,Y=2000) # method 2
s2.do()
# Merge the two scripts
s = s1+s2
print("this is my full script")
s.description
s.do()

# The result for s1 is
    3 = 1 + 2
    3 = 2 + 1
# The result for s2 is
    2000000 = 1000 * 2000
    2000000 = 2000 * 1000
# The result for s=s1+s2 is
    # Property of the addition
    3000 = 1000 + 2000
    3000 = 2000 + 1000
    # Property of the multiplication
    2000000 = 1000 * 2000
    2000000 = 2000 * 1000
</code></pre>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class script:
    &#34;&#34;&#34;
    script: A Core Class for Flexible LAMMPS Script Generation

    The `script` class provides a flexible framework for generating dynamic LAMMPS
    script sections. It supports various LAMMPS sections such as &#34;GLOBAL&#34;, &#34;INITIALIZE&#34;,
    &#34;GEOMETRY&#34;, &#34;INTERACTIONS&#34;, and more, while allowing users to define custom sections
    with variable definitions, templates, and dynamic evaluation of script content.

    Key Features:
    -------------
    - **Dynamic Script Generation**: Easily define and manage script sections,
      using templates and definitions to dynamically generate LAMMPS-compatible scripts.
    - **Script Concatenation**: Combine multiple script sections while managing
      variable precedence and ensuring that definitions propagate as expected.
    - **Flexible Variable Management**: Separate `DEFINITIONS` for static variables and
      `USER` for user-defined variables, with clear rules for inheritance and precedence.
    - **Operators for Advanced Script Handling**: Use `+`, `&amp;`, `&gt;&gt;`, `|`, and `**` operators
      for script merging, static execution, right-shifting of definitions, and more.
    - **Pipeline Support**: Integrate scripts into pipelines, with full support for
      staged execution, variable inheritance, and reordering of script sections.

    Practical Use Cases:
    --------------------
    - **LAMMPS Automation**: Automate the generation of complex LAMMPS scripts by defining
      reusable script sections with variables and templates.
    - **Multi-Step Simulations**: Manage multi-step simulations by splitting large scripts
      into smaller, manageable sections and combining them as needed.
    - **Advanced Script Control**: Dynamically modify script behavior by overriding variables
      or using advanced operators to concatenate, pipe, or merge scripts.

    Methods:
    --------
    __init__(self, persistentfile=True, persistentfolder=None, printflag=False, verbose=False, **userdefinitions):
        Initializes a new `script` object, with optional user-defined variables
        passed as `userdefinitions`.

    do(self, printflag=None, verbose=None):
        Generates the LAMMPS script based on the current configuration, evaluating
        templates and definitions to produce the final output.

    script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Generate the final LAMMPS script from the pipeline or a subset of the pipeline.

    add(self, s):
        Overloads the `+` operator to concatenate script objects, merging definitions
        and templates while maintaining variable precedence.

    and(self, s):
        Overloads the `&amp;` operator for static execution, combining the generated scripts
        of two script objects without merging their definitions.

    __mul__(self, ntimes):
        Overloads the `*` operator to repeat the script `ntimes`, returning a new script
        object with repeated sections.

    __pow__(self, ntimes):
        Overloads the `**` operator to concatenate the script with itself `ntimes`,
        similar to the `&amp;` operator, but repeated.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the script into a pipeline,
        returning a `pipescript` object.

    write(self, file, printflag=True, verbose=False):
        Writes the generated script to a file, including headers with metadata.

    tmpwrite(self):
        Writes the script to a temporary file, creating both a full version and a clean
        version without comments.

    printheader(txt, align=&#34;^&#34;, width=80, filler=&#34;~&#34;):
        Static method to print formatted headers, useful for organizing output.

    __copy__(self):
        Creates a shallow copy of the script object.

    __deepcopy__(self, memo):
        Creates a deep copy of the script object, duplicating all internal variables.

    Additional Features:
    --------------------
    - **Customizable Templates**: Use string templates with variable placeholders
      (e.g., `${value}`) to dynamically generate script lines.
    - **Static and User-Defined Variables**: Manage global `DEFINITIONS` for static
      variables and `USER` variables for dynamic, user-defined settings.
    - **Advanced Operators**: Leverage a range of operators (`+`, `&gt;&gt;`, `|`, `&amp;`) to
      manipulate script content, inherit definitions, and control variable precedence.
    - **Verbose Output**: Control verbosity to include detailed comments and debugging
      information in generated scripts.

    Original Content:
    -----------------
    The `script` class supports LAMMPS section generation and variable management with
    features such as:
    - **Dynamic Evaluation of Scripts**: Definitions and templates are evaluated at runtime,
      allowing for flexible and reusable scripts.
    - **Inheritance of Definitions**: Variable definitions can be inherited from previous
      sections, allowing for modular script construction.
    - **Precedence Rules for Variables**: When scripts are concatenated, definitions from
      the left take precedence, ensuring that the first defined values are preserved.
    - **Instance and Global Variables**: Instance variables are set via the `USER` object,
      while global variables (shared across instances) are managed in `DEFINITIONS`.
    - **Script Pipelines**: Scripts can be integrated into pipelines for sequential execution
      and dynamic variable propagation.
    - **Flexible Output Formats**: Lists are expanded into space-separated strings, while
      tuples are expanded with commas, making the output more readable.

    Example Usage:
    --------------
    ```
    from pizza.script import script, scriptdata

    class example_section(script):
        DEFINITIONS = scriptdata(
            X = 10,
            Y = 20,
            result = &#34;${X} + ${Y}&#34;
        )
        TEMPLATE = &#34;${result} = ${X} + ${Y}&#34;

    s1 = example_section()
    s1.USER.X = 5
    s1.do()
    ```

    The output for `s1.do()` will be:
    ```
    25 = 5 + 20
    ```

    With additional sections, scripts can be concatenated and executed as a single
    entity, with inheritance of variables and customizable behavior.


        --------------------------------------
           OVERVIEW ANDE DETAILED FEATURES
        --------------------------------------

        The class script enables to generate dynamically LAMMPS sections
        &#34;NONE&#34;,&#34;GLOBAL&#34;,&#34;INITIALIZE&#34;,&#34;GEOMETRY&#34;,&#34;DISCRETIZATION&#34;,
        &#34;BOUNDARY&#34;,&#34;INTERACTIONS&#34;,&#34;INTEGRATION&#34;,&#34;DUMP&#34;,&#34;STATUS&#34;,&#34;RUN&#34;


        # %% This the typical construction for a class
        class XXXXsection(script):
            &#34;&#34; &#34; LAMMPS script: XXXX session &#34;&#34; &#34;
            name = &#34;XXXXXX&#34;
            description = name+&#34; section&#34;
            position = 0
            section = 0
            userid = &#34;example&#34;
            version = 0.1

            DEFINITIONS = scriptdata(
                 value= 1,
            expression= &#34;${value+1}&#34;,
                  text= &#34;$my text&#34;
                )

            TEMPLATE = &#34;&#34; &#34;
        # :UNDEF SECTION:
        #   to be defined
        LAMMPS code with ${value}, ${expression}, ${text}
            &#34;&#34; &#34;

        DEFINTIONS can be inherited from a previous section
        DEFINITIONS = previousection.DEFINTIONS + scriptdata(
                 value= 1,
            expression= &#34;${value+1}&#34;,
                  text= &#34;$my text&#34;
            )


        Recommandation: Split a large script into a small classes or actions
        An example of use could be:
            move1 = translation(displacement=10)+rotation(angle=30)
            move2 = shear(rate=0.1)+rotation(angle=20)
            bigmove = move1+move2+move1
            script = bigmove.do() generates the script

        NOTE1: Use the print() and the method do() to get the script interpreted

        NOTE2: DEFINITIONS can be pretified using DEFINITIONS.generator()

        NOTE3: Variables can extracted from a template using TEMPLATE.scan()

        NOTE4: Scripts can be joined (from top down to bottom).
        The first definitions keep higher precedence. Please do not use
        a variable twice with different contents.

        myscript = s1 + s2 + s3 will propagate the definitions
        without overwritting previous values). myscript will be
        defined as s1 (same name, position, userid, etc.)

        myscript += s appends the script section s to myscript

        NOTE5: rules of precedence when script are concatenated
        The attributes from the class (name, description...) are kept from the left
        The values of the right overwrite all DEFINITIONS

        NOTE6: user variables (instance variables) can set with USER or at the construction
        myclass_instance = myclass(myvariable = myvalue)
        myclass_instance.USER.myvariable = myvalue

        NOTE7: how to change variables for all instances at once?
        In the example below, let x is a global variable (instance independent)
        and y a local variable (instance dependent)
        instance1 = myclass(y=1) --&gt; y=1 in instance1
        instance2 = myclass(y=2) --&gt; y=2 in instance2
        instance3.USER.y=3 --&gt; y=3 in instance3
        instance1.DEFINITIONS.x = 10 --&gt; x=10 in all instances (1,2,3)

        If x is also defined in the USER section, its value will be used
        Setting instance3.USER.x = 30 will assign x=30 only in instance3

        NOTE8: if a the script is used with different values for a same parameter
        use the operator &amp; to concatenate the results instead of the script
        example: load(file=&#34;myfile1&#34;) &amp; load(file=&#34;myfile2) &amp; load(file=&#34;myfile3&#34;)+...

        NOTE9: lists (e.g., [1,2,&#39;a&#39;,3] are expanded (&#34;1 2 a 3&#34;)
               tuples (e.g. (1,2)) are expanded (&#34;1,2&#34;)
               It is easier to read [&#34;lost&#34;,&#34;ignore&#34;] than &#34;$ lost ignore&#34;

        NOTE 10: New operators &gt;&gt; and || extend properties
            + merge all scripts but overwrite definitions
            &amp; execute statically script content
            &gt;&gt; pass only DEFINITIONS but not TEMPLATE to the right
            | pipe execution such as in Bash, the result is a pipeline

        NOTE 11: Scripts in pipelines are very flexible, they support
        full indexing à la Matlab, including staged executions
            method do(idx) generates the script corresponding to indices idx
            method script(idx) generates the corresponding script object

        --------------------------[ FULL EXAMPLE ]-----------------------------

        # Import the class
        from pizza.script import *

        # Override the class globalsection
        class scriptexample(globalsection):
            description = &#34;demonstrate commutativity of additions&#34;
            verbose = True

            DEFINITIONS = scriptdata(
                X = 10,
                Y = 20,
                R1 = &#34;${X}+${Y}&#34;,
                R2 = &#34;${Y}+${X}&#34;
                )
            TEMPLATE = &#34;&#34; &#34;
            # Property of the addition
            ${R1} = ${X} + ${Y}
            ${R2} = ${Y} + ${X}
         &#34;&#34; &#34;

        # derived from scriptexample, X and Y are reused
        class scriptexample2(scriptexample):
            description = &#34;demonstrate commutativity of multiplications&#34;
            verbose = True
            DEFINITIONS = scriptexample.DEFINITIONS + scriptdata(
                R3 = &#34;${X} * ${Y}&#34;,
                R4 = &#34;${Y} * ${X}&#34;,
                )
            TEMPLATE = &#34;&#34; &#34;
            # Property of the multiplication
            ${R3} = ${X} * ${Y}
            ${R4} = ${Y} * ${X}
         &#34;&#34; &#34;

        # call the first class and override the values X and Y
        s1 = scriptexample()
        s1.USER.X = 1  # method 1 of override
        s1.USER.Y = 2
        s1.do()
        # call the second class and override the values X and Y
        s2 = scriptexample2(X=1000,Y=2000) # method 2
        s2.do()
        # Merge the two scripts
        s = s1+s2
        print(&#34;this is my full script&#34;)
        s.description
        s.do()

        # The result for s1 is
            3 = 1 + 2
            3 = 2 + 1
        # The result for s2 is
            2000000 = 1000 * 2000
            2000000 = 2000 * 1000
        # The result for s=s1+s2 is
            # Property of the addition
            3000 = 1000 + 2000
            3000 = 2000 + 1000
            # Property of the multiplication
            2000000 = 1000 * 2000
            2000000 = 2000 * 1000

    &#34;&#34;&#34;

    # metadata
    metadata = get_metadata()               # retrieve all metadata

    type = &#34;script&#34;                         # type (class name)
    name = &#34;empty script&#34;                   # name
    description = &#34;it is an empty script&#34;   # description
    position = 0                            # 0 = root
    section = 0                             # section (0=undef)
    userid = &#34;undefined&#34;                    # user name
    version = metadata[&#34;version&#34;]           # version
    license = metadata[&#34;license&#34;]
    email = metadata[&#34;email&#34;]               # email

    verbose = False                         # set it to True to force verbosity
    _contact = (&#34;INRAE\SAYFOOD\olivier.vitrac@agroparistech.fr&#34;,
                &#34;INRAE\SAYFOOD\william.jenkinson@agroparistech.fr&#34;,
                &#34;INRAE\SAYFOOD\han.chen@inrae.fr&#34;)

    SECTIONS = [&#34;NONE&#34;,&#34;GLOBAL&#34;,&#34;INITIALIZE&#34;,&#34;GEOMETRY&#34;,&#34;DISCRETIZATION&#34;,
                &#34;BOUNDARY&#34;,&#34;INTERACTIONS&#34;,&#34;INTEGRATION&#34;,&#34;DUMP&#34;,&#34;STATUS&#34;,&#34;RUN&#34;]

    # Main class variables
    # These definitions are for instances
    DEFINITIONS = scriptdata()
    TEMPLATE = &#34;&#34;&#34;
        # empty LAMMPS script
    &#34;&#34;&#34;

    # constructor
    def __init__(self,persistentfile=True,
                 persistentfolder = None,
                 printflag = False,
                 verbose = False,
                 verbosity = None,
                 **userdefinitions):
        &#34;&#34;&#34; constructor adding instance definitions stored in USER &#34;&#34;&#34;
        if persistentfolder is None: persistentfolder = get_tmp_location()
        self.persistentfile = persistentfile
        self.persistentfolder = persistentfolder
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.USER = scriptdata(**userdefinitions)

    # print method for headers (static, no implicit argument)
    @staticmethod
    def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
        &#34;&#34;&#34; print header &#34;&#34;&#34;
        if txt==&#34;&#34;:
            print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
        else:
            print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))

    # String representation
    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self.type}:{self.name}:{self.userid}&#34;

    # Display/representation method
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        stamp = str(self)
        self.printheader(f&#34;{stamp} | version={self.version}&#34;,filler=&#34;/&#34;)
        self.printheader(&#34;POSITION &amp; DESCRIPTION&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        print(f&#34;     position: {self.position}&#34;)
        print(f&#34;         role: {self.role} (section={self.section})&#34;)
        print(f&#34;  description: {self.description}&#34;)
        self.printheader(&#34;DEFINITIONS&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        if len(self.DEFINITIONS)&lt;15:
            self.DEFINITIONS.__repr__()
        else:
            print(&#34;too many definitions: &#34;,self.DEFINITIONS)
        if self.verbose:
            self.printheader(&#34;USER&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
            self.USER.__repr__()
            self.printheader(&#34;TEMPLATE&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
            print(self.TEMPLATE)
            self.printheader(&#34;SCRIPT&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        print(self.do(printflag=False))
        self.printheader(&#34;&#34;)
        return stamp

    # Extract attributes within the class
    def getallattributes(self):
        &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
        return {k: getattr(self, k) for k in dir(self) \
                if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}

    # Generate the script
    def do(self,printflag=None,verbose=None):
        &#34;&#34;&#34;
        Generate the LAMMPS script based on the current configuration.

        This method generates a LAMMPS-compatible script from the templates and definitions
        stored in the `script` object. The generated script can be displayed, returned,
        and optionally include comments for debugging or clarity.

        Parameters:
        - printflag (bool, optional): If True, the generated script is printed to the console.
                                      Default is True.
        - verbose (bool, optional): If True, comments and additional information are included
                                    in the generated script. If False, comments are removed.
                                    Default is True.

        Returns:
        - str: The generated LAMMPS script.

        Method Behavior:
        - The method first collects all key-value pairs from `DEFINITIONS` and `USER` objects,
          which store the configuration data for the script.
        - Lists and tuples in the collected data are formatted into a readable string with proper
          separators (space for lists, comma for tuples) and prefixed with a &#39;%&#39; to indicate comments.
        - The generated command template is formatted and evaluated using the collected data.
        - If `verbose` is set to False, comments in the generated script are removed.
        - The script is then printed if `printflag` is True.
        - Finally, the formatted script is returned as a string.

        Example Usage:
        --------------
        &gt;&gt;&gt; s = script()
        &gt;&gt;&gt; s.do(printflag=True, verbose=True)
        units           si
        dimension       3
        boundary        f f f
        # Additional script commands...

        &gt;&gt;&gt; s.do(printflag=False, verbose=False)
        &#39;units si\ndimension 3\nboundary f f f\n# Additional script commands...&#39;

        Notes:
        - Comments are indicated in the script with &#39;%&#39; or &#39;#&#39;.
        - The [position {self.position}:{self.userid}] marker is inserted for tracking
          script sections or modifications.
        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        inputs = self.DEFINITIONS + self.USER
        for k in inputs.keys():
            if isinstance(inputs.getattr(k),list):
                inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k)))
            elif isinstance(inputs.getattr(k),tuple):
                inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k),sep=&#34;,&#34;))
        cmd = inputs.formateval(self.TEMPLATE)
        cmd = cmd.replace(&#34;[comment]&#34;,f&#34;[position {self.position}:{self.userid}]&#34;)
        if not verbose: cmd=remove_comments(cmd)
        if printflag: print(cmd)
        return cmd

    # Return the role of the script (based on section)
    @property
    def role(self):
        &#34;&#34;&#34; convert section index into a role (section name) &#34;&#34;&#34;
        if self.section in range(len(self.SECTIONS)):
            return self.SECTIONS[self.section]
        else:
            return &#34;&#34;

    # override +
    def __add__(self,s):
        &#34;&#34;&#34; overload addition operator &#34;&#34;&#34;
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        if isinstance(s,script):
            dup = duplicate(self)
            dup.DEFINITIONS = dup.DEFINITIONS + s.DEFINITIONS
            dup.USER = dup.USER + s.USER
            dup.TEMPLATE = &#34;\n&#34;.join([dup.TEMPLATE,s.TEMPLATE])
            return dup
        elif isinstance(s,pipescript):
            return pipescript(self, printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity) | s
        elif isinstance(s,dscript):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        elif isinstance(s, scriptobjectgroup):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s, group):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        elif isinstance(s, groupcollection):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s,region):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        raise TypeError(f&#34;the second operand in + must a script, pipescript, scriptobjectgroup,\n group, groupcollection or region object not {type(s)}&#34;)

    # override +=
    def _iadd__(self,s):
        &#34;&#34;&#34; overload addition operator &#34;&#34;&#34;
        if isinstance(s,script):
            self.DEFINITIONS = self.DEFINITIONS + s.DEFINITIONS
            self.USER = self.USER + s.USER
            self.TEMPLATE = &#34;\n&#34;.join([self.TEMPLATE,s.TEMPLATE])
        else:
            raise TypeError(&#34;the second operand must a script object&#34;)

    # override &gt;&gt;
    def __rshift__(self,s):
        &#34;&#34;&#34; overload right  shift operator (keep only the last template) &#34;&#34;&#34;
        if isinstance(s,script):
            dup = duplicate(self)
            dup.DEFINITIONS = dup.DEFINITIONS + s.DEFINITIONS
            dup.USER = dup.USER + s.USER
            dup.TEMPLATE = s.TEMPLATE
            return dup
        else:
            raise TypeError(f&#34;the second operand in &gt;&gt; must a script object not {type(s)}&#34;)

    # override &amp;
    def __and__(self,s):
        &#34;&#34;&#34; overload and operator &#34;&#34;&#34;
        if isinstance(s,script):
            dup = duplicate(self)
            dup.TEMPLATE = &#34;\n&#34;.join([self.do(printflag=False,verbose=False),s.do(printflag=False,verbose=False)])
            return dup
        raise TypeError(f&#34;the second operand in &amp; must a script object not {type(s)}&#34;)

    # override *
    def __mul__(self,ntimes):
        &#34;&#34;&#34; overload * operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
           res = duplicate(self)
           if ntimes&gt;1:
               for n in range(1,ntimes): res += self
           return res
        raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)

    # override **
    def __pow__(self,ntimes):
        &#34;&#34;&#34; overload ** operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
           res = duplicate(self)
           if ntimes&gt;1:
               for n in range(1,ntimes): res = res &amp; self
           return res
        raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)

    # pipe scripts
    def __or__(self,pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        if isinstance(pipe, dscript):
            rightarg = pipe.pipescript(printflag=pipe.printflag,verbose=pipe.verbose,verbosity=pipe.verbosity)
        elif isinstance(pipe,group):
            rightarg = pipe.script(printflag=pipe.printflag,verbose=pipe.verbose,verbosity=pipe.verbosity)
        elif isinstance(pipe,groupcollection):
            rightarg = pipe.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(pipe,region):
            rightarg = pipe.pscript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        else:
            rightarg = pipe
        if isinstance(rightarg,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | rightarg
        else:
            raise ValueError(&#34;the argument in | must a pipescript, a scriptobject or a scriptobjectgroup not {type(s)}&#34;)


    def header(self, verbose=True, verbosity=None, style=2):
        &#34;&#34;&#34;
        Generate a formatted header for the script file.

        Parameters:
            verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                        Defaults to the instance&#39;s `verbose`.
            style (int from 1 to 6, optional): ASCII style to frame the header (default=2)

        Returns:
            str: A formatted string representing the script&#39;s metadata and initialization details.
                 Returns an empty string if verbosity is False.

        The header includes:
            - Script version, license, and contact email.
            - User ID and the number of initialized definitions.
            - Current system user, hostname, and working directory.
            - Persistent filename and folder path.
            - Timestamp of the header generation.
        &#34;&#34;&#34;
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        if not verbose:
            return &#34;&#34;
        # Prepare the header content
        lines = [
            f&#34;PIZZA.SCRIPT FILE v{script.version} | License: {script.license} | Email: {script.email}&#34;,
            &#34;&#34;,
            f&#34;&lt;{str(self)}&gt;&#34;,
            f&#34;Initialized with {len(self.USER)} definitions | Verbosity: {verbosity}&#34;,
            f&#34;Persistent file: \&#34;{self.persistentfile}\&#34; | Folder: \&#34;{self.persistentfolder}\&#34;&#34;,
            &#34;&#34;,
            f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
            f&#34;{datetime.datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
        ]
        # Use the shared method to format the header
        return frame_header(lines,style=style)


    # write file
    def write(self, file, printflag=True, verbose=False, overwrite=False, style=2):
        &#34;&#34;&#34;
        Write the script to a file.

        Parameters:
            - file (str): The file path where the script will be saved.
            - printflag (bool): Flag to enable/disable printing of details.
            - verbose (bool): Flag to enable/disable verbose mode.
            - overwrite (bool): Whether to overwrite the file if it already exists.
            - style (int, optional):
                Defines the ASCII frame style for the header.
                Valid values are integers from 1 to 6, corresponding to predefined styles:
                    1. Basic box with `+`, `-`, and `|`
                    2. Double-line frame with `╔`, `═`, and `║`
                    3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                    4. Thick outer frame with `#`, `=`, and `#`
                    5. Box drawing characters with `┌`, `─`, and `│`
                    6. Minimalist dotted frame with `.`, `:`, and `.`
                Default is `2` (frame with rounded corners).

        Returns:
            str: The full absolute path of the file written.

        Raises:
            FileExistsError: If the file already exists and overwrite is False.
        &#34;&#34;&#34;
        # Resolve full path
        full_path = os.path.abspath(file)
        if os.path.exists(full_path) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{full_path}&#39; already exists. Use overwrite=True to overwrite it.&#34;)
        if os.path.exists(full_path) and overwrite and verbose:
            print(f&#34;Warning: Overwriting the existing file &#39;{full_path}&#39;.&#34;)
        # Generate the script and write to the file
        cmd = self.do(printflag=printflag, verbose=verbose)
        with open(full_path, &#34;w&#34;) as f:
            print(self.header(verbosity=verbose, style=style), &#34;\n&#34;, file=f)
            print(cmd, file=f)
        # Return the full path of the written file
        return full_path

    def tmpwrite(self, verbose=False, style=1):
        &#34;&#34;&#34;
        Write the script to a temporary file and create optional persistent copies.

        Parameters:
            verbose (bool, optional): Controls verbosity during script generation. Defaults to False.

        The method:
            - Creates a temporary file for the script, with platform-specific behavior:
                - On Windows (`os.name == &#39;nt&#39;`), the file is not automatically deleted.
                - On other systems, the file is temporary and deleted upon closure.
            - Writes a header and the script content into the temporary file.
            - Optionally creates a persistent copy in the `self.persistentfolder` directory:
                - `script.preview.&lt;suffix&gt;`: A persistent copy of the temporary file.
                - `script.preview.clean.&lt;suffix&gt;`: A clean copy with comments and empty lines removed.
            - Handles cleanup and exceptions gracefully to avoid leaving orphaned files.
            - style (int, optional):
                Defines the ASCII frame style for the header.
                Valid values are integers from 1 to 6, corresponding to predefined styles:
                    1. Basic box with `+`, `-`, and `|`
                    2. Double-line frame with `╔`, `═`, and `║`
                    3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                    4. Thick outer frame with `#`, `=`, and `#`
                    5. Box drawing characters with `┌`, `─`, and `│`
                    6. Minimalist dotted frame with `.`, `:`, and `.`
                Default is `1` (basic box).

        Returns:
            TemporaryFile: The temporary file handle (non-Windows systems only).
            None: On Windows, the file is closed and not returned.

        Raises:
            Exception: If there is an error creating or writing to the temporary file.
        &#34;&#34;&#34;
        try:
            # OS-specific temporary file behavior
            if os.name == &#39;nt&#39;:  # Windows
                ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;, delete=False)
            else:  # Other platforms
                ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;)

            # Generate header and content
            header = (
                f&#34;# TEMPORARY PIZZA.SCRIPT FILE\n&#34;
                f&#34;# {&#39;-&#39; * 40}\n&#34;
                f&#34;{self.header(verbosity=verbose, style=style)}&#34;
            )
            content = (
                header
                + &#34;\n# This is a temporary file (it will be deleted automatically)\n\n&#34;
                + self.do(printflag=False, verbose=verbose)
            )

            # Write content to the temporary file
            ftmp.write(BOM_UTF8 + content.encode(&#39;utf-8&#39;))
            ftmp.seek(0)  # Reset file pointer to the beginning

        except Exception as e:
            # Handle errors gracefully
            ftmp.close()
            os.remove(ftmp.name)  # Clean up the temporary file
            raise Exception(f&#34;Failed to write to or handle the temporary file: {e}&#34;) from None

        print(&#34;\nTemporary File Header:\n&#34;, header, &#34;\n&#34;)
        print(&#34;A temporary file has been generated here:\n&#34;, ftmp.name)

        # Persistent copy creation
        if self.persistentfile:
            ftmpname = os.path.basename(ftmp.name)
            fcopyname = os.path.join(self.persistentfolder, f&#34;script.preview.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
            copyfile(ftmp.name, fcopyname)
            print(&#34;A persistent copy has been created here:\n&#34;, fcopyname)

            # Create a clean copy without empty lines or comments
            with open(ftmp.name, &#34;r&#34;) as f:
                lines = f.readlines()
            bom_utf8_str = BOM_UTF8.decode(&#34;utf-8&#34;)
            clean_lines = [
                line for line in lines
                if line.strip() and not line.lstrip().startswith(&#34;#&#34;) and not line.startswith(bom_utf8_str)
            ]
            fcleanname = os.path.join(self.persistentfolder, f&#34;script.preview.clean.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
            with open(fcleanname, &#34;w&#34;) as f:
                f.writelines(clean_lines)
            print(&#34;A clean copy has been created here:\n&#34;, fcleanname)

            # Handle file closure for Windows
            if os.name == &#39;nt&#39;:
                ftmp.close()
                return None
            else:
                return ftmp


    # Note that it was not the original intent to copy scripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo))
        return copie

    def detect_variables(self):
        &#34;&#34;&#34;
        Detects variables in the content of the template using the pattern r&#39;\$\{(\w+)\}&#39;.

        Returns:
        --------
        list
            A list of unique variable names detected in the content.
        &#34;&#34;&#34;
        # Regular expression to match variables in the format ${varname}
        variable_pattern = re.compile(r&#39;\$\{(\w+)\}&#39;)
        # Ensure TEMPLATE is iterable (split string into lines if needed)
        if isinstance(self.TEMPLATE, str):
            lines = self.TEMPLATE.splitlines()  # Split string into lines
        elif isinstance(self.TEMPLATE, list):
            lines = self.TEMPLATE
        else:
            raise TypeError(&#34;TEMPLATE must be a string or a list of strings.&#34;)
        # Detect variables from all lines
        detected_vars = {variable for line in lines for variable in variable_pattern.findall(line)}
        # Return the list of unique variables
        return list(detected_vars)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dscript.lamdaScript" href="#dscript.lamdaScript">lamdaScript</a></li>
<li>pizza.dscript.lamdaScript</li>
<li>pizza.region.LammpsGeneric</li>
<li>pizza.script.boundarysection</li>
<li>pizza.script.discretizationsection</li>
<li>pizza.script.dumpsection</li>
<li>pizza.script.geometrysection</li>
<li>pizza.script.globalsection</li>
<li>pizza.script.initializesection</li>
<li>pizza.script.integrationsection</li>
<li>pizza.script.interactionsection</li>
<li>pizza.script.runsection</li>
<li>pizza.script.statussection</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dscript.script.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.email"><code class="name">var <span class="ident">email</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.license"><code class="name">var <span class="ident">license</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dscript.script.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dscript.script.printheader"><code class="name flex">
<span>def <span class="ident">printheader</span></span>(<span>txt, align='^', width=80, filler='~')</span>
</code></dt>
<dd>
<div class="desc"><p>print header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
    &#34;&#34;&#34; print header &#34;&#34;&#34;
    if txt==&#34;&#34;:
        print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
    else:
        print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dscript.script.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"><p>convert section index into a role (section name)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def role(self):
    &#34;&#34;&#34; convert section index into a role (section name) &#34;&#34;&#34;
    if self.section in range(len(self.SECTIONS)):
        return self.SECTIONS[self.section]
    else:
        return &#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dscript.script.detect_variables"><code class="name flex">
<span>def <span class="ident">detect_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects variables in the content of the template using the pattern r'\${(\w+)}'.</p>
<h2 id="returns">Returns:</h2>
<p>list
A list of unique variable names detected in the content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_variables(self):
    &#34;&#34;&#34;
    Detects variables in the content of the template using the pattern r&#39;\$\{(\w+)\}&#39;.

    Returns:
    --------
    list
        A list of unique variable names detected in the content.
    &#34;&#34;&#34;
    # Regular expression to match variables in the format ${varname}
    variable_pattern = re.compile(r&#39;\$\{(\w+)\}&#39;)
    # Ensure TEMPLATE is iterable (split string into lines if needed)
    if isinstance(self.TEMPLATE, str):
        lines = self.TEMPLATE.splitlines()  # Split string into lines
    elif isinstance(self.TEMPLATE, list):
        lines = self.TEMPLATE
    else:
        raise TypeError(&#34;TEMPLATE must be a string or a list of strings.&#34;)
    # Detect variables from all lines
    detected_vars = {variable for line in lines for variable in variable_pattern.findall(line)}
    # Return the list of unique variables
    return list(detected_vars)</code></pre>
</details>
</dd>
<dt id="dscript.script.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, printflag=None, verbose=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the LAMMPS script based on the current configuration.</p>
<pre><code>    This method generates a LAMMPS-compatible script from the templates and definitions
    stored in the &lt;code&gt;&lt;a title="dscript.script" href="#dscript.script"&gt;script&lt;/a&gt;&lt;/code&gt; object. The generated script can be displayed, returned,
    and optionally include comments for debugging or clarity.

    Parameters:
    - printflag (bool, optional): If True, the generated script is printed to the console.
                                  Default is True.
    - verbose (bool, optional): If True, comments and additional information are included
                                in the generated script. If False, comments are removed.
                                Default is True.

    Returns:
    - str: The generated LAMMPS script.

    Method Behavior:
    - The method first collects all key-value pairs from &lt;code&gt;DEFINITIONS&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; objects,
      which store the configuration data for the script.
    - Lists and tuples in the collected data are formatted into a readable string with proper
      separators (space for lists, comma for tuples) and prefixed with a '%' to indicate comments.
    - The generated command template is formatted and evaluated using the collected data.
    - If &lt;code&gt;verbose&lt;/code&gt; is set to False, comments in the generated script are removed.
    - The script is then printed if &lt;code&gt;printflag&lt;/code&gt; is True.
    - Finally, the formatted script is returned as a string.

    Example Usage:
    --------------
    &gt;&gt;&gt; s = script()
    &gt;&gt;&gt; s.do(printflag=True, verbose=True)
    units           si
    dimension       3
    boundary        f f f
    # Additional script commands...

    &gt;&gt;&gt; s.do(printflag=False, verbose=False)
    'units si
</code></pre>
<p>dimension 3
boundary f f f</p>
<h1 id="additional-script-commands">Additional script commands&hellip;'</h1>
<pre><code>    Notes:
    - Comments are indicated in the script with '%' or '#'.
    - The [position {self.position}:{self.userid}] marker is inserted for tracking
      script sections or modifications.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self,printflag=None,verbose=None):
    &#34;&#34;&#34;
    Generate the LAMMPS script based on the current configuration.

    This method generates a LAMMPS-compatible script from the templates and definitions
    stored in the `script` object. The generated script can be displayed, returned,
    and optionally include comments for debugging or clarity.

    Parameters:
    - printflag (bool, optional): If True, the generated script is printed to the console.
                                  Default is True.
    - verbose (bool, optional): If True, comments and additional information are included
                                in the generated script. If False, comments are removed.
                                Default is True.

    Returns:
    - str: The generated LAMMPS script.

    Method Behavior:
    - The method first collects all key-value pairs from `DEFINITIONS` and `USER` objects,
      which store the configuration data for the script.
    - Lists and tuples in the collected data are formatted into a readable string with proper
      separators (space for lists, comma for tuples) and prefixed with a &#39;%&#39; to indicate comments.
    - The generated command template is formatted and evaluated using the collected data.
    - If `verbose` is set to False, comments in the generated script are removed.
    - The script is then printed if `printflag` is True.
    - Finally, the formatted script is returned as a string.

    Example Usage:
    --------------
    &gt;&gt;&gt; s = script()
    &gt;&gt;&gt; s.do(printflag=True, verbose=True)
    units           si
    dimension       3
    boundary        f f f
    # Additional script commands...

    &gt;&gt;&gt; s.do(printflag=False, verbose=False)
    &#39;units si\ndimension 3\nboundary f f f\n# Additional script commands...&#39;

    Notes:
    - Comments are indicated in the script with &#39;%&#39; or &#39;#&#39;.
    - The [position {self.position}:{self.userid}] marker is inserted for tracking
      script sections or modifications.
    &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = self.verbose if verbose is None else verbose
    inputs = self.DEFINITIONS + self.USER
    for k in inputs.keys():
        if isinstance(inputs.getattr(k),list):
            inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k)))
        elif isinstance(inputs.getattr(k),tuple):
            inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k),sep=&#34;,&#34;))
    cmd = inputs.formateval(self.TEMPLATE)
    cmd = cmd.replace(&#34;[comment]&#34;,f&#34;[position {self.position}:{self.userid}]&#34;)
    if not verbose: cmd=remove_comments(cmd)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="dscript.script.getallattributes"><code class="name flex">
<span>def <span class="ident">getallattributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>advanced method to get all attributes including class ones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getallattributes(self):
    &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
    return {k: getattr(self, k) for k in dir(self) \
            if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}</code></pre>
</details>
</dd>
<dt id="dscript.script.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self, verbose=True, verbosity=None, style=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a formatted header for the script file.</p>
<h2 id="parameters">Parameters</h2>
<p>verbosity (bool, optional): If specified, overrides the instance's <code>verbose</code> setting.
Defaults to the instance's <code>verbose</code>.
style (int from 1 to 6, optional): ASCII style to frame the header (default=2)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representing the script's metadata and initialization details.
Returns an empty string if verbosity is False.</dd>
</dl>
<p>The header includes:
- Script version, license, and contact email.
- User ID and the number of initialized definitions.
- Current system user, hostname, and working directory.
- Persistent filename and folder path.
- Timestamp of the header generation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self, verbose=True, verbosity=None, style=2):
    &#34;&#34;&#34;
    Generate a formatted header for the script file.

    Parameters:
        verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                    Defaults to the instance&#39;s `verbose`.
        style (int from 1 to 6, optional): ASCII style to frame the header (default=2)

    Returns:
        str: A formatted string representing the script&#39;s metadata and initialization details.
             Returns an empty string if verbosity is False.

    The header includes:
        - Script version, license, and contact email.
        - User ID and the number of initialized definitions.
        - Current system user, hostname, and working directory.
        - Persistent filename and folder path.
        - Timestamp of the header generation.
    &#34;&#34;&#34;
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    if not verbose:
        return &#34;&#34;
    # Prepare the header content
    lines = [
        f&#34;PIZZA.SCRIPT FILE v{script.version} | License: {script.license} | Email: {script.email}&#34;,
        &#34;&#34;,
        f&#34;&lt;{str(self)}&gt;&#34;,
        f&#34;Initialized with {len(self.USER)} definitions | Verbosity: {verbosity}&#34;,
        f&#34;Persistent file: \&#34;{self.persistentfile}\&#34; | Folder: \&#34;{self.persistentfolder}\&#34;&#34;,
        &#34;&#34;,
        f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
        f&#34;{datetime.datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
    ]
    # Use the shared method to format the header
    return frame_header(lines,style=style)</code></pre>
</details>
</dd>
<dt id="dscript.script.tmpwrite"><code class="name flex">
<span>def <span class="ident">tmpwrite</span></span>(<span>self, verbose=False, style=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the script to a temporary file and create optional persistent copies.</p>
<h2 id="parameters">Parameters</h2>
<p>verbose (bool, optional): Controls verbosity during script generation. Defaults to False.</p>
<p>The method:
- Creates a temporary file for the script, with platform-specific behavior:
- On Windows (<code>os.name == 'nt'</code>), the file is not automatically deleted.
- On other systems, the file is temporary and deleted upon closure.
- Writes a header and the script content into the temporary file.
- Optionally creates a persistent copy in the <code>self.persistentfolder</code> directory:
- <code>script.preview.&lt;suffix&gt;</code>: A persistent copy of the temporary file.
- <code>script.preview.clean.&lt;suffix&gt;</code>: A clean copy with comments and empty lines removed.
- Handles cleanup and exceptions gracefully to avoid leaving orphaned files.
- style (int, optional):
Defines the ASCII frame style for the header.
Valid values are integers from 1 to 6, corresponding to predefined styles:
1. Basic box with <code>+</code>, <code>-</code>, and <code>|</code>
2. Double-line frame with <code>╔</code>, <code>═</code>, and <code>║</code>
3. Rounded corners with <code>.</code>, <code>'</code>, <code>-</code>, and <code>|</code>
4. Thick outer frame with <code>#</code>, <code>=</code>, and <code>#</code>
5. Box drawing characters with <code>┌</code>, <code>─</code>, and <code>│</code>
6. Minimalist dotted frame with <code>.</code>, <code>:</code>, and <code>.</code>
Default is <code>1</code> (basic box).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TemporaryFile</code></dt>
<dd>The temporary file handle (non-Windows systems only).</dd>
<dt><code>None</code></dt>
<dd>On Windows, the file is closed and not returned.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If there is an error creating or writing to the temporary file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tmpwrite(self, verbose=False, style=1):
    &#34;&#34;&#34;
    Write the script to a temporary file and create optional persistent copies.

    Parameters:
        verbose (bool, optional): Controls verbosity during script generation. Defaults to False.

    The method:
        - Creates a temporary file for the script, with platform-specific behavior:
            - On Windows (`os.name == &#39;nt&#39;`), the file is not automatically deleted.
            - On other systems, the file is temporary and deleted upon closure.
        - Writes a header and the script content into the temporary file.
        - Optionally creates a persistent copy in the `self.persistentfolder` directory:
            - `script.preview.&lt;suffix&gt;`: A persistent copy of the temporary file.
            - `script.preview.clean.&lt;suffix&gt;`: A clean copy with comments and empty lines removed.
        - Handles cleanup and exceptions gracefully to avoid leaving orphaned files.
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with `╔`, `═`, and `║`
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with `┌`, `─`, and `│`
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `1` (basic box).

    Returns:
        TemporaryFile: The temporary file handle (non-Windows systems only).
        None: On Windows, the file is closed and not returned.

    Raises:
        Exception: If there is an error creating or writing to the temporary file.
    &#34;&#34;&#34;
    try:
        # OS-specific temporary file behavior
        if os.name == &#39;nt&#39;:  # Windows
            ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;, delete=False)
        else:  # Other platforms
            ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;)

        # Generate header and content
        header = (
            f&#34;# TEMPORARY PIZZA.SCRIPT FILE\n&#34;
            f&#34;# {&#39;-&#39; * 40}\n&#34;
            f&#34;{self.header(verbosity=verbose, style=style)}&#34;
        )
        content = (
            header
            + &#34;\n# This is a temporary file (it will be deleted automatically)\n\n&#34;
            + self.do(printflag=False, verbose=verbose)
        )

        # Write content to the temporary file
        ftmp.write(BOM_UTF8 + content.encode(&#39;utf-8&#39;))
        ftmp.seek(0)  # Reset file pointer to the beginning

    except Exception as e:
        # Handle errors gracefully
        ftmp.close()
        os.remove(ftmp.name)  # Clean up the temporary file
        raise Exception(f&#34;Failed to write to or handle the temporary file: {e}&#34;) from None

    print(&#34;\nTemporary File Header:\n&#34;, header, &#34;\n&#34;)
    print(&#34;A temporary file has been generated here:\n&#34;, ftmp.name)

    # Persistent copy creation
    if self.persistentfile:
        ftmpname = os.path.basename(ftmp.name)
        fcopyname = os.path.join(self.persistentfolder, f&#34;script.preview.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
        copyfile(ftmp.name, fcopyname)
        print(&#34;A persistent copy has been created here:\n&#34;, fcopyname)

        # Create a clean copy without empty lines or comments
        with open(ftmp.name, &#34;r&#34;) as f:
            lines = f.readlines()
        bom_utf8_str = BOM_UTF8.decode(&#34;utf-8&#34;)
        clean_lines = [
            line for line in lines
            if line.strip() and not line.lstrip().startswith(&#34;#&#34;) and not line.startswith(bom_utf8_str)
        ]
        fcleanname = os.path.join(self.persistentfolder, f&#34;script.preview.clean.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
        with open(fcleanname, &#34;w&#34;) as f:
            f.writelines(clean_lines)
        print(&#34;A clean copy has been created here:\n&#34;, fcleanname)

        # Handle file closure for Windows
        if os.name == &#39;nt&#39;:
            ftmp.close()
            return None
        else:
            return ftmp</code></pre>
</details>
</dd>
<dt id="dscript.script.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, printflag=True, verbose=False, overwrite=False, style=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the script to a file.</p>
<h2 id="parameters">Parameters</h2>
<ul>
<li>file (str): The file path where the script will be saved.</li>
<li>printflag (bool): Flag to enable/disable printing of details.</li>
<li>verbose (bool): Flag to enable/disable verbose mode.</li>
<li>overwrite (bool): Whether to overwrite the file if it already exists.</li>
<li>style (int, optional):
Defines the ASCII frame style for the header.
Valid values are integers from 1 to 6, corresponding to predefined styles:
1. Basic box with <code>+</code>, <code>-</code>, and <code>|</code>
2. Double-line frame with <code>╔</code>, <code>═</code>, and <code>║</code>
3. Rounded corners with <code>.</code>, <code>'</code>, <code>-</code>, and <code>|</code>
4. Thick outer frame with <code>#</code>, <code>=</code>, and <code>#</code>
5. Box drawing characters with <code>┌</code>, <code>─</code>, and <code>│</code>
6. Minimalist dotted frame with <code>.</code>, <code>:</code>, and <code>.</code>
Default is <code>2</code> (frame with rounded corners).</li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The full absolute path of the file written.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and overwrite is False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, printflag=True, verbose=False, overwrite=False, style=2):
    &#34;&#34;&#34;
    Write the script to a file.

    Parameters:
        - file (str): The file path where the script will be saved.
        - printflag (bool): Flag to enable/disable printing of details.
        - verbose (bool): Flag to enable/disable verbose mode.
        - overwrite (bool): Whether to overwrite the file if it already exists.
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with `╔`, `═`, and `║`
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with `┌`, `─`, and `│`
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `2` (frame with rounded corners).

    Returns:
        str: The full absolute path of the file written.

    Raises:
        FileExistsError: If the file already exists and overwrite is False.
    &#34;&#34;&#34;
    # Resolve full path
    full_path = os.path.abspath(file)
    if os.path.exists(full_path) and not overwrite:
        raise FileExistsError(f&#34;The file &#39;{full_path}&#39; already exists. Use overwrite=True to overwrite it.&#34;)
    if os.path.exists(full_path) and overwrite and verbose:
        print(f&#34;Warning: Overwriting the existing file &#39;{full_path}&#39;.&#34;)
    # Generate the script and write to the file
    cmd = self.do(printflag=printflag, verbose=verbose)
    with open(full_path, &#34;w&#34;) as f:
        print(self.header(verbosity=verbose, style=style), &#34;\n&#34;, file=f)
        print(cmd, file=f)
    # Return the full path of the written file
    return full_path</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dscript.scriptdata"><code class="flex name class">
<span>class <span class="ident">scriptdata</span></span>
<span>(</span><span>sortdefinitions=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>class of script parameters
Typical constructor:
DEFINITIONS = scriptdata(
var1 = value1,
var2 = value2
)
See script, struct, param to get review all methods attached to it</p>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scriptdata(param):
    &#34;&#34;&#34;
        class of script parameters
            Typical constructor:
                DEFINITIONS = scriptdata(
                    var1 = value1,
                    var2 = value2
                    )
        See script, struct, param to get review all methods attached to it
    &#34;&#34;&#34;
    _type = &#34;SD&#34;
    _fulltype = &#34;script data&#34;
    _ftype = &#34;definition&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="dscript.scriptobjectgroup"><code class="flex name class">
<span>class <span class="ident">scriptobjectgroup</span></span>
<span>(</span><span>*SOgroup)</span>
</code></dt>
<dd>
<div class="desc"><p>scriptobjectgroup: A Class for Managing Groups of Script Objects in LAMMPS</p>
<p>The <code><a title="dscript.scriptobjectgroup" href="#dscript.scriptobjectgroup">scriptobjectgroup</a></code> class is designed to represent a group of <code>scriptobject</code> instances,
such as beads or atoms in a simulation. This class allows users to group objects together
based on their properties (e.g., beadtype, name), and provides tools to generate scripts
that define interactions, groups, and forcefields for these objects in LAMMPS.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Group Management</strong>: Objects can be combined into a group, where each <code>beadtype</code> occurs
once. The class ensures that objects are uniquely identified by their <code>beadtype</code> and <code>name</code>.</li>
<li><strong>Dynamic Properties</strong>: The group’s properties (e.g., <code>beadtype</code>, <code>name</code>, <code>groupname</code>)
are dynamically calculated, ensuring that the group reflects the current state of the objects.</li>
<li><strong>Script Generation</strong>: Provides methods to generate scripts based on the group's objects,
including interaction forcefields and group definitions.</li>
<li><strong>Interaction Accumulation</strong>: Automatically accumulates and updates all forcefield
interactions for the objects in the group.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>LAMMPS Group Definitions</strong>: Define groups of objects for use in LAMMPS simulations,
based on properties like <code>beadtype</code> and <code>groupname</code>.</li>
<li><strong>Forcefield Management</strong>: Automatically manage and update interaction forcefields for
objects in the group.</li>
<li><strong>Script Generation</strong>: Generate LAMMPS-compatible scripts that include group definitions,
input file handling, and interaction forcefields.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, *SOgroup):
Initializes a new <code><a title="dscript.scriptobjectgroup" href="#dscript.scriptobjectgroup">scriptobjectgroup</a></code> with one or more <code>scriptobject</code> instances.</p>
<p><strong>str</strong>(self):
Returns a string representation of the <code><a title="dscript.scriptobjectgroup" href="#dscript.scriptobjectgroup">scriptobjectgroup</a></code>, showing the number of objects
in the group and their <code>beadtypes</code>.</p>
<p><strong>add</strong>(self, SOgroup):
Combines two <code><a title="dscript.scriptobjectgroup" href="#dscript.scriptobjectgroup">scriptobjectgroup</a></code> instances or a <code>scriptobject</code> with an existing group,
ensuring that <code>beadtype</code> values are unique.</p>
<p><strong>or</strong>(self, pipe):
Overloads the pipe (<code>|</code>) operator to integrate the group into a pipeline.</p>
<p>select(self, beadtype=None):
Selects and returns a subset of the group based on the specified <code>beadtype</code>.</p>
<p>script(self, printflag=False, verbosity=2, verbose=None):
Generates a script based on the current collection of objects, including input file
handling, group definitions, and interaction forcefields.</p>
<p>interactions(self, printflag=False, verbosity=2, verbose=None):
Updates and accumulates all forcefields for the objects in the group.</p>
<p>group_generator(self, name=None):
Generates and returns a <code>group</code> object, based on the existing group structure.</p>
<h2 id="properties">Properties:</h2>
<ul>
<li>list : Converts the group into a sorted list of objects.</li>
<li>zip : Returns a sorted list of tuples containing <code>beadtype</code>, <code>name</code>, <code>group</code>, and <code>filename</code>
for each object.</li>
<li>n : Returns the number of objects in the group.</li>
<li>beadtype : Returns a list of the <code>beadtypes</code> for all objects in the group.</li>
<li>name : Returns a list of the <code>names</code> for all objects in the group.</li>
<li>groupname : Returns a list of all group names (synonyms).</li>
<li>filename : Returns a dictionary mapping filenames to the objects that use them.</li>
<li>str : Returns a string representation of the group's <code>beadtypes</code>.</li>
<li>min : Returns the minimum <code>beadtype</code> in the group.</li>
<li>max : Returns the maximum <code>beadtype</code> in the group.</li>
<li>minmax : Returns a tuple of the minimum and maximum <code>beadtypes</code> in the group.</li>
<li>forcefield : Returns the interaction forcefields for the group.</li>
</ul>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="dscript.scriptobjectgroup" href="#dscript.scriptobjectgroup">scriptobjectgroup</a></code> class enables the collection and management of multiple
<code>scriptobject</code> instances, providing the following functionalities:
- <strong>Group Creation</strong>: Groups are automatically formed by combining individual objects
using the <code>+</code> operator. Each <code>beadtype</code> occurs only once in the group, and errors are
raised if an object with the same <code>name</code> or <code>beadtype</code> already exists.
- <strong>Dynamic Properties</strong>: Properties such as <code>beadtype</code>, <code>name</code>, <code>groupname</code>, and <code>filename</code>
are dynamically calculated, reflecting the current state of the objects.
- <strong>Forcefield Handling</strong>: Forcefields are automatically managed for the objects in the group,
including diagonal and off-diagonal terms for pair interactions.
- <strong>Script Generation</strong>: Scripts are generated to define the interactions, groups, and
input file handling for LAMMPS.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>from pizza.scriptobject import scriptobject, scriptobjectgroup, rigidwall, solidfood, water

# Define some script objects
b1 = scriptobject(name=&quot;bead 1&quot;, group=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], filename='myfile1', forcefield=rigidwall())
b2 = scriptobject(name=&quot;bead 2&quot;, group=[&quot;B&quot;, &quot;C&quot;], filename='myfile1', forcefield=rigidwall())
b3 = scriptobject(name=&quot;bead 3&quot;, group=[&quot;B&quot;, &quot;D&quot;, &quot;E&quot;], forcefield=solidfood())
b4 = scriptobject(name=&quot;bead 4&quot;, group=&quot;D&quot;, beadtype=1, filename=&quot;myfile2&quot;, forcefield=water())

# Combine objects into a group
collection = b1 + b2 + b3 + b4

# Select a subset of objects and generate a script
grp_typ1 = collection.select(1)
grpB = collection.group.B
script12 = collection.select([1, 2]).script()
</code></pre>
<p>Output:</p>
<pre><code>script object group with 4 objects (1 2 3 4)
script
</code></pre>
<h2 id="overview">OVERVIEW:</h2>
<pre><code>class of script object group
    script object groups are built from script objects OBJ1, OBJ2,..
    GRP = scriptobjectgroup(OBJ1,OBJ2,...)
    GRP = OBJ1+OBJ2+...

note: each beadtype occurs once in the group (if not an error message is generated)

List of methods
    struct() converts data as structure
    select([1,2,4]) selects objects with matching beadtypes

List of properties (dynamically calculated)
    converted data: list, str, zip, beadtype, name, groupname, group, filename
    numeric: len, min, max, minmax
    forcefield related: interactions, forcefield
    script: generate the script (load,group,forcefield)

Full syntax (toy example)
</code></pre>
<p>b1 = scriptobject(name="bead 1",group = ["A", "B", "C"],filename='myfile1',forcefield=rigidwall())
b2 = scriptobject(name="bead 2", group = ["B", "C"],filename = 'myfile1',forcefield=rigidwall())
b3 = scriptobject(name="bead 3", group = ["B", "D", "E"],forcefield=solidfood())
b4 = scriptobject(name="bead 4", group = "D",beadtype = 1,filename="myfile2",forcefield=water())</p>
<pre><code>note: beadtype are incremented during the collection (effect of order)

    # generate a collection, select a typ 1 and a subgroup, generate the script for 1,2

    collection = b1+b2+b3+b4
    grp_typ1 = collection.select(1)
    grpB = collection.group.B
    script12 = collection.select([1,2]).script

note: collection.group.B returns a strcture with 6 fields
-----------:----------------------------------------
    groupid: 2 &lt;-- automatic group numbering
groupidname: B &lt;-- group name
  groupname: ['A', 'B', 'C', 'D', 'E'] &lt;--- snonyms
   beadtype: [1, 2, 3] &lt;-- beads belonging to B
       name: ['bead 1', 'bead 2', 'bead 3'] &lt;-- their names
        str: group B 1 2 3 &lt;-- LAMMPS syntax
-----------:----------------------------------------
</code></pre>
<p>SOG constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scriptobjectgroup(struct):
    &#34;&#34;&#34;
    scriptobjectgroup: A Class for Managing Groups of Script Objects in LAMMPS

    The `scriptobjectgroup` class is designed to represent a group of `scriptobject` instances,
    such as beads or atoms in a simulation. This class allows users to group objects together
    based on their properties (e.g., beadtype, name), and provides tools to generate scripts
    that define interactions, groups, and forcefields for these objects in LAMMPS.

    Key Features:
    -------------
    - **Group Management**: Objects can be combined into a group, where each `beadtype` occurs
      once. The class ensures that objects are uniquely identified by their `beadtype` and `name`.
    - **Dynamic Properties**: The group’s properties (e.g., `beadtype`, `name`, `groupname`)
      are dynamically calculated, ensuring that the group reflects the current state of the objects.
    - **Script Generation**: Provides methods to generate scripts based on the group&#39;s objects,
      including interaction forcefields and group definitions.
    - **Interaction Accumulation**: Automatically accumulates and updates all forcefield
      interactions for the objects in the group.

    Practical Use Cases:
    --------------------
    - **LAMMPS Group Definitions**: Define groups of objects for use in LAMMPS simulations,
      based on properties like `beadtype` and `groupname`.
    - **Forcefield Management**: Automatically manage and update interaction forcefields for
      objects in the group.
    - **Script Generation**: Generate LAMMPS-compatible scripts that include group definitions,
      input file handling, and interaction forcefields.

    Methods:
    --------
    __init__(self, *SOgroup):
        Initializes a new `scriptobjectgroup` with one or more `scriptobject` instances.

    __str__(self):
        Returns a string representation of the `scriptobjectgroup`, showing the number of objects
        in the group and their `beadtypes`.

    __add__(self, SOgroup):
        Combines two `scriptobjectgroup` instances or a `scriptobject` with an existing group,
        ensuring that `beadtype` values are unique.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the group into a pipeline.

    select(self, beadtype=None):
        Selects and returns a subset of the group based on the specified `beadtype`.

    script(self, printflag=False, verbosity=2, verbose=None):
        Generates a script based on the current collection of objects, including input file
        handling, group definitions, and interaction forcefields.

    interactions(self, printflag=False, verbosity=2, verbose=None):
        Updates and accumulates all forcefields for the objects in the group.

    group_generator(self, name=None):
        Generates and returns a `group` object, based on the existing group structure.

    Properties:
    -----------
    - list : Converts the group into a sorted list of objects.
    - zip : Returns a sorted list of tuples containing `beadtype`, `name`, `group`, and `filename`
      for each object.
    - n : Returns the number of objects in the group.
    - beadtype : Returns a list of the `beadtypes` for all objects in the group.
    - name : Returns a list of the `names` for all objects in the group.
    - groupname : Returns a list of all group names (synonyms).
    - filename : Returns a dictionary mapping filenames to the objects that use them.
    - str : Returns a string representation of the group&#39;s `beadtypes`.
    - min : Returns the minimum `beadtype` in the group.
    - max : Returns the maximum `beadtype` in the group.
    - minmax : Returns a tuple of the minimum and maximum `beadtypes` in the group.
    - forcefield : Returns the interaction forcefields for the group.

    Original Content:
    -----------------
    The `scriptobjectgroup` class enables the collection and management of multiple
    `scriptobject` instances, providing the following functionalities:
    - **Group Creation**: Groups are automatically formed by combining individual objects
      using the `+` operator. Each `beadtype` occurs only once in the group, and errors are
      raised if an object with the same `name` or `beadtype` already exists.
    - **Dynamic Properties**: Properties such as `beadtype`, `name`, `groupname`, and `filename`
      are dynamically calculated, reflecting the current state of the objects.
    - **Forcefield Handling**: Forcefields are automatically managed for the objects in the group,
      including diagonal and off-diagonal terms for pair interactions.
    - **Script Generation**: Scripts are generated to define the interactions, groups, and
      input file handling for LAMMPS.

    Example Usage:
    --------------
    ```
    from pizza.scriptobject import scriptobject, scriptobjectgroup, rigidwall, solidfood, water

    # Define some script objects
    b1 = scriptobject(name=&#34;bead 1&#34;, group=[&#34;A&#34;, &#34;B&#34;, &#34;C&#34;], filename=&#39;myfile1&#39;, forcefield=rigidwall())
    b2 = scriptobject(name=&#34;bead 2&#34;, group=[&#34;B&#34;, &#34;C&#34;], filename=&#39;myfile1&#39;, forcefield=rigidwall())
    b3 = scriptobject(name=&#34;bead 3&#34;, group=[&#34;B&#34;, &#34;D&#34;, &#34;E&#34;], forcefield=solidfood())
    b4 = scriptobject(name=&#34;bead 4&#34;, group=&#34;D&#34;, beadtype=1, filename=&#34;myfile2&#34;, forcefield=water())

    # Combine objects into a group
    collection = b1 + b2 + b3 + b4

    # Select a subset of objects and generate a script
    grp_typ1 = collection.select(1)
    grpB = collection.group.B
    script12 = collection.select([1, 2]).script()
    ```

    Output:
    ```
    script object group with 4 objects (1 2 3 4)
    script
    ```

    OVERVIEW:
    --------------


        class of script object group
            script object groups are built from script objects OBJ1, OBJ2,..
            GRP = scriptobjectgroup(OBJ1,OBJ2,...)
            GRP = OBJ1+OBJ2+...

        note: each beadtype occurs once in the group (if not an error message is generated)

        List of methods
            struct() converts data as structure
            select([1,2,4]) selects objects with matching beadtypes

        List of properties (dynamically calculated)
            converted data: list, str, zip, beadtype, name, groupname, group, filename
            numeric: len, min, max, minmax
            forcefield related: interactions, forcefield
            script: generate the script (load,group,forcefield)

        Full syntax (toy example)

    b1 = scriptobject(name=&#34;bead 1&#34;,group = [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;],filename=&#39;myfile1&#39;,forcefield=rigidwall())
    b2 = scriptobject(name=&#34;bead 2&#34;, group = [&#34;B&#34;, &#34;C&#34;],filename = &#39;myfile1&#39;,forcefield=rigidwall())
    b3 = scriptobject(name=&#34;bead 3&#34;, group = [&#34;B&#34;, &#34;D&#34;, &#34;E&#34;],forcefield=solidfood())
    b4 = scriptobject(name=&#34;bead 4&#34;, group = &#34;D&#34;,beadtype = 1,filename=&#34;myfile2&#34;,forcefield=water())

        note: beadtype are incremented during the collection (effect of order)

            # generate a collection, select a typ 1 and a subgroup, generate the script for 1,2

            collection = b1+b2+b3+b4
            grp_typ1 = collection.select(1)
            grpB = collection.group.B
            script12 = collection.select([1,2]).script

        note: collection.group.B returns a strcture with 6 fields
        -----------:----------------------------------------
            groupid: 2 &lt;-- automatic group numbering
        groupidname: B &lt;-- group name
          groupname: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] &lt;--- snonyms
           beadtype: [1, 2, 3] &lt;-- beads belonging to B
               name: [&#39;bead 1&#39;, &#39;bead 2&#39;, &#39;bead 3&#39;] &lt;-- their names
                str: group B 1 2 3 &lt;-- LAMMPS syntax
        -----------:----------------------------------------

    &#34;&#34;&#34;
    _type = &#34;SOG&#34;
    _fulltype = &#34;script object group&#34;
    _ftype = &#34;object&#34;
    _propertyasattribute = True

    def __init__(self,*SOgroup):
        &#34;&#34;&#34; SOG constructor &#34;&#34;&#34;
        super(scriptobjectgroup,self).__init__()
        beadtypemax = 0
        names = []
        for k in range(len(SOgroup)):
            if isinstance(SOgroup[k],scriptobject):
                if SOgroup[k].beadtype&lt;beadtypemax or SOgroup[k].beadtype==None:
                    beadtypemax +=1
                    SOgroup[k].beadtype = beadtypemax
                if SOgroup[k].name not in names:
                    self.setattr(SOgroup[k].name,SOgroup[k])
                    beadtypemax = SOgroup[k].beadtype
                else:
                    raise ValueError(&#39;the script object &#34;%s&#34; already exists&#39; % SOgroup[k].name)
                names.append(SOgroup[k].name)
            else:
                raise ValueError(&#34;the argument #%d is not a script object&#34;)

    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self._fulltype} with {len(self)} {self._ftype}s ({span(self.beadtype)})&#34;

    def __add__(self, SOgroup):
        &#34;&#34;&#34; overload + &#34;&#34;&#34;
        beadlist = self.beadtype
        dup = duplicate(self)
        if isinstance(SOgroup,scriptobject):
            if SOgroup.name not in self.keys():
                if SOgroup.beadtype in beadlist and \
                  (SOgroup.beadtype==None or SOgroup.beadtype==self.min):
                      SOgroup.beadtype = self.max+1
                if SOgroup.beadtype not in beadlist:
                    dup.setattr(SOgroup.name, SOgroup)
                    beadlist.append(SOgroup.beadtype)
                    return dup
                else:
                    raise ValueError(&#39;%s (beadtype=%d) is already in use, same beadtype&#39; \
                                     % (SOgroup.name,SOgroup.beadtype))
            else:
                raise ValueError(&#39;the object &#34;%s&#34; is already in the list&#39; % SOgroup.name)
        elif isinstance(SOgroup,scriptobjectgroup):
            for k in SOgroup.keys():
                if k not in dup.keys():
                    if SOgroup.getattr(k).beadtype not in beadlist:
                        dup.setattr(k,SOgroup.getattr(k))
                        beadlist.append(SOgroup.getattr(k).beadtype)
                    else:
                        raise ValueError(&#39;%s (beadtype=%d) is already in use, same beadtype&#39; \
                                         % (k,SOgroup.getattr(k).beadtype))
                else:
                    raise ValueError(&#39;the object &#34;%s&#34; is already in the list&#39; % k)
            return dup
        else:
            raise ValueError(&#34;the argument #%d is not a script object or a script object group&#34;)

    def __or__(self, pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        if isinstance(pipe,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self) | pipe
        else:
            raise ValueError(&#34;the argument must a pipescript, a scriptobject or a scriptobjectgroup&#34;)

    @property
    def list(self):
        &#34;&#34;&#34; convert into a list &#34;&#34;&#34;
        return sorted(self)

    @property
    def zip(self):
        &#34;&#34;&#34; zip beadtypes and names &#34;&#34;&#34;
        return sorted( \
            [(self.getattr(k).beadtype,self.getattr(k).name,self.getattr(k).group,self.getattr(k).filename) \
            for k in self.keys()])

    @property
    def n(self):
        &#34;&#34;&#34; returns the number of bead types &#34;&#34;&#34;
        return len(self)

    @property
    def beadtype(self):
        &#34;&#34;&#34; returns the beads in the group &#34;&#34;&#34;
        return [x for x,_,_,_ in self.zip]

    @property
    def name(self):
        &#34;&#34;&#34; &#34;return the list of names &#34;&#34;&#34;
        return [x for _,x,_,_ in self.zip]

    @property
    def groupname(self):
        &#34;&#34;&#34; &#34;return the list of groupnames &#34;&#34;&#34;
        grp = []
        for _,_,glist,_ in self.zip:
            for g in glist:
                if g not in grp: grp.append(g)
        return grp

    @property
    def filename(self):
        &#34;&#34;&#34; &#34;return the list of names as a dictionary &#34;&#34;&#34;
        files = {}
        for _,n,_,fn in self.zip:
            if fn != &#34;&#34;:
                if fn not in files:
                    files[fn] = [n]
                else:
                    files[fn].append(n)
        return files

    @property
    def str(self):
        return span(self.beadtype)

    def struct(self,groupid=1,groupidname=&#34;undef&#34;):
        &#34;&#34;&#34; create a group with name &#34;&#34;&#34;
        return struct(
                groupid = groupid,
            groupidname = groupidname,
              groupname = self.groupname, # meaning is synonyms
               beadtype = self.beadtype,
                   name = self.name,
                    str = &#34;group %s %s&#34; % (groupidname, span(self.beadtype))
               )

    @property
    def minmax(self):
        &#34;&#34;&#34; returns the min,max of beadtype &#34;&#34;&#34;
        return self.min,self.max

    @property
    def min(self):
        &#34;&#34;&#34; returns the min of beadtype &#34;&#34;&#34;
        return min(self.beadtype)

    @property
    def max(self):
        &#34;&#34;&#34; returns the max of beadtype &#34;&#34;&#34;
        return max(self.beadtype)

    def select(self,beadtype=None):
        &#34;&#34;&#34; select bead from a keep beadlist &#34;&#34;&#34;
        if beadtype==None: beadtype = list(range(self.min,self.max+1))
        if not isinstance(beadtype,(list,tuple)): beadtype = [beadtype]
        dup = scriptobjectgroup()
        for b,n,_,_ in self.zip:
            if b in beadtype:
                dup = dup + self.getattr(n)
                dup.getattr(n).USER = self.getattr(n).USER
                dup.getattr(n).forcefield = self.getattr(n).forcefield
        return dup

    @property
    def group(self):
        &#34;&#34;&#34; build groups from group (groupname contains synonyms) &#34;&#34;&#34;
        groupdef = struct()
        gid = 0
        bng = self.zip
        for g in self.groupname:
            gid +=1
            b =[x for x,_,gx,_ in bng if g in gx]
            groupdef.setattr(g,self.select(b).struct(groupid = gid, groupidname = g))
        return groupdef

    @CallableScript
    def interactions(self, printflag=False, verbosity=2, verbose=None):
        &#34;&#34;&#34; update and accumulate all forcefields &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        FF = []
        for b in self.beadtype:
            selection = deepduplicate(self.select(b)[0])
            selection.forcefield.beadtype = selection.beadtype
            selection.forcefield.userid = selection.name
            FF.append(selection.forcefield)
        # initialize interactions with pair_style
        TEMPLATE = &#34;\n# ===== [ BEGIN FORCEFIELD SECTION ] &#34;+&#34;=&#34;*80 if verbosity&gt;0 else &#34;&#34;
        TEMPLATE = FF[0].pair_style(verbose=verbosity&gt;0)
        # pair diagonal terms
        for i in range(len(FF)):
            TEMPLATE += FF[i].pair_diagcoeff(verbose=verbosity&gt;0)
        # pair off-diagonal terms
        for j in range(1,len(FF)):
            for i in range(0,j):
                TEMPLATE += FF[i].pair_offdiagcoeff(o=FF[j],verbose=verbosity&gt;0)
        # end
        TEMPLATE += &#34;\n# ===== [ END FORCEFIELD SECTION ] &#34;+&#34;=&#34;*82+&#34;\n&#34;  if verbosity&gt;0 else &#34;&#34;
        return FF,TEMPLATE

    @property
    def forcefield(self):
        &#34;&#34;&#34; interaction forcefields &#34;&#34;&#34;
        FF,_ = self.interactions
        return FF

    @CallableScript
    def script(self, printflag=False, verbosity=None, verbose=None):
        &#34;&#34;&#34;
            Generate a script based on the current collection of script objects

            Parameters:
            -----------
            printflag : bool, optional, default=False
                If True, prints the generated script.
            verbosity (int, optional): Controls the level of detail in the generated script.
                - 0: Minimal output, no comments.
                - 1: Basic comments for run steps.
                - 2: Detailed comments with additional information.
                Default is 2

            Returns:
            --------
            script
                The generated script describing the interactions between script objects.
        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if verbose is False else verbosity
        TEMPFILES = &#34;&#34;
        isfirst = True
        files_added = False
        if self.filename:
            for fn, cfn in self.filename.items():
                if fn and cfn:
                    if not files_added:
                        files_added = True
                        TEMPFILES += &#34;\n# ===== [ BEGIN INPUT FILES SECTION ] &#34; + &#34;=&#34; * 79 + &#34;\n&#34; if verbosity&gt;0 else &#34;&#34;
                    TEMPFILES += span(cfn, sep=&#34;, &#34;, left=&#34;\n# load files for objects: &#34;, right=&#34;\n&#34;) if verbosity&gt;1 else &#34;&#34;
                    if isfirst:
                        isfirst = False
                        TEMPFILES += f&#34;\tread_data {fn}\n&#34;  # First file, no append
                    else:
                        TEMPFILES += f&#34;\tread_data {fn} add append\n&#34;  # Subsequent files, append
        # define groups
        TEMPGRP = &#34;\n# ===== [ BEGIN GROUP SECTION ] &#34;+&#34;=&#34;*85 + &#34;\n&#34; if verbosity&gt;0 else &#34;&#34;
        for g in self.group:
            TEMPGRP += f&#39;\n\t#\tDefinition of group {g.groupid}:{g.groupidname}\n&#39; if verbosity&gt;1 else &#34;&#34;
            TEMPGRP += f&#39;\t#\t={span(g.name,sep=&#34;, &#34;)}\n&#39; if verbosity&gt;1 else &#34;&#34;
            TEMPGRP += f&#39;\t#\tSimilar groups: {span(g.groupname,sep=&#34;, &#34;)}\n&#39; if verbosity&gt;1 else &#34;&#34;
            TEMPGRP += f&#39;\tgroup \t {g.groupidname} \ttype \t {span(g.beadtype)}\n&#39;
        TEMPGRP += &#34;\n# ===== [ END GROUP SECTION ] &#34;+&#34;=&#34;*87+&#34;\n\n&#34; if verbosity&gt;0 else &#34;&#34;
        # define interactions
        _,TEMPFF = self.interactions(printflag=printflag, verbosity=verbosity)
        # chain strings into a script
        tscript = script(printflag=False,verbose=verbosity&gt;1)
        tscript.name = &#34;scriptobject script&#34;        # name
        tscript.description = str(self)             # description
        tscript.userid = &#34;scriptobject&#34;             # user name
        tscript.TEMPLATE = TEMPFILES+TEMPGRP+TEMPFF
        if verbosity==0:
            tscript.TEMPLATE = remove_comments(tscript.TEMPLATE)
        if printflag:
            repr(tscript)
        return tscript

    def group_generator(self, name=None):
        &#34;&#34;&#34;
        Generate and return a group object.

        This method creates a new `group` object, optionally with a specified name.
        If no name is provided, it generates a default name based on the current
        instance&#39;s `name` attribute, formatted with the `span` function. The method
        then iterates through the existing groups in `self.group`, adding each group
        to the new `group` object based on its `groupidname` and `beadtype`.

        Parameters:
        -----------
        name : str, optional
            The name for the generated group object. If not provided, a default name
            is generated based on the current instance&#39;s `name`.

        Returns:
        --------
        group
            A newly created `group` object with criteria set based on the existing groups.
        &#34;&#34;&#34;
        from pizza.group import group
        # Use the provided name or generate a default name using the span function
        G = group(name=name if name is not None else span(self.name, &#34;,&#34;, &#34;[&#34;, &#34;]&#34;))
        # Add criteria for each group in self.group
        for g in self.group:
            G.add_group_criteria(g.groupidname, type=g.beadtype)
        return G


    def mass(self, name=None, default_mass=&#34;${mass}&#34;, printflag=False, verbosity=2, verbose=True):
        &#34;&#34;&#34;
        Generates LAMMPS mass commands for each unique beadtype in the collection.

        The method iterates through all `scriptobjectgroup` instances in the collection,
        collects unique beadtypes, and ensures that each beadtype has a consistent mass.
        If a beadtype has `mass=None`, it assigns a default mass as specified by `default_mass`.

        ### Parameters:
            name (str, optional):
                The name to assign to the resulting `script` object. Defaults to a generated name.
            default_mass (str, int, or float, optional):
                The default mass value to assign when a beadtype&#39;s mass is `None`.
                Can be a string, integer, or floating-point value. Defaults to `&#34;${mass}&#34;`.
            printflag (bool, optional):
                If `True`, prints the representation of the resulting `script` object. Defaults to `False`.
            verbosity (int, optional):
                The verbosity level for logging or debugging. Higher values indicate more detailed output.
                Defaults to `2`.
            verbose (bool, optional):
                If `True`, includes a comment header in the output. Overrides `verbosity` when `False`.
                Defaults to `True`.

        ### Returns:
            script: A `script` object containing the mass commands for each beadtype, formatted as follows:
                     ```
                     mass 1 1.0
                     mass 2 ${mass}
                     mass 3 2.5
                     ```
                     The `TEMPLATE` attribute of the `script` object holds the formatted mass commands as a single string.

        ### Raises:
            ValueError: If a beadtype has inconsistent mass values across different `scriptobjectgroup` instances.

        ### Example:
            ```python
            # Create scriptobjectgroup instances
            obj1 = scriptobjectgroup(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
            obj2 = scriptobjectgroup(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
            obj3 = scriptobjectgroup(beadtype=3, group=&#34;C&#34;, mass=2.5)

            # Initialize a script group with the scriptobjectgroup instances
            G = scriptobjectgroup([obj1, obj2, obj3])

            # Generate mass commands
            M = G.mass()
            print(M.do())
            ```

            **Output:**
            ```
            # &lt;script:group:mass&gt; definitions for 3 beads
            mass 1 1.0
            mass 2 ${mass}
            mass 3 2.5
            ```
        &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        beadtype_mass = {}
        for iobj in range(0,len(self)):
            obj = self[iobj]
            bt = obj.beadtype
            mass = obj.mass if obj.mass is not None else default_mass
            if bt in beadtype_mass:
                if beadtype_mass[bt] != mass:
                    raise ValueError(
                        f&#34;Inconsistent masses for beadtype {bt}: {beadtype_mass[bt]} vs {mass}&#34;
                    )
            else:
                beadtype_mass[bt] = mass
        # Sort beadtypes for consistent ordering
        sorted_beadtypes = sorted(beadtype_mass.keys())
        # Generate mass commands
        lines = [f&#34;mass {bt} {beadtype_mass[bt]}&#34; for bt in sorted_beadtypes]
        # return a script object
        nameid = f&#34;&lt;script:group:{self.name}:mass&gt;&#34;
        description = f&#34;{nameid} definitions for {len(self)} beads&#34;
        if verbose:
            lines.insert(0, &#34;# &#34;+description)
        mscript = script(printflag=False,verbose=verbosity&gt;1)
        mscript.name = nameid if name is None else name
        mscript.description = description
        mscript.userid = &#34;scriptobject&#34;             # user name
        mscript.TEMPLATE = &#34;\n&#34;.join(lines)
        mscript.DEFINITIONS.mass = default_mass
        if printflag:
            repr(mscript)
        return mscript</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="dscript.scriptobjectgroup.beadtype"><code class="name">var <span class="ident">beadtype</span></code></dt>
<dd>
<div class="desc"><p>returns the beads in the group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beadtype(self):
    &#34;&#34;&#34; returns the beads in the group &#34;&#34;&#34;
    return [x for x,_,_,_ in self.zip]</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.filename"><code class="name">var <span class="ident">filename</span></code></dt>
<dd>
<div class="desc"><p>"return the list of names as a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def filename(self):
    &#34;&#34;&#34; &#34;return the list of names as a dictionary &#34;&#34;&#34;
    files = {}
    for _,n,_,fn in self.zip:
        if fn != &#34;&#34;:
            if fn not in files:
                files[fn] = [n]
            else:
                files[fn].append(n)
    return files</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.forcefield"><code class="name">var <span class="ident">forcefield</span></code></dt>
<dd>
<div class="desc"><p>interaction forcefields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def forcefield(self):
    &#34;&#34;&#34; interaction forcefields &#34;&#34;&#34;
    FF,_ = self.interactions
    return FF</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.group"><code class="name">var <span class="ident">group</span></code></dt>
<dd>
<div class="desc"><p>build groups from group (groupname contains synonyms)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def group(self):
    &#34;&#34;&#34; build groups from group (groupname contains synonyms) &#34;&#34;&#34;
    groupdef = struct()
    gid = 0
    bng = self.zip
    for g in self.groupname:
        gid +=1
        b =[x for x,_,gx,_ in bng if g in gx]
        groupdef.setattr(g,self.select(b).struct(groupid = gid, groupidname = g))
    return groupdef</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.groupname"><code class="name">var <span class="ident">groupname</span></code></dt>
<dd>
<div class="desc"><p>"return the list of groupnames</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def groupname(self):
    &#34;&#34;&#34; &#34;return the list of groupnames &#34;&#34;&#34;
    grp = []
    for _,_,glist,_ in self.zip:
        for g in glist:
            if g not in grp: grp.append(g)
    return grp</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.list"><code class="name">var <span class="ident">list</span></code></dt>
<dd>
<div class="desc"><p>convert into a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def list(self):
    &#34;&#34;&#34; convert into a list &#34;&#34;&#34;
    return sorted(self)</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.max"><code class="name">var <span class="ident">max</span></code></dt>
<dd>
<div class="desc"><p>returns the max of beadtype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max(self):
    &#34;&#34;&#34; returns the max of beadtype &#34;&#34;&#34;
    return max(self.beadtype)</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.min"><code class="name">var <span class="ident">min</span></code></dt>
<dd>
<div class="desc"><p>returns the min of beadtype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min(self):
    &#34;&#34;&#34; returns the min of beadtype &#34;&#34;&#34;
    return min(self.beadtype)</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.minmax"><code class="name">var <span class="ident">minmax</span></code></dt>
<dd>
<div class="desc"><p>returns the min,max of beadtype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def minmax(self):
    &#34;&#34;&#34; returns the min,max of beadtype &#34;&#34;&#34;
    return self.min,self.max</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>returns the number of bead types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34; returns the number of bead types &#34;&#34;&#34;
    return len(self)</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>"return the list of names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34; &#34;return the list of names &#34;&#34;&#34;
    return [x for _,x,_,_ in self.zip]</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.str"><code class="name">var <span class="ident">str</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def str(self):
    return span(self.beadtype)</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.zip"><code class="name">var <span class="ident">zip</span></code></dt>
<dd>
<div class="desc"><p>zip beadtypes and names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zip(self):
    &#34;&#34;&#34; zip beadtypes and names &#34;&#34;&#34;
    return sorted( \
        [(self.getattr(k).beadtype,self.getattr(k).name,self.getattr(k).group,self.getattr(k).filename) \
        for k in self.keys()])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dscript.scriptobjectgroup.group_generator"><code class="name flex">
<span>def <span class="ident">group_generator</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return a group object.</p>
<p>This method creates a new <code>group</code> object, optionally with a specified name.
If no name is provided, it generates a default name based on the current
instance's <code>name</code> attribute, formatted with the <code><a title="dscript.span" href="#dscript.span">span()</a></code> function. The method
then iterates through the existing groups in <code>self.group</code>, adding each group
to the new <code>group</code> object based on its <code>groupidname</code> and <code>beadtype</code>.</p>
<h2 id="parameters">Parameters:</h2>
<p>name : str, optional
The name for the generated group object. If not provided, a default name
is generated based on the current instance's <code>name</code>.</p>
<h2 id="returns">Returns:</h2>
<p>group
A newly created <code>group</code> object with criteria set based on the existing groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_generator(self, name=None):
    &#34;&#34;&#34;
    Generate and return a group object.

    This method creates a new `group` object, optionally with a specified name.
    If no name is provided, it generates a default name based on the current
    instance&#39;s `name` attribute, formatted with the `span` function. The method
    then iterates through the existing groups in `self.group`, adding each group
    to the new `group` object based on its `groupidname` and `beadtype`.

    Parameters:
    -----------
    name : str, optional
        The name for the generated group object. If not provided, a default name
        is generated based on the current instance&#39;s `name`.

    Returns:
    --------
    group
        A newly created `group` object with criteria set based on the existing groups.
    &#34;&#34;&#34;
    from pizza.group import group
    # Use the provided name or generate a default name using the span function
    G = group(name=name if name is not None else span(self.name, &#34;,&#34;, &#34;[&#34;, &#34;]&#34;))
    # Add criteria for each group in self.group
    for g in self.group:
        G.add_group_criteria(g.groupidname, type=g.beadtype)
    return G</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.interactions"><code class="name flex">
<span>def <span class="ident">interactions</span></span>(<span>printflag=False, verbosity=2, verbose=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">return lambda printflag=False, verbosity=2, verbose=None: self.func(instance, printflag=printflag, verbosity=verbosity, verbose=verbose)</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.mass"><code class="name flex">
<span>def <span class="ident">mass</span></span>(<span>self, name=None, default_mass='${mass}', printflag=False, verbosity=2, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates LAMMPS mass commands for each unique beadtype in the collection.</p>
<p>The method iterates through all <code><a title="dscript.scriptobjectgroup" href="#dscript.scriptobjectgroup">scriptobjectgroup</a></code> instances in the collection,
collects unique beadtypes, and ensures that each beadtype has a consistent mass.
If a beadtype has <code>mass=None</code>, it assigns a default mass as specified by <code>default_mass</code>.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>name (str, optional):
    The name to assign to the resulting &lt;code&gt;&lt;a title="dscript.script" href="#dscript.script"&gt;script&lt;/a&gt;&lt;/code&gt; object. Defaults to a generated name.
default_mass (str, int, or float, optional):
    The default mass value to assign when a beadtype's mass is &lt;code&gt;None&lt;/code&gt;.
    Can be a string, integer, or floating-point value. Defaults to `"${mass}"`.
printflag (bool, optional):
    If &lt;code&gt;True&lt;/code&gt;, prints the representation of the resulting &lt;code&gt;&lt;a title="dscript.script" href="#dscript.script"&gt;script&lt;/a&gt;&lt;/code&gt; object. Defaults to &lt;code&gt;False&lt;/code&gt;.
verbosity (int, optional):
    The verbosity level for logging or debugging. Higher values indicate more detailed output.
    Defaults to &lt;code&gt;2&lt;/code&gt;.
verbose (bool, optional):
    If &lt;code&gt;True&lt;/code&gt;, includes a comment header in the output. Overrides &lt;code&gt;verbosity&lt;/code&gt; when &lt;code&gt;False&lt;/code&gt;.
    Defaults to &lt;code&gt;True&lt;/code&gt;.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>script: A &lt;code&gt;&lt;a title="dscript.script" href="#dscript.script"&gt;script&lt;/a&gt;&lt;/code&gt; object containing the mass commands for each beadtype, formatted as follows:
         ```
         mass 1 1.0
         mass 2 ${mass}
         mass 3 2.5
         ```
         The &lt;code&gt;TEMPLATE&lt;/code&gt; attribute of the &lt;code&gt;&lt;a title="dscript.script" href="#dscript.script"&gt;script&lt;/a&gt;&lt;/code&gt; object holds the formatted mass commands as a single string.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>ValueError: If a beadtype has inconsistent mass values across different &lt;code&gt;&lt;a title="dscript.scriptobjectgroup" href="#dscript.scriptobjectgroup"&gt;scriptobjectgroup&lt;/a&gt;&lt;/code&gt; instances.
</code></pre>
<h3 id="example">Example:</h3>
<pre><code>```python
# Create scriptobjectgroup instances
obj1 = scriptobjectgroup(beadtype=1, group=["all", "A"], mass=1.0)
obj2 = scriptobjectgroup(beadtype=2, group=["all", "B", "C"])
obj3 = scriptobjectgroup(beadtype=3, group="C", mass=2.5)

# Initialize a script group with the scriptobjectgroup instances
G = scriptobjectgroup([obj1, obj2, obj3])

# Generate mass commands
M = G.mass()
print(M.do())
```

**Output:**
```
# &lt;script:group:mass&gt; definitions for 3 beads
mass 1 1.0
mass 2 ${mass}
mass 3 2.5
```
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mass(self, name=None, default_mass=&#34;${mass}&#34;, printflag=False, verbosity=2, verbose=True):
    &#34;&#34;&#34;
    Generates LAMMPS mass commands for each unique beadtype in the collection.

    The method iterates through all `scriptobjectgroup` instances in the collection,
    collects unique beadtypes, and ensures that each beadtype has a consistent mass.
    If a beadtype has `mass=None`, it assigns a default mass as specified by `default_mass`.

    ### Parameters:
        name (str, optional):
            The name to assign to the resulting `script` object. Defaults to a generated name.
        default_mass (str, int, or float, optional):
            The default mass value to assign when a beadtype&#39;s mass is `None`.
            Can be a string, integer, or floating-point value. Defaults to `&#34;${mass}&#34;`.
        printflag (bool, optional):
            If `True`, prints the representation of the resulting `script` object. Defaults to `False`.
        verbosity (int, optional):
            The verbosity level for logging or debugging. Higher values indicate more detailed output.
            Defaults to `2`.
        verbose (bool, optional):
            If `True`, includes a comment header in the output. Overrides `verbosity` when `False`.
            Defaults to `True`.

    ### Returns:
        script: A `script` object containing the mass commands for each beadtype, formatted as follows:
                 ```
                 mass 1 1.0
                 mass 2 ${mass}
                 mass 3 2.5
                 ```
                 The `TEMPLATE` attribute of the `script` object holds the formatted mass commands as a single string.

    ### Raises:
        ValueError: If a beadtype has inconsistent mass values across different `scriptobjectgroup` instances.

    ### Example:
        ```python
        # Create scriptobjectgroup instances
        obj1 = scriptobjectgroup(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
        obj2 = scriptobjectgroup(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
        obj3 = scriptobjectgroup(beadtype=3, group=&#34;C&#34;, mass=2.5)

        # Initialize a script group with the scriptobjectgroup instances
        G = scriptobjectgroup([obj1, obj2, obj3])

        # Generate mass commands
        M = G.mass()
        print(M.do())
        ```

        **Output:**
        ```
        # &lt;script:group:mass&gt; definitions for 3 beads
        mass 1 1.0
        mass 2 ${mass}
        mass 3 2.5
        ```
    &#34;&#34;&#34;
    verbosity = 0 if verbose is False else verbosity
    beadtype_mass = {}
    for iobj in range(0,len(self)):
        obj = self[iobj]
        bt = obj.beadtype
        mass = obj.mass if obj.mass is not None else default_mass
        if bt in beadtype_mass:
            if beadtype_mass[bt] != mass:
                raise ValueError(
                    f&#34;Inconsistent masses for beadtype {bt}: {beadtype_mass[bt]} vs {mass}&#34;
                )
        else:
            beadtype_mass[bt] = mass
    # Sort beadtypes for consistent ordering
    sorted_beadtypes = sorted(beadtype_mass.keys())
    # Generate mass commands
    lines = [f&#34;mass {bt} {beadtype_mass[bt]}&#34; for bt in sorted_beadtypes]
    # return a script object
    nameid = f&#34;&lt;script:group:{self.name}:mass&gt;&#34;
    description = f&#34;{nameid} definitions for {len(self)} beads&#34;
    if verbose:
        lines.insert(0, &#34;# &#34;+description)
    mscript = script(printflag=False,verbose=verbosity&gt;1)
    mscript.name = nameid if name is None else name
    mscript.description = description
    mscript.userid = &#34;scriptobject&#34;             # user name
    mscript.TEMPLATE = &#34;\n&#34;.join(lines)
    mscript.DEFINITIONS.mass = default_mass
    if printflag:
        repr(mscript)
    return mscript</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>printflag=False, verbosity=2, verbose=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">return lambda printflag=False, verbosity=2, verbose=None: self.func(instance, printflag=printflag, verbosity=verbosity, verbose=verbose)</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, beadtype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>select bead from a keep beadlist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self,beadtype=None):
    &#34;&#34;&#34; select bead from a keep beadlist &#34;&#34;&#34;
    if beadtype==None: beadtype = list(range(self.min,self.max+1))
    if not isinstance(beadtype,(list,tuple)): beadtype = [beadtype]
    dup = scriptobjectgroup()
    for b,n,_,_ in self.zip:
        if b in beadtype:
            dup = dup + self.getattr(n)
            dup.getattr(n).USER = self.getattr(n).USER
            dup.getattr(n).forcefield = self.getattr(n).forcefield
    return dup</code></pre>
</details>
</dd>
<dt id="dscript.scriptobjectgroup.struct"><code class="name flex">
<span>def <span class="ident">struct</span></span>(<span>self, groupid=1, groupidname='undef')</span>
</code></dt>
<dd>
<div class="desc"><p>create a group with name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct(self,groupid=1,groupidname=&#34;undef&#34;):
    &#34;&#34;&#34; create a group with name &#34;&#34;&#34;
    return struct(
            groupid = groupid,
        groupidname = groupidname,
          groupname = self.groupname, # meaning is synonyms
           beadtype = self.beadtype,
               name = self.name,
                str = &#34;group %s %s&#34; % (groupidname, span(self.beadtype))
           )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#overview">Overview:</a></li>
<li><a href="#update-pizza-10">UPDATE Pizza 1.0</a></li>
<li><a href="#key-features">Key Features:</a></li>
<li><a href="#applications">Applications:</a></li>
<li><a href="#key-classes">Key Classes:</a></li>
<li><a href="#notes">Notes:</a></li>
<li><a href="#important-distinction-between-pizzadscript-and-pizzascript-with-possible-evolution-in-the-future">Important Distinction between PIZZA.DSCRIPT and PIZZA.SCRIPT: (with possible evolution in the future)</a></li>
<li><a href="#practical-usage">Practical Usage:</a></li>
<li><a href="#dscript-save-file-format-instructions">DSCRIPT SAVE FILE Format Instructions:</a><ul>
<li><a href="#printreprmydscript-1-gives-all-details">print(repr(mydscript[-1])) gives all details</a></li>
<li><a href="#template-content-id23-1-line-31-defs-all-variables-have-be-created-also-locally">Template Content | id:23
(1 line, 31 defs)
&lt;&mdash; all variables have be created also locally</a></li>
<li><a href="#run-runtime">run ${runtime}</a></li>
<li><a href="#detected-variable-1-1-0">Detected Variable
(1 / +1 / -0)</a></li>
<li><a href="#runtime-this-runtime-is-a-variable">[+] runtime
&lt;&mdash; this runtime is a variable</a></li>
<li><a href="#template-attributes-7-attributes">Template Attributes
(7 attributes)</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#license">License</a></li>
<li><a href="#contact">Contact</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dscript.autoname" href="#dscript.autoname">autoname</a></code></li>
<li><code><a title="dscript.frame_header" href="#dscript.frame_header">frame_header</a></code></li>
<li><code><a title="dscript.get_metadata" href="#dscript.get_metadata">get_metadata</a></code></li>
<li><code><a title="dscript.remove_comments" href="#dscript.remove_comments">remove_comments</a></code></li>
<li><code><a title="dscript.span" href="#dscript.span">span</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dscript.ScriptTemplate" href="#dscript.ScriptTemplate">ScriptTemplate</a></code></h4>
<ul class="">
<li><code><a title="dscript.ScriptTemplate.check_variables" href="#dscript.ScriptTemplate.check_variables">check_variables</a></code></li>
<li><code><a title="dscript.ScriptTemplate.content" href="#dscript.ScriptTemplate.content">content</a></code></li>
<li><code><a title="dscript.ScriptTemplate.default_attributes" href="#dscript.ScriptTemplate.default_attributes">default_attributes</a></code></li>
<li><code><a title="dscript.ScriptTemplate.detect_variables" href="#dscript.ScriptTemplate.detect_variables">detect_variables</a></code></li>
<li><code><a title="dscript.ScriptTemplate.do" href="#dscript.ScriptTemplate.do">do</a></code></li>
<li><code><a title="dscript.ScriptTemplate.is_variable_defined" href="#dscript.ScriptTemplate.is_variable_defined">is_variable_defined</a></code></li>
<li><code><a title="dscript.ScriptTemplate.is_variable_set_value_only" href="#dscript.ScriptTemplate.is_variable_set_value_only">is_variable_set_value_only</a></code></li>
<li><code><a title="dscript.ScriptTemplate.parse_content" href="#dscript.ScriptTemplate.parse_content">parse_content</a></code></li>
<li><code><a title="dscript.ScriptTemplate.refreshvar" href="#dscript.ScriptTemplate.refreshvar">refreshvar</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dscript.VariableOccurrences" href="#dscript.VariableOccurrences">VariableOccurrences</a></code></h4>
<ul class="">
<li><code><a title="dscript.VariableOccurrences.export" href="#dscript.VariableOccurrences.export">export</a></code></li>
<li><code><a title="dscript.VariableOccurrences.get_all_elements_in_lists" href="#dscript.VariableOccurrences.get_all_elements_in_lists">get_all_elements_in_lists</a></code></li>
<li><code><a title="dscript.VariableOccurrences.get_all_values" href="#dscript.VariableOccurrences.get_all_values">get_all_values</a></code></li>
<li><code><a title="dscript.VariableOccurrences.get_raw_data" href="#dscript.VariableOccurrences.get_raw_data">get_raw_data</a></code></li>
<li><code><a title="dscript.VariableOccurrences.get_steps_with_value" href="#dscript.VariableOccurrences.get_steps_with_value">get_steps_with_value</a></code></li>
<li><code><a title="dscript.VariableOccurrences.get_steps_with_value_in_scope" href="#dscript.VariableOccurrences.get_steps_with_value_in_scope">get_steps_with_value_in_scope</a></code></li>
<li><code><a title="dscript.VariableOccurrences.get_usage_count" href="#dscript.VariableOccurrences.get_usage_count">get_usage_count</a></code></li>
<li><code><a title="dscript.VariableOccurrences.summarize" href="#dscript.VariableOccurrences.summarize">summarize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dscript.dscript" href="#dscript.dscript">dscript</a></code></h4>
<ul class="">
<li><code><a title="dscript.dscript.add_dynamic_script" href="#dscript.dscript.add_dynamic_script">add_dynamic_script</a></code></li>
<li><code><a title="dscript.dscript.check_all_variables" href="#dscript.dscript.check_all_variables">check_all_variables</a></code></li>
<li><code><a title="dscript.dscript.clean" href="#dscript.dscript.clean">clean</a></code></li>
<li><code><a title="dscript.dscript.construction_attributes" href="#dscript.dscript.construction_attributes">construction_attributes</a></code></li>
<li><code><a title="dscript.dscript.createEmptyVariables" href="#dscript.dscript.createEmptyVariables">createEmptyVariables</a></code></li>
<li><code><a title="dscript.dscript.detect_all_variables" href="#dscript.dscript.detect_all_variables">detect_all_variables</a></code></li>
<li><code><a title="dscript.dscript.do" href="#dscript.dscript.do">do</a></code></li>
<li><code><a title="dscript.dscript.flattenvariables" href="#dscript.dscript.flattenvariables">flattenvariables</a></code></li>
<li><code><a title="dscript.dscript.generator" href="#dscript.dscript.generator">generator</a></code></li>
<li><code><a title="dscript.dscript.get_attributes_by_index" href="#dscript.dscript.get_attributes_by_index">get_attributes_by_index</a></code></li>
<li><code><a title="dscript.dscript.get_content_by_index" href="#dscript.dscript.get_content_by_index">get_content_by_index</a></code></li>
<li><code><a title="dscript.dscript.header" href="#dscript.dscript.header">header</a></code></li>
<li><code><a title="dscript.dscript.items" href="#dscript.dscript.items">items</a></code></li>
<li><code><a title="dscript.dscript.keys" href="#dscript.dscript.keys">keys</a></code></li>
<li><code><a title="dscript.dscript.list_values" href="#dscript.dscript.list_values">list_values</a></code></li>
<li><code><a title="dscript.dscript.load" href="#dscript.dscript.load">load</a></code></li>
<li><code><a title="dscript.dscript.parsesyntax" href="#dscript.dscript.parsesyntax">parsesyntax</a></code></li>
<li><code><a title="dscript.dscript.parsesyntax_legacy" href="#dscript.dscript.parsesyntax_legacy">parsesyntax_legacy</a></code></li>
<li><code><a title="dscript.dscript.pipescript" href="#dscript.dscript.pipescript">pipescript</a></code></li>
<li><code><a title="dscript.dscript.print_var_info" href="#dscript.dscript.print_var_info">print_var_info</a></code></li>
<li><code><a title="dscript.dscript.reorder" href="#dscript.dscript.reorder">reorder</a></code></li>
<li><code><a title="dscript.dscript.save" href="#dscript.dscript.save">save</a></code></li>
<li><code><a title="dscript.dscript.script" href="#dscript.dscript.script">script</a></code></li>
<li><code><a title="dscript.dscript.search" href="#dscript.dscript.search">search</a></code></li>
<li><code><a title="dscript.dscript.set_all_variables" href="#dscript.dscript.set_all_variables">set_all_variables</a></code></li>
<li><code><a title="dscript.dscript.values" href="#dscript.dscript.values">values</a></code></li>
<li><code><a title="dscript.dscript.var_info" href="#dscript.dscript.var_info">var_info</a></code></li>
<li><code><a title="dscript.dscript.write" href="#dscript.dscript.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dscript.lambdaScriptdata" href="#dscript.lambdaScriptdata">lambdaScriptdata</a></code></h4>
</li>
<li>
<h4><code><a title="dscript.lamdaScript" href="#dscript.lamdaScript">lamdaScript</a></code></h4>
<ul class="">
<li><code><a title="dscript.lamdaScript.name" href="#dscript.lamdaScript.name">name</a></code></li>
<li><code><a title="dscript.lamdaScript.role" href="#dscript.lamdaScript.role">role</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dscript.paramauto" href="#dscript.paramauto">paramauto</a></code></h4>
</li>
<li>
<h4><code><a title="dscript.pipescript" href="#dscript.pipescript">pipescript</a></code></h4>
<ul class="">
<li><code><a title="dscript.pipescript.USER" href="#dscript.pipescript.USER">USER</a></code></li>
<li><code><a title="dscript.pipescript.clear" href="#dscript.pipescript.clear">clear</a></code></li>
<li><code><a title="dscript.pipescript.do" href="#dscript.pipescript.do">do</a></code></li>
<li><code><a title="dscript.pipescript.do_legacy" href="#dscript.pipescript.do_legacy">do_legacy</a></code></li>
<li><code><a title="dscript.pipescript.dscript" href="#dscript.pipescript.dscript">dscript</a></code></li>
<li><code><a title="dscript.pipescript.generate_report" href="#dscript.pipescript.generate_report">generate_report</a></code></li>
<li><code><a title="dscript.pipescript.getUSER" href="#dscript.pipescript.getUSER">getUSER</a></code></li>
<li><code><a title="dscript.pipescript.header" href="#dscript.pipescript.header">header</a></code></li>
<li><code><a title="dscript.pipescript.join" href="#dscript.pipescript.join">join</a></code></li>
<li><code><a title="dscript.pipescript.list_multiple_values" href="#dscript.pipescript.list_multiple_values">list_multiple_values</a></code></li>
<li><code><a title="dscript.pipescript.list_values" href="#dscript.pipescript.list_values">list_values</a></code></li>
<li><code><a title="dscript.pipescript.n" href="#dscript.pipescript.n">n</a></code></li>
<li><code><a title="dscript.pipescript.nrun" href="#dscript.pipescript.nrun">nrun</a></code></li>
<li><code><a title="dscript.pipescript.plot_multiple_value_distributions" href="#dscript.pipescript.plot_multiple_value_distributions">plot_multiple_value_distributions</a></code></li>
<li><code><a title="dscript.pipescript.rename" href="#dscript.pipescript.rename">rename</a></code></li>
<li><code><a title="dscript.pipescript.script" href="#dscript.pipescript.script">script</a></code></li>
<li><code><a title="dscript.pipescript.scripts" href="#dscript.pipescript.scripts">scripts</a></code></li>
<li><code><a title="dscript.pipescript.setUSER" href="#dscript.pipescript.setUSER">setUSER</a></code></li>
<li><code><a title="dscript.pipescript.write" href="#dscript.pipescript.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dscript.script" href="#dscript.script">script</a></code></h4>
<ul class="two-column">
<li><code><a title="dscript.script.DEFINITIONS" href="#dscript.script.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="dscript.script.SECTIONS" href="#dscript.script.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="dscript.script.TEMPLATE" href="#dscript.script.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="dscript.script.description" href="#dscript.script.description">description</a></code></li>
<li><code><a title="dscript.script.detect_variables" href="#dscript.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="dscript.script.do" href="#dscript.script.do">do</a></code></li>
<li><code><a title="dscript.script.email" href="#dscript.script.email">email</a></code></li>
<li><code><a title="dscript.script.getallattributes" href="#dscript.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="dscript.script.header" href="#dscript.script.header">header</a></code></li>
<li><code><a title="dscript.script.license" href="#dscript.script.license">license</a></code></li>
<li><code><a title="dscript.script.metadata" href="#dscript.script.metadata">metadata</a></code></li>
<li><code><a title="dscript.script.name" href="#dscript.script.name">name</a></code></li>
<li><code><a title="dscript.script.position" href="#dscript.script.position">position</a></code></li>
<li><code><a title="dscript.script.printheader" href="#dscript.script.printheader">printheader</a></code></li>
<li><code><a title="dscript.script.role" href="#dscript.script.role">role</a></code></li>
<li><code><a title="dscript.script.section" href="#dscript.script.section">section</a></code></li>
<li><code><a title="dscript.script.tmpwrite" href="#dscript.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="dscript.script.type" href="#dscript.script.type">type</a></code></li>
<li><code><a title="dscript.script.userid" href="#dscript.script.userid">userid</a></code></li>
<li><code><a title="dscript.script.verbose" href="#dscript.script.verbose">verbose</a></code></li>
<li><code><a title="dscript.script.version" href="#dscript.script.version">version</a></code></li>
<li><code><a title="dscript.script.write" href="#dscript.script.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dscript.scriptdata" href="#dscript.scriptdata">scriptdata</a></code></h4>
</li>
<li>
<h4><code><a title="dscript.scriptobjectgroup" href="#dscript.scriptobjectgroup">scriptobjectgroup</a></code></h4>
<ul class="two-column">
<li><code><a title="dscript.scriptobjectgroup.beadtype" href="#dscript.scriptobjectgroup.beadtype">beadtype</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.filename" href="#dscript.scriptobjectgroup.filename">filename</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.forcefield" href="#dscript.scriptobjectgroup.forcefield">forcefield</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.group" href="#dscript.scriptobjectgroup.group">group</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.group_generator" href="#dscript.scriptobjectgroup.group_generator">group_generator</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.groupname" href="#dscript.scriptobjectgroup.groupname">groupname</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.interactions" href="#dscript.scriptobjectgroup.interactions">interactions</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.list" href="#dscript.scriptobjectgroup.list">list</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.mass" href="#dscript.scriptobjectgroup.mass">mass</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.max" href="#dscript.scriptobjectgroup.max">max</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.min" href="#dscript.scriptobjectgroup.min">min</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.minmax" href="#dscript.scriptobjectgroup.minmax">minmax</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.n" href="#dscript.scriptobjectgroup.n">n</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.name" href="#dscript.scriptobjectgroup.name">name</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.script" href="#dscript.scriptobjectgroup.script">script</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.select" href="#dscript.scriptobjectgroup.select">select</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.str" href="#dscript.scriptobjectgroup.str">str</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.struct" href="#dscript.scriptobjectgroup.struct">struct</a></code></li>
<li><code><a title="dscript.scriptobjectgroup.zip" href="#dscript.scriptobjectgroup.zip">zip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>