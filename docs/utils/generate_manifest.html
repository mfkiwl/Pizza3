<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>generate_manifest API documentation</title>
<meta name="description" content="Manifest Manager for Pizza3 Project â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>generate_manifest</code></h1>
</header>
<section id="section-intro">
<p>Manifest Manager for Pizza3 Project</p>
<p>===================================</p>
<p>The <code>manifestManager</code> module provides a robust interface for creating, synchronizing,
and validating manifests within the Pizza3 project. A manifest serves as an inventory
of project files, capturing essential metadata such as file paths, hashes, and sizes.
This facilitates efficient tracking of project changes, ensuring integrity and consistency
across different environments or versions.</p>
<h2 id="goals">Goals:</h2>
<ul>
<li><strong>Create Manifests:</strong> Generate comprehensive manifests that catalog all relevant project files.</li>
<li><strong>Diff Manifests:</strong> Compare local and source manifests to identify additions, modifications, or deletions.</li>
<li><strong>Update Manifests:</strong> Synchronize local project files with a source manifest, handling updates and ensuring integrity.</li>
<li><strong>Maintain Integrity:</strong> Utilize file hashing to verify the integrity of project files, detecting any unintended alterations.</li>
</ul>
<h2 id="usage">Usage:</h2>
<p>The module is designed to be executed as a standalone script, accepting various command-line
arguments to perform desired actions. It leverages the <code><a title="generate_manifest.FileEntity" href="#generate_manifest.FileEntity">FileEntity</a></code> class to represent individual
files and directories, capturing their metadata for manifest operations.</p>
<h2 id="example-commands">Example Commands:</h2>
<ul>
<li><strong>Create a Manifest:</strong></li>
</ul>
<p><code>bash
python3 manifestManager.py create -p /path/to/project -m project.manifest</code></p>
<ul>
<li><strong>Diff Two Manifests:</strong></li>
</ul>
<p><code>bash
python3 manifestManager.py diff -l /local/manifest/dir -s &lt;https://example.com/source/manifest&gt; --print</code></p>
<ul>
<li><strong>Update a Manifest:</strong></li>
</ul>
<p><code>bash
python3 manifestManager.py update -l /local/manifest/dir -s &lt;https://example.com/source/manifest&gt; --prompt</code></p>
<h2 id="dependencies">Dependencies:</h2>
<ul>
<li>Python 3.x</li>
<li>Standard Python libraries: <code>os</code>, <code>hashlib</code>, <code>urllib</code>, <code>shutil</code>, <code>errno</code>, <code>argparse</code>, <code>sys</code></li>
</ul>
<h2 id="author">Author:</h2>
<p>Michael Imelfort</p>
<h2 id="license">License:</h2>
<p>GPLv3</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
Manifest Manager for Pizza3 Project

===================================

The `manifestManager` module provides a robust interface for creating, synchronizing,
and validating manifests within the Pizza3 project. A manifest serves as an inventory
of project files, capturing essential metadata such as file paths, hashes, and sizes.
This facilitates efficient tracking of project changes, ensuring integrity and consistency
across different environments or versions.

Goals:
------
- **Create Manifests:** Generate comprehensive manifests that catalog all relevant project files.
- **Diff Manifests:** Compare local and source manifests to identify additions, modifications, or deletions.
- **Update Manifests:** Synchronize local project files with a source manifest, handling updates and ensuring integrity.
- **Maintain Integrity:** Utilize file hashing to verify the integrity of project files, detecting any unintended alterations.

Usage:
------
The module is designed to be executed as a standalone script, accepting various command-line
arguments to perform desired actions. It leverages the `FileEntity` class to represent individual
files and directories, capturing their metadata for manifest operations.

Example Commands:
-----------------
- **Create a Manifest:**
  
  ```bash
  python3 manifestManager.py create -p /path/to/project -m project.manifest
  ```

- **Diff Two Manifests:**
  
  ```bash
  python3 manifestManager.py diff -l /local/manifest/dir -s https://example.com/source/manifest --print
  ```

- **Update a Manifest:**
  
  ```bash
  python3 manifestManager.py update -l /local/manifest/dir -s https://example.com/source/manifest --prompt
  ```

Dependencies:
-------------
- Python 3.x
- Standard Python libraries: `os`, `hashlib`, `urllib`, `shutil`, `errno`, `argparse`, `sys`

Author:
-------
Michael Imelfort

License:
--------
GPLv3

&#34;&#34;&#34;

#!/usr/bin/env python3
###############################################################################
#                                                                             #
#    generate_manifest.py                                                     #
#                                                                             #
#    Work with online data manifests (creating / syncing / validating)        #
#                                                                             #
#    Copyright (C) Michael Imelfort                                           #
#                                                                             #
###############################################################################
#                                                                             #
#    This program is free software: you can redistribute it and/or modify     #
#    it under the terms of the GNU General Public License as published by     #
#    the Free Software Foundation, either version 3 of the License, or        #
#    (at your option) any later version.                                      #
#                                                                             #
#    This program is distributed in the hope that it will be useful,          #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
#    GNU General Public License for more details.                             #
#                                                                             #
#    You should have received a copy of the GNU General Public License        #
#    along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.     #
#                                                                             #
###############################################################################

__author__ = [&#34;Michael Imelfort&#34;,&#34;Olivier Vitrac&#34;]
__copyright__ = &#34;Copyright 2014&#34;
__credits__ = [&#34;Michael Imelfort&#34;]
__license__ = &#34;GPLv3&#34;
__version__ = &#34;0.35&#34;


###############################################################################
###############################################################################
###############################################################################
###############################################################################

# System includes
import os
import hashlib
import urllib.request, urllib.error, urllib.parse
import shutil
import errno
import argparse
import sys

###############################################################################
###############################################################################
###############################################################################
###############################################################################

class FileEntity(object):
    &#34;&#34;&#34;Represents a file or directory entity with associated metadata.&#34;&#34;&#34;
    
    def __init__(self,
                 name,      # Name of the entity
                 path,      # Relative path to the root directory
                 parent,    # Parent FileEntity object (None for root)
                 hashd,     # Hash of the file (None for directories)
                 size       # Size of the file in bytes (0 for directories)
                 ):
        &#34;&#34;&#34;
        Initializes a new instance of the FileEntity class.

        Args:
            name (str): The name of the entity on the file system.
            path (str): The relative path to the root directory.
            parent (FileEntity or None): The parent FileEntity object containing this entity.
                - `None` if the entity is the root.
            hashd (str): The SHA-256 hash of the file.
                - Set to `&#39;-&#39;` for directories.
            size (int): The size of the file in bytes.
                - Set to `0` for directories.
        &#34;&#34;&#34;
        self.name = name
        self.path = path
        self.parent = parent
        self.hashd = hashd
        self.size = size
        self.type = &#39;dir&#39; if self.hashd == &#39;-&#39; else &#39;file&#39;  # Determine type based on hashd

    def getFullPath(self):
        &#34;&#34;&#34;
        Retrieves the full path to this entity by concatenating parent paths.

        Returns:
            str: The absolute path to the entity.
                - For the root entity, returns its name.
                - For other entities, joins the parent&#39;s full path with its own name.
        &#34;&#34;&#34;
        if self.parent is None:
            return self.name  # Root entity
        else:
            return os.path.join(self.parent.getFullPath(), self.name)

    def checkIntegrity(self):
        &#34;&#34;&#34;
        Checks the integrity of the file by comparing its stored hash with a newly computed hash.

        For directories, integrity is assumed to be intact.

        Returns:
            bool: 
                - `True` if the entity is a directory or if the file&#39;s hash matches the stored hash.
                - `False` otherwise.
        &#34;&#34;&#34;
        if self.type == &#39;dir&#39;:
            return True  # Directories are assumed to be intact
        else:
            # Placeholder for actual integrity check
            # Implement hash comparison logic if necessary
            return True

    def __str__(self):
        &#34;&#34;&#34;
        Provides a string representation of the FileEntity instance.

        Returns:
            str: A tab-separated string containing the entity&#39;s path, hash, and size.
                - Format: &#34;relative_path/name\thashd\tsize&#34;
                - For the root entity, returns an empty string.
        &#34;&#34;&#34;
        if self.parent is not None:
            return &#34;\t&#34;.join([os.path.join(self.path, self.name), self.hashd, str(self.size)])
        return &#34;&#34;

###############################################################################
###############################################################################
###############################################################################
###############################################################################

class ManifestManager(object):
    &#34;&#34;&#34;
    ManifestManager Class

    ======================

    The `ManifestManager` class serves as the core interface for managing project manifests
    within the Pizza3 project. It encapsulates functionalities to create, compare, and update
    manifests, ensuring that the project&#39;s file structure remains consistent and unaltered
    across different environments or versions.

    Attributes:
    -----------
    timeout : int
        Specifies the timeout duration (in seconds) for network operations when fetching remote manifests.
    myExtensions : list of str
        A list of file extensions to include in the manifest (e.g., Python and shell scripts).
    files : list of FileEntity
        A collection of `FileEntity` objects representing the project&#39;s files and directories.
    type : str
        The type of manifest being managed (default is &#39;generic&#39;).

    Methods:
    --------
    createManifest(path, manifestName=None, exclude_dirs=None, exclude_files=None, extensions=None)
        Generates a manifest by inventorying all relevant files within the specified directory.
    
    diffManifests(localManifestLocation, sourceManifestLocation, localManifestName=None, sourceManifestName=None, printDiffs=False)
        Compares two manifests to identify differences such as added, modified, or deleted files and directories.
    
    updateManifest(localManifestLocation, sourceManifestLocation, localManifestName=None, sourceManifestName=None, prompt=True)
        Updates the local project files based on the differences identified between the local and source manifests.
    
    getManType(line)
        Extracts the manifest type from a given line of the manifest file.
    
    formatData(amount)
        Formats a byte size into a human-readable string (e.g., KB, MB, GB).
    
    makeSurePathExists(path)
        Ensures that a specified directory path exists, creating it if necessary.
    
    promptUserDownload()
        Prompts the user for confirmation before proceeding with downloading updates.
    
    walk(parents, full_path, rel_path, dirs, files, skipFile=&#34;.dmanifest&#34;, exclude_dirs=None, exclude_files=None, extensions=None)
        Recursively traverses the project directory to catalog files and directories, excluding specified files.
    
    listdir(path)
        Lists directories, files, and symbolic links within a specified path.
    
    hashfile(fileName, blocksize=65536)
        Computes the SHA-256 hash of a given file to ensure integrity.

    Usage Example:
    --------------
    ```python
    from generate_manifest import ManifestManager

    # Initialize the manager with specific extensions
    manager = ManifestManager()

    # Create a new manifest including .py, .sh, .md, and .html files
    manager.createManifest(&#39;/path/to/project&#39;, manifestName=&#39;project.manifest&#39;, extensions=[&#39;.py&#39;, &#39;.sh&#39;, &#39;.md&#39;, &#39;.html&#39;])

    # Diff two manifests and print differences
    manager.diffManifests(
        localManifestLocation=&#39;/local/manifest/dir&#39;,
        sourceManifestLocation=&#39;https://example.com/source/manifest&#39;,
        printDiffs=True
    )

    # Update the local manifest based on the source
    manager.updateManifest(
        localManifestLocation=&#39;/local/manifest/dir&#39;,
        sourceManifestLocation=&#39;https://example.com/source/manifest&#39;,
        prompt=True
    )
    ```
    &#34;&#34;&#34;
    
    def __init__(self, manType=None, timeout=30):
        &#34;&#34;&#34;
        Initializes a new instance of the ManifestManager class.

        Args:
            manType (str, optional): The type/category of the manifest. Defaults to &#34;generic&#34;.
            timeout (int, optional): Timeout duration in seconds for network operations. Defaults to 30.
        &#34;&#34;&#34;
        self.timeout = timeout
        self.myExtensions = [&#34;.py&#34;, &#34;.sh&#34;]  # Default extensions
        self.files = []
        if manType is not None:
            self.type = manType
        else:
            self.type = &#34;generic&#34;

    def createManifest(self, path, manifestName=None, exclude_dirs=None, exclude_files=None, extensions=None):
        &#34;&#34;&#34;
        Inventory all files in the specified path and create a manifest file.

        Args:
            path (str): The root directory path to inventory.
            manifestName (str, optional): The name of the manifest file. Defaults to &#34;.dmanifest&#34;.
            exclude_dirs (list of str, optional): List of directories to exclude from the manifest.
            exclude_files (list of str, optional): List of files to exclude from the manifest.
            extensions (list of str, optional): List of file extensions to include in the manifest.
                - If provided, overrides the default `myExtensions`.
                - If None, uses the existing `myExtensions`.
        &#34;&#34;&#34;
        if manifestName is None:
            manifestName = &#34;.dmanifest&#34;  # Default manifest name
        print(f&#34;Creating manifest &#39;{manifestName}&#39; for path: {path}&#34;)

        # Update extensions if provided
        if extensions is not None:
            self.myExtensions = extensions
            print(f&#34;Using custom extensions: {self.myExtensions}&#34;)
        else:
            print(f&#34;Using default extensions: {self.myExtensions}&#34;)

        # Make the root file entity
        root_path = os.path.abspath(path)
        root_fe = FileEntity(&#39;root&#39;, &#34;.&#34;, None, &#34;-&#34;, 0)
        self.files.append(root_fe)

        # Now make all the ones below
        parents = [root_fe]
        dirs, files, _ = self.listdir(path)
        print(f&#34;Initial directories: {dirs}&#34;)
        print(f&#34;Initial files: {files}&#34;)
        self.walk(parents, root_path, &#39;&#39;, dirs, files, skipFile=manifestName, exclude_dirs=exclude_dirs, exclude_files=exclude_files, extensions=self.myExtensions)

        with open(os.path.join(path, manifestName), &#39;w&#39;) as man_fh:
            # Print the header
            man_fh.write(&#34;#\t::: %s ::: \tPizza3 manifest version %s\n\n&#34; % (self.type, __version__))
            for f in self.files:
                if f.parent is not None:
                    man_fh.write(&#34;%s\n&#34; % f)
        print(f&#34;Manifest &#39;{manifestName}&#39; successfully written to &#39;{path}&#39;.&#34;)

    def diffManifests(self,
                      localManifestLocation,
                      sourceManifestLocation,
                      localManifestName=None,
                      sourceManifestName=None,
                      printDiffs=False):
        &#34;&#34;&#34;
        Check for any differences between two manifests.

        Args:
            localManifestLocation (str): Path to the local manifest directory.
            sourceManifestLocation (str): Path or URL to the source manifest location.
            localManifestName (str, optional): Name of the local manifest file. Defaults to &#34;.dmanifest&#34;.
            sourceManifestName (str, optional): Name of the source manifest file. Defaults to &#34;.dmanifest&#34;.
            printDiffs (bool, optional): Flag to print the differences. Defaults to False.

        Returns:
            tuple: Contains source path, added files, added directories, deleted files, and modified files.
                   Returns (None, None, None, None, None) if an error occurs.
        &#34;&#34;&#34;
        if localManifestName is None:
            localManifestName = &#34;.dmanifest&#34;
        if sourceManifestName is None:
            sourceManifestName = &#34;.dmanifest&#34;

        print(f&#34;Diffing manifests: Local=&#39;{localManifestLocation}/{localManifestName}&#39;, Source=&#39;{sourceManifestLocation}/{sourceManifestName}&#39;&#34;)
        
        # Get the &#34;type&#34; of the local manifest
        l_type = &#34;generic&#34;
        try:
            with open(os.path.join(localManifestLocation, localManifestName)) as l_man:
                for line in l_man:
                    if line.startswith(&#34;#&#34;):
                        l_type = self.getManType(line)
                        print(f&#34;Local manifest type: {l_type}&#34;)
                    break
        except FileNotFoundError:
            print(f&#34;Error: Local manifest &#39;{localManifestName}&#39; not found in &#39;{localManifestLocation}&#39;.&#34;)
            return (None, None, None, None, None)

        # Load the source manifest
        s_type = &#34;generic&#34;
        source_man = {}
        source = &#34;&#34;
        # First, assume it is remote
        try:
            source_url = urllib.parse.urljoin(sourceManifestLocation + &#39;/&#39;, sourceManifestName)
            print(f&#34;Attempting to load source manifest from URL: {source_url}&#34;)
            with urllib.request.urlopen(source_url, timeout=self.timeout) as s_man:
                source = sourceManifestLocation + &#34;/&#34;
                for line in s_man:
                    decoded_line = line.decode(&#39;utf-8&#39;)
                    if decoded_line.startswith(&#34;#&#34;):
                        s_type = self.getManType(decoded_line)
                        print(f&#34;Source manifest type: {s_type}&#34;)
                        if s_type != l_type:
                            print(f&#34;Error: Type of source manifest ({s_type}) does not match type of local manifest ({l_type}).&#34;)
                            return (None, None, None, None, None)
                        continue
                    fields = decoded_line.rstrip().split(&#34;\t&#34;)
                    if len(fields) &gt;= 3:
                        source_man[fields[0]] = [fields[1], fields[2], False]
        except urllib.error.URLError as e:
            print(f&#34;Warning: Could not load source manifest from URL. Attempting to load from local path. Error: {e}&#34;)
            # If not remote, assume it&#39;s a local file path
            try:
                with open(os.path.join(sourceManifestLocation, sourceManifestName)) as s_man:
                    source = os.path.join(sourceManifestLocation) + os.path.sep
                    for line in s_man:
                        if line.startswith(&#34;#&#34;):
                            s_type = self.getManType(line)
                            print(f&#34;Source manifest type: {s_type}&#34;)
                            if s_type != l_type:
                                print(f&#34;Error: Type of source manifest ({s_type}) does not match type of local manifest ({l_type}).&#34;)
                                return (None, None, None, None, None)
                            continue
                        fields = line.rstrip().split(&#34;\t&#34;)
                        if len(fields) &gt;= 3:
                            source_man[fields[0]] = [fields[1], fields[2], False]
            except FileNotFoundError:
                print(f&#34;Error: Source manifest &#39;{sourceManifestName}&#39; not found in &#39;{sourceManifestLocation}&#39;.&#34;)
                return (None, None, None, None, None)

        print(f&#34;Loaded {len(source_man)} entries from source manifest.&#34;)

        # Keep lists of modifications
        deleted = []
        addedDirs = []
        addedFiles = []
        modified = []

        try:
            with open(os.path.join(localManifestLocation, localManifestName)) as l_man:
                for line in l_man:
                    if line.startswith(&#34;#&#34;):
                        continue
                    fields = line.rstrip().split(&#34;\t&#34;)
                    if len(fields) &lt; 3:
                        continue
                    path, hashd, size = fields[0], fields[1], fields[2]
                    if path in source_man:
                        if source_man[path][0] != hashd:
                            # Hashes don&#39;t match
                            modified.append(path)
                        # Mark as seen
                        source_man[path][2] = True
                    else:
                        # File has been deleted from the source manifest
                        deleted.append(path)
        except FileNotFoundError:
            print(f&#34;Error: Local manifest &#39;{localManifestName}&#39; not found in &#39;{localManifestLocation}&#39;.&#34;)
            return (None, None, None, None, None)

        # Check for new files
        for f in list(source_man.keys()):
            if not source_man[f][2]:
                if source_man[f][0] == &#39;-&#39;:
                    addedDirs.append(f)
                else:
                    addedFiles.append(f)

        print(f&#34;Diff Results - Added Files: {len(addedFiles)}, Added Dirs: {len(addedDirs)}, Deleted Files: {len(deleted)}, Modified Files: {len(modified)}&#34;)

        if printDiffs:
            new_size = 0
            modified_size = 0
            for f in addedFiles:
                try:
                    new_size += int(source_man[f][1])
                except ValueError:
                    pass
            for f in modified:
                try:
                    modified_size += int(source_man[f][1])
                except ValueError:
                    pass

            if addedFiles:
                print(&#34;#------------------------------------------------------&#34;)
                print(f&#34;# Source contains {len(addedFiles)} new file(s) ({self.formatData(new_size)})&#34;)
                for f in addedFiles:
                    print(&#34;\t&#34;.join([self.formatData(int(source_man[f][1])), f]))

            if addedDirs:
                print(&#34;#------------------------------------------------------&#34;)
                print(f&#34;# Source contains {len(addedDirs)} new folder(s)&#34;)
                for f in addedDirs:
                    print(f)

            if modified:
                print(&#34;#------------------------------------------------------&#34;)
                print(f&#34;# Source contains {len(modified)} modified file(s) ({self.formatData(modified_size)})&#34;)
                for f in modified:
                    print(f)

            if deleted:
                print(&#34;#------------------------------------------------------&#34;)
                print(f&#34;# {len(deleted)} file(s) have been deleted in the source:&#34;)
                for f in deleted:
                    print(f)
        else:
            return (source,
                    [(a, source_man[a]) for a in addedFiles],
                    [(a, source_man[a]) for a in addedDirs],
                    deleted,
                    [(m, source_man[m]) for m in modified])

    def updateManifest(self,
                       localManifestLocation,
                       sourceManifestLocation,
                       localManifestName=None,
                       sourceManifestName=None,
                       prompt=True):
        &#34;&#34;&#34;
        Update local files based on remote changes.

        Args:
            localManifestLocation (str): Path to the local manifest directory.
            sourceManifestLocation (str): Path or URL to the source manifest location.
            localManifestName (str, optional): Name of the local manifest file. Defaults to &#34;.dmanifest&#34;.
            sourceManifestName (str, optional): Name of the source manifest file. Defaults to &#34;.dmanifest&#34;.
            prompt (bool, optional): Flag to prompt the user before downloading updates. Defaults to True.

        Returns:
            bool: 
                - `True` if the update was successful.
                - `False` otherwise.
        &#34;&#34;&#34;
        # Get the diffs
        diff = self.diffManifests(localManifestLocation,
                                  sourceManifestLocation,
                                  localManifestName,
                                  sourceManifestName,
                                  printDiffs=False)
        source, added_files, added_dirs, deleted, modified = diff

        # Bail if the diff failed
        if source is None:
            return False

        # No changes by default
        do_down = False
        if prompt:
            total_size = 0
            for f in added_files:
                try:
                    total_size += int(f[1][1])
                except ValueError:
                    pass
            for f in modified:
                try:
                    total_size += int(f[1][1])
                except ValueError:
                    pass
            if total_size != 0:
                print(&#34;****************************************************************&#34;)
                print(f&#34;{len(added_files)} new file(s) to be downloaded from source&#34;)
                print(f&#34;{len(modified)} existing file(s) to be updated&#34;)
                print(f&#34;{self.formatData(total_size)} will need to be downloaded&#34;)
                do_down = self.promptUserDownload()
                if not do_down:
                    print(&#34;Download aborted&#34;)

        update_manifest = False
        if do_down:
            update_manifest = True
            for add in added_dirs:
                # Make the dirs first
                full_path = os.path.abspath(os.path.join(localManifestLocation, add[0]))
                print(f&#34;Creating directory: {full_path}&#34;)
                self.makeSurePathExists(full_path)
            for add in added_files:
                full_path = os.path.abspath(os.path.join(localManifestLocation, add[0]))
                print(f&#34;Downloading new file: {add[0]} -&gt; {full_path}&#34;)
                try:
                    urllib.request.urlretrieve(source + add[0], full_path)
                except Exception as e:
                    print(f&#34;Error downloading {add[0]}: {e}&#34;)
            for modify in modified:
                full_path = os.path.abspath(os.path.join(localManifestLocation, modify[0]))
                print(f&#34;Updating existing file: {modify[0]} -&gt; {full_path}&#34;)
                try:
                    urllib.request.urlretrieve(source + modify[0], full_path)
                except Exception as e:
                    print(f&#34;Error updating {modify[0]}: {e}&#34;)

        if update_manifest:
            print(&#34;(Re)creating manifest file (please be patient)&#34;)
            self.createManifest(localManifestLocation, manifestName=localManifestName)
            
        return True

    def getManType(self, line):
        &#34;&#34;&#34;
        Work out the manifest type from the first line of the file.

        Args:
            line (str): A line from the manifest file.

        Returns:
            str: The extracted manifest type. Defaults to &#34;generic&#34; if extraction fails.
        &#34;&#34;&#34;
        try:
            return line.rstrip().split(&#34;:::&#34;)[1].strip()
        except IndexError:
            return &#34;generic&#34;

    def formatData(self, amount):
        &#34;&#34;&#34;
        Pretty print file sizes into human-readable formats.

        Args:
            amount (int): Size in bytes.

        Returns:
            str: Formatted size string (e.g., &#34;10 MB&#34;).
        &#34;&#34;&#34;
        try:
            amount = int(amount)
        except (ValueError, TypeError):
            return &#34;0 B&#34;
        if amount &lt; 1024*1024:
            return f&#34;{amount} B&#34;
        elif amount &lt; 1024*1024*1024:
            return f&#34;{amount / (1024*1024):.2f} MB&#34;
        elif amount &lt; 1024*1024*1024*1024:
            return f&#34;{amount / (1024*1024*1024):.2f} GB&#34;
        elif amount &lt; 1024*1024*1024*1024*1024:
            return f&#34;{amount / (1024*1024*1024*1024):.2f} TB&#34;
        else:
            return f&#34;{amount / (1024*1024*1024*1024*1024):.2f} PB&#34;

    #-----------------------------------------------------------------------------
    # FS utilities

    def makeSurePathExists(self, path):
        &#34;&#34;&#34;
        Ensures that a specified directory path exists, creating it if necessary.

        Args:
            path (str): The directory path to verify or create.
        &#34;&#34;&#34;
        try:
            os.makedirs(path)
            print(f&#34;Directory created: {path}&#34;)
        except OSError as exception:
            if exception.errno != errno.EEXIST:
                raise
            else:
                print(f&#34;Directory already exists: {path}&#34;)

    def promptUserDownload(self):
        &#34;&#34;&#34;
        Prompts the user for confirmation before proceeding with downloading updates.

        Returns:
            bool: 
                - `True` if the user confirms.
                - `False` otherwise.
        &#34;&#34;&#34;
        input_not_ok = True
        minimal = False
        valid_responses = {&#39;Y&#39;: True, &#39;N&#39;: False}
        vrs = &#34;,&#34;.join([x.lower() for x in list(valid_responses.keys())])
        while input_not_ok:
            if minimal:
                option = input(f&#34;Download? ({vrs}) : &#34;).upper()
            else:
                option = input(f&#34;Confirm you want to download this data\n&#34;
                               f&#34;Changes *WILL* be permanent\n&#34;
                               f&#34;Continue? ({vrs}) : &#34;).upper()
            if option in valid_responses:
                print(&#34;****************************************************************&#34;)
                return valid_responses[option]
            else:
                print(f&#34;ERROR: unrecognised choice &#39;{option}&#39;&#34;)
                minimal = True

    def walk(self, parents, full_path, rel_path, dirs, files, skipFile=&#34;.dmanifest&#34;, exclude_dirs=None, exclude_files=None, extensions=None):
        &#34;&#34;&#34;
        Recursively walks through the directory tree to catalog files and directories.

        Args:
            parents (list of FileEntity): Stack of parent directories.
            full_path (str): Absolute path to the current directory.
            rel_path (str): Relative path from the root.
            dirs (list of str): List of directories in the current path.
            files (list of str): List of files in the current path.
            skipFile (str, optional): File to skip (e.g., the manifest file itself). Defaults to &#34;.dmanifest&#34;.
            exclude_dirs (list of str, optional): List of directories to exclude.
            exclude_files (list of str, optional): List of files to exclude.
            extensions (list of str, optional): List of file extensions to include.
        &#34;&#34;&#34;
        print(f&#34;Entering directory: {full_path}&#34;)
        # First do files here
        for f in files:
            if (f != skipFile) and (not extensions or os.path.splitext(f)[1] in extensions):
                if exclude_files and f in exclude_files:
                    print(f&#34;Excluding file: {os.path.join(rel_path, f)}&#34;)
                    continue
                path = os.path.join(full_path, f)
                print(f&#34;Adding file: {path}&#34;)
                self.files.append(FileEntity(f, rel_path, parents[-1], self.hashfile(path), os.path.getsize(path)))
        for d in dirs:
            if exclude_dirs and d in exclude_dirs:
                print(f&#34;Excluding directory: {os.path.join(rel_path, d)}&#34;)
                continue
            # The walk will go into these dirs first
            tmp_fe = FileEntity(d, rel_path, parents[-1], &#34;-&#34;, 0)
            print(f&#34;Adding directory: {os.path.join(rel_path, d)}&#34;)
            self.files.append(tmp_fe)
            parents.append(tmp_fe)
            new_full_path = os.path.join(full_path, d)
            new_rel_path = os.path.join(rel_path, d)
            new_dirs, new_files, _ = self.listdir(new_full_path)
            self.walk(parents, new_full_path, new_rel_path, new_dirs, new_files, skipFile=skipFile, exclude_dirs=exclude_dirs, exclude_files=exclude_files, extensions=extensions)
            parents.pop()

    def listdir(self, path):
        &#34;&#34;&#34;
        Lists directories, files, and symbolic links within a specified path.

        Args:
            path (str): The directory path to list.

        Returns:
            tuple: Three lists containing directories, files, and symbolic links respectively.
        &#34;&#34;&#34;
        dirs, files, links = [], [], []
        try:
            for name in os.listdir(path):
                path_name = os.path.join(path, name)
                if os.path.isdir(path_name):
                    dirs.append(name)
                elif os.path.isfile(path_name):
                    files.append(name)
                elif os.path.islink(path_name):
                    links.append(name)
        except PermissionError as e:
            print(f&#34;Permission denied accessing &#39;{path}&#39;: {e}&#34;)
        except Exception as e:
            print(f&#34;Error accessing &#39;{path}&#39;: {e}&#34;)
        return dirs, files, links

    def hashfile(self, fileName, blocksize=65536):
        &#34;&#34;&#34;
        Hashes a file and returns its SHA-256 digest.

        Args:
            fileName (str): Path to the file to hash.
            blocksize (int, optional): Size of each read from the file. Defaults to 65536.

        Returns:
            str: The SHA-256 hash of the file. Returns &#34;?&#34; if hashing fails.
        &#34;&#34;&#34;
        hasher = hashlib.sha256()
        try:
            with open(fileName, &#34;rb&#34;) as fh:
                buf = fh.read(blocksize)
                while len(buf) &gt; 0:
                    hasher.update(buf.strip())
                    buf = fh.read(blocksize)
                return hasher.hexdigest()
        except FileNotFoundError:
            print(f&#34;Warning: File not found during hashing: {fileName}&#34;)
            return &#34;?&#34;
        except Exception as e:
            print(f&#34;Error hashing file {fileName}: {e}&#34;)
            return &#34;?&#34;

###############################################################################
###############################################################################
###############################################################################
###############################################################################

def main():
    parser = argparse.ArgumentParser(description=&#34;Manage project manifests for Pizza3.&#34;)
    subparsers = parser.add_subparsers(dest=&#39;action&#39;, help=&#39;Available actions&#39;)

    # Create Manifest
    parser_create = subparsers.add_parser(&#39;create&#39;, help=&#39;Create a new manifest&#39;)
    parser_create.add_argument(&#39;-p&#39;, &#39;--path&#39;, required=True, help=&#39;Path to the project directory&#39;)
    parser_create.add_argument(&#39;-m&#39;, &#39;--manifest&#39;, default=&#34;.dmanifest&#34;, help=&#39;Name of the manifest file&#39;)
    parser_create.add_argument(&#39;--exclude-dirs&#39;, nargs=&#39;*&#39;, help=&#39;List of directories to exclude from the manifest&#39;)
    parser_create.add_argument(&#39;--exclude-files&#39;, nargs=&#39;*&#39;, help=&#39;List of files to exclude from the manifest&#39;)
    parser_create.add_argument(&#39;--extensions&#39;, nargs=&#39;*&#39;, help=&#39;List of file extensions to include (e.g., .py .sh .md .html)&#39;)

    # Diff Manifests
    parser_diff = subparsers.add_parser(&#39;diff&#39;, help=&#39;Diff two manifests&#39;)
    parser_diff.add_argument(&#39;-l&#39;, &#39;--local&#39;, required=True, help=&#39;Local manifest directory&#39;)
    parser_diff.add_argument(&#39;-s&#39;, &#39;--source&#39;, required=True, help=&#39;Source manifest location (URL or path)&#39;)
    parser_diff.add_argument(&#39;--local-manifest&#39;, default=&#34;.dmanifest&#34;, help=&#39;Name of the local manifest file&#39;)
    parser_diff.add_argument(&#39;--source-manifest&#39;, default=&#34;.dmanifest&#34;, help=&#39;Name of the source manifest file&#39;)
    parser_diff.add_argument(&#39;--print&#39;, action=&#39;store_true&#39;, help=&#39;Print differences&#39;)

    # Update Manifest
    parser_update = subparsers.add_parser(&#39;update&#39;, help=&#39;Update local manifest based on source&#39;)
    parser_update.add_argument(&#39;-l&#39;, &#39;--local&#39;, required=True, help=&#39;Local manifest directory&#39;)
    parser_update.add_argument(&#39;-s&#39;, &#39;--source&#39;, required=True, help=&#39;Source manifest location (URL or path)&#39;)
    parser_update.add_argument(&#39;--local-manifest&#39;, default=&#34;.dmanifest&#34;, help=&#39;Name of the local manifest file&#39;)
    parser_update.add_argument(&#39;--source-manifest&#39;, default=&#34;.dmanifest&#34;, help=&#39;Name of the source manifest file&#39;)
    parser_update.add_argument(&#39;--prompt&#39;, action=&#39;store_true&#39;, help=&#39;Prompt before downloading updates&#39;)

    args = parser.parse_args()

    if args.action is None:
        parser.print_help()
        sys.exit(1)

    manager = ManifestManager()

    if args.action == &#39;create&#39;:
        manager.createManifest(
            args.path,
            manifestName=args.manifest,
            exclude_dirs=args.exclude_dirs,
            exclude_files=args.exclude_files,
            extensions=args.extensions
        )
        print(f&#34;Manifest &#39;{args.manifest}&#39; created at &#39;{args.path}&#39;.&#34;)
        sys.exit(0)

    elif args.action == &#39;diff&#39;:
        diff = manager.diffManifests(
            localManifestLocation=args.local,
            sourceManifestLocation=args.source,
            localManifestName=args.local_manifest,
            sourceManifestName=args.source_manifest,
            printDiffs=args.print
        )
        if diff[0] is not None and args.print:
            print(&#34;Diff operation completed.&#34;)
        elif diff[0] is None:
            print(&#34;Diff operation failed.&#34;)
        else:
            # Handle non-print diff results if needed
            pass
        sys.exit(0)

    elif args.action == &#39;update&#39;:
        success = manager.updateManifest(
            localManifestLocation=args.local,
            sourceManifestLocation=args.source,
            localManifestName=args.local_manifest,
            sourceManifestName=args.source_manifest,
            prompt=args.prompt
        )
        if success:
            print(&#34;Manifest update completed successfully.&#34;)
        else:
            print(&#34;Manifest update failed.&#34;)
        sys.exit(0)

if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="generate_manifest.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    parser = argparse.ArgumentParser(description=&#34;Manage project manifests for Pizza3.&#34;)
    subparsers = parser.add_subparsers(dest=&#39;action&#39;, help=&#39;Available actions&#39;)

    # Create Manifest
    parser_create = subparsers.add_parser(&#39;create&#39;, help=&#39;Create a new manifest&#39;)
    parser_create.add_argument(&#39;-p&#39;, &#39;--path&#39;, required=True, help=&#39;Path to the project directory&#39;)
    parser_create.add_argument(&#39;-m&#39;, &#39;--manifest&#39;, default=&#34;.dmanifest&#34;, help=&#39;Name of the manifest file&#39;)
    parser_create.add_argument(&#39;--exclude-dirs&#39;, nargs=&#39;*&#39;, help=&#39;List of directories to exclude from the manifest&#39;)
    parser_create.add_argument(&#39;--exclude-files&#39;, nargs=&#39;*&#39;, help=&#39;List of files to exclude from the manifest&#39;)
    parser_create.add_argument(&#39;--extensions&#39;, nargs=&#39;*&#39;, help=&#39;List of file extensions to include (e.g., .py .sh .md .html)&#39;)

    # Diff Manifests
    parser_diff = subparsers.add_parser(&#39;diff&#39;, help=&#39;Diff two manifests&#39;)
    parser_diff.add_argument(&#39;-l&#39;, &#39;--local&#39;, required=True, help=&#39;Local manifest directory&#39;)
    parser_diff.add_argument(&#39;-s&#39;, &#39;--source&#39;, required=True, help=&#39;Source manifest location (URL or path)&#39;)
    parser_diff.add_argument(&#39;--local-manifest&#39;, default=&#34;.dmanifest&#34;, help=&#39;Name of the local manifest file&#39;)
    parser_diff.add_argument(&#39;--source-manifest&#39;, default=&#34;.dmanifest&#34;, help=&#39;Name of the source manifest file&#39;)
    parser_diff.add_argument(&#39;--print&#39;, action=&#39;store_true&#39;, help=&#39;Print differences&#39;)

    # Update Manifest
    parser_update = subparsers.add_parser(&#39;update&#39;, help=&#39;Update local manifest based on source&#39;)
    parser_update.add_argument(&#39;-l&#39;, &#39;--local&#39;, required=True, help=&#39;Local manifest directory&#39;)
    parser_update.add_argument(&#39;-s&#39;, &#39;--source&#39;, required=True, help=&#39;Source manifest location (URL or path)&#39;)
    parser_update.add_argument(&#39;--local-manifest&#39;, default=&#34;.dmanifest&#34;, help=&#39;Name of the local manifest file&#39;)
    parser_update.add_argument(&#39;--source-manifest&#39;, default=&#34;.dmanifest&#34;, help=&#39;Name of the source manifest file&#39;)
    parser_update.add_argument(&#39;--prompt&#39;, action=&#39;store_true&#39;, help=&#39;Prompt before downloading updates&#39;)

    args = parser.parse_args()

    if args.action is None:
        parser.print_help()
        sys.exit(1)

    manager = ManifestManager()

    if args.action == &#39;create&#39;:
        manager.createManifest(
            args.path,
            manifestName=args.manifest,
            exclude_dirs=args.exclude_dirs,
            exclude_files=args.exclude_files,
            extensions=args.extensions
        )
        print(f&#34;Manifest &#39;{args.manifest}&#39; created at &#39;{args.path}&#39;.&#34;)
        sys.exit(0)

    elif args.action == &#39;diff&#39;:
        diff = manager.diffManifests(
            localManifestLocation=args.local,
            sourceManifestLocation=args.source,
            localManifestName=args.local_manifest,
            sourceManifestName=args.source_manifest,
            printDiffs=args.print
        )
        if diff[0] is not None and args.print:
            print(&#34;Diff operation completed.&#34;)
        elif diff[0] is None:
            print(&#34;Diff operation failed.&#34;)
        else:
            # Handle non-print diff results if needed
            pass
        sys.exit(0)

    elif args.action == &#39;update&#39;:
        success = manager.updateManifest(
            localManifestLocation=args.local,
            sourceManifestLocation=args.source,
            localManifestName=args.local_manifest,
            sourceManifestName=args.source_manifest,
            prompt=args.prompt
        )
        if success:
            print(&#34;Manifest update completed successfully.&#34;)
        else:
            print(&#34;Manifest update failed.&#34;)
        sys.exit(0)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="generate_manifest.FileEntity"><code class="flex name class">
<span>class <span class="ident">FileEntity</span></span>
<span>(</span><span>name, path, parent, hashd, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a file or directory entity with associated metadata.</p>
<p>Initializes a new instance of the FileEntity class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the entity on the file system.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The relative path to the root directory.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="generate_manifest.FileEntity" href="#generate_manifest.FileEntity">FileEntity</a></code> or <code>None</code></dt>
<dd>The parent FileEntity object containing this entity.
- <code>None</code> if the entity is the root.</dd>
<dt><strong><code>hashd</code></strong> :&ensp;<code>str</code></dt>
<dd>The SHA-256 hash of the file.
- Set to <code>'-'</code> for directories.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of the file in bytes.
- Set to <code>0</code> for directories.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileEntity(object):
    &#34;&#34;&#34;Represents a file or directory entity with associated metadata.&#34;&#34;&#34;
    
    def __init__(self,
                 name,      # Name of the entity
                 path,      # Relative path to the root directory
                 parent,    # Parent FileEntity object (None for root)
                 hashd,     # Hash of the file (None for directories)
                 size       # Size of the file in bytes (0 for directories)
                 ):
        &#34;&#34;&#34;
        Initializes a new instance of the FileEntity class.

        Args:
            name (str): The name of the entity on the file system.
            path (str): The relative path to the root directory.
            parent (FileEntity or None): The parent FileEntity object containing this entity.
                - `None` if the entity is the root.
            hashd (str): The SHA-256 hash of the file.
                - Set to `&#39;-&#39;` for directories.
            size (int): The size of the file in bytes.
                - Set to `0` for directories.
        &#34;&#34;&#34;
        self.name = name
        self.path = path
        self.parent = parent
        self.hashd = hashd
        self.size = size
        self.type = &#39;dir&#39; if self.hashd == &#39;-&#39; else &#39;file&#39;  # Determine type based on hashd

    def getFullPath(self):
        &#34;&#34;&#34;
        Retrieves the full path to this entity by concatenating parent paths.

        Returns:
            str: The absolute path to the entity.
                - For the root entity, returns its name.
                - For other entities, joins the parent&#39;s full path with its own name.
        &#34;&#34;&#34;
        if self.parent is None:
            return self.name  # Root entity
        else:
            return os.path.join(self.parent.getFullPath(), self.name)

    def checkIntegrity(self):
        &#34;&#34;&#34;
        Checks the integrity of the file by comparing its stored hash with a newly computed hash.

        For directories, integrity is assumed to be intact.

        Returns:
            bool: 
                - `True` if the entity is a directory or if the file&#39;s hash matches the stored hash.
                - `False` otherwise.
        &#34;&#34;&#34;
        if self.type == &#39;dir&#39;:
            return True  # Directories are assumed to be intact
        else:
            # Placeholder for actual integrity check
            # Implement hash comparison logic if necessary
            return True

    def __str__(self):
        &#34;&#34;&#34;
        Provides a string representation of the FileEntity instance.

        Returns:
            str: A tab-separated string containing the entity&#39;s path, hash, and size.
                - Format: &#34;relative_path/name\thashd\tsize&#34;
                - For the root entity, returns an empty string.
        &#34;&#34;&#34;
        if self.parent is not None:
            return &#34;\t&#34;.join([os.path.join(self.path, self.name), self.hashd, str(self.size)])
        return &#34;&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="generate_manifest.FileEntity.checkIntegrity"><code class="name flex">
<span>def <span class="ident">checkIntegrity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the integrity of the file by comparing its stored hash with a newly computed hash.</p>
<p>For directories, integrity is assumed to be intact.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>
<ul>
<li><code>True</code> if the entity is a directory or if the file's hash matches the stored hash.</li>
<li><code>False</code> otherwise.</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkIntegrity(self):
    &#34;&#34;&#34;
    Checks the integrity of the file by comparing its stored hash with a newly computed hash.

    For directories, integrity is assumed to be intact.

    Returns:
        bool: 
            - `True` if the entity is a directory or if the file&#39;s hash matches the stored hash.
            - `False` otherwise.
    &#34;&#34;&#34;
    if self.type == &#39;dir&#39;:
        return True  # Directories are assumed to be intact
    else:
        # Placeholder for actual integrity check
        # Implement hash comparison logic if necessary
        return True</code></pre>
</details>
</dd>
<dt id="generate_manifest.FileEntity.getFullPath"><code class="name flex">
<span>def <span class="ident">getFullPath</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the full path to this entity by concatenating parent paths.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The absolute path to the entity.
- For the root entity, returns its name.
- For other entities, joins the parent's full path with its own name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFullPath(self):
    &#34;&#34;&#34;
    Retrieves the full path to this entity by concatenating parent paths.

    Returns:
        str: The absolute path to the entity.
            - For the root entity, returns its name.
            - For other entities, joins the parent&#39;s full path with its own name.
    &#34;&#34;&#34;
    if self.parent is None:
        return self.name  # Root entity
    else:
        return os.path.join(self.parent.getFullPath(), self.name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="generate_manifest.ManifestManager"><code class="flex name class">
<span>class <span class="ident">ManifestManager</span></span>
<span>(</span><span>manType=None, timeout=30)</span>
</code></dt>
<dd>
<div class="desc"><p>ManifestManager Class</p>
<p>======================</p>
<p>The <code><a title="generate_manifest.ManifestManager" href="#generate_manifest.ManifestManager">ManifestManager</a></code> class serves as the core interface for managing project manifests
within the Pizza3 project. It encapsulates functionalities to create, compare, and update
manifests, ensuring that the project's file structure remains consistent and unaltered
across different environments or versions.</p>
<h2 id="attributes">Attributes:</h2>
<p>timeout : int
Specifies the timeout duration (in seconds) for network operations when fetching remote manifests.
myExtensions : list of str
A list of file extensions to include in the manifest (e.g., Python and shell scripts).
files : list of FileEntity
A collection of <code><a title="generate_manifest.FileEntity" href="#generate_manifest.FileEntity">FileEntity</a></code> objects representing the project's files and directories.
type : str
The type of manifest being managed (default is 'generic').</p>
<h2 id="methods">Methods:</h2>
<p>createManifest(path, manifestName=None, exclude_dirs=None, exclude_files=None, extensions=None)
Generates a manifest by inventorying all relevant files within the specified directory.</p>
<p>diffManifests(localManifestLocation, sourceManifestLocation, localManifestName=None, sourceManifestName=None, printDiffs=False)
Compares two manifests to identify differences such as added, modified, or deleted files and directories.</p>
<p>updateManifest(localManifestLocation, sourceManifestLocation, localManifestName=None, sourceManifestName=None, prompt=True)
Updates the local project files based on the differences identified between the local and source manifests.</p>
<p>getManType(line)
Extracts the manifest type from a given line of the manifest file.</p>
<p>formatData(amount)
Formats a byte size into a human-readable string (e.g., KB, MB, GB).</p>
<p>makeSurePathExists(path)
Ensures that a specified directory path exists, creating it if necessary.</p>
<p>promptUserDownload()
Prompts the user for confirmation before proceeding with downloading updates.</p>
<p>walk(parents, full_path, rel_path, dirs, files, skipFile=".dmanifest", exclude_dirs=None, exclude_files=None, extensions=None)
Recursively traverses the project directory to catalog files and directories, excluding specified files.</p>
<p>listdir(path)
Lists directories, files, and symbolic links within a specified path.</p>
<p>hashfile(fileName, blocksize=65536)
Computes the SHA-256 hash of a given file to ensure integrity.</p>
<h2 id="usage-example">Usage Example:</h2>
<pre><code class="language-python">from generate_manifest import ManifestManager

# Initialize the manager with specific extensions
manager = ManifestManager()

# Create a new manifest including .py, .sh, .md, and .html files
manager.createManifest('/path/to/project', manifestName='project.manifest', extensions=['.py', '.sh', '.md', '.html'])

# Diff two manifests and print differences
manager.diffManifests(
    localManifestLocation='/local/manifest/dir',
    sourceManifestLocation='https://example.com/source/manifest',
    printDiffs=True
)

# Update the local manifest based on the source
manager.updateManifest(
    localManifestLocation='/local/manifest/dir',
    sourceManifestLocation='https://example.com/source/manifest',
    prompt=True
)
</code></pre>
<p>Initializes a new instance of the ManifestManager class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>manType</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The type/category of the manifest. Defaults to "generic".</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Timeout duration in seconds for network operations. Defaults to 30.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ManifestManager(object):
    &#34;&#34;&#34;
    ManifestManager Class

    ======================

    The `ManifestManager` class serves as the core interface for managing project manifests
    within the Pizza3 project. It encapsulates functionalities to create, compare, and update
    manifests, ensuring that the project&#39;s file structure remains consistent and unaltered
    across different environments or versions.

    Attributes:
    -----------
    timeout : int
        Specifies the timeout duration (in seconds) for network operations when fetching remote manifests.
    myExtensions : list of str
        A list of file extensions to include in the manifest (e.g., Python and shell scripts).
    files : list of FileEntity
        A collection of `FileEntity` objects representing the project&#39;s files and directories.
    type : str
        The type of manifest being managed (default is &#39;generic&#39;).

    Methods:
    --------
    createManifest(path, manifestName=None, exclude_dirs=None, exclude_files=None, extensions=None)
        Generates a manifest by inventorying all relevant files within the specified directory.
    
    diffManifests(localManifestLocation, sourceManifestLocation, localManifestName=None, sourceManifestName=None, printDiffs=False)
        Compares two manifests to identify differences such as added, modified, or deleted files and directories.
    
    updateManifest(localManifestLocation, sourceManifestLocation, localManifestName=None, sourceManifestName=None, prompt=True)
        Updates the local project files based on the differences identified between the local and source manifests.
    
    getManType(line)
        Extracts the manifest type from a given line of the manifest file.
    
    formatData(amount)
        Formats a byte size into a human-readable string (e.g., KB, MB, GB).
    
    makeSurePathExists(path)
        Ensures that a specified directory path exists, creating it if necessary.
    
    promptUserDownload()
        Prompts the user for confirmation before proceeding with downloading updates.
    
    walk(parents, full_path, rel_path, dirs, files, skipFile=&#34;.dmanifest&#34;, exclude_dirs=None, exclude_files=None, extensions=None)
        Recursively traverses the project directory to catalog files and directories, excluding specified files.
    
    listdir(path)
        Lists directories, files, and symbolic links within a specified path.
    
    hashfile(fileName, blocksize=65536)
        Computes the SHA-256 hash of a given file to ensure integrity.

    Usage Example:
    --------------
    ```python
    from generate_manifest import ManifestManager

    # Initialize the manager with specific extensions
    manager = ManifestManager()

    # Create a new manifest including .py, .sh, .md, and .html files
    manager.createManifest(&#39;/path/to/project&#39;, manifestName=&#39;project.manifest&#39;, extensions=[&#39;.py&#39;, &#39;.sh&#39;, &#39;.md&#39;, &#39;.html&#39;])

    # Diff two manifests and print differences
    manager.diffManifests(
        localManifestLocation=&#39;/local/manifest/dir&#39;,
        sourceManifestLocation=&#39;https://example.com/source/manifest&#39;,
        printDiffs=True
    )

    # Update the local manifest based on the source
    manager.updateManifest(
        localManifestLocation=&#39;/local/manifest/dir&#39;,
        sourceManifestLocation=&#39;https://example.com/source/manifest&#39;,
        prompt=True
    )
    ```
    &#34;&#34;&#34;
    
    def __init__(self, manType=None, timeout=30):
        &#34;&#34;&#34;
        Initializes a new instance of the ManifestManager class.

        Args:
            manType (str, optional): The type/category of the manifest. Defaults to &#34;generic&#34;.
            timeout (int, optional): Timeout duration in seconds for network operations. Defaults to 30.
        &#34;&#34;&#34;
        self.timeout = timeout
        self.myExtensions = [&#34;.py&#34;, &#34;.sh&#34;]  # Default extensions
        self.files = []
        if manType is not None:
            self.type = manType
        else:
            self.type = &#34;generic&#34;

    def createManifest(self, path, manifestName=None, exclude_dirs=None, exclude_files=None, extensions=None):
        &#34;&#34;&#34;
        Inventory all files in the specified path and create a manifest file.

        Args:
            path (str): The root directory path to inventory.
            manifestName (str, optional): The name of the manifest file. Defaults to &#34;.dmanifest&#34;.
            exclude_dirs (list of str, optional): List of directories to exclude from the manifest.
            exclude_files (list of str, optional): List of files to exclude from the manifest.
            extensions (list of str, optional): List of file extensions to include in the manifest.
                - If provided, overrides the default `myExtensions`.
                - If None, uses the existing `myExtensions`.
        &#34;&#34;&#34;
        if manifestName is None:
            manifestName = &#34;.dmanifest&#34;  # Default manifest name
        print(f&#34;Creating manifest &#39;{manifestName}&#39; for path: {path}&#34;)

        # Update extensions if provided
        if extensions is not None:
            self.myExtensions = extensions
            print(f&#34;Using custom extensions: {self.myExtensions}&#34;)
        else:
            print(f&#34;Using default extensions: {self.myExtensions}&#34;)

        # Make the root file entity
        root_path = os.path.abspath(path)
        root_fe = FileEntity(&#39;root&#39;, &#34;.&#34;, None, &#34;-&#34;, 0)
        self.files.append(root_fe)

        # Now make all the ones below
        parents = [root_fe]
        dirs, files, _ = self.listdir(path)
        print(f&#34;Initial directories: {dirs}&#34;)
        print(f&#34;Initial files: {files}&#34;)
        self.walk(parents, root_path, &#39;&#39;, dirs, files, skipFile=manifestName, exclude_dirs=exclude_dirs, exclude_files=exclude_files, extensions=self.myExtensions)

        with open(os.path.join(path, manifestName), &#39;w&#39;) as man_fh:
            # Print the header
            man_fh.write(&#34;#\t::: %s ::: \tPizza3 manifest version %s\n\n&#34; % (self.type, __version__))
            for f in self.files:
                if f.parent is not None:
                    man_fh.write(&#34;%s\n&#34; % f)
        print(f&#34;Manifest &#39;{manifestName}&#39; successfully written to &#39;{path}&#39;.&#34;)

    def diffManifests(self,
                      localManifestLocation,
                      sourceManifestLocation,
                      localManifestName=None,
                      sourceManifestName=None,
                      printDiffs=False):
        &#34;&#34;&#34;
        Check for any differences between two manifests.

        Args:
            localManifestLocation (str): Path to the local manifest directory.
            sourceManifestLocation (str): Path or URL to the source manifest location.
            localManifestName (str, optional): Name of the local manifest file. Defaults to &#34;.dmanifest&#34;.
            sourceManifestName (str, optional): Name of the source manifest file. Defaults to &#34;.dmanifest&#34;.
            printDiffs (bool, optional): Flag to print the differences. Defaults to False.

        Returns:
            tuple: Contains source path, added files, added directories, deleted files, and modified files.
                   Returns (None, None, None, None, None) if an error occurs.
        &#34;&#34;&#34;
        if localManifestName is None:
            localManifestName = &#34;.dmanifest&#34;
        if sourceManifestName is None:
            sourceManifestName = &#34;.dmanifest&#34;

        print(f&#34;Diffing manifests: Local=&#39;{localManifestLocation}/{localManifestName}&#39;, Source=&#39;{sourceManifestLocation}/{sourceManifestName}&#39;&#34;)
        
        # Get the &#34;type&#34; of the local manifest
        l_type = &#34;generic&#34;
        try:
            with open(os.path.join(localManifestLocation, localManifestName)) as l_man:
                for line in l_man:
                    if line.startswith(&#34;#&#34;):
                        l_type = self.getManType(line)
                        print(f&#34;Local manifest type: {l_type}&#34;)
                    break
        except FileNotFoundError:
            print(f&#34;Error: Local manifest &#39;{localManifestName}&#39; not found in &#39;{localManifestLocation}&#39;.&#34;)
            return (None, None, None, None, None)

        # Load the source manifest
        s_type = &#34;generic&#34;
        source_man = {}
        source = &#34;&#34;
        # First, assume it is remote
        try:
            source_url = urllib.parse.urljoin(sourceManifestLocation + &#39;/&#39;, sourceManifestName)
            print(f&#34;Attempting to load source manifest from URL: {source_url}&#34;)
            with urllib.request.urlopen(source_url, timeout=self.timeout) as s_man:
                source = sourceManifestLocation + &#34;/&#34;
                for line in s_man:
                    decoded_line = line.decode(&#39;utf-8&#39;)
                    if decoded_line.startswith(&#34;#&#34;):
                        s_type = self.getManType(decoded_line)
                        print(f&#34;Source manifest type: {s_type}&#34;)
                        if s_type != l_type:
                            print(f&#34;Error: Type of source manifest ({s_type}) does not match type of local manifest ({l_type}).&#34;)
                            return (None, None, None, None, None)
                        continue
                    fields = decoded_line.rstrip().split(&#34;\t&#34;)
                    if len(fields) &gt;= 3:
                        source_man[fields[0]] = [fields[1], fields[2], False]
        except urllib.error.URLError as e:
            print(f&#34;Warning: Could not load source manifest from URL. Attempting to load from local path. Error: {e}&#34;)
            # If not remote, assume it&#39;s a local file path
            try:
                with open(os.path.join(sourceManifestLocation, sourceManifestName)) as s_man:
                    source = os.path.join(sourceManifestLocation) + os.path.sep
                    for line in s_man:
                        if line.startswith(&#34;#&#34;):
                            s_type = self.getManType(line)
                            print(f&#34;Source manifest type: {s_type}&#34;)
                            if s_type != l_type:
                                print(f&#34;Error: Type of source manifest ({s_type}) does not match type of local manifest ({l_type}).&#34;)
                                return (None, None, None, None, None)
                            continue
                        fields = line.rstrip().split(&#34;\t&#34;)
                        if len(fields) &gt;= 3:
                            source_man[fields[0]] = [fields[1], fields[2], False]
            except FileNotFoundError:
                print(f&#34;Error: Source manifest &#39;{sourceManifestName}&#39; not found in &#39;{sourceManifestLocation}&#39;.&#34;)
                return (None, None, None, None, None)

        print(f&#34;Loaded {len(source_man)} entries from source manifest.&#34;)

        # Keep lists of modifications
        deleted = []
        addedDirs = []
        addedFiles = []
        modified = []

        try:
            with open(os.path.join(localManifestLocation, localManifestName)) as l_man:
                for line in l_man:
                    if line.startswith(&#34;#&#34;):
                        continue
                    fields = line.rstrip().split(&#34;\t&#34;)
                    if len(fields) &lt; 3:
                        continue
                    path, hashd, size = fields[0], fields[1], fields[2]
                    if path in source_man:
                        if source_man[path][0] != hashd:
                            # Hashes don&#39;t match
                            modified.append(path)
                        # Mark as seen
                        source_man[path][2] = True
                    else:
                        # File has been deleted from the source manifest
                        deleted.append(path)
        except FileNotFoundError:
            print(f&#34;Error: Local manifest &#39;{localManifestName}&#39; not found in &#39;{localManifestLocation}&#39;.&#34;)
            return (None, None, None, None, None)

        # Check for new files
        for f in list(source_man.keys()):
            if not source_man[f][2]:
                if source_man[f][0] == &#39;-&#39;:
                    addedDirs.append(f)
                else:
                    addedFiles.append(f)

        print(f&#34;Diff Results - Added Files: {len(addedFiles)}, Added Dirs: {len(addedDirs)}, Deleted Files: {len(deleted)}, Modified Files: {len(modified)}&#34;)

        if printDiffs:
            new_size = 0
            modified_size = 0
            for f in addedFiles:
                try:
                    new_size += int(source_man[f][1])
                except ValueError:
                    pass
            for f in modified:
                try:
                    modified_size += int(source_man[f][1])
                except ValueError:
                    pass

            if addedFiles:
                print(&#34;#------------------------------------------------------&#34;)
                print(f&#34;# Source contains {len(addedFiles)} new file(s) ({self.formatData(new_size)})&#34;)
                for f in addedFiles:
                    print(&#34;\t&#34;.join([self.formatData(int(source_man[f][1])), f]))

            if addedDirs:
                print(&#34;#------------------------------------------------------&#34;)
                print(f&#34;# Source contains {len(addedDirs)} new folder(s)&#34;)
                for f in addedDirs:
                    print(f)

            if modified:
                print(&#34;#------------------------------------------------------&#34;)
                print(f&#34;# Source contains {len(modified)} modified file(s) ({self.formatData(modified_size)})&#34;)
                for f in modified:
                    print(f)

            if deleted:
                print(&#34;#------------------------------------------------------&#34;)
                print(f&#34;# {len(deleted)} file(s) have been deleted in the source:&#34;)
                for f in deleted:
                    print(f)
        else:
            return (source,
                    [(a, source_man[a]) for a in addedFiles],
                    [(a, source_man[a]) for a in addedDirs],
                    deleted,
                    [(m, source_man[m]) for m in modified])

    def updateManifest(self,
                       localManifestLocation,
                       sourceManifestLocation,
                       localManifestName=None,
                       sourceManifestName=None,
                       prompt=True):
        &#34;&#34;&#34;
        Update local files based on remote changes.

        Args:
            localManifestLocation (str): Path to the local manifest directory.
            sourceManifestLocation (str): Path or URL to the source manifest location.
            localManifestName (str, optional): Name of the local manifest file. Defaults to &#34;.dmanifest&#34;.
            sourceManifestName (str, optional): Name of the source manifest file. Defaults to &#34;.dmanifest&#34;.
            prompt (bool, optional): Flag to prompt the user before downloading updates. Defaults to True.

        Returns:
            bool: 
                - `True` if the update was successful.
                - `False` otherwise.
        &#34;&#34;&#34;
        # Get the diffs
        diff = self.diffManifests(localManifestLocation,
                                  sourceManifestLocation,
                                  localManifestName,
                                  sourceManifestName,
                                  printDiffs=False)
        source, added_files, added_dirs, deleted, modified = diff

        # Bail if the diff failed
        if source is None:
            return False

        # No changes by default
        do_down = False
        if prompt:
            total_size = 0
            for f in added_files:
                try:
                    total_size += int(f[1][1])
                except ValueError:
                    pass
            for f in modified:
                try:
                    total_size += int(f[1][1])
                except ValueError:
                    pass
            if total_size != 0:
                print(&#34;****************************************************************&#34;)
                print(f&#34;{len(added_files)} new file(s) to be downloaded from source&#34;)
                print(f&#34;{len(modified)} existing file(s) to be updated&#34;)
                print(f&#34;{self.formatData(total_size)} will need to be downloaded&#34;)
                do_down = self.promptUserDownload()
                if not do_down:
                    print(&#34;Download aborted&#34;)

        update_manifest = False
        if do_down:
            update_manifest = True
            for add in added_dirs:
                # Make the dirs first
                full_path = os.path.abspath(os.path.join(localManifestLocation, add[0]))
                print(f&#34;Creating directory: {full_path}&#34;)
                self.makeSurePathExists(full_path)
            for add in added_files:
                full_path = os.path.abspath(os.path.join(localManifestLocation, add[0]))
                print(f&#34;Downloading new file: {add[0]} -&gt; {full_path}&#34;)
                try:
                    urllib.request.urlretrieve(source + add[0], full_path)
                except Exception as e:
                    print(f&#34;Error downloading {add[0]}: {e}&#34;)
            for modify in modified:
                full_path = os.path.abspath(os.path.join(localManifestLocation, modify[0]))
                print(f&#34;Updating existing file: {modify[0]} -&gt; {full_path}&#34;)
                try:
                    urllib.request.urlretrieve(source + modify[0], full_path)
                except Exception as e:
                    print(f&#34;Error updating {modify[0]}: {e}&#34;)

        if update_manifest:
            print(&#34;(Re)creating manifest file (please be patient)&#34;)
            self.createManifest(localManifestLocation, manifestName=localManifestName)
            
        return True

    def getManType(self, line):
        &#34;&#34;&#34;
        Work out the manifest type from the first line of the file.

        Args:
            line (str): A line from the manifest file.

        Returns:
            str: The extracted manifest type. Defaults to &#34;generic&#34; if extraction fails.
        &#34;&#34;&#34;
        try:
            return line.rstrip().split(&#34;:::&#34;)[1].strip()
        except IndexError:
            return &#34;generic&#34;

    def formatData(self, amount):
        &#34;&#34;&#34;
        Pretty print file sizes into human-readable formats.

        Args:
            amount (int): Size in bytes.

        Returns:
            str: Formatted size string (e.g., &#34;10 MB&#34;).
        &#34;&#34;&#34;
        try:
            amount = int(amount)
        except (ValueError, TypeError):
            return &#34;0 B&#34;
        if amount &lt; 1024*1024:
            return f&#34;{amount} B&#34;
        elif amount &lt; 1024*1024*1024:
            return f&#34;{amount / (1024*1024):.2f} MB&#34;
        elif amount &lt; 1024*1024*1024*1024:
            return f&#34;{amount / (1024*1024*1024):.2f} GB&#34;
        elif amount &lt; 1024*1024*1024*1024*1024:
            return f&#34;{amount / (1024*1024*1024*1024):.2f} TB&#34;
        else:
            return f&#34;{amount / (1024*1024*1024*1024*1024):.2f} PB&#34;

    #-----------------------------------------------------------------------------
    # FS utilities

    def makeSurePathExists(self, path):
        &#34;&#34;&#34;
        Ensures that a specified directory path exists, creating it if necessary.

        Args:
            path (str): The directory path to verify or create.
        &#34;&#34;&#34;
        try:
            os.makedirs(path)
            print(f&#34;Directory created: {path}&#34;)
        except OSError as exception:
            if exception.errno != errno.EEXIST:
                raise
            else:
                print(f&#34;Directory already exists: {path}&#34;)

    def promptUserDownload(self):
        &#34;&#34;&#34;
        Prompts the user for confirmation before proceeding with downloading updates.

        Returns:
            bool: 
                - `True` if the user confirms.
                - `False` otherwise.
        &#34;&#34;&#34;
        input_not_ok = True
        minimal = False
        valid_responses = {&#39;Y&#39;: True, &#39;N&#39;: False}
        vrs = &#34;,&#34;.join([x.lower() for x in list(valid_responses.keys())])
        while input_not_ok:
            if minimal:
                option = input(f&#34;Download? ({vrs}) : &#34;).upper()
            else:
                option = input(f&#34;Confirm you want to download this data\n&#34;
                               f&#34;Changes *WILL* be permanent\n&#34;
                               f&#34;Continue? ({vrs}) : &#34;).upper()
            if option in valid_responses:
                print(&#34;****************************************************************&#34;)
                return valid_responses[option]
            else:
                print(f&#34;ERROR: unrecognised choice &#39;{option}&#39;&#34;)
                minimal = True

    def walk(self, parents, full_path, rel_path, dirs, files, skipFile=&#34;.dmanifest&#34;, exclude_dirs=None, exclude_files=None, extensions=None):
        &#34;&#34;&#34;
        Recursively walks through the directory tree to catalog files and directories.

        Args:
            parents (list of FileEntity): Stack of parent directories.
            full_path (str): Absolute path to the current directory.
            rel_path (str): Relative path from the root.
            dirs (list of str): List of directories in the current path.
            files (list of str): List of files in the current path.
            skipFile (str, optional): File to skip (e.g., the manifest file itself). Defaults to &#34;.dmanifest&#34;.
            exclude_dirs (list of str, optional): List of directories to exclude.
            exclude_files (list of str, optional): List of files to exclude.
            extensions (list of str, optional): List of file extensions to include.
        &#34;&#34;&#34;
        print(f&#34;Entering directory: {full_path}&#34;)
        # First do files here
        for f in files:
            if (f != skipFile) and (not extensions or os.path.splitext(f)[1] in extensions):
                if exclude_files and f in exclude_files:
                    print(f&#34;Excluding file: {os.path.join(rel_path, f)}&#34;)
                    continue
                path = os.path.join(full_path, f)
                print(f&#34;Adding file: {path}&#34;)
                self.files.append(FileEntity(f, rel_path, parents[-1], self.hashfile(path), os.path.getsize(path)))
        for d in dirs:
            if exclude_dirs and d in exclude_dirs:
                print(f&#34;Excluding directory: {os.path.join(rel_path, d)}&#34;)
                continue
            # The walk will go into these dirs first
            tmp_fe = FileEntity(d, rel_path, parents[-1], &#34;-&#34;, 0)
            print(f&#34;Adding directory: {os.path.join(rel_path, d)}&#34;)
            self.files.append(tmp_fe)
            parents.append(tmp_fe)
            new_full_path = os.path.join(full_path, d)
            new_rel_path = os.path.join(rel_path, d)
            new_dirs, new_files, _ = self.listdir(new_full_path)
            self.walk(parents, new_full_path, new_rel_path, new_dirs, new_files, skipFile=skipFile, exclude_dirs=exclude_dirs, exclude_files=exclude_files, extensions=extensions)
            parents.pop()

    def listdir(self, path):
        &#34;&#34;&#34;
        Lists directories, files, and symbolic links within a specified path.

        Args:
            path (str): The directory path to list.

        Returns:
            tuple: Three lists containing directories, files, and symbolic links respectively.
        &#34;&#34;&#34;
        dirs, files, links = [], [], []
        try:
            for name in os.listdir(path):
                path_name = os.path.join(path, name)
                if os.path.isdir(path_name):
                    dirs.append(name)
                elif os.path.isfile(path_name):
                    files.append(name)
                elif os.path.islink(path_name):
                    links.append(name)
        except PermissionError as e:
            print(f&#34;Permission denied accessing &#39;{path}&#39;: {e}&#34;)
        except Exception as e:
            print(f&#34;Error accessing &#39;{path}&#39;: {e}&#34;)
        return dirs, files, links

    def hashfile(self, fileName, blocksize=65536):
        &#34;&#34;&#34;
        Hashes a file and returns its SHA-256 digest.

        Args:
            fileName (str): Path to the file to hash.
            blocksize (int, optional): Size of each read from the file. Defaults to 65536.

        Returns:
            str: The SHA-256 hash of the file. Returns &#34;?&#34; if hashing fails.
        &#34;&#34;&#34;
        hasher = hashlib.sha256()
        try:
            with open(fileName, &#34;rb&#34;) as fh:
                buf = fh.read(blocksize)
                while len(buf) &gt; 0:
                    hasher.update(buf.strip())
                    buf = fh.read(blocksize)
                return hasher.hexdigest()
        except FileNotFoundError:
            print(f&#34;Warning: File not found during hashing: {fileName}&#34;)
            return &#34;?&#34;
        except Exception as e:
            print(f&#34;Error hashing file {fileName}: {e}&#34;)
            return &#34;?&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="generate_manifest.ManifestManager.createManifest"><code class="name flex">
<span>def <span class="ident">createManifest</span></span>(<span>self, path, manifestName=None, exclude_dirs=None, exclude_files=None, extensions=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Inventory all files in the specified path and create a manifest file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The root directory path to inventory.</dd>
<dt><strong><code>manifestName</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the manifest file. Defaults to ".dmanifest".</dd>
<dt><strong><code>exclude_dirs</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>List of directories to exclude from the manifest.</dd>
<dt><strong><code>exclude_files</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>List of files to exclude from the manifest.</dd>
<dt><strong><code>extensions</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>List of file extensions to include in the manifest.
- If provided, overrides the default <code>myExtensions</code>.
- If None, uses the existing <code>myExtensions</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createManifest(self, path, manifestName=None, exclude_dirs=None, exclude_files=None, extensions=None):
    &#34;&#34;&#34;
    Inventory all files in the specified path and create a manifest file.

    Args:
        path (str): The root directory path to inventory.
        manifestName (str, optional): The name of the manifest file. Defaults to &#34;.dmanifest&#34;.
        exclude_dirs (list of str, optional): List of directories to exclude from the manifest.
        exclude_files (list of str, optional): List of files to exclude from the manifest.
        extensions (list of str, optional): List of file extensions to include in the manifest.
            - If provided, overrides the default `myExtensions`.
            - If None, uses the existing `myExtensions`.
    &#34;&#34;&#34;
    if manifestName is None:
        manifestName = &#34;.dmanifest&#34;  # Default manifest name
    print(f&#34;Creating manifest &#39;{manifestName}&#39; for path: {path}&#34;)

    # Update extensions if provided
    if extensions is not None:
        self.myExtensions = extensions
        print(f&#34;Using custom extensions: {self.myExtensions}&#34;)
    else:
        print(f&#34;Using default extensions: {self.myExtensions}&#34;)

    # Make the root file entity
    root_path = os.path.abspath(path)
    root_fe = FileEntity(&#39;root&#39;, &#34;.&#34;, None, &#34;-&#34;, 0)
    self.files.append(root_fe)

    # Now make all the ones below
    parents = [root_fe]
    dirs, files, _ = self.listdir(path)
    print(f&#34;Initial directories: {dirs}&#34;)
    print(f&#34;Initial files: {files}&#34;)
    self.walk(parents, root_path, &#39;&#39;, dirs, files, skipFile=manifestName, exclude_dirs=exclude_dirs, exclude_files=exclude_files, extensions=self.myExtensions)

    with open(os.path.join(path, manifestName), &#39;w&#39;) as man_fh:
        # Print the header
        man_fh.write(&#34;#\t::: %s ::: \tPizza3 manifest version %s\n\n&#34; % (self.type, __version__))
        for f in self.files:
            if f.parent is not None:
                man_fh.write(&#34;%s\n&#34; % f)
    print(f&#34;Manifest &#39;{manifestName}&#39; successfully written to &#39;{path}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="generate_manifest.ManifestManager.diffManifests"><code class="name flex">
<span>def <span class="ident">diffManifests</span></span>(<span>self, localManifestLocation, sourceManifestLocation, localManifestName=None, sourceManifestName=None, printDiffs=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Check for any differences between two manifests.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>localManifestLocation</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the local manifest directory.</dd>
<dt><strong><code>sourceManifestLocation</code></strong> :&ensp;<code>str</code></dt>
<dd>Path or URL to the source manifest location.</dd>
<dt><strong><code>localManifestName</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the local manifest file. Defaults to ".dmanifest".</dd>
<dt><strong><code>sourceManifestName</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the source manifest file. Defaults to ".dmanifest".</dd>
<dt><strong><code>printDiffs</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag to print the differences. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Contains source path, added files, added directories, deleted files, and modified files.
Returns (None, None, None, None, None) if an error occurs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diffManifests(self,
                  localManifestLocation,
                  sourceManifestLocation,
                  localManifestName=None,
                  sourceManifestName=None,
                  printDiffs=False):
    &#34;&#34;&#34;
    Check for any differences between two manifests.

    Args:
        localManifestLocation (str): Path to the local manifest directory.
        sourceManifestLocation (str): Path or URL to the source manifest location.
        localManifestName (str, optional): Name of the local manifest file. Defaults to &#34;.dmanifest&#34;.
        sourceManifestName (str, optional): Name of the source manifest file. Defaults to &#34;.dmanifest&#34;.
        printDiffs (bool, optional): Flag to print the differences. Defaults to False.

    Returns:
        tuple: Contains source path, added files, added directories, deleted files, and modified files.
               Returns (None, None, None, None, None) if an error occurs.
    &#34;&#34;&#34;
    if localManifestName is None:
        localManifestName = &#34;.dmanifest&#34;
    if sourceManifestName is None:
        sourceManifestName = &#34;.dmanifest&#34;

    print(f&#34;Diffing manifests: Local=&#39;{localManifestLocation}/{localManifestName}&#39;, Source=&#39;{sourceManifestLocation}/{sourceManifestName}&#39;&#34;)
    
    # Get the &#34;type&#34; of the local manifest
    l_type = &#34;generic&#34;
    try:
        with open(os.path.join(localManifestLocation, localManifestName)) as l_man:
            for line in l_man:
                if line.startswith(&#34;#&#34;):
                    l_type = self.getManType(line)
                    print(f&#34;Local manifest type: {l_type}&#34;)
                break
    except FileNotFoundError:
        print(f&#34;Error: Local manifest &#39;{localManifestName}&#39; not found in &#39;{localManifestLocation}&#39;.&#34;)
        return (None, None, None, None, None)

    # Load the source manifest
    s_type = &#34;generic&#34;
    source_man = {}
    source = &#34;&#34;
    # First, assume it is remote
    try:
        source_url = urllib.parse.urljoin(sourceManifestLocation + &#39;/&#39;, sourceManifestName)
        print(f&#34;Attempting to load source manifest from URL: {source_url}&#34;)
        with urllib.request.urlopen(source_url, timeout=self.timeout) as s_man:
            source = sourceManifestLocation + &#34;/&#34;
            for line in s_man:
                decoded_line = line.decode(&#39;utf-8&#39;)
                if decoded_line.startswith(&#34;#&#34;):
                    s_type = self.getManType(decoded_line)
                    print(f&#34;Source manifest type: {s_type}&#34;)
                    if s_type != l_type:
                        print(f&#34;Error: Type of source manifest ({s_type}) does not match type of local manifest ({l_type}).&#34;)
                        return (None, None, None, None, None)
                    continue
                fields = decoded_line.rstrip().split(&#34;\t&#34;)
                if len(fields) &gt;= 3:
                    source_man[fields[0]] = [fields[1], fields[2], False]
    except urllib.error.URLError as e:
        print(f&#34;Warning: Could not load source manifest from URL. Attempting to load from local path. Error: {e}&#34;)
        # If not remote, assume it&#39;s a local file path
        try:
            with open(os.path.join(sourceManifestLocation, sourceManifestName)) as s_man:
                source = os.path.join(sourceManifestLocation) + os.path.sep
                for line in s_man:
                    if line.startswith(&#34;#&#34;):
                        s_type = self.getManType(line)
                        print(f&#34;Source manifest type: {s_type}&#34;)
                        if s_type != l_type:
                            print(f&#34;Error: Type of source manifest ({s_type}) does not match type of local manifest ({l_type}).&#34;)
                            return (None, None, None, None, None)
                        continue
                    fields = line.rstrip().split(&#34;\t&#34;)
                    if len(fields) &gt;= 3:
                        source_man[fields[0]] = [fields[1], fields[2], False]
        except FileNotFoundError:
            print(f&#34;Error: Source manifest &#39;{sourceManifestName}&#39; not found in &#39;{sourceManifestLocation}&#39;.&#34;)
            return (None, None, None, None, None)

    print(f&#34;Loaded {len(source_man)} entries from source manifest.&#34;)

    # Keep lists of modifications
    deleted = []
    addedDirs = []
    addedFiles = []
    modified = []

    try:
        with open(os.path.join(localManifestLocation, localManifestName)) as l_man:
            for line in l_man:
                if line.startswith(&#34;#&#34;):
                    continue
                fields = line.rstrip().split(&#34;\t&#34;)
                if len(fields) &lt; 3:
                    continue
                path, hashd, size = fields[0], fields[1], fields[2]
                if path in source_man:
                    if source_man[path][0] != hashd:
                        # Hashes don&#39;t match
                        modified.append(path)
                    # Mark as seen
                    source_man[path][2] = True
                else:
                    # File has been deleted from the source manifest
                    deleted.append(path)
    except FileNotFoundError:
        print(f&#34;Error: Local manifest &#39;{localManifestName}&#39; not found in &#39;{localManifestLocation}&#39;.&#34;)
        return (None, None, None, None, None)

    # Check for new files
    for f in list(source_man.keys()):
        if not source_man[f][2]:
            if source_man[f][0] == &#39;-&#39;:
                addedDirs.append(f)
            else:
                addedFiles.append(f)

    print(f&#34;Diff Results - Added Files: {len(addedFiles)}, Added Dirs: {len(addedDirs)}, Deleted Files: {len(deleted)}, Modified Files: {len(modified)}&#34;)

    if printDiffs:
        new_size = 0
        modified_size = 0
        for f in addedFiles:
            try:
                new_size += int(source_man[f][1])
            except ValueError:
                pass
        for f in modified:
            try:
                modified_size += int(source_man[f][1])
            except ValueError:
                pass

        if addedFiles:
            print(&#34;#------------------------------------------------------&#34;)
            print(f&#34;# Source contains {len(addedFiles)} new file(s) ({self.formatData(new_size)})&#34;)
            for f in addedFiles:
                print(&#34;\t&#34;.join([self.formatData(int(source_man[f][1])), f]))

        if addedDirs:
            print(&#34;#------------------------------------------------------&#34;)
            print(f&#34;# Source contains {len(addedDirs)} new folder(s)&#34;)
            for f in addedDirs:
                print(f)

        if modified:
            print(&#34;#------------------------------------------------------&#34;)
            print(f&#34;# Source contains {len(modified)} modified file(s) ({self.formatData(modified_size)})&#34;)
            for f in modified:
                print(f)

        if deleted:
            print(&#34;#------------------------------------------------------&#34;)
            print(f&#34;# {len(deleted)} file(s) have been deleted in the source:&#34;)
            for f in deleted:
                print(f)
    else:
        return (source,
                [(a, source_man[a]) for a in addedFiles],
                [(a, source_man[a]) for a in addedDirs],
                deleted,
                [(m, source_man[m]) for m in modified])</code></pre>
</details>
</dd>
<dt id="generate_manifest.ManifestManager.formatData"><code class="name flex">
<span>def <span class="ident">formatData</span></span>(<span>self, amount)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty print file sizes into human-readable formats.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>Size in bytes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Formatted size string (e.g., "10 MB").</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatData(self, amount):
    &#34;&#34;&#34;
    Pretty print file sizes into human-readable formats.

    Args:
        amount (int): Size in bytes.

    Returns:
        str: Formatted size string (e.g., &#34;10 MB&#34;).
    &#34;&#34;&#34;
    try:
        amount = int(amount)
    except (ValueError, TypeError):
        return &#34;0 B&#34;
    if amount &lt; 1024*1024:
        return f&#34;{amount} B&#34;
    elif amount &lt; 1024*1024*1024:
        return f&#34;{amount / (1024*1024):.2f} MB&#34;
    elif amount &lt; 1024*1024*1024*1024:
        return f&#34;{amount / (1024*1024*1024):.2f} GB&#34;
    elif amount &lt; 1024*1024*1024*1024*1024:
        return f&#34;{amount / (1024*1024*1024*1024):.2f} TB&#34;
    else:
        return f&#34;{amount / (1024*1024*1024*1024*1024):.2f} PB&#34;</code></pre>
</details>
</dd>
<dt id="generate_manifest.ManifestManager.getManType"><code class="name flex">
<span>def <span class="ident">getManType</span></span>(<span>self, line)</span>
</code></dt>
<dd>
<div class="desc"><p>Work out the manifest type from the first line of the file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>line</code></strong> :&ensp;<code>str</code></dt>
<dd>A line from the manifest file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The extracted manifest type. Defaults to "generic" if extraction fails.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getManType(self, line):
    &#34;&#34;&#34;
    Work out the manifest type from the first line of the file.

    Args:
        line (str): A line from the manifest file.

    Returns:
        str: The extracted manifest type. Defaults to &#34;generic&#34; if extraction fails.
    &#34;&#34;&#34;
    try:
        return line.rstrip().split(&#34;:::&#34;)[1].strip()
    except IndexError:
        return &#34;generic&#34;</code></pre>
</details>
</dd>
<dt id="generate_manifest.ManifestManager.hashfile"><code class="name flex">
<span>def <span class="ident">hashfile</span></span>(<span>self, fileName, blocksize=65536)</span>
</code></dt>
<dd>
<div class="desc"><p>Hashes a file and returns its SHA-256 digest.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fileName</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file to hash.</dd>
<dt><strong><code>blocksize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Size of each read from the file. Defaults to 65536.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The SHA-256 hash of the file. Returns "?" if hashing fails.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hashfile(self, fileName, blocksize=65536):
    &#34;&#34;&#34;
    Hashes a file and returns its SHA-256 digest.

    Args:
        fileName (str): Path to the file to hash.
        blocksize (int, optional): Size of each read from the file. Defaults to 65536.

    Returns:
        str: The SHA-256 hash of the file. Returns &#34;?&#34; if hashing fails.
    &#34;&#34;&#34;
    hasher = hashlib.sha256()
    try:
        with open(fileName, &#34;rb&#34;) as fh:
            buf = fh.read(blocksize)
            while len(buf) &gt; 0:
                hasher.update(buf.strip())
                buf = fh.read(blocksize)
            return hasher.hexdigest()
    except FileNotFoundError:
        print(f&#34;Warning: File not found during hashing: {fileName}&#34;)
        return &#34;?&#34;
    except Exception as e:
        print(f&#34;Error hashing file {fileName}: {e}&#34;)
        return &#34;?&#34;</code></pre>
</details>
</dd>
<dt id="generate_manifest.ManifestManager.listdir"><code class="name flex">
<span>def <span class="ident">listdir</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Lists directories, files, and symbolic links within a specified path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory path to list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Three lists containing directories, files, and symbolic links respectively.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def listdir(self, path):
    &#34;&#34;&#34;
    Lists directories, files, and symbolic links within a specified path.

    Args:
        path (str): The directory path to list.

    Returns:
        tuple: Three lists containing directories, files, and symbolic links respectively.
    &#34;&#34;&#34;
    dirs, files, links = [], [], []
    try:
        for name in os.listdir(path):
            path_name = os.path.join(path, name)
            if os.path.isdir(path_name):
                dirs.append(name)
            elif os.path.isfile(path_name):
                files.append(name)
            elif os.path.islink(path_name):
                links.append(name)
    except PermissionError as e:
        print(f&#34;Permission denied accessing &#39;{path}&#39;: {e}&#34;)
    except Exception as e:
        print(f&#34;Error accessing &#39;{path}&#39;: {e}&#34;)
    return dirs, files, links</code></pre>
</details>
</dd>
<dt id="generate_manifest.ManifestManager.makeSurePathExists"><code class="name flex">
<span>def <span class="ident">makeSurePathExists</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensures that a specified directory path exists, creating it if necessary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The directory path to verify or create.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeSurePathExists(self, path):
    &#34;&#34;&#34;
    Ensures that a specified directory path exists, creating it if necessary.

    Args:
        path (str): The directory path to verify or create.
    &#34;&#34;&#34;
    try:
        os.makedirs(path)
        print(f&#34;Directory created: {path}&#34;)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise
        else:
            print(f&#34;Directory already exists: {path}&#34;)</code></pre>
</details>
</dd>
<dt id="generate_manifest.ManifestManager.promptUserDownload"><code class="name flex">
<span>def <span class="ident">promptUserDownload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prompts the user for confirmation before proceeding with downloading updates.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>
<ul>
<li><code>True</code> if the user confirms.</li>
<li><code>False</code> otherwise.</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def promptUserDownload(self):
    &#34;&#34;&#34;
    Prompts the user for confirmation before proceeding with downloading updates.

    Returns:
        bool: 
            - `True` if the user confirms.
            - `False` otherwise.
    &#34;&#34;&#34;
    input_not_ok = True
    minimal = False
    valid_responses = {&#39;Y&#39;: True, &#39;N&#39;: False}
    vrs = &#34;,&#34;.join([x.lower() for x in list(valid_responses.keys())])
    while input_not_ok:
        if minimal:
            option = input(f&#34;Download? ({vrs}) : &#34;).upper()
        else:
            option = input(f&#34;Confirm you want to download this data\n&#34;
                           f&#34;Changes *WILL* be permanent\n&#34;
                           f&#34;Continue? ({vrs}) : &#34;).upper()
        if option in valid_responses:
            print(&#34;****************************************************************&#34;)
            return valid_responses[option]
        else:
            print(f&#34;ERROR: unrecognised choice &#39;{option}&#39;&#34;)
            minimal = True</code></pre>
</details>
</dd>
<dt id="generate_manifest.ManifestManager.updateManifest"><code class="name flex">
<span>def <span class="ident">updateManifest</span></span>(<span>self, localManifestLocation, sourceManifestLocation, localManifestName=None, sourceManifestName=None, prompt=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Update local files based on remote changes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>localManifestLocation</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the local manifest directory.</dd>
<dt><strong><code>sourceManifestLocation</code></strong> :&ensp;<code>str</code></dt>
<dd>Path or URL to the source manifest location.</dd>
<dt><strong><code>localManifestName</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the local manifest file. Defaults to ".dmanifest".</dd>
<dt><strong><code>sourceManifestName</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the source manifest file. Defaults to ".dmanifest".</dd>
<dt><strong><code>prompt</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag to prompt the user before downloading updates. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>
<ul>
<li><code>True</code> if the update was successful.</li>
<li><code>False</code> otherwise.</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateManifest(self,
                   localManifestLocation,
                   sourceManifestLocation,
                   localManifestName=None,
                   sourceManifestName=None,
                   prompt=True):
    &#34;&#34;&#34;
    Update local files based on remote changes.

    Args:
        localManifestLocation (str): Path to the local manifest directory.
        sourceManifestLocation (str): Path or URL to the source manifest location.
        localManifestName (str, optional): Name of the local manifest file. Defaults to &#34;.dmanifest&#34;.
        sourceManifestName (str, optional): Name of the source manifest file. Defaults to &#34;.dmanifest&#34;.
        prompt (bool, optional): Flag to prompt the user before downloading updates. Defaults to True.

    Returns:
        bool: 
            - `True` if the update was successful.
            - `False` otherwise.
    &#34;&#34;&#34;
    # Get the diffs
    diff = self.diffManifests(localManifestLocation,
                              sourceManifestLocation,
                              localManifestName,
                              sourceManifestName,
                              printDiffs=False)
    source, added_files, added_dirs, deleted, modified = diff

    # Bail if the diff failed
    if source is None:
        return False

    # No changes by default
    do_down = False
    if prompt:
        total_size = 0
        for f in added_files:
            try:
                total_size += int(f[1][1])
            except ValueError:
                pass
        for f in modified:
            try:
                total_size += int(f[1][1])
            except ValueError:
                pass
        if total_size != 0:
            print(&#34;****************************************************************&#34;)
            print(f&#34;{len(added_files)} new file(s) to be downloaded from source&#34;)
            print(f&#34;{len(modified)} existing file(s) to be updated&#34;)
            print(f&#34;{self.formatData(total_size)} will need to be downloaded&#34;)
            do_down = self.promptUserDownload()
            if not do_down:
                print(&#34;Download aborted&#34;)

    update_manifest = False
    if do_down:
        update_manifest = True
        for add in added_dirs:
            # Make the dirs first
            full_path = os.path.abspath(os.path.join(localManifestLocation, add[0]))
            print(f&#34;Creating directory: {full_path}&#34;)
            self.makeSurePathExists(full_path)
        for add in added_files:
            full_path = os.path.abspath(os.path.join(localManifestLocation, add[0]))
            print(f&#34;Downloading new file: {add[0]} -&gt; {full_path}&#34;)
            try:
                urllib.request.urlretrieve(source + add[0], full_path)
            except Exception as e:
                print(f&#34;Error downloading {add[0]}: {e}&#34;)
        for modify in modified:
            full_path = os.path.abspath(os.path.join(localManifestLocation, modify[0]))
            print(f&#34;Updating existing file: {modify[0]} -&gt; {full_path}&#34;)
            try:
                urllib.request.urlretrieve(source + modify[0], full_path)
            except Exception as e:
                print(f&#34;Error updating {modify[0]}: {e}&#34;)

    if update_manifest:
        print(&#34;(Re)creating manifest file (please be patient)&#34;)
        self.createManifest(localManifestLocation, manifestName=localManifestName)
        
    return True</code></pre>
</details>
</dd>
<dt id="generate_manifest.ManifestManager.walk"><code class="name flex">
<span>def <span class="ident">walk</span></span>(<span>self, parents, full_path, rel_path, dirs, files, skipFile='.dmanifest', exclude_dirs=None, exclude_files=None, extensions=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively walks through the directory tree to catalog files and directories.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parents</code></strong> :&ensp;<code>list</code> of <code><a title="generate_manifest.FileEntity" href="#generate_manifest.FileEntity">FileEntity</a></code></dt>
<dd>Stack of parent directories.</dd>
<dt><strong><code>full_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Absolute path to the current directory.</dd>
<dt><strong><code>rel_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Relative path from the root.</dd>
<dt><strong><code>dirs</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of directories in the current path.</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of files in the current path.</dd>
<dt><strong><code>skipFile</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File to skip (e.g., the manifest file itself). Defaults to ".dmanifest".</dd>
<dt><strong><code>exclude_dirs</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>List of directories to exclude.</dd>
<dt><strong><code>exclude_files</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>List of files to exclude.</dd>
<dt><strong><code>extensions</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>List of file extensions to include.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk(self, parents, full_path, rel_path, dirs, files, skipFile=&#34;.dmanifest&#34;, exclude_dirs=None, exclude_files=None, extensions=None):
    &#34;&#34;&#34;
    Recursively walks through the directory tree to catalog files and directories.

    Args:
        parents (list of FileEntity): Stack of parent directories.
        full_path (str): Absolute path to the current directory.
        rel_path (str): Relative path from the root.
        dirs (list of str): List of directories in the current path.
        files (list of str): List of files in the current path.
        skipFile (str, optional): File to skip (e.g., the manifest file itself). Defaults to &#34;.dmanifest&#34;.
        exclude_dirs (list of str, optional): List of directories to exclude.
        exclude_files (list of str, optional): List of files to exclude.
        extensions (list of str, optional): List of file extensions to include.
    &#34;&#34;&#34;
    print(f&#34;Entering directory: {full_path}&#34;)
    # First do files here
    for f in files:
        if (f != skipFile) and (not extensions or os.path.splitext(f)[1] in extensions):
            if exclude_files and f in exclude_files:
                print(f&#34;Excluding file: {os.path.join(rel_path, f)}&#34;)
                continue
            path = os.path.join(full_path, f)
            print(f&#34;Adding file: {path}&#34;)
            self.files.append(FileEntity(f, rel_path, parents[-1], self.hashfile(path), os.path.getsize(path)))
    for d in dirs:
        if exclude_dirs and d in exclude_dirs:
            print(f&#34;Excluding directory: {os.path.join(rel_path, d)}&#34;)
            continue
        # The walk will go into these dirs first
        tmp_fe = FileEntity(d, rel_path, parents[-1], &#34;-&#34;, 0)
        print(f&#34;Adding directory: {os.path.join(rel_path, d)}&#34;)
        self.files.append(tmp_fe)
        parents.append(tmp_fe)
        new_full_path = os.path.join(full_path, d)
        new_rel_path = os.path.join(rel_path, d)
        new_dirs, new_files, _ = self.listdir(new_full_path)
        self.walk(parents, new_full_path, new_rel_path, new_dirs, new_files, skipFile=skipFile, exclude_dirs=exclude_dirs, exclude_files=exclude_files, extensions=extensions)
        parents.pop()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#goals">Goals:</a></li>
<li><a href="#usage">Usage:</a></li>
<li><a href="#example-commands">Example Commands:</a></li>
<li><a href="#dependencies">Dependencies:</a></li>
<li><a href="#author">Author:</a></li>
<li><a href="#license">License:</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="generate_manifest.main" href="#generate_manifest.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="generate_manifest.FileEntity" href="#generate_manifest.FileEntity">FileEntity</a></code></h4>
<ul class="">
<li><code><a title="generate_manifest.FileEntity.checkIntegrity" href="#generate_manifest.FileEntity.checkIntegrity">checkIntegrity</a></code></li>
<li><code><a title="generate_manifest.FileEntity.getFullPath" href="#generate_manifest.FileEntity.getFullPath">getFullPath</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="generate_manifest.ManifestManager" href="#generate_manifest.ManifestManager">ManifestManager</a></code></h4>
<ul class="two-column">
<li><code><a title="generate_manifest.ManifestManager.createManifest" href="#generate_manifest.ManifestManager.createManifest">createManifest</a></code></li>
<li><code><a title="generate_manifest.ManifestManager.diffManifests" href="#generate_manifest.ManifestManager.diffManifests">diffManifests</a></code></li>
<li><code><a title="generate_manifest.ManifestManager.formatData" href="#generate_manifest.ManifestManager.formatData">formatData</a></code></li>
<li><code><a title="generate_manifest.ManifestManager.getManType" href="#generate_manifest.ManifestManager.getManType">getManType</a></code></li>
<li><code><a title="generate_manifest.ManifestManager.hashfile" href="#generate_manifest.ManifestManager.hashfile">hashfile</a></code></li>
<li><code><a title="generate_manifest.ManifestManager.listdir" href="#generate_manifest.ManifestManager.listdir">listdir</a></code></li>
<li><code><a title="generate_manifest.ManifestManager.makeSurePathExists" href="#generate_manifest.ManifestManager.makeSurePathExists">makeSurePathExists</a></code></li>
<li><code><a title="generate_manifest.ManifestManager.promptUserDownload" href="#generate_manifest.ManifestManager.promptUserDownload">promptUserDownload</a></code></li>
<li><code><a title="generate_manifest.ManifestManager.updateManifest" href="#generate_manifest.ManifestManager.updateManifest">updateManifest</a></code></li>
<li><code><a title="generate_manifest.ManifestManager.walk" href="#generate_manifest.ManifestManager.walk">walk</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>