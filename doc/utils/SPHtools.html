<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>SPHtools API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SPHtools</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np


# %% packSPH
def packSPH(siz=5, r=0.5, typ=&#39;HCP&#39;):
    &#34;&#34;&#34;
    PACKSPH returns the HCP or FCC packing of siz spheres of radius r

    Args:
    siz: array_like, [5, 5, 5] number of spheres along x,y,z
         if siz is a scalar, the same siz is applied to all dimensions [siz, siz, siz]
    r: float, bead radius
    typ: str, optional, &#39;HCP&#39; (default, period 2) or &#39;FCC&#39; (period 3)

    Returns:
    X: array_like, [size(1) x size(2) x size(3)] x 3 centers


    Example:

        import matplotlib.pyplot as plt
        from utils.SPHtools import packSPH

        X = packSPH(5)

        fig = plt.figure()
        ax = fig.add_subplot(111, projection=&#39;3d&#39;)
        ax.scatter(X[:, 0], X[:, 1], X[:, 2], s=10, c=&#39;b&#39;, alpha=0.5)
        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)
        plt.show()

    &#34;&#34;&#34;
    # 2023-02-20 | INRAE\Olivier Vitrac, Han Chen | rev. 2023-02-21

    # arg check
    rdefault = 0.5
    typdefault = &#39;HCP&#39;
    sizedefault = 5

    if siz is None: siz = sizedefault
    if r is None: r = rdefault
    if typ == &#39;&#39;:typ = typdefault
    if np.size(siz) == 1:siz = np.array([siz, siz, siz])
    if len(siz) != 3: raise ValueError(&#39;siz must be 1x3 or 3x1 vector&#39;)
    if not isinstance(typ, str):raise TypeError(&#39;typ must be a char array&#39;)

    # flag
    forceFCC = 0 if typ.upper() == &#39;HCP&#39; else 1

    # Lattice
    i, j, k = np.mgrid[0:siz[0], 0:siz[1], 0:siz[2]]
    i, j, k = i.flatten(), j.flatten(), k.flatten()

    X = np.zeros((np.size(i), 3))
    X[:, 0] = 2 * i + np.mod(j + k, 2)
    X[:, 1] = np.sqrt(3) * (j + np.mod(k, 2) / 3) + (np.mod(k, 3) == 2) * forceFCC
    X[:, 2] = 2 * np.sqrt(6) * k / 3

    return r * X

# %% kernelSPH
def kernelSPH(h=None, typ=&#39;lucy&#39;, d=3):
    &#34;&#34;&#34;
    KERNELSPH return a SPH kernel

    Syntax:
        W = kernelSPH(h,typ,d)
    Inputs:
            h : cutoff
          typ : kernel name (default = Lucy)
            d : dimension
    Output:
            W : kernel function lambda r: ...

    Example:
        from utils.SPHtools import kernelSPH
        W = kernelSPH(1,&#39;lucy&#39;,3)

    See also: interp3SPH, interp2SPH, packSPH
    &#34;&#34;&#34;
    # 2023-02-20 | INRAE\Olivier Vitrac, Han Chen | rev. 2023-02-21

    # arg check
    if h is None:
        raise ValueError(&#39;Supply a value for h&#39;)
    if typ is None:
        typ = &#39;lucy&#39;
    if not isinstance(typ, str):
        raise ValueError(&#39;typ must be a string&#39;)
    if d is None:
        d = 3
    if d &lt; 2 or d &gt; 3:
        raise ValueError(&#39;d must be equal to 1, 2 or 3&#39;)

    # main
    if typ.lower() == &#39;lucy&#39;:

        if d == 3:
            # W = @(r) (r&lt;h) .* (1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi;
            W = lambda r, h=h: np.double(r &lt; h) * \
            (1.0/h**3 * (r/h - 1.0)**3 * ((r*3.0)/h + 1.0) * (-1.05e+2/1.6e+1) / np.pi)
        elif d == 2:
            #  W = @(r) (r&lt;h) .* (1.0./h.^2.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*-5.0)./pi;
            W = lambda r, h=h: np.double(r &lt; h) * \
            (1.0/h**2 * (r/h - 1.0)**3 * ((r*3.0)/h + 1.0) * (-5.0) / np.pi)

    elif typ.lower() == &#39;lucyder&#39;:
        if d == 3:
            # W = @(r) (r&lt;h) .* (1.0./h.^4.*(r./h-1.0).^3.*(-3.15e+2./1.6e+1))./pi-(1.0./h.^4.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*(3.15e+2./1.6e+1))./pi;
            W = lambda r,h=h: np.double(r &lt; h) * \
                (\
                1.0/h**4 * (r/h - 1.0)**3 * (-3.15e+2/1.6e+1) / np.pi \
                - 1.0/h**4 * (r/h - 1.0)**2 * ((r*3.0)/h + 1.0) * (3.15e+2/1.6e+1) / np.pi \
                )
        elif d == 2:
            # W = @(r) (r&lt;h) .* (1.0./h.^3.*(r./h-1.0).^3.*-1.5e+1)./pi-(1.0./h.^3.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*1.5e+1)./pi;
            W = lambda r,h=h: np.double(r &lt; h) * \
                ( \
                1.0/h**3 * (r/h - 1.0)**3 * (-1.5e+1) / np.pi
                - 1.0/h**3 * (r/h - 1.0)**2 * ((r*3.0)/h + 1.0) * (1.5e+1) / np.pi \
                )
        else:
            raise NotImplementedError(f&#34;the kernel &#39;{typ}&#39; is not implemented&#34;)

    return W


# %%interp3SPH

def interp3SPH(centers = packSPH(5),
               y = np.array([]),
               Xq =None,
               Yq =None,
               Zq =None,
               W = kernelSPH(1,&#39;lucy&#39;,3),
               V = np.array([])):

    &#34;&#34;&#34;
    INTERP3SPH interpolates y at Xq,Yq,Zq using the 3D kernel W centered on centers

   Syntax:
       Vq = interp3SPH(X,y,Xq,Yq,Zq [,W,V])

   Inputs:
     centers : kx3 coordinates of the kernel centers
           y : kxny values at X (m is the number of values associated with the same center)
               [] (empty matrix) forces a uniform density calculatoin
          Xq : array or matrix coordinates along X
          Yq : array or matrix coordinates along Y
          Zq : array or matrix coordinates along Z
           W : kernel function @(r) &lt;-- use kernelSPH() to supply a vectorized kernel
           V : kx1 volume of the kernels (default=1)
               [] (empty matrix) or scalar value forces uniform volumes (default =1)

   Output:
           Vq : same size as Xq, with an additional dimension if y was an array

    Example:  arbitrary field to be interpolated x+2*y-3*z

        import numpy as np
        import matplotlib.pyplot as plt
        from mpl_toolkits.mplot3d import Axes3D
        from scipy.interpolate import griddata

        from utils.SPHtools import interp3SPH


        r = 0.5
        h = 2*r
        XYZ = packSPH(5,r)
        W = kernelSPH(h,&#39;lucy&#39;,3)
        y = XYZ @ np.array([1,2,-3]).transpose()
        nresolution = 50
        xg = np.linspace(np.min(XYZ[:,0])-h,np.max(XYZ[:,0])+h,num=nresolution)
        yg = np.linspace(np.min(XYZ[:,1])-h,np.max(XYZ[:,1])+h,num=nresolution)
        zg = np.linspace(np.min(XYZ[:,2])-h,np.max(XYZ[:,2])+h,num=nresolution)
        Xg,Yg,Zg = np.meshgrid(xg,yg,zg)
        Vg = interp3SPH(XYZ,y,Xg,Yg,Zg,W)

        # projection along y,z
        fig = plt.figure()
        ax = fig.add_subplot(111)
        ax.plot(Xg[1,:,1],np.mean(Vg,axis=(0,2),keepdims=False),color=&#39;red&#39;,marker=&#39;o&#39;)

        # unvalidated code for voxels
        fig = plt.figure()
        cmap = plt.cm.get_cmap(&#34;RdPu_r&#34;, 64)
        ax = fig.add_subplot(111, projection=&#39;3d&#39;)
        ax.set_box_aspect([1,1,1]) # set aspect ratio of the 3D plot
        hs = ax.contour(Xg, Yg, Zg, Vg, 10, cmap=cmap) # not working
        fig.colorbar(hs, ax=ax)
        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)
        plt.show()

   See also: interp2SPH, kernelSPH, packSPH

    &#34;&#34;&#34;

    # 2023-02-20 | INRAE\Olivier Vitrac, Han Chen | rev. 2023-02-21

    # arg check
    if isinstance(centers,list): centers = np.array(centers)
    k,d = centers.shape
    ky,ny = np.shape(y) if np.ndim(y)&gt;1 else (np.size(y),1)
    kv = np.size(V)
    if k==0: raise ValueError(&#39;please supply some centers&#39;)
    if d != 3: raise ValueError(&#39;3 dimensions (columns) are required&#39;)
    if ky*ny==0: y = np.ones(k,1); ky=k; ny=1;
    if ky != k: raise ValueError(f&#39;the number of y values ({ky}) does not match the number of kernels ({k})&#39;)
    if Xq.shape != Yq.shape  or Yq.shape != Zq.shape: raise ValueError(&#39;Xq,Yq and Zq do not have compatible sizes&#39;)
    if kv==0:  V=1;  kv=1;
    if kv==1: V = np.ones([k,1])*V; kv=k;
    if kv!=k: raise ValueError(f&#39;the number of V values ({kv}) does not match the number of kernels ({k})&#39;)

    # main
    sumW = [];
    verbosity = np.size(Xq)&gt;1e4;
    for i in range(k):
        # initialization if needed
        if i==0:
            for iy in range(ny):
                sumW.append(np.zeros(np.shape(Xq),dtype=Xq.dtype))
        # interpolation
        if verbosity:print(f&#39;interpolate respectively to kernel {i} of {k}&#39;)
        R = np.sqrt( (Xq-centers[i,0])**2 + \
                     (Yq-centers[i,1])**2 + \
                     (Zq-centers[i,2])**2 )
        if np.ndim(y)==1:
            sumW[0] = sumW[0] + y[i] * V[i] * W(R);
        else:
            for iy in range(ny):
                sumW[iy] = sumW[iy] + y[i,iy] * V[i] * W(R);

    # output (data unfolding)
    if ny==1:
        return sumW[0];
    else:
        return np.stack(sumW,axis=Xq.ndim)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="SPHtools.interp3SPH"><code class="name flex">
<span>def <span class="ident">interp3SPH</span></span>(<span>centers=array([[0.
, 0.
, 0.
],
[0.5
, 0.28867513, 0.81649658],
[0.
, 0.
, 1.63299316],
[0.5
, 0.28867513, 2.44948974],
[0.
, 0.
, 3.26598632],
[0.5
, 0.8660254 , 0.
],
[0.
, 1.15470054, 0.81649658],
[0.5
, 0.8660254 , 1.63299316],
[0.
, 1.15470054, 2.44948974],
[0.5
, 0.8660254 , 3.26598632],
[0.
, 1.73205081, 0.
],
[0.5
, 2.02072594, 0.81649658],
[0.
, 1.73205081, 1.63299316],
[0.5
, 2.02072594, 2.44948974],
[0.
, 1.73205081, 3.26598632],
[0.5
, 2.59807621, 0.
],
[0.
, 2.88675135, 0.81649658],
[0.5
, 2.59807621, 1.63299316],
[0.
, 2.88675135, 2.44948974],
[0.5
, 2.59807621, 3.26598632],
[0.
, 3.46410162, 0.
],
[0.5
, 3.75277675, 0.81649658],
[0.
, 3.46410162, 1.63299316],
[0.5
, 3.75277675, 2.44948974],
[0.
, 3.46410162, 3.26598632],
[1.
, 0.
, 0.
],
[1.5
, 0.28867513, 0.81649658],
[1.
, 0.
, 1.63299316],
[1.5
, 0.28867513, 2.44948974],
[1.
, 0.
, 3.26598632],
[1.5
, 0.8660254 , 0.
],
[1.
, 1.15470054, 0.81649658],
[1.5
, 0.8660254 , 1.63299316],
[1.
, 1.15470054, 2.44948974],
[1.5
, 0.8660254 , 3.26598632],
[1.
, 1.73205081, 0.
],
[1.5
, 2.02072594, 0.81649658],
[1.
, 1.73205081, 1.63299316],
[1.5
, 2.02072594, 2.44948974],
[1.
, 1.73205081, 3.26598632],
[1.5
, 2.59807621, 0.
],
[1.
, 2.88675135, 0.81649658],
[1.5
, 2.59807621, 1.63299316],
[1.
, 2.88675135, 2.44948974],
[1.5
, 2.59807621, 3.26598632],
[1.
, 3.46410162, 0.
],
[1.5
, 3.75277675, 0.81649658],
[1.
, 3.46410162, 1.63299316],
[1.5
, 3.75277675, 2.44948974],
[1.
, 3.46410162, 3.26598632],
[2.
, 0.
, 0.
],
[2.5
, 0.28867513, 0.81649658],
[2.
, 0.
, 1.63299316],
[2.5
, 0.28867513, 2.44948974],
[2.
, 0.
, 3.26598632],
[2.5
, 0.8660254 , 0.
],
[2.
, 1.15470054, 0.81649658],
[2.5
, 0.8660254 , 1.63299316],
[2.
, 1.15470054, 2.44948974],
[2.5
, 0.8660254 , 3.26598632],
[2.
, 1.73205081, 0.
],
[2.5
, 2.02072594, 0.81649658],
[2.
, 1.73205081, 1.63299316],
[2.5
, 2.02072594, 2.44948974],
[2.
, 1.73205081, 3.26598632],
[2.5
, 2.59807621, 0.
],
[2.
, 2.88675135, 0.81649658],
[2.5
, 2.59807621, 1.63299316],
[2.
, 2.88675135, 2.44948974],
[2.5
, 2.59807621, 3.26598632],
[2.
, 3.46410162, 0.
],
[2.5
, 3.75277675, 0.81649658],
[2.
, 3.46410162, 1.63299316],
[2.5
, 3.75277675, 2.44948974],
[2.
, 3.46410162, 3.26598632],
[3.
, 0.
, 0.
],
[3.5
, 0.28867513, 0.81649658],
[3.
, 0.
, 1.63299316],
[3.5
, 0.28867513, 2.44948974],
[3.
, 0.
, 3.26598632],
[3.5
, 0.8660254 , 0.
],
[3.
, 1.15470054, 0.81649658],
[3.5
, 0.8660254 , 1.63299316],
[3.
, 1.15470054, 2.44948974],
[3.5
, 0.8660254 , 3.26598632],
[3.
, 1.73205081, 0.
],
[3.5
, 2.02072594, 0.81649658],
[3.
, 1.73205081, 1.63299316],
[3.5
, 2.02072594, 2.44948974],
[3.
, 1.73205081, 3.26598632],
[3.5
, 2.59807621, 0.
],
[3.
, 2.88675135, 0.81649658],
[3.5
, 2.59807621, 1.63299316],
[3.
, 2.88675135, 2.44948974],
[3.5
, 2.59807621, 3.26598632],
[3.
, 3.46410162, 0.
],
[3.5
, 3.75277675, 0.81649658],
[3.
, 3.46410162, 1.63299316],
[3.5
, 3.75277675, 2.44948974],
[3.
, 3.46410162, 3.26598632],
[4.
, 0.
, 0.
],
[4.5
, 0.28867513, 0.81649658],
[4.
, 0.
, 1.63299316],
[4.5
, 0.28867513, 2.44948974],
[4.
, 0.
, 3.26598632],
[4.5
, 0.8660254 , 0.
],
[4.
, 1.15470054, 0.81649658],
[4.5
, 0.8660254 , 1.63299316],
[4.
, 1.15470054, 2.44948974],
[4.5
, 0.8660254 , 3.26598632],
[4.
, 1.73205081, 0.
],
[4.5
, 2.02072594, 0.81649658],
[4.
, 1.73205081, 1.63299316],
[4.5
, 2.02072594, 2.44948974],
[4.
, 1.73205081, 3.26598632],
[4.5
, 2.59807621, 0.
],
[4.
, 2.88675135, 0.81649658],
[4.5
, 2.59807621, 1.63299316],
[4.
, 2.88675135, 2.44948974],
[4.5
, 2.59807621, 3.26598632],
[4.
, 3.46410162, 0.
],
[4.5
, 3.75277675, 0.81649658],
[4.
, 3.46410162, 1.63299316],
[4.5
, 3.75277675, 2.44948974],
[4.
, 3.46410162, 3.26598632]]), y=array([], dtype=float64), Xq=None, Yq=None, Zq=None, W=&lt;function kernelSPH.&lt;locals&gt;.&lt;lambda&gt;&gt;, V=array([], dtype=float64))</span>
</code></dt>
<dd>
<div class="desc"><p>INTERP3SPH interpolates y at Xq,Yq,Zq using the 3D kernel W centered on centers</p>
<h2 id="syntax">Syntax</h2>
<p>Vq = interp3SPH(X,y,Xq,Yq,Zq [,W,V])</p>
<h2 id="inputs">Inputs</h2>
<p>centers : kx3 coordinates of the kernel centers
y : kxny values at X (m is the number of values associated with the same center)
[] (empty matrix) forces a uniform density calculatoin
Xq : array or matrix coordinates along X
Yq : array or matrix coordinates along Y
Zq : array or matrix coordinates along Z
W : kernel function @(r) &lt;&ndash; use kernelSPH() to supply a vectorized kernel
V : kx1 volume of the kernels (default=1)
[] (empty matrix) or scalar value forces uniform volumes (default =1)</p>
<h2 id="output">Output</h2>
<p>Vq : same size as Xq, with an additional dimension if y was an array</p>
<p>Example:
arbitrary field to be interpolated x+2<em>y-3</em>z</p>
<pre><code> import numpy as np
 import matplotlib.pyplot as plt
 from mpl_toolkits.mplot3d import Axes3D
 from scipy.interpolate import griddata

 from utils.SPHtools import interp3SPH


 r = 0.5
 h = 2*r
 XYZ = packSPH(5,r)
 W = kernelSPH(h,'lucy',3)
 y = XYZ @ np.array([1,2,-3]).transpose()
 nresolution = 50
 xg = np.linspace(np.min(XYZ[:,0])-h,np.max(XYZ[:,0])+h,num=nresolution)
 yg = np.linspace(np.min(XYZ[:,1])-h,np.max(XYZ[:,1])+h,num=nresolution)
 zg = np.linspace(np.min(XYZ[:,2])-h,np.max(XYZ[:,2])+h,num=nresolution)
 Xg,Yg,Zg = np.meshgrid(xg,yg,zg)
 Vg = interp3SPH(XYZ,y,Xg,Yg,Zg,W)

 # projection along y,z
 fig = plt.figure()
 ax = fig.add_subplot(111)
 ax.plot(Xg[1,:,1],np.mean(Vg,axis=(0,2),keepdims=False),color='red',marker='o')

 # unvalidated code for voxels
 fig = plt.figure()
 cmap = plt.cm.get_cmap("RdPu_r", 64)
 ax = fig.add_subplot(111, projection='3d')
 ax.set_box_aspect([1,1,1]) # set aspect ratio of the 3D plot
 hs = ax.contour(Xg, Yg, Zg, Vg, 10, cmap=cmap) # not working
 fig.colorbar(hs, ax=ax)
 ax.set_xlabel('X')
 ax.set_ylabel('Y')
 ax.set_zlabel('Z')
 plt.show()
</code></pre>
<p>See also: interp2SPH, kernelSPH, packSPH</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp3SPH(centers = packSPH(5),
               y = np.array([]),
               Xq =None,
               Yq =None,
               Zq =None,
               W = kernelSPH(1,&#39;lucy&#39;,3),
               V = np.array([])):

    &#34;&#34;&#34;
    INTERP3SPH interpolates y at Xq,Yq,Zq using the 3D kernel W centered on centers

   Syntax:
       Vq = interp3SPH(X,y,Xq,Yq,Zq [,W,V])

   Inputs:
     centers : kx3 coordinates of the kernel centers
           y : kxny values at X (m is the number of values associated with the same center)
               [] (empty matrix) forces a uniform density calculatoin
          Xq : array or matrix coordinates along X
          Yq : array or matrix coordinates along Y
          Zq : array or matrix coordinates along Z
           W : kernel function @(r) &lt;-- use kernelSPH() to supply a vectorized kernel
           V : kx1 volume of the kernels (default=1)
               [] (empty matrix) or scalar value forces uniform volumes (default =1)

   Output:
           Vq : same size as Xq, with an additional dimension if y was an array

    Example:  arbitrary field to be interpolated x+2*y-3*z

        import numpy as np
        import matplotlib.pyplot as plt
        from mpl_toolkits.mplot3d import Axes3D
        from scipy.interpolate import griddata

        from utils.SPHtools import interp3SPH


        r = 0.5
        h = 2*r
        XYZ = packSPH(5,r)
        W = kernelSPH(h,&#39;lucy&#39;,3)
        y = XYZ @ np.array([1,2,-3]).transpose()
        nresolution = 50
        xg = np.linspace(np.min(XYZ[:,0])-h,np.max(XYZ[:,0])+h,num=nresolution)
        yg = np.linspace(np.min(XYZ[:,1])-h,np.max(XYZ[:,1])+h,num=nresolution)
        zg = np.linspace(np.min(XYZ[:,2])-h,np.max(XYZ[:,2])+h,num=nresolution)
        Xg,Yg,Zg = np.meshgrid(xg,yg,zg)
        Vg = interp3SPH(XYZ,y,Xg,Yg,Zg,W)

        # projection along y,z
        fig = plt.figure()
        ax = fig.add_subplot(111)
        ax.plot(Xg[1,:,1],np.mean(Vg,axis=(0,2),keepdims=False),color=&#39;red&#39;,marker=&#39;o&#39;)

        # unvalidated code for voxels
        fig = plt.figure()
        cmap = plt.cm.get_cmap(&#34;RdPu_r&#34;, 64)
        ax = fig.add_subplot(111, projection=&#39;3d&#39;)
        ax.set_box_aspect([1,1,1]) # set aspect ratio of the 3D plot
        hs = ax.contour(Xg, Yg, Zg, Vg, 10, cmap=cmap) # not working
        fig.colorbar(hs, ax=ax)
        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)
        plt.show()

   See also: interp2SPH, kernelSPH, packSPH

    &#34;&#34;&#34;

    # 2023-02-20 | INRAE\Olivier Vitrac, Han Chen | rev. 2023-02-21

    # arg check
    if isinstance(centers,list): centers = np.array(centers)
    k,d = centers.shape
    ky,ny = np.shape(y) if np.ndim(y)&gt;1 else (np.size(y),1)
    kv = np.size(V)
    if k==0: raise ValueError(&#39;please supply some centers&#39;)
    if d != 3: raise ValueError(&#39;3 dimensions (columns) are required&#39;)
    if ky*ny==0: y = np.ones(k,1); ky=k; ny=1;
    if ky != k: raise ValueError(f&#39;the number of y values ({ky}) does not match the number of kernels ({k})&#39;)
    if Xq.shape != Yq.shape  or Yq.shape != Zq.shape: raise ValueError(&#39;Xq,Yq and Zq do not have compatible sizes&#39;)
    if kv==0:  V=1;  kv=1;
    if kv==1: V = np.ones([k,1])*V; kv=k;
    if kv!=k: raise ValueError(f&#39;the number of V values ({kv}) does not match the number of kernels ({k})&#39;)

    # main
    sumW = [];
    verbosity = np.size(Xq)&gt;1e4;
    for i in range(k):
        # initialization if needed
        if i==0:
            for iy in range(ny):
                sumW.append(np.zeros(np.shape(Xq),dtype=Xq.dtype))
        # interpolation
        if verbosity:print(f&#39;interpolate respectively to kernel {i} of {k}&#39;)
        R = np.sqrt( (Xq-centers[i,0])**2 + \
                     (Yq-centers[i,1])**2 + \
                     (Zq-centers[i,2])**2 )
        if np.ndim(y)==1:
            sumW[0] = sumW[0] + y[i] * V[i] * W(R);
        else:
            for iy in range(ny):
                sumW[iy] = sumW[iy] + y[i,iy] * V[i] * W(R);

    # output (data unfolding)
    if ny==1:
        return sumW[0];
    else:
        return np.stack(sumW,axis=Xq.ndim)</code></pre>
</details>
</dd>
<dt id="SPHtools.kernelSPH"><code class="name flex">
<span>def <span class="ident">kernelSPH</span></span>(<span>h=None, typ='lucy', d=3)</span>
</code></dt>
<dd>
<div class="desc"><p>KERNELSPH return a SPH kernel</p>
<h2 id="syntax">Syntax</h2>
<p>W = kernelSPH(h,typ,d)</p>
<h2 id="inputs">Inputs</h2>
<p>h : cutoff
typ : kernel name (default = Lucy)
d : dimension</p>
<h2 id="output">Output</h2>
<p>W : kernel function lambda r: &hellip;</p>
<h2 id="example">Example</h2>
<p>from utils.SPHtools import kernelSPH
W = kernelSPH(1,'lucy',3)</p>
<p>See also: interp3SPH, interp2SPH, packSPH</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kernelSPH(h=None, typ=&#39;lucy&#39;, d=3):
    &#34;&#34;&#34;
    KERNELSPH return a SPH kernel

    Syntax:
        W = kernelSPH(h,typ,d)
    Inputs:
            h : cutoff
          typ : kernel name (default = Lucy)
            d : dimension
    Output:
            W : kernel function lambda r: ...

    Example:
        from utils.SPHtools import kernelSPH
        W = kernelSPH(1,&#39;lucy&#39;,3)

    See also: interp3SPH, interp2SPH, packSPH
    &#34;&#34;&#34;
    # 2023-02-20 | INRAE\Olivier Vitrac, Han Chen | rev. 2023-02-21

    # arg check
    if h is None:
        raise ValueError(&#39;Supply a value for h&#39;)
    if typ is None:
        typ = &#39;lucy&#39;
    if not isinstance(typ, str):
        raise ValueError(&#39;typ must be a string&#39;)
    if d is None:
        d = 3
    if d &lt; 2 or d &gt; 3:
        raise ValueError(&#39;d must be equal to 1, 2 or 3&#39;)

    # main
    if typ.lower() == &#39;lucy&#39;:

        if d == 3:
            # W = @(r) (r&lt;h) .* (1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi;
            W = lambda r, h=h: np.double(r &lt; h) * \
            (1.0/h**3 * (r/h - 1.0)**3 * ((r*3.0)/h + 1.0) * (-1.05e+2/1.6e+1) / np.pi)
        elif d == 2:
            #  W = @(r) (r&lt;h) .* (1.0./h.^2.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*-5.0)./pi;
            W = lambda r, h=h: np.double(r &lt; h) * \
            (1.0/h**2 * (r/h - 1.0)**3 * ((r*3.0)/h + 1.0) * (-5.0) / np.pi)

    elif typ.lower() == &#39;lucyder&#39;:
        if d == 3:
            # W = @(r) (r&lt;h) .* (1.0./h.^4.*(r./h-1.0).^3.*(-3.15e+2./1.6e+1))./pi-(1.0./h.^4.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*(3.15e+2./1.6e+1))./pi;
            W = lambda r,h=h: np.double(r &lt; h) * \
                (\
                1.0/h**4 * (r/h - 1.0)**3 * (-3.15e+2/1.6e+1) / np.pi \
                - 1.0/h**4 * (r/h - 1.0)**2 * ((r*3.0)/h + 1.0) * (3.15e+2/1.6e+1) / np.pi \
                )
        elif d == 2:
            # W = @(r) (r&lt;h) .* (1.0./h.^3.*(r./h-1.0).^3.*-1.5e+1)./pi-(1.0./h.^3.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*1.5e+1)./pi;
            W = lambda r,h=h: np.double(r &lt; h) * \
                ( \
                1.0/h**3 * (r/h - 1.0)**3 * (-1.5e+1) / np.pi
                - 1.0/h**3 * (r/h - 1.0)**2 * ((r*3.0)/h + 1.0) * (1.5e+1) / np.pi \
                )
        else:
            raise NotImplementedError(f&#34;the kernel &#39;{typ}&#39; is not implemented&#34;)

    return W</code></pre>
</details>
</dd>
<dt id="SPHtools.packSPH"><code class="name flex">
<span>def <span class="ident">packSPH</span></span>(<span>siz=5, r=0.5, typ='HCP')</span>
</code></dt>
<dd>
<div class="desc"><p>PACKSPH returns the HCP or FCC packing of siz spheres of radius r</p>
<p>Args:
siz: array_like, [5, 5, 5] number of spheres along x,y,z
if siz is a scalar, the same siz is applied to all dimensions [siz, siz, siz]
r: float, bead radius
typ: str, optional, 'HCP' (default, period 2) or 'FCC' (period 3)</p>
<p>Returns:
X: array_like, [size(1) x size(2) x size(3)] x 3 centers</p>
<h2 id="example">Example</h2>
<p>import matplotlib.pyplot as plt
from utils.SPHtools import packSPH</p>
<p>X = packSPH(5)</p>
<p>fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(X[:, 0], X[:, 1], X[:, 2], s=10, c='b', alpha=0.5)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
plt.show()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def packSPH(siz=5, r=0.5, typ=&#39;HCP&#39;):
    &#34;&#34;&#34;
    PACKSPH returns the HCP or FCC packing of siz spheres of radius r

    Args:
    siz: array_like, [5, 5, 5] number of spheres along x,y,z
         if siz is a scalar, the same siz is applied to all dimensions [siz, siz, siz]
    r: float, bead radius
    typ: str, optional, &#39;HCP&#39; (default, period 2) or &#39;FCC&#39; (period 3)

    Returns:
    X: array_like, [size(1) x size(2) x size(3)] x 3 centers


    Example:

        import matplotlib.pyplot as plt
        from utils.SPHtools import packSPH

        X = packSPH(5)

        fig = plt.figure()
        ax = fig.add_subplot(111, projection=&#39;3d&#39;)
        ax.scatter(X[:, 0], X[:, 1], X[:, 2], s=10, c=&#39;b&#39;, alpha=0.5)
        ax.set_xlabel(&#39;X&#39;)
        ax.set_ylabel(&#39;Y&#39;)
        ax.set_zlabel(&#39;Z&#39;)
        plt.show()

    &#34;&#34;&#34;
    # 2023-02-20 | INRAE\Olivier Vitrac, Han Chen | rev. 2023-02-21

    # arg check
    rdefault = 0.5
    typdefault = &#39;HCP&#39;
    sizedefault = 5

    if siz is None: siz = sizedefault
    if r is None: r = rdefault
    if typ == &#39;&#39;:typ = typdefault
    if np.size(siz) == 1:siz = np.array([siz, siz, siz])
    if len(siz) != 3: raise ValueError(&#39;siz must be 1x3 or 3x1 vector&#39;)
    if not isinstance(typ, str):raise TypeError(&#39;typ must be a char array&#39;)

    # flag
    forceFCC = 0 if typ.upper() == &#39;HCP&#39; else 1

    # Lattice
    i, j, k = np.mgrid[0:siz[0], 0:siz[1], 0:siz[2]]
    i, j, k = i.flatten(), j.flatten(), k.flatten()

    X = np.zeros((np.size(i), 3))
    X[:, 0] = 2 * i + np.mod(j + k, 2)
    X[:, 1] = np.sqrt(3) * (j + np.mod(k, 2) / 3) + (np.mod(k, 3) == 2) * forceFCC
    X[:, 2] = 2 * np.sqrt(6) * k / 3

    return r * X</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="SPHtools.interp3SPH" href="#SPHtools.interp3SPH">interp3SPH</a></code></li>
<li><code><a title="SPHtools.kernelSPH" href="#SPHtools.kernelSPH">kernelSPH</a></code></li>
<li><code><a title="SPHtools.packSPH" href="#SPHtools.packSPH">packSPH</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>