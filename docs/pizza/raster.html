<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>raster API documentation</title>
<meta name="description" content="`raster.py` provides methods to generate and manipulate raster-based geometries for LAMMPS input files. It includes tools for creating, plotting, and â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>raster</code></h1>
</header>
<section id="section-intro">
<p><code>raster.py</code> provides methods to generate and manipulate raster-based geometries for LAMMPS input files. It includes tools for creating, plotting, and exporting geometric objects, with advanced features for particle systems such as emulsions and core-shell dispersions. This module is part of the <strong>Pizza3</strong> toolkit.</p>
<hr>
<h2 id="features">Features</h2>
<h3 id="1-raster-area-creation">1. <strong>Raster Area Creation</strong></h3>
<p>Create a raster object with customizable dimensions and properties:</p>
<pre><code class="language-python">R = raster(width=200, height=200, dpi=300)
</code></pre>
<h3 id="2-geometric-object-insertion">2. <strong>Geometric Object Insertion</strong></h3>
<p>Define and manipulate objects such as rectangles, circles, triangles, diamonds, and polygons:</p>
<pre><code class="language-python">R.rectangle(10, 20, 15, 30, name='rect1', beadtype=1)
R.circle(50, 50, 10, name='circle1', beadtype=2, angle=45)
R.triangle(30, 40, 10, name='triangle1', beadtype=3, angle=30)
</code></pre>
<h3 id="3-collections-and-paths">3. <strong>Collections and Paths</strong></h3>
<p>Group objects into collections or copy them along specified paths:</p>
<pre><code class="language-python">R.collection(object1, object2, name='my_collection', beadtype=1)
R.copyalongpath(object1, name='path_collection', path=linear, n=5)
</code></pre>
<h3 id="4-scatter-and-emulsions">4. <strong>Scatter and Emulsions</strong></h3>
<p>Generate random distributions of particles:
- <strong>Emulsions</strong>: Place circular particles within defined boundaries.
- <strong>Core-Shell Particles</strong>: Insert particles with inner and outer radii.</p>
<pre><code class="language-python">e = emulsion(xmin=10, ymin=10, xmax=100, ymax=100)
e.insertion([10, 20, 30], beadtype=1)
</code></pre>
<h3 id="5-visualization">5. <strong>Visualization</strong></h3>
<p>Preview objects and raster layouts:</p>
<pre><code class="language-python">R.plot()
R.show(extra=&quot;label&quot;, contour=True)
</code></pre>
<h3 id="6-exporting-to-lammps">6. <strong>Exporting to LAMMPS</strong></h3>
<p>Generate a <code>pizza.data3.data</code> object for exporting to LAMMPS:</p>
<pre><code class="language-python">data_obj = R.data(scale=(1, 1), center=(0, 0))
data_obj.write(&quot;output_file.lmp&quot;)
</code></pre>
<hr>
<h2 id="advanced-features">Advanced Features</h2>
<ul>
<li><strong>Overlay Images</strong>: Import and convert images to raster objects with beads:
<code>python
R.overlay(50, 50, filename="image.jpg", ncolors=4, beadtype=2)</code></li>
<li><strong>Hexagonal Packing</strong>: Generate hex-packed data for particle arrangements.</li>
<li><strong>Labeling and Masking</strong>: Add labels to objects or define masked regions.</li>
</ul>
<hr>
<h2 id="usage-examples">Usage Examples</h2>
<h3 id="basic-example">Basic Example</h3>
<pre><code class="language-python">R = raster(width=100, height=100)
R.rectangle(10, 20, 15, 30, name='rect1', beadtype=1)
R.circle(50, 50, 10, name='circle1', beadtype=2)
R.plot()
R.show(extra=&quot;label&quot;)
</code></pre>
<h3 id="emulsion-generation">Emulsion Generation</h3>
<pre><code class="language-python">E = raster(width=400, height=400)
e = emulsion(xmin=10, ymin=10, xmax=390, ymax=390)
e.insertion([60, 50, 40, 30], beadtype=1)
E.scatter(e, name=&quot;emulsion&quot;)
E.plot()
E.show()
</code></pre>
<h3 id="core-shell-dispersion">Core-Shell Dispersion</h3>
<pre><code class="language-python">C = raster(width=400, height=400)
cs = coreshell(xmin=10, ymin=10, xmax=390, ymax=390)
cs.insertion([60, 50, 40], beadtype=(1, 2), thickness=4)
C.scatter(cs, name=&quot;core-shell&quot;)
C.plot()
C.show()
</code></pre>
<hr>
<h2 id="requirements">Requirements</h2>
<p>Since version 0.40, image overlays and live previews depend on the <code>Pizza3.pizza.private.PIL</code> library. For compatibility, the customized version of PIL must be compiled:</p>
<pre><code class="language-bash">cd Pizza3/pizza/private/PIL
python3 setup.py install
</code></pre>
<hr>
<h2 id="authors-and-credits">Authors and Credits</h2>
<ul>
<li><strong>Author</strong>: Olivier Vitrac</li>
<li><strong>Email</strong>: olivier.vitrac@agroparistech.fr</li>
<li><strong>License</strong>: GPLv3</li>
<li><strong>Credits</strong>: [Olivier Vitrac, Pizza3 Development Team]</li>
</ul>
<hr>
<h2 id="old-help">Old help</h2>
<pre><code>RASTER method to generate LAMMPS input files (in 2D for this version)

Generate a raster area
    R = raster()
    R = raster(width=200, height=200, dpi=300)

Set objects (rectangle, circle, triangle, diamond...)
    R.rectangle(1,24,2,20,name='rect1')
    R.rectangle(60,80,50,81,name='rect2',beadtype=2,angle=40)
    R.rectangle(50,50,10,10,mode="center",angle=45,beadtype=1)
    R.circle(45,20,5,name='C1',beadtype=3)
    R.circle(35,10,5,name='C2',beadtype=3)

    R.circle(15,30,10,name='p1',beadtype=4,shaperatio=0.2,angle=-30)
    R.circle(12,40,8,name='p2',beadtype=4,shaperatio=0.2,angle=20)
    R.circle(12,80,22,name='p3',beadtype=4,shaperatio=1.3,angle=20)

    R.triangle(85,20,10,name='T1',beadtype=5,angle=20)
    R.diamond(85,35,5,name='D1',beadtype=5,angle=20)
    R.pentagon(50,35,5,name='P1',beadtype=5,angle=90)
    R.hexagon(47,85,12,name='H1',beadtype=5,angle=90)

List simple objects
    R.list()
    R.get("p1")
    R.p1
    R.C1

List objects in a collection
    R.C1.get("p1")
    R.C1.p1 shows the object p1 in the collection C1

Build objects and show them
    R.plot()
    R.show()

Show and manage labels
    R.show(extra="label",contour=True)
    R.label("rect003")
    R.unlabel('rect1')

Manage objects, update and show

Get the image and convert the image to text
    I = R.numeric()
    T = R.string()
    R.print()

Create a pizza.dump3.dump object
    X = R.data()
    X=R.data(scale=(1,1),center=(0,0))
    X.write("/tmp/myfile")


Build an emulsion/suspension
    C = raster(width=400,height=400)
    e = emulsion(xmin=10, ymin=10, xmax=390, ymax=390)
    e.insertion([60,50,40,30,20,15,15,10,8,20,12,8,6,4,11,13],beadtype=1)
    C.scatter(e,name="emulsion")
    C.plot()
    C.show()


Build a core-shell dispersion
    D = raster(width=400,height=400)
    cs = coreshell(xmin=10, ymin=10, xmax=390, ymax=390)
    cs.insertion([60,50,40,30,20,15,15,10,8,20,12,8,11,13],beadtype=(1,2),thickness = 4)
    D.scatter(cs,name="core-shell")
    D.plot()
    D.show()


More advanced features enable object copy, duplication along a path
Contruction of scattered particles
See: copyalongpath(), scatter(), emulsion(), coreshell()

Examples follow in the __main__ section

--------------------------------------------------------------------
BUILDING REQUIREMENTS:
    Since version 0.40, overlay(), torgb() and live previews
    use Pizza3.pizza.private.PIL library

    The customized version of PIL needs to be compiled for your system
    By assuming that anaconda is used:

        condainit

        cd Pizza3/pizza/private/PIL
        python3 setup.py install

        unzip -l dist/UNKNOWN-9.1.0-py3.9-linux-x86_64.egg
        unzip -j "dist/UNKNOWN-9.1.0-py3.9-linux-x86_64.egg" "PIL/_imaging.cpython-39-x86_64-linux-gnu.so" .

        rm -rf dist/
        rm -rf build/
        rm -rf ../UNKNOWN.egg-info

--------------------------------------------------------------------
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;

`raster.py` provides methods to generate and manipulate raster-based geometries for LAMMPS input files. It includes tools for creating, plotting, and exporting geometric objects, with advanced features for particle systems such as emulsions and core-shell dispersions. This module is part of the **Pizza3** toolkit.

---

## Features

### 1. **Raster Area Creation**
Create a raster object with customizable dimensions and properties:
```python
R = raster(width=200, height=200, dpi=300)
```

### 2. **Geometric Object Insertion**
Define and manipulate objects such as rectangles, circles, triangles, diamonds, and polygons:
```python
R.rectangle(10, 20, 15, 30, name=&#39;rect1&#39;, beadtype=1)
R.circle(50, 50, 10, name=&#39;circle1&#39;, beadtype=2, angle=45)
R.triangle(30, 40, 10, name=&#39;triangle1&#39;, beadtype=3, angle=30)
```

### 3. **Collections and Paths**
Group objects into collections or copy them along specified paths:
```python
R.collection(object1, object2, name=&#39;my_collection&#39;, beadtype=1)
R.copyalongpath(object1, name=&#39;path_collection&#39;, path=linear, n=5)
```

### 4. **Scatter and Emulsions**
Generate random distributions of particles:
- **Emulsions**: Place circular particles within defined boundaries.
- **Core-Shell Particles**: Insert particles with inner and outer radii.
```python
e = emulsion(xmin=10, ymin=10, xmax=100, ymax=100)
e.insertion([10, 20, 30], beadtype=1)
```

### 5. **Visualization**
Preview objects and raster layouts:
```python
R.plot()
R.show(extra=&#34;label&#34;, contour=True)
```

### 6. **Exporting to LAMMPS**
Generate a `pizza.data3.data` object for exporting to LAMMPS:
```python
data_obj = R.data(scale=(1, 1), center=(0, 0))
data_obj.write(&#34;output_file.lmp&#34;)
```

---

## Advanced Features
- **Overlay Images**: Import and convert images to raster objects with beads:
  ```python
  R.overlay(50, 50, filename=&#34;image.jpg&#34;, ncolors=4, beadtype=2)
  ```
- **Hexagonal Packing**: Generate hex-packed data for particle arrangements.
- **Labeling and Masking**: Add labels to objects or define masked regions.

---

## Usage Examples

### Basic Example
```python
R = raster(width=100, height=100)
R.rectangle(10, 20, 15, 30, name=&#39;rect1&#39;, beadtype=1)
R.circle(50, 50, 10, name=&#39;circle1&#39;, beadtype=2)
R.plot()
R.show(extra=&#34;label&#34;)
```

### Emulsion Generation
```python
E = raster(width=400, height=400)
e = emulsion(xmin=10, ymin=10, xmax=390, ymax=390)
e.insertion([60, 50, 40, 30], beadtype=1)
E.scatter(e, name=&#34;emulsion&#34;)
E.plot()
E.show()
```

### Core-Shell Dispersion
```python
C = raster(width=400, height=400)
cs = coreshell(xmin=10, ymin=10, xmax=390, ymax=390)
cs.insertion([60, 50, 40], beadtype=(1, 2), thickness=4)
C.scatter(cs, name=&#34;core-shell&#34;)
C.plot()
C.show()
```

---

## Requirements
Since version 0.40, image overlays and live previews depend on the `Pizza3.pizza.private.PIL` library. For compatibility, the customized version of PIL must be compiled:
```bash
cd Pizza3/pizza/private/PIL
python3 setup.py install
```

---

## Authors and Credits
- **Author**: Olivier Vitrac
- **Email**: olivier.vitrac@agroparistech.fr
- **License**: GPLv3
- **Credits**: [Olivier Vitrac, Pizza3 Development Team]

---

## Old help

    RASTER method to generate LAMMPS input files (in 2D for this version)

    Generate a raster area
        R = raster()
        R = raster(width=200, height=200, dpi=300)

    Set objects (rectangle, circle, triangle, diamond...)
        R.rectangle(1,24,2,20,name=&#39;rect1&#39;)
        R.rectangle(60,80,50,81,name=&#39;rect2&#39;,beadtype=2,angle=40)
        R.rectangle(50,50,10,10,mode=&#34;center&#34;,angle=45,beadtype=1)
        R.circle(45,20,5,name=&#39;C1&#39;,beadtype=3)
        R.circle(35,10,5,name=&#39;C2&#39;,beadtype=3)

        R.circle(15,30,10,name=&#39;p1&#39;,beadtype=4,shaperatio=0.2,angle=-30)
        R.circle(12,40,8,name=&#39;p2&#39;,beadtype=4,shaperatio=0.2,angle=20)
        R.circle(12,80,22,name=&#39;p3&#39;,beadtype=4,shaperatio=1.3,angle=20)

        R.triangle(85,20,10,name=&#39;T1&#39;,beadtype=5,angle=20)
        R.diamond(85,35,5,name=&#39;D1&#39;,beadtype=5,angle=20)
        R.pentagon(50,35,5,name=&#39;P1&#39;,beadtype=5,angle=90)
        R.hexagon(47,85,12,name=&#39;H1&#39;,beadtype=5,angle=90)

    List simple objects
        R.list()
        R.get(&#34;p1&#34;)
        R.p1
        R.C1

    List objects in a collection
        R.C1.get(&#34;p1&#34;)
        R.C1.p1 shows the object p1 in the collection C1

    Build objects and show them
        R.plot()
        R.show()

    Show and manage labels
        R.show(extra=&#34;label&#34;,contour=True)
        R.label(&#34;rect003&#34;)
        R.unlabel(&#39;rect1&#39;)

    Manage objects, update and show

    Get the image and convert the image to text
        I = R.numeric()
        T = R.string()
        R.print()

    Create a pizza.dump3.dump object
        X = R.data()
        X=R.data(scale=(1,1),center=(0,0))
        X.write(&#34;/tmp/myfile&#34;)


    Build an emulsion/suspension
        C = raster(width=400,height=400)
        e = emulsion(xmin=10, ymin=10, xmax=390, ymax=390)
        e.insertion([60,50,40,30,20,15,15,10,8,20,12,8,6,4,11,13],beadtype=1)
        C.scatter(e,name=&#34;emulsion&#34;)
        C.plot()
        C.show()


    Build a core-shell dispersion
        D = raster(width=400,height=400)
        cs = coreshell(xmin=10, ymin=10, xmax=390, ymax=390)
        cs.insertion([60,50,40,30,20,15,15,10,8,20,12,8,11,13],beadtype=(1,2),thickness = 4)
        D.scatter(cs,name=&#34;core-shell&#34;)
        D.plot()
        D.show()


    More advanced features enable object copy, duplication along a path
    Contruction of scattered particles
    See: copyalongpath(), scatter(), emulsion(), coreshell()

    Examples follow in the __main__ section

    --------------------------------------------------------------------
    BUILDING REQUIREMENTS:
        Since version 0.40, overlay(), torgb() and live previews
        use Pizza3.pizza.private.PIL library

        The customized version of PIL needs to be compiled for your system
        By assuming that anaconda is used:

            condainit

            cd Pizza3/pizza/private/PIL
            python3 setup.py install

            unzip -l dist/UNKNOWN-9.1.0-py3.9-linux-x86_64.egg
            unzip -j &#34;dist/UNKNOWN-9.1.0-py3.9-linux-x86_64.egg&#34; &#34;PIL/_imaging.cpython-39-x86_64-linux-gnu.so&#34; .

            rm -rf dist/
            rm -rf build/
            rm -rf ../UNKNOWN.egg-info

    --------------------------------------------------------------------

&#34;&#34;&#34;


__project__ = &#34;Pizza3&#34;
__author__ = &#34;Olivier Vitrac&#34;
__copyright__ = &#34;Copyright 2022&#34;
__credits__ = [&#34;Olivier Vitrac&#34;]
__license__ = &#34;GPLv3&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;0.99991&#34;


# INRAE\Olivier Vitrac - rev. 2024-12-08
# contact: olivier.vitrac@agroparistech.fr, han.chen@inrae.fr

# History
# 2022-02-05 first alpha version
# 2022-02-06 RC for 2D
# 2022-02-08 add count(), update the display method
# 2022-02-10 add figure(), newfigure(), count()
# 2022-02-11 improve display, add data()
# 2022-02-12 major release, fully compatible with pizza.data3.data
# 2022-02-13 the example (&lt;F5&gt;) has been modified R.plot() should precedes R.list()
# 2022-02-28 update write files for SMD, add scale and center to R.data()
# 2022-03-02 fix data(): xlo and ylow (beads should not overlap the boundary), scale radii, volumes
# 2022-03-20 major update, add collection, duplication, translation, scatter(), emulsion()
# 2022-03-22 update raster to insert customized beadtypes
# 2022-03-23 add coreshell()
# 2022-03-23 fix nattempt, add arc
# 2022-04-01 add maxtype to  raster.data(), e.g. raster.data(maxtype=4)
# 2022-04-08 add beadtype2(alternative beadtype, ratio) to salt objects
# 2022-04-13 descale volume in data() for stability reason
# 2022-04-23 very first overlay implementation (alpha version) -- version 0.40
# 2022-04-24 full implementation of overlay (not fully tested yet, intended to behave has a regular object)
# 2022-04-25 full integration of PIL
# 2022-04-26 add torgb(), thumbnails, add angle, scale=(scalex,scaley) to overlay()
# 2022-04-26 add building instructions, version 0.421
# 2022-04-27 add scale to the representation of overlay objects (0.422)
# 2022-04-28 fix len(raster object) - typo error (0.4221)
# 2022-05-03 add hexpacking to data(), enables you to reproduces an hexgonal packaging
# 2023-01-03 workaround to have raster working on Windows without restrictions
# 2024-12-08 improved help

# %% Imports and private library
import os
from platform import system as sys
from copy import copy as duplicate
from copy import deepcopy as deepduplicate
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.path as path
import matplotlib.patches as patches
import matplotlib.cm as cmap
from IPython.display import display
from pizza.data3 import data as data3
from pizza.private.mstruct import struct

if sys()==&#34;Windows&#34;:
    try:
        from PIL import Image, ImagePalette
        PILavailable = True
    except ImportError:
        print(&#34;WARNING: no image capabilities in Windows&#34;)
        PILavailable = False
else:
    from pizza.private.PIL import Image, ImagePalette
    PILavailable = True

__all__ = [&#39;Circle&#39;, &#39;Collection&#39;, &#39;Diamond&#39;, &#39;Hexagon&#39;, &#39;Pentagon&#39;, &#39;Rectangle&#39;, &#39;Triangle&#39;, &#39;arc&#39;, &#39;collection&#39;, &#39;coregeometry&#39;, &#39;coreshell&#39;, &#39;data3&#39;, &#39;emulsion&#39;, &#39;genericpolygon&#39;, &#39;imagesc&#39;, &#39;ind2rgb&#39;, &#39;linear&#39;, &#39;overlay&#39;, &#39;raster&#39;, &#39;scatter&#39;, &#39;struct&#39;]


def _rotate(x0,y0,xc,yc,angle):
    angle = np.pi * angle / 180.0
    x1 = (x0 - xc)*np.cos(angle) - (y0 - yc)*np.sin(angle) + xc
    y1 = (x0 - xc)*np.sin(angle) + (y0 - yc)*np.cos(angle) + yc
    return x1, y1

def _extents(f):
    halftick = ( f[1] - f[0] ) / 2
    return [f[0] - halftick, f[-1] + halftick]

# wrapper of imagesc (note that the origin is bottom left)
# usage: data = np.random.randn(5,10)
#        imagesc(data)
def imagesc(im,x=None,y=None):
    &#34;&#34;&#34;  imagesc Ã  la Matlab
            imagesc(np2array) &#34;&#34;&#34;
    if x==None: x=np.arange(1,np.shape(im)[1]+1)
    if y==None: y=np.arange(1,np.shape(im)[0]+1)
    plt.imshow(im, extent=_extents(x) + _extents(y),
               aspect=&#34;auto&#34;, origin=&#34;lower&#34;, interpolation=&#34;none&#34;)

# convert indexed image to RGB (using PIL)
# rgbim = ind2rgb(im,ncolors=number of colors)
def ind2rgb(im,ncolors=64):
    &#34;&#34;&#34; Convert indexed image (NumPy array) to RGB
            rgb = ind2rgb(np2array,ncolors=nc)
            use rgb.save(&#34;/path/filename.png&#34;) for saving
    &#34;&#34;&#34;
    raw = Image.fromarray(np.flipud(im),&#34;P&#34;)
    col0 = np.array(np.round(255*cmap.get_cmap(&#34;viridis&#34;,ncolors).colors[:,:3]),dtype=&#34;uint8&#34;)
    col = bytearray(np.resize(col0,(256,3)).flatten())
    pal = ImagePalette.ImagePalette(mode=&#34;RGB&#34;,palette=col)
    #Image.convert(mode=None, matrix=None, dither=None, palette=Palette.WEB, colors=256)
    raw.putpalette(pal)
    return raw

# helper for parametric functions
def linear(xmin=10,ymin=10,xmax=80,ymax=80,n=5,USER=struct()):
    &#34;&#34;&#34;  Equispaced points along a trajectory
            X,Y = linear(xmin=value,ymin=value,xmax=value,ymax=value,n=int)
    &#34;&#34;&#34;
    return np.linspace(xmin,xmax,n), np.linspace(ymin,ymax,n)

def arc(xmin=10,ymin=50,xmax=80,ymax=50,n=5,USER=struct(radius=20,direction=1)):
    &#34;&#34;&#34;  Point distributed along an arc
            X,Y = arc(xmin=value,ymin=value,xmax=value,ymax=value,n=int,
                      USER=struct(radius=value,direction=1))
            Use direction to choose the upward +1 or downward -1 circle
        see: https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points
    &#34;&#34;&#34;
    R = 0 if &#34;radius&#34; not in USER else USER.radius
    direction = +1 if &#34;direction&#34; not in USER else USER.direction
    dx,dy = xmax-xmin, ymax-ymin
    q = np.sqrt(dx**2+dy**2) # distance
    R = max(R,q/2) # radius constraint
    d = np.sqrt(R**2-(q/2)**2) # distance along the mirror line
    xc = (xmin+xmax)/2 - direction * d*dy/q
    yc = (ymin+ymax)/2 + direction * d*dx/q
    thmin,thmax = np.arctan((ymin-yc)/(xmin-xc)), np.arctan((ymax-yc)/(xmax-xc))
    if d==0: thmax = thmin + np.pi
    th = np.linspace(thmin,thmax,n)
    return xc+np.cos(th)*R,yc+np.sin(th)*R

# %% raster class
class raster:
    &#34;&#34;&#34; raster class for LAMMPS SMD

    Constructor

        R = raster(width=100,height=100...)

        Extra properties
            dpi, fontsize

        additional properties for R.data()
            scale, center : full scaling
            mass, volume, radius, contactradius, velocities, forces: bead scaling
            filename

        List of available properties = default values

                   name = &#34;default raster&#34;
                  width = 100
                 height = 100
                    dpi = 200
               fontsize = 10
                   mass = 1
                 volume = 1
                 radius = 1.5
          contactradius = 0.5
             velocities = [0, 0, 0]
                 forces = [0, 0, 0]
                preview = True
           previewthumb = (128,128)
               filename = [&#34;%dx%d raster (%s)&#34; % (self.width,self.height,self.name)]

    Graphical objects

        R.rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode=&#34;lower&#34;, angle=0, ismask=False])
        R.rectangle(xcenter,ycenter,width,height [, beadtype=1,mode=&#34;center&#34;, angle=0, ismask=False])
        R.circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
        R.triangle(...)
        R.diamond(...)
        R.pentagon(...)
        R.hexagon(...)

        R.overlay(xleft,xright,filename==&#34;valid/image.ext&#34;,color=2,beadtype=1)

        note: use fake=True to generate an object without inserting it

        R.collection(...) generates collection of existing or fake objects
        R.object.copy(...) enables to copy an object

    Display methods (precedence affects the result)
        R.plot()
        R.show(), R.show(extra=&#34;label&#34;,contour=True,what=&#34;beadtype&#34; or &#34;objindex&#34;)
        R.show(extra=&#34;labels&#34;)
        R.list()
        R.get(&#34;object&#34;)
        R.print()
        R.label(&#34;object&#34;)
        R.unlabel(&#34;object&#34;)
        R.figure()
        R.newfigure(dpi=300)

        R.numeric()
        R.string(), R.string(what=&#34;beadtype&#34; or &#34;objindex&#34;))
        R.names()
        R.print()

    Clear and delete
        R.clear()
        R.clear(&#34;all&#34;)
        R.delete(&#34;object&#34;)

    Copy objects
        R.copyalongpath(....)
        R.scatter()

    Generate an input data object
        X = R.data() or X=R.data(scale=(1,1),center=(0,0))
        X.write(&#34;/tmp/myfile&#34;)

    &#34;&#34;&#34;

    # CONSTRUCTOR ----------------------------
    def __init__(self,
                 # raster properties
                 name=&#34;default raster&#34;,
                 width=100,
                 height=100,
                 # printing and display
                 dpi=200,
                 fontsize=10,
                 # for data conversion
                 mass=1,
                 volume=1,
                 radius=1.5,
                 contactradius=0.5,
                 velocities=[0,0,0],
                 forces=[0,0,0],
                 preview=True,
                 previewthumb = (128,128),
                 filename=&#34;&#34;
                 ):

        &#34;&#34;&#34; initialize raster &#34;&#34;&#34;
        self.name = name
        self.width = width
        self.height = height
        self.xcenter= width/2
        self.ycenter = height/2
        self.objects = {}
        self.nobjects = 0    # total number of objects (alive)
        self.nbeads = 0
        self.counter = { &#34;triangle&#34;:0,
                          &#34;diamond&#34;:0,
                        &#34;rectangle&#34;:0,
                         &#34;pentagon&#34;:0,
                          &#34;hexagon&#34;:0,
                           &#34;circle&#34;:0,
                          &#34;overlay&#34;:0,
                       &#34;collection&#34;:0,
                              &#34;all&#34;:0
                    }
        self.fontsize = 10   # font size for labels
        self.imbead = np.zeros((height,width),dtype=np.int8)
        self.imobj = np.zeros((height,width),dtype=np.int8)
        self.hfig = [] # figure handle
        self.dpi = dpi
        # generic SMD properties (to be rescaled)
        self.volume = volume
        self.mass = mass
        self.radius = radius
        self.contactradius = contactradius
        self.velocities = velocities
        self.forces =forces

        self.preview = preview
        self.previewthumb = previewthumb

        if filename == &#34;&#34;:
            self.filename = [&#34;%dx%d raster (%s)&#34; % (self.width,self.height,self.name)]
        else:
            self.filename = filename


    # DATA ----------------------------
    def data(self,scale=(1,1),center=(0,0),maxtype=None,hexpacking=None):
        &#34;&#34;&#34;
            return a pizza.data object
                data()
                data(scale=(scalex,scaley),
                     center=(centerx,centery),
                     maxtype=number,
                     hexpacking=(0.5,0))
        &#34;&#34;&#34;
        if not isinstance(scale,tuple) or len(scale)!=2:
            raise ValueError(&#34;scale must be tuple (scalex,scaley)&#34;)
        if not isinstance(center,tuple) or len(scale)!=2:
            raise ValueError(&#34;center must be tuple (centerx,centery)&#34;)
        scalez = np.sqrt(scale[0]*scale[1])
        scalevol = scale[0]*scale[1] #*scalez
        maxtypeheader = self.count()[-1][0] if maxtype is None else maxtype
        n = self.length()
        i,j = self.imbead.nonzero() # x=j+0.5 y=i+0.5
        x = (j+0.5-center[0])*scale[0]
        y = (i+0.5-center[1])*scale[1]
        if hexpacking is not None:
            if isinstance(hexpacking,tuple) and len(hexpacking)==2:
                for k in range(len(i)):
                    if i[k] % 2:
                        x[k] = (j[k]+0.5+hexpacking[1]-center[0])*scale[0]
                    else:
                        x[k] = (j[k]+0.5+hexpacking[0]-center[0])*scale[0]
            else:
                raise ValueError(&#34;hexpacking should be a tuple (shiftodd,shifteven)&#34;)
        X = data3()  # empty pizza.data3.data object
        X.title = self.name + &#34;(raster)&#34;
        X.headers = {&#39;atoms&#39;: n,
                      &#39;atom types&#39;: maxtypeheader,
                      &#39;xlo xhi&#39;: ((0.0-center[0])*scale[0], (self.width-0.0-center[0])*scale[0]),
                      &#39;ylo yhi&#39;: ((0.0-center[1])*scale[1], (self.height-0.0-center[1])*scale[1]),
                      &#39;zlo zhi&#39;: (0, scalez)}
        # [ATOMS] section
        X.append(&#39;Atoms&#39;,list(range(1,n+1)),True,&#34;id&#34;)       # id
        X.append(&#39;Atoms&#39;,self.imbead[i,j],True,&#34;type&#34;)       # Type
        X.append(&#39;Atoms&#39;,1,True,&#34;mol&#34;)                       # mol
        X.append(&#39;Atoms&#39;,self.volume*scalevol,False,&#34;c_vol&#34;) # c_vol
        X.append(&#39;Atoms&#39;,self.mass*scalevol,False,&#34;mass&#34;)    # mass
        X.append(&#39;Atoms&#39;,self.radius*scalez,False,&#34;radius&#34;)         # radius
        X.append(&#39;Atoms&#39;,self.contactradius*scalez,False,&#34;c_contact_radius&#34;) # c_contact_radius
        X.append(&#39;Atoms&#39;,x,False,&#34;x&#34;)        # x
        X.append(&#39;Atoms&#39;,y,False,&#34;y&#34;)        # y
        X.append(&#39;Atoms&#39;,0,False,&#34;z&#34;)        # z
        X.append(&#39;Atoms&#39;,x,False,&#34;x0&#34;)       # x0
        X.append(&#39;Atoms&#39;,y,False,&#34;y0&#34;)       # y0
        X.append(&#39;Atoms&#39;,0,False,&#34;z0&#34;)       # z0
        # [VELOCITIES] section
        X.append(&#39;Velocities&#39;,list(range(1,n+1)),True,&#34;id&#34;) # id
        X.append(&#39;Velocities&#39;,self.velocities[0],False,&#34;vx&#34;) # vx
        X.append(&#39;Velocities&#39;,self.velocities[1],False,&#34;vy&#34;) # vy
        X.append(&#39;Velocities&#39;,self.velocities[2],False,&#34;vz&#34;) # vz
        # pseudo-filename
        X.flist = self.filename
        return X

    # LENGTH ----------------------------
    def length(self,t=None,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; returns the total number of beads length(type,&#34;beadtype&#34;) &#34;&#34;&#34;
        if what == &#34;beadtype&#34;:
            num = self.imbead
        elif what == &#34;objindex&#34;:
            num = self.imobj
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        if t==None:
            return np.count_nonzero(num&gt;0)
        else:
            return np.count_nonzero(num==t)

    # NUMERIC ----------------------------
    def numeric(self):
        &#34;&#34;&#34; retrieve the image as a numpy.array &#34;&#34;&#34;
        return self.imbead, self.imobj

    # STRING ----------------------------
    def string(self,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; convert the image as ASCII strings &#34;&#34;&#34;
        if what == &#34;beadtype&#34;:
            num = np.flipud(duplicate(self.imbead))
        elif what == &#34;objindex&#34;:
            num = np.flipud(duplicate(self.imobj))
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        num[num&gt;0] = num[num&gt;0] + 65
        num[num==0] = 32
        num = list(num)
        return [&#34;&#34;.join(map(chr,x)) for x in num]

    # GET -----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.objects:
            return self.objects[name]
        else:
            raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # GETATTR --------------------------
    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return self.get(key)

    # CLEAR ----------------------------
    def clear(self,what=&#34;nothing&#34;):
        &#34;&#34;&#34; clear the plotting area, use clear(&#34;all&#34;)) to remove all objects &#34;&#34;&#34;
        self.imbead = np.zeros((self.height,self.width),dtype=np.int8)
        self.imobj = np.zeros((self.height,self.width),dtype=np.int8)
        for o in self.names():
            if what==&#34;all&#34;:
                self.delete(o)
            else:
                self.objects[o].isplotted = False
                self.objects[o].islabelled = False
                if not self.objects[o].ismask:
                    self.nbeads -= self.objects[o].nbeads
                self.objects[o].nbeads = 0  # number of beads (plotted)
        self.figure()
        plt.cla()
        self.show()

    # DISP method ----------------------------
    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        ctyp = self.count() # count objects (not beads)
        print(&#34;-&#34;*40)
        print(&#39;RASTER area &#34;%s&#34; with %d objects&#39; % (self.name,self.nobjects))
        print(&#34;-&#34;*40)
        print(&#34;&lt;- grid size -&gt;&#34;)
        print(&#34;\twidth: %d&#34; % self.width)
        print(&#34;\theight: %d&#34; % self.height)
        print(&#34;&lt;- bead types -&gt;&#34;)
        nbt = 0
        if len(ctyp):
            for i,c in enumerate(ctyp):
                nb = self.length(c[0])
                nbt += nb
                print(&#34;\t type=%d (%d objects, %d beads)&#34; % (c[0],c[1],nb))
        else:
            print(&#34;\tno bead assigned&#34;)
        print(&#34;-&#34;*40)
        if self.preview and len(self)&gt;0 and self.max&gt;0:
            if PILavailable:
                display(self.torgb(&#34;beadtype&#34;,self.previewthumb))
                display(self.torgb(&#34;objindex&#34;,self.previewthumb))
            else:
                print(&#34;no PIL image&#34;)
        return &#34;RASTER AREA %d x %d with %d objects (%d types, %d beads).&#34; % \
        (self.width,self.height,self.nobjects,len(ctyp),nbt)

    # TORGB method ----------------------------
    def torgb(self,what=&#34;beadtype&#34;,thumb=None):
        &#34;&#34;&#34; converts bead raster to image
                rgb = raster.torgb(what=&#34;beadtype&#34;)
                thumbnail = raster.torgb(what=&#34;beadtype&#34;,(128,128))
                use: rgb.save(&#34;/path/filename.png&#34;) for saving

            what = &#34;beadtype&#34; or &#34;objindex&#34;
        &#34;&#34;&#34;
        if what==&#34;beadtype&#34;:
            rgb = ind2rgb(self.imbead,ncolors=self.max+1)
        elif what == &#34;objindex&#34;:
            rgb = ind2rgb(self.imobj,ncolors=len(self)+1)
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        if thumb is not None: rgb.thumbnail(thumb)
        return rgb

    # COUNT method ----------------------------
    def count(self):
        &#34;&#34;&#34; count objects by type &#34;&#34;&#34;
        typlist = []
        for  o in self.names():
            if isinstance(self.objects[o].beadtype,list):
                typlist += self.objects[o].beadtype
            else:
                typlist.append(self.objects[o].beadtype)
        utypes = list(set(typlist))
        c = []
        for t in utypes:
            c.append((t,typlist.count(t)))
        return c

    # max method ------------------------------
    @property
    def max(self):
        &#34;&#34;&#34; max bead type &#34;&#34;&#34;
        typlist = []
        for  o in self.names():
            if isinstance(self.objects[o].beadtype,list):
                typlist += self.objects[o].beadtype
            else:
                typlist.append(self.objects[o].beadtype)
        return max(typlist)

    # len method ------------------------------
    def __len__(self):
        &#34;&#34;&#34; len method &#34;&#34;&#34;
        return len(self.objects)

    # NAMES method ----------------------------
    def names(self):
        &#34;&#34;&#34; return the names of objects sorted as index &#34;&#34;&#34;
        namesunsorted=namessorted=list(self.objects.keys())
        nobj = len(namesunsorted)
        for iobj in range(nobj):
            namessorted[self.objects[namesunsorted[iobj]].index-1] = namesunsorted[iobj]
        return namessorted

    # LIST method ----------------------------
    def list(self):
        &#34;&#34;&#34; list objects &#34;&#34;&#34;
        fmt = &#34;%%%ss:&#34; % max(10,max([len(n) for n in self.names()])+2)
        print(&#34;RASTER with %d objects&#34; % self.nobjects)
        for o in self.objects.keys():
            print(fmt % self.objects[o].name,&#34;%-10s&#34; % self.objects[o].kind,
                  &#34;(beadtype=%d,object index=[%d,%d], n=%d)&#34; % \
                      (self.objects[o].beadtype,
                       self.objects[o].index,
                       self.objects[o].subindex,
                       self.objects[o].nbeads))

    # EXIST method ----------------------------
    def exist(self,name):
        &#34;&#34;&#34; exist object &#34;&#34;&#34;
        return name in self.objects

    # DELETE method ----------------------------
    def delete(self,name):
        &#34;&#34;&#34; delete object &#34;&#34;&#34;
        if name in self.objects:
            if not self.objects[name].ismask:
                self.nbeads -= self.objects[name].nbeads
            del self.objects[name]
            self.nobjects -= 1
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)
        self.clear()
        self.plot()
        self.show(extra=&#34;label&#34;)

    # VALID method
    def valid(self,x,y):
        &#34;&#34;&#34; validation of coordinates &#34;&#34;&#34;
        return min(self.width,max(0,round(x))),min(self.height,max(0,round(y)))

    # frameobj method
    def frameobj(self,obj):
        &#34;&#34;&#34; frame coordinates by taking into account translation &#34;&#34;&#34;
        if obj.hasclosefit:
            envelope = 0
        else:
            envelope = 1
        xmin, ymin = self.valid(obj.xmin-envelope, obj.ymin-envelope)
        xmax, ymax = self.valid(obj.xmax+envelope, obj.ymax+envelope)
        return xmin, ymin, xmax, ymax

    # RECTANGLE ----------------------------
    def rectangle(self,a,b,c,d,
                  mode=&#34;lowerleft&#34;,name=None,angle=0,
                  beadtype=None,ismask=False,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        rectangle object
            rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode=&#34;lower&#34;, angle=0, ismask=False])
            rectangle(xcenter,ycenter,width,height [, beadtype=1,mode=&#34;center&#34;, angle=0, ismask=False])

            use rectangle(...,beadtype2=(type,ratio)) to salt an object with beads
            from another type and with a given ratio
        &#34;&#34;&#34;
        # object creation
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;rectangle&#34;] += 1
        R = Rectangle((self.counter[&#34;all&#34;],self.counter[&#34;rectangle&#34;]))
        if (name != None) and (name != &#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            R.name = name
        else:
            name = R.name
        if beadtype is not None: R.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        R.beadtype2 = beadtype2
        if ismask: R.beadtype = 0
        R.ismask = R.beadtype==0
        # build vertices
        if mode == &#34;lowerleft&#34;:
            R.xcenter0 = (a+b)/2
            R.ycenter0 = (c+d)/2
            R.vertices = [
                _rotate(a,c,R.xcenter0,R.ycenter0,angle),
                _rotate(b,c,R.xcenter0,R.ycenter0,angle),
                _rotate(b,d,R.xcenter0,R.ycenter0,angle),
                _rotate(a,d,R.xcenter0,R.ycenter0,angle),
                _rotate(a,c,R.xcenter0,R.ycenter0,angle)
                ] # anti-clockwise, closed (last point repeated)
        elif mode == &#34;center&#34;:
            R.xcenter0 = a
            R.ycenter0 = b
            R.vertices = [
                _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a+c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a+c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a-c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle)
                ]
        else:
            raise ValueError(&#39;&#34;%s&#34; is not a recognized mode, use &#34;lowerleft&#34; (default) and &#34;center&#34; instead&#39;)
        # build path object and range
        R.codes =    [ path.Path.MOVETO,
                     path.Path.LINETO,
                     path.Path.LINETO,
                     path.Path.LINETO,
                     path.Path.CLOSEPOLY
                    ]
        R.nvertices = len(R.vertices)-1
        R.xmin0, R.ymin0, R.xmax0, R.ymax0 = R.corners()
        R.xmin0, R.ymin0 = self.valid(R.xmin0,R.ymin0)
        R.xmax0, R.ymax0 = self.valid(R.xmax0,R.ymax0)
        R.angle = angle
        # store the object (if not fake)
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[&#34;rectangle&#34;] -= 1
            return R
        else:
            self.objects[name] = R
            self.nobjects += 1
            return None


    # CIRCLE ----------------------------
    def circle(self,xc,yc,radius,
                  name=None,shaperatio=1,angle=0,beadtype=None,ismask=False,
                  resolution=20,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        circle object (or any regular polygon)
            circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
            use circle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        # object creation
        self.counter[&#34;all&#34;] += 1
        if resolution==3:
            typ = &#34;triangle&#34;
            self.counter[&#34;triangle&#34;] += 1
            G = Triangle((self.counter[&#34;all&#34;],self.counter[&#34;triangle&#34;]))
        elif resolution==4:
            typ = &#34;diamond&#34;
            self.counter[&#34;diamond&#34;] += 1
            G = Diamond((self.counter[&#34;all&#34;],self.counter[&#34;diamond&#34;]))
        elif resolution==5:
            typ = &#34;pentagon&#34;
            self.counter[&#34;pentagon&#34;] += 1
            G = Pentagon((self.counter[&#34;all&#34;],self.counter[&#34;pentagon&#34;]))
        elif resolution==6:
            typ = &#34;hexagon&#34;
            self.counter[&#34;hexagon&#34;] += 1
            G = Hexagon((self.counter[&#34;all&#34;],self.counter[&#34;hexagon&#34;]))
        else:
            typ = &#34;circle&#34;
            self.counter[&#34;circle&#34;] += 1
            G = Circle((self.counter[&#34;all&#34;],self.counter[&#34;circle&#34;]),resolution=resolution)
        if (name != None) and (name != &#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            G.name = name
        else:
            name = G.name
        if beadtype is not None: G.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        G.beadtype2 = beadtype2
        if ismask: G.beadtype = 0
        G.ismask = G.beadtype==0
        # build vertices
        th = np.linspace(0,2*np.pi,G.resolution+1) +shiftangle*np.pi/180
        xgen = xc + radius * np.cos(th)
        ygen = yc + radius * shaperatio * np.sin(th)
        G.xcenter0, G.ycenter0, G.radius = xc, yc, radius
        G.vertices, G.codes = [], []
        for i in range(G.resolution+1):
            G.vertices.append(_rotate(xgen[i],ygen[i],xc,yc,angle))
            if i==0:
                G.codes.append(path.Path.MOVETO)
            elif i==G.resolution:
                G.codes.append(path.Path.CLOSEPOLY)
            else:
                G.codes.append(path.Path.LINETO)
        G.nvertices = len(G.vertices)-1
        # build path object and range
        G.xmin0, G.ymin0, G.xmax0, G.ymax0 = G.corners()
        G.xmin0, G.ymin0 = self.valid(G.xmin0,G.ymin0)
        G.xmax0, G.ymax0 = self.valid(G.xmax0,G.ymax0)
        G.angle, G.shaperatio = angle, shaperatio
        # store the object
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[typ] -= 1
            return G
        else:
            self.objects[name] = G
            self.nobjects += 1
            return None

    # OVERLAY -------------------------------
    def overlay(self,x0,y0,
                name = None,
                filename = None,
                color = 1,
                colormax = None,
                ncolors = 4,
                beadtype = None,
                beadtype2 = None,
                ismask = False,
                fake = False,
                flipud = True,
                angle = 0,
                scale= (1,1)
                ):
        &#34;&#34;&#34;
            overlay object: made from an image converted to nc colors
            the object is made from the level ranged between ic and jc (bounds included)
            note: if palette found, no conversion is applied

            O = overlay(x0,y0,filename=&#34;/this/is/my/image.png&#34;,ncolors=nc,color=ic,colormax=jc,beadtype=b)
            O = overlay(...angle=0,scale=(1,1)) to induce rotation and change of scale
            O = overlay(....ismask=False,fake=False)

            note use overlay(...flipud=False) to prevent image fliping (standard)

            Outputs:
                O.original original image (PIL)
                O.raw image converted to ncolors if needed

        &#34;&#34;&#34;
        if filename is None or filename==&#34;&#34;:
            raise ValueError(&#34;filename is required (valid image)&#34;)
        O = overlay(counter=(self.counter[&#34;all&#34;]+1,self.counter[&#34;overlay&#34;]+1),
                    filename = filename,
                    xmin = x0,
                    ymin = y0,
                    ncolors = ncolors,
                    flipud = flipud,
                    angle = angle,
                    scale = scale
                    )
        O.select(color=color, colormax=colormax)
        if (name is not None) and (name !=&#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            O.name = name
        else:
            name = O.name
        if beadtype is not None: O.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        O.beadtype2 = beadtype2
        if ismask: O.beadtype = 0
        O.ismask = O.beadtype==0
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;overlay&#34;] += 1
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[&#34;overlay&#34;] -= 1
            return O
        else:
            self.objects[name] = O
            self.nobjects += 1
            return None


    # COLLECTION ----------------------------
    def collection(self,*obj,
                   name=None,
                   beadtype=None,
                   ismask=None,
                   translate = [0.0,0.0],
                   fake = False,
                   **kwobj):
        &#34;&#34;&#34;
            collection of objects:
                collection(draftraster,name=&#34;mycollect&#34; [,beadtype=1,ismask=True]
                collection(name=&#34;mycollect&#34;,newobjname1 = obj1, newobjname2 = obj2...)
        &#34;&#34;&#34;
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;collection&#34;] += 1
        C = Collection((self.counter[&#34;all&#34;],self.counter[&#34;collection&#34;]))
        # name
        if name != None:
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            C.name = name
        else:
            name = C.name
        # build the collection
        C.collection = collection(*obj,**kwobj)
        xmin = ymin = +1e99
        xmax = ymax = -1e99
        # apply modifications (beadtype, ismask)
        for o in C.collection.keys():
            tmp = C.collection.getattr(o)
            tmp.translate[0] += translate[0]
            tmp.translate[1] += translate[1]
            xmin, xmax = min(xmin,tmp.xmin), max(xmax,tmp.xmax)
            ymin, ymax = min(ymin,tmp.ymin), max(ymax,tmp.ymax)
            if beadtype != None: tmp.beadtype = beadtype
            if ismask != None: tmp.ismask = ismask
            C.collection.setattr(o,tmp)
        C.xmin, C.xmax, C.ymin, C.ymax = xmin, xmax, ymin, ymax
        C.width, C.height = xmax-xmin, ymax-ymin
        if fake:
            return C
        else:
            self.objects[name] = C
            self.nobjects += 1
            return None

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # =========== pseudo methods connected to circle() ===========
    # TRIANGLE, DIAMOND, PENTAGON, HEXAGON, -----------------------
    def triangle(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        triangle object
            triangle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use triangle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=3,
           angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)

    def diamond(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        diamond object
            diamond(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use diamond(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=4,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)

    def pentagon(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        pentagon object
            pentagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use pentagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=5,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)

    def hexagon(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        hexagon object
            hexagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use hexagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=6,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # label method ----------------------------
    def label(self,name,**fmt):
        &#34;&#34;&#34;
            label:
                label(name [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
        &#34;&#34;&#34;
        self.figure()
        if name in self.objects:
            if not self.objects[name].islabelled:
                if self.objects[name].alike == &#34;mixed&#34;:
                    for o in self.objects[name].collection:
                        self.labelobj(o,**fmt)
                else:
                    self.labelobj(self.objects[name],**fmt)
                plt.show()
                self.objects[name].islabelled = True
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)

    # label object method -----------------------------
    def labelobj(self,obj,contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2,ax=plt.gca()):
        &#34;&#34;&#34;
            labelobj:
                labelobj(obj [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
        &#34;&#34;&#34;
        if contour: contour = obj.hascontour # e.g. overlays do not have contour

        if contour:
            patch = patches.PathPatch(obj.polygon2plot,
                                      facecolor=facecolor,
                                      edgecolor=edgecolor,
                                      lw=linewidth)
            obj.hlabel[&#34;contour&#34;] = ax.add_patch(patch)
        else:
            obj.hlabel[&#34;contour&#34;] = None
        obj.hlabel[&#34;text&#34;] = \
        plt.text(obj.xcenter,
                 obj.ycenter,
                 &#34;%s\n(t=$%d$,$n_p$=%d)&#34; % (obj.name, obj.beadtype,obj.nbeads),
                 horizontalalignment = &#34;center&#34;,
                 verticalalignment = &#34;center_baseline&#34;,
                 fontsize=self.fontsize
                 )


    def unlabel(self,name):
        &#34;&#34;&#34; unlabel &#34;&#34;&#34;
        if name in self.objects:
            if  self.objects[name].islabelled:
                self.objects[name].hlabel[&#34;contour&#34;].remove()
                self.objects[name].hlabel[&#34;text&#34;].remove()
                self.objects[name].hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
                self.objects[name].islabelled = False
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)


    # PLOT method ----------------------------
    def plot(self):
        &#34;&#34;&#34; plot &#34;&#34;&#34;
        for o in self.objects:
            if not self.objects[o].isplotted:
                if self.objects[o].alike == &#34;mixed&#34;:
                    for o2 in self.objects[o].collection:
                        self.plotobj(o2)
                else:
                    self.plotobj(self.objects[o])
                # store it as plotted
                self.objects[o].isplotted = True
                if not self.objects[o].ismask:
                    self.nbeads += self.objects[o].nbeads


    # PLOTobj method  -----------------------
    def plotobj(self,obj):
        &#34;&#34;&#34; plotobj(obj) &#34;&#34;&#34;
        if obj.alike == &#34;circle&#34;:
            xmin, ymin, xmax, ymax = self.frameobj(obj)
            j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
            points = np.vstack((j.flatten(),i.flatten())).T
            npoints = points.shape[0]
            inside = obj.polygon.contains_points(points)
            if obj.beadtype2 is None:          # -- no salting --
                for k in range(npoints):
                    if inside[k] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1
            else:
                for k in range(npoints):       # -- salting --
                    if inside[k] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            if np.random.rand()&lt;obj.beadtype2[1]:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                            else:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1

        elif obj.alike == &#34;overlay&#34;:
            xmin, ymin, xmax, ymax = self.frameobj(obj)
            j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
            points = np.vstack((j.flatten(),i.flatten())).T
            npoints = points.shape[0]
            inside = obj.select()
            if obj.beadtype2 is None:          # -- no salting --
                for k in range(npoints):
                    if inside[ points[k,1]-ymin, points[k,0]-xmin ] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1
            else:
                for k in range(npoints):       # -- salting --
                    if inside[ points[k,0]-ymin, points[k,0]-xmin ] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            if np.random.rand()&lt;obj.beadtype2[1]:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                            else:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1

        else:
            raise ValueError(&#34;This object type is notimplemented&#34;)

    # SHOW method ----------------------------
    def show(self,extra=&#34;none&#34;,contour=True,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; show method: show(extra=&#34;label&#34;,contour=True,what=&#34;beadtype&#34;) &#34;&#34;&#34;
        self.figure()
        if what==&#34;beadtype&#34;:
            imagesc(self.imbead)
        elif what == &#34;objindex&#34;:
            imagesc(self.imobj)
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        if extra == &#34;label&#34;:
            ax = plt.gca()
            for o in self.names():
                if not self.objects[o].ismask:
                    self.label(o,ax=ax,contour=contour)
            ax.set_title(&#34;raster area: %s \n (n=%d, $n_p$=%d)&#34; %\
                      (self.name,self.length(),self.nbeads) )
            plt.show()

    # SHOW method ----------------------------
    def print(self,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; print method &#34;&#34;&#34;
        txt = self.string(what=what)
        for i in range(len(txt)):
            print(txt[i],end=&#34;\n&#34;)


    # FIGURE method ----------------------------
    def figure(self):
        &#34;&#34;&#34; set the current figure &#34;&#34;&#34;
        if self.hfig==[] or not plt.fignum_exists(self.hfig.number):
            self.newfigure()
        plt.figure(self.hfig.number)

    # NEWFIGURE method ----------------------------
    def newfigure(self):
        &#34;&#34;&#34; create a new figure (dpi=200) &#34;&#34;&#34;
        self.hfig = plt.figure(dpi=self.dpi)

    # COPY OBJECT ALONG a contour -----------------
    def copyalongpath(self,obj,
                      name=&#34;path&#34;,
                  beadtype=None,
                      path=linear,
                      xmin=10,
                      ymin=10,
                      xmax=70,
                      ymax=90,
                         n=7,
                      USER=struct()):
        &#34;&#34;&#34;

        The method enable to copy an existing object (from the current raster,
        from another raster or a fake object) amp,g

        Parameters
        ----------
        obj : real or fake object
            the object to be copied.
        name : string, optional
            the name of the object collection. The default is &#34;path&#34;.
        beadtype : integet, optional
            type of bead (can override existing value). The default is None.
        path : function, optional
            parametric function returning x,y. The default is linear.
            x is between xmin and xmax, and y between ymin, ymax
        xmin : int64 or float, optional
            left x corner position. The default is 10.
        ymin : int64 or float, optional
            bottom y corner position. The default is 10.
        xmax : int64 or float, optional
            right x corner position. The default is 70.
        ymax : int64 or float, optional
            top y corner position. The default is 90.
        n : integet, optional
            number of copies. The default is 7.
     USER : structure to pass specific parameters

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if not isinstance(USER,struct):
            raise TypeError(&#34;USER should be a structure&#34;)
        x,y = path(xmin=xmin,ymin=ymin,xmax=xmax,ymax=ymax,n=n,USER=USER)
        btyp = obj.beadtype if beadtype == None else beadtype
        collect = {}
        for i in range(n):
            nameobj = &#34;%s_%s_%02d&#34; % (name,obj.name,i)
            x[i], y[i] = self.valid(x[i], y[i])
            translate = [ x[i]-obj.xcenter, y[i]-obj.ycenter ]
            collect[nameobj] = obj.copy(translate=translate,
                                        name=nameobj,
                                        beadtype=btyp)
        self.collection(**collect,name=name)


    # SCATTER -------------------------------
    def scatter(self,
                 E,
                 name=&#34;emulsion&#34;,
                 beadtype=None,
                 ismask = False
                 ):
        &#34;&#34;&#34;


        Parameters
        ----------
        E : scatter or emulsion object
            codes for x,y and r.
        name : string, optional
            name of the collection. The default is &#34;emulsion&#34;.
        beadtype : integer, optional
            for all objects. The default is 1.
        ismask : logical, optional
            Set it to true to force a mask. The default is False.

        Raises
        ------
        TypeError
            Return an error of the object is not a scatter type.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if isinstance(E,scatter):
            collect = {}
            for i in range(E.n):
                b = E.beadtype[i] if beadtype==None else beadtype
                nameobj = &#34;glob%02d&#34; % i
                collect[nameobj] = self.circle(E.x[i],E.y[i],E.r[i],
                            name=nameobj,beadtype=b,ismask=ismask,fake=True)
            self.collection(**collect,name=name)
        else:
            raise TypeError(&#34;the first argument must be an emulsion object&#34;)


# %% PRIVATE SUB-CLASSES
# Use the equivalent methods of raster() to call these constructors
#   raster.rectangle, raster.circle, raster.triangle... raster.collection
#
# Two counters are used for automatic naming
#   counter[0] is the overall index (total number of objects created)
#   counter[1] is the index of objects of this type (total number of objects created for this class)
#
#   Overview:
#       genericpolygon --&gt; Rectancle, Circle
#       Circle --&gt; Triangle, Diamond, Pentagon, Hexagon
#       Collection --&gt; graphical object for collections (many properties are dynamic)
#       struct --&gt; collection is the low-level class container of Collection

class coregeometry:
    &#34;&#34;&#34; core geometry object&#34;&#34;&#34;

    @property
    def xcenter(self):
        &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
        return self.xcenter0 + self.translate[0]
    @property
    def ycenter(self):
        &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
        return self.ycenter0 + self.translate[1]
    @property
    def xmin(self):
        &#34;&#34;&#34; xleft position &#34;&#34;&#34;
        return self.xmin0 + self.translate[0]
    @property
    def xmax(self):
        &#34;&#34;&#34; xright position &#34;&#34;&#34;
        return self.xmax0 + self.translate[0]
    @property
    def ymin(self):
        &#34;&#34;&#34; yleft position &#34;&#34;&#34;
        return self.ymin0 + self.translate[1]
    @property
    def ymax(self):
        &#34;&#34;&#34; yright position &#34;&#34;&#34;
        return self.ymax0 + self.translate[1]
    @property
    def width(self):
        &#34;&#34;&#34; oibject width range &#34;&#34;&#34;
        return self.xmax - self.xmin
    @property
    def height(self):
        &#34;&#34;&#34; oibject height range &#34;&#34;&#34;
        return self.ymax - self.ymin

    def copy(self,translate=None,beadtype=None,name=&#34;&#34;):
        &#34;&#34;&#34; returns a copy of the graphical object &#34;&#34;&#34;
        if self.alike != &#34;mixed&#34;:
            dup = deepduplicate(self)
            if translate != None: # applies translation
                dup.translate[0] += translate[0]
                dup.translate[1] += translate[1]
            if beadtype != None: # update beadtype
                dup.beadtype = beadtype
            if name != &#34;&#34;: # update name
                dup.name = name
            return dup
        else:
            raise ValueError(&#34;collections cannot be copied, regenerate the collection instead&#34;)


class overlay(coregeometry):
    &#34;&#34;&#34; generic overlay class &#34;&#34;&#34;

    hascontour = False
    hasclosefit = True

    def __init__(self,
                 counter = (0,0),
                 filename=&#34;./sandbox/image.jpg&#34;,
                 xmin = 0,
                 ymin = 0,
                 ncolors = 4,
                 flipud = True,
                 angle = 0,
                 scale = (1,1)
                 ):
        &#34;&#34;&#34; generate an overlay from file
                overlay(counter=(c1,c2),filename=&#34;this/is/myimage.jpg&#34;,xmin=x0,ymin=y0,colors=4)
                additional options
                    overlay(...,flipud=True,angle=0,scale=(1,1))
        &#34;&#34;&#34;
        self.name = &#34;over%03d&#34; % counter[1]
        self.kind = &#34;overlay&#34;       # kind of object
        self.alike = &#34;overlay&#34;      # similar object for plotting
        self.beadtype = 1           # bead type
        self.beadtype2 = None       # bead type 2 (alternative beadtype, ratio)
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]  # modification used when an object is duplicated
        if scale is None: scale = 1
        if not isinstance(scale,(tuple,list)): scale = (scale,scale)
        self.scale = scale
        if angle is None: angle = 0
        self.angle = angle
        self.flipud = flipud
        if not os.path.isfile(filename):
            raise IOError(f&#39;the file &#34;{filename}&#34; does not exist&#39;)
        self.filename = filename
        self.ncolors = ncolors
        self.color = None
        self.colormax = None
        self.original,self.raw,self.im,self.map = self.load()
        self.xmin0 = xmin
        self.ymin0 = ymin
        self.xmax0 = xmin + self.im.shape[1]
        self.ymax0 = ymin + self.im.shape[0]
        self.xcenter0 = (self.xmin+self.xmax)/2
        self.ycenter0 = (self.ymin+self.ymax)/2

    def select(self,color=None,colormax=None,scale=None,angle=None):
        &#34;&#34;&#34; select the color index:
                select(color = c) peeks pixels = c
                select(color = c, colormax = cmax) peeks pixels&gt;=c and pixels&lt;=cmax
        &#34;&#34;&#34;
        if color is None:
            color = self.color
        else:
            self.color = color
        if (colormax is None) and (self.colormax is not None) and (self.colormax &gt; self.color):
                colormax = self.colormax
        else:
            colormax = self.colormax = color
        if isinstance(color,int) and color&lt;len(self.map):
            S = np.logical_and(self.im&gt;=color,self.im&lt;=colormax)
            self.nbeads = np.count_nonzero(S)
            return np.flipud(S) if self.flipud else S
        raise ValueError(&#34;color must be an integer lower than %d&#34; % len(self.map))

    def load(self):
        &#34;&#34;&#34; load image and process it
                returns the image, the indexed image and its color map (Ã  la Matlab, such as imread)

                note: if the image contains a palette it is used, if not the
                image is converted to an indexed image without dihtering
        &#34;&#34;&#34;
        I = Image.open(self.filename)
        if self.angle != 0:
            I= I.rotate(self.angle)
        if self.scale[0] * self.scale[1] != 1:
            I = I.resize((round(I.size[0]*self.scale[0]),round(I.size[1]*self.scale[1])))
        palette = I.getpalette()
        if palette is None:
            J=I.convert(mode=&#34;P&#34;,colors=self.ncolors,palette=Image.Palette.ADAPTIVE)
            palette = J.getpalette()
        else:
            J = I
        p = np.array(palette,dtype=&#34;uint8&#34;).reshape((int(len(palette)/3),3))
        ncolors = len(p.sum(axis=1).nonzero()[0]);
        if ncolors&lt;self.ncolors:
            print(f&#34;only {ncolors} are available&#34;)
        return I,J, np.array(J,dtype=&#34;uint8&#34;), p[:ncolors,:]

    def __repr__(self):
        &#34;&#34;&#34; display for rectangle class &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(f&#39;\tfilename: &#34;{self.filename}&#34;&#39;)
        print(&#34;\tangle = %0.4g (original image)&#34; % self.angle)
        print(&#34;\tscale = [%0.4g, %0.4g] (original image)&#34; % self.scale)
        print(f&#34;\tncolors = {self.ncolors} (selected={self.color})&#34;)
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        print(&#34;note: use the attribute origina,raw to see the raw image&#34;)
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind,self.name,self.beadtype)



class genericpolygon(coregeometry):
    &#34;&#34;&#34; generic polygon methods &#34;&#34;&#34;

    hascontour = True
    hasclosefit = False

    @property
    def polygon(self):
        &#34;&#34;&#34;
        R.polygon = path.Path(R.vertices,R.codes,closed=True)
        &#34;&#34;&#34;
        v = self.vertices
        if self.translate != None:
            vtmp = list(map(list,zip(*v)))
            for i in range(len(vtmp[0])):
                vtmp[0][i] += self.translate[0]
                vtmp[1][i] += self.translate[1]
            v = list(zip(*vtmp))
        return path.Path(v,self.codes,closed=True)

    @property
    def polygon2plot(self):
        &#34;&#34;&#34;
        R.polygon2plot = path.Path(R.polygon.vertices+ np.array([1,1]),R.codes,closed=True)
        &#34;&#34;&#34;
        return path.Path(self.polygon.vertices+ np.array([1,1]),self.codes,closed=True)

    def corners(self):
        &#34;&#34;&#34; returns xmin, ymin, xmax, ymax &#34;&#34;&#34;
        return min([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
               min([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1], \
               max([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
               max([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1]


class Rectangle(genericpolygon):
    &#34;&#34;&#34; Rectangle class &#34;&#34;&#34;
    def __init__(self,counter):
        self.name = &#34;rect%03d&#34; % counter[1]
        self.kind = &#34;rectangle&#34;     # kind of object
        self.alike = &#34;circle&#34;       # similar object for plotting
        self.beadtype = 1           # bead type
        self.beadtype2 = None       # bead type 2 (alternative beadtype, ratio)
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]  # modification used when an object is duplicated

    def __repr__(self):
        &#34;&#34;&#34; display for rectangle class &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\tangle = %0.4g&#34; % self.angle)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind,self.name,self.beadtype)


class Circle(genericpolygon):
    &#34;&#34;&#34; Circle class &#34;&#34;&#34;
    def __init__(self,counter,resolution=20):
        self.name = &#34;circ%03d&#34; % counter[1]
        self.kind = &#34;circle&#34;         # kind of object
        self.alike = &#34;circle&#34;        # similar object for plotting
        self.resolution = resolution # default resolution
        self.beadtype = 1            # bead type
        self.beadtype2 = None        # bead type 2 (alternative beadtype, ratio)
        self.nbeads = 0              # number of beads
        self.ismask = False          # True if beadtype == 0
        self.isplotted = False       # True if plotted
        self.islabelled = False      # True if labelled
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]   # modification used when an object is duplicated


    def __repr__(self):
        &#34;&#34;&#34; display circle &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name,self.kind) )
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\tradius = %0.4g&#34; % self.radius)
        print(&#34;\tshaperatio = %0.4g&#34; % self.shaperatio)
        print(&#34;\tangle = %0.4g&#34; % self.angle)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind, self.name,self.beadtype)

class Triangle(Circle):
    &#34;&#34;&#34; Triangle class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=3)
        self.name = &#34;tri%03d&#34; % counter[1]
        self.kind = &#34;triangle&#34;     # kind of object


class Diamond(Circle):
    &#34;&#34;&#34; Diamond class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=4)
        self.name = &#34;diam%03d&#34; % counter[1]
        self.kind = &#34;diamond&#34;     # kind of object


class Pentagon(Circle):
    &#34;&#34;&#34; Pentagon class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=5)
        self.name = &#34;penta%03d&#34; % counter[1]
        self.kind = &#34;pentagon&#34;     # kind of object


class Hexagon(Circle):
    &#34;&#34;&#34; Hexagon class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=6)
        self.name = &#34;hex%03d&#34; % counter[1]
        self.kind = &#34;Hexagon&#34;     # kind of object

class collection(struct):
    &#34;&#34;&#34; collection class container (not to be called directly) &#34;&#34;&#34;
    _type = &#34;collect&#34;               # object type
    _fulltype = &#34;Collections&#34;    # full name
    _ftype = &#34;collection&#34;        # field name
    def __init__(self,*obj,**kwobj):
        # store the objects with their alias
        super().__init__(**kwobj)
        # store objects with their real names
        for o in obj:
            if isinstance(o,raster):
                s = struct.dict2struct(o.objects)
                list_s = s.keys()
                for i in range(len(list_s)): self.setattr(list_s[i], s[i].copy())
            elif o!=None:
                self.setattr(o.name, o.copy())

class Collection:
    &#34;&#34;&#34; Collection object &#34;&#34;&#34;
    def __init__(self,counter):
        self.name = &#34;collect%03d&#34; % counter[1]
        self.kind = &#34;collection&#34;    # kind of object
        self.alike = &#34;mixed&#34;        # similar object for plotting
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.collection = collection()
        self.translate = [0.0,0.0]

    def __repr__(self):
        keylengths = [len(key) for key in self.collection.keys()]
        width = max(10,max(keylengths)+2)
        fmt = &#34;%%%ss:&#34; % width
        line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(line)
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % self.xycenter)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        print(line,&#39;  name: type &#34;original name&#34; [centerx centery] [translatex translatey]&#39;,line,sep=&#34;\n&#34;)
        for key,value in self.collection.items():
            print(fmt % key,value.kind,
                  &#39;&#34;%s&#34;&#39; % value.name,
                  &#34;[%0.4g %0.4g]&#34; % (value.xcenter,value.ycenter),
                  &#34;[%0.4g %0.4g]&#34; % (value.translate[0],value.translate[1]))
        print(line)
        return &#34;%s object: %s (beadtype=[%s])&#34; % (self.kind,self.name,&#34;, &#34;.join(map(str,self.beadtype)))

    # GET -----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.collection:
            return self.collection.getattr(name)
        else:
            raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # GETATTR --------------------------
    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return self.get(key)

    @property
    def xycenter(self):
        &#34;&#34;&#34; returns the xcenter and ycenter of  the collection &#34;&#34;&#34;
        sx = sy = 0
        n = len(self.collection)
        for o in self.collection:
            sx += o.xcenter
            sy += o.ycenter
        return sx/n, sy/n

    @property
    def xcenter(self):
        &#34;&#34;&#34; returns xcenter &#34;&#34;&#34;
        xc,_ = self.xycenter

    @property
    def ycenter(self):
        &#34;&#34;&#34; returns ycenter &#34;&#34;&#34;
        _,yc = self.xycenter

    @property
    def beadtype(self):
        &#34;&#34;&#34; returns the xcenter and ycenter of the collection &#34;&#34;&#34;
        b = []
        for o in self.collection:
            if o.beadtype not in b:
                b.append(o.beadtype)
        if len(b)==0:
            return 1
        else:
            return b


# %% scatter class and emulsion class
#    Simplified scatter and emulsion generator

class scatter():
    &#34;&#34;&#34; generic top scatter class &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        The scatter class provides an easy constructor
        to distribute in space objects according to their
        positions x,y, size r (radius) and beadtype.

        The class is used to derive emulsions.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.x = np.array([],dtype=int)
        self.y = np.array([],dtype=int)
        self.r = np.array([],dtype=int)
        self.beadtype = []

    @property
    def n(self):
        return len(self.x)

    def pairdist(self,x,y):
        &#34;&#34;&#34; pair distance to the surface of all disks/spheres &#34;&#34;&#34;
        if self.n==0:
            return np.Inf
        else:
            return np.floor(np.sqrt((x-self.x)**2+(y-self.y)**2)-self.r)


class emulsion(scatter):
    &#34;&#34;&#34; emulsion generator &#34;&#34;&#34;

    def __init__(self, xmin=10, ymin=10, xmax=90, ymax=90,
                 maxtrials=1000, beadtype=1, forcedinsertion=True):
        &#34;&#34;&#34;


        Parameters
        ----------
        The insertions are performed between xmin,ymin and xmax,ymax
        xmin : int64 or real, optional
            x left corner. The default is 10.
        ymin : int64 or real, optional
            y bottom corner. The default is 10.
        xmax : int64 or real, optional
            x right corner. The default is 90.
        ymax : int64 or real, optional
            y top corner. The default is 90.
        beadtype : default beadtype to apply if not precised at insertion
        maxtrials : integer, optional
            Maximum of attempts for an object. The default is 1000.
        forcedinsertion : logical, optional
            Set it to true to force the next insertion. The default is True.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        super().__init__()
        self.xmin, self.xmax, self.ymin, self.ymax = xmin, xmax, ymin, ymax
        self.lastinsertion = (None,None,None,None) # x,y,r, beadtype
        self.width = xmax-xmin
        self.height = ymax-ymin
        self.defautbeadtype = beadtype
        self.maxtrials = maxtrials
        self.forcedinsertion = forcedinsertion

    def __repr__(self):
        print(f&#34; Emulsion object\n\t{self.width}x{self.height} starting at x={self.xmin}, y={self.ymin}&#34;)
        print(f&#34;\tcontains {self.n} insertions&#34;)
        print(&#34;\tmaximum insertion trials:&#34;, self.maxtrials)
        print(&#34;\tforce next insertion if previous fails:&#34;, self.forcedinsertion)
        return f&#34;emulsion with {self.n} insertions&#34;


    def walldist(self,x,y):
        &#34;&#34;&#34; shortest distance to the wall &#34;&#34;&#34;
        return min(abs(x-self.xmin),abs(y-self.ymin),abs(x-self.xmax),abs(y-self.ymax))

    def dist(self,x,y):
        &#34;&#34;&#34; shortest distance of the center (x,y) to the wall or any object&#34;&#34;&#34;
        return np.minimum(np.min(self.pairdist(x,y)),self.walldist(x,y))

    def accepted(self,x,y,r):
        &#34;&#34;&#34; acceptation criterion &#34;&#34;&#34;
        return self.dist(x,y)&gt;r

    def rand(self):
        &#34;&#34;&#34; random position x,y  &#34;&#34;&#34;
        return  np.round(np.random.uniform(low=self.xmin,high=self.xmax)), \
                np.round(np.random.uniform(low=self.ymin,high=self.ymax))

    def setbeadtype(self,beadtype):
        &#34;&#34;&#34; set the default or the supplied beadtype  &#34;&#34;&#34;
        if beadtype == None:
            self.beadtype.append(self.defautbeadtype)
            return self.defautbeadtype
        else:
            self.beadtype.append(beadtype)
            return beadtype

    def insertone(self,x=None,y=None,r=None,beadtype=None,overlap=False):
        &#34;&#34;&#34;
            insert one object of radius r
            properties:
                x,y coordinates (if missing, picked randomly from uniform distribution)
                r radius (default = 2% of diagonal)
                beadtype (default = defautbeadtype)
                overlap = False (accept only if no overlap)
        &#34;&#34;&#34;
        attempt, success = 0, False
        random = (x==None) or (y==None)
        if r==None:
            r = 0.02*np.sqrt(self.width**2+self.height**2)
        while not success and attempt&lt;self.maxtrials:
            attempt += 1
            if random: x,y = self.rand()
            if overlap:
                success = True
            else:
                success = self.accepted(x,y,r)
        if success:
            self.x = np.append(self.x,x)
            self.y = np.append(self.y,y)
            self.r = np.append(self.r,r)
            b=self.setbeadtype(beadtype)
            self.lastinsertion = (x,y,r,b)
        return success

    def insertion(self,rlist,beadtype=None):
        &#34;&#34;&#34;
            insert a list of objects
                nsuccess=insertion(rlist,beadtype=None)
                beadtype=b forces the value b
                if None, defaultbeadtype is used instead
        &#34;&#34;&#34;
        rlist.sort(reverse=True)
        ntodo = len(rlist)
        n = nsuccess = 0
        stop = False
        while not stop:
            n += 1
            success = self.insertone(r=rlist[n-1],beadtype=beadtype)
            if success: nsuccess += 1
            stop = (n==ntodo) or (not success and not self.forcedinsertion)
        if nsuccess==ntodo:
            print(f&#34;{nsuccess} objects inserted successfully&#34;)
        else:
            print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
        return nsuccess


class coreshell(emulsion):
    &#34;&#34;&#34;
        coreshell generator
            inherited from emulsion
            the method insertion has been modified to integrate
                thickess = shell thickness value
                beadtype = (shell beadtype, core beadtype)
    &#34;&#34;&#34;

    def insertion(self,rlist,thickness=None, beadtype=(1,2)):
        &#34;&#34;&#34;
            insert a list of objects
                nsuccess=insertion(...)

                List of properties
                    rlist = [r1, r2,...]
                    thickness = shell thcikness value
                    beadtype = (shell beadtype, core beadtype)
        &#34;&#34;&#34;
        # check arguments
        if thickness==None:
            raise AttributeError(&#34;set a value for the shell thickness&#34;)
        if not isinstance(beadtype,tuple):
            raise TypeError(&#34;beadtype must be a turple&#34;)
        # prepare the work
        rlist.sort(reverse=True)
        ntodo = len(rlist)
        n = nsuccess = 0
        stop = False
        while not stop:
            # next insertion and check rcore
            n += 1
            rshell = rlist[n-1]
            rcore = rshell - thickness
            if rcore&lt;=0:
                raise ValueError(
 f&#34;The external radius={rshell} cannot be smaller than the shell thickness={thickness}&#34;)
            # do the insertion of the shell (largest radius)
            success = self.insertone(r=rshell,beadtype=beadtype[0],overlap=False)
            if success:
                success = self.insertone(
                    x = self.lastinsertion[0],
                    y = self.lastinsertion[1],
                    r=rcore,
                    beadtype=beadtype[1],
                    overlap=True)
                nsuccess += 1
            stop = (n==ntodo) or (not success and not self.forcedinsertion)
        if nsuccess==ntodo:
            print(f&#34;{nsuccess} objects inserted successfully&#34;)
        else:
            print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
        return nsuccess

# %% debug section - generic code to test methods (press F5)
# ===================================================
# main()
# ===================================================
# for debugging purposes (code called as a script)
# the code is called from here
# ===================================================
if __name__ == &#39;__main__&#39;:

# %% basic example

    plt.close(&#34;all&#34;)
    R = raster()
    R.rectangle(1,24,2,20,name=&#39;rect1&#39;)
    R.rectangle(60,80,50,81,name=&#39;rect2&#39;,beadtype=2,angle=40,beadtype2=(9,0.2))
    R.rectangle(50,50,10,10,mode=&#34;center&#34;,angle=45,beadtype=1)
    R.circle(45,20,5,name=&#39;C1&#39;,beadtype=3,beadtype2=(8,0.25))
    R.circle(35,10,5,name=&#39;C2&#39;,beadtype=3)

    R.circle(15,30,10,name=&#39;p1&#39;,beadtype=4,shaperatio=0.2,angle=-30)
    R.circle(12,40,8,name=&#39;p2&#39;,beadtype=4,shaperatio=0.2,angle=20)
    R.circle(12,80,22,name=&#39;p3&#39;,beadtype=4,shaperatio=1.3,angle=20,beadtype2=(9,0.1))

    R.triangle(85,20,10,name=&#39;T1&#39;,beadtype=5,angle=20)
    R.diamond(85,35,5,name=&#39;D1&#39;,beadtype=5,angle=20,beadtype2=(9,0.5))
    R.pentagon(50,35,5,name=&#39;P1&#39;,beadtype=5,angle=90)
    R.hexagon(47,85,12,name=&#39;H1&#39;,beadtype=5,angle=90)

    R.label(&#34;rect003&#34;)
    R.plot()

    R.list()
    R.show()

    R.clear()
    R.show()
    R.plot()
    R.show(extra=&#34;label&#34;)
    R.label(&#34;rect003&#34;)
    R.unlabel(&#39;rect1&#39;)

    X=R.data()

# %% another example
    S = raster(width=1000,height=1000)
    S.rectangle(150,850,850,1000,name=&#34;top&#34;,beadtype=1)
    S.rectangle(150,850,0,150,name=&#34;bottom&#34;,beadtype=2)
    S.circle(500,500,480,name=&#34;mask&#34;,ismask=True,resolution=500)
    S.triangle(250,880,80,name=&#39;tooth1&#39;,angle=60,beadtype=1)
    S.triangle(750,880,80,name=&#39;tooth2&#39;,angle=-0,beadtype=1)
    S.circle(500,200,300,name=&#34;tongue&#34;,beadtype=5,shaperatio=0.3,resolution=300)
    S.rectangle(500,450,320,320,name=&#34;food&#34;,mode=&#34;center&#34;,beadtype=3)
    S.plot()
    S.show(extra=&#34;label&#34;,contour=False)



# %% advanced example
    #plt.close(&#34;all&#34;)
    draft = raster()
    draft.rectangle(1,24,2,20,name=&#39;rect1&#39;),
    draft.rectangle(60,80,50,81,name=&#39;rect2&#39;,beadtype=2,angle=40),
    draft.rectangle(50,50,10,10,mode=&#34;center&#34;,angle=45,beadtype=1),
    draft.circle(45,20,5,name=&#39;C1&#39;,beadtype=3),
    draft.circle(35,10,5,name=&#39;C2&#39;,beadtype=3),
    draft.circle(10,10,2,name=&#34;X&#34;,beadtype=4)

    A = raster()
    A.collection(draft,name=&#34;C1&#34;,beadtype=1,translate=[10,30])
    repr(A)
    A.objects
    A.plot()
    A.show(extra=&#34;label&#34;)
    A.objects

    B = raster()
    #B.collection(X=draft.X,beadtype=1,translate=[50,50])
    B.copyalongpath(draft.X,name=&#34;PX&#34;,beadtype=2,
                    path=arc,
                     xmin=10,
                     ymin=10,
                     xmax=90,
                     ymax=50,
                        n=12)
    B.plot()
    B.show(extra=&#34;label&#34;)


# %% emulsion example
    C = raster(width=400,height=400)
    e = emulsion(xmin=10, ymin=10, xmax=390, ymax=390)
    e.insertion([60,50,40,30,20,15,15,10,8,20,12,8,6,4,11,13],beadtype=1)
    e.insertion([30,10,20,2,4,5,5,10,12,20,25,12,14,16,17],beadtype=2)
    e.insertion([40,2,8,6,6,5,5,2,3,4,4,4,4,4,10,16,12,14,13],beadtype=3)
    C.scatter(e,name=&#34;emulsion&#34;)
    C.plot()
    C.show()


# %% core-shell example
    D = raster(width=400,height=400)
    cs = coreshell(xmin=10, ymin=10, xmax=390, ymax=390)
    cs.insertion([60,50,40,30,20,15,15,10,8,20,12,8,11,13],beadtype=(1,2),thickness = 4)
    D.scatter(cs,name=&#34;core-shell&#34;)
    D.plot()
    D.show()

# %% overlay example
    I = raster(width=600,height=600)
    I.overlay(30,100,name=&#34;pix0&#34;,filename=&#34;./sandbox/image.jpg&#34;,ncolors=4,color=0,beadtype=1,angle=10,scale=(1.1,1.1))
    I.overlay(30,100,name=&#34;pix2&#34;,filename=&#34;./sandbox/image.jpg&#34;,ncolors=4,color=2,beadtype=2,angle=10,scale=(1.1,1.1))
    I.label(&#34;pix0&#34;)
    I.plot()
    I.show(extra=&#34;label&#34;)
    I.pix0.original
    I.pix0.raw
    a = I.torgb(&#34;objindex&#34;,(512,512))
    a.show()
    a.save(&#34;./tmp/preview.png&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="raster.arc"><code class="name flex">
<span>def <span class="ident">arc</span></span>(<span>xmin=10, ymin=50, xmax=80, ymax=50, n=5, USER=structure (struct object) with 2 fields)</span>
</code></dt>
<dd>
<div class="desc"><p>Point distributed along an arc
X,Y = arc(xmin=value,ymin=value,xmax=value,ymax=value,n=int,
USER=struct(radius=value,direction=1))
Use direction to choose the upward +1 or downward -1 circle
see: <a href="https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points">https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arc(xmin=10,ymin=50,xmax=80,ymax=50,n=5,USER=struct(radius=20,direction=1)):
    &#34;&#34;&#34;  Point distributed along an arc
            X,Y = arc(xmin=value,ymin=value,xmax=value,ymax=value,n=int,
                      USER=struct(radius=value,direction=1))
            Use direction to choose the upward +1 or downward -1 circle
        see: https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points
    &#34;&#34;&#34;
    R = 0 if &#34;radius&#34; not in USER else USER.radius
    direction = +1 if &#34;direction&#34; not in USER else USER.direction
    dx,dy = xmax-xmin, ymax-ymin
    q = np.sqrt(dx**2+dy**2) # distance
    R = max(R,q/2) # radius constraint
    d = np.sqrt(R**2-(q/2)**2) # distance along the mirror line
    xc = (xmin+xmax)/2 - direction * d*dy/q
    yc = (ymin+ymax)/2 + direction * d*dx/q
    thmin,thmax = np.arctan((ymin-yc)/(xmin-xc)), np.arctan((ymax-yc)/(xmax-xc))
    if d==0: thmax = thmin + np.pi
    th = np.linspace(thmin,thmax,n)
    return xc+np.cos(th)*R,yc+np.sin(th)*R</code></pre>
</details>
</dd>
<dt id="raster.imagesc"><code class="name flex">
<span>def <span class="ident">imagesc</span></span>(<span>im, x=None, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>imagesc Ã  la Matlab
imagesc(np2array)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imagesc(im,x=None,y=None):
    &#34;&#34;&#34;  imagesc Ã  la Matlab
            imagesc(np2array) &#34;&#34;&#34;
    if x==None: x=np.arange(1,np.shape(im)[1]+1)
    if y==None: y=np.arange(1,np.shape(im)[0]+1)
    plt.imshow(im, extent=_extents(x) + _extents(y),
               aspect=&#34;auto&#34;, origin=&#34;lower&#34;, interpolation=&#34;none&#34;)</code></pre>
</details>
</dd>
<dt id="raster.ind2rgb"><code class="name flex">
<span>def <span class="ident">ind2rgb</span></span>(<span>im, ncolors=64)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert indexed image (NumPy array) to RGB
rgb = ind2rgb(np2array,ncolors=nc)
use rgb.save("/path/filename.png") for saving</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ind2rgb(im,ncolors=64):
    &#34;&#34;&#34; Convert indexed image (NumPy array) to RGB
            rgb = ind2rgb(np2array,ncolors=nc)
            use rgb.save(&#34;/path/filename.png&#34;) for saving
    &#34;&#34;&#34;
    raw = Image.fromarray(np.flipud(im),&#34;P&#34;)
    col0 = np.array(np.round(255*cmap.get_cmap(&#34;viridis&#34;,ncolors).colors[:,:3]),dtype=&#34;uint8&#34;)
    col = bytearray(np.resize(col0,(256,3)).flatten())
    pal = ImagePalette.ImagePalette(mode=&#34;RGB&#34;,palette=col)
    #Image.convert(mode=None, matrix=None, dither=None, palette=Palette.WEB, colors=256)
    raw.putpalette(pal)
    return raw</code></pre>
</details>
</dd>
<dt id="raster.linear"><code class="name flex">
<span>def <span class="ident">linear</span></span>(<span>xmin=10, ymin=10, xmax=80, ymax=80, n=5, USER=structure (struct object) with 0 fields)</span>
</code></dt>
<dd>
<div class="desc"><p>Equispaced points along a trajectory
X,Y = linear(xmin=value,ymin=value,xmax=value,ymax=value,n=int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear(xmin=10,ymin=10,xmax=80,ymax=80,n=5,USER=struct()):
    &#34;&#34;&#34;  Equispaced points along a trajectory
            X,Y = linear(xmin=value,ymin=value,xmax=value,ymax=value,n=int)
    &#34;&#34;&#34;
    return np.linspace(xmin,xmax,n), np.linspace(ymin,ymax,n)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="raster.Circle"><code class="flex name class">
<span>class <span class="ident">Circle</span></span>
<span>(</span><span>counter, resolution=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Circle class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Circle(genericpolygon):
    &#34;&#34;&#34; Circle class &#34;&#34;&#34;
    def __init__(self,counter,resolution=20):
        self.name = &#34;circ%03d&#34; % counter[1]
        self.kind = &#34;circle&#34;         # kind of object
        self.alike = &#34;circle&#34;        # similar object for plotting
        self.resolution = resolution # default resolution
        self.beadtype = 1            # bead type
        self.beadtype2 = None        # bead type 2 (alternative beadtype, ratio)
        self.nbeads = 0              # number of beads
        self.ismask = False          # True if beadtype == 0
        self.isplotted = False       # True if plotted
        self.islabelled = False      # True if labelled
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]   # modification used when an object is duplicated


    def __repr__(self):
        &#34;&#34;&#34; display circle &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name,self.kind) )
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\tradius = %0.4g&#34; % self.radius)
        print(&#34;\tshaperatio = %0.4g&#34; % self.shaperatio)
        print(&#34;\tangle = %0.4g&#34; % self.angle)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind, self.name,self.beadtype)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="raster.Diamond" href="#raster.Diamond">Diamond</a></li>
<li><a title="raster.Hexagon" href="#raster.Hexagon">Hexagon</a></li>
<li><a title="raster.Pentagon" href="#raster.Pentagon">Pentagon</a></li>
<li><a title="raster.Triangle" href="#raster.Triangle">Triangle</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.genericpolygon.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.genericpolygon.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.genericpolygon.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.genericpolygon.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.genericpolygon.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.genericpolygon.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.genericpolygon.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.genericpolygon.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.genericpolygon.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.genericpolygon.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.genericpolygon.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.genericpolygon.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.Collection"><code class="flex name class">
<span>class <span class="ident">Collection</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Collection object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Collection:
    &#34;&#34;&#34; Collection object &#34;&#34;&#34;
    def __init__(self,counter):
        self.name = &#34;collect%03d&#34; % counter[1]
        self.kind = &#34;collection&#34;    # kind of object
        self.alike = &#34;mixed&#34;        # similar object for plotting
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.collection = collection()
        self.translate = [0.0,0.0]

    def __repr__(self):
        keylengths = [len(key) for key in self.collection.keys()]
        width = max(10,max(keylengths)+2)
        fmt = &#34;%%%ss:&#34; % width
        line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(line)
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % self.xycenter)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        print(line,&#39;  name: type &#34;original name&#34; [centerx centery] [translatex translatey]&#39;,line,sep=&#34;\n&#34;)
        for key,value in self.collection.items():
            print(fmt % key,value.kind,
                  &#39;&#34;%s&#34;&#39; % value.name,
                  &#34;[%0.4g %0.4g]&#34; % (value.xcenter,value.ycenter),
                  &#34;[%0.4g %0.4g]&#34; % (value.translate[0],value.translate[1]))
        print(line)
        return &#34;%s object: %s (beadtype=[%s])&#34; % (self.kind,self.name,&#34;, &#34;.join(map(str,self.beadtype)))

    # GET -----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.collection:
            return self.collection.getattr(name)
        else:
            raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # GETATTR --------------------------
    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return self.get(key)

    @property
    def xycenter(self):
        &#34;&#34;&#34; returns the xcenter and ycenter of  the collection &#34;&#34;&#34;
        sx = sy = 0
        n = len(self.collection)
        for o in self.collection:
            sx += o.xcenter
            sy += o.ycenter
        return sx/n, sy/n

    @property
    def xcenter(self):
        &#34;&#34;&#34; returns xcenter &#34;&#34;&#34;
        xc,_ = self.xycenter

    @property
    def ycenter(self):
        &#34;&#34;&#34; returns ycenter &#34;&#34;&#34;
        _,yc = self.xycenter

    @property
    def beadtype(self):
        &#34;&#34;&#34; returns the xcenter and ycenter of the collection &#34;&#34;&#34;
        b = []
        for o in self.collection:
            if o.beadtype not in b:
                b.append(o.beadtype)
        if len(b)==0:
            return 1
        else:
            return b</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="raster.Collection.beadtype"><code class="name">var <span class="ident">beadtype</span></code></dt>
<dd>
<div class="desc"><p>returns the xcenter and ycenter of the collection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beadtype(self):
    &#34;&#34;&#34; returns the xcenter and ycenter of the collection &#34;&#34;&#34;
    b = []
    for o in self.collection:
        if o.beadtype not in b:
            b.append(o.beadtype)
    if len(b)==0:
        return 1
    else:
        return b</code></pre>
</details>
</dd>
<dt id="raster.Collection.xcenter"><code class="name">var <span class="ident">xcenter</span></code></dt>
<dd>
<div class="desc"><p>returns xcenter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xcenter(self):
    &#34;&#34;&#34; returns xcenter &#34;&#34;&#34;
    xc,_ = self.xycenter</code></pre>
</details>
</dd>
<dt id="raster.Collection.xycenter"><code class="name">var <span class="ident">xycenter</span></code></dt>
<dd>
<div class="desc"><p>returns the xcenter and ycenter of
the collection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xycenter(self):
    &#34;&#34;&#34; returns the xcenter and ycenter of  the collection &#34;&#34;&#34;
    sx = sy = 0
    n = len(self.collection)
    for o in self.collection:
        sx += o.xcenter
        sy += o.ycenter
    return sx/n, sy/n</code></pre>
</details>
</dd>
<dt id="raster.Collection.ycenter"><code class="name">var <span class="ident">ycenter</span></code></dt>
<dd>
<div class="desc"><p>returns ycenter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ycenter(self):
    &#34;&#34;&#34; returns ycenter &#34;&#34;&#34;
    _,yc = self.xycenter</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.Collection.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self,name):
    &#34;&#34;&#34; returns the object &#34;&#34;&#34;
    if name in self.collection:
        return self.collection.getattr(name)
    else:
        raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="raster.Diamond"><code class="flex name class">
<span>class <span class="ident">Diamond</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Diamond class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Diamond(Circle):
    &#34;&#34;&#34; Diamond class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=4)
        self.name = &#34;diam%03d&#34; % counter[1]
        self.kind = &#34;diamond&#34;     # kind of object</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.Circle" href="#raster.Circle">Circle</a></li>
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.Circle" href="#raster.Circle">Circle</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.Circle.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.Circle.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.Circle.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.Circle.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.Circle.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.Circle.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.Circle.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.Circle.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.Circle.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.Circle.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.Circle.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.Circle.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.Hexagon"><code class="flex name class">
<span>class <span class="ident">Hexagon</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Hexagon class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hexagon(Circle):
    &#34;&#34;&#34; Hexagon class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=6)
        self.name = &#34;hex%03d&#34; % counter[1]
        self.kind = &#34;Hexagon&#34;     # kind of object</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.Circle" href="#raster.Circle">Circle</a></li>
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.Circle" href="#raster.Circle">Circle</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.Circle.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.Circle.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.Circle.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.Circle.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.Circle.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.Circle.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.Circle.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.Circle.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.Circle.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.Circle.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.Circle.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.Circle.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.Pentagon"><code class="flex name class">
<span>class <span class="ident">Pentagon</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Pentagon class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pentagon(Circle):
    &#34;&#34;&#34; Pentagon class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=5)
        self.name = &#34;penta%03d&#34; % counter[1]
        self.kind = &#34;pentagon&#34;     # kind of object</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.Circle" href="#raster.Circle">Circle</a></li>
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.Circle" href="#raster.Circle">Circle</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.Circle.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.Circle.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.Circle.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.Circle.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.Circle.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.Circle.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.Circle.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.Circle.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.Circle.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.Circle.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.Circle.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.Circle.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.Rectangle"><code class="flex name class">
<span>class <span class="ident">Rectangle</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Rectangle class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rectangle(genericpolygon):
    &#34;&#34;&#34; Rectangle class &#34;&#34;&#34;
    def __init__(self,counter):
        self.name = &#34;rect%03d&#34; % counter[1]
        self.kind = &#34;rectangle&#34;     # kind of object
        self.alike = &#34;circle&#34;       # similar object for plotting
        self.beadtype = 1           # bead type
        self.beadtype2 = None       # bead type 2 (alternative beadtype, ratio)
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]  # modification used when an object is duplicated

    def __repr__(self):
        &#34;&#34;&#34; display for rectangle class &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\tangle = %0.4g&#34; % self.angle)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind,self.name,self.beadtype)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.genericpolygon.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.genericpolygon.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.genericpolygon.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.genericpolygon.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.genericpolygon.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.genericpolygon.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.genericpolygon.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.genericpolygon.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.genericpolygon.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.genericpolygon.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.genericpolygon.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.genericpolygon.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.Triangle"><code class="flex name class">
<span>class <span class="ident">Triangle</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Triangle class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Triangle(Circle):
    &#34;&#34;&#34; Triangle class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=3)
        self.name = &#34;tri%03d&#34; % counter[1]
        self.kind = &#34;triangle&#34;     # kind of object</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.Circle" href="#raster.Circle">Circle</a></li>
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.Circle" href="#raster.Circle">Circle</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.Circle.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.Circle.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.Circle.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.Circle.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.Circle.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.Circle.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.Circle.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.Circle.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.Circle.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.Circle.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.Circle.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.Circle.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.collection"><code class="flex name class">
<span>class <span class="ident">collection</span></span>
<span>(</span><span>*obj, **kwobj)</span>
</code></dt>
<dd>
<div class="desc"><p>collection class container (not to be called directly) </p>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class collection(struct):
    &#34;&#34;&#34; collection class container (not to be called directly) &#34;&#34;&#34;
    _type = &#34;collect&#34;               # object type
    _fulltype = &#34;Collections&#34;    # full name
    _ftype = &#34;collection&#34;        # field name
    def __init__(self,*obj,**kwobj):
        # store the objects with their alias
        super().__init__(**kwobj)
        # store objects with their real names
        for o in obj:
            if isinstance(o,raster):
                s = struct.dict2struct(o.objects)
                list_s = s.keys()
                for i in range(len(list_s)): self.setattr(list_s[i], s[i].copy())
            elif o!=None:
                self.setattr(o.name, o.copy())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="raster.coregeometry"><code class="flex name class">
<span>class <span class="ident">coregeometry</span></span>
</code></dt>
<dd>
<div class="desc"><p>core geometry object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class coregeometry:
    &#34;&#34;&#34; core geometry object&#34;&#34;&#34;

    @property
    def xcenter(self):
        &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
        return self.xcenter0 + self.translate[0]
    @property
    def ycenter(self):
        &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
        return self.ycenter0 + self.translate[1]
    @property
    def xmin(self):
        &#34;&#34;&#34; xleft position &#34;&#34;&#34;
        return self.xmin0 + self.translate[0]
    @property
    def xmax(self):
        &#34;&#34;&#34; xright position &#34;&#34;&#34;
        return self.xmax0 + self.translate[0]
    @property
    def ymin(self):
        &#34;&#34;&#34; yleft position &#34;&#34;&#34;
        return self.ymin0 + self.translate[1]
    @property
    def ymax(self):
        &#34;&#34;&#34; yright position &#34;&#34;&#34;
        return self.ymax0 + self.translate[1]
    @property
    def width(self):
        &#34;&#34;&#34; oibject width range &#34;&#34;&#34;
        return self.xmax - self.xmin
    @property
    def height(self):
        &#34;&#34;&#34; oibject height range &#34;&#34;&#34;
        return self.ymax - self.ymin

    def copy(self,translate=None,beadtype=None,name=&#34;&#34;):
        &#34;&#34;&#34; returns a copy of the graphical object &#34;&#34;&#34;
        if self.alike != &#34;mixed&#34;:
            dup = deepduplicate(self)
            if translate != None: # applies translation
                dup.translate[0] += translate[0]
                dup.translate[1] += translate[1]
            if beadtype != None: # update beadtype
                dup.beadtype = beadtype
            if name != &#34;&#34;: # update name
                dup.name = name
            return dup
        else:
            raise ValueError(&#34;collections cannot be copied, regenerate the collection instead&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.overlay" href="#raster.overlay">overlay</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="raster.coregeometry.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"><p>oibject height range</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self):
    &#34;&#34;&#34; oibject height range &#34;&#34;&#34;
    return self.ymax - self.ymin</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"><p>oibject width range</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self):
    &#34;&#34;&#34; oibject width range &#34;&#34;&#34;
    return self.xmax - self.xmin</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.xcenter"><code class="name">var <span class="ident">xcenter</span></code></dt>
<dd>
<div class="desc"><p>xcenter with translate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xcenter(self):
    &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
    return self.xcenter0 + self.translate[0]</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.xmax"><code class="name">var <span class="ident">xmax</span></code></dt>
<dd>
<div class="desc"><p>xright position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xmax(self):
    &#34;&#34;&#34; xright position &#34;&#34;&#34;
    return self.xmax0 + self.translate[0]</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.xmin"><code class="name">var <span class="ident">xmin</span></code></dt>
<dd>
<div class="desc"><p>xleft position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xmin(self):
    &#34;&#34;&#34; xleft position &#34;&#34;&#34;
    return self.xmin0 + self.translate[0]</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.ycenter"><code class="name">var <span class="ident">ycenter</span></code></dt>
<dd>
<div class="desc"><p>xcenter with translate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ycenter(self):
    &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
    return self.ycenter0 + self.translate[1]</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.ymax"><code class="name">var <span class="ident">ymax</span></code></dt>
<dd>
<div class="desc"><p>yright position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ymax(self):
    &#34;&#34;&#34; yright position &#34;&#34;&#34;
    return self.ymax0 + self.translate[1]</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.ymin"><code class="name">var <span class="ident">ymin</span></code></dt>
<dd>
<div class="desc"><p>yleft position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ymin(self):
    &#34;&#34;&#34; yleft position &#34;&#34;&#34;
    return self.ymin0 + self.translate[1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.coregeometry.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, translate=None, beadtype=None, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>returns a copy of the graphical object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self,translate=None,beadtype=None,name=&#34;&#34;):
    &#34;&#34;&#34; returns a copy of the graphical object &#34;&#34;&#34;
    if self.alike != &#34;mixed&#34;:
        dup = deepduplicate(self)
        if translate != None: # applies translation
            dup.translate[0] += translate[0]
            dup.translate[1] += translate[1]
        if beadtype != None: # update beadtype
            dup.beadtype = beadtype
        if name != &#34;&#34;: # update name
            dup.name = name
        return dup
    else:
        raise ValueError(&#34;collections cannot be copied, regenerate the collection instead&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="raster.coreshell"><code class="flex name class">
<span>class <span class="ident">coreshell</span></span>
<span>(</span><span>xmin=10, ymin=10, xmax=90, ymax=90, maxtrials=1000, beadtype=1, forcedinsertion=True)</span>
</code></dt>
<dd>
<div class="desc"><p>coreshell generator
inherited from emulsion
the method insertion has been modified to integrate
thickess = shell thickness value
beadtype = (shell beadtype, core beadtype)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>The insertions are performed between xmin,ymin and xmax,ymax</dt>
<dt><strong><code>xmin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>x left corner. The default is 10.</dd>
<dt><strong><code>ymin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>y bottom corner. The default is 10.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>x right corner. The default is 90.</dd>
<dt><strong><code>ymax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>y top corner. The default is 90.</dd>
<dt><strong><code>beadtype</code></strong> :&ensp;<code>default beadtype to apply if not precised at insertion</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>maxtrials</code></strong> :&ensp;<code>integer</code>, optional</dt>
<dd>Maximum of attempts for an object. The default is 1000.</dd>
<dt><strong><code>forcedinsertion</code></strong> :&ensp;<code>logical</code>, optional</dt>
<dd>Set it to true to force the next insertion. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class coreshell(emulsion):
    &#34;&#34;&#34;
        coreshell generator
            inherited from emulsion
            the method insertion has been modified to integrate
                thickess = shell thickness value
                beadtype = (shell beadtype, core beadtype)
    &#34;&#34;&#34;

    def insertion(self,rlist,thickness=None, beadtype=(1,2)):
        &#34;&#34;&#34;
            insert a list of objects
                nsuccess=insertion(...)

                List of properties
                    rlist = [r1, r2,...]
                    thickness = shell thcikness value
                    beadtype = (shell beadtype, core beadtype)
        &#34;&#34;&#34;
        # check arguments
        if thickness==None:
            raise AttributeError(&#34;set a value for the shell thickness&#34;)
        if not isinstance(beadtype,tuple):
            raise TypeError(&#34;beadtype must be a turple&#34;)
        # prepare the work
        rlist.sort(reverse=True)
        ntodo = len(rlist)
        n = nsuccess = 0
        stop = False
        while not stop:
            # next insertion and check rcore
            n += 1
            rshell = rlist[n-1]
            rcore = rshell - thickness
            if rcore&lt;=0:
                raise ValueError(
 f&#34;The external radius={rshell} cannot be smaller than the shell thickness={thickness}&#34;)
            # do the insertion of the shell (largest radius)
            success = self.insertone(r=rshell,beadtype=beadtype[0],overlap=False)
            if success:
                success = self.insertone(
                    x = self.lastinsertion[0],
                    y = self.lastinsertion[1],
                    r=rcore,
                    beadtype=beadtype[1],
                    overlap=True)
                nsuccess += 1
            stop = (n==ntodo) or (not success and not self.forcedinsertion)
        if nsuccess==ntodo:
            print(f&#34;{nsuccess} objects inserted successfully&#34;)
        else:
            print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
        return nsuccess</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.emulsion" href="#raster.emulsion">emulsion</a></li>
<li><a title="raster.scatter" href="#raster.scatter">scatter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="raster.coreshell.insertion"><code class="name flex">
<span>def <span class="ident">insertion</span></span>(<span>self, rlist, thickness=None, beadtype=(1, 2))</span>
</code></dt>
<dd>
<div class="desc"><p>insert a list of objects
nsuccess=insertion(&hellip;)</p>
<pre><code>List of properties
    rlist = [r1, r2,...]
    thickness = shell thcikness value
    beadtype = (shell beadtype, core beadtype)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">   def insertion(self,rlist,thickness=None, beadtype=(1,2)):
       &#34;&#34;&#34;
           insert a list of objects
               nsuccess=insertion(...)

               List of properties
                   rlist = [r1, r2,...]
                   thickness = shell thcikness value
                   beadtype = (shell beadtype, core beadtype)
       &#34;&#34;&#34;
       # check arguments
       if thickness==None:
           raise AttributeError(&#34;set a value for the shell thickness&#34;)
       if not isinstance(beadtype,tuple):
           raise TypeError(&#34;beadtype must be a turple&#34;)
       # prepare the work
       rlist.sort(reverse=True)
       ntodo = len(rlist)
       n = nsuccess = 0
       stop = False
       while not stop:
           # next insertion and check rcore
           n += 1
           rshell = rlist[n-1]
           rcore = rshell - thickness
           if rcore&lt;=0:
               raise ValueError(
f&#34;The external radius={rshell} cannot be smaller than the shell thickness={thickness}&#34;)
           # do the insertion of the shell (largest radius)
           success = self.insertone(r=rshell,beadtype=beadtype[0],overlap=False)
           if success:
               success = self.insertone(
                   x = self.lastinsertion[0],
                   y = self.lastinsertion[1],
                   r=rcore,
                   beadtype=beadtype[1],
                   overlap=True)
               nsuccess += 1
           stop = (n==ntodo) or (not success and not self.forcedinsertion)
       if nsuccess==ntodo:
           print(f&#34;{nsuccess} objects inserted successfully&#34;)
       else:
           print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
       return nsuccess</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.emulsion" href="#raster.emulsion">emulsion</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.emulsion.accepted" href="#raster.emulsion.accepted">accepted</a></code></li>
<li><code><a title="raster.emulsion.dist" href="#raster.emulsion.dist">dist</a></code></li>
<li><code><a title="raster.emulsion.insertone" href="#raster.emulsion.insertone">insertone</a></code></li>
<li><code><a title="raster.emulsion.pairdist" href="#raster.scatter.pairdist">pairdist</a></code></li>
<li><code><a title="raster.emulsion.rand" href="#raster.emulsion.rand">rand</a></code></li>
<li><code><a title="raster.emulsion.setbeadtype" href="#raster.emulsion.setbeadtype">setbeadtype</a></code></li>
<li><code><a title="raster.emulsion.walldist" href="#raster.emulsion.walldist">walldist</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.data"><code class="flex name class">
<span>class <span class="ident">data3</span></span>
<span>(</span><span>*args:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="raster.data" href="#raster.data">data</a></code> class provides tools to read, write, and manipulate LAMMPS data files,
enabling seamless integration with the <code>dump</code> class for restart generation and
simulation data management.</p>
<p>Initialize a data object.</p>
<h2 id="parameters">Parameters</h2>
<p>*args: Variable length argument list.
- No arguments: Creates an empty data object.
- One argument (filename or dump object): Initializes from a file or dump object.
- Two arguments (dump object, timestep): Initializes from a dump object at a specific timestep.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class data:
    &#34;&#34;&#34;
    The `data` class provides tools to read, write, and manipulate LAMMPS data files,
    enabling seamless integration with the `dump` class for restart generation and
    simulation data management.
    &#34;&#34;&#34;

    # Class-level keywords for headers and sections
    HKEYWORDS = [
        &#34;atoms&#34;,
        &#34;ellipsoids&#34;,
        &#34;lines&#34;,
        &#34;triangles&#34;,
        &#34;bodies&#34;,
        &#34;bonds&#34;,
        &#34;angles&#34;,
        &#34;dihedrals&#34;,
        &#34;impropers&#34;,
        &#34;atom types&#34;,
        &#34;bond types&#34;,
        &#34;angle types&#34;,
        &#34;dihedral types&#34;,
        &#34;improper types&#34;,
        &#34;xlo xhi&#34;,
        &#34;ylo yhi&#34;,
        &#34;zlo zhi&#34;,
        &#34;xy xz yz&#34;,
    ]

    SKEYWORDS = [
        [&#34;Masses&#34;, &#34;atom types&#34;],
        [&#34;Atoms&#34;, &#34;atoms&#34;],
        [&#34;Ellipsoids&#34;, &#34;ellipsoids&#34;],
        [&#34;Lines&#34;, &#34;lines&#34;],
        [&#34;Triangles&#34;, &#34;triangles&#34;],
        [&#34;Bodies&#34;, &#34;bodies&#34;],
        [&#34;Bonds&#34;, &#34;bonds&#34;],
        [&#34;Angles&#34;, &#34;angles&#34;],
        [&#34;Dihedrals&#34;, &#34;dihedrals&#34;],
        [&#34;Impropers&#34;, &#34;impropers&#34;],
        [&#34;Velocities&#34;, &#34;atoms&#34;],
        [&#34;Pair Coeffs&#34;, &#34;atom types&#34;],
        [&#34;Bond Coeffs&#34;, &#34;bond types&#34;],
        [&#34;Angle Coeffs&#34;, &#34;angle types&#34;],
        [&#34;Dihedral Coeffs&#34;, &#34;dihedral types&#34;],
        [&#34;Improper Coeffs&#34;, &#34;improper types&#34;],
        [&#34;BondBond Coeffs&#34;, &#34;angle types&#34;],
        [&#34;BondAngle Coeffs&#34;, &#34;angle types&#34;],
        [&#34;MiddleBondTorsion Coeffs&#34;, &#34;dihedral types&#34;],
        [&#34;EndBondTorsion Coeffs&#34;, &#34;dihedral types&#34;],
        [&#34;AngleTorsion Coeffs&#34;, &#34;dihedral types&#34;],
        [&#34;AngleAngleTorsion Coeffs&#34;, &#34;dihedral types&#34;],
        [&#34;BondBond13 Coeffs&#34;, &#34;dihedral types&#34;],
        [&#34;AngleAngle Coeffs&#34;, &#34;improper types&#34;],
        [&#34;Molecules&#34;, &#34;atoms&#34;],
        [&#34;Tinker Types&#34;, &#34;atoms&#34;],
    ]

    def __init__(self, *args: Any):
        &#34;&#34;&#34;
        Initialize a data object.

        Parameters:
            *args: Variable length argument list.
                - No arguments: Creates an empty data object.
                - One argument (filename or dump object): Initializes from a file or dump object.
                - Two arguments (dump object, timestep): Initializes from a dump object at a specific timestep.
        &#34;&#34;&#34;
        self.nselect = 1
        self.names: Dict[str, int] = {}
        self.headers: Dict[str, Union[int, Tuple[float, float], Tuple[float, float, float]]] = {}
        self.sections: Dict[str, List[str]] = {}
        self.flist: List[str] = []
        self.restart: bool = False

        if not args:
            # Default Constructor (empty object)
            self.title = &#34;LAMMPS data file&#34;
            logger.debug(&#34;Initialized empty data object.&#34;)
            return

        first_arg = args[0]

        if isinstance(first_arg, dump):
            # Constructor from an existing dump object
            self._init_from_dump(first_arg, *args[1:])
        elif isinstance(first_arg, str):
            # Constructor from a DATA file
            self._init_from_file(*args)
        else:
            raise TypeError(&#34;Invalid argument type for data constructor.&#34;)

    def _init_from_dump(self, dump_obj: dump, timestep: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Initialize the data object from a dump object.

        Parameters:
            dump_obj (dump): The dump object to initialize from.
            timestep (Optional[int]): The specific timestep to use. If None, the last timestep is used.
        &#34;&#34;&#34;
        times = dump_obj.time()
        num_timesteps = len(times)

        if timestep is not None:
            if timestep not in times:
                raise ValueError(&#34;The input timestep is not available in the dump object.&#34;)
            selected_time = timestep
        else:
            selected_time = times[-1]

        try:
            index = times.index(selected_time)
        except ValueError:
            raise ValueError(&#34;Selected timestep not found in dump object.&#34;)

        self.title = (f&#39;LAMMPS data file (restart from &#34;{dump_obj.flist[0]}&#34; &#39;
                      f&#39;t = {selected_time:.5g} (frame {index + 1} of {num_timesteps}))&#39;)
        logger.debug(f&#34;Set title: {self.title}&#34;)

        # Set headers
        snap = dump_obj.snaps[index]
        self.headers = {
            &#39;atoms&#39;: snap.natoms,
            &#39;atom types&#39;: dump_obj.minmax(&#34;type&#34;)[1],
            &#39;xlo xhi&#39;: (snap.xlo, snap.xhi),
            &#39;ylo yhi&#39;: (snap.ylo, snap.yhi),
            &#39;zlo zhi&#39;: (snap.zlo, snap.zhi)
        }
        logger.debug(f&#34;Set headers: {self.headers}&#34;)

        # Initialize sections
        self.sections = {}
        template_atoms = {
            &#34;smd&#34;: [&#34;id&#34;, &#34;type&#34;, &#34;mol&#34;, &#34;c_vol&#34;, &#34;mass&#34;, &#34;radius&#34;,
                    &#34;c_contact_radius&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;f_1[1]&#34;, &#34;f_1[2]&#34;, &#34;f_1[3]&#34;]
        }

        if dump_obj.kind(template_atoms[&#34;smd&#34;]):
            for col in template_atoms[&#34;smd&#34;]:
                vector = dump_obj.vecs(selected_time, col)
                is_id_type_mol = col in [&#34;id&#34;, &#34;type&#34;, &#34;mol&#34;]
                self.append(&#34;Atoms&#34;, vector, force_integer=is_id_type_mol, property_name=col)
        else:
            raise ValueError(&#34;Please add your ATOMS section in the constructor.&#34;)

        # Set velocities if required
        template_velocities = {&#34;smd&#34;: [&#34;id&#34;, &#34;vx&#34;, &#34;vy&#34;, &#34;vz&#34;]}
        if dump_obj.kind(template_atoms[&#34;smd&#34;]):
            if dump_obj.kind(template_velocities[&#34;smd&#34;]):
                for col in template_velocities[&#34;smd&#34;]:
                    vector = dump_obj.vecs(selected_time, col)
                    is_id = col == &#34;id&#34;
                    self.append(&#34;Velocities&#34;, vector, force_integer=is_id, property_name=col)
            else:
                raise ValueError(&#34;The velocities are missing for the style SMD.&#34;)

        # Store filename
        self.flist = dump_obj.flist.copy()
        self.restart = True
        logger.debug(&#34;Initialized data object from dump.&#34;)

    def _init_from_file(self, filename: str) -&gt; None:
        &#34;&#34;&#34;
        Initialize the data object from a LAMMPS data file.

        Parameters:
            filename (str): Path to the LAMMPS data file.
        &#34;&#34;&#34;
        flist = [filename]
        is_gzipped = filename.endswith(&#34;.gz&#34;)

        try:
            if is_gzipped:
                with subprocess.Popen([PIZZA_GUNZIP, &#34;-c&#34;, filename],
                                      stdout=subprocess.PIPE,
                                      text=True) as proc:
                    file_handle = proc.stdout
                    logger.debug(f&#34;Opened gzipped file: {filename}&#34;)
            else:
                file_handle = open(filename, &#39;r&#39;)
                logger.debug(f&#34;Opened file: {filename}&#34;)

            with file_handle:
                self.title = file_handle.readline().strip()
                logger.debug(f&#34;Read title: {self.title}&#34;)

                # Read headers
                while True:
                    line = file_handle.readline()
                    if not line:
                        break
                    line = line.strip()
                    if not line:
                        continue

                    found = False
                    for keyword in self.HKEYWORDS:
                        if keyword in line:
                            found = True
                            words = line.split()
                            if keyword in [&#34;xlo xhi&#34;, &#34;ylo yhi&#34;, &#34;zlo zhi&#34;]:
                                self.headers[keyword] = (float(words[0]), float(words[1]))
                            elif keyword == &#34;xy xz yz&#34;:
                                self.headers[keyword] = (float(words[0]), float(words[1]), float(words[2]))
                            else:
                                self.headers[keyword] = int(words[0])
                            logger.debug(f&#34;Set header &#39;{keyword}&#39;: {self.headers[keyword]}&#34;)
                            break
                    if not found:
                        break  # Reached the end of headers

                # Read sections
                while line:
                    found_section = False
                    for pair in self.SKEYWORDS:
                        keyword, length_key = pair
                        if keyword == line:
                            found_section = True
                            if length_key not in self.headers:
                                raise ValueError(f&#34;Data section &#39;{keyword}&#39; has no matching header value.&#34;)
                            count = self.headers[length_key]
                            file_handle.readline()  # Read the blank line after section keyword
                            section_lines = [file_handle.readline() for _ in range(count)]
                            self.sections[keyword] = section_lines
                            logger.debug(f&#34;Read section &#39;{keyword}&#39; with {count} entries.&#34;)
                            break
                    if not found_section:
                        raise ValueError(f&#34;Invalid section &#39;{line}&#39; in data file.&#34;)
                    # Read next section keyword
                    line = file_handle.readline()
                    if line:
                        line = line.strip()

            self.flist = flist
            self.restart = False
            logger.info(f&#34;Initialized data object from file &#39;{filename}&#39;.&#34;)
        except subprocess.CalledProcessError as e:
            logger.error(f&#34;Error decompressing file &#39;{filename}&#39;: {e}&#34;)
            raise
        except FileNotFoundError:
            logger.error(f&#34;File &#39;{filename}&#39; not found.&#34;)
            raise
        except Exception as e:
            logger.error(f&#34;Error reading file &#39;{filename}&#39;: {e}&#34;)
            raise

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Return a string representation of the data object.

        Returns:
            str: Description of the data object.
        &#34;&#34;&#34;
        if not self.sections or not self.headers:
            ret = f&#34;empty {self.title}&#34;
            logger.info(ret)
            return ret

        kind = &#34;restart&#34; if self.restart else &#34;source&#34;
        header_info = (f&#34;Data file: {self.flist[0]}\n&#34;
                       f&#34;\tcontains {self.headers.get(&#39;atoms&#39;, 0)} atoms from {self.headers.get(&#39;atom types&#39;, 0)} atom types\n&#34;
                       f&#34;\twith box = [{self.headers.get(&#39;xlo xhi&#39;, (0, 0))[0]} &#34;
                       f&#34;{self.headers.get(&#39;xlo xhi&#39;, (0, 0))[1]} &#34;
                       f&#34;{self.headers.get(&#39;ylo yhi&#39;, (0, 0))[0]} &#34;
                       f&#34;{self.headers.get(&#39;ylo yhi&#39;, (0, 0))[1]} &#34;
                       f&#34;{self.headers.get(&#39;zlo zhi&#39;, (0, 0))[0]} &#34;
                       f&#34;{self.headers.get(&#39;zlo zhi&#39;, (0, 0))[1]}]&#34;)

        logger.info(header_info)
        section_info = &#34;\twith the following sections:&#34;
        logger.info(section_info)
        for section_name in self.sections.keys():
            section_details = f&#34;\t\t{self.dispsection(section_name, False)}&#34;
            logger.info(section_details)

        ret = (f&#39;LAMMPS data object including {self.headers.get(&#34;atoms&#34;, 0)} atoms &#39;
               f&#39;({self.maxtype()} types, {kind}=&#34;{self.flist[0]}&#34;)&#39;)
        return ret

    def map(self, *pairs: Any) -&gt; None:
        &#34;&#34;&#34;
        Assign names to atom columns.

        Parameters:
            *pairs (Any): Pairs of column indices and names.

        Raises:
            ValueError: If an odd number of arguments is provided.
        &#34;&#34;&#34;
        if len(pairs) % 2 != 0:
            raise ValueError(&#34;data.map() requires pairs of mappings.&#34;)

        for i in range(0, len(pairs), 2):
            column_index = pairs[i] - 1
            name = pairs[i + 1]
            self.names[name] = column_index
            logger.debug(f&#34;Mapped column &#39;{name}&#39; to index {column_index + 1}.&#34;)

    def get(self, *args: Any) -&gt; Union[List[List[float]], List[float]]:
        &#34;&#34;&#34;
        Extract information from data file fields.

        Parameters:
            *args: Variable length argument list.
                - One argument: Returns all columns as a 2D list of floats.
                - Two arguments: Returns the specified column as a list of floats.

        Returns:
            Union[List[List[float]], List[float]]: Extracted data.

        Raises:
            ValueError: If invalid number of arguments is provided.
            KeyError: If the specified field is not found.
        &#34;&#34;&#34;
        if len(args) == 1:
            field = args[0]
            array = []
            lines = self.sections.get(field, [])
            for line in lines:
                words = line.split()
                values = [float(word) for word in words]
                array.append(values)
            logger.debug(f&#34;Extracted all columns from field &#39;{field}&#39;.&#34;)
            return array
        elif len(args) == 2:
            field, column = args
            column_index = column - 1
            vec = []
            lines = self.sections.get(field, [])
            for line in lines:
                words = line.split()
                vec.append(float(words[column_index]))
            logger.debug(f&#34;Extracted column {column} from field &#39;{field}&#39;.&#34;)
            return vec
        else:
            raise ValueError(&#34;Invalid arguments for data.get().&#34;)

    def reorder(self, section: str, *order: int) -&gt; None:
        &#34;&#34;&#34;
        Reorder columns in a data file section.

        Parameters:
            section (str): The name of the section to reorder.
            *order (int): The new order of column indices.

        Raises:
            ValueError: If the section name is invalid.
        &#34;&#34;&#34;
        if section not in self.sections:
            raise ValueError(f&#39;&#34;{section}&#34; is not a valid section name.&#39;)

        num_columns = len(order)
        logger.info(f&#34;&gt;&gt; Reordering {num_columns} columns in section &#39;{section}&#39;.&#34;)

        old_lines = self.sections[section]
        new_lines = []

        for line in old_lines:
            words = line.split()
            try:
                reordered = &#34; &#34;.join(words[i - 1] for i in order) + &#34;\n&#34;
            except IndexError:
                raise ValueError(&#34;Column index out of range during reorder.&#34;)
            new_lines.append(reordered)

        self.sections[section] = new_lines
        logger.debug(f&#34;Reordered columns in section &#39;{section}&#39;.&#34;)

    def replace(self, section: str, column: int, vector: Union[List[float], float]) -&gt; None:
        &#34;&#34;&#34;
        Replace a column in a named section with a vector of values.

        Parameters:
            section (str): The name of the section.
            column (int): The column index to replace (1-based).
            vector (Union[List[float], float]): The new values or a single scalar value.

        Raises:
            ValueError: If the section is invalid or vector length mismatch.
        &#34;&#34;&#34;
        if section not in self.sections:
            raise ValueError(f&#39;&#34;{section}&#34; is not a valid section name.&#39;)

        lines = self.sections[section]
        num_lines = len(lines)

        if not isinstance(vector, list):
            vector = [vector]
        if len(vector) == 1:
            vector = vector * num_lines
        if len(vector) != num_lines:
            raise ValueError(f&#39;The length of new data ({len(vector)}) in section &#34;{section}&#34; does not match the number of rows {num_lines}.&#39;)

        new_lines = []
        column_index = column - 1
        for i, line in enumerate(lines):
            words = line.split()
            if column_index &gt;= len(words):
                raise ValueError(f&#34;Column index {column} out of range for section &#39;{section}&#39;.&#34;)
            words[column_index] = str(vector[i])
            new_line = &#34; &#34;.join(words) + &#34;\n&#34;
            new_lines.append(new_line)

        self.sections[section] = new_lines
        logger.debug(f&#34;Replaced column {column} in section &#39;{section}&#39; with new data.&#34;)

    def append(self, section: str, vector: Union[List[float], np.ndarray, float],
               force_integer: bool = False, property_name: Optional[str] = None) -&gt; None:
        &#34;&#34;&#34;
        Append a new column to a named section.

        Parameters:
            section (str): The name of the section.
            vector (Union[List[float], np.ndarray, float]): The values to append.
            force_integer (bool): If True, values are converted to integers.
            property_name (Optional[str]): The name of the property being appended.

        Raises:
            ValueError: If vector length mismatch occurs.
        &#34;&#34;&#34;
        if section not in self.sections:
            self.sections[section] = []
            logger.info(f&#39;Added new section [{section}] - file=&#34;{self.title}&#34;.&#39;)

        lines = self.sections[section]
        num_lines = len(lines)

        if not isinstance(vector, (list, np.ndarray)):
            vector = [vector]
        if property_name:
            logger.info(f&#39;\t&gt; Adding property &#34;{property_name}&#34; with {len(vector)} values to [{section}].&#39;)
        else:
            logger.info(f&#39;\t&gt; Adding {len(vector)} values to [{section}] (no name).&#39;)

        new_lines = []

        if num_lines == 0:
            # Empty section, create initial lines
            num_entries = len(vector)
            for i in range(num_entries):
                value = int(vector[i]) if force_integer else vector[i]
                new_line = f&#34;{int(value) if force_integer else value}\n&#34;
                new_lines.append(new_line)
            logger.debug(f&#34;Initialized empty section &#39;{section}&#39; with new column.&#34;)
        else:
            if len(vector) == 1:
                vector = vector * num_lines
            if len(vector) != num_lines:
                raise ValueError(f&#39;The length of new data ({len(vector)}) in section &#34;{section}&#34; does not match the number of rows {num_lines}.&#39;)

            for i, line in enumerate(lines):
                value = int(vector[i]) if force_integer else vector[i]
                new_word = str(value)
                new_line = line.rstrip(&#39;\n&#39;) + f&#34; {new_word}\n&#34;
                new_lines.append(new_line)

        self.sections[section] = new_lines
        logger.debug(f&#34;Appended new column to section &#39;{section}&#39;.&#34;)

    def dispsection(self, section: str, include_header: bool = True) -&gt; str:
        &#34;&#34;&#34;
        Display information about a section.

        Parameters:
            section (str): The name of the section.
            include_header (bool): Whether to include &#34;LAMMPS data section&#34; in the output.

        Returns:
            str: Description of the section.
        &#34;&#34;&#34;
        if section not in self.sections:
            raise ValueError(f&#34;Section &#39;{section}&#39; not found in data object.&#34;)

        lines = self.sections[section]
        num_lines = len(lines)
        num_columns = len(lines[0].split()) if lines else 0
        ret = f&#39;&#34;{section}&#34;: {num_lines} x {num_columns} values&#39;

        if include_header:
            ret = f&#34;LAMMPS data section {ret}&#34;
        return ret

    def newxyz(self, dm: dump, ntime: int) -&gt; None:
        &#34;&#34;&#34;
        Replace x, y, z coordinates in the Atoms section with those from a dump object.

        Parameters:
            dm (dump): The dump object containing new coordinates.
            ntime (int): The timestep to extract coordinates from.

        Raises:
            ValueError: If required columns are not defined.
        &#34;&#34;&#34;
        nsnap = dm.findtime(ntime)
        logger.info(f&#34;&gt;&gt; Replacing XYZ for {nsnap} snapshots.&#34;)

        dm.sort(ntime)
        x, y, z = dm.vecs(ntime, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;)

        self.replace(&#34;Atoms&#34;, self.names.get(&#34;x&#34;, 0) + 1, x)
        self.replace(&#34;Atoms&#34;, self.names.get(&#34;y&#34;, 0) + 1, y)
        self.replace(&#34;Atoms&#34;, self.names.get(&#34;z&#34;, 0) + 1, z)

        if &#34;ix&#34; in dm.names and &#34;ix&#34; in self.names:
            ix, iy, iz = dm.vecs(ntime, &#34;ix&#34;, &#34;iy&#34;, &#34;iz&#34;)
            self.replace(&#34;Atoms&#34;, self.names.get(&#34;ix&#34;, 0) + 1, ix)
            self.replace(&#34;Atoms&#34;, self.names.get(&#34;iy&#34;, 0) + 1, iy)
            self.replace(&#34;Atoms&#34;, self.names.get(&#34;iz&#34;, 0) + 1, iz)

        logger.debug(f&#34;Replaced XYZ coordinates at timestep {ntime}.&#34;)

    def delete(self, keyword: str) -&gt; None:
        &#34;&#34;&#34;
        Delete a header value or section from the data object.

        Parameters:
            keyword (str): The header or section name to delete.

        Raises:
            ValueError: If the keyword is not found.
        &#34;&#34;&#34;
        if keyword in self.headers:
            del self.headers[keyword]
            logger.debug(f&#34;Deleted header &#39;{keyword}&#39;.&#34;)
        elif keyword in self.sections:
            del self.sections[keyword]
            logger.debug(f&#34;Deleted section &#39;{keyword}&#39;.&#34;)
        else:
            raise ValueError(&#34;Keyword not found in data object.&#34;)

    def write(self, filename: str) -&gt; None:
        &#34;&#34;&#34;
        Write the data object to a LAMMPS data file.

        Parameters:
            filename (str): The output file path.
        &#34;&#34;&#34;
        try:
            with open(filename, &#34;w&#34;) as f:
                f.write(f&#34;{self.title}\n&#34;)
                logger.debug(f&#34;Wrote title to file &#39;{filename}&#39;.&#34;)

                # Write headers
                for keyword in self.HKEYWORDS:
                    if keyword in self.headers:
                        value = self.headers[keyword]
                        if keyword in [&#34;xlo xhi&#34;, &#34;ylo yhi&#34;, &#34;zlo zhi&#34;]:
                            f.write(f&#34;{value[0]} {value[1]} {keyword}\n&#34;)
                        elif keyword == &#34;xy xz yz&#34;:
                            f.write(f&#34;{value[0]} {value[1]} {value[2]} {keyword}\n&#34;)
                        else:
                            f.write(f&#34;{value} {keyword}\n&#34;)
                        logger.debug(f&#34;Wrote header &#39;{keyword}&#39; to file.&#34;)

                # Write sections
                for pair in self.SKEYWORDS:
                    keyword = pair[0]
                    if keyword in self.sections:
                        f.write(f&#34;\n{keyword}\n\n&#34;)
                        for line in self.sections[keyword]:
                            f.write(line)
                        logger.debug(f&#34;Wrote section &#39;{keyword}&#39; to file.&#34;)

            logger.info(f&#34;Data object written to &#39;{filename}&#39;.&#34;)
        except IOError as e:
            logger.error(f&#34;Error writing to file &#39;{filename}&#39;: {e}&#34;)
            raise

    def iterator(self, flag: int) -&gt; Tuple[int, int, int]:
        &#34;&#34;&#34;
        Iterator method compatible with other tools.

        Parameters:
            flag (int): 0 for the first call, 1 for subsequent calls.

        Returns:
            Tuple[int, int, int]: (index, time, flag)
        &#34;&#34;&#34;
        if flag == 0:
            return 0, 0, 1
        return 0, 0, -1

    def findtime(self, n: int) -&gt; int:
        &#34;&#34;&#34;
        Find the index of a given timestep.

        Parameters:
            n (int): The timestep to find.

        Returns:
            int: The index of the timestep.

        Raises:
            ValueError: If the timestep does not exist.
        &#34;&#34;&#34;
        if n == 0:
            return 0
        raise ValueError(f&#34;No step {n} exists.&#34;)

    def viz(self, isnap: int) -&gt; Tuple[int, List[float], List[List[Union[int, float]]],
                                      List[List[Union[int, float]]], List[Any], List[Any]]:
        &#34;&#34;&#34;
        Return visualization data for a specified snapshot.

        Parameters:
            isnap (int): Snapshot index (must be 0 for data object).

        Returns:
            Tuple containing time, box dimensions, atoms, bonds, tris, and lines.

        Raises:
            ValueError: If isnap is not 0.
        &#34;&#34;&#34;
        if isnap:
            raise ValueError(&#34;Cannot call data.viz() with isnap != 0.&#34;)

        id_idx = self.names.get(&#34;id&#34;)
        type_idx = self.names.get(&#34;type&#34;)
        x_idx = self.names.get(&#34;x&#34;)
        y_idx = self.names.get(&#34;y&#34;)
        z_idx = self.names.get(&#34;z&#34;)

        if None in [id_idx, type_idx, x_idx, y_idx, z_idx]:
            raise ValueError(&#34;One or more required columns (id, type, x, y, z) are not defined.&#34;)

        xlohi = self.headers.get(&#34;xlo xhi&#34;, (0.0, 0.0))
        ylohi = self.headers.get(&#34;ylo yhi&#34;, (0.0, 0.0))
        zlohi = self.headers.get(&#34;zlo zhi&#34;, (0.0, 0.0))
        box = [xlohi[0], ylohi[0], zlohi[0], xlohi[1], ylohi[1], zlohi[1]]

        # Create atom list needed by viz from id, type, x, y, z
        atoms = []
        atom_lines = self.sections.get(&#34;Atoms&#34;, [])
        for line in atom_lines:
            words = line.split()
            atoms.append([
                int(words[id_idx]),
                int(words[type_idx]),
                float(words[x_idx]),
                float(words[y_idx]),
                float(words[z_idx]),
            ])

        # Create list of current bond coords from list of bonds
        bonds = []
        if &#34;Bonds&#34; in self.sections:
            bond_lines = self.sections[&#34;Bonds&#34;]
            for line in bond_lines:
                words = line.split()
                bid = int(words[0])
                btype = int(words[1])
                atom1 = int(words[2])
                atom2 = int(words[3])
                if atom1 - 1 &gt;= len(atom_lines) or atom2 - 1 &gt;= len(atom_lines):
                    raise ValueError(&#34;Atom index in Bonds section out of range.&#34;)
                atom1_words = self.sections[&#34;Atoms&#34;][atom1 - 1].split()
                atom2_words = self.sections[&#34;Atoms&#34;][atom2 - 1].split()
                bonds.append([
                    bid,
                    btype,
                    float(atom1_words[x_idx]),
                    float(atom1_words[y_idx]),
                    float(atom1_words[z_idx]),
                    float(atom2_words[x_idx]),
                    float(atom2_words[y_idx]),
                    float(atom2_words[z_idx]),
                    int(atom1_words[type_idx]),
                    int(atom2_words[type_idx]),
                ])

        tris = []
        lines = []
        logger.debug(&#34;Prepared visualization data.&#34;)
        return 0, box, atoms, bonds, tris, lines

    def maxbox(self) -&gt; List[float]:
        &#34;&#34;&#34;
        Return the box dimensions.

        Returns:
            List[float]: [xlo, ylo, zlo, xhi, yhi, zhi]
        &#34;&#34;&#34;
        xlohi = self.headers.get(&#34;xlo xhi&#34;, (0.0, 0.0))
        ylohi = self.headers.get(&#34;ylo yhi&#34;, (0.0, 0.0))
        zlohi = self.headers.get(&#34;zlo zhi&#34;, (0.0, 0.0))
        box = [xlohi[0], ylohi[0], zlohi[0], xlohi[1], ylohi[1], zlohi[1]]
        logger.debug(f&#34;Box dimensions: {box}&#34;)
        return box

    def maxtype(self) -&gt; int:
        &#34;&#34;&#34;
        Return the number of atom types.

        Returns:
            int: Number of atom types.
        &#34;&#34;&#34;
        maxtype = self.headers.get(&#34;atom types&#34;, 0)
        logger.debug(f&#34;Number of atom types: {maxtype}&#34;)
        return maxtype</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="raster.data.HKEYWORDS"><code class="name">var <span class="ident">HKEYWORDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="raster.data.SKEYWORDS"><code class="name">var <span class="ident">SKEYWORDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.data.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, section:Â str, vector:Â Union[List[float],Â numpy.ndarray,Â float], force_integer:Â boolÂ =Â False, property_name:Â Optional[str]Â =Â None) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Append a new column to a named section.</p>
<h2 id="parameters">Parameters</h2>
<p>section (str): The name of the section.
vector (Union[List[float], np.ndarray, float]): The values to append.
force_integer (bool): If True, values are converted to integers.
property_name (Optional[str]): The name of the property being appended.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If vector length mismatch occurs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, section: str, vector: Union[List[float], np.ndarray, float],
           force_integer: bool = False, property_name: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;
    Append a new column to a named section.

    Parameters:
        section (str): The name of the section.
        vector (Union[List[float], np.ndarray, float]): The values to append.
        force_integer (bool): If True, values are converted to integers.
        property_name (Optional[str]): The name of the property being appended.

    Raises:
        ValueError: If vector length mismatch occurs.
    &#34;&#34;&#34;
    if section not in self.sections:
        self.sections[section] = []
        logger.info(f&#39;Added new section [{section}] - file=&#34;{self.title}&#34;.&#39;)

    lines = self.sections[section]
    num_lines = len(lines)

    if not isinstance(vector, (list, np.ndarray)):
        vector = [vector]
    if property_name:
        logger.info(f&#39;\t&gt; Adding property &#34;{property_name}&#34; with {len(vector)} values to [{section}].&#39;)
    else:
        logger.info(f&#39;\t&gt; Adding {len(vector)} values to [{section}] (no name).&#39;)

    new_lines = []

    if num_lines == 0:
        # Empty section, create initial lines
        num_entries = len(vector)
        for i in range(num_entries):
            value = int(vector[i]) if force_integer else vector[i]
            new_line = f&#34;{int(value) if force_integer else value}\n&#34;
            new_lines.append(new_line)
        logger.debug(f&#34;Initialized empty section &#39;{section}&#39; with new column.&#34;)
    else:
        if len(vector) == 1:
            vector = vector * num_lines
        if len(vector) != num_lines:
            raise ValueError(f&#39;The length of new data ({len(vector)}) in section &#34;{section}&#34; does not match the number of rows {num_lines}.&#39;)

        for i, line in enumerate(lines):
            value = int(vector[i]) if force_integer else vector[i]
            new_word = str(value)
            new_line = line.rstrip(&#39;\n&#39;) + f&#34; {new_word}\n&#34;
            new_lines.append(new_line)

    self.sections[section] = new_lines
    logger.debug(f&#34;Appended new column to section &#39;{section}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="raster.data.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, keyword:Â str) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a header value or section from the data object.</p>
<h2 id="parameters">Parameters</h2>
<p>keyword (str): The header or section name to delete.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the keyword is not found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, keyword: str) -&gt; None:
    &#34;&#34;&#34;
    Delete a header value or section from the data object.

    Parameters:
        keyword (str): The header or section name to delete.

    Raises:
        ValueError: If the keyword is not found.
    &#34;&#34;&#34;
    if keyword in self.headers:
        del self.headers[keyword]
        logger.debug(f&#34;Deleted header &#39;{keyword}&#39;.&#34;)
    elif keyword in self.sections:
        del self.sections[keyword]
        logger.debug(f&#34;Deleted section &#39;{keyword}&#39;.&#34;)
    else:
        raise ValueError(&#34;Keyword not found in data object.&#34;)</code></pre>
</details>
</dd>
<dt id="raster.data.dispsection"><code class="name flex">
<span>def <span class="ident">dispsection</span></span>(<span>self, section:Â str, include_header:Â boolÂ =Â True) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Display information about a section.</p>
<h2 id="parameters">Parameters</h2>
<p>section (str): The name of the section.
include_header (bool): Whether to include "LAMMPS data section" in the output.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Description of the section.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispsection(self, section: str, include_header: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Display information about a section.

    Parameters:
        section (str): The name of the section.
        include_header (bool): Whether to include &#34;LAMMPS data section&#34; in the output.

    Returns:
        str: Description of the section.
    &#34;&#34;&#34;
    if section not in self.sections:
        raise ValueError(f&#34;Section &#39;{section}&#39; not found in data object.&#34;)

    lines = self.sections[section]
    num_lines = len(lines)
    num_columns = len(lines[0].split()) if lines else 0
    ret = f&#39;&#34;{section}&#34;: {num_lines} x {num_columns} values&#39;

    if include_header:
        ret = f&#34;LAMMPS data section {ret}&#34;
    return ret</code></pre>
</details>
</dd>
<dt id="raster.data.findtime"><code class="name flex">
<span>def <span class="ident">findtime</span></span>(<span>self, n:Â int) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Find the index of a given timestep.</p>
<h2 id="parameters">Parameters</h2>
<p>n (int): The timestep to find.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The index of the timestep.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the timestep does not exist.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findtime(self, n: int) -&gt; int:
    &#34;&#34;&#34;
    Find the index of a given timestep.

    Parameters:
        n (int): The timestep to find.

    Returns:
        int: The index of the timestep.

    Raises:
        ValueError: If the timestep does not exist.
    &#34;&#34;&#34;
    if n == 0:
        return 0
    raise ValueError(f&#34;No step {n} exists.&#34;)</code></pre>
</details>
</dd>
<dt id="raster.data.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, *args:Â Any) â€‘>Â Union[List[List[float]],Â List[float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract information from data file fields.</p>
<h2 id="parameters">Parameters</h2>
<p>*args: Variable length argument list.
- One argument: Returns all columns as a 2D list of floats.
- Two arguments: Returns the specified column as a list of floats.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[List[List[float]], List[float]]</code></dt>
<dd>Extracted data.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If invalid number of arguments is provided.</dd>
<dt><code>KeyError</code></dt>
<dd>If the specified field is not found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, *args: Any) -&gt; Union[List[List[float]], List[float]]:
    &#34;&#34;&#34;
    Extract information from data file fields.

    Parameters:
        *args: Variable length argument list.
            - One argument: Returns all columns as a 2D list of floats.
            - Two arguments: Returns the specified column as a list of floats.

    Returns:
        Union[List[List[float]], List[float]]: Extracted data.

    Raises:
        ValueError: If invalid number of arguments is provided.
        KeyError: If the specified field is not found.
    &#34;&#34;&#34;
    if len(args) == 1:
        field = args[0]
        array = []
        lines = self.sections.get(field, [])
        for line in lines:
            words = line.split()
            values = [float(word) for word in words]
            array.append(values)
        logger.debug(f&#34;Extracted all columns from field &#39;{field}&#39;.&#34;)
        return array
    elif len(args) == 2:
        field, column = args
        column_index = column - 1
        vec = []
        lines = self.sections.get(field, [])
        for line in lines:
            words = line.split()
            vec.append(float(words[column_index]))
        logger.debug(f&#34;Extracted column {column} from field &#39;{field}&#39;.&#34;)
        return vec
    else:
        raise ValueError(&#34;Invalid arguments for data.get().&#34;)</code></pre>
</details>
</dd>
<dt id="raster.data.iterator"><code class="name flex">
<span>def <span class="ident">iterator</span></span>(<span>self, flag:Â int) â€‘>Â Tuple[int,Â int,Â int]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterator method compatible with other tools.</p>
<h2 id="parameters">Parameters</h2>
<p>flag (int): 0 for the first call, 1 for subsequent calls.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[int, int, int]</code></dt>
<dd>(index, time, flag)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterator(self, flag: int) -&gt; Tuple[int, int, int]:
    &#34;&#34;&#34;
    Iterator method compatible with other tools.

    Parameters:
        flag (int): 0 for the first call, 1 for subsequent calls.

    Returns:
        Tuple[int, int, int]: (index, time, flag)
    &#34;&#34;&#34;
    if flag == 0:
        return 0, 0, 1
    return 0, 0, -1</code></pre>
</details>
</dd>
<dt id="raster.data.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, *pairs:Â Any) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Assign names to atom columns.</p>
<h2 id="parameters">Parameters</h2>
<p>*pairs (Any): Pairs of column indices and names.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If an odd number of arguments is provided.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, *pairs: Any) -&gt; None:
    &#34;&#34;&#34;
    Assign names to atom columns.

    Parameters:
        *pairs (Any): Pairs of column indices and names.

    Raises:
        ValueError: If an odd number of arguments is provided.
    &#34;&#34;&#34;
    if len(pairs) % 2 != 0:
        raise ValueError(&#34;data.map() requires pairs of mappings.&#34;)

    for i in range(0, len(pairs), 2):
        column_index = pairs[i] - 1
        name = pairs[i + 1]
        self.names[name] = column_index
        logger.debug(f&#34;Mapped column &#39;{name}&#39; to index {column_index + 1}.&#34;)</code></pre>
</details>
</dd>
<dt id="raster.data.maxbox"><code class="name flex">
<span>def <span class="ident">maxbox</span></span>(<span>self) â€‘>Â List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the box dimensions.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[float]</code></dt>
<dd>[xlo, ylo, zlo, xhi, yhi, zhi]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxbox(self) -&gt; List[float]:
    &#34;&#34;&#34;
    Return the box dimensions.

    Returns:
        List[float]: [xlo, ylo, zlo, xhi, yhi, zhi]
    &#34;&#34;&#34;
    xlohi = self.headers.get(&#34;xlo xhi&#34;, (0.0, 0.0))
    ylohi = self.headers.get(&#34;ylo yhi&#34;, (0.0, 0.0))
    zlohi = self.headers.get(&#34;zlo zhi&#34;, (0.0, 0.0))
    box = [xlohi[0], ylohi[0], zlohi[0], xlohi[1], ylohi[1], zlohi[1]]
    logger.debug(f&#34;Box dimensions: {box}&#34;)
    return box</code></pre>
</details>
</dd>
<dt id="raster.data.maxtype"><code class="name flex">
<span>def <span class="ident">maxtype</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of atom types.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of atom types.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxtype(self) -&gt; int:
    &#34;&#34;&#34;
    Return the number of atom types.

    Returns:
        int: Number of atom types.
    &#34;&#34;&#34;
    maxtype = self.headers.get(&#34;atom types&#34;, 0)
    logger.debug(f&#34;Number of atom types: {maxtype}&#34;)
    return maxtype</code></pre>
</details>
</dd>
<dt id="raster.data.newxyz"><code class="name flex">
<span>def <span class="ident">newxyz</span></span>(<span>self, dm:Â pizza.dump3.dump, ntime:Â int) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Replace x, y, z coordinates in the Atoms section with those from a dump object.</p>
<h2 id="parameters">Parameters</h2>
<p>dm (dump): The dump object containing new coordinates.
ntime (int): The timestep to extract coordinates from.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If required columns are not defined.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newxyz(self, dm: dump, ntime: int) -&gt; None:
    &#34;&#34;&#34;
    Replace x, y, z coordinates in the Atoms section with those from a dump object.

    Parameters:
        dm (dump): The dump object containing new coordinates.
        ntime (int): The timestep to extract coordinates from.

    Raises:
        ValueError: If required columns are not defined.
    &#34;&#34;&#34;
    nsnap = dm.findtime(ntime)
    logger.info(f&#34;&gt;&gt; Replacing XYZ for {nsnap} snapshots.&#34;)

    dm.sort(ntime)
    x, y, z = dm.vecs(ntime, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;)

    self.replace(&#34;Atoms&#34;, self.names.get(&#34;x&#34;, 0) + 1, x)
    self.replace(&#34;Atoms&#34;, self.names.get(&#34;y&#34;, 0) + 1, y)
    self.replace(&#34;Atoms&#34;, self.names.get(&#34;z&#34;, 0) + 1, z)

    if &#34;ix&#34; in dm.names and &#34;ix&#34; in self.names:
        ix, iy, iz = dm.vecs(ntime, &#34;ix&#34;, &#34;iy&#34;, &#34;iz&#34;)
        self.replace(&#34;Atoms&#34;, self.names.get(&#34;ix&#34;, 0) + 1, ix)
        self.replace(&#34;Atoms&#34;, self.names.get(&#34;iy&#34;, 0) + 1, iy)
        self.replace(&#34;Atoms&#34;, self.names.get(&#34;iz&#34;, 0) + 1, iz)

    logger.debug(f&#34;Replaced XYZ coordinates at timestep {ntime}.&#34;)</code></pre>
</details>
</dd>
<dt id="raster.data.reorder"><code class="name flex">
<span>def <span class="ident">reorder</span></span>(<span>self, section:Â str, *order:Â int) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Reorder columns in a data file section.</p>
<h2 id="parameters">Parameters</h2>
<p>section (str): The name of the section to reorder.
*order (int): The new order of column indices.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the section name is invalid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reorder(self, section: str, *order: int) -&gt; None:
    &#34;&#34;&#34;
    Reorder columns in a data file section.

    Parameters:
        section (str): The name of the section to reorder.
        *order (int): The new order of column indices.

    Raises:
        ValueError: If the section name is invalid.
    &#34;&#34;&#34;
    if section not in self.sections:
        raise ValueError(f&#39;&#34;{section}&#34; is not a valid section name.&#39;)

    num_columns = len(order)
    logger.info(f&#34;&gt;&gt; Reordering {num_columns} columns in section &#39;{section}&#39;.&#34;)

    old_lines = self.sections[section]
    new_lines = []

    for line in old_lines:
        words = line.split()
        try:
            reordered = &#34; &#34;.join(words[i - 1] for i in order) + &#34;\n&#34;
        except IndexError:
            raise ValueError(&#34;Column index out of range during reorder.&#34;)
        new_lines.append(reordered)

    self.sections[section] = new_lines
    logger.debug(f&#34;Reordered columns in section &#39;{section}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="raster.data.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, section:Â str, column:Â int, vector:Â Union[List[float],Â float]) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Replace a column in a named section with a vector of values.</p>
<h2 id="parameters">Parameters</h2>
<p>section (str): The name of the section.
column (int): The column index to replace (1-based).
vector (Union[List[float], float]): The new values or a single scalar value.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the section is invalid or vector length mismatch.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, section: str, column: int, vector: Union[List[float], float]) -&gt; None:
    &#34;&#34;&#34;
    Replace a column in a named section with a vector of values.

    Parameters:
        section (str): The name of the section.
        column (int): The column index to replace (1-based).
        vector (Union[List[float], float]): The new values or a single scalar value.

    Raises:
        ValueError: If the section is invalid or vector length mismatch.
    &#34;&#34;&#34;
    if section not in self.sections:
        raise ValueError(f&#39;&#34;{section}&#34; is not a valid section name.&#39;)

    lines = self.sections[section]
    num_lines = len(lines)

    if not isinstance(vector, list):
        vector = [vector]
    if len(vector) == 1:
        vector = vector * num_lines
    if len(vector) != num_lines:
        raise ValueError(f&#39;The length of new data ({len(vector)}) in section &#34;{section}&#34; does not match the number of rows {num_lines}.&#39;)

    new_lines = []
    column_index = column - 1
    for i, line in enumerate(lines):
        words = line.split()
        if column_index &gt;= len(words):
            raise ValueError(f&#34;Column index {column} out of range for section &#39;{section}&#39;.&#34;)
        words[column_index] = str(vector[i])
        new_line = &#34; &#34;.join(words) + &#34;\n&#34;
        new_lines.append(new_line)

    self.sections[section] = new_lines
    logger.debug(f&#34;Replaced column {column} in section &#39;{section}&#39; with new data.&#34;)</code></pre>
</details>
</dd>
<dt id="raster.data.viz"><code class="name flex">
<span>def <span class="ident">viz</span></span>(<span>self, isnap:Â int) â€‘>Â Tuple[int,Â List[float],Â List[List[Union[int,Â float]]],Â List[List[Union[int,Â float]]],Â List[Any],Â List[Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Return visualization data for a specified snapshot.</p>
<h2 id="parameters">Parameters</h2>
<p>isnap (int): Snapshot index (must be 0 for data object).</p>
<h2 id="returns">Returns</h2>
<p>Tuple containing time, box dimensions, atoms, bonds, tris, and lines.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If isnap is not 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz(self, isnap: int) -&gt; Tuple[int, List[float], List[List[Union[int, float]]],
                                  List[List[Union[int, float]]], List[Any], List[Any]]:
    &#34;&#34;&#34;
    Return visualization data for a specified snapshot.

    Parameters:
        isnap (int): Snapshot index (must be 0 for data object).

    Returns:
        Tuple containing time, box dimensions, atoms, bonds, tris, and lines.

    Raises:
        ValueError: If isnap is not 0.
    &#34;&#34;&#34;
    if isnap:
        raise ValueError(&#34;Cannot call data.viz() with isnap != 0.&#34;)

    id_idx = self.names.get(&#34;id&#34;)
    type_idx = self.names.get(&#34;type&#34;)
    x_idx = self.names.get(&#34;x&#34;)
    y_idx = self.names.get(&#34;y&#34;)
    z_idx = self.names.get(&#34;z&#34;)

    if None in [id_idx, type_idx, x_idx, y_idx, z_idx]:
        raise ValueError(&#34;One or more required columns (id, type, x, y, z) are not defined.&#34;)

    xlohi = self.headers.get(&#34;xlo xhi&#34;, (0.0, 0.0))
    ylohi = self.headers.get(&#34;ylo yhi&#34;, (0.0, 0.0))
    zlohi = self.headers.get(&#34;zlo zhi&#34;, (0.0, 0.0))
    box = [xlohi[0], ylohi[0], zlohi[0], xlohi[1], ylohi[1], zlohi[1]]

    # Create atom list needed by viz from id, type, x, y, z
    atoms = []
    atom_lines = self.sections.get(&#34;Atoms&#34;, [])
    for line in atom_lines:
        words = line.split()
        atoms.append([
            int(words[id_idx]),
            int(words[type_idx]),
            float(words[x_idx]),
            float(words[y_idx]),
            float(words[z_idx]),
        ])

    # Create list of current bond coords from list of bonds
    bonds = []
    if &#34;Bonds&#34; in self.sections:
        bond_lines = self.sections[&#34;Bonds&#34;]
        for line in bond_lines:
            words = line.split()
            bid = int(words[0])
            btype = int(words[1])
            atom1 = int(words[2])
            atom2 = int(words[3])
            if atom1 - 1 &gt;= len(atom_lines) or atom2 - 1 &gt;= len(atom_lines):
                raise ValueError(&#34;Atom index in Bonds section out of range.&#34;)
            atom1_words = self.sections[&#34;Atoms&#34;][atom1 - 1].split()
            atom2_words = self.sections[&#34;Atoms&#34;][atom2 - 1].split()
            bonds.append([
                bid,
                btype,
                float(atom1_words[x_idx]),
                float(atom1_words[y_idx]),
                float(atom1_words[z_idx]),
                float(atom2_words[x_idx]),
                float(atom2_words[y_idx]),
                float(atom2_words[z_idx]),
                int(atom1_words[type_idx]),
                int(atom2_words[type_idx]),
            ])

    tris = []
    lines = []
    logger.debug(&#34;Prepared visualization data.&#34;)
    return 0, box, atoms, bonds, tris, lines</code></pre>
</details>
</dd>
<dt id="raster.data.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, filename:Â str) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Write the data object to a LAMMPS data file.</p>
<h2 id="parameters">Parameters</h2>
<p>filename (str): The output file path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, filename: str) -&gt; None:
    &#34;&#34;&#34;
    Write the data object to a LAMMPS data file.

    Parameters:
        filename (str): The output file path.
    &#34;&#34;&#34;
    try:
        with open(filename, &#34;w&#34;) as f:
            f.write(f&#34;{self.title}\n&#34;)
            logger.debug(f&#34;Wrote title to file &#39;{filename}&#39;.&#34;)

            # Write headers
            for keyword in self.HKEYWORDS:
                if keyword in self.headers:
                    value = self.headers[keyword]
                    if keyword in [&#34;xlo xhi&#34;, &#34;ylo yhi&#34;, &#34;zlo zhi&#34;]:
                        f.write(f&#34;{value[0]} {value[1]} {keyword}\n&#34;)
                    elif keyword == &#34;xy xz yz&#34;:
                        f.write(f&#34;{value[0]} {value[1]} {value[2]} {keyword}\n&#34;)
                    else:
                        f.write(f&#34;{value} {keyword}\n&#34;)
                    logger.debug(f&#34;Wrote header &#39;{keyword}&#39; to file.&#34;)

            # Write sections
            for pair in self.SKEYWORDS:
                keyword = pair[0]
                if keyword in self.sections:
                    f.write(f&#34;\n{keyword}\n\n&#34;)
                    for line in self.sections[keyword]:
                        f.write(line)
                    logger.debug(f&#34;Wrote section &#39;{keyword}&#39; to file.&#34;)

        logger.info(f&#34;Data object written to &#39;{filename}&#39;.&#34;)
    except IOError as e:
        logger.error(f&#34;Error writing to file &#39;{filename}&#39;: {e}&#34;)
        raise</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="raster.emulsion"><code class="flex name class">
<span>class <span class="ident">emulsion</span></span>
<span>(</span><span>xmin=10, ymin=10, xmax=90, ymax=90, maxtrials=1000, beadtype=1, forcedinsertion=True)</span>
</code></dt>
<dd>
<div class="desc"><p>emulsion generator </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>The insertions are performed between xmin,ymin and xmax,ymax</dt>
<dt><strong><code>xmin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>x left corner. The default is 10.</dd>
<dt><strong><code>ymin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>y bottom corner. The default is 10.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>x right corner. The default is 90.</dd>
<dt><strong><code>ymax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>y top corner. The default is 90.</dd>
<dt><strong><code>beadtype</code></strong> :&ensp;<code>default beadtype to apply if not precised at insertion</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>maxtrials</code></strong> :&ensp;<code>integer</code>, optional</dt>
<dd>Maximum of attempts for an object. The default is 1000.</dd>
<dt><strong><code>forcedinsertion</code></strong> :&ensp;<code>logical</code>, optional</dt>
<dd>Set it to true to force the next insertion. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class emulsion(scatter):
    &#34;&#34;&#34; emulsion generator &#34;&#34;&#34;

    def __init__(self, xmin=10, ymin=10, xmax=90, ymax=90,
                 maxtrials=1000, beadtype=1, forcedinsertion=True):
        &#34;&#34;&#34;


        Parameters
        ----------
        The insertions are performed between xmin,ymin and xmax,ymax
        xmin : int64 or real, optional
            x left corner. The default is 10.
        ymin : int64 or real, optional
            y bottom corner. The default is 10.
        xmax : int64 or real, optional
            x right corner. The default is 90.
        ymax : int64 or real, optional
            y top corner. The default is 90.
        beadtype : default beadtype to apply if not precised at insertion
        maxtrials : integer, optional
            Maximum of attempts for an object. The default is 1000.
        forcedinsertion : logical, optional
            Set it to true to force the next insertion. The default is True.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        super().__init__()
        self.xmin, self.xmax, self.ymin, self.ymax = xmin, xmax, ymin, ymax
        self.lastinsertion = (None,None,None,None) # x,y,r, beadtype
        self.width = xmax-xmin
        self.height = ymax-ymin
        self.defautbeadtype = beadtype
        self.maxtrials = maxtrials
        self.forcedinsertion = forcedinsertion

    def __repr__(self):
        print(f&#34; Emulsion object\n\t{self.width}x{self.height} starting at x={self.xmin}, y={self.ymin}&#34;)
        print(f&#34;\tcontains {self.n} insertions&#34;)
        print(&#34;\tmaximum insertion trials:&#34;, self.maxtrials)
        print(&#34;\tforce next insertion if previous fails:&#34;, self.forcedinsertion)
        return f&#34;emulsion with {self.n} insertions&#34;


    def walldist(self,x,y):
        &#34;&#34;&#34; shortest distance to the wall &#34;&#34;&#34;
        return min(abs(x-self.xmin),abs(y-self.ymin),abs(x-self.xmax),abs(y-self.ymax))

    def dist(self,x,y):
        &#34;&#34;&#34; shortest distance of the center (x,y) to the wall or any object&#34;&#34;&#34;
        return np.minimum(np.min(self.pairdist(x,y)),self.walldist(x,y))

    def accepted(self,x,y,r):
        &#34;&#34;&#34; acceptation criterion &#34;&#34;&#34;
        return self.dist(x,y)&gt;r

    def rand(self):
        &#34;&#34;&#34; random position x,y  &#34;&#34;&#34;
        return  np.round(np.random.uniform(low=self.xmin,high=self.xmax)), \
                np.round(np.random.uniform(low=self.ymin,high=self.ymax))

    def setbeadtype(self,beadtype):
        &#34;&#34;&#34; set the default or the supplied beadtype  &#34;&#34;&#34;
        if beadtype == None:
            self.beadtype.append(self.defautbeadtype)
            return self.defautbeadtype
        else:
            self.beadtype.append(beadtype)
            return beadtype

    def insertone(self,x=None,y=None,r=None,beadtype=None,overlap=False):
        &#34;&#34;&#34;
            insert one object of radius r
            properties:
                x,y coordinates (if missing, picked randomly from uniform distribution)
                r radius (default = 2% of diagonal)
                beadtype (default = defautbeadtype)
                overlap = False (accept only if no overlap)
        &#34;&#34;&#34;
        attempt, success = 0, False
        random = (x==None) or (y==None)
        if r==None:
            r = 0.02*np.sqrt(self.width**2+self.height**2)
        while not success and attempt&lt;self.maxtrials:
            attempt += 1
            if random: x,y = self.rand()
            if overlap:
                success = True
            else:
                success = self.accepted(x,y,r)
        if success:
            self.x = np.append(self.x,x)
            self.y = np.append(self.y,y)
            self.r = np.append(self.r,r)
            b=self.setbeadtype(beadtype)
            self.lastinsertion = (x,y,r,b)
        return success

    def insertion(self,rlist,beadtype=None):
        &#34;&#34;&#34;
            insert a list of objects
                nsuccess=insertion(rlist,beadtype=None)
                beadtype=b forces the value b
                if None, defaultbeadtype is used instead
        &#34;&#34;&#34;
        rlist.sort(reverse=True)
        ntodo = len(rlist)
        n = nsuccess = 0
        stop = False
        while not stop:
            n += 1
            success = self.insertone(r=rlist[n-1],beadtype=beadtype)
            if success: nsuccess += 1
            stop = (n==ntodo) or (not success and not self.forcedinsertion)
        if nsuccess==ntodo:
            print(f&#34;{nsuccess} objects inserted successfully&#34;)
        else:
            print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
        return nsuccess</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.scatter" href="#raster.scatter">scatter</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="raster.coreshell" href="#raster.coreshell">coreshell</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="raster.emulsion.accepted"><code class="name flex">
<span>def <span class="ident">accepted</span></span>(<span>self, x, y, r)</span>
</code></dt>
<dd>
<div class="desc"><p>acceptation criterion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accepted(self,x,y,r):
    &#34;&#34;&#34; acceptation criterion &#34;&#34;&#34;
    return self.dist(x,y)&gt;r</code></pre>
</details>
</dd>
<dt id="raster.emulsion.dist"><code class="name flex">
<span>def <span class="ident">dist</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>shortest distance of the center (x,y) to the wall or any object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist(self,x,y):
    &#34;&#34;&#34; shortest distance of the center (x,y) to the wall or any object&#34;&#34;&#34;
    return np.minimum(np.min(self.pairdist(x,y)),self.walldist(x,y))</code></pre>
</details>
</dd>
<dt id="raster.emulsion.insertion"><code class="name flex">
<span>def <span class="ident">insertion</span></span>(<span>self, rlist, beadtype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>insert a list of objects
nsuccess=insertion(rlist,beadtype=None)
beadtype=b forces the value b
if None, defaultbeadtype is used instead</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertion(self,rlist,beadtype=None):
    &#34;&#34;&#34;
        insert a list of objects
            nsuccess=insertion(rlist,beadtype=None)
            beadtype=b forces the value b
            if None, defaultbeadtype is used instead
    &#34;&#34;&#34;
    rlist.sort(reverse=True)
    ntodo = len(rlist)
    n = nsuccess = 0
    stop = False
    while not stop:
        n += 1
        success = self.insertone(r=rlist[n-1],beadtype=beadtype)
        if success: nsuccess += 1
        stop = (n==ntodo) or (not success and not self.forcedinsertion)
    if nsuccess==ntodo:
        print(f&#34;{nsuccess} objects inserted successfully&#34;)
    else:
        print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
    return nsuccess</code></pre>
</details>
</dd>
<dt id="raster.emulsion.insertone"><code class="name flex">
<span>def <span class="ident">insertone</span></span>(<span>self, x=None, y=None, r=None, beadtype=None, overlap=False)</span>
</code></dt>
<dd>
<div class="desc"><p>insert one object of radius r
properties:
x,y coordinates (if missing, picked randomly from uniform distribution)
r radius (default = 2% of diagonal)
beadtype (default = defautbeadtype)
overlap = False (accept only if no overlap)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertone(self,x=None,y=None,r=None,beadtype=None,overlap=False):
    &#34;&#34;&#34;
        insert one object of radius r
        properties:
            x,y coordinates (if missing, picked randomly from uniform distribution)
            r radius (default = 2% of diagonal)
            beadtype (default = defautbeadtype)
            overlap = False (accept only if no overlap)
    &#34;&#34;&#34;
    attempt, success = 0, False
    random = (x==None) or (y==None)
    if r==None:
        r = 0.02*np.sqrt(self.width**2+self.height**2)
    while not success and attempt&lt;self.maxtrials:
        attempt += 1
        if random: x,y = self.rand()
        if overlap:
            success = True
        else:
            success = self.accepted(x,y,r)
    if success:
        self.x = np.append(self.x,x)
        self.y = np.append(self.y,y)
        self.r = np.append(self.r,r)
        b=self.setbeadtype(beadtype)
        self.lastinsertion = (x,y,r,b)
    return success</code></pre>
</details>
</dd>
<dt id="raster.emulsion.rand"><code class="name flex">
<span>def <span class="ident">rand</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>random position x,y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand(self):
    &#34;&#34;&#34; random position x,y  &#34;&#34;&#34;
    return  np.round(np.random.uniform(low=self.xmin,high=self.xmax)), \
            np.round(np.random.uniform(low=self.ymin,high=self.ymax))</code></pre>
</details>
</dd>
<dt id="raster.emulsion.setbeadtype"><code class="name flex">
<span>def <span class="ident">setbeadtype</span></span>(<span>self, beadtype)</span>
</code></dt>
<dd>
<div class="desc"><p>set the default or the supplied beadtype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setbeadtype(self,beadtype):
    &#34;&#34;&#34; set the default or the supplied beadtype  &#34;&#34;&#34;
    if beadtype == None:
        self.beadtype.append(self.defautbeadtype)
        return self.defautbeadtype
    else:
        self.beadtype.append(beadtype)
        return beadtype</code></pre>
</details>
</dd>
<dt id="raster.emulsion.walldist"><code class="name flex">
<span>def <span class="ident">walldist</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>shortest distance to the wall</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walldist(self,x,y):
    &#34;&#34;&#34; shortest distance to the wall &#34;&#34;&#34;
    return min(abs(x-self.xmin),abs(y-self.ymin),abs(x-self.xmax),abs(y-self.ymax))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.scatter" href="#raster.scatter">scatter</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.scatter.pairdist" href="#raster.scatter.pairdist">pairdist</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.genericpolygon"><code class="flex name class">
<span>class <span class="ident">genericpolygon</span></span>
</code></dt>
<dd>
<div class="desc"><p>generic polygon methods</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class genericpolygon(coregeometry):
    &#34;&#34;&#34; generic polygon methods &#34;&#34;&#34;

    hascontour = True
    hasclosefit = False

    @property
    def polygon(self):
        &#34;&#34;&#34;
        R.polygon = path.Path(R.vertices,R.codes,closed=True)
        &#34;&#34;&#34;
        v = self.vertices
        if self.translate != None:
            vtmp = list(map(list,zip(*v)))
            for i in range(len(vtmp[0])):
                vtmp[0][i] += self.translate[0]
                vtmp[1][i] += self.translate[1]
            v = list(zip(*vtmp))
        return path.Path(v,self.codes,closed=True)

    @property
    def polygon2plot(self):
        &#34;&#34;&#34;
        R.polygon2plot = path.Path(R.polygon.vertices+ np.array([1,1]),R.codes,closed=True)
        &#34;&#34;&#34;
        return path.Path(self.polygon.vertices+ np.array([1,1]),self.codes,closed=True)

    def corners(self):
        &#34;&#34;&#34; returns xmin, ymin, xmax, ymax &#34;&#34;&#34;
        return min([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
               min([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1], \
               max([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
               max([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="raster.Circle" href="#raster.Circle">Circle</a></li>
<li><a title="raster.Rectangle" href="#raster.Rectangle">Rectangle</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="raster.genericpolygon.hasclosefit"><code class="name">var <span class="ident">hasclosefit</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="raster.genericpolygon.hascontour"><code class="name">var <span class="ident">hascontour</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="raster.genericpolygon.polygon"><code class="name">var <span class="ident">polygon</span></code></dt>
<dd>
<div class="desc"><p>R.polygon = path.Path(R.vertices,R.codes,closed=True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def polygon(self):
    &#34;&#34;&#34;
    R.polygon = path.Path(R.vertices,R.codes,closed=True)
    &#34;&#34;&#34;
    v = self.vertices
    if self.translate != None:
        vtmp = list(map(list,zip(*v)))
        for i in range(len(vtmp[0])):
            vtmp[0][i] += self.translate[0]
            vtmp[1][i] += self.translate[1]
        v = list(zip(*vtmp))
    return path.Path(v,self.codes,closed=True)</code></pre>
</details>
</dd>
<dt id="raster.genericpolygon.polygon2plot"><code class="name">var <span class="ident">polygon2plot</span></code></dt>
<dd>
<div class="desc"><p>R.polygon2plot = path.Path(R.polygon.vertices+ np.array([1,1]),R.codes,closed=True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def polygon2plot(self):
    &#34;&#34;&#34;
    R.polygon2plot = path.Path(R.polygon.vertices+ np.array([1,1]),R.codes,closed=True)
    &#34;&#34;&#34;
    return path.Path(self.polygon.vertices+ np.array([1,1]),self.codes,closed=True)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.genericpolygon.corners"><code class="name flex">
<span>def <span class="ident">corners</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns xmin, ymin, xmax, ymax</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corners(self):
    &#34;&#34;&#34; returns xmin, ymin, xmax, ymax &#34;&#34;&#34;
    return min([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
           min([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1], \
           max([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
           max([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.coregeometry.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.coregeometry.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.coregeometry.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.coregeometry.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.coregeometry.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.coregeometry.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.coregeometry.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.coregeometry.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.coregeometry.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.overlay"><code class="flex name class">
<span>class <span class="ident">overlay</span></span>
<span>(</span><span>counter=(0, 0), filename='./sandbox/image.jpg', xmin=0, ymin=0, ncolors=4, flipud=True, angle=0, scale=(1, 1))</span>
</code></dt>
<dd>
<div class="desc"><p>generic overlay class </p>
<p>generate an overlay from file
overlay(counter=(c1,c2),filename="this/is/myimage.jpg",xmin=x0,ymin=y0,colors=4)
additional options
overlay(&hellip;,flipud=True,angle=0,scale=(1,1))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class overlay(coregeometry):
    &#34;&#34;&#34; generic overlay class &#34;&#34;&#34;

    hascontour = False
    hasclosefit = True

    def __init__(self,
                 counter = (0,0),
                 filename=&#34;./sandbox/image.jpg&#34;,
                 xmin = 0,
                 ymin = 0,
                 ncolors = 4,
                 flipud = True,
                 angle = 0,
                 scale = (1,1)
                 ):
        &#34;&#34;&#34; generate an overlay from file
                overlay(counter=(c1,c2),filename=&#34;this/is/myimage.jpg&#34;,xmin=x0,ymin=y0,colors=4)
                additional options
                    overlay(...,flipud=True,angle=0,scale=(1,1))
        &#34;&#34;&#34;
        self.name = &#34;over%03d&#34; % counter[1]
        self.kind = &#34;overlay&#34;       # kind of object
        self.alike = &#34;overlay&#34;      # similar object for plotting
        self.beadtype = 1           # bead type
        self.beadtype2 = None       # bead type 2 (alternative beadtype, ratio)
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]  # modification used when an object is duplicated
        if scale is None: scale = 1
        if not isinstance(scale,(tuple,list)): scale = (scale,scale)
        self.scale = scale
        if angle is None: angle = 0
        self.angle = angle
        self.flipud = flipud
        if not os.path.isfile(filename):
            raise IOError(f&#39;the file &#34;{filename}&#34; does not exist&#39;)
        self.filename = filename
        self.ncolors = ncolors
        self.color = None
        self.colormax = None
        self.original,self.raw,self.im,self.map = self.load()
        self.xmin0 = xmin
        self.ymin0 = ymin
        self.xmax0 = xmin + self.im.shape[1]
        self.ymax0 = ymin + self.im.shape[0]
        self.xcenter0 = (self.xmin+self.xmax)/2
        self.ycenter0 = (self.ymin+self.ymax)/2

    def select(self,color=None,colormax=None,scale=None,angle=None):
        &#34;&#34;&#34; select the color index:
                select(color = c) peeks pixels = c
                select(color = c, colormax = cmax) peeks pixels&gt;=c and pixels&lt;=cmax
        &#34;&#34;&#34;
        if color is None:
            color = self.color
        else:
            self.color = color
        if (colormax is None) and (self.colormax is not None) and (self.colormax &gt; self.color):
                colormax = self.colormax
        else:
            colormax = self.colormax = color
        if isinstance(color,int) and color&lt;len(self.map):
            S = np.logical_and(self.im&gt;=color,self.im&lt;=colormax)
            self.nbeads = np.count_nonzero(S)
            return np.flipud(S) if self.flipud else S
        raise ValueError(&#34;color must be an integer lower than %d&#34; % len(self.map))

    def load(self):
        &#34;&#34;&#34; load image and process it
                returns the image, the indexed image and its color map (Ã  la Matlab, such as imread)

                note: if the image contains a palette it is used, if not the
                image is converted to an indexed image without dihtering
        &#34;&#34;&#34;
        I = Image.open(self.filename)
        if self.angle != 0:
            I= I.rotate(self.angle)
        if self.scale[0] * self.scale[1] != 1:
            I = I.resize((round(I.size[0]*self.scale[0]),round(I.size[1]*self.scale[1])))
        palette = I.getpalette()
        if palette is None:
            J=I.convert(mode=&#34;P&#34;,colors=self.ncolors,palette=Image.Palette.ADAPTIVE)
            palette = J.getpalette()
        else:
            J = I
        p = np.array(palette,dtype=&#34;uint8&#34;).reshape((int(len(palette)/3),3))
        ncolors = len(p.sum(axis=1).nonzero()[0]);
        if ncolors&lt;self.ncolors:
            print(f&#34;only {ncolors} are available&#34;)
        return I,J, np.array(J,dtype=&#34;uint8&#34;), p[:ncolors,:]

    def __repr__(self):
        &#34;&#34;&#34; display for rectangle class &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(f&#39;\tfilename: &#34;{self.filename}&#34;&#39;)
        print(&#34;\tangle = %0.4g (original image)&#34; % self.angle)
        print(&#34;\tscale = [%0.4g, %0.4g] (original image)&#34; % self.scale)
        print(f&#34;\tncolors = {self.ncolors} (selected={self.color})&#34;)
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        print(&#34;note: use the attribute origina,raw to see the raw image&#34;)
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind,self.name,self.beadtype)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="raster.overlay.hasclosefit"><code class="name">var <span class="ident">hasclosefit</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="raster.overlay.hascontour"><code class="name">var <span class="ident">hascontour</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.overlay.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>load image and process it
returns the image, the indexed image and its color map (Ã  la Matlab, such as imread)</p>
<p>note: if the image contains a palette it is used, if not the
image is converted to an indexed image without dihtering</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self):
    &#34;&#34;&#34; load image and process it
            returns the image, the indexed image and its color map (Ã  la Matlab, such as imread)

            note: if the image contains a palette it is used, if not the
            image is converted to an indexed image without dihtering
    &#34;&#34;&#34;
    I = Image.open(self.filename)
    if self.angle != 0:
        I= I.rotate(self.angle)
    if self.scale[0] * self.scale[1] != 1:
        I = I.resize((round(I.size[0]*self.scale[0]),round(I.size[1]*self.scale[1])))
    palette = I.getpalette()
    if palette is None:
        J=I.convert(mode=&#34;P&#34;,colors=self.ncolors,palette=Image.Palette.ADAPTIVE)
        palette = J.getpalette()
    else:
        J = I
    p = np.array(palette,dtype=&#34;uint8&#34;).reshape((int(len(palette)/3),3))
    ncolors = len(p.sum(axis=1).nonzero()[0]);
    if ncolors&lt;self.ncolors:
        print(f&#34;only {ncolors} are available&#34;)
    return I,J, np.array(J,dtype=&#34;uint8&#34;), p[:ncolors,:]</code></pre>
</details>
</dd>
<dt id="raster.overlay.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, color=None, colormax=None, scale=None, angle=None)</span>
</code></dt>
<dd>
<div class="desc"><p>select the color index:
select(color = c) peeks pixels = c
select(color = c, colormax = cmax) peeks pixels&gt;=c and pixels&lt;=cmax</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self,color=None,colormax=None,scale=None,angle=None):
    &#34;&#34;&#34; select the color index:
            select(color = c) peeks pixels = c
            select(color = c, colormax = cmax) peeks pixels&gt;=c and pixels&lt;=cmax
    &#34;&#34;&#34;
    if color is None:
        color = self.color
    else:
        self.color = color
    if (colormax is None) and (self.colormax is not None) and (self.colormax &gt; self.color):
            colormax = self.colormax
    else:
        colormax = self.colormax = color
    if isinstance(color,int) and color&lt;len(self.map):
        S = np.logical_and(self.im&gt;=color,self.im&lt;=colormax)
        self.nbeads = np.count_nonzero(S)
        return np.flipud(S) if self.flipud else S
    raise ValueError(&#34;color must be an integer lower than %d&#34; % len(self.map))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.coregeometry.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.coregeometry.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.coregeometry.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.coregeometry.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.coregeometry.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.coregeometry.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.coregeometry.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.coregeometry.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.coregeometry.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.raster"><code class="flex name class">
<span>class <span class="ident">raster</span></span>
<span>(</span><span>name='default raster', width=100, height=100, dpi=200, fontsize=10, mass=1, volume=1, radius=1.5, contactradius=0.5, velocities=[0, 0, 0], forces=[0, 0, 0], preview=True, previewthumb=(128, 128), filename='')</span>
</code></dt>
<dd>
<div class="desc"><p>raster class for LAMMPS SMD</p>
<p>Constructor</p>
<pre><code>R = raster(width=100,height=100...)

Extra properties
    dpi, fontsize

additional properties for R.data()
    scale, center : full scaling
    mass, volume, radius, contactradius, velocities, forces: bead scaling
    filename

List of available properties = default values

           name = "default raster"
          width = 100
         height = 100
            dpi = 200
       fontsize = 10
           mass = 1
         volume = 1
         radius = 1.5
  contactradius = 0.5
     velocities = [0, 0, 0]
         forces = [0, 0, 0]
        preview = True
   previewthumb = (128,128)
       filename = ["%dx%d raster (%s)" % (self.width,self.height,self.name)]
</code></pre>
<p>Graphical objects</p>
<pre><code>R.rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode="lower", angle=0, ismask=False])
R.rectangle(xcenter,ycenter,width,height [, beadtype=1,mode="center", angle=0, ismask=False])
R.circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
R.triangle(...)
R.diamond(...)
R.pentagon(...)
R.hexagon(...)

R.overlay(xleft,xright,filename=="valid/image.ext",color=2,beadtype=1)

note: use fake=True to generate an object without inserting it

R.collection(...) generates collection of existing or fake objects
R.object.copy(...) enables to copy an object
</code></pre>
<p>Display methods (precedence affects the result)
R.plot()
R.show(), R.show(extra="label",contour=True,what="beadtype" or "objindex")
R.show(extra="labels")
R.list()
R.get("object")
R.print()
R.label("object")
R.unlabel("object")
R.figure()
R.newfigure(dpi=300)</p>
<pre><code>R.numeric()
R.string(), R.string(what="beadtype" or "objindex"))
R.names()
R.print()
</code></pre>
<p>Clear and delete
R.clear()
R.clear("all")
R.delete("object")</p>
<p>Copy objects
R.copyalongpath(....)
R.scatter()</p>
<p>Generate an input data object
X = R.data() or X=R.data(scale=(1,1),center=(0,0))
X.write("/tmp/myfile")</p>
<p>initialize raster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class raster:
    &#34;&#34;&#34; raster class for LAMMPS SMD

    Constructor

        R = raster(width=100,height=100...)

        Extra properties
            dpi, fontsize

        additional properties for R.data()
            scale, center : full scaling
            mass, volume, radius, contactradius, velocities, forces: bead scaling
            filename

        List of available properties = default values

                   name = &#34;default raster&#34;
                  width = 100
                 height = 100
                    dpi = 200
               fontsize = 10
                   mass = 1
                 volume = 1
                 radius = 1.5
          contactradius = 0.5
             velocities = [0, 0, 0]
                 forces = [0, 0, 0]
                preview = True
           previewthumb = (128,128)
               filename = [&#34;%dx%d raster (%s)&#34; % (self.width,self.height,self.name)]

    Graphical objects

        R.rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode=&#34;lower&#34;, angle=0, ismask=False])
        R.rectangle(xcenter,ycenter,width,height [, beadtype=1,mode=&#34;center&#34;, angle=0, ismask=False])
        R.circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
        R.triangle(...)
        R.diamond(...)
        R.pentagon(...)
        R.hexagon(...)

        R.overlay(xleft,xright,filename==&#34;valid/image.ext&#34;,color=2,beadtype=1)

        note: use fake=True to generate an object without inserting it

        R.collection(...) generates collection of existing or fake objects
        R.object.copy(...) enables to copy an object

    Display methods (precedence affects the result)
        R.plot()
        R.show(), R.show(extra=&#34;label&#34;,contour=True,what=&#34;beadtype&#34; or &#34;objindex&#34;)
        R.show(extra=&#34;labels&#34;)
        R.list()
        R.get(&#34;object&#34;)
        R.print()
        R.label(&#34;object&#34;)
        R.unlabel(&#34;object&#34;)
        R.figure()
        R.newfigure(dpi=300)

        R.numeric()
        R.string(), R.string(what=&#34;beadtype&#34; or &#34;objindex&#34;))
        R.names()
        R.print()

    Clear and delete
        R.clear()
        R.clear(&#34;all&#34;)
        R.delete(&#34;object&#34;)

    Copy objects
        R.copyalongpath(....)
        R.scatter()

    Generate an input data object
        X = R.data() or X=R.data(scale=(1,1),center=(0,0))
        X.write(&#34;/tmp/myfile&#34;)

    &#34;&#34;&#34;

    # CONSTRUCTOR ----------------------------
    def __init__(self,
                 # raster properties
                 name=&#34;default raster&#34;,
                 width=100,
                 height=100,
                 # printing and display
                 dpi=200,
                 fontsize=10,
                 # for data conversion
                 mass=1,
                 volume=1,
                 radius=1.5,
                 contactradius=0.5,
                 velocities=[0,0,0],
                 forces=[0,0,0],
                 preview=True,
                 previewthumb = (128,128),
                 filename=&#34;&#34;
                 ):

        &#34;&#34;&#34; initialize raster &#34;&#34;&#34;
        self.name = name
        self.width = width
        self.height = height
        self.xcenter= width/2
        self.ycenter = height/2
        self.objects = {}
        self.nobjects = 0    # total number of objects (alive)
        self.nbeads = 0
        self.counter = { &#34;triangle&#34;:0,
                          &#34;diamond&#34;:0,
                        &#34;rectangle&#34;:0,
                         &#34;pentagon&#34;:0,
                          &#34;hexagon&#34;:0,
                           &#34;circle&#34;:0,
                          &#34;overlay&#34;:0,
                       &#34;collection&#34;:0,
                              &#34;all&#34;:0
                    }
        self.fontsize = 10   # font size for labels
        self.imbead = np.zeros((height,width),dtype=np.int8)
        self.imobj = np.zeros((height,width),dtype=np.int8)
        self.hfig = [] # figure handle
        self.dpi = dpi
        # generic SMD properties (to be rescaled)
        self.volume = volume
        self.mass = mass
        self.radius = radius
        self.contactradius = contactradius
        self.velocities = velocities
        self.forces =forces

        self.preview = preview
        self.previewthumb = previewthumb

        if filename == &#34;&#34;:
            self.filename = [&#34;%dx%d raster (%s)&#34; % (self.width,self.height,self.name)]
        else:
            self.filename = filename


    # DATA ----------------------------
    def data(self,scale=(1,1),center=(0,0),maxtype=None,hexpacking=None):
        &#34;&#34;&#34;
            return a pizza.data object
                data()
                data(scale=(scalex,scaley),
                     center=(centerx,centery),
                     maxtype=number,
                     hexpacking=(0.5,0))
        &#34;&#34;&#34;
        if not isinstance(scale,tuple) or len(scale)!=2:
            raise ValueError(&#34;scale must be tuple (scalex,scaley)&#34;)
        if not isinstance(center,tuple) or len(scale)!=2:
            raise ValueError(&#34;center must be tuple (centerx,centery)&#34;)
        scalez = np.sqrt(scale[0]*scale[1])
        scalevol = scale[0]*scale[1] #*scalez
        maxtypeheader = self.count()[-1][0] if maxtype is None else maxtype
        n = self.length()
        i,j = self.imbead.nonzero() # x=j+0.5 y=i+0.5
        x = (j+0.5-center[0])*scale[0]
        y = (i+0.5-center[1])*scale[1]
        if hexpacking is not None:
            if isinstance(hexpacking,tuple) and len(hexpacking)==2:
                for k in range(len(i)):
                    if i[k] % 2:
                        x[k] = (j[k]+0.5+hexpacking[1]-center[0])*scale[0]
                    else:
                        x[k] = (j[k]+0.5+hexpacking[0]-center[0])*scale[0]
            else:
                raise ValueError(&#34;hexpacking should be a tuple (shiftodd,shifteven)&#34;)
        X = data3()  # empty pizza.data3.data object
        X.title = self.name + &#34;(raster)&#34;
        X.headers = {&#39;atoms&#39;: n,
                      &#39;atom types&#39;: maxtypeheader,
                      &#39;xlo xhi&#39;: ((0.0-center[0])*scale[0], (self.width-0.0-center[0])*scale[0]),
                      &#39;ylo yhi&#39;: ((0.0-center[1])*scale[1], (self.height-0.0-center[1])*scale[1]),
                      &#39;zlo zhi&#39;: (0, scalez)}
        # [ATOMS] section
        X.append(&#39;Atoms&#39;,list(range(1,n+1)),True,&#34;id&#34;)       # id
        X.append(&#39;Atoms&#39;,self.imbead[i,j],True,&#34;type&#34;)       # Type
        X.append(&#39;Atoms&#39;,1,True,&#34;mol&#34;)                       # mol
        X.append(&#39;Atoms&#39;,self.volume*scalevol,False,&#34;c_vol&#34;) # c_vol
        X.append(&#39;Atoms&#39;,self.mass*scalevol,False,&#34;mass&#34;)    # mass
        X.append(&#39;Atoms&#39;,self.radius*scalez,False,&#34;radius&#34;)         # radius
        X.append(&#39;Atoms&#39;,self.contactradius*scalez,False,&#34;c_contact_radius&#34;) # c_contact_radius
        X.append(&#39;Atoms&#39;,x,False,&#34;x&#34;)        # x
        X.append(&#39;Atoms&#39;,y,False,&#34;y&#34;)        # y
        X.append(&#39;Atoms&#39;,0,False,&#34;z&#34;)        # z
        X.append(&#39;Atoms&#39;,x,False,&#34;x0&#34;)       # x0
        X.append(&#39;Atoms&#39;,y,False,&#34;y0&#34;)       # y0
        X.append(&#39;Atoms&#39;,0,False,&#34;z0&#34;)       # z0
        # [VELOCITIES] section
        X.append(&#39;Velocities&#39;,list(range(1,n+1)),True,&#34;id&#34;) # id
        X.append(&#39;Velocities&#39;,self.velocities[0],False,&#34;vx&#34;) # vx
        X.append(&#39;Velocities&#39;,self.velocities[1],False,&#34;vy&#34;) # vy
        X.append(&#39;Velocities&#39;,self.velocities[2],False,&#34;vz&#34;) # vz
        # pseudo-filename
        X.flist = self.filename
        return X

    # LENGTH ----------------------------
    def length(self,t=None,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; returns the total number of beads length(type,&#34;beadtype&#34;) &#34;&#34;&#34;
        if what == &#34;beadtype&#34;:
            num = self.imbead
        elif what == &#34;objindex&#34;:
            num = self.imobj
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        if t==None:
            return np.count_nonzero(num&gt;0)
        else:
            return np.count_nonzero(num==t)

    # NUMERIC ----------------------------
    def numeric(self):
        &#34;&#34;&#34; retrieve the image as a numpy.array &#34;&#34;&#34;
        return self.imbead, self.imobj

    # STRING ----------------------------
    def string(self,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; convert the image as ASCII strings &#34;&#34;&#34;
        if what == &#34;beadtype&#34;:
            num = np.flipud(duplicate(self.imbead))
        elif what == &#34;objindex&#34;:
            num = np.flipud(duplicate(self.imobj))
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        num[num&gt;0] = num[num&gt;0] + 65
        num[num==0] = 32
        num = list(num)
        return [&#34;&#34;.join(map(chr,x)) for x in num]

    # GET -----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.objects:
            return self.objects[name]
        else:
            raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # GETATTR --------------------------
    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return self.get(key)

    # CLEAR ----------------------------
    def clear(self,what=&#34;nothing&#34;):
        &#34;&#34;&#34; clear the plotting area, use clear(&#34;all&#34;)) to remove all objects &#34;&#34;&#34;
        self.imbead = np.zeros((self.height,self.width),dtype=np.int8)
        self.imobj = np.zeros((self.height,self.width),dtype=np.int8)
        for o in self.names():
            if what==&#34;all&#34;:
                self.delete(o)
            else:
                self.objects[o].isplotted = False
                self.objects[o].islabelled = False
                if not self.objects[o].ismask:
                    self.nbeads -= self.objects[o].nbeads
                self.objects[o].nbeads = 0  # number of beads (plotted)
        self.figure()
        plt.cla()
        self.show()

    # DISP method ----------------------------
    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        ctyp = self.count() # count objects (not beads)
        print(&#34;-&#34;*40)
        print(&#39;RASTER area &#34;%s&#34; with %d objects&#39; % (self.name,self.nobjects))
        print(&#34;-&#34;*40)
        print(&#34;&lt;- grid size -&gt;&#34;)
        print(&#34;\twidth: %d&#34; % self.width)
        print(&#34;\theight: %d&#34; % self.height)
        print(&#34;&lt;- bead types -&gt;&#34;)
        nbt = 0
        if len(ctyp):
            for i,c in enumerate(ctyp):
                nb = self.length(c[0])
                nbt += nb
                print(&#34;\t type=%d (%d objects, %d beads)&#34; % (c[0],c[1],nb))
        else:
            print(&#34;\tno bead assigned&#34;)
        print(&#34;-&#34;*40)
        if self.preview and len(self)&gt;0 and self.max&gt;0:
            if PILavailable:
                display(self.torgb(&#34;beadtype&#34;,self.previewthumb))
                display(self.torgb(&#34;objindex&#34;,self.previewthumb))
            else:
                print(&#34;no PIL image&#34;)
        return &#34;RASTER AREA %d x %d with %d objects (%d types, %d beads).&#34; % \
        (self.width,self.height,self.nobjects,len(ctyp),nbt)

    # TORGB method ----------------------------
    def torgb(self,what=&#34;beadtype&#34;,thumb=None):
        &#34;&#34;&#34; converts bead raster to image
                rgb = raster.torgb(what=&#34;beadtype&#34;)
                thumbnail = raster.torgb(what=&#34;beadtype&#34;,(128,128))
                use: rgb.save(&#34;/path/filename.png&#34;) for saving

            what = &#34;beadtype&#34; or &#34;objindex&#34;
        &#34;&#34;&#34;
        if what==&#34;beadtype&#34;:
            rgb = ind2rgb(self.imbead,ncolors=self.max+1)
        elif what == &#34;objindex&#34;:
            rgb = ind2rgb(self.imobj,ncolors=len(self)+1)
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        if thumb is not None: rgb.thumbnail(thumb)
        return rgb

    # COUNT method ----------------------------
    def count(self):
        &#34;&#34;&#34; count objects by type &#34;&#34;&#34;
        typlist = []
        for  o in self.names():
            if isinstance(self.objects[o].beadtype,list):
                typlist += self.objects[o].beadtype
            else:
                typlist.append(self.objects[o].beadtype)
        utypes = list(set(typlist))
        c = []
        for t in utypes:
            c.append((t,typlist.count(t)))
        return c

    # max method ------------------------------
    @property
    def max(self):
        &#34;&#34;&#34; max bead type &#34;&#34;&#34;
        typlist = []
        for  o in self.names():
            if isinstance(self.objects[o].beadtype,list):
                typlist += self.objects[o].beadtype
            else:
                typlist.append(self.objects[o].beadtype)
        return max(typlist)

    # len method ------------------------------
    def __len__(self):
        &#34;&#34;&#34; len method &#34;&#34;&#34;
        return len(self.objects)

    # NAMES method ----------------------------
    def names(self):
        &#34;&#34;&#34; return the names of objects sorted as index &#34;&#34;&#34;
        namesunsorted=namessorted=list(self.objects.keys())
        nobj = len(namesunsorted)
        for iobj in range(nobj):
            namessorted[self.objects[namesunsorted[iobj]].index-1] = namesunsorted[iobj]
        return namessorted

    # LIST method ----------------------------
    def list(self):
        &#34;&#34;&#34; list objects &#34;&#34;&#34;
        fmt = &#34;%%%ss:&#34; % max(10,max([len(n) for n in self.names()])+2)
        print(&#34;RASTER with %d objects&#34; % self.nobjects)
        for o in self.objects.keys():
            print(fmt % self.objects[o].name,&#34;%-10s&#34; % self.objects[o].kind,
                  &#34;(beadtype=%d,object index=[%d,%d], n=%d)&#34; % \
                      (self.objects[o].beadtype,
                       self.objects[o].index,
                       self.objects[o].subindex,
                       self.objects[o].nbeads))

    # EXIST method ----------------------------
    def exist(self,name):
        &#34;&#34;&#34; exist object &#34;&#34;&#34;
        return name in self.objects

    # DELETE method ----------------------------
    def delete(self,name):
        &#34;&#34;&#34; delete object &#34;&#34;&#34;
        if name in self.objects:
            if not self.objects[name].ismask:
                self.nbeads -= self.objects[name].nbeads
            del self.objects[name]
            self.nobjects -= 1
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)
        self.clear()
        self.plot()
        self.show(extra=&#34;label&#34;)

    # VALID method
    def valid(self,x,y):
        &#34;&#34;&#34; validation of coordinates &#34;&#34;&#34;
        return min(self.width,max(0,round(x))),min(self.height,max(0,round(y)))

    # frameobj method
    def frameobj(self,obj):
        &#34;&#34;&#34; frame coordinates by taking into account translation &#34;&#34;&#34;
        if obj.hasclosefit:
            envelope = 0
        else:
            envelope = 1
        xmin, ymin = self.valid(obj.xmin-envelope, obj.ymin-envelope)
        xmax, ymax = self.valid(obj.xmax+envelope, obj.ymax+envelope)
        return xmin, ymin, xmax, ymax

    # RECTANGLE ----------------------------
    def rectangle(self,a,b,c,d,
                  mode=&#34;lowerleft&#34;,name=None,angle=0,
                  beadtype=None,ismask=False,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        rectangle object
            rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode=&#34;lower&#34;, angle=0, ismask=False])
            rectangle(xcenter,ycenter,width,height [, beadtype=1,mode=&#34;center&#34;, angle=0, ismask=False])

            use rectangle(...,beadtype2=(type,ratio)) to salt an object with beads
            from another type and with a given ratio
        &#34;&#34;&#34;
        # object creation
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;rectangle&#34;] += 1
        R = Rectangle((self.counter[&#34;all&#34;],self.counter[&#34;rectangle&#34;]))
        if (name != None) and (name != &#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            R.name = name
        else:
            name = R.name
        if beadtype is not None: R.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        R.beadtype2 = beadtype2
        if ismask: R.beadtype = 0
        R.ismask = R.beadtype==0
        # build vertices
        if mode == &#34;lowerleft&#34;:
            R.xcenter0 = (a+b)/2
            R.ycenter0 = (c+d)/2
            R.vertices = [
                _rotate(a,c,R.xcenter0,R.ycenter0,angle),
                _rotate(b,c,R.xcenter0,R.ycenter0,angle),
                _rotate(b,d,R.xcenter0,R.ycenter0,angle),
                _rotate(a,d,R.xcenter0,R.ycenter0,angle),
                _rotate(a,c,R.xcenter0,R.ycenter0,angle)
                ] # anti-clockwise, closed (last point repeated)
        elif mode == &#34;center&#34;:
            R.xcenter0 = a
            R.ycenter0 = b
            R.vertices = [
                _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a+c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a+c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a-c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle)
                ]
        else:
            raise ValueError(&#39;&#34;%s&#34; is not a recognized mode, use &#34;lowerleft&#34; (default) and &#34;center&#34; instead&#39;)
        # build path object and range
        R.codes =    [ path.Path.MOVETO,
                     path.Path.LINETO,
                     path.Path.LINETO,
                     path.Path.LINETO,
                     path.Path.CLOSEPOLY
                    ]
        R.nvertices = len(R.vertices)-1
        R.xmin0, R.ymin0, R.xmax0, R.ymax0 = R.corners()
        R.xmin0, R.ymin0 = self.valid(R.xmin0,R.ymin0)
        R.xmax0, R.ymax0 = self.valid(R.xmax0,R.ymax0)
        R.angle = angle
        # store the object (if not fake)
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[&#34;rectangle&#34;] -= 1
            return R
        else:
            self.objects[name] = R
            self.nobjects += 1
            return None


    # CIRCLE ----------------------------
    def circle(self,xc,yc,radius,
                  name=None,shaperatio=1,angle=0,beadtype=None,ismask=False,
                  resolution=20,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        circle object (or any regular polygon)
            circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
            use circle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        # object creation
        self.counter[&#34;all&#34;] += 1
        if resolution==3:
            typ = &#34;triangle&#34;
            self.counter[&#34;triangle&#34;] += 1
            G = Triangle((self.counter[&#34;all&#34;],self.counter[&#34;triangle&#34;]))
        elif resolution==4:
            typ = &#34;diamond&#34;
            self.counter[&#34;diamond&#34;] += 1
            G = Diamond((self.counter[&#34;all&#34;],self.counter[&#34;diamond&#34;]))
        elif resolution==5:
            typ = &#34;pentagon&#34;
            self.counter[&#34;pentagon&#34;] += 1
            G = Pentagon((self.counter[&#34;all&#34;],self.counter[&#34;pentagon&#34;]))
        elif resolution==6:
            typ = &#34;hexagon&#34;
            self.counter[&#34;hexagon&#34;] += 1
            G = Hexagon((self.counter[&#34;all&#34;],self.counter[&#34;hexagon&#34;]))
        else:
            typ = &#34;circle&#34;
            self.counter[&#34;circle&#34;] += 1
            G = Circle((self.counter[&#34;all&#34;],self.counter[&#34;circle&#34;]),resolution=resolution)
        if (name != None) and (name != &#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            G.name = name
        else:
            name = G.name
        if beadtype is not None: G.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        G.beadtype2 = beadtype2
        if ismask: G.beadtype = 0
        G.ismask = G.beadtype==0
        # build vertices
        th = np.linspace(0,2*np.pi,G.resolution+1) +shiftangle*np.pi/180
        xgen = xc + radius * np.cos(th)
        ygen = yc + radius * shaperatio * np.sin(th)
        G.xcenter0, G.ycenter0, G.radius = xc, yc, radius
        G.vertices, G.codes = [], []
        for i in range(G.resolution+1):
            G.vertices.append(_rotate(xgen[i],ygen[i],xc,yc,angle))
            if i==0:
                G.codes.append(path.Path.MOVETO)
            elif i==G.resolution:
                G.codes.append(path.Path.CLOSEPOLY)
            else:
                G.codes.append(path.Path.LINETO)
        G.nvertices = len(G.vertices)-1
        # build path object and range
        G.xmin0, G.ymin0, G.xmax0, G.ymax0 = G.corners()
        G.xmin0, G.ymin0 = self.valid(G.xmin0,G.ymin0)
        G.xmax0, G.ymax0 = self.valid(G.xmax0,G.ymax0)
        G.angle, G.shaperatio = angle, shaperatio
        # store the object
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[typ] -= 1
            return G
        else:
            self.objects[name] = G
            self.nobjects += 1
            return None

    # OVERLAY -------------------------------
    def overlay(self,x0,y0,
                name = None,
                filename = None,
                color = 1,
                colormax = None,
                ncolors = 4,
                beadtype = None,
                beadtype2 = None,
                ismask = False,
                fake = False,
                flipud = True,
                angle = 0,
                scale= (1,1)
                ):
        &#34;&#34;&#34;
            overlay object: made from an image converted to nc colors
            the object is made from the level ranged between ic and jc (bounds included)
            note: if palette found, no conversion is applied

            O = overlay(x0,y0,filename=&#34;/this/is/my/image.png&#34;,ncolors=nc,color=ic,colormax=jc,beadtype=b)
            O = overlay(...angle=0,scale=(1,1)) to induce rotation and change of scale
            O = overlay(....ismask=False,fake=False)

            note use overlay(...flipud=False) to prevent image fliping (standard)

            Outputs:
                O.original original image (PIL)
                O.raw image converted to ncolors if needed

        &#34;&#34;&#34;
        if filename is None or filename==&#34;&#34;:
            raise ValueError(&#34;filename is required (valid image)&#34;)
        O = overlay(counter=(self.counter[&#34;all&#34;]+1,self.counter[&#34;overlay&#34;]+1),
                    filename = filename,
                    xmin = x0,
                    ymin = y0,
                    ncolors = ncolors,
                    flipud = flipud,
                    angle = angle,
                    scale = scale
                    )
        O.select(color=color, colormax=colormax)
        if (name is not None) and (name !=&#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            O.name = name
        else:
            name = O.name
        if beadtype is not None: O.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        O.beadtype2 = beadtype2
        if ismask: O.beadtype = 0
        O.ismask = O.beadtype==0
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;overlay&#34;] += 1
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[&#34;overlay&#34;] -= 1
            return O
        else:
            self.objects[name] = O
            self.nobjects += 1
            return None


    # COLLECTION ----------------------------
    def collection(self,*obj,
                   name=None,
                   beadtype=None,
                   ismask=None,
                   translate = [0.0,0.0],
                   fake = False,
                   **kwobj):
        &#34;&#34;&#34;
            collection of objects:
                collection(draftraster,name=&#34;mycollect&#34; [,beadtype=1,ismask=True]
                collection(name=&#34;mycollect&#34;,newobjname1 = obj1, newobjname2 = obj2...)
        &#34;&#34;&#34;
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;collection&#34;] += 1
        C = Collection((self.counter[&#34;all&#34;],self.counter[&#34;collection&#34;]))
        # name
        if name != None:
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            C.name = name
        else:
            name = C.name
        # build the collection
        C.collection = collection(*obj,**kwobj)
        xmin = ymin = +1e99
        xmax = ymax = -1e99
        # apply modifications (beadtype, ismask)
        for o in C.collection.keys():
            tmp = C.collection.getattr(o)
            tmp.translate[0] += translate[0]
            tmp.translate[1] += translate[1]
            xmin, xmax = min(xmin,tmp.xmin), max(xmax,tmp.xmax)
            ymin, ymax = min(ymin,tmp.ymin), max(ymax,tmp.ymax)
            if beadtype != None: tmp.beadtype = beadtype
            if ismask != None: tmp.ismask = ismask
            C.collection.setattr(o,tmp)
        C.xmin, C.xmax, C.ymin, C.ymax = xmin, xmax, ymin, ymax
        C.width, C.height = xmax-xmin, ymax-ymin
        if fake:
            return C
        else:
            self.objects[name] = C
            self.nobjects += 1
            return None

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # =========== pseudo methods connected to circle() ===========
    # TRIANGLE, DIAMOND, PENTAGON, HEXAGON, -----------------------
    def triangle(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        triangle object
            triangle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use triangle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=3,
           angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)

    def diamond(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        diamond object
            diamond(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use diamond(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=4,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)

    def pentagon(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        pentagon object
            pentagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use pentagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=5,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)

    def hexagon(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        hexagon object
            hexagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use hexagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=6,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # label method ----------------------------
    def label(self,name,**fmt):
        &#34;&#34;&#34;
            label:
                label(name [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
        &#34;&#34;&#34;
        self.figure()
        if name in self.objects:
            if not self.objects[name].islabelled:
                if self.objects[name].alike == &#34;mixed&#34;:
                    for o in self.objects[name].collection:
                        self.labelobj(o,**fmt)
                else:
                    self.labelobj(self.objects[name],**fmt)
                plt.show()
                self.objects[name].islabelled = True
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)

    # label object method -----------------------------
    def labelobj(self,obj,contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2,ax=plt.gca()):
        &#34;&#34;&#34;
            labelobj:
                labelobj(obj [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
        &#34;&#34;&#34;
        if contour: contour = obj.hascontour # e.g. overlays do not have contour

        if contour:
            patch = patches.PathPatch(obj.polygon2plot,
                                      facecolor=facecolor,
                                      edgecolor=edgecolor,
                                      lw=linewidth)
            obj.hlabel[&#34;contour&#34;] = ax.add_patch(patch)
        else:
            obj.hlabel[&#34;contour&#34;] = None
        obj.hlabel[&#34;text&#34;] = \
        plt.text(obj.xcenter,
                 obj.ycenter,
                 &#34;%s\n(t=$%d$,$n_p$=%d)&#34; % (obj.name, obj.beadtype,obj.nbeads),
                 horizontalalignment = &#34;center&#34;,
                 verticalalignment = &#34;center_baseline&#34;,
                 fontsize=self.fontsize
                 )


    def unlabel(self,name):
        &#34;&#34;&#34; unlabel &#34;&#34;&#34;
        if name in self.objects:
            if  self.objects[name].islabelled:
                self.objects[name].hlabel[&#34;contour&#34;].remove()
                self.objects[name].hlabel[&#34;text&#34;].remove()
                self.objects[name].hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
                self.objects[name].islabelled = False
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)


    # PLOT method ----------------------------
    def plot(self):
        &#34;&#34;&#34; plot &#34;&#34;&#34;
        for o in self.objects:
            if not self.objects[o].isplotted:
                if self.objects[o].alike == &#34;mixed&#34;:
                    for o2 in self.objects[o].collection:
                        self.plotobj(o2)
                else:
                    self.plotobj(self.objects[o])
                # store it as plotted
                self.objects[o].isplotted = True
                if not self.objects[o].ismask:
                    self.nbeads += self.objects[o].nbeads


    # PLOTobj method  -----------------------
    def plotobj(self,obj):
        &#34;&#34;&#34; plotobj(obj) &#34;&#34;&#34;
        if obj.alike == &#34;circle&#34;:
            xmin, ymin, xmax, ymax = self.frameobj(obj)
            j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
            points = np.vstack((j.flatten(),i.flatten())).T
            npoints = points.shape[0]
            inside = obj.polygon.contains_points(points)
            if obj.beadtype2 is None:          # -- no salting --
                for k in range(npoints):
                    if inside[k] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1
            else:
                for k in range(npoints):       # -- salting --
                    if inside[k] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            if np.random.rand()&lt;obj.beadtype2[1]:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                            else:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1

        elif obj.alike == &#34;overlay&#34;:
            xmin, ymin, xmax, ymax = self.frameobj(obj)
            j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
            points = np.vstack((j.flatten(),i.flatten())).T
            npoints = points.shape[0]
            inside = obj.select()
            if obj.beadtype2 is None:          # -- no salting --
                for k in range(npoints):
                    if inside[ points[k,1]-ymin, points[k,0]-xmin ] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1
            else:
                for k in range(npoints):       # -- salting --
                    if inside[ points[k,0]-ymin, points[k,0]-xmin ] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            if np.random.rand()&lt;obj.beadtype2[1]:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                            else:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1

        else:
            raise ValueError(&#34;This object type is notimplemented&#34;)

    # SHOW method ----------------------------
    def show(self,extra=&#34;none&#34;,contour=True,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; show method: show(extra=&#34;label&#34;,contour=True,what=&#34;beadtype&#34;) &#34;&#34;&#34;
        self.figure()
        if what==&#34;beadtype&#34;:
            imagesc(self.imbead)
        elif what == &#34;objindex&#34;:
            imagesc(self.imobj)
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        if extra == &#34;label&#34;:
            ax = plt.gca()
            for o in self.names():
                if not self.objects[o].ismask:
                    self.label(o,ax=ax,contour=contour)
            ax.set_title(&#34;raster area: %s \n (n=%d, $n_p$=%d)&#34; %\
                      (self.name,self.length(),self.nbeads) )
            plt.show()

    # SHOW method ----------------------------
    def print(self,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; print method &#34;&#34;&#34;
        txt = self.string(what=what)
        for i in range(len(txt)):
            print(txt[i],end=&#34;\n&#34;)


    # FIGURE method ----------------------------
    def figure(self):
        &#34;&#34;&#34; set the current figure &#34;&#34;&#34;
        if self.hfig==[] or not plt.fignum_exists(self.hfig.number):
            self.newfigure()
        plt.figure(self.hfig.number)

    # NEWFIGURE method ----------------------------
    def newfigure(self):
        &#34;&#34;&#34; create a new figure (dpi=200) &#34;&#34;&#34;
        self.hfig = plt.figure(dpi=self.dpi)

    # COPY OBJECT ALONG a contour -----------------
    def copyalongpath(self,obj,
                      name=&#34;path&#34;,
                  beadtype=None,
                      path=linear,
                      xmin=10,
                      ymin=10,
                      xmax=70,
                      ymax=90,
                         n=7,
                      USER=struct()):
        &#34;&#34;&#34;

        The method enable to copy an existing object (from the current raster,
        from another raster or a fake object) amp,g

        Parameters
        ----------
        obj : real or fake object
            the object to be copied.
        name : string, optional
            the name of the object collection. The default is &#34;path&#34;.
        beadtype : integet, optional
            type of bead (can override existing value). The default is None.
        path : function, optional
            parametric function returning x,y. The default is linear.
            x is between xmin and xmax, and y between ymin, ymax
        xmin : int64 or float, optional
            left x corner position. The default is 10.
        ymin : int64 or float, optional
            bottom y corner position. The default is 10.
        xmax : int64 or float, optional
            right x corner position. The default is 70.
        ymax : int64 or float, optional
            top y corner position. The default is 90.
        n : integet, optional
            number of copies. The default is 7.
     USER : structure to pass specific parameters

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if not isinstance(USER,struct):
            raise TypeError(&#34;USER should be a structure&#34;)
        x,y = path(xmin=xmin,ymin=ymin,xmax=xmax,ymax=ymax,n=n,USER=USER)
        btyp = obj.beadtype if beadtype == None else beadtype
        collect = {}
        for i in range(n):
            nameobj = &#34;%s_%s_%02d&#34; % (name,obj.name,i)
            x[i], y[i] = self.valid(x[i], y[i])
            translate = [ x[i]-obj.xcenter, y[i]-obj.ycenter ]
            collect[nameobj] = obj.copy(translate=translate,
                                        name=nameobj,
                                        beadtype=btyp)
        self.collection(**collect,name=name)


    # SCATTER -------------------------------
    def scatter(self,
                 E,
                 name=&#34;emulsion&#34;,
                 beadtype=None,
                 ismask = False
                 ):
        &#34;&#34;&#34;


        Parameters
        ----------
        E : scatter or emulsion object
            codes for x,y and r.
        name : string, optional
            name of the collection. The default is &#34;emulsion&#34;.
        beadtype : integer, optional
            for all objects. The default is 1.
        ismask : logical, optional
            Set it to true to force a mask. The default is False.

        Raises
        ------
        TypeError
            Return an error of the object is not a scatter type.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if isinstance(E,scatter):
            collect = {}
            for i in range(E.n):
                b = E.beadtype[i] if beadtype==None else beadtype
                nameobj = &#34;glob%02d&#34; % i
                collect[nameobj] = self.circle(E.x[i],E.y[i],E.r[i],
                            name=nameobj,beadtype=b,ismask=ismask,fake=True)
            self.collection(**collect,name=name)
        else:
            raise TypeError(&#34;the first argument must be an emulsion object&#34;)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="raster.raster.max"><code class="name">var <span class="ident">max</span></code></dt>
<dd>
<div class="desc"><p>max bead type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max(self):
    &#34;&#34;&#34; max bead type &#34;&#34;&#34;
    typlist = []
    for  o in self.names():
        if isinstance(self.objects[o].beadtype,list):
            typlist += self.objects[o].beadtype
        else:
            typlist.append(self.objects[o].beadtype)
    return max(typlist)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.raster.circle"><code class="name flex">
<span>def <span class="ident">circle</span></span>(<span>self, xc, yc, radius, name=None, shaperatio=1, angle=0, beadtype=None, ismask=False, resolution=20, shiftangle=0, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>circle object (or any regular polygon)
circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
use circle(&hellip;,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle(self,xc,yc,radius,
              name=None,shaperatio=1,angle=0,beadtype=None,ismask=False,
              resolution=20,shiftangle=0,fake=False,beadtype2=None):
    &#34;&#34;&#34;
    circle object (or any regular polygon)
        circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
        use circle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
    &#34;&#34;&#34;
    # object creation
    self.counter[&#34;all&#34;] += 1
    if resolution==3:
        typ = &#34;triangle&#34;
        self.counter[&#34;triangle&#34;] += 1
        G = Triangle((self.counter[&#34;all&#34;],self.counter[&#34;triangle&#34;]))
    elif resolution==4:
        typ = &#34;diamond&#34;
        self.counter[&#34;diamond&#34;] += 1
        G = Diamond((self.counter[&#34;all&#34;],self.counter[&#34;diamond&#34;]))
    elif resolution==5:
        typ = &#34;pentagon&#34;
        self.counter[&#34;pentagon&#34;] += 1
        G = Pentagon((self.counter[&#34;all&#34;],self.counter[&#34;pentagon&#34;]))
    elif resolution==6:
        typ = &#34;hexagon&#34;
        self.counter[&#34;hexagon&#34;] += 1
        G = Hexagon((self.counter[&#34;all&#34;],self.counter[&#34;hexagon&#34;]))
    else:
        typ = &#34;circle&#34;
        self.counter[&#34;circle&#34;] += 1
        G = Circle((self.counter[&#34;all&#34;],self.counter[&#34;circle&#34;]),resolution=resolution)
    if (name != None) and (name != &#34;&#34;):
        if self.exist(name):
            print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
            self.delete(name)
        G.name = name
    else:
        name = G.name
    if beadtype is not None: G.beadtype = int(np.floor(beadtype))
    if beadtype2 is not None:
        if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
            raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
    G.beadtype2 = beadtype2
    if ismask: G.beadtype = 0
    G.ismask = G.beadtype==0
    # build vertices
    th = np.linspace(0,2*np.pi,G.resolution+1) +shiftangle*np.pi/180
    xgen = xc + radius * np.cos(th)
    ygen = yc + radius * shaperatio * np.sin(th)
    G.xcenter0, G.ycenter0, G.radius = xc, yc, radius
    G.vertices, G.codes = [], []
    for i in range(G.resolution+1):
        G.vertices.append(_rotate(xgen[i],ygen[i],xc,yc,angle))
        if i==0:
            G.codes.append(path.Path.MOVETO)
        elif i==G.resolution:
            G.codes.append(path.Path.CLOSEPOLY)
        else:
            G.codes.append(path.Path.LINETO)
    G.nvertices = len(G.vertices)-1
    # build path object and range
    G.xmin0, G.ymin0, G.xmax0, G.ymax0 = G.corners()
    G.xmin0, G.ymin0 = self.valid(G.xmin0,G.ymin0)
    G.xmax0, G.ymax0 = self.valid(G.xmax0,G.ymax0)
    G.angle, G.shaperatio = angle, shaperatio
    # store the object
    if fake:
        self.counter[&#34;all&#34;] -= 1
        self.counter[typ] -= 1
        return G
    else:
        self.objects[name] = G
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="raster.raster.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, what='nothing')</span>
</code></dt>
<dd>
<div class="desc"><p>clear the plotting area, use clear("all")) to remove all objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self,what=&#34;nothing&#34;):
    &#34;&#34;&#34; clear the plotting area, use clear(&#34;all&#34;)) to remove all objects &#34;&#34;&#34;
    self.imbead = np.zeros((self.height,self.width),dtype=np.int8)
    self.imobj = np.zeros((self.height,self.width),dtype=np.int8)
    for o in self.names():
        if what==&#34;all&#34;:
            self.delete(o)
        else:
            self.objects[o].isplotted = False
            self.objects[o].islabelled = False
            if not self.objects[o].ismask:
                self.nbeads -= self.objects[o].nbeads
            self.objects[o].nbeads = 0  # number of beads (plotted)
    self.figure()
    plt.cla()
    self.show()</code></pre>
</details>
</dd>
<dt id="raster.raster.collection"><code class="name flex">
<span>def <span class="ident">collection</span></span>(<span>self, *obj, name=None, beadtype=None, ismask=None, translate=[0.0, 0.0], fake=False, **kwobj)</span>
</code></dt>
<dd>
<div class="desc"><p>collection of objects:
collection(draftraster,name="mycollect" [,beadtype=1,ismask=True]
collection(name="mycollect",newobjname1 = obj1, newobjname2 = obj2&hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collection(self,*obj,
               name=None,
               beadtype=None,
               ismask=None,
               translate = [0.0,0.0],
               fake = False,
               **kwobj):
    &#34;&#34;&#34;
        collection of objects:
            collection(draftraster,name=&#34;mycollect&#34; [,beadtype=1,ismask=True]
            collection(name=&#34;mycollect&#34;,newobjname1 = obj1, newobjname2 = obj2...)
    &#34;&#34;&#34;
    self.counter[&#34;all&#34;] += 1
    self.counter[&#34;collection&#34;] += 1
    C = Collection((self.counter[&#34;all&#34;],self.counter[&#34;collection&#34;]))
    # name
    if name != None:
        if self.exist(name):
            print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
            self.delete(name)
        C.name = name
    else:
        name = C.name
    # build the collection
    C.collection = collection(*obj,**kwobj)
    xmin = ymin = +1e99
    xmax = ymax = -1e99
    # apply modifications (beadtype, ismask)
    for o in C.collection.keys():
        tmp = C.collection.getattr(o)
        tmp.translate[0] += translate[0]
        tmp.translate[1] += translate[1]
        xmin, xmax = min(xmin,tmp.xmin), max(xmax,tmp.xmax)
        ymin, ymax = min(ymin,tmp.ymin), max(ymax,tmp.ymax)
        if beadtype != None: tmp.beadtype = beadtype
        if ismask != None: tmp.ismask = ismask
        C.collection.setattr(o,tmp)
    C.xmin, C.xmax, C.ymin, C.ymax = xmin, xmax, ymin, ymax
    C.width, C.height = xmax-xmin, ymax-ymin
    if fake:
        return C
    else:
        self.objects[name] = C
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="raster.raster.copyalongpath"><code class="name flex">
<span>def <span class="ident">copyalongpath</span></span>(<span>self, obj, name='path', beadtype=None, path=&lt;function linear&gt;, xmin=10, ymin=10, xmax=70, ymax=90, n=7, USER=structure (struct object) with 0 fields)</span>
</code></dt>
<dd>
<div class="desc"><p>The method enable to copy an existing object (from the current raster,
from another raster or a fake object) amp,g</p>
<p>Parameters</p>
<hr>
<p>obj : real or fake object
the object to be copied.
name : string, optional
the name of the object collection. The default is "path".
beadtype : integet, optional
type of bead (can override existing value). The default is None.
path : function, optional
parametric function returning x,y. The default is linear.
x is between xmin and xmax, and y between ymin, ymax
xmin : int64 or float, optional
left x corner position. The default is 10.
ymin : int64 or float, optional
bottom y corner position. The default is 10.
xmax : int64 or float, optional
right x corner position. The default is 70.
ymax : int64 or float, optional
top y corner position. The default is 90.
n : integet, optional
number of copies. The default is 7.
USER : structure to pass specific parameters</p>
<p>Returns</p>
<hr>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copyalongpath(self,obj,
                  name=&#34;path&#34;,
              beadtype=None,
                  path=linear,
                  xmin=10,
                  ymin=10,
                  xmax=70,
                  ymax=90,
                     n=7,
                  USER=struct()):
    &#34;&#34;&#34;

    The method enable to copy an existing object (from the current raster,
    from another raster or a fake object) amp,g

    Parameters
    ----------
    obj : real or fake object
        the object to be copied.
    name : string, optional
        the name of the object collection. The default is &#34;path&#34;.
    beadtype : integet, optional
        type of bead (can override existing value). The default is None.
    path : function, optional
        parametric function returning x,y. The default is linear.
        x is between xmin and xmax, and y between ymin, ymax
    xmin : int64 or float, optional
        left x corner position. The default is 10.
    ymin : int64 or float, optional
        bottom y corner position. The default is 10.
    xmax : int64 or float, optional
        right x corner position. The default is 70.
    ymax : int64 or float, optional
        top y corner position. The default is 90.
    n : integet, optional
        number of copies. The default is 7.
 USER : structure to pass specific parameters

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if not isinstance(USER,struct):
        raise TypeError(&#34;USER should be a structure&#34;)
    x,y = path(xmin=xmin,ymin=ymin,xmax=xmax,ymax=ymax,n=n,USER=USER)
    btyp = obj.beadtype if beadtype == None else beadtype
    collect = {}
    for i in range(n):
        nameobj = &#34;%s_%s_%02d&#34; % (name,obj.name,i)
        x[i], y[i] = self.valid(x[i], y[i])
        translate = [ x[i]-obj.xcenter, y[i]-obj.ycenter ]
        collect[nameobj] = obj.copy(translate=translate,
                                    name=nameobj,
                                    beadtype=btyp)
    self.collection(**collect,name=name)</code></pre>
</details>
</dd>
<dt id="raster.raster.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>count objects by type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self):
    &#34;&#34;&#34; count objects by type &#34;&#34;&#34;
    typlist = []
    for  o in self.names():
        if isinstance(self.objects[o].beadtype,list):
            typlist += self.objects[o].beadtype
        else:
            typlist.append(self.objects[o].beadtype)
    utypes = list(set(typlist))
    c = []
    for t in utypes:
        c.append((t,typlist.count(t)))
    return c</code></pre>
</details>
</dd>
<dt id="raster.raster.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>self, scale=(1, 1), center=(0, 0), maxtype=None, hexpacking=None)</span>
</code></dt>
<dd>
<div class="desc"><p>return a pizza.data object
data()
data(scale=(scalex,scaley),
center=(centerx,centery),
maxtype=number,
hexpacking=(0.5,0))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data(self,scale=(1,1),center=(0,0),maxtype=None,hexpacking=None):
    &#34;&#34;&#34;
        return a pizza.data object
            data()
            data(scale=(scalex,scaley),
                 center=(centerx,centery),
                 maxtype=number,
                 hexpacking=(0.5,0))
    &#34;&#34;&#34;
    if not isinstance(scale,tuple) or len(scale)!=2:
        raise ValueError(&#34;scale must be tuple (scalex,scaley)&#34;)
    if not isinstance(center,tuple) or len(scale)!=2:
        raise ValueError(&#34;center must be tuple (centerx,centery)&#34;)
    scalez = np.sqrt(scale[0]*scale[1])
    scalevol = scale[0]*scale[1] #*scalez
    maxtypeheader = self.count()[-1][0] if maxtype is None else maxtype
    n = self.length()
    i,j = self.imbead.nonzero() # x=j+0.5 y=i+0.5
    x = (j+0.5-center[0])*scale[0]
    y = (i+0.5-center[1])*scale[1]
    if hexpacking is not None:
        if isinstance(hexpacking,tuple) and len(hexpacking)==2:
            for k in range(len(i)):
                if i[k] % 2:
                    x[k] = (j[k]+0.5+hexpacking[1]-center[0])*scale[0]
                else:
                    x[k] = (j[k]+0.5+hexpacking[0]-center[0])*scale[0]
        else:
            raise ValueError(&#34;hexpacking should be a tuple (shiftodd,shifteven)&#34;)
    X = data3()  # empty pizza.data3.data object
    X.title = self.name + &#34;(raster)&#34;
    X.headers = {&#39;atoms&#39;: n,
                  &#39;atom types&#39;: maxtypeheader,
                  &#39;xlo xhi&#39;: ((0.0-center[0])*scale[0], (self.width-0.0-center[0])*scale[0]),
                  &#39;ylo yhi&#39;: ((0.0-center[1])*scale[1], (self.height-0.0-center[1])*scale[1]),
                  &#39;zlo zhi&#39;: (0, scalez)}
    # [ATOMS] section
    X.append(&#39;Atoms&#39;,list(range(1,n+1)),True,&#34;id&#34;)       # id
    X.append(&#39;Atoms&#39;,self.imbead[i,j],True,&#34;type&#34;)       # Type
    X.append(&#39;Atoms&#39;,1,True,&#34;mol&#34;)                       # mol
    X.append(&#39;Atoms&#39;,self.volume*scalevol,False,&#34;c_vol&#34;) # c_vol
    X.append(&#39;Atoms&#39;,self.mass*scalevol,False,&#34;mass&#34;)    # mass
    X.append(&#39;Atoms&#39;,self.radius*scalez,False,&#34;radius&#34;)         # radius
    X.append(&#39;Atoms&#39;,self.contactradius*scalez,False,&#34;c_contact_radius&#34;) # c_contact_radius
    X.append(&#39;Atoms&#39;,x,False,&#34;x&#34;)        # x
    X.append(&#39;Atoms&#39;,y,False,&#34;y&#34;)        # y
    X.append(&#39;Atoms&#39;,0,False,&#34;z&#34;)        # z
    X.append(&#39;Atoms&#39;,x,False,&#34;x0&#34;)       # x0
    X.append(&#39;Atoms&#39;,y,False,&#34;y0&#34;)       # y0
    X.append(&#39;Atoms&#39;,0,False,&#34;z0&#34;)       # z0
    # [VELOCITIES] section
    X.append(&#39;Velocities&#39;,list(range(1,n+1)),True,&#34;id&#34;) # id
    X.append(&#39;Velocities&#39;,self.velocities[0],False,&#34;vx&#34;) # vx
    X.append(&#39;Velocities&#39;,self.velocities[1],False,&#34;vy&#34;) # vy
    X.append(&#39;Velocities&#39;,self.velocities[2],False,&#34;vz&#34;) # vz
    # pseudo-filename
    X.flist = self.filename
    return X</code></pre>
</details>
</dd>
<dt id="raster.raster.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>delete object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self,name):
    &#34;&#34;&#34; delete object &#34;&#34;&#34;
    if name in self.objects:
        if not self.objects[name].ismask:
            self.nbeads -= self.objects[name].nbeads
        del self.objects[name]
        self.nobjects -= 1
    else:
        raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)
    self.clear()
    self.plot()
    self.show(extra=&#34;label&#34;)</code></pre>
</details>
</dd>
<dt id="raster.raster.diamond"><code class="name flex">
<span>def <span class="ident">diamond</span></span>(<span>self, xc, yc, radius, name=None, shaperatio=1, angle=0, beadtype=None, ismask=False, shiftangle=0, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>diamond object
diamond(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
use diamond(&hellip;,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diamond(self,xc,yc,radius,name=None,
             shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
    &#34;&#34;&#34;
    diamond object
        diamond(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
        use diamond(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
    &#34;&#34;&#34;
    self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=4,
        angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)</code></pre>
</details>
</dd>
<dt id="raster.raster.exist"><code class="name flex">
<span>def <span class="ident">exist</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>exist object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exist(self,name):
    &#34;&#34;&#34; exist object &#34;&#34;&#34;
    return name in self.objects</code></pre>
</details>
</dd>
<dt id="raster.raster.figure"><code class="name flex">
<span>def <span class="ident">figure</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>set the current figure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def figure(self):
    &#34;&#34;&#34; set the current figure &#34;&#34;&#34;
    if self.hfig==[] or not plt.fignum_exists(self.hfig.number):
        self.newfigure()
    plt.figure(self.hfig.number)</code></pre>
</details>
</dd>
<dt id="raster.raster.frameobj"><code class="name flex">
<span>def <span class="ident">frameobj</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>frame coordinates by taking into account translation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frameobj(self,obj):
    &#34;&#34;&#34; frame coordinates by taking into account translation &#34;&#34;&#34;
    if obj.hasclosefit:
        envelope = 0
    else:
        envelope = 1
    xmin, ymin = self.valid(obj.xmin-envelope, obj.ymin-envelope)
    xmax, ymax = self.valid(obj.xmax+envelope, obj.ymax+envelope)
    return xmin, ymin, xmax, ymax</code></pre>
</details>
</dd>
<dt id="raster.raster.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self,name):
    &#34;&#34;&#34; returns the object &#34;&#34;&#34;
    if name in self.objects:
        return self.objects[name]
    else:
        raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)</code></pre>
</details>
</dd>
<dt id="raster.raster.hexagon"><code class="name flex">
<span>def <span class="ident">hexagon</span></span>(<span>self, xc, yc, radius, name=None, shaperatio=1, angle=0, beadtype=None, ismask=False, shiftangle=0, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>hexagon object
hexagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
use hexagon(&hellip;,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hexagon(self,xc,yc,radius,name=None,
             shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
    &#34;&#34;&#34;
    hexagon object
        hexagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
        use hexagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
    &#34;&#34;&#34;
    self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=6,
        angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)</code></pre>
</details>
</dd>
<dt id="raster.raster.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>self, name, **fmt)</span>
</code></dt>
<dd>
<div class="desc"><p>label:
label(name [, contour=True,edgecolor="orange",facecolor="none",linewidth=2, ax=plt.gca()])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label(self,name,**fmt):
    &#34;&#34;&#34;
        label:
            label(name [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
    &#34;&#34;&#34;
    self.figure()
    if name in self.objects:
        if not self.objects[name].islabelled:
            if self.objects[name].alike == &#34;mixed&#34;:
                for o in self.objects[name].collection:
                    self.labelobj(o,**fmt)
            else:
                self.labelobj(self.objects[name],**fmt)
            plt.show()
            self.objects[name].islabelled = True
    else:
        raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)</code></pre>
</details>
</dd>
<dt id="raster.raster.labelobj"><code class="name flex">
<span>def <span class="ident">labelobj</span></span>(<span>self, obj, contour=True, edgecolor='orange', facecolor='none', linewidth=2, ax=&lt;Axes: &gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>labelobj:
labelobj(obj [, contour=True,edgecolor="orange",facecolor="none",linewidth=2, ax=plt.gca()])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def labelobj(self,obj,contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2,ax=plt.gca()):
    &#34;&#34;&#34;
        labelobj:
            labelobj(obj [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
    &#34;&#34;&#34;
    if contour: contour = obj.hascontour # e.g. overlays do not have contour

    if contour:
        patch = patches.PathPatch(obj.polygon2plot,
                                  facecolor=facecolor,
                                  edgecolor=edgecolor,
                                  lw=linewidth)
        obj.hlabel[&#34;contour&#34;] = ax.add_patch(patch)
    else:
        obj.hlabel[&#34;contour&#34;] = None
    obj.hlabel[&#34;text&#34;] = \
    plt.text(obj.xcenter,
             obj.ycenter,
             &#34;%s\n(t=$%d$,$n_p$=%d)&#34; % (obj.name, obj.beadtype,obj.nbeads),
             horizontalalignment = &#34;center&#34;,
             verticalalignment = &#34;center_baseline&#34;,
             fontsize=self.fontsize
             )</code></pre>
</details>
</dd>
<dt id="raster.raster.length"><code class="name flex">
<span>def <span class="ident">length</span></span>(<span>self, t=None, what='beadtype')</span>
</code></dt>
<dd>
<div class="desc"><p>returns the total number of beads length(type,"beadtype")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length(self,t=None,what=&#34;beadtype&#34;):
    &#34;&#34;&#34; returns the total number of beads length(type,&#34;beadtype&#34;) &#34;&#34;&#34;
    if what == &#34;beadtype&#34;:
        num = self.imbead
    elif what == &#34;objindex&#34;:
        num = self.imobj
    else:
        raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
    if t==None:
        return np.count_nonzero(num&gt;0)
    else:
        return np.count_nonzero(num==t)</code></pre>
</details>
</dd>
<dt id="raster.raster.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>list objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self):
    &#34;&#34;&#34; list objects &#34;&#34;&#34;
    fmt = &#34;%%%ss:&#34; % max(10,max([len(n) for n in self.names()])+2)
    print(&#34;RASTER with %d objects&#34; % self.nobjects)
    for o in self.objects.keys():
        print(fmt % self.objects[o].name,&#34;%-10s&#34; % self.objects[o].kind,
              &#34;(beadtype=%d,object index=[%d,%d], n=%d)&#34; % \
                  (self.objects[o].beadtype,
                   self.objects[o].index,
                   self.objects[o].subindex,
                   self.objects[o].nbeads))</code></pre>
</details>
</dd>
<dt id="raster.raster.names"><code class="name flex">
<span>def <span class="ident">names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the names of objects sorted as index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def names(self):
    &#34;&#34;&#34; return the names of objects sorted as index &#34;&#34;&#34;
    namesunsorted=namessorted=list(self.objects.keys())
    nobj = len(namesunsorted)
    for iobj in range(nobj):
        namessorted[self.objects[namesunsorted[iobj]].index-1] = namesunsorted[iobj]
    return namessorted</code></pre>
</details>
</dd>
<dt id="raster.raster.newfigure"><code class="name flex">
<span>def <span class="ident">newfigure</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create a new figure (dpi=200)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newfigure(self):
    &#34;&#34;&#34; create a new figure (dpi=200) &#34;&#34;&#34;
    self.hfig = plt.figure(dpi=self.dpi)</code></pre>
</details>
</dd>
<dt id="raster.raster.numeric"><code class="name flex">
<span>def <span class="ident">numeric</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>retrieve the image as a numpy.array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric(self):
    &#34;&#34;&#34; retrieve the image as a numpy.array &#34;&#34;&#34;
    return self.imbead, self.imobj</code></pre>
</details>
</dd>
<dt id="raster.raster.overlay"><code class="name flex">
<span>def <span class="ident">overlay</span></span>(<span>self, x0, y0, name=None, filename=None, color=1, colormax=None, ncolors=4, beadtype=None, beadtype2=None, ismask=False, fake=False, flipud=True, angle=0, scale=(1, 1))</span>
</code></dt>
<dd>
<div class="desc"><p>overlay object: made from an image converted to nc colors
the object is made from the level ranged between ic and jc (bounds included)
note: if palette found, no conversion is applied</p>
<p>O = overlay(x0,y0,filename="/this/is/my/image.png",ncolors=nc,color=ic,colormax=jc,beadtype=b)
O = overlay(&hellip;angle=0,scale=(1,1)) to induce rotation and change of scale
O = overlay(....ismask=False,fake=False)</p>
<p>note use overlay(&hellip;flipud=False) to prevent image fliping (standard)</p>
<h2 id="outputs">Outputs</h2>
<p>O.original original image (PIL)
O.raw image converted to ncolors if needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlay(self,x0,y0,
            name = None,
            filename = None,
            color = 1,
            colormax = None,
            ncolors = 4,
            beadtype = None,
            beadtype2 = None,
            ismask = False,
            fake = False,
            flipud = True,
            angle = 0,
            scale= (1,1)
            ):
    &#34;&#34;&#34;
        overlay object: made from an image converted to nc colors
        the object is made from the level ranged between ic and jc (bounds included)
        note: if palette found, no conversion is applied

        O = overlay(x0,y0,filename=&#34;/this/is/my/image.png&#34;,ncolors=nc,color=ic,colormax=jc,beadtype=b)
        O = overlay(...angle=0,scale=(1,1)) to induce rotation and change of scale
        O = overlay(....ismask=False,fake=False)

        note use overlay(...flipud=False) to prevent image fliping (standard)

        Outputs:
            O.original original image (PIL)
            O.raw image converted to ncolors if needed

    &#34;&#34;&#34;
    if filename is None or filename==&#34;&#34;:
        raise ValueError(&#34;filename is required (valid image)&#34;)
    O = overlay(counter=(self.counter[&#34;all&#34;]+1,self.counter[&#34;overlay&#34;]+1),
                filename = filename,
                xmin = x0,
                ymin = y0,
                ncolors = ncolors,
                flipud = flipud,
                angle = angle,
                scale = scale
                )
    O.select(color=color, colormax=colormax)
    if (name is not None) and (name !=&#34;&#34;):
        if self.exist(name):
            print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
            self.delete(name)
        O.name = name
    else:
        name = O.name
    if beadtype is not None: O.beadtype = int(np.floor(beadtype))
    if beadtype2 is not None:
        if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
            raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
    O.beadtype2 = beadtype2
    if ismask: O.beadtype = 0
    O.ismask = O.beadtype==0
    self.counter[&#34;all&#34;] += 1
    self.counter[&#34;overlay&#34;] += 1
    if fake:
        self.counter[&#34;all&#34;] -= 1
        self.counter[&#34;overlay&#34;] -= 1
        return O
    else:
        self.objects[name] = O
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="raster.raster.pentagon"><code class="name flex">
<span>def <span class="ident">pentagon</span></span>(<span>self, xc, yc, radius, name=None, shaperatio=1, angle=0, beadtype=None, ismask=False, shiftangle=0, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>pentagon object
pentagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
use pentagon(&hellip;,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pentagon(self,xc,yc,radius,name=None,
             shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
    &#34;&#34;&#34;
    pentagon object
        pentagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
        use pentagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
    &#34;&#34;&#34;
    self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=5,
        angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)</code></pre>
</details>
</dd>
<dt id="raster.raster.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>plot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):
    &#34;&#34;&#34; plot &#34;&#34;&#34;
    for o in self.objects:
        if not self.objects[o].isplotted:
            if self.objects[o].alike == &#34;mixed&#34;:
                for o2 in self.objects[o].collection:
                    self.plotobj(o2)
            else:
                self.plotobj(self.objects[o])
            # store it as plotted
            self.objects[o].isplotted = True
            if not self.objects[o].ismask:
                self.nbeads += self.objects[o].nbeads</code></pre>
</details>
</dd>
<dt id="raster.raster.plotobj"><code class="name flex">
<span>def <span class="ident">plotobj</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>plotobj(obj)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotobj(self,obj):
    &#34;&#34;&#34; plotobj(obj) &#34;&#34;&#34;
    if obj.alike == &#34;circle&#34;:
        xmin, ymin, xmax, ymax = self.frameobj(obj)
        j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
        points = np.vstack((j.flatten(),i.flatten())).T
        npoints = points.shape[0]
        inside = obj.polygon.contains_points(points)
        if obj.beadtype2 is None:          # -- no salting --
            for k in range(npoints):
                if inside[k] and \
                    points[k,0]&gt;=0 and \
                    points[k,0]&lt;self.width and \
                    points[k,1]&gt;=0 and \
                    points[k,1]&lt;self.height:
                        self.imbead[points[k,1],points[k,0]] = obj.beadtype
                        self.imobj[points[k,1],points[k,0]] = obj.index
                        obj.nbeads += 1
        else:
            for k in range(npoints):       # -- salting --
                if inside[k] and \
                    points[k,0]&gt;=0 and \
                    points[k,0]&lt;self.width and \
                    points[k,1]&gt;=0 and \
                    points[k,1]&lt;self.height:
                        if np.random.rand()&lt;obj.beadtype2[1]:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                        else:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                        self.imobj[points[k,1],points[k,0]] = obj.index
                        obj.nbeads += 1

    elif obj.alike == &#34;overlay&#34;:
        xmin, ymin, xmax, ymax = self.frameobj(obj)
        j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
        points = np.vstack((j.flatten(),i.flatten())).T
        npoints = points.shape[0]
        inside = obj.select()
        if obj.beadtype2 is None:          # -- no salting --
            for k in range(npoints):
                if inside[ points[k,1]-ymin, points[k,0]-xmin ] and \
                    points[k,0]&gt;=0 and \
                    points[k,0]&lt;self.width and \
                    points[k,1]&gt;=0 and \
                    points[k,1]&lt;self.height:
                        self.imbead[points[k,1],points[k,0]] = obj.beadtype
                        self.imobj[points[k,1],points[k,0]] = obj.index
                        obj.nbeads += 1
        else:
            for k in range(npoints):       # -- salting --
                if inside[ points[k,0]-ymin, points[k,0]-xmin ] and \
                    points[k,0]&gt;=0 and \
                    points[k,0]&lt;self.width and \
                    points[k,1]&gt;=0 and \
                    points[k,1]&lt;self.height:
                        if np.random.rand()&lt;obj.beadtype2[1]:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                        else:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                        self.imobj[points[k,1],points[k,0]] = obj.index
                        obj.nbeads += 1

    else:
        raise ValueError(&#34;This object type is notimplemented&#34;)</code></pre>
</details>
</dd>
<dt id="raster.raster.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, what='beadtype')</span>
</code></dt>
<dd>
<div class="desc"><p>print method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self,what=&#34;beadtype&#34;):
    &#34;&#34;&#34; print method &#34;&#34;&#34;
    txt = self.string(what=what)
    for i in range(len(txt)):
        print(txt[i],end=&#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="raster.raster.rectangle"><code class="name flex">
<span>def <span class="ident">rectangle</span></span>(<span>self, a, b, c, d, mode='lowerleft', name=None, angle=0, beadtype=None, ismask=False, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>rectangle object
rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode="lower", angle=0, ismask=False])
rectangle(xcenter,ycenter,width,height [, beadtype=1,mode="center", angle=0, ismask=False])</p>
<pre><code>use rectangle(...,beadtype2=(type,ratio)) to salt an object with beads
from another type and with a given ratio
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rectangle(self,a,b,c,d,
              mode=&#34;lowerleft&#34;,name=None,angle=0,
              beadtype=None,ismask=False,fake=False,beadtype2=None):
    &#34;&#34;&#34;
    rectangle object
        rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode=&#34;lower&#34;, angle=0, ismask=False])
        rectangle(xcenter,ycenter,width,height [, beadtype=1,mode=&#34;center&#34;, angle=0, ismask=False])

        use rectangle(...,beadtype2=(type,ratio)) to salt an object with beads
        from another type and with a given ratio
    &#34;&#34;&#34;
    # object creation
    self.counter[&#34;all&#34;] += 1
    self.counter[&#34;rectangle&#34;] += 1
    R = Rectangle((self.counter[&#34;all&#34;],self.counter[&#34;rectangle&#34;]))
    if (name != None) and (name != &#34;&#34;):
        if self.exist(name):
            print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
            self.delete(name)
        R.name = name
    else:
        name = R.name
    if beadtype is not None: R.beadtype = int(np.floor(beadtype))
    if beadtype2 is not None:
        if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
            raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
    R.beadtype2 = beadtype2
    if ismask: R.beadtype = 0
    R.ismask = R.beadtype==0
    # build vertices
    if mode == &#34;lowerleft&#34;:
        R.xcenter0 = (a+b)/2
        R.ycenter0 = (c+d)/2
        R.vertices = [
            _rotate(a,c,R.xcenter0,R.ycenter0,angle),
            _rotate(b,c,R.xcenter0,R.ycenter0,angle),
            _rotate(b,d,R.xcenter0,R.ycenter0,angle),
            _rotate(a,d,R.xcenter0,R.ycenter0,angle),
            _rotate(a,c,R.xcenter0,R.ycenter0,angle)
            ] # anti-clockwise, closed (last point repeated)
    elif mode == &#34;center&#34;:
        R.xcenter0 = a
        R.ycenter0 = b
        R.vertices = [
            _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
            _rotate(a+c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
            _rotate(a+c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
            _rotate(a-c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
            _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle)
            ]
    else:
        raise ValueError(&#39;&#34;%s&#34; is not a recognized mode, use &#34;lowerleft&#34; (default) and &#34;center&#34; instead&#39;)
    # build path object and range
    R.codes =    [ path.Path.MOVETO,
                 path.Path.LINETO,
                 path.Path.LINETO,
                 path.Path.LINETO,
                 path.Path.CLOSEPOLY
                ]
    R.nvertices = len(R.vertices)-1
    R.xmin0, R.ymin0, R.xmax0, R.ymax0 = R.corners()
    R.xmin0, R.ymin0 = self.valid(R.xmin0,R.ymin0)
    R.xmax0, R.ymax0 = self.valid(R.xmax0,R.ymax0)
    R.angle = angle
    # store the object (if not fake)
    if fake:
        self.counter[&#34;all&#34;] -= 1
        self.counter[&#34;rectangle&#34;] -= 1
        return R
    else:
        self.objects[name] = R
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="raster.raster.scatter"><code class="name flex">
<span>def <span class="ident">scatter</span></span>(<span>self, E, name='emulsion', beadtype=None, ismask=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>E</code></strong> :&ensp;<code><a title="raster.scatter" href="#raster.scatter">scatter</a></code> or <code><a title="raster.emulsion" href="#raster.emulsion">emulsion</a> object</code></dt>
<dd>codes for x,y and r.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>name of the collection. The default is "emulsion".</dd>
<dt><strong><code>beadtype</code></strong> :&ensp;<code>integer</code>, optional</dt>
<dd>for all objects. The default is 1.</dd>
<dt><strong><code>ismask</code></strong> :&ensp;<code>logical</code>, optional</dt>
<dd>Set it to true to force a mask. The default is False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Return an error of the object is not a scatter type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatter(self,
             E,
             name=&#34;emulsion&#34;,
             beadtype=None,
             ismask = False
             ):
    &#34;&#34;&#34;


    Parameters
    ----------
    E : scatter or emulsion object
        codes for x,y and r.
    name : string, optional
        name of the collection. The default is &#34;emulsion&#34;.
    beadtype : integer, optional
        for all objects. The default is 1.
    ismask : logical, optional
        Set it to true to force a mask. The default is False.

    Raises
    ------
    TypeError
        Return an error of the object is not a scatter type.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if isinstance(E,scatter):
        collect = {}
        for i in range(E.n):
            b = E.beadtype[i] if beadtype==None else beadtype
            nameobj = &#34;glob%02d&#34; % i
            collect[nameobj] = self.circle(E.x[i],E.y[i],E.r[i],
                        name=nameobj,beadtype=b,ismask=ismask,fake=True)
        self.collection(**collect,name=name)
    else:
        raise TypeError(&#34;the first argument must be an emulsion object&#34;)</code></pre>
</details>
</dd>
<dt id="raster.raster.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, extra='none', contour=True, what='beadtype')</span>
</code></dt>
<dd>
<div class="desc"><p>show method: show(extra="label",contour=True,what="beadtype")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self,extra=&#34;none&#34;,contour=True,what=&#34;beadtype&#34;):
    &#34;&#34;&#34; show method: show(extra=&#34;label&#34;,contour=True,what=&#34;beadtype&#34;) &#34;&#34;&#34;
    self.figure()
    if what==&#34;beadtype&#34;:
        imagesc(self.imbead)
    elif what == &#34;objindex&#34;:
        imagesc(self.imobj)
    else:
        raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
    if extra == &#34;label&#34;:
        ax = plt.gca()
        for o in self.names():
            if not self.objects[o].ismask:
                self.label(o,ax=ax,contour=contour)
        ax.set_title(&#34;raster area: %s \n (n=%d, $n_p$=%d)&#34; %\
                  (self.name,self.length(),self.nbeads) )
        plt.show()</code></pre>
</details>
</dd>
<dt id="raster.raster.string"><code class="name flex">
<span>def <span class="ident">string</span></span>(<span>self, what='beadtype')</span>
</code></dt>
<dd>
<div class="desc"><p>convert the image as ASCII strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string(self,what=&#34;beadtype&#34;):
    &#34;&#34;&#34; convert the image as ASCII strings &#34;&#34;&#34;
    if what == &#34;beadtype&#34;:
        num = np.flipud(duplicate(self.imbead))
    elif what == &#34;objindex&#34;:
        num = np.flipud(duplicate(self.imobj))
    else:
        raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
    num[num&gt;0] = num[num&gt;0] + 65
    num[num==0] = 32
    num = list(num)
    return [&#34;&#34;.join(map(chr,x)) for x in num]</code></pre>
</details>
</dd>
<dt id="raster.raster.torgb"><code class="name flex">
<span>def <span class="ident">torgb</span></span>(<span>self, what='beadtype', thumb=None)</span>
</code></dt>
<dd>
<div class="desc"><p>converts bead raster to image
rgb = raster.torgb(what="beadtype")
thumbnail = raster.torgb(what="beadtype",(128,128))
use: rgb.save("/path/filename.png") for saving</p>
<p>what = "beadtype" or "objindex"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def torgb(self,what=&#34;beadtype&#34;,thumb=None):
    &#34;&#34;&#34; converts bead raster to image
            rgb = raster.torgb(what=&#34;beadtype&#34;)
            thumbnail = raster.torgb(what=&#34;beadtype&#34;,(128,128))
            use: rgb.save(&#34;/path/filename.png&#34;) for saving

        what = &#34;beadtype&#34; or &#34;objindex&#34;
    &#34;&#34;&#34;
    if what==&#34;beadtype&#34;:
        rgb = ind2rgb(self.imbead,ncolors=self.max+1)
    elif what == &#34;objindex&#34;:
        rgb = ind2rgb(self.imobj,ncolors=len(self)+1)
    else:
        raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
    if thumb is not None: rgb.thumbnail(thumb)
    return rgb</code></pre>
</details>
</dd>
<dt id="raster.raster.triangle"><code class="name flex">
<span>def <span class="ident">triangle</span></span>(<span>self, xc, yc, radius, name=None, shaperatio=1, angle=0, beadtype=None, ismask=False, shiftangle=0, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>triangle object
triangle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
use triangle(&hellip;,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle(self,xc,yc,radius,name=None,
             shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
    &#34;&#34;&#34;
    triangle object
        triangle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
        use triangle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
    &#34;&#34;&#34;
    self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=3,
       angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)</code></pre>
</details>
</dd>
<dt id="raster.raster.unlabel"><code class="name flex">
<span>def <span class="ident">unlabel</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>unlabel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unlabel(self,name):
    &#34;&#34;&#34; unlabel &#34;&#34;&#34;
    if name in self.objects:
        if  self.objects[name].islabelled:
            self.objects[name].hlabel[&#34;contour&#34;].remove()
            self.objects[name].hlabel[&#34;text&#34;].remove()
            self.objects[name].hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
            self.objects[name].islabelled = False
    else:
        raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)</code></pre>
</details>
</dd>
<dt id="raster.raster.valid"><code class="name flex">
<span>def <span class="ident">valid</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>validation of coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valid(self,x,y):
    &#34;&#34;&#34; validation of coordinates &#34;&#34;&#34;
    return min(self.width,max(0,round(x))),min(self.height,max(0,round(y)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="raster.scatter"><code class="flex name class">
<span>class <span class="ident">scatter</span></span>
</code></dt>
<dd>
<div class="desc"><p>generic top scatter class </p>
<p>The scatter class provides an easy constructor
to distribute in space objects according to their
positions x,y, size r (radius) and beadtype.</p>
<p>The class is used to derive emulsions.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scatter():
    &#34;&#34;&#34; generic top scatter class &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        The scatter class provides an easy constructor
        to distribute in space objects according to their
        positions x,y, size r (radius) and beadtype.

        The class is used to derive emulsions.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.x = np.array([],dtype=int)
        self.y = np.array([],dtype=int)
        self.r = np.array([],dtype=int)
        self.beadtype = []

    @property
    def n(self):
        return len(self.x)

    def pairdist(self,x,y):
        &#34;&#34;&#34; pair distance to the surface of all disks/spheres &#34;&#34;&#34;
        if self.n==0:
            return np.Inf
        else:
            return np.floor(np.sqrt((x-self.x)**2+(y-self.y)**2)-self.r)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="raster.emulsion" href="#raster.emulsion">emulsion</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="raster.scatter.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    return len(self.x)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.scatter.pairdist"><code class="name flex">
<span>def <span class="ident">pairdist</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>pair distance to the surface of all disks/spheres</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pairdist(self,x,y):
    &#34;&#34;&#34; pair distance to the surface of all disks/spheres &#34;&#34;&#34;
    if self.n==0:
        return np.Inf
    else:
        return np.floor(np.sqrt((x-self.x)**2+(y-self.y)**2)-self.r)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="raster.struct"><code class="flex name class">
<span>class <span class="ident">struct</span></span>
<span>(</span><span>debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-struct">Class: <code><a title="raster.struct" href="#raster.struct">struct</a></code></h1>
<p>A lightweight class that mimics Matlab-like structures, with additional features
such as dynamic field creation, indexing, concatenation, and compatibility with
evaluated parameters (<code>param</code>).</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Dynamic creation of fields.</li>
<li>Indexing and iteration support for fields.</li>
<li>Concatenation and subtraction of structures.</li>
<li>Conversion to and from dictionaries.</li>
<li>Compatible with <code>param</code> and <code>paramauto</code> for evaluation and dependency handling.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic Usage</h4>
<pre><code class="language-python">s = struct(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
print(s.a)  # 1
s.d = 11    # Append a new field
delattr(s, 'd')  # Delete the field
</code></pre>
<h4 id="using-param-for-evaluation">Using <code>param</code> for Evaluation</h4>
<pre><code class="language-python">p = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
p.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-subtraction">Concatenation and Subtraction</h3>
<p>Fields from the right-most structure overwrite existing values.</p>
<pre><code class="language-python">a = struct(a=1, b=2)
b = struct(c=3, d=&quot;d&quot;, e=&quot;e&quot;)
c = a + b
e = c - a
</code></pre>
<hr>
<h3 id="practical-shorthands">Practical Shorthands</h3>
<h4 id="constructing-a-structure-from-keys">Constructing a Structure from Keys</h4>
<pre><code class="language-python">s = struct.fromkeys([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
# Output:
# --------
#      a: None
#      b: None
#      c: None
#      d: None
# --------
</code></pre>
<h4 id="building-a-structure-from-variables-in-a-string">Building a Structure from Variables in a String</h4>
<pre><code class="language-python">s = struct.scan(&quot;${a} + ${b} * ${c} / ${d} --- ${ee}&quot;)
s.a = 1
s.b = &quot;test&quot;
s.c = [1, &quot;a&quot;, 2]
s.generator()
# Output:
# X = struct(
#      a=1,
#      b=&quot;test&quot;,
#      c=[1, 'a', 2],
#      d=None,
#      ee=None
# )
</code></pre>
<h4 id="indexing-and-iteration">Indexing and Iteration</h4>
<p>Structures can be indexed or sliced like lists.</p>
<pre><code class="language-python">c = a + b
c[0]      # Access the first field
c[-1]     # Access the last field
c[:2]     # Slice the structure
for field in c:
    print(field)
</code></pre>
<hr>
<h3 id="dynamic-dependency-management">Dynamic Dependency Management</h3>
<p><code><a title="raster.struct" href="#raster.struct">struct</a></code> provides control over dependencies, sorting, and evaluation.</p>
<pre><code class="language-python">s = struct(d=3, e=&quot;${c} + {d}&quot;, c='${a} + ${b}', a=1, b=2)
s.sortdefinitions()
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}
#      e: ${c} + ${d}
# --------
</code></pre>
<p>For dynamic evaluation, use <code>param</code>:</p>
<pre><code class="language-python">p = param(sortdefinitions=True, d=3, e=&quot;${c} + ${d}&quot;, c='${a} + ${b}', a=1, b=2)
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}  (= 3)
#      e: ${c} + ${d}  (= 6)
# --------
</code></pre>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two structures (<code>__add__</code>).</li>
<li><code>-</code>: Subtraction of fields (<code>__sub__</code>).</li>
<li><code>&lt;&lt;</code>: Import values from another structure (<code>__lshift__</code>)</li>
<li><code>len()</code>: Number of fields (<code>__len__</code>).</li>
<li><code>in</code>: Check for field existence (<code>__contains__</code>).</li>
</ul>
<h4 id="method-overview">Method Overview</h4>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>check(default)</code></td>
<td>Populate fields with defaults if missing.</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>Remove all fields.</td>
</tr>
<tr>
<td><code>dict2struct(dico)</code></td>
<td>Create a structure from a dictionary.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display the structure.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate expressions within fields.</td>
</tr>
<tr>
<td><code>fromkeys(keys)</code></td>
<td>Create a structure from a list of keys.</td>
</tr>
<tr>
<td><code>generator()</code></td>
<td>Generate Python code representing the structure.</td>
</tr>
<tr>
<td><code>importfrom()</code></td>
<td>Import undefined values from another struct or dict.</td>
</tr>
<tr>
<td><code>items()</code></td>
<td>Return key-value pairs.</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>Return all keys in the structure.</td>
</tr>
<tr>
<td><code>read(file)</code></td>
<td>Load structure fields from a file.</td>
</tr>
<tr>
<td><code>scan(string)</code></td>
<td>Extract variables from a string and populate fields.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>struct2dict()</code></td>
<td>Convert the structure to a dictionary.</td>
</tr>
<tr>
<td><code>validkeys()</code></td>
<td>Return valid keys</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>Return all field values.</td>
</tr>
<tr>
<td><code>write(file)</code></td>
<td>Save the structure to a file.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="dynamic-properties">Dynamic Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isempty</code></td>
<td><code>True</code> if the structure is empty.</td>
</tr>
<tr>
<td><code>isdefined</code></td>
<td><code>True</code> if all fields are defined.</td>
</tr>
</tbody>
</table>
<hr>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class struct():
    &#34;&#34;&#34;
    Class: `struct`
    ================

    A lightweight class that mimics Matlab-like structures, with additional features
    such as dynamic field creation, indexing, concatenation, and compatibility with
    evaluated parameters (`param`).

    ---

    ### Features
    - Dynamic creation of fields.
    - Indexing and iteration support for fields.
    - Concatenation and subtraction of structures.
    - Conversion to and from dictionaries.
    - Compatible with `param` and `paramauto` for evaluation and dependency handling.

    ---

    ### Examples

    #### Basic Usage
    ```python
    s = struct(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    print(s.a)  # 1
    s.d = 11    # Append a new field
    delattr(s, &#39;d&#39;)  # Delete the field
    ```

    #### Using `param` for Evaluation
    ```python
    p = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    p.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    # --------
    ```

    ---

    ### Concatenation and Subtraction
    Fields from the right-most structure overwrite existing values.
    ```python
    a = struct(a=1, b=2)
    b = struct(c=3, d=&#34;d&#34;, e=&#34;e&#34;)
    c = a + b
    e = c - a
    ```

    ---

    ### Practical Shorthands

    #### Constructing a Structure from Keys
    ```python
    s = struct.fromkeys([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;])
    # Output:
    # --------
    #      a: None
    #      b: None
    #      c: None
    #      d: None
    # --------
    ```

    #### Building a Structure from Variables in a String
    ```python
    s = struct.scan(&#34;${a} + ${b} * ${c} / ${d} --- ${ee}&#34;)
    s.a = 1
    s.b = &#34;test&#34;
    s.c = [1, &#34;a&#34;, 2]
    s.generator()
    # Output:
    # X = struct(
    #      a=1,
    #      b=&#34;test&#34;,
    #      c=[1, &#39;a&#39;, 2],
    #      d=None,
    #      ee=None
    # )
    ```

    #### Indexing and Iteration
    Structures can be indexed or sliced like lists.
    ```python
    c = a + b
    c[0]      # Access the first field
    c[-1]     # Access the last field
    c[:2]     # Slice the structure
    for field in c:
        print(field)
    ```

    ---

    ### Dynamic Dependency Management
    `struct` provides control over dependencies, sorting, and evaluation.

    ```python
    s = struct(d=3, e=&#34;${c} + {d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    s.sortdefinitions()
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}
    #      e: ${c} + ${d}
    # --------
    ```

    For dynamic evaluation, use `param`:
    ```python
    p = param(sortdefinitions=True, d=3, e=&#34;${c} + ${d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}  (= 3)
    #      e: ${c} + ${d}  (= 6)
    # --------
    ```

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two structures (`__add__`).
    - `-`: Subtraction of fields (`__sub__`).
    - `&lt;&lt;`: Import values from another structure (`__lshift__`)
    - `len()`: Number of fields (`__len__`).
    - `in`: Check for field existence (`__contains__`).

    #### Method Overview
    | Method                | Description                                             |
    |-----------------------|---------------------------------------------------------|
    | `check(default)`      | Populate fields with defaults if missing.               |
    | `clear()`             | Remove all fields.                                      |
    | `dict2struct(dico)`   | Create a structure from a dictionary.                   |
    | `disp()`              | Display the structure.                                  |
    | `eval()`              | Evaluate expressions within fields.                     |
    | `fromkeys(keys)`      | Create a structure from a list of keys.                 |
    | `generator()`         | Generate Python code representing the structure.        |
    | `importfrom()`        | Import undefined values from another struct or dict.    |
    | `items()`             | Return key-value pairs.                                 |
    | `keys()`              | Return all keys in the structure.                       |
    | `read(file)`          | Load structure fields from a file.                      |
    | `scan(string)`        | Extract variables from a string and populate fields.    |
    | `sortdefinitions()`   | Sort fields to resolve dependencies.                    |
    | `struct2dict()`       | Convert the structure to a dictionary.                  |
    | `validkeys()`         | Return valid keys                                       |
    | `values()`            | Return all field values.                                |
    | `write(file)`         | Save the structure to a file.                           |

    ---

    ### Dynamic Properties
    | Property    | Description                            |
    |-------------|----------------------------------------|
    | `isempty`   | `True` if the structure is empty.      |
    | `isdefined` | `True` if all fields are defined.      |

    ---
    &#34;&#34;&#34;

    # attributes to be overdefined
    _type = &#34;struct&#34;        # object type
    _fulltype = &#34;structure&#34; # full name
    _ftype = &#34;field&#34;        # field name
    _evalfeature = False    # true if eval() is available
    _maxdisplay = 40        # maximum number of characters to display (should be even)
    _propertyasattribute = False
    _precision = 4

    # attributes for the iterator method
    # Please keep it static, duplicate the object before changing _iter_
    _iter_ = 0

    # excluded attributes (keep the , in the Tupple if it is singleton)
    _excludedattr = {&#39;_iter_&#39;,&#39;__class__&#39;,&#39;_protection&#39;,&#39;_evaluation&#39;,&#39;_returnerror&#39;,&#39;_debug&#39;,&#39;_precision&#39;} # used by keys() and len()


    # Methods
    def __init__(self,debug=False,**kwargs):
        &#34;&#34;&#34; constructor, use debug=True to report eval errors&#34;&#34;&#34;
        # Optionally extend _excludedattr here
        self._excludedattr = self._excludedattr | {&#39;_excludedattr&#39;, &#39;_type&#39;, &#39;_fulltype&#39;,&#39;_ftype&#39;} # addition 2024-10-11
        self._debug = debug
        self.set(**kwargs)

    def zip(self):
        &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
        return zip(self.keys(),self.values())

    @staticmethod
    def dict2struct(dico,makeparam=False):
        &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
        if isinstance(dico,dict):
            s = param() if makeparam else struct()
            s.set(**dico)
            return s
        raise TypeError(&#34;the argument must be a dictionary&#34;)

    def struct2dict(self):
        &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
        return dict(self.zip())

    def struct2param(self,protection=False,evaluation=True):
        &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
        p = param(**self.struct2dict())
        for i in range(len(self)):
            if isinstance(self[i],pstr): p[i] = pstr(p[i])
        p._protection = protection
        p._evaluation = evaluation
        return p

    def set(self,**kwargs):
        &#34;&#34;&#34; initialization &#34;&#34;&#34;
        self.__dict__.update(kwargs)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value

    def getattr(self,key):
        &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
        if key in self.__dict__:
            return self.__dict__[key]
        elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
             key not in self._excludedattr and \
             key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
            # If _propertyasattribute is True and it&#39;s a property, get its value
            return self.__class__.__dict__[key].fget(self)
        else:
            raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)

    def hasattr(self, key):
        &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
        return key in self.__dict__ or (
            getattr(self, &#39;_propertyasattribute&#39;, False) and
            key not in self._excludedattr and
            key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
        )

    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return pstr.eval(self.getattr(key))

    def __setattr__(self,key,value):
        &#34;&#34;&#34; set attribute override &#34;&#34;&#34;
        self.setattr(key,value)

    def __contains__(self,item):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(item)

    def keys(self):
        &#34;&#34;&#34; return the fields &#34;&#34;&#34;
        # keys() is used by struct() and its iterator
        return [key for key in self.__dict__.keys() if key not in self._excludedattr]

    def keyssorted(self,reverse=True):
        &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
        klist = self.keys()
        l = [len(k) for k in klist]
        return [k for _,k in sorted(zip(l,klist),reverse=reverse)]

    def values(self):
        &#34;&#34;&#34; return the values &#34;&#34;&#34;
        # values() is used by struct() and its iterator
        return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]

    @staticmethod
    def fromkeysvalues(keys,values,makeparam=False):
        &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
            use makeparam = True to create a param instead of struct
        &#34;&#34;&#34;
        if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
        if not isinstance(keys,_list_types): keys = [keys]
        if not isinstance(values,_list_types): values = [values]
        nk,nv = len(keys), len(values)
        s = param() if makeparam else struct()
        if nk&gt;0 and nv&gt;0:
            iv = 0
            for ik in range(nk):
                s.setattr(keys[ik], values[iv])
                iv = min(nv-1,iv+1)
            for ik in range(nk,nv):
                s.setattr(f&#34;key{ik}&#34;, values[ik])
        return s

    def items(self):
        &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
        return self.zip()

    def __getitem__(self,idx):
        &#34;&#34;&#34;
            s[i] returns the ith element of the structure
            s[:4] returns a structure with the four first fields
            s[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.getattr(self.keys()[idx])
            raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            out = struct.fromkeysvalues(self.keys()[idx], self.values()[idx])
            if isinstance(self,paramauto):
                return paramauto(**out)
            elif isinstance(self,param):
                return param(**out)
            else:
                return out
        elif isinstance(idx,(list,tuple)):
            k,v= self.keys(), self.values()
            nk = len(k)
            s = param() if isinstance(self,param) else struct()
            for i in idx:
                if isinstance(i,int):
                    if -nk &lt;= i &lt; nk:  # Allow standard Python negative indexing
                        i = i % nk  # Convert negative index to positive equivalent
                        s.setattr(k[i],v[i])
                    else:
                        raise IndexError(f&#34;idx must contain integers in range [-{nk}, {nk-1}], not {i}&#34;)
                elif isinstance(i,str):
                    if i in self:
                        s.setattr(i, self.getattr(i))
                    else:
                        raise KeyError((f&#39;idx &#34;{idx}&#34; is not a valid key&#39;))
                else:
                    TypeError(&#34;idx must contain only integers or strings&#34;)
            return s
        elif isinstance(idx,str):
            return self.getattr(idx)
        else:
            raise TypeError(&#34;The index must be an integer or a slice and not a %s&#34; % type(idx).__name__)

    def __setitem__(self,idx,value):
        &#34;&#34;&#34; set the ith element of the structure  &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                self.setattr(self.keys()[idx], value)
            else:
                raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            k = self.keys()[idx]
            if len(value)&lt;=1:
                for i in range(len(k)): self.setattr(k[i], value)
            elif len(k) == len(value):
                for i in range(len(k)): self.setattr(k[i], value[i])
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of elements in the slice (%d)&#34; \
                       % (len(value),len(idx)))
        elif isinstance(idx,(list,tuple)):
            if len(value)&lt;=1:
                for i in range(len(idx)): self[idx[i]]=value
            elif len(idx) == len(value):
                for i in range(len(idx)): self[idx[i]]=value[i]
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of indices (%d)&#34; \
                                 % (len(value),len(idx)))

    def __len__(self):
        &#34;&#34;&#34; return the number of fields &#34;&#34;&#34;
        # len() is used by struct() and its iterator
        return len(self.keys())

    def __iter__(self):
        &#34;&#34;&#34; struct iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    def __next__(self):
        &#34;&#34;&#34; increment iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum {self._ftype} iteration reached {len(self)}&#34;)

    def __add__(self, s, sortdefinitions=False, raiseerror=True, silentmode=True):
        &#34;&#34;&#34;
        Add two structure objects, with precedence as follows:

          paramauto &gt; param &gt; struct

        In c = a + b, if b has a higher precedence than a then c will be of b&#39;s class,
        otherwise it will be of a&#39;s class.

        The new instance is created by copying the fields from the left-hand operand (a)
        and then updating with the fields from the right-hand operand (b).
        &#34;&#34;&#34;
        if not isinstance(s, struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)

        # Define a helper to assign a precedence value.
        def get_precedence(obj):
            if isinstance(obj, paramauto):
                return 2
            elif isinstance(obj, param):
                return 1
            elif isinstance(obj, struct):
                return 0
            else:
                return 0  # fallback for unknown derivations

        # Determine which class to use for the duplicate.
        # If s (b) has a higher precedence than self (a), use s&#39;s class; otherwise, use self&#39;s.
        hi_class = self.__class__ if get_precedence(self) &gt;= get_precedence(s) else s.__class__
        # Create a new instance of the chosen class by copying self&#39;s fields.
        dup = hi_class(**self)
        # Update with the fields from s.
        dup.update(**s)
        if sortdefinitions:
            dup.sortdefinitions(raiseerror=raiseerror, silentmode=silentmode)
        return dup

    def __iadd__(self,s,sortdefinitions=False,raiseerror=False, silentmode=True):
        &#34;&#34;&#34; iadd a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        self.update(**s)
        if sortdefinitions: self.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return self

    def __sub__(self,s):
        &#34;&#34;&#34; sub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        listofkeys = dup.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(dup,k)
        return dup

    def __isub__(self,s):
        &#34;&#34;&#34; isub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        listofkeys = self.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(self,k)
        return self

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        if self.__dict__=={}:
            print(f&#34;empty {self._fulltype} ({self._type} object) with no {self._type}s&#34;)
            return f&#34;empty {self._fulltype}&#34;
        else:
            numfmt = f&#34;.{self._precision}g&#34;
            tmp = self.eval() if self._evalfeature else []
            keylengths = [len(key) for key in self.__dict__]
            width = max(10,max(keylengths)+2)
            fmt = &#34;%%%ss:&#34; % width
            fmteval = fmt[:-1]+&#34;=&#34;
            fmtcls =  fmt[:-1]+&#34;:&#34;
            line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
            print(line)
            for key,value in self.__dict__.items():
                if key not in self._excludedattr:
                    if isinstance(value,_numeric_types):
                        # old code (removed on 2025-01-18)
                        # if isinstance(value,pstr):
                        #     print(fmt % key,&#39;p&#34;&#39;+self.dispmax(value)+&#39;&#34;&#39;)
                        # if isinstance(value,str) and value==&#34;&#34;:
                        #     print(fmt % key,&#39;&#34;&#34;&#39;)
                        # else:
                        #     print(fmt % key,self.dispmax(value))
                        if isinstance(value,np.ndarray):
                            print(fmt % key, struct.format_array(value,numfmt=numfmt))
                        else:
                            print(fmt % key,self.dispmax(value))
                    elif isinstance(value,struct):
                        print(fmt % key,self.dispmax(value.__str__()))
                    elif isinstance(value,(type,dict)):
                        print(fmt % key,self.dispmax(str(value)))
                    else:
                        print(fmt % key,type(value))
                        print(fmtcls % &#34;&#34;,self.dispmax(str(value)))
                    if self._evalfeature:
                        if isinstance(self,paramauto):
                            try:
                                if isinstance(value,pstr):
                                    print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                                elif isinstance(value,str):
                                    if value == &#34;&#34;:
                                        print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(tmp.getattr(key)))
                            except Exception as err:
                                print(fmteval % &#34;&#34;,err.message, err.args)
                        else:
                            if isinstance(value,pstr):
                                print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                            elif isinstance(value,str):
                                if value == &#34;&#34;:
                                    print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                else:
                                    calcvalue =tmp.getattr(key)
                                    if isinstance(calcvalue, str) and &#34;error&#34; in calcvalue.lower():
                                        print(fmteval % &#34;&#34;,calcvalue)
                                    else:
                                        if isinstance(calcvalue,np.ndarray):
                                            print(fmteval % &#34;&#34;, struct.format_array(calcvalue,numfmt=numfmt))
                                        else:
                                            print(fmteval % &#34;&#34;,self.dispmax(calcvalue))
                            elif isinstance(value,list):
                                calcvalue =tmp.getattr(key)
                                print(fmteval % &#34;&#34;,self.dispmax(str(calcvalue)))
            print(line)
            return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    def disp(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        self.__repr__()

    def __str__(self):
        return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    @property
    def isempty(self):
        &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
        return len(self)==0

    def clear(self):
        &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
        for k in self.keys(): delattr(self,k)

    def format(self, s, escape=False, raiseerror=True):
        &#34;&#34;&#34;
            Format a string with fields using {field} as placeholders.
            Handles expressions like ${variable1}.

            Args:
                s (str): The input string to format.
                escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
                raiseerror (bool): If True, raises errors for missing fields.

            Note:
                NumPy vectors and matrices are converted into their text representation (default behavior)
                If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

            Returns:
                str: The formatted string.
        &#34;&#34;&#34;
        tmp = self.np2str()
        if raiseerror:
            try:
                if escape:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.format_map(AttrErrorDict(self.__dict__))
                else:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
            except AttributeError as attr_err:
                # Handle AttributeError for expressions with operators
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
                return s_  # Revert to using &#39;${&#39; for unresolved expressions
            except IndexError as idx_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
                raise IndexError from idx_err
            except Exception as other_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                raise RuntimeError from other_err
        else:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except:  # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))

    def format_legacy(self,s,escape=False,raiseerror=True):
        &#34;&#34;&#34;
            format a string with field (use {field} as placeholders)
                s.replace(string), s.replace(string,escape=True)
                where:
                    s is a struct object
                    string is a string with possibly ${variable1}
                    escape is a flag to prevent ${} replaced by {}
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format(**self.__dict__)
                else:
                    return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
            except KeyError as kerr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
                return s_ # instead of s (we put back $) - OV 2023/01/27
            except Exception as othererr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                raise RuntimeError from othererr
        else:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)

    def fromkeys(self,keys):
        &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
        return self+struct(**dict.fromkeys(keys,None))

    @staticmethod
    def scan(s):
        &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
        tmp = struct()
        #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
        found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
        uniq = []
        for x in found:
            if x not in uniq: uniq.append(x)
        return tmp.fromkeys(uniq)

    @staticmethod
    def isstrexpression(s):
        &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        return re.search(r&#34;\$\{.*?\}&#34;,s) is not None

    @property
    def isexpression(self):
        &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        for k,v in self.items():
            if isinstance(v,str):
                s.setattr(k,struct.isstrexpression(v))
            else:
                s.setattr(k,False)
        return s

    @staticmethod
    def isstrdefined(s,ref):
        &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        if struct.isstrexpression(s):
            k = struct.scan(s).keys()
            allfound,i,nk = True,0,len(k)
            while (i&lt;nk) and allfound:
                allfound = k[i] in ref
                i += 1
            return allfound
        else:
            return False


    def isdefined(self,ref=None):
        &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
        nk = len(k)
        if ref is None:
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
                else:
                    s.setattr(k[i],True)
        else:
            if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],ref))
                else:
                    s.setattr(k[i],True)
        return s

    def sortdefinitions(self,raiseerror=True,silentmode=False):
        &#34;&#34;&#34; sortdefintions sorts all definitions
            so that they can be executed as param().
            If any inconsistency is found, an error message is generated.

            Flags = default values
                raiseerror=True show erros of True
                silentmode=False no warning if True
        &#34;&#34;&#34;
        find = lambda xlist: [i for i, x in enumerate(xlist) if x]
        findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
        k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
        istatic = findnot(isexpr)
        idynamic = find(isexpr)
        static = struct.fromkeysvalues(
            [ k[i] for i in istatic ],
            [ v[i] for i in istatic ],
            makeparam = False)
        dynamic = struct.fromkeysvalues(
            [ k[i] for i in idynamic ],
            [ v[i] for i in idynamic ],
            makeparam=False)
        current = static # make static the current structure
        nmissing, anychange, errorfound = len(dynamic), False, False
        while nmissing:
            itst, found = 0, False
            while itst&lt;nmissing and not found:
                teststruct = current + dynamic[[itst]] # add the test field
                found = all(list(teststruct.isdefined()))
                ifound = itst
                itst += 1
            if found:
                current = teststruct # we accept the new field
                dynamic[ifound] = []
                nmissing -= 1
                anychange = True
            else:
                if raiseerror:
                    raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                                   (nmissing,len(self),self._ftype))
                else:
                    if (not errorfound) and (not silentmode):
                        print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                              (nmissing,len(self),self._ftype))
                    current = teststruct # we accept the new field (even if it cannot be interpreted)
                    dynamic[ifound] = []
                    nmissing -= 1
                    errorfound = True
        if anychange:
            self.clear() # reset all fields and assign them in the proper order
            k,v = current.keys(), current.values()
            for i in range(len(k)):
                self.setattr(k[i],v[i])


    def generator(self, printout=False):
        &#34;&#34;&#34;
        Generate Python code of the equivalent structure.

        This method converts the current structure (an instance of `param`, `paramauto`, or `struct`)
        into Python code that, when executed, recreates an equivalent structure. The generated code is
        formatted with one field per line.

        By default (when `printout` is False), the generated code is returned as a raw string that starts
        directly with, for example, `param(` (or `paramauto(` or `struct(`), with no &#34;X = &#34; prefix or leading
        newline. When `printout` is True, the generated code is printed to standard output and includes a prefix
        &#34;X = &#34; to indicate the variable name.

        Parameters:
            printout (bool): If True, the generated code is printed to standard output with the &#34;X = &#34; prefix.
                             If False (default), the code is returned as a raw string starting with, e.g.,
                             `param(`.

        Returns:
            str: The generated Python code representing the structure (regardless of whether it was printed).
        &#34;&#34;&#34;
        nk = len(self)
        tmp = self.np2str()
        # Compute the field format based on the maximum key length (with a minimum width of 10)
        fmt = &#34;%%%ss =&#34; % max(10, max([len(k) for k in self.keys()]) + 2)
        # Determine the appropriate class string for the current instance.
        if isinstance(self, param):
            classstr = &#34;param&#34;
        elif &#39;paramauto&#39; in globals() and isinstance(self, paramauto):
            classstr = &#34;paramauto&#34;
        else:
            classstr = &#34;struct&#34;

        lines = []
        if nk == 0:
            # For an empty structure.
            if printout:
                lines.append(f&#34;X = {classstr}()&#34;)
            else:
                lines.append(f&#34;{classstr}()&#34;)
        else:
            # Header: include &#34;X = &#34; only if printing.
            if printout:
                header = f&#34;X = {classstr}(&#34;
            else:
                header = f&#34;{classstr}(&#34;
            lines.append(header)
            # Iterate over keys to generate each field line.
            for i, k in enumerate(self.keys()):
                v = getattr(self, k)
                if isinstance(v, np.ndarray):
                    vtmp = getattr(tmp, k)
                    field = fmt % k + &#34; &#34; + vtmp
                elif isinstance(v, (int, float)) or v is None:
                    field = fmt % k + &#34; &#34; + str(v)
                elif isinstance(v, str):
                    field = fmt % k + &#34; &#34; + f&#39;&#34;{v}&#34;&#39;
                elif isinstance(v, (list, tuple, dict)):
                    field = fmt % k + &#34; &#34; + str(v)
                else:
                    field = fmt % k + &#34; &#34; + &#34;/* unsupported type */&#34;
                # Append a comma after each field except the last one.
                if i &lt; nk - 1:
                    field += &#34;,&#34;
                lines.append(field)
            # Create a closing line that aligns the closing parenthesis.
            closing_line = fmt[:-1] % &#34;)&#34;
            lines.append(closing_line)
        result = &#34;\n&#34;.join(lines)
        if printout:
            print(result)
            return None
        return result


    # copy and deep copy methpds for the class
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, duplicatedeep(v, memo))
        return copie


    # write a file
    def write(self, file, overwrite=True, mkdir=False):
        &#34;&#34;&#34;
            write the equivalent structure (not recursive for nested struct)
                write(filename, overwrite=True, mkdir=False)

            Parameters:
            - file: The file path to write to.
            - overwrite: Whether to overwrite the file if it exists (default: True).
            - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()

        # Check if the directory exists or if mkdir is set to True, create it
        if mkdir:
            file_path.parent.mkdir(parents=True, exist_ok=True)
        elif not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If overwrite is False and the file already exists, raise an exception
        if not overwrite and file_path.exists():
            raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
        # Convert to static if needed
        if isinstance(p,(param,paramauto)):
            tmp = self.tostatic()
        else:
            tmp = self
        # Open and write to the file using the resolved path
        with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
            print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
            for k, v in tmp.items():
                if v is None:
                    print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
                elif isinstance(v, (int, float)):
                    print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
                elif isinstance(v, str):
                    print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
                else:
                    print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)


    # read a file
    @staticmethod
    def read(file):
        &#34;&#34;&#34;
            read the equivalent structure
                read(filename)

            Parameters:
            - file: The file path to read from.
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()
        # Check if the parent directory exists, otherwise raise an error
        if not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If the file does not exist, raise an exception
        if not file_path.exists():
            raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
        # Open and read the file
        with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            s = struct()  # Assuming struct is defined elsewhere
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                expr = line.split(sep=&#34;=&#34;)
                if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                    lhs = expr[0]
                    rhs = &#34;&#34;.join(expr[1:]).strip()
                    if len(rhs) == 0 or rhs == &#34;None&#34;:
                        v = None
                    else:
                        v = eval(rhs)
                    s.setattr(lhs, v)
        return s

    # argcheck
    def check(self,default):
        &#34;&#34;&#34;
        populate fields from a default structure
            check(defaultstruct)
            missing field, None and [] values are replaced by default ones

            Note: a.check(b) is equivalent to b+a except for [] and None values
        &#34;&#34;&#34;
        if not isinstance(default,struct):
            raise TypeError(&#34;the first argument must be a structure&#34;)
        for f in default.keys():
            ref = default.getattr(f)
            if f not in self:
                self.setattr(f, ref)
            else:
                current = self.getattr(f)
                if ((current is None)  or (current==[])) and \
                    ((ref is not None) and (ref!=[])):
                        self.setattr(f, ref)


    # update values based on key:value
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple fields at once, while protecting certain attributes.

        Parameters:
        -----------
        **kwargs : dict
            The fields to update and their new values.

        Protected attributes defined in _excludedattr are not updated.

        Usage:
        ------
        s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
        &#34;&#34;&#34;
        protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

        for key, value in kwargs.items():
            if key in protected_attributes:
                print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
            else:
                self.setattr(key, value)


    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract a sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            A new instance of the same class as the original, containing
            only the specified keys.

        Usage:
        ------
        sub_struct = s(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        # Create a new instance of the same class
        sub_struct = self.__class__()

        # Get the full type and field type for error messages
        fulltype = getattr(self, &#39;_fulltype&#39;, &#39;structure&#39;)
        ftype = getattr(self, &#39;_ftype&#39;, &#39;field&#39;)

        # Add only the specified keys to the new sub-structure
        for key in keys:
            if key in self:
                sub_struct.setattr(key, self.getattr(key))
            else:
                raise KeyError(f&#34;{fulltype} does not contain the {ftype} &#39;{key}&#39;.&#34;)

        return sub_struct


    def __delattr__(self, key):
        &#34;&#34;&#34; Delete an instance attribute if it exists and is not a class or excluded attribute. &#34;&#34;&#34;
        if key in self._excludedattr:
            raise AttributeError(f&#34;Cannot delete excluded attribute &#39;{key}&#39;&#34;)
        elif key in self.__class__.__dict__:  # Check if it&#39;s a class attribute
            raise AttributeError(f&#34;Cannot delete class attribute &#39;{key}&#39;&#34;)
        elif key in self.__dict__:  # Delete only if in instance&#39;s __dict__
            del self.__dict__[key]
        else:
            raise AttributeError(f&#34;{self._type} has no attribute &#39;{key}&#39;&#34;)


    # A la Matlab display method of vectors, matrices and ND-arrays
    @staticmethod
    def format_array(value,numfmt=&#34;.4g&#34;):
        &#34;&#34;&#34;
        Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
        Recursively formats multi-dimensional arrays without introducing unwanted commas.

        Args:
            value (np.ndarray): The NumPy array to format.
            numfmt: numeric format to be used for the string conversion (default=&#34;.4g&#34;)

        Returns:
            str: A formatted string representation of the array.
        &#34;&#34;&#34;
        dtype_str = {
            np.float64: &#34;double&#34;,
            np.float32: &#34;single&#34;,
            np.int32: &#34;int32&#34;,
            np.int64: &#34;int64&#34;,
            np.complex64: &#34;complex single&#34;,
            np.complex128: &#34;complex double&#34;,
        }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

        max_display = 10  # Maximum number of elements to display

        def format_recursive(arr):
            &#34;&#34;&#34;
            Recursively formats the array based on its dimensions.

            Args:
                arr (np.ndarray): The array or sub-array to format.

            Returns:
                str: Formatted string of the array.
            &#34;&#34;&#34;
            if arr.ndim == 0:
                return f&#34;{arr.item()}&#34;

            if arr.ndim == 1:
                if len(arr) &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr) + &#34;]&#34;
                else:
                    return f&#34;[{len(arr)} elements]&#34;

            if arr.ndim == 2:
                if arr.shape[1] == 1:
                    # Column vector
                    if arr.shape[0] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in arr) + &#34;]T&#34;
                    else:
                        return f&#34;[{arr.shape[0]}Ã—1 vector]&#34;
                elif arr.shape[0] == 1:
                    # Row vector
                    if arr.shape[1] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr[0]) + &#34;]&#34;
                    else:
                        return f&#34;[1Ã—{arr.shape[1]} vector]&#34;
                else:
                    # General matrix
                    return f&#34;[{arr.shape[0]}Ã—{arr.shape[1]} matrix]&#34;

            # For higher dimensions
            shape_str = &#34;Ã—&#34;.join(map(str, arr.shape))
            if arr.size &lt;= max_display:
                # Show full content
                if arr.ndim &gt; 2:
                    # Represent multi-dimensional arrays with nested brackets
                    return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
            return f&#34;[{shape_str} array ({dtype_str})]&#34;

        if value.size == 0:
            return &#34;[]&#34;

        if value.ndim == 0 or value.size == 1:
            return f&#34;{value.item()} ({dtype_str})&#34;

        if value.ndim == 1 or value.ndim == 2:
            # Use existing logic for vectors and matrices
            if value.ndim == 1:
                if len(value) &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{len(value)}Ã—1 {dtype_str}]&#34;
            elif value.ndim == 2:
                rows, cols = value.shape
                if cols == 1:  # Column vector
                    if rows &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[{rows}Ã—1 {dtype_str}]&#34;
                elif rows == 1:  # Row vector
                    if cols &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[1Ã—{cols} {dtype_str}]&#34;
                else:  # General matrix
                    formatted = f&#34;[{rows}Ã—{cols} {dtype_str}]&#34;
            return formatted

        # For higher-dimensional arrays
        if value.size &lt;= max_display:
            formatted = format_recursive(value)
        else:
            shape_str = &#34;Ã—&#34;.join(map(str, value.shape))
            formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

        return formatted


    # convert all NumPy entries to &#34;nestable&#34; expressions
    def np2str(self):
        &#34;&#34;&#34; Convert all NumPy entries of s into their string representations, handling both lists and dictionaries. &#34;&#34;&#34;
        out = struct()
        def format_numpy_result(value):
            &#34;&#34;&#34;
            Converts a NumPy array or scalar into a string representation:
            - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
            - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
            - If the value is a list or dict, the conversion is applied recursively.
            - Non-ndarray inputs that are not list/dict are returned without modification.

            Args:
                value (np.ndarray, scalar, list, dict, or other): The value to format.

            Returns:
                str, list, dict, or original type: A properly formatted string for NumPy arrays/scalars,
                a recursively converted list/dict, or the original value.
            &#34;&#34;&#34;
            if isinstance(value, dict):
                # Recursively process each key in the dictionary.
                new_dict = {}
                for k, v in value.items():
                    new_dict[k] = format_numpy_result(v)
                return new_dict
            elif isinstance(value, list):
                # Recursively process each element in the list.
                return [format_numpy_result(x) for x in value]
            elif isinstance(value, tuple):
                return tuple(format_numpy_result(x) for x in value)
            elif isinstance(value, struct):
                return value.npstr()
            elif np.isscalar(value):
                # For scalars: if numeric, use str() to avoid extra quotes.
                if isinstance(value, (int, float, complex, str)) or value is None:
                    return value
                else:
                    return repr(value)
            elif isinstance(value, np.ndarray):
                # Check if the array has exactly one element.
                if value.size == 1:
                    # Extract the scalar value.
                    return repr(value.item())
                # Convert the array to a nested list.
                nested_list = value.tolist()
                # Recursively format the nested list into a valid string.
                def list_to_string(lst):
                    if isinstance(lst, list):
                        return &#34;[&#34; + &#34;,&#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                    else:
                        return repr(lst)
                return list_to_string(nested_list)
            else:
                # Return the input unmodified if not a NumPy array, list, dict, or scalar.
                return str(value) # str() preferred over repr() for concision
        # Process all entries in self.
        for key, value in self.items():
            out.setattr(key, format_numpy_result(value))
        return out

    # minimal replacement of placeholders by numbers or their string representations
    def numrepl(self, text):
        r&#34;&#34;&#34;
        Replace all placeholders of the form ${key} in the given text by the corresponding
        numeric value from the instance fields, under the following conditions:

        1. &#39;key&#39; must be a valid field in self (i.e., if key in self).
        2. The value corresponding to &#39;key&#39; is either:
             - an int,
             - a float, or
             - a string that represents a valid number (e.g., &#34;1&#34; or &#34;1.0&#34;).

        Only when these conditions are met, the placeholder is substituted.
        The conversion preserves the original type: if the stored value is int, then the
        substitution will be done as an integer (e.g., 1 and not 1.0). Otherwise, if it is
        a float then it will be substituted as a float.

        Any placeholder for which the above conditions are not met remains unchanged.

        Placeholders are recognized by the pattern &#34;${&lt;key&gt;}&#34; where &lt;key&gt; is captured as all
        text until the next &#34;}&#34; (optionally allowing whitespace inside the braces).
        &#34;&#34;&#34;
        # Pattern: match &#34;${&#34;, then optional whitespace, capture all characters until &#34;}&#34;,
        # then optional whitespace, then &#34;}&#34;.
        placeholder_pattern = re.compile(r&#34;\$\{\s*([^}]+?)\s*\}&#34;)

        def replace_match(match):
            key = match.group(1)
            # Check if the key exists in self.
            if key in self:
                value = self[key]
                # If the value is already numeric, substitute directly.
                if isinstance(value, (int, float)):
                    return str(value)
                # If the value is a string, try to interpret it as a numeric value.
                elif isinstance(value, str):
                    s = value.strip()
                    # Check if s is a valid integer representation.
                    if re.fullmatch(r&#34;[+-]?\d+&#34;, s):
                        try:
                            num = int(s)
                            return str(num)
                        except ValueError:
                            # Should not occur because the regex already matched.
                            return match.group(0)
                    # Check if s is a valid float representation (including scientific notation).
                    elif re.fullmatch(r&#34;[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?&#34;, s):
                        try:
                            num = float(s)
                            return str(num)
                        except ValueError:
                            return match.group(0)
            # If key not in self or value is not numeric (or numeric string), leave placeholder intact.
            return match.group(0)

        # Replace all placeholders in the text using the replacer function.
        return placeholder_pattern.sub(replace_match, text)

    # import method
    def importfrom(self, s, nonempty=True, replacedefaultvar=True):
        &#34;&#34;&#34;
        Import values from &#39;s&#39; into self according to the following rules:

        - Only fields that already exist in self are considered.
        - If s is a dictionary, it is converted to a struct via struct(**s).
        - If the current value of a field in self is empty (None, &#34;&#34;, [] or ()),
          then that field is updated from s.
        - If nonempty is True (default), then only non-empty values from s are imported.
        - If replacedefaultvar is True (default), then if a field in self exactly equals
          &#34;${key}&#34; (with key being the field name), it is replaced by the corresponding
          value from s if it is empty.
        - Raises a TypeError if s is not a dict or struct (i.e. if it doesnâ€™t support keys()).
        &#34;&#34;&#34;
        # If s is a dictionary, convert it to a struct instance.
        if isinstance(s, dict):
            s = struct(**s)
        elif not hasattr(s, &#34;keys&#34;):
            raise TypeError(f&#34;s must be a struct or a dictionary not a type {type(s).__name__}&#34;)

        for key in self.keys():
            if key in s:
                s_value = getattr(s, key)
                current_value = getattr(self, key)
                if is_empty(current_value) or (replacedefaultvar and current_value == &#34;${&#34; + key + &#34;}&#34;):
                    if nonempty:
                        if not is_empty(s_value):
                            setattr(self, key, s_value)
                    else:
                        setattr(self, key, s_value)

    # importfrom with copy
    def __lshift__(self, other):
        &#34;&#34;&#34;
        Allows the syntax:

            s = s1 &lt;&lt; s2

        where a new instance is created as a copy of s1 (preserving its type, whether
        struct, param, or paramauto) and then updated with the values from s2 using
        importfrom.
        &#34;&#34;&#34;
        # Create a new instance preserving the type of self.
        new_instance = type(self)(**{k: getattr(self, k) for k in self.keys()})
        # Import values from other (s2) into the new instance.
        new_instance.importfrom(other)
        return new_instance

    # returns only valid keys
    def validkeys(self, list_of_keys):
        &#34;&#34;&#34;
        Validate and return the subset of keys from the provided list that are valid in the instance.

        Parameters:
        -----------
        list_of_keys : list
            A list of keys (as strings) to check against the instanceâ€™s attributes.

        Returns:
        --------
        list
            A list of keys from list_of_keys that are valid (i.e., exist as attributes in the instance).

        Raises:
        -------
        TypeError
            If list_of_keys is not a list or if any element in list_of_keys is not a string.

        Example:
        --------
        &gt;&gt;&gt; s = struct()
        &gt;&gt;&gt; s.foo = 42
        &gt;&gt;&gt; s.bar = &#34;hello&#34;
        &gt;&gt;&gt; valid = s.validkeys([&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;])
        &gt;&gt;&gt; print(valid)   # Output: [&#39;foo&#39;, &#39;bar&#39;] assuming &#39;baz&#39; is not defined in s
        &#34;&#34;&#34;
        # Check that list_of_keys is a list
        if not isinstance(list_of_keys, list):
            raise TypeError(&#34;list_of_keys must be a list&#34;)

        # Check that every entry in the list is a string
        for key in list_of_keys:
            if not isinstance(key, str):
                raise TypeError(&#34;Each key in list_of_keys must be a string&#34;)

        # Assuming valid keys are those present in the instance&#39;s __dict__
        return [key for key in list_of_keys if key in self]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.raster.collection</li>
<li>pizza.region.regioncollection</li>
<li>pizza.script.scriptobject</li>
<li>pizza.script.scriptobjectgroup</li>
<li><a title="raster.collection" href="#raster.collection">collection</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="raster.struct.dict2struct"><code class="name flex">
<span>def <span class="ident">dict2struct</span></span>(<span>dico, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>create a structure from a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dict2struct(dico,makeparam=False):
    &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
    if isinstance(dico,dict):
        s = param() if makeparam else struct()
        s.set(**dico)
        return s
    raise TypeError(&#34;the argument must be a dictionary&#34;)</code></pre>
</details>
</dd>
<dt id="raster.struct.format_array"><code class="name flex">
<span>def <span class="ident">format_array</span></span>(<span>value, numfmt='.4g')</span>
</code></dt>
<dd>
<div class="desc"><p>Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
Recursively formats multi-dimensional arrays without introducing unwanted commas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The NumPy array to format.</dd>
<dt><strong><code>numfmt</code></strong></dt>
<dd>numeric format to be used for the string conversion (default=".4g")</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representation of the array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_array(value,numfmt=&#34;.4g&#34;):
    &#34;&#34;&#34;
    Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
    Recursively formats multi-dimensional arrays without introducing unwanted commas.

    Args:
        value (np.ndarray): The NumPy array to format.
        numfmt: numeric format to be used for the string conversion (default=&#34;.4g&#34;)

    Returns:
        str: A formatted string representation of the array.
    &#34;&#34;&#34;
    dtype_str = {
        np.float64: &#34;double&#34;,
        np.float32: &#34;single&#34;,
        np.int32: &#34;int32&#34;,
        np.int64: &#34;int64&#34;,
        np.complex64: &#34;complex single&#34;,
        np.complex128: &#34;complex double&#34;,
    }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

    max_display = 10  # Maximum number of elements to display

    def format_recursive(arr):
        &#34;&#34;&#34;
        Recursively formats the array based on its dimensions.

        Args:
            arr (np.ndarray): The array or sub-array to format.

        Returns:
            str: Formatted string of the array.
        &#34;&#34;&#34;
        if arr.ndim == 0:
            return f&#34;{arr.item()}&#34;

        if arr.ndim == 1:
            if len(arr) &lt;= max_display:
                return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr) + &#34;]&#34;
            else:
                return f&#34;[{len(arr)} elements]&#34;

        if arr.ndim == 2:
            if arr.shape[1] == 1:
                # Column vector
                if arr.shape[0] &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in arr) + &#34;]T&#34;
                else:
                    return f&#34;[{arr.shape[0]}Ã—1 vector]&#34;
            elif arr.shape[0] == 1:
                # Row vector
                if arr.shape[1] &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr[0]) + &#34;]&#34;
                else:
                    return f&#34;[1Ã—{arr.shape[1]} vector]&#34;
            else:
                # General matrix
                return f&#34;[{arr.shape[0]}Ã—{arr.shape[1]} matrix]&#34;

        # For higher dimensions
        shape_str = &#34;Ã—&#34;.join(map(str, arr.shape))
        if arr.size &lt;= max_display:
            # Show full content
            if arr.ndim &gt; 2:
                # Represent multi-dimensional arrays with nested brackets
                return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
        return f&#34;[{shape_str} array ({dtype_str})]&#34;

    if value.size == 0:
        return &#34;[]&#34;

    if value.ndim == 0 or value.size == 1:
        return f&#34;{value.item()} ({dtype_str})&#34;

    if value.ndim == 1 or value.ndim == 2:
        # Use existing logic for vectors and matrices
        if value.ndim == 1:
            if len(value) &lt;= max_display:
                formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
            else:
                formatted = f&#34;[{len(value)}Ã—1 {dtype_str}]&#34;
        elif value.ndim == 2:
            rows, cols = value.shape
            if cols == 1:  # Column vector
                if rows &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{rows}Ã—1 {dtype_str}]&#34;
            elif rows == 1:  # Row vector
                if cols &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[1Ã—{cols} {dtype_str}]&#34;
            else:  # General matrix
                formatted = f&#34;[{rows}Ã—{cols} {dtype_str}]&#34;
        return formatted

    # For higher-dimensional arrays
    if value.size &lt;= max_display:
        formatted = format_recursive(value)
    else:
        shape_str = &#34;Ã—&#34;.join(map(str, value.shape))
        formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

    return formatted</code></pre>
</details>
</dd>
<dt id="raster.struct.fromkeysvalues"><code class="name flex">
<span>def <span class="ident">fromkeysvalues</span></span>(<span>keys, values, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>struct.keysvalues(keys,values) creates a structure from keys and values
use makeparam = True to create a param instead of struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromkeysvalues(keys,values,makeparam=False):
    &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
        use makeparam = True to create a param instead of struct
    &#34;&#34;&#34;
    if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
    if not isinstance(keys,_list_types): keys = [keys]
    if not isinstance(values,_list_types): values = [values]
    nk,nv = len(keys), len(values)
    s = param() if makeparam else struct()
    if nk&gt;0 and nv&gt;0:
        iv = 0
        for ik in range(nk):
            s.setattr(keys[ik], values[iv])
            iv = min(nv-1,iv+1)
        for ik in range(nk,nv):
            s.setattr(f&#34;key{ik}&#34;, values[ik])
    return s</code></pre>
</details>
</dd>
<dt id="raster.struct.isstrdefined"><code class="name flex">
<span>def <span class="ident">isstrdefined</span></span>(<span>s, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrdefined(string,ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrdefined(s,ref):
    &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
    if struct.isstrexpression(s):
        k = struct.scan(s).keys()
        allfound,i,nk = True,0,len(k)
        while (i&lt;nk) and allfound:
            allfound = k[i] in ref
            i += 1
        return allfound
    else:
        return False</code></pre>
</details>
</dd>
<dt id="raster.struct.isstrexpression"><code class="name flex">
<span>def <span class="ident">isstrexpression</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrexpression(string) returns true if s contains an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrexpression(s):
    &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    return re.search(r&#34;\$\{.*?\}&#34;,s) is not None</code></pre>
</details>
</dd>
<dt id="raster.struct.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>read the equivalent structure
read(filename)</p>
<p>Parameters:
- file: The file path to read from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read(file):
    &#34;&#34;&#34;
        read the equivalent structure
            read(filename)

        Parameters:
        - file: The file path to read from.
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()
    # Check if the parent directory exists, otherwise raise an error
    if not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If the file does not exist, raise an exception
    if not file_path.exists():
        raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
    # Open and read the file
    with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
        s = struct()  # Assuming struct is defined elsewhere
        while True:
            line = f.readline()
            if not line:
                break
            line = line.strip()
            expr = line.split(sep=&#34;=&#34;)
            if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                lhs = expr[0]
                rhs = &#34;&#34;.join(expr[1:]).strip()
                if len(rhs) == 0 or rhs == &#34;None&#34;:
                    v = None
                else:
                    v = eval(rhs)
                s.setattr(lhs, v)
    return s</code></pre>
</details>
</dd>
<dt id="raster.struct.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>scan(string) scan a string for variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def scan(s):
    &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
    tmp = struct()
    #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
    found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
    uniq = []
    for x in found:
        if x not in uniq: uniq.append(x)
    return tmp.fromkeys(uniq)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="raster.struct.isempty"><code class="name">var <span class="ident">isempty</span></code></dt>
<dd>
<div class="desc"><p>isempty is set to True for an empty structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isempty(self):
    &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
    return len(self)==0</code></pre>
</details>
</dd>
<dt id="raster.struct.isexpression"><code class="name">var <span class="ident">isexpression</span></code></dt>
<dd>
<div class="desc"><p>same structure with True if it is an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isexpression(self):
    &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    for k,v in self.items():
        if isinstance(v,str):
            s.setattr(k,struct.isstrexpression(v))
        else:
            s.setattr(k,False)
    return s</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.struct.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, default)</span>
</code></dt>
<dd>
<div class="desc"><p>populate fields from a default structure
check(defaultstruct)
missing field, None and [] values are replaced by default ones</p>
<pre><code>Note: a.check(b) is equivalent to b+a except for [] and None values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self,default):
    &#34;&#34;&#34;
    populate fields from a default structure
        check(defaultstruct)
        missing field, None and [] values are replaced by default ones

        Note: a.check(b) is equivalent to b+a except for [] and None values
    &#34;&#34;&#34;
    if not isinstance(default,struct):
        raise TypeError(&#34;the first argument must be a structure&#34;)
    for f in default.keys():
        ref = default.getattr(f)
        if f not in self:
            self.setattr(f, ref)
        else:
            current = self.getattr(f)
            if ((current is None)  or (current==[])) and \
                ((ref is not None) and (ref!=[])):
                    self.setattr(f, ref)</code></pre>
</details>
</dd>
<dt id="raster.struct.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear() delete all fields while preserving the original class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
    for k in self.keys(): delattr(self,k)</code></pre>
</details>
</dd>
<dt id="raster.struct.disp"><code class="name flex">
<span>def <span class="ident">disp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>display method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disp(self):
    &#34;&#34;&#34; display method &#34;&#34;&#34;
    self.__repr__()</code></pre>
</details>
</dd>
<dt id="raster.struct.dispmax"><code class="name flex">
<span>def <span class="ident">dispmax</span></span>(<span>self, content)</span>
</code></dt>
<dd>
<div class="desc"><p>optimize display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispmax(self,content):
    &#34;&#34;&#34; optimize display &#34;&#34;&#34;
    strcontent = str(content)
    if len(strcontent)&gt;self._maxdisplay:
        nchar = round(self._maxdisplay/2)
        return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
    else:
        return content</code></pre>
</details>
</dd>
<dt id="raster.struct.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Format a string with fields using {field} as placeholders.
Handles expressions like ${variable1}.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>The input string to format.</dd>
<dt><strong><code>escape</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, prevents replacing '${' with '{'.</dd>
<dt><strong><code>raiseerror</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, raises errors for missing fields.</dd>
</dl>
<h2 id="note">Note</h2>
<p>NumPy vectors and matrices are converted into their text representation (default behavior)
If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, s, escape=False, raiseerror=True):
    &#34;&#34;&#34;
        Format a string with fields using {field} as placeholders.
        Handles expressions like ${variable1}.

        Args:
            s (str): The input string to format.
            escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
            raiseerror (bool): If True, raises errors for missing fields.

        Note:
            NumPy vectors and matrices are converted into their text representation (default behavior)
            If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

        Returns:
            str: The formatted string.
    &#34;&#34;&#34;
    tmp = self.np2str()
    if raiseerror:
        try:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
        except AttributeError as attr_err:
            # Handle AttributeError for expressions with operators
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            if self._debug:
                print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
            return s_  # Revert to using &#39;${&#39; for unresolved expressions
        except IndexError as idx_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            if self._debug:
                print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
            raise IndexError from idx_err
        except Exception as other_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            raise RuntimeError from other_err
    else:
        if escape:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.format_map(AttrErrorDict(tmp.__dict__))
            except: # if an error occurs, we use the orginal content
                return s.format_map(AttrErrorDict(self.__dict__))
        else:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
            except:  # if an error occurs, we use the orginal content
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))</code></pre>
</details>
</dd>
<dt id="raster.struct.format_legacy"><code class="name flex">
<span>def <span class="ident">format_legacy</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>format a string with field (use {field} as placeholders)
s.replace(string), s.replace(string,escape=True)
where:
s is a struct object
string is a string with possibly ${variable1}
escape is a flag to prevent ${} replaced by {}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_legacy(self,s,escape=False,raiseerror=True):
    &#34;&#34;&#34;
        format a string with field (use {field} as placeholders)
            s.replace(string), s.replace(string,escape=True)
            where:
                s is a struct object
                string is a string with possibly ${variable1}
                escape is a flag to prevent ${} replaced by {}
    &#34;&#34;&#34;
    if raiseerror:
        try:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
        except KeyError as kerr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
            return s_ # instead of s (we put back $) - OV 2023/01/27
        except Exception as othererr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            raise RuntimeError from othererr
    else:
        if escape:
            return s.format(**self.__dict__)
        else:
            return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)</code></pre>
</details>
</dd>
<dt id="raster.struct.fromkeys"><code class="name flex">
<span>def <span class="ident">fromkeys</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a structure from keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromkeys(self,keys):
    &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
    return self+struct(**dict.fromkeys(keys,None))</code></pre>
</details>
</dd>
<dt id="raster.struct.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self, printout=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Python code of the equivalent structure.</p>
<p>This method converts the current structure (an instance of <code>param</code>, <code>paramauto</code>, or <code><a title="raster.struct" href="#raster.struct">struct</a></code>)
into Python code that, when executed, recreates an equivalent structure. The generated code is
formatted with one field per line.</p>
<p>By default (when <code>printout</code> is False), the generated code is returned as a raw string that starts
directly with, for example, <code>param(</code> (or <code>paramauto(</code> or <code><a title="raster.struct" href="#raster.struct">struct</a>(</code>), with no "X = " prefix or leading
newline. When <code>printout</code> is True, the generated code is printed to standard output and includes a prefix
"X = " to indicate the variable name.</p>
<h2 id="parameters">Parameters</h2>
<p>printout (bool): If True, the generated code is printed to standard output with the "X = " prefix.
If False (default), the code is returned as a raw string starting with, e.g.,
<code>param(</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated Python code representing the structure (regardless of whether it was printed).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self, printout=False):
    &#34;&#34;&#34;
    Generate Python code of the equivalent structure.

    This method converts the current structure (an instance of `param`, `paramauto`, or `struct`)
    into Python code that, when executed, recreates an equivalent structure. The generated code is
    formatted with one field per line.

    By default (when `printout` is False), the generated code is returned as a raw string that starts
    directly with, for example, `param(` (or `paramauto(` or `struct(`), with no &#34;X = &#34; prefix or leading
    newline. When `printout` is True, the generated code is printed to standard output and includes a prefix
    &#34;X = &#34; to indicate the variable name.

    Parameters:
        printout (bool): If True, the generated code is printed to standard output with the &#34;X = &#34; prefix.
                         If False (default), the code is returned as a raw string starting with, e.g.,
                         `param(`.

    Returns:
        str: The generated Python code representing the structure (regardless of whether it was printed).
    &#34;&#34;&#34;
    nk = len(self)
    tmp = self.np2str()
    # Compute the field format based on the maximum key length (with a minimum width of 10)
    fmt = &#34;%%%ss =&#34; % max(10, max([len(k) for k in self.keys()]) + 2)
    # Determine the appropriate class string for the current instance.
    if isinstance(self, param):
        classstr = &#34;param&#34;
    elif &#39;paramauto&#39; in globals() and isinstance(self, paramauto):
        classstr = &#34;paramauto&#34;
    else:
        classstr = &#34;struct&#34;

    lines = []
    if nk == 0:
        # For an empty structure.
        if printout:
            lines.append(f&#34;X = {classstr}()&#34;)
        else:
            lines.append(f&#34;{classstr}()&#34;)
    else:
        # Header: include &#34;X = &#34; only if printing.
        if printout:
            header = f&#34;X = {classstr}(&#34;
        else:
            header = f&#34;{classstr}(&#34;
        lines.append(header)
        # Iterate over keys to generate each field line.
        for i, k in enumerate(self.keys()):
            v = getattr(self, k)
            if isinstance(v, np.ndarray):
                vtmp = getattr(tmp, k)
                field = fmt % k + &#34; &#34; + vtmp
            elif isinstance(v, (int, float)) or v is None:
                field = fmt % k + &#34; &#34; + str(v)
            elif isinstance(v, str):
                field = fmt % k + &#34; &#34; + f&#39;&#34;{v}&#34;&#39;
            elif isinstance(v, (list, tuple, dict)):
                field = fmt % k + &#34; &#34; + str(v)
            else:
                field = fmt % k + &#34; &#34; + &#34;/* unsupported type */&#34;
            # Append a comma after each field except the last one.
            if i &lt; nk - 1:
                field += &#34;,&#34;
            lines.append(field)
        # Create a closing line that aligns the closing parenthesis.
        closing_line = fmt[:-1] % &#34;)&#34;
        lines.append(closing_line)
    result = &#34;\n&#34;.join(lines)
    if printout:
        print(result)
        return None
    return result</code></pre>
</details>
</dd>
<dt id="raster.struct.getattr"><code class="name flex">
<span>def <span class="ident">getattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get attribute override to access both instance attributes and properties if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getattr(self,key):
    &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
    if key in self.__dict__:
        return self.__dict__[key]
    elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
         key not in self._excludedattr and \
         key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
        # If _propertyasattribute is True and it&#39;s a property, get its value
        return self.__class__.__dict__[key].fget(self)
    else:
        raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)</code></pre>
</details>
</dd>
<dt id="raster.struct.hasattr"><code class="name flex">
<span>def <span class="ident">hasattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the field exists, considering properties as regular attributes if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasattr(self, key):
    &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
    return key in self.__dict__ or (
        getattr(self, &#39;_propertyasattribute&#39;, False) and
        key not in self._excludedattr and
        key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
    )</code></pre>
</details>
</dd>
<dt id="raster.struct.importfrom"><code class="name flex">
<span>def <span class="ident">importfrom</span></span>(<span>self, s, nonempty=True, replacedefaultvar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Import values from 's' into self according to the following rules:</p>
<ul>
<li>Only fields that already exist in self are considered.</li>
<li>If s is a dictionary, it is converted to a struct via struct(**s).</li>
<li>If the current value of a field in self is empty (None, "", [] or ()),
then that field is updated from s.</li>
<li>If nonempty is True (default), then only non-empty values from s are imported.</li>
<li>If replacedefaultvar is True (default), then if a field in self exactly equals
"${key}" (with key being the field name), it is replaced by the corresponding
value from s if it is empty.</li>
<li>Raises a TypeError if s is not a dict or struct (i.e. if it doesnâ€™t support keys()).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importfrom(self, s, nonempty=True, replacedefaultvar=True):
    &#34;&#34;&#34;
    Import values from &#39;s&#39; into self according to the following rules:

    - Only fields that already exist in self are considered.
    - If s is a dictionary, it is converted to a struct via struct(**s).
    - If the current value of a field in self is empty (None, &#34;&#34;, [] or ()),
      then that field is updated from s.
    - If nonempty is True (default), then only non-empty values from s are imported.
    - If replacedefaultvar is True (default), then if a field in self exactly equals
      &#34;${key}&#34; (with key being the field name), it is replaced by the corresponding
      value from s if it is empty.
    - Raises a TypeError if s is not a dict or struct (i.e. if it doesnâ€™t support keys()).
    &#34;&#34;&#34;
    # If s is a dictionary, convert it to a struct instance.
    if isinstance(s, dict):
        s = struct(**s)
    elif not hasattr(s, &#34;keys&#34;):
        raise TypeError(f&#34;s must be a struct or a dictionary not a type {type(s).__name__}&#34;)

    for key in self.keys():
        if key in s:
            s_value = getattr(s, key)
            current_value = getattr(self, key)
            if is_empty(current_value) or (replacedefaultvar and current_value == &#34;${&#34; + key + &#34;}&#34;):
                if nonempty:
                    if not is_empty(s_value):
                        setattr(self, key, s_value)
                else:
                    setattr(self, key, s_value)</code></pre>
</details>
</dd>
<dt id="raster.struct.isdefined"><code class="name flex">
<span>def <span class="ident">isdefined</span></span>(<span>self, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>isdefined(ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdefined(self,ref=None):
    &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
    nk = len(k)
    if ref is None:
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
            else:
                s.setattr(k[i],True)
    else:
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],ref))
            else:
                s.setattr(k[i],True)
    return s</code></pre>
</details>
</dd>
<dt id="raster.struct.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all elements as iterable key, value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
    return self.zip()</code></pre>
</details>
</dd>
<dt id="raster.struct.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34; return the fields &#34;&#34;&#34;
    # keys() is used by struct() and its iterator
    return [key for key in self.__dict__.keys() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="raster.struct.keyssorted"><code class="name flex">
<span>def <span class="ident">keyssorted</span></span>(<span>self, reverse=True)</span>
</code></dt>
<dd>
<div class="desc"><p>sort keys by length()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyssorted(self,reverse=True):
    &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
    klist = self.keys()
    l = [len(k) for k in klist]
    return [k for _,k in sorted(zip(l,klist),reverse=reverse)]</code></pre>
</details>
</dd>
<dt id="raster.struct.np2str"><code class="name flex">
<span>def <span class="ident">np2str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all NumPy entries of s into their string representations, handling both lists and dictionaries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def np2str(self):
    &#34;&#34;&#34; Convert all NumPy entries of s into their string representations, handling both lists and dictionaries. &#34;&#34;&#34;
    out = struct()
    def format_numpy_result(value):
        &#34;&#34;&#34;
        Converts a NumPy array or scalar into a string representation:
        - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
        - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
        - If the value is a list or dict, the conversion is applied recursively.
        - Non-ndarray inputs that are not list/dict are returned without modification.

        Args:
            value (np.ndarray, scalar, list, dict, or other): The value to format.

        Returns:
            str, list, dict, or original type: A properly formatted string for NumPy arrays/scalars,
            a recursively converted list/dict, or the original value.
        &#34;&#34;&#34;
        if isinstance(value, dict):
            # Recursively process each key in the dictionary.
            new_dict = {}
            for k, v in value.items():
                new_dict[k] = format_numpy_result(v)
            return new_dict
        elif isinstance(value, list):
            # Recursively process each element in the list.
            return [format_numpy_result(x) for x in value]
        elif isinstance(value, tuple):
            return tuple(format_numpy_result(x) for x in value)
        elif isinstance(value, struct):
            return value.npstr()
        elif np.isscalar(value):
            # For scalars: if numeric, use str() to avoid extra quotes.
            if isinstance(value, (int, float, complex, str)) or value is None:
                return value
            else:
                return repr(value)
        elif isinstance(value, np.ndarray):
            # Check if the array has exactly one element.
            if value.size == 1:
                # Extract the scalar value.
                return repr(value.item())
            # Convert the array to a nested list.
            nested_list = value.tolist()
            # Recursively format the nested list into a valid string.
            def list_to_string(lst):
                if isinstance(lst, list):
                    return &#34;[&#34; + &#34;,&#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                else:
                    return repr(lst)
            return list_to_string(nested_list)
        else:
            # Return the input unmodified if not a NumPy array, list, dict, or scalar.
            return str(value) # str() preferred over repr() for concision
    # Process all entries in self.
    for key, value in self.items():
        out.setattr(key, format_numpy_result(value))
    return out</code></pre>
</details>
</dd>
<dt id="raster.struct.numrepl"><code class="name flex">
<span>def <span class="ident">numrepl</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace all placeholders of the form ${key} in the given text by the corresponding
numeric value from the instance fields, under the following conditions:</p>
<ol>
<li>'key' must be a valid field in self (i.e., if key in self).</li>
<li>The value corresponding to 'key' is either:<ul>
<li>an int,</li>
<li>a float, or</li>
<li>a string that represents a valid number (e.g., "1" or "1.0").</li>
</ul>
</li>
</ol>
<p>Only when these conditions are met, the placeholder is substituted.
The conversion preserves the original type: if the stored value is int, then the
substitution will be done as an integer (e.g., 1 and not 1.0). Otherwise, if it is
a float then it will be substituted as a float.</p>
<p>Any placeholder for which the above conditions are not met remains unchanged.</p>
<p>Placeholders are recognized by the pattern "${<key>}" where <key> is captured as all
text until the next "}" (optionally allowing whitespace inside the braces).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numrepl(self, text):
    r&#34;&#34;&#34;
    Replace all placeholders of the form ${key} in the given text by the corresponding
    numeric value from the instance fields, under the following conditions:

    1. &#39;key&#39; must be a valid field in self (i.e., if key in self).
    2. The value corresponding to &#39;key&#39; is either:
         - an int,
         - a float, or
         - a string that represents a valid number (e.g., &#34;1&#34; or &#34;1.0&#34;).

    Only when these conditions are met, the placeholder is substituted.
    The conversion preserves the original type: if the stored value is int, then the
    substitution will be done as an integer (e.g., 1 and not 1.0). Otherwise, if it is
    a float then it will be substituted as a float.

    Any placeholder for which the above conditions are not met remains unchanged.

    Placeholders are recognized by the pattern &#34;${&lt;key&gt;}&#34; where &lt;key&gt; is captured as all
    text until the next &#34;}&#34; (optionally allowing whitespace inside the braces).
    &#34;&#34;&#34;
    # Pattern: match &#34;${&#34;, then optional whitespace, capture all characters until &#34;}&#34;,
    # then optional whitespace, then &#34;}&#34;.
    placeholder_pattern = re.compile(r&#34;\$\{\s*([^}]+?)\s*\}&#34;)

    def replace_match(match):
        key = match.group(1)
        # Check if the key exists in self.
        if key in self:
            value = self[key]
            # If the value is already numeric, substitute directly.
            if isinstance(value, (int, float)):
                return str(value)
            # If the value is a string, try to interpret it as a numeric value.
            elif isinstance(value, str):
                s = value.strip()
                # Check if s is a valid integer representation.
                if re.fullmatch(r&#34;[+-]?\d+&#34;, s):
                    try:
                        num = int(s)
                        return str(num)
                    except ValueError:
                        # Should not occur because the regex already matched.
                        return match.group(0)
                # Check if s is a valid float representation (including scientific notation).
                elif re.fullmatch(r&#34;[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?&#34;, s):
                    try:
                        num = float(s)
                        return str(num)
                    except ValueError:
                        return match.group(0)
        # If key not in self or value is not numeric (or numeric string), leave placeholder intact.
        return match.group(0)

    # Replace all placeholders in the text using the replacer function.
    return placeholder_pattern.sub(replace_match, text)</code></pre>
</details>
</dd>
<dt id="raster.struct.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self,**kwargs):
    &#34;&#34;&#34; initialization &#34;&#34;&#34;
    self.__dict__.update(kwargs)</code></pre>
</details>
</dd>
<dt id="raster.struct.setattr"><code class="name flex">
<span>def <span class="ident">setattr</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>set field and value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setattr(self,key,value):
    &#34;&#34;&#34; set field and value &#34;&#34;&#34;
    if isinstance(value,list) and len(value)==0 and key in self:
        delattr(self, key)
    else:
        self.__dict__[key] = value</code></pre>
</details>
</dd>
<dt id="raster.struct.sortdefinitions"><code class="name flex">
<span>def <span class="ident">sortdefinitions</span></span>(<span>self, raiseerror=True, silentmode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>sortdefintions sorts all definitions
so that they can be executed as param().
If any inconsistency is found, an error message is generated.</p>
<p>Flags = default values
raiseerror=True show erros of True
silentmode=False no warning if True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortdefinitions(self,raiseerror=True,silentmode=False):
    &#34;&#34;&#34; sortdefintions sorts all definitions
        so that they can be executed as param().
        If any inconsistency is found, an error message is generated.

        Flags = default values
            raiseerror=True show erros of True
            silentmode=False no warning if True
    &#34;&#34;&#34;
    find = lambda xlist: [i for i, x in enumerate(xlist) if x]
    findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
    k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
    istatic = findnot(isexpr)
    idynamic = find(isexpr)
    static = struct.fromkeysvalues(
        [ k[i] for i in istatic ],
        [ v[i] for i in istatic ],
        makeparam = False)
    dynamic = struct.fromkeysvalues(
        [ k[i] for i in idynamic ],
        [ v[i] for i in idynamic ],
        makeparam=False)
    current = static # make static the current structure
    nmissing, anychange, errorfound = len(dynamic), False, False
    while nmissing:
        itst, found = 0, False
        while itst&lt;nmissing and not found:
            teststruct = current + dynamic[[itst]] # add the test field
            found = all(list(teststruct.isdefined()))
            ifound = itst
            itst += 1
        if found:
            current = teststruct # we accept the new field
            dynamic[ifound] = []
            nmissing -= 1
            anychange = True
        else:
            if raiseerror:
                raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                               (nmissing,len(self),self._ftype))
            else:
                if (not errorfound) and (not silentmode):
                    print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                          (nmissing,len(self),self._ftype))
                current = teststruct # we accept the new field (even if it cannot be interpreted)
                dynamic[ifound] = []
                nmissing -= 1
                errorfound = True
    if anychange:
        self.clear() # reset all fields and assign them in the proper order
        k,v = current.keys(), current.values()
        for i in range(len(k)):
            self.setattr(k[i],v[i])</code></pre>
</details>
</dd>
<dt id="raster.struct.struct2dict"><code class="name flex">
<span>def <span class="ident">struct2dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create a dictionary from the current structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2dict(self):
    &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
    return dict(self.zip())</code></pre>
</details>
</dd>
<dt id="raster.struct.struct2param"><code class="name flex">
<span>def <span class="ident">struct2param</span></span>(<span>self, protection=False, evaluation=True)</span>
</code></dt>
<dd>
<div class="desc"><p>convert an object struct() to param()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2param(self,protection=False,evaluation=True):
    &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
    p = param(**self.struct2dict())
    for i in range(len(self)):
        if isinstance(self[i],pstr): p[i] = pstr(p[i])
    p._protection = protection
    p._evaluation = evaluation
    return p</code></pre>
</details>
</dd>
<dt id="raster.struct.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update multiple fields at once, while protecting certain attributes.</p>
<h2 id="parameters">Parameters:</h2>
<p>**kwargs : dict
The fields to update and their new values.</p>
<p>Protected attributes defined in _excludedattr are not updated.</p>
<h2 id="usage">Usage:</h2>
<p>s.update(a=10, b=[1, 2, 3], new_field="new_value")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update multiple fields at once, while protecting certain attributes.

    Parameters:
    -----------
    **kwargs : dict
        The fields to update and their new values.

    Protected attributes defined in _excludedattr are not updated.

    Usage:
    ------
    s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
    &#34;&#34;&#34;
    protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

    for key, value in kwargs.items():
        if key in protected_attributes:
            print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
        else:
            self.setattr(key, value)</code></pre>
</details>
</dd>
<dt id="raster.struct.validkeys"><code class="name flex">
<span>def <span class="ident">validkeys</span></span>(<span>self, list_of_keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate and return the subset of keys from the provided list that are valid in the instance.</p>
<h2 id="parameters">Parameters:</h2>
<p>list_of_keys : list
A list of keys (as strings) to check against the instanceâ€™s attributes.</p>
<h2 id="returns">Returns:</h2>
<p>list
A list of keys from list_of_keys that are valid (i.e., exist as attributes in the instance).</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If list_of_keys is not a list or if any element in list_of_keys is not a string.</p>
<h2 id="example">Example:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; s = struct()
&gt;&gt;&gt; s.foo = 42
&gt;&gt;&gt; s.bar = &quot;hello&quot;
&gt;&gt;&gt; valid = s.validkeys([&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;])
&gt;&gt;&gt; print(valid)   # Output: ['foo', 'bar'] assuming 'baz' is not defined in s
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validkeys(self, list_of_keys):
    &#34;&#34;&#34;
    Validate and return the subset of keys from the provided list that are valid in the instance.

    Parameters:
    -----------
    list_of_keys : list
        A list of keys (as strings) to check against the instanceâ€™s attributes.

    Returns:
    --------
    list
        A list of keys from list_of_keys that are valid (i.e., exist as attributes in the instance).

    Raises:
    -------
    TypeError
        If list_of_keys is not a list or if any element in list_of_keys is not a string.

    Example:
    --------
    &gt;&gt;&gt; s = struct()
    &gt;&gt;&gt; s.foo = 42
    &gt;&gt;&gt; s.bar = &#34;hello&#34;
    &gt;&gt;&gt; valid = s.validkeys([&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;])
    &gt;&gt;&gt; print(valid)   # Output: [&#39;foo&#39;, &#39;bar&#39;] assuming &#39;baz&#39; is not defined in s
    &#34;&#34;&#34;
    # Check that list_of_keys is a list
    if not isinstance(list_of_keys, list):
        raise TypeError(&#34;list_of_keys must be a list&#34;)

    # Check that every entry in the list is a string
    for key in list_of_keys:
        if not isinstance(key, str):
            raise TypeError(&#34;Each key in list_of_keys must be a string&#34;)

    # Assuming valid keys are those present in the instance&#39;s __dict__
    return [key for key in list_of_keys if key in self]</code></pre>
</details>
</dd>
<dt id="raster.struct.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34; return the values &#34;&#34;&#34;
    # values() is used by struct() and its iterator
    return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="raster.struct.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, overwrite=True, mkdir=False)</span>
</code></dt>
<dd>
<div class="desc"><p>write the equivalent structure (not recursive for nested struct)
write(filename, overwrite=True, mkdir=False)</p>
<p>Parameters:
- file: The file path to write to.
- overwrite: Whether to overwrite the file if it exists (default: True).
- mkdir: Whether to create the directory if it doesn't exist (default: False).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, overwrite=True, mkdir=False):
    &#34;&#34;&#34;
        write the equivalent structure (not recursive for nested struct)
            write(filename, overwrite=True, mkdir=False)

        Parameters:
        - file: The file path to write to.
        - overwrite: Whether to overwrite the file if it exists (default: True).
        - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()

    # Check if the directory exists or if mkdir is set to True, create it
    if mkdir:
        file_path.parent.mkdir(parents=True, exist_ok=True)
    elif not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If overwrite is False and the file already exists, raise an exception
    if not overwrite and file_path.exists():
        raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
    # Convert to static if needed
    if isinstance(p,(param,paramauto)):
        tmp = self.tostatic()
    else:
        tmp = self
    # Open and write to the file using the resolved path
    with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
        print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
        for k, v in tmp.items():
            if v is None:
                print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
            elif isinstance(v, (int, float)):
                print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
            elif isinstance(v, str):
                print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
            else:
                print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="raster.struct.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>zip keys and values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self):
    &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
    return zip(self.keys(),self.values())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#features">Features</a><ul>
<li><a href="#1-raster-area-creation">1. Raster Area Creation</a></li>
<li><a href="#2-geometric-object-insertion">2. Geometric Object Insertion</a></li>
<li><a href="#3-collections-and-paths">3. Collections and Paths</a></li>
<li><a href="#4-scatter-and-emulsions">4. Scatter and Emulsions</a></li>
<li><a href="#5-visualization">5. Visualization</a></li>
<li><a href="#6-exporting-to-lammps">6. Exporting to LAMMPS</a></li>
</ul>
</li>
<li><a href="#advanced-features">Advanced Features</a></li>
<li><a href="#usage-examples">Usage Examples</a><ul>
<li><a href="#basic-example">Basic Example</a></li>
<li><a href="#emulsion-generation">Emulsion Generation</a></li>
<li><a href="#core-shell-dispersion">Core-Shell Dispersion</a></li>
</ul>
</li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#authors-and-credits">Authors and Credits</a></li>
<li><a href="#old-help">Old help</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="raster.arc" href="#raster.arc">arc</a></code></li>
<li><code><a title="raster.imagesc" href="#raster.imagesc">imagesc</a></code></li>
<li><code><a title="raster.ind2rgb" href="#raster.ind2rgb">ind2rgb</a></code></li>
<li><code><a title="raster.linear" href="#raster.linear">linear</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="raster.Circle" href="#raster.Circle">Circle</a></code></h4>
</li>
<li>
<h4><code><a title="raster.Collection" href="#raster.Collection">Collection</a></code></h4>
<ul class="">
<li><code><a title="raster.Collection.beadtype" href="#raster.Collection.beadtype">beadtype</a></code></li>
<li><code><a title="raster.Collection.get" href="#raster.Collection.get">get</a></code></li>
<li><code><a title="raster.Collection.xcenter" href="#raster.Collection.xcenter">xcenter</a></code></li>
<li><code><a title="raster.Collection.xycenter" href="#raster.Collection.xycenter">xycenter</a></code></li>
<li><code><a title="raster.Collection.ycenter" href="#raster.Collection.ycenter">ycenter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.Diamond" href="#raster.Diamond">Diamond</a></code></h4>
</li>
<li>
<h4><code><a title="raster.Hexagon" href="#raster.Hexagon">Hexagon</a></code></h4>
</li>
<li>
<h4><code><a title="raster.Pentagon" href="#raster.Pentagon">Pentagon</a></code></h4>
</li>
<li>
<h4><code><a title="raster.Rectangle" href="#raster.Rectangle">Rectangle</a></code></h4>
</li>
<li>
<h4><code><a title="raster.Triangle" href="#raster.Triangle">Triangle</a></code></h4>
</li>
<li>
<h4><code><a title="raster.collection" href="#raster.collection">collection</a></code></h4>
</li>
<li>
<h4><code><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></code></h4>
<ul class="two-column">
<li><code><a title="raster.coregeometry.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.coregeometry.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.coregeometry.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.coregeometry.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.coregeometry.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.coregeometry.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.coregeometry.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.coregeometry.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.coregeometry.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.coreshell" href="#raster.coreshell">coreshell</a></code></h4>
<ul class="">
<li><code><a title="raster.coreshell.insertion" href="#raster.coreshell.insertion">insertion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.data" href="#raster.data">data</a></code></h4>
<ul class="two-column">
<li><code><a title="raster.data.HKEYWORDS" href="#raster.data.HKEYWORDS">HKEYWORDS</a></code></li>
<li><code><a title="raster.data.SKEYWORDS" href="#raster.data.SKEYWORDS">SKEYWORDS</a></code></li>
<li><code><a title="raster.data.append" href="#raster.data.append">append</a></code></li>
<li><code><a title="raster.data.delete" href="#raster.data.delete">delete</a></code></li>
<li><code><a title="raster.data.dispsection" href="#raster.data.dispsection">dispsection</a></code></li>
<li><code><a title="raster.data.findtime" href="#raster.data.findtime">findtime</a></code></li>
<li><code><a title="raster.data.get" href="#raster.data.get">get</a></code></li>
<li><code><a title="raster.data.iterator" href="#raster.data.iterator">iterator</a></code></li>
<li><code><a title="raster.data.map" href="#raster.data.map">map</a></code></li>
<li><code><a title="raster.data.maxbox" href="#raster.data.maxbox">maxbox</a></code></li>
<li><code><a title="raster.data.maxtype" href="#raster.data.maxtype">maxtype</a></code></li>
<li><code><a title="raster.data.newxyz" href="#raster.data.newxyz">newxyz</a></code></li>
<li><code><a title="raster.data.reorder" href="#raster.data.reorder">reorder</a></code></li>
<li><code><a title="raster.data.replace" href="#raster.data.replace">replace</a></code></li>
<li><code><a title="raster.data.viz" href="#raster.data.viz">viz</a></code></li>
<li><code><a title="raster.data.write" href="#raster.data.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.emulsion" href="#raster.emulsion">emulsion</a></code></h4>
<ul class="two-column">
<li><code><a title="raster.emulsion.accepted" href="#raster.emulsion.accepted">accepted</a></code></li>
<li><code><a title="raster.emulsion.dist" href="#raster.emulsion.dist">dist</a></code></li>
<li><code><a title="raster.emulsion.insertion" href="#raster.emulsion.insertion">insertion</a></code></li>
<li><code><a title="raster.emulsion.insertone" href="#raster.emulsion.insertone">insertone</a></code></li>
<li><code><a title="raster.emulsion.rand" href="#raster.emulsion.rand">rand</a></code></li>
<li><code><a title="raster.emulsion.setbeadtype" href="#raster.emulsion.setbeadtype">setbeadtype</a></code></li>
<li><code><a title="raster.emulsion.walldist" href="#raster.emulsion.walldist">walldist</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></code></h4>
<ul class="">
<li><code><a title="raster.genericpolygon.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.genericpolygon.hasclosefit" href="#raster.genericpolygon.hasclosefit">hasclosefit</a></code></li>
<li><code><a title="raster.genericpolygon.hascontour" href="#raster.genericpolygon.hascontour">hascontour</a></code></li>
<li><code><a title="raster.genericpolygon.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.genericpolygon.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.overlay" href="#raster.overlay">overlay</a></code></h4>
<ul class="">
<li><code><a title="raster.overlay.hasclosefit" href="#raster.overlay.hasclosefit">hasclosefit</a></code></li>
<li><code><a title="raster.overlay.hascontour" href="#raster.overlay.hascontour">hascontour</a></code></li>
<li><code><a title="raster.overlay.load" href="#raster.overlay.load">load</a></code></li>
<li><code><a title="raster.overlay.select" href="#raster.overlay.select">select</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.raster" href="#raster.raster">raster</a></code></h4>
<ul class="two-column">
<li><code><a title="raster.raster.circle" href="#raster.raster.circle">circle</a></code></li>
<li><code><a title="raster.raster.clear" href="#raster.raster.clear">clear</a></code></li>
<li><code><a title="raster.raster.collection" href="#raster.raster.collection">collection</a></code></li>
<li><code><a title="raster.raster.copyalongpath" href="#raster.raster.copyalongpath">copyalongpath</a></code></li>
<li><code><a title="raster.raster.count" href="#raster.raster.count">count</a></code></li>
<li><code><a title="raster.raster.data" href="#raster.raster.data">data</a></code></li>
<li><code><a title="raster.raster.delete" href="#raster.raster.delete">delete</a></code></li>
<li><code><a title="raster.raster.diamond" href="#raster.raster.diamond">diamond</a></code></li>
<li><code><a title="raster.raster.exist" href="#raster.raster.exist">exist</a></code></li>
<li><code><a title="raster.raster.figure" href="#raster.raster.figure">figure</a></code></li>
<li><code><a title="raster.raster.frameobj" href="#raster.raster.frameobj">frameobj</a></code></li>
<li><code><a title="raster.raster.get" href="#raster.raster.get">get</a></code></li>
<li><code><a title="raster.raster.hexagon" href="#raster.raster.hexagon">hexagon</a></code></li>
<li><code><a title="raster.raster.label" href="#raster.raster.label">label</a></code></li>
<li><code><a title="raster.raster.labelobj" href="#raster.raster.labelobj">labelobj</a></code></li>
<li><code><a title="raster.raster.length" href="#raster.raster.length">length</a></code></li>
<li><code><a title="raster.raster.list" href="#raster.raster.list">list</a></code></li>
<li><code><a title="raster.raster.max" href="#raster.raster.max">max</a></code></li>
<li><code><a title="raster.raster.names" href="#raster.raster.names">names</a></code></li>
<li><code><a title="raster.raster.newfigure" href="#raster.raster.newfigure">newfigure</a></code></li>
<li><code><a title="raster.raster.numeric" href="#raster.raster.numeric">numeric</a></code></li>
<li><code><a title="raster.raster.overlay" href="#raster.raster.overlay">overlay</a></code></li>
<li><code><a title="raster.raster.pentagon" href="#raster.raster.pentagon">pentagon</a></code></li>
<li><code><a title="raster.raster.plot" href="#raster.raster.plot">plot</a></code></li>
<li><code><a title="raster.raster.plotobj" href="#raster.raster.plotobj">plotobj</a></code></li>
<li><code><a title="raster.raster.print" href="#raster.raster.print">print</a></code></li>
<li><code><a title="raster.raster.rectangle" href="#raster.raster.rectangle">rectangle</a></code></li>
<li><code><a title="raster.raster.scatter" href="#raster.raster.scatter">scatter</a></code></li>
<li><code><a title="raster.raster.show" href="#raster.raster.show">show</a></code></li>
<li><code><a title="raster.raster.string" href="#raster.raster.string">string</a></code></li>
<li><code><a title="raster.raster.torgb" href="#raster.raster.torgb">torgb</a></code></li>
<li><code><a title="raster.raster.triangle" href="#raster.raster.triangle">triangle</a></code></li>
<li><code><a title="raster.raster.unlabel" href="#raster.raster.unlabel">unlabel</a></code></li>
<li><code><a title="raster.raster.valid" href="#raster.raster.valid">valid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.scatter" href="#raster.scatter">scatter</a></code></h4>
<ul class="">
<li><code><a title="raster.scatter.n" href="#raster.scatter.n">n</a></code></li>
<li><code><a title="raster.scatter.pairdist" href="#raster.scatter.pairdist">pairdist</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.struct" href="#raster.struct">struct</a></code></h4>
<ul class="two-column">
<li><code><a title="raster.struct.check" href="#raster.struct.check">check</a></code></li>
<li><code><a title="raster.struct.clear" href="#raster.struct.clear">clear</a></code></li>
<li><code><a title="raster.struct.dict2struct" href="#raster.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="raster.struct.disp" href="#raster.struct.disp">disp</a></code></li>
<li><code><a title="raster.struct.dispmax" href="#raster.struct.dispmax">dispmax</a></code></li>
<li><code><a title="raster.struct.format" href="#raster.struct.format">format</a></code></li>
<li><code><a title="raster.struct.format_array" href="#raster.struct.format_array">format_array</a></code></li>
<li><code><a title="raster.struct.format_legacy" href="#raster.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="raster.struct.fromkeys" href="#raster.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="raster.struct.fromkeysvalues" href="#raster.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="raster.struct.generator" href="#raster.struct.generator">generator</a></code></li>
<li><code><a title="raster.struct.getattr" href="#raster.struct.getattr">getattr</a></code></li>
<li><code><a title="raster.struct.hasattr" href="#raster.struct.hasattr">hasattr</a></code></li>
<li><code><a title="raster.struct.importfrom" href="#raster.struct.importfrom">importfrom</a></code></li>
<li><code><a title="raster.struct.isdefined" href="#raster.struct.isdefined">isdefined</a></code></li>
<li><code><a title="raster.struct.isempty" href="#raster.struct.isempty">isempty</a></code></li>
<li><code><a title="raster.struct.isexpression" href="#raster.struct.isexpression">isexpression</a></code></li>
<li><code><a title="raster.struct.isstrdefined" href="#raster.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="raster.struct.isstrexpression" href="#raster.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="raster.struct.items" href="#raster.struct.items">items</a></code></li>
<li><code><a title="raster.struct.keys" href="#raster.struct.keys">keys</a></code></li>
<li><code><a title="raster.struct.keyssorted" href="#raster.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="raster.struct.np2str" href="#raster.struct.np2str">np2str</a></code></li>
<li><code><a title="raster.struct.numrepl" href="#raster.struct.numrepl">numrepl</a></code></li>
<li><code><a title="raster.struct.read" href="#raster.struct.read">read</a></code></li>
<li><code><a title="raster.struct.scan" href="#raster.struct.scan">scan</a></code></li>
<li><code><a title="raster.struct.set" href="#raster.struct.set">set</a></code></li>
<li><code><a title="raster.struct.setattr" href="#raster.struct.setattr">setattr</a></code></li>
<li><code><a title="raster.struct.sortdefinitions" href="#raster.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="raster.struct.struct2dict" href="#raster.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="raster.struct.struct2param" href="#raster.struct.struct2param">struct2param</a></code></li>
<li><code><a title="raster.struct.update" href="#raster.struct.update">update</a></code></li>
<li><code><a title="raster.struct.validkeys" href="#raster.struct.validkeys">validkeys</a></code></li>
<li><code><a title="raster.struct.values" href="#raster.struct.values">values</a></code></li>
<li><code><a title="raster.struct.write" href="#raster.struct.write">write</a></code></li>
<li><code><a title="raster.struct.zip" href="#raster.struct.zip">zip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>