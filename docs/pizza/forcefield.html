<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>forcefield API documentation</title>
<meta name="description" content="Synopsis of forcefield Class
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>forcefield</code></h1>
</header>
<section id="section-intro">
<h1 id="synopsis-of-forcefield-class">Synopsis of forcefield Class</h1>
<p>The <code><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></code> class defines the core behavior for managing inter-particle interactions
in molecular dynamics simulations or similar physics-based models. It provides methods
to calculate interaction parameters, including pair styles, diagonal pair coefficients,
and off-diagonal pair coefficients, which are crucial for forcefield models.</p>
<h2 id="key-attributes">Key Attributes:</h2>
<ul>
<li><code>PAIR_STYLE</code> (str): Defines the pair style command for the forcefield interactions.</li>
<li><code>PAIR_DIAGCOEFF</code> (str): Defines the command for calculating diagonal pair coefficients.</li>
<li><code>PAIR_OFFDIAGCOEFF</code> (str): Defines the command for calculating off-diagonal pair coefficients.</li>
<li><code>parameters</code> (parameterforcefield): Stores the parameters used for interaction evaluations.</li>
<li><code>beadtype</code> (int): The bead type used in the forcefield model.</li>
<li><code>userid</code> (str): A unique identifier for the forcefield instance.</li>
</ul>
<h2 id="key-methods">Key Methods:</h2>
<ul>
<li><code>pair_style(printflag=True)</code>: Returns the pair style command based on the current
<code>parameters</code>, <code>beadtype</code>, and <code>userid</code>.</li>
<li><code>pair_diagcoeff(printflag=True, i=None)</code>: Returns the diagonal pair coefficient command
based on the current bead type <code>i</code> and <code>userid</code>. The bead type can be overridden.</li>
<li>
<p><code>pair_offdiagcoeff(o=None, printflag=True, i=None)</code>: Returns the off-diagonal pair
coefficient command for interactions between two bead types or forcefield objects.
The bead type <code>i</code> and the interacting forcefield <code>o</code> can be specified or overridden.</p>
<p>&mdash; forcefield methods for LAMMPS &mdash;</p>
<p>The superclass provides a collection of classes to define materials
and forcefields. Note that the following hierarchy is used:
&gt; forcefield() is the top class (to be called directly)
&gt; customff(forcefield) defines a new forcefield so called customff
&gt; customstyle(customff) defines a pair-style applicable to customff
&gt; custommaterial(customstyle) defines a new material</p>
<p>&mdash; Material library (first implementations) &mdash;</p>
<pre><code>w = water(beadtype=1, userid="fluid")
w.parameters.Cp = 20
print("
</code></pre>
<p>"*2,w)</p>
<pre><code>f = solidfood(beadtype=2, userid="elastic")
print("
</code></pre>
<p>"*2,f)</p>
<pre><code>r = rigidwall(beadtype=3, userid="wall")
print("
</code></pre>
<p>"*2,r)</p>
<p>&mdash; Template to define a material &mdash;</p>
<pre><code>  class mymaterial(myforcefield):
      userid = "short name"
      version = value
      def __init__(self, beadtype=1, userid=None):
          super().__init__()
          if userid!=None: self.userid = userid
          self.name.material"] = "short of the material"
          self.description.material"] = "full description"
          self.beadtype = beadtype
          self.parameters = parameterforcefield(
              param1 = value1,
              param2 = value2,
              param3 = "math expression with ${param1, ${param2}"
          )
</code></pre>
<p>&mdash; Example of outputs | LAMMPS:SMD:tlsph:solidfood &mdash;</p>
<pre><code>========================== [ elastic | version=0.1 ] ===========================

  Bead of type 2 = [LAMMPS:SMD:tlsph:solidfood]
  -----------------:----------------------------------------
                rho: 1000
                 c0: 10.0
                  E: 5*${c0}^2*${rho}
                 nu: 0.3
                 q1: 1.0
                 q2: 0.0
                 Hg: 10
                 Cp: 1.0
        sigma_yield: 0.1*${E}
          hardening: 0
      contact_scale: 1.5
  contact_stiffness: 2.5*${c0}^2*${rho}
  -----------------:----------------------------------------
forcefield object with 12 parameters

............................... [ description ] ................................

        #       LAMMPS:SMD - solid, liquid, rigid forcefields (continuum mechanics)
        #       SMD:TLSPH - total Lagrangian for solids
        #       food beads - solid behavior

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ [ methods ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

replace FFi,FFj by your variable names &lt;&lt;&lt;
        To assign a type, use: FFi.beadtype = integer value
        Use the methods FFi.pair_style() and FFi.pair_coeff(FFj)
        Note for pairs: the caller object is i (FFi), the argument is j (FFj or j)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ [ template ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # [2:elastic] PAIR STYLE SMD
    pair_style      hybrid/overlay smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION &amp;
                                   smd/tlsph smd/hertz 1.5

    # [2:elastic x 2:elastic] Diagonal pair coefficient tlsph
    pair_coeff      2 2 smd/tlsph *COMMON 1000 500000.0 0.3 1.0 0.0 10 1.0 &amp;
                    *STRENGTH_LINEAR_PLASTIC 50000.0 0 &amp;
                    *EOS_LINEAR &amp;
                    *END

    # [2:elastic x 1:none] Off-diagonal pair coefficient (generic)
    pair_coeff      2 1 smd/hertz 250000.0

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>run this code by pressing <F5></p>
</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Synopsis of forcefield Class
============================

The `forcefield` class defines the core behavior for managing inter-particle interactions
in molecular dynamics simulations or similar physics-based models. It provides methods
to calculate interaction parameters, including pair styles, diagonal pair coefficients,
and off-diagonal pair coefficients, which are crucial for forcefield models.

Key Attributes:
---------------
- `PAIR_STYLE` (str): Defines the pair style command for the forcefield interactions.
- `PAIR_DIAGCOEFF` (str): Defines the command for calculating diagonal pair coefficients.
- `PAIR_OFFDIAGCOEFF` (str): Defines the command for calculating off-diagonal pair coefficients.
- `parameters` (parameterforcefield): Stores the parameters used for interaction evaluations.
- `beadtype` (int): The bead type used in the forcefield model.
- `userid` (str): A unique identifier for the forcefield instance.

Key Methods:
------------
- `pair_style(printflag=True)`: Returns the pair style command based on the current
  `parameters`, `beadtype`, and `userid`.
- `pair_diagcoeff(printflag=True, i=None)`: Returns the diagonal pair coefficient command
  based on the current bead type `i` and `userid`. The bead type can be overridden.
- `pair_offdiagcoeff(o=None, printflag=True, i=None)`: Returns the off-diagonal pair
  coefficient command for interactions between two bead types or forcefield objects.
  The bead type `i` and the interacting forcefield `o` can be specified or overridden.



    --- forcefield methods for LAMMPS ---

    The superclass provides a collection of classes to define materials
    and forcefields. Note that the following hierarchy is used:
        &gt; forcefield() is the top class (to be called directly)
        &gt; customff(forcefield) defines a new forcefield so called customff
        &gt; customstyle(customff) defines a pair-style applicable to customff
        &gt; custommaterial(customstyle) defines a new material


    --- Material library (first implementations) ---

        w = water(beadtype=1, userid=&#34;fluid&#34;)
        w.parameters.Cp = 20
        print(&#34;\n&#34;*2,w)

        f = solidfood(beadtype=2, userid=&#34;elastic&#34;)
        print(&#34;\n&#34;*2,f)

        r = rigidwall(beadtype=3, userid=&#34;wall&#34;)
        print(&#34;\n&#34;*2,r)


    --- Template to define a material ---

          class mymaterial(myforcefield):
              userid = &#34;short name&#34;
              version = value
              def __init__(self, beadtype=1, userid=None):
                  super().__init__()
                  if userid!=None: self.userid = userid
                  self.name.material&#34;] = &#34;short of the material&#34;
                  self.description.material&#34;] = &#34;full description&#34;
                  self.beadtype = beadtype
                  self.parameters = parameterforcefield(
                      param1 = value1,
                      param2 = value2,
                      param3 = &#34;math expression with ${param1, ${param2}&#34;
                  )


    --- Example of outputs | LAMMPS:SMD:tlsph:solidfood ---

        ========================== [ elastic | version=0.1 ] ===========================

          Bead of type 2 = [LAMMPS:SMD:tlsph:solidfood]
          -----------------:----------------------------------------
                        rho: 1000
                         c0: 10.0
                          E: 5*${c0}^2*${rho}
                         nu: 0.3
                         q1: 1.0
                         q2: 0.0
                         Hg: 10
                         Cp: 1.0
                sigma_yield: 0.1*${E}
                  hardening: 0
              contact_scale: 1.5
          contact_stiffness: 2.5*${c0}^2*${rho}
          -----------------:----------------------------------------
        forcefield object with 12 parameters

        ............................... [ description ] ................................

                #       LAMMPS:SMD - solid, liquid, rigid forcefields (continuum mechanics)
                #       SMD:TLSPH - total Lagrangian for solids
                #       food beads - solid behavior

        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ [ methods ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        replace FFi,FFj by your variable names &lt;&lt;&lt;
                To assign a type, use: FFi.beadtype = integer value
                Use the methods FFi.pair_style() and FFi.pair_coeff(FFj)
                Note for pairs: the caller object is i (FFi), the argument is j (FFj or j)

        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ [ template ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


            # [2:elastic] PAIR STYLE SMD
            pair_style      hybrid/overlay smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION &amp;
                                           smd/tlsph smd/hertz 1.5


            # [2:elastic x 2:elastic] Diagonal pair coefficient tlsph
            pair_coeff      2 2 smd/tlsph *COMMON 1000 500000.0 0.3 1.0 0.0 10 1.0 &amp;
                            *STRENGTH_LINEAR_PLASTIC 50000.0 0 &amp;
                            *EOS_LINEAR &amp;
                            *END


            # [2:elastic x 1:none] Off-diagonal pair coefficient (generic)
            pair_coeff      2 1 smd/hertz 250000.0


        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    run this code by pressing &lt;F5&gt;

&#34;&#34;&#34;

__project__ = &#34;Pizza3&#34;
__author__ = &#34;Olivier Vitrac&#34;
__copyright__ = &#34;Copyright 2022&#34;
__credits__ = [&#34;Olivier Vitrac&#34;]
__license__ = &#34;GPLv3&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;0.9971&#34;


# INRAE\Olivier Vitrac - rev. 2022-10-10
# contact: olivier.vitrac@agroparistech.fr

# History
# 2022-02-12 early version
# 2022-02-13 release candidate
# 2022-02-20 made compatible with the update private.mstruct.py
# 2022-02-28 fix class inheritance with mutable type, update is carried with + and struct()
# 2022-03-02 fix off-diagonal order for i,j
# 2022-03-19 standardized pizza path
# 2022-04-16 add saltTLSPH() forcefield in the material library, and document it better
# 2022-05-16 force sortdefintions for + and += with parameterforcefield()
# 2022-05-17 direct use of pizza.private.mstruct.paramauto()
# 2023-07-25 fix forcefield (deepduplicate instead of duplicate)
# 2024-09-10 updated documentation for pizza.forcefield (to be read along with pizza.dforcefield)
# 2024-09-12 upgrading of parameterforcefield
# 2024-09-21 dforcefield and forcefield can be combined indifferently (no precedence)
# 2024-10-10 fix the dynamic parameterization with dforcefield (more overrides)

# %% Dependencies
import types
# All forcefield parameters are stored Ã  la Matlab in a structure
from pizza.private.mstruct import struct,paramauto

__all__ = [&#39;forcefield&#39;, &#39;none&#39;, &#39;paramauto&#39;, &#39;parameterforcefield&#39;, &#39;rigidwall&#39;, &#39;saltTLSPH&#39;, &#39;smd&#39;, &#39;solidfood&#39;, &#39;struct&#39;, &#39;tlsph&#39;, &#39;ulsph&#39;, &#39;water&#39;]


# %% Parent class (not to be called directly)
# Note that some attributes are stored in the instances but in the class itself
#   recommendation 1: Recreate/derive a class when possible
#   recommendation 2: __dict__ list only properties in the instance,
#                     use getallattributes() to see all attributes

# container of forcefield parameters
class parameterforcefield(paramauto):
    &#34;&#34;&#34; class of forcefields parameters, derived from param
        note that conctanating two forcefields force them
        to to be sorted
    &#34;&#34;&#34;
    _type = &#34;FF&#34;
    _fulltype = &#34;forcefield&#34;
    _ftype = &#34;parameter&#34;
    _maxdisplay = 80

    # same strategy as used in dscript for forcing  _returnerror = False (added 2024-09-12)
    def __init__(self, _protection=False, _evaluation=True, sortdefinitions=False, **kwargs):
        &#34;&#34;&#34;
        Constructor for parameterforcefield. It forces the parent&#39;s _returnerror parameter to False.

        Parameters:
        -----------
        _protection : bool, optional
            Whether to enable protection on the parameters (default: False).
        _evaluation : bool, optional
            Whether evaluation is enabled for the parameters (default: True).
        sortdefinitions : bool, optional
            Whether to sort definitions upon initialization (default: False).
        **kwargs : dict
            Additional keyword arguments for the parent class.
        &#34;&#34;&#34;
        # Call the parent class constructor
        super().__init__(_protection=_protection, _evaluation=_evaluation, sortdefinitions=sortdefinitions, **kwargs)
        # Override the _returnerror attribute at the instance level
        self._returnerror = False


# core class
class forcefield():
    &#34;&#34;&#34;
    The `forcefield` class represents the core implementation of a forcefield model,
    defining interaction parameters and coefficients for simulations. This class provides
    methods to handle pair styles, diagonal pair coefficients, and off-diagonal pair coefficients,
    which are essential for simulating inter-particle interactions in molecular dynamics or
    other physics-based simulations.

    Attributes:
    -----------
    PAIR_STYLE : str
        The default pair style command for the forcefield interactions.

    PAIR_DIAGCOEFF : str
        The default command for calculating diagonal pair coefficients.

    PAIR_OFFDIAGCOEFF : str
        The default command for calculating off-diagonal pair coefficients.

    parameters : parameterforcefield
        An instance of `parameterforcefield` that stores the parameters for
        evaluating interaction commands.

    beadtype : int
        The bead type associated with the current forcefield instance.

    userid : str
        A unique identifier for the forcefield instance, used in interaction commands.

    Methods:
    --------
    pair_style(printflag=True):
        Generate and return the pair style command based on the current parameters,
        beadtype, and userid.

    pair_diagcoeff(printflag=True, i=None):
        Generate and return the diagonal pair coefficients based on the current parameters,
        beadtype, and userid. The bead type `i` can be overridden with an optional argument.

    pair_offdiagcoeff(o=None, printflag=True, i=None):
        Generate and return the off-diagonal pair coefficients between two different
        bead types or forcefield objects. The bead type `i` can be overridden, and the
        interaction with another forcefield object `o` can also be specified.

    Notes:
    ------
    - This class is intended to be extended by specific forcefield types such as `ulsph`.
    - The parameters used in the interaction commands are dynamically evaluated using
      the `parameterforcefield` class, which provides the required values during runtime.
    &#34;&#34;&#34;

    # Main attributes (instance independent)
    name = struct(forcefield=&#34;undefined&#34;, style=&#34;undefined&#34;, material=&#34;undefined&#34;)
    description = struct(forcefield=&#34;missing&#34;, style=&#34;missing&#34;, material=&#34;missing&#34;)
    beadtype = 1  # default bead type
    parameters = parameterforcefield() # empty parameters object
    userid = &#34;undefined&#34;
    version = 0

    # print method for headers (static, no implicit argument)
    @staticmethod
    def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
        &#34;&#34;&#34; print header &#34;&#34;&#34;
        if txt==&#34;&#34;:
            print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
        else:
            print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))

    # Display/representation method
    # The method provides full help for the end-user
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        stamp = self.name.forcefield+&#34;:&#34;+self.name.style+&#34;:&#34;+self.name.material
        self.printheader(&#34;%s | version=%0.3g&#34; % (self.userid,self.version),filler=&#34;=&#34;)
        print(&#34;  Bead of type %d = [%s]&#34; % (self.beadtype,stamp))
        print(self.parameters)
        self.printheader(&#34;description&#34;,filler=&#34;.&#34;)
        print(&#34;\t# \t%s&#34; % self.description.forcefield)
        print(&#34;\t# \t%s&#34; % self.description.style)
        print(&#34;\t# \t%s&#34; % self.description.material)
        self.printheader(&#34;methods&#34;)
        print(&#34;\t   &gt;&gt;&gt; replace FFi,FFj by your variable names &lt;&lt;&lt;&#34;)
        print(&#34;\tTo assign a type, use: FFi.beadtype = integer value&#34;)
        print(&#34;\tUse the methods FFi.pair_style() and FFi.pair_coeff(FFj)&#34;)
        print(&#34;\tNote for pairs: the caller object is i (FFi), the argument is j (FFj or j)&#34;)
        self.printheader(&#34;template&#34;)
        self.pair_style()
        self.pair_diagcoeff()
        self.pair_offdiagcoeff()
        self.printheader(&#34;&#34;)
        return stamp

    # Extract attributes within the class
    def getallattributes(self):
        &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
        return {k: getattr(self, k) for k in dir(self) \
                if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}


    # Forcefield Methods: pair_style(), pair_coeff()
    # the substitution of LAMMPS variables is carried out with the method
    # parameters.format() method implemented in struct and inherited by parameterforcefield()
    def pair_style(self,printflag=False,verbose=True, raw=False,USER=None,beadtype=None,userid=None):
        &#34;&#34;&#34;
        Generate and return the pair style command for the current forcefield instance.

        This method creates a formatted pair style command based on the interaction parameters
        stored in the `parameters` attribute. It allows customization of the command using the
        `beadtype` and `userid` arguments. The behavior can be altered by passing a `USER` object
        or opting for the raw command template.

        Parameters:
        -----------
        printflag : bool, optional, default=False
            If True, the generated pair style command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        raw : bool, optional, default=False
            If True, returns the raw template of the pair style without any interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier used in the generated command. If not provided, the
            instance&#39;s beadtype is used.
        userid : str, optional, default=None
            The user identifier to include in the formatted command. Defaults to the instance&#39;s
            userid if not specified.

        Returns:
        --------
        str
            The formatted pair style command string.

        Raises:
        -------
        TypeError
            If `USER` is provided but is not of type `struct` or derived from `struct`.
        &#34;&#34;&#34;
        # raw format
        if raw:
            return self.PAIR_STYLE
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # cmd
        cmd = parameters.formateval(self.PAIR_STYLE)
        # Replace [comment] with the formatted comment (e.g., &#34;[2:my_user_id]&#34;)
        cmd = cmd.replace(&#34;[comment]&#34;,&#34;[%d:%s]&#34; % (beadtype, userid) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


    def pair_diagcoeff(self,printflag=False,verbose=True, i=None,raw=False,USER=None,beadtype=None,userid=None):
        &#34;&#34;&#34;
        Generate and return the diagonal pair coefficients for the current forcefield instance.

        This method evaluates the diagonal pair coefficients based on the interaction parameters,
        the bead type (`beadtype`), and the user identifier (`userid`). The bead type `i` can
        be overridden by passing it as an argument. The method supports returning the raw template
        without evaluation and modifying parameters using a `USER` object.

        Parameters:
        -----------
        printflag : bool, optional, default=False
            If True, the generated diagonal pair coefficient command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        i : int, optional, default=None
            The bead type used for evaluating the diagonal pair coefficients. If not provided,
            defaults to the instance&#39;s bead type (`self.beadtype`).
        raw : bool, optional, default=False
            If True, returns the raw template for the diagonal pair coefficients without interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier to use in the command. Defaults to the instance&#39;s beadtype
            if not provided.
        userid : str, optional, default=None
            The user identifier to include in the formatted command. Defaults to the instance&#39;s
            userid if not specified.

        Returns:
        --------
        str
            The formatted diagonal pair coefficient command string.

        Raises:
        -------
        TypeError
            If `USER` is provided but is not of type `struct` or derived from `struct`.
        &#34;&#34;&#34;
        # raw format
        if raw:
            return self.PAIR_DIAGCOEFF
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # diagonal index
        i = i if i is not None else beadtype
        # cmd
        cmd = parameters.formateval(self.PAIR_DIAGCOEFF) % (i,i)
        # Replace [comment] with the formatted string, without using .format()
        cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, userid, i, userid) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


    def pair_offdiagcoeff(self,o=None,printflag=False,verbose=True,i=None,raw=False,USER=None,beadtype=None,userid=None,oname=None):
        &#34;&#34;&#34;
        Generate and return the off-diagonal pair coefficients for the current forcefield instance.

        This method evaluates the off-diagonal pair coefficients between two different bead types
        or forcefield objects, using the interaction parameters, bead type, and user identifier.
        The bead type `i` can be overridden, and the interaction with another forcefield object `o`
        can also be specified.

        Parameters:
        -----------
        o : forcefield or int, optional, default=None
            The second forcefield object or bead type used for calculating the off-diagonal
            pair coefficients. If not provided, the method assumes interactions between
            beads of the same type.
        printflag : bool, optional, default=False
            If True, the generated off-diagonal pair coefficient command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        i : int, optional, default=None
            The bead type used for the current forcefield instance. If not provided,
            defaults to the instance&#39;s bead type (`self.beadtype`).
        raw : bool, optional, default=False
            If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier used in the command. Defaults to the instance&#39;s beadtype
            if not provided.
        userid : str, optional, default=None
            The user identifier included in the formatted command. Defaults to the instance&#39;s
            userid if not specified.
        oname : str, optional, default=None
            The user identifier for the second forcefield or bead type. If not provided, it
            defaults to `&#34;none&#34;`.

        Returns:
        --------
        str
            The formatted off-diagonal pair coefficient command string.

        Raises:
        -------
        TypeError
            If `USER` is not of type `struct` or derived from `struct`.
        IndexError
            If the first argument `o` is not a forcefield object or an integer.
        &#34;&#34;&#34;

        # raw format
        if raw:
            return self.PAIR_OFFDIAGCOEFF
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
            i = i if i is not None else beadtype
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # Determine the first bead type (i)
        i = i if i is not None else beadtype
        # Determine the second bead type (j) based on o
        if o is None:
            j = i
        elif hasattr(o, &#39;beadtype&#39;):
            j = o.beadtype
        elif isinstance(o, (float, int)):
            j = int(o)
        else:
            raise IndexError(&#34;The first argument should be a forcefield object or an integer representing bead type.&#34;)
        # Adjust j if it matches i (to ensure off-diagonal interaction)
        if j == i:
            j = i - 1 if i &gt; 1 else i + 1
        oname = oname if oname is not None else o.userid if hasattr(o, &#34;userid&#34;) else &#34;none&#34;
        # cmd
        cmd = parameters.formateval(self.PAIR_OFFDIAGCOEFF) % (min(i,j),max(j,i))
        # Replace [comment] with the formatted string, without using .format()
        cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, self.userid, j, oname) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


# %% Forecefield library
# This section can be upgraded by the end-user according to the manual of each style
# numerical value shoud be declared with variable/parameter with the same syntax as in LAMMPS.
# Note that you can copy directly LAMMPS code between triple &#34;&#34;&#34; for templates
# Main templates are strings: PAIR_STYLE, PAIR_DIAGCOEFF, PAIR_OFFDIAGCOEFF
#
# ${param} represents the variable called &#34;param&#34;, and whose value will be defined
# in the parameters section of the material class as parameters.param = value
#
# use {comment} to add an automatic comment
# %d in PAIR_COEFF represent place holder for corresponding beadtype
#
# The subsitutions are managed by the parent class forcefield().

# BEGIN PAIR-STYLE FORCEFIELD ===========================
class smd(forcefield):
    &#34;&#34;&#34; SMD forcefield &#34;&#34;&#34;
    name = forcefield.name + struct(forcefield=&#34;LAMMPS:SMD&#34;)
    description = forcefield.description + struct(forcefield=&#34;LAMMPS:SMD - solid, liquid, rigid forcefields (continuum mechanics)&#34;)

    # forcefield definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_STYLE = &#34;&#34;&#34;
    # [comment] PAIR STYLE SMD
    pair_style      hybrid/overlay smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION &amp;
                                   smd/tlsph smd/hertz ${contact_scale}
    &#34;&#34;&#34;
# END PAIR-STYLE FORCEFIELD ===========================


# BEGIN PAIR-COEFF FORCEFIELD ===========================
class ulsph(smd):
    &#34;&#34;&#34; SMD:ULSPH forcefield (updated Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;ulsph&#34;)
    description = smd.description + struct(style=&#34;SMD:ULSPH - updated Lagrangian for fluids - SPH-like&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Pair diagonal coefficient ulsph
    pair_coeff      %d %d smd/ulsph *COMMON ${rho} ${c0} ${q1} ${Cp} 0 &amp;
                    *EOS_TAIT ${taitexponent} &amp;
                    *END
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;
# END PAIR-COEFF FORCEFIELD ===========================


# BEGIN PAIR-COEFF FORCEFIELD ===========================
class tlsph(smd):
    &#34;&#34;&#34; SMD:TLSPH forcefield (total Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;tlsph&#34;)
    description = smd.description + struct(style=&#34;SMD:TLSPH - total Lagrangian for solids&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Diagonal pair coefficient tlsph
    pair_coeff      %d %d smd/tlsph *COMMON ${rho} ${E} ${nu} ${q1} ${q2} ${Hg} ${Cp} &amp;
                    *STRENGTH_LINEAR_PLASTIC ${sigma_yield} ${hardening} &amp;
                    *EOS_LINEAR &amp;
                    *END
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;
# END PAIR-COEFF FORCEFIELD ===========================


# BEGIN PAIR-COEFF FORCEFIELD ===========================
class none(smd):
    &#34;&#34;&#34; SMD:TLSPH forcefield (updated Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;none&#34;)
    description = smd.description + struct(style=&#34;no interactions&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Diagonal pair coefficient tlsph
    pair_coeff      %d %d none
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;
# END PAIR-COEFF FORCEFIELD ===========================



# %% Material library
# template:
#   class mymaterial(myforcefield):
#       userid = &#34;short name&#34;
#       version = value
#       def __init__(self, beadtype=1, userid=None):
#           super().__init__()
#           if userid!=None: self.userid = userid
#           self.name.material&#34;] = &#34;short of the material&#34;
#           self.description.material&#34;] = &#34;full description&#34;
#           self.beadtype = beadtype
#           self.parameters = parameterforcefield(
#               param1 = value1,
#               param2 = value2,
#               param3 = &#34;math expression with ${param1, ${param2}&#34;
#           )
#
# ATTENTION: ${param1} and ${param2} cannot be used in an expression
#            if they do not have been prealably defined

# BEGIN MATERIAL: WATER ========================================
class water(ulsph):
    &#34;&#34;&#34; water material (smd:ulsph): generic water model
            water()
            water(beadtype=index, userid=&#34;myfluid&#34;, USER=...)

            override any propery with USER.parameter (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=1000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.q1: standard artificial viscosity linear coefficient (default=1.0)
                USER.Cp: heat capacity of material -- not used here (default=1.0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = ulsph.name + struct(material=&#34;water&#34;)
    description = ulsph.description + struct(material=&#34;water beads - SPH-like&#34;)
    userid = &#39;water&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; water forcefield:
            water(beadtype=index, userid=&#34;myfluid&#34;) &#34;&#34;&#34;
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # water-water interactions
            rho = 1000,
            c0 = 10.0,
            q1 = 1.0,
            Cp = 1.0,
            taitexponent = 7,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;
            ) + USER # update with user properties if any

# END MATERIAL: WATER ==========================================


# BEGIN MATERIAL: SOLID FOOD ========================================
class solidfood(tlsph):
    &#34;&#34;&#34; solidfood material (smd:tlsph): model solid food object
            solidfood()
            solidfood(beadtype=index, userid=&#34;myfood&#34;, USER=...)

            override any propery with USER.property=value (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=1000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.E: Young&#39;s modulus in Pa (default=&#34;5*${c0}^2*${rho}&#34;)
                USER.nu: Poisson ratio (default=0.3)
                USER.q1: standard artificial viscosity linear coefficient (default=1.0)
                USER.q2: standard artificial viscosity quadratic coefficient (default=0)
                USER.Hg: hourglass control coefficient (default=10.0)
                USER.Cp: heat capacity of material -- not used here (default=1.0)
                USER.sigma_yield: plastic yield stress in Pa (default=&#34;0.1*${E}&#34;)
                USER.hardening: hardening parameter (default=0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = tlsph.name + struct(material=&#34;solidfood&#34;)
    description = tlsph.description + struct(material=&#34;food beads - solid behavior&#34;)
    userid = &#39;solidfood&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; food forcefield:
            solidfood(beadtype=index, userid=&#34;myfood&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # food-food interactions
            rho = 1000,
            c0 = 10.0,
            E = &#34;5*${c0}^2*${rho}&#34;,
            nu = 0.3,
            q1 = 1.0,
            q2 = 0.0,
            Hg = 10.0,
            Cp = 1.0,
            sigma_yield = &#34;0.1*${E}&#34;,
            hardening = 0,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#34;2.5*${c0}^2*${rho}&#34;
            ) + USER # update with user properties if any

# END MATERIAL: SOLID FOOD ==========================================


# BEGIN MATERIAL: SALT TLSPH ========================================
class saltTLSPH(tlsph):
    &#34;&#34;&#34; SALTLSPH (smd:tlsph): ongoing &#34;salting&#34; beadtype for rheology control
            saltTLSPH()
            saltTLSPH(beadtype=index, userid=&#34;salt&#34;, USER=...)

            override any property with USER.property = value
    &#34;&#34;&#34;
    name = tlsph.name + struct(material=&#34;solidfood&#34;)
    description = tlsph.description + struct(material=&#34;food beads - solid behavior&#34;)
    userid = &#39;&#34;salt&#34;&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; saltTLSPH forcefield:
            saltTLSPH(beadtype=index, userid=&#34;salt&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # food-food interactions
            rho = 1000,
            c0 = 10.0,
            E = &#39;5*${c0}^2*${rho}&#39;,
            nu = 0.3,
            q1 = 1.0,
            q2 = 0.0,
            Hg = 10,
            Cp = 1.0,
            sigma_yield = &#39;0.1*${E}&#39;,
            hardening = 0,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;
            ) + USER # update with user properties if any

# END MATERIAL: SOLID FOOD ==========================================



# BEGIN MATERIAL: RIGID WALLS ========================================
class rigidwall(none):
    &#34;&#34;&#34; rigid walls (smd:none):
            rigidwall()
            rigidwall(beadtype=index, userid=&#34;wall&#34;, USER=...)

            override any propery with USER.parameter (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=3000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = none.name + struct(material=&#34;walls&#34;)
    description = none.description + struct(material=&#34;rigid walls&#34;)
    userid = &#39;solidfood&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; rigidwall forcefield:
            rigidwall(beadtype=index, userid=&#34;mywall&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            rho = 3000,
            c0 = 10.0,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;,
            contact_scale = 1.5
            ) + USER # update with user properties if any


# END MATERIAL: RIGID WALLS ==========================================


# %% DEBUG
# ===================================================
# main()
# ===================================================
# for debugging purposes (code called as a script)
# the code is called from here
# ===================================================
if __name__ == &#39;__main__&#39;:
    w = water(beadtype=1, userid=&#34;fluid&#34;)
    w.parameters.Cp = 20
    print(&#34;\n&#34;*2,w)
    f = solidfood(beadtype=2, userid=&#34;elastic&#34;)
    print(&#34;\n&#34;*2,f)
    r = rigidwall(beadtype=3, userid=&#34;wall&#34;)
    print(&#34;\n&#34;*2,r)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="forcefield.forcefield"><code class="flex name class">
<span>class <span class="ident">forcefield</span></span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></code> class represents the core implementation of a forcefield model,
defining interaction parameters and coefficients for simulations. This class provides
methods to handle pair styles, diagonal pair coefficients, and off-diagonal pair coefficients,
which are essential for simulating inter-particle interactions in molecular dynamics or
other physics-based simulations.</p>
<h2 id="attributes">Attributes:</h2>
<p>PAIR_STYLE : str
The default pair style command for the forcefield interactions.</p>
<p>PAIR_DIAGCOEFF : str
The default command for calculating diagonal pair coefficients.</p>
<p>PAIR_OFFDIAGCOEFF : str
The default command for calculating off-diagonal pair coefficients.</p>
<p>parameters : parameterforcefield
An instance of <code><a title="forcefield.parameterforcefield" href="#forcefield.parameterforcefield">parameterforcefield</a></code> that stores the parameters for
evaluating interaction commands.</p>
<p>beadtype : int
The bead type associated with the current forcefield instance.</p>
<p>userid : str
A unique identifier for the forcefield instance, used in interaction commands.</p>
<h2 id="methods">Methods:</h2>
<p>pair_style(printflag=True):
Generate and return the pair style command based on the current parameters,
beadtype, and userid.</p>
<p>pair_diagcoeff(printflag=True, i=None):
Generate and return the diagonal pair coefficients based on the current parameters,
beadtype, and userid. The bead type <code>i</code> can be overridden with an optional argument.</p>
<p>pair_offdiagcoeff(o=None, printflag=True, i=None):
Generate and return the off-diagonal pair coefficients between two different
bead types or forcefield objects. The bead type <code>i</code> can be overridden, and the
interaction with another forcefield object <code>o</code> can also be specified.</p>
<h2 id="notes">Notes:</h2>
<ul>
<li>This class is intended to be extended by specific forcefield types such as <code><a title="forcefield.ulsph" href="#forcefield.ulsph">ulsph</a></code>.</li>
<li>The parameters used in the interaction commands are dynamically evaluated using
the <code><a title="forcefield.parameterforcefield" href="#forcefield.parameterforcefield">parameterforcefield</a></code> class, which provides the required values during runtime.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class forcefield():
    &#34;&#34;&#34;
    The `forcefield` class represents the core implementation of a forcefield model,
    defining interaction parameters and coefficients for simulations. This class provides
    methods to handle pair styles, diagonal pair coefficients, and off-diagonal pair coefficients,
    which are essential for simulating inter-particle interactions in molecular dynamics or
    other physics-based simulations.

    Attributes:
    -----------
    PAIR_STYLE : str
        The default pair style command for the forcefield interactions.

    PAIR_DIAGCOEFF : str
        The default command for calculating diagonal pair coefficients.

    PAIR_OFFDIAGCOEFF : str
        The default command for calculating off-diagonal pair coefficients.

    parameters : parameterforcefield
        An instance of `parameterforcefield` that stores the parameters for
        evaluating interaction commands.

    beadtype : int
        The bead type associated with the current forcefield instance.

    userid : str
        A unique identifier for the forcefield instance, used in interaction commands.

    Methods:
    --------
    pair_style(printflag=True):
        Generate and return the pair style command based on the current parameters,
        beadtype, and userid.

    pair_diagcoeff(printflag=True, i=None):
        Generate and return the diagonal pair coefficients based on the current parameters,
        beadtype, and userid. The bead type `i` can be overridden with an optional argument.

    pair_offdiagcoeff(o=None, printflag=True, i=None):
        Generate and return the off-diagonal pair coefficients between two different
        bead types or forcefield objects. The bead type `i` can be overridden, and the
        interaction with another forcefield object `o` can also be specified.

    Notes:
    ------
    - This class is intended to be extended by specific forcefield types such as `ulsph`.
    - The parameters used in the interaction commands are dynamically evaluated using
      the `parameterforcefield` class, which provides the required values during runtime.
    &#34;&#34;&#34;

    # Main attributes (instance independent)
    name = struct(forcefield=&#34;undefined&#34;, style=&#34;undefined&#34;, material=&#34;undefined&#34;)
    description = struct(forcefield=&#34;missing&#34;, style=&#34;missing&#34;, material=&#34;missing&#34;)
    beadtype = 1  # default bead type
    parameters = parameterforcefield() # empty parameters object
    userid = &#34;undefined&#34;
    version = 0

    # print method for headers (static, no implicit argument)
    @staticmethod
    def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
        &#34;&#34;&#34; print header &#34;&#34;&#34;
        if txt==&#34;&#34;:
            print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
        else:
            print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))

    # Display/representation method
    # The method provides full help for the end-user
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        stamp = self.name.forcefield+&#34;:&#34;+self.name.style+&#34;:&#34;+self.name.material
        self.printheader(&#34;%s | version=%0.3g&#34; % (self.userid,self.version),filler=&#34;=&#34;)
        print(&#34;  Bead of type %d = [%s]&#34; % (self.beadtype,stamp))
        print(self.parameters)
        self.printheader(&#34;description&#34;,filler=&#34;.&#34;)
        print(&#34;\t# \t%s&#34; % self.description.forcefield)
        print(&#34;\t# \t%s&#34; % self.description.style)
        print(&#34;\t# \t%s&#34; % self.description.material)
        self.printheader(&#34;methods&#34;)
        print(&#34;\t   &gt;&gt;&gt; replace FFi,FFj by your variable names &lt;&lt;&lt;&#34;)
        print(&#34;\tTo assign a type, use: FFi.beadtype = integer value&#34;)
        print(&#34;\tUse the methods FFi.pair_style() and FFi.pair_coeff(FFj)&#34;)
        print(&#34;\tNote for pairs: the caller object is i (FFi), the argument is j (FFj or j)&#34;)
        self.printheader(&#34;template&#34;)
        self.pair_style()
        self.pair_diagcoeff()
        self.pair_offdiagcoeff()
        self.printheader(&#34;&#34;)
        return stamp

    # Extract attributes within the class
    def getallattributes(self):
        &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
        return {k: getattr(self, k) for k in dir(self) \
                if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}


    # Forcefield Methods: pair_style(), pair_coeff()
    # the substitution of LAMMPS variables is carried out with the method
    # parameters.format() method implemented in struct and inherited by parameterforcefield()
    def pair_style(self,printflag=False,verbose=True, raw=False,USER=None,beadtype=None,userid=None):
        &#34;&#34;&#34;
        Generate and return the pair style command for the current forcefield instance.

        This method creates a formatted pair style command based on the interaction parameters
        stored in the `parameters` attribute. It allows customization of the command using the
        `beadtype` and `userid` arguments. The behavior can be altered by passing a `USER` object
        or opting for the raw command template.

        Parameters:
        -----------
        printflag : bool, optional, default=False
            If True, the generated pair style command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        raw : bool, optional, default=False
            If True, returns the raw template of the pair style without any interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier used in the generated command. If not provided, the
            instance&#39;s beadtype is used.
        userid : str, optional, default=None
            The user identifier to include in the formatted command. Defaults to the instance&#39;s
            userid if not specified.

        Returns:
        --------
        str
            The formatted pair style command string.

        Raises:
        -------
        TypeError
            If `USER` is provided but is not of type `struct` or derived from `struct`.
        &#34;&#34;&#34;
        # raw format
        if raw:
            return self.PAIR_STYLE
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # cmd
        cmd = parameters.formateval(self.PAIR_STYLE)
        # Replace [comment] with the formatted comment (e.g., &#34;[2:my_user_id]&#34;)
        cmd = cmd.replace(&#34;[comment]&#34;,&#34;[%d:%s]&#34; % (beadtype, userid) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


    def pair_diagcoeff(self,printflag=False,verbose=True, i=None,raw=False,USER=None,beadtype=None,userid=None):
        &#34;&#34;&#34;
        Generate and return the diagonal pair coefficients for the current forcefield instance.

        This method evaluates the diagonal pair coefficients based on the interaction parameters,
        the bead type (`beadtype`), and the user identifier (`userid`). The bead type `i` can
        be overridden by passing it as an argument. The method supports returning the raw template
        without evaluation and modifying parameters using a `USER` object.

        Parameters:
        -----------
        printflag : bool, optional, default=False
            If True, the generated diagonal pair coefficient command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        i : int, optional, default=None
            The bead type used for evaluating the diagonal pair coefficients. If not provided,
            defaults to the instance&#39;s bead type (`self.beadtype`).
        raw : bool, optional, default=False
            If True, returns the raw template for the diagonal pair coefficients without interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier to use in the command. Defaults to the instance&#39;s beadtype
            if not provided.
        userid : str, optional, default=None
            The user identifier to include in the formatted command. Defaults to the instance&#39;s
            userid if not specified.

        Returns:
        --------
        str
            The formatted diagonal pair coefficient command string.

        Raises:
        -------
        TypeError
            If `USER` is provided but is not of type `struct` or derived from `struct`.
        &#34;&#34;&#34;
        # raw format
        if raw:
            return self.PAIR_DIAGCOEFF
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # diagonal index
        i = i if i is not None else beadtype
        # cmd
        cmd = parameters.formateval(self.PAIR_DIAGCOEFF) % (i,i)
        # Replace [comment] with the formatted string, without using .format()
        cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, userid, i, userid) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


    def pair_offdiagcoeff(self,o=None,printflag=False,verbose=True,i=None,raw=False,USER=None,beadtype=None,userid=None,oname=None):
        &#34;&#34;&#34;
        Generate and return the off-diagonal pair coefficients for the current forcefield instance.

        This method evaluates the off-diagonal pair coefficients between two different bead types
        or forcefield objects, using the interaction parameters, bead type, and user identifier.
        The bead type `i` can be overridden, and the interaction with another forcefield object `o`
        can also be specified.

        Parameters:
        -----------
        o : forcefield or int, optional, default=None
            The second forcefield object or bead type used for calculating the off-diagonal
            pair coefficients. If not provided, the method assumes interactions between
            beads of the same type.
        printflag : bool, optional, default=False
            If True, the generated off-diagonal pair coefficient command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        i : int, optional, default=None
            The bead type used for the current forcefield instance. If not provided,
            defaults to the instance&#39;s bead type (`self.beadtype`).
        raw : bool, optional, default=False
            If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier used in the command. Defaults to the instance&#39;s beadtype
            if not provided.
        userid : str, optional, default=None
            The user identifier included in the formatted command. Defaults to the instance&#39;s
            userid if not specified.
        oname : str, optional, default=None
            The user identifier for the second forcefield or bead type. If not provided, it
            defaults to `&#34;none&#34;`.

        Returns:
        --------
        str
            The formatted off-diagonal pair coefficient command string.

        Raises:
        -------
        TypeError
            If `USER` is not of type `struct` or derived from `struct`.
        IndexError
            If the first argument `o` is not a forcefield object or an integer.
        &#34;&#34;&#34;

        # raw format
        if raw:
            return self.PAIR_OFFDIAGCOEFF
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
            i = i if i is not None else beadtype
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # Determine the first bead type (i)
        i = i if i is not None else beadtype
        # Determine the second bead type (j) based on o
        if o is None:
            j = i
        elif hasattr(o, &#39;beadtype&#39;):
            j = o.beadtype
        elif isinstance(o, (float, int)):
            j = int(o)
        else:
            raise IndexError(&#34;The first argument should be a forcefield object or an integer representing bead type.&#34;)
        # Adjust j if it matches i (to ensure off-diagonal interaction)
        if j == i:
            j = i - 1 if i &gt; 1 else i + 1
        oname = oname if oname is not None else o.userid if hasattr(o, &#34;userid&#34;) else &#34;none&#34;
        # cmd
        cmd = parameters.formateval(self.PAIR_OFFDIAGCOEFF) % (min(i,j),max(j,i))
        # Replace [comment] with the formatted string, without using .format()
        cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, self.userid, j, oname) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="forcefield.smd" href="#forcefield.smd">smd</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forcefield.forcefield.beadtype"><code class="name">var <span class="ident">beadtype</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.forcefield.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.forcefield.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.forcefield.parameters"><code class="name">var <span class="ident">parameters</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.forcefield.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.forcefield.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="forcefield.forcefield.printheader"><code class="name flex">
<span>def <span class="ident">printheader</span></span>(<span>txt, align='^', width=80, filler='~')</span>
</code></dt>
<dd>
<div class="desc"><p>print header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
    &#34;&#34;&#34; print header &#34;&#34;&#34;
    if txt==&#34;&#34;:
        print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
    else:
        print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="forcefield.forcefield.getallattributes"><code class="name flex">
<span>def <span class="ident">getallattributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>advanced method to get all attributes including class ones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getallattributes(self):
    &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
    return {k: getattr(self, k) for k in dir(self) \
            if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}</code></pre>
</details>
</dd>
<dt id="forcefield.forcefield.pair_diagcoeff"><code class="name flex">
<span>def <span class="ident">pair_diagcoeff</span></span>(<span>self, printflag=False, verbose=True, i=None, raw=False, USER=None, beadtype=None, userid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the diagonal pair coefficients for the current forcefield instance.</p>
<p>This method evaluates the diagonal pair coefficients based on the interaction parameters,
the bead type (<code>beadtype</code>), and the user identifier (<code>userid</code>). The bead type <code>i</code> can
be overridden by passing it as an argument. The method supports returning the raw template
without evaluation and modifying parameters using a <code>USER</code> object.</p>
<h2 id="parameters">Parameters:</h2>
<p>printflag : bool, optional, default=False
If True, the generated diagonal pair coefficient command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
i : int, optional, default=None
The bead type used for evaluating the diagonal pair coefficients. If not provided,
defaults to the instance's bead type (<code>self.beadtype</code>).
raw : bool, optional, default=False
If True, returns the raw template for the diagonal pair coefficients without interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier to use in the command. Defaults to the instance's beadtype
if not provided.
userid : str, optional, default=None
The user identifier to include in the formatted command. Defaults to the instance's
userid if not specified.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted diagonal pair coefficient command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is provided but is not of type <code><a title="forcefield.struct" href="#forcefield.struct">struct</a></code> or derived from <code><a title="forcefield.struct" href="#forcefield.struct">struct</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_diagcoeff(self,printflag=False,verbose=True, i=None,raw=False,USER=None,beadtype=None,userid=None):
    &#34;&#34;&#34;
    Generate and return the diagonal pair coefficients for the current forcefield instance.

    This method evaluates the diagonal pair coefficients based on the interaction parameters,
    the bead type (`beadtype`), and the user identifier (`userid`). The bead type `i` can
    be overridden by passing it as an argument. The method supports returning the raw template
    without evaluation and modifying parameters using a `USER` object.

    Parameters:
    -----------
    printflag : bool, optional, default=False
        If True, the generated diagonal pair coefficient command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    i : int, optional, default=None
        The bead type used for evaluating the diagonal pair coefficients. If not provided,
        defaults to the instance&#39;s bead type (`self.beadtype`).
    raw : bool, optional, default=False
        If True, returns the raw template for the diagonal pair coefficients without interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier to use in the command. Defaults to the instance&#39;s beadtype
        if not provided.
    userid : str, optional, default=None
        The user identifier to include in the formatted command. Defaults to the instance&#39;s
        userid if not specified.

    Returns:
    --------
    str
        The formatted diagonal pair coefficient command string.

    Raises:
    -------
    TypeError
        If `USER` is provided but is not of type `struct` or derived from `struct`.
    &#34;&#34;&#34;
    # raw format
    if raw:
        return self.PAIR_DIAGCOEFF
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # diagonal index
    i = i if i is not None else beadtype
    # cmd
    cmd = parameters.formateval(self.PAIR_DIAGCOEFF) % (i,i)
    # Replace [comment] with the formatted string, without using .format()
    cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, userid, i, userid) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="forcefield.forcefield.pair_offdiagcoeff"><code class="name flex">
<span>def <span class="ident">pair_offdiagcoeff</span></span>(<span>self, o=None, printflag=False, verbose=True, i=None, raw=False, USER=None, beadtype=None, userid=None, oname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the off-diagonal pair coefficients for the current forcefield instance.</p>
<p>This method evaluates the off-diagonal pair coefficients between two different bead types
or forcefield objects, using the interaction parameters, bead type, and user identifier.
The bead type <code>i</code> can be overridden, and the interaction with another forcefield object <code>o</code>
can also be specified.</p>
<h2 id="parameters">Parameters:</h2>
<p>o : forcefield or int, optional, default=None
The second forcefield object or bead type used for calculating the off-diagonal
pair coefficients. If not provided, the method assumes interactions between
beads of the same type.
printflag : bool, optional, default=False
If True, the generated off-diagonal pair coefficient command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
i : int, optional, default=None
The bead type used for the current forcefield instance. If not provided,
defaults to the instance's bead type (<code>self.beadtype</code>).
raw : bool, optional, default=False
If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier used in the command. Defaults to the instance's beadtype
if not provided.
userid : str, optional, default=None
The user identifier included in the formatted command. Defaults to the instance's
userid if not specified.
oname : str, optional, default=None
The user identifier for the second forcefield or bead type. If not provided, it
defaults to <code>"none"</code>.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted off-diagonal pair coefficient command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is not of type <code><a title="forcefield.struct" href="#forcefield.struct">struct</a></code> or derived from <code><a title="forcefield.struct" href="#forcefield.struct">struct</a></code>.
IndexError
If the first argument <code>o</code> is not a forcefield object or an integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_offdiagcoeff(self,o=None,printflag=False,verbose=True,i=None,raw=False,USER=None,beadtype=None,userid=None,oname=None):
    &#34;&#34;&#34;
    Generate and return the off-diagonal pair coefficients for the current forcefield instance.

    This method evaluates the off-diagonal pair coefficients between two different bead types
    or forcefield objects, using the interaction parameters, bead type, and user identifier.
    The bead type `i` can be overridden, and the interaction with another forcefield object `o`
    can also be specified.

    Parameters:
    -----------
    o : forcefield or int, optional, default=None
        The second forcefield object or bead type used for calculating the off-diagonal
        pair coefficients. If not provided, the method assumes interactions between
        beads of the same type.
    printflag : bool, optional, default=False
        If True, the generated off-diagonal pair coefficient command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    i : int, optional, default=None
        The bead type used for the current forcefield instance. If not provided,
        defaults to the instance&#39;s bead type (`self.beadtype`).
    raw : bool, optional, default=False
        If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier used in the command. Defaults to the instance&#39;s beadtype
        if not provided.
    userid : str, optional, default=None
        The user identifier included in the formatted command. Defaults to the instance&#39;s
        userid if not specified.
    oname : str, optional, default=None
        The user identifier for the second forcefield or bead type. If not provided, it
        defaults to `&#34;none&#34;`.

    Returns:
    --------
    str
        The formatted off-diagonal pair coefficient command string.

    Raises:
    -------
    TypeError
        If `USER` is not of type `struct` or derived from `struct`.
    IndexError
        If the first argument `o` is not a forcefield object or an integer.
    &#34;&#34;&#34;

    # raw format
    if raw:
        return self.PAIR_OFFDIAGCOEFF
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
        i = i if i is not None else beadtype
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # Determine the first bead type (i)
    i = i if i is not None else beadtype
    # Determine the second bead type (j) based on o
    if o is None:
        j = i
    elif hasattr(o, &#39;beadtype&#39;):
        j = o.beadtype
    elif isinstance(o, (float, int)):
        j = int(o)
    else:
        raise IndexError(&#34;The first argument should be a forcefield object or an integer representing bead type.&#34;)
    # Adjust j if it matches i (to ensure off-diagonal interaction)
    if j == i:
        j = i - 1 if i &gt; 1 else i + 1
    oname = oname if oname is not None else o.userid if hasattr(o, &#34;userid&#34;) else &#34;none&#34;
    # cmd
    cmd = parameters.formateval(self.PAIR_OFFDIAGCOEFF) % (min(i,j),max(j,i))
    # Replace [comment] with the formatted string, without using .format()
    cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, self.userid, j, oname) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="forcefield.forcefield.pair_style"><code class="name flex">
<span>def <span class="ident">pair_style</span></span>(<span>self, printflag=False, verbose=True, raw=False, USER=None, beadtype=None, userid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the pair style command for the current forcefield instance.</p>
<p>This method creates a formatted pair style command based on the interaction parameters
stored in the <code>parameters</code> attribute. It allows customization of the command using the
<code>beadtype</code> and <code>userid</code> arguments. The behavior can be altered by passing a <code>USER</code> object
or opting for the raw command template.</p>
<h2 id="parameters">Parameters:</h2>
<p>printflag : bool, optional, default=False
If True, the generated pair style command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
raw : bool, optional, default=False
If True, returns the raw template of the pair style without any interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier used in the generated command. If not provided, the
instance's beadtype is used.
userid : str, optional, default=None
The user identifier to include in the formatted command. Defaults to the instance's
userid if not specified.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted pair style command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is provided but is not of type <code><a title="forcefield.struct" href="#forcefield.struct">struct</a></code> or derived from <code><a title="forcefield.struct" href="#forcefield.struct">struct</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_style(self,printflag=False,verbose=True, raw=False,USER=None,beadtype=None,userid=None):
    &#34;&#34;&#34;
    Generate and return the pair style command for the current forcefield instance.

    This method creates a formatted pair style command based on the interaction parameters
    stored in the `parameters` attribute. It allows customization of the command using the
    `beadtype` and `userid` arguments. The behavior can be altered by passing a `USER` object
    or opting for the raw command template.

    Parameters:
    -----------
    printflag : bool, optional, default=False
        If True, the generated pair style command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    raw : bool, optional, default=False
        If True, returns the raw template of the pair style without any interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier used in the generated command. If not provided, the
        instance&#39;s beadtype is used.
    userid : str, optional, default=None
        The user identifier to include in the formatted command. Defaults to the instance&#39;s
        userid if not specified.

    Returns:
    --------
    str
        The formatted pair style command string.

    Raises:
    -------
    TypeError
        If `USER` is provided but is not of type `struct` or derived from `struct`.
    &#34;&#34;&#34;
    # raw format
    if raw:
        return self.PAIR_STYLE
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # cmd
    cmd = parameters.formateval(self.PAIR_STYLE)
    # Replace [comment] with the formatted comment (e.g., &#34;[2:my_user_id]&#34;)
    cmd = cmd.replace(&#34;[comment]&#34;,&#34;[%d:%s]&#34; % (beadtype, userid) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="forcefield.none"><code class="flex name class">
<span>class <span class="ident">none</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD:TLSPH forcefield (updated Lagrangian)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class none(smd):
    &#34;&#34;&#34; SMD:TLSPH forcefield (updated Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;none&#34;)
    description = smd.description + struct(style=&#34;no interactions&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Diagonal pair coefficient tlsph
    pair_coeff      %d %d none
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="forcefield.smd" href="#forcefield.smd">smd</a></li>
<li><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="forcefield.rigidwall" href="#forcefield.rigidwall">rigidwall</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forcefield.none.PAIR_DIAGCOEFF"><code class="name">var <span class="ident">PAIR_DIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.none.PAIR_OFFDIAGCOEFF"><code class="name">var <span class="ident">PAIR_OFFDIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.none.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.none.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="forcefield.smd" href="#forcefield.smd">smd</a></b></code>:
<ul class="hlist">
<li><code><a title="forcefield.smd.getallattributes" href="#forcefield.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="forcefield.smd.pair_diagcoeff" href="#forcefield.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="forcefield.smd.pair_offdiagcoeff" href="#forcefield.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="forcefield.smd.pair_style" href="#forcefield.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="forcefield.smd.printheader" href="#forcefield.forcefield.printheader">printheader</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="forcefield.paramauto"><code class="flex name class">
<span>class <span class="ident">paramauto</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-paramauto">Class: <code><a title="forcefield.paramauto" href="#forcefield.paramauto">paramauto</a></code></h1>
<p>A subclass of <code>param</code> with enhanced handling for automatic sorting and evaluation
of definitions. The <code><a title="forcefield.paramauto" href="#forcefield.paramauto">paramauto</a></code> class ensures that all fields are sorted to resolve
dependencies, allowing seamless stacking of partially defined objects.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Inherits all functionalities of <code>param</code>.</li>
<li>Automatically sorts definitions for dependency resolution.</li>
<li>Simplifies handling of partial definitions in dynamic structures.</li>
<li>Supports safe concatenation of definitions.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="automatic-dependency-sorting">Automatic Dependency Sorting</h4>
<p>Definitions are automatically sorted to resolve dependencies:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${b}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${b} (= 3)
# --------
</code></pre>
<h4 id="handling-missing-definitions">Handling Missing Definitions</h4>
<p>Unresolved dependencies raise warnings but do not block execution:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${d}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-inheritance">Concatenation and Inheritance</h3>
<p>Concatenating <code><a title="forcefield.paramauto" href="#forcefield.paramauto">paramauto</a></code> objects resolves definitions:</p>
<pre><code class="language-python">p1 = paramauto(a=1, b=&quot;${a}+2&quot;)
p2 = paramauto(c=&quot;${b}*3&quot;)
p3 = p1 + p2
p3.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 2 (= 3)
#      c: ${b} * 3 (= 9)
# --------
</code></pre>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Automatically sorts fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate all fields, resolving dependencies.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display all fields with their resolved values.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="overloaded-operators">Overloaded Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenates two <code><a title="forcefield.paramauto" href="#forcefield.paramauto">paramauto</a></code> objects, resolving dependencies.</li>
<li><code>+=</code>: Updates the current object with another, resolving dependencies.</li>
<li><code>len()</code>: Number of fields.</li>
<li><code>in</code>: Check for field existence.</li>
</ul>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="partial-definitions">Partial Definitions</h4>
<p>The <code><a title="forcefield.paramauto" href="#forcefield.paramauto">paramauto</a></code> class simplifies handling of partially defined fields:</p>
<pre><code class="language-python">p = paramauto(a=&quot;${d}&quot;, b=&quot;${a}+1&quot;)
p.disp()
# Warning: Unable to resolve dependencies.
# --------
#      a: ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
#      b: ${a} + 1 (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------

p.d = 10
p.disp()
# Dependencies are resolved:
# --------
#      d: 10
#      a: ${d} (= 10)
#      b: ${a} + 1 (= 11)
# --------
</code></pre>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>The <code><a title="forcefield.paramauto" href="#forcefield.paramauto">paramauto</a></code> class is computationally more intensive than <code>param</code> due to automatic sorting.</li>
<li>It is ideal for managing dynamic systems with complex interdependencies.</li>
</ul>
<h3 id="examples_1">Examples</h3>
<pre><code>            p = paramauto()
            p.b = "${aa}"
            p.disp()
        yields
            WARNING: unable to interpret 1/1 expressions in "definitions"
              -----------:----------------------------------------
                        b: ${aa}
                         = &lt; undef definition "${aa}" &gt;
              -----------:----------------------------------------
              p.aa = 2
              p.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
            -----------:----------------------------------------
            q = paramauto(c="${aa}+${b}")+p
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
                      c: ${aa}+${b}
                       = 4
            -----------:----------------------------------------
            q.aa = 30
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 30
                      b: ${aa}
                       = 30
                      c: ${aa}+${b}
                       = 60
            -----------:----------------------------------------
            q.aa = "${d}"
            q.disp()
        yields multiple errors (recursion)
        WARNING: unable to interpret 3/3 expressions in "definitions"
          -----------:----------------------------------------
                   aa: ${d}
                     = &lt; undef definition "${d}" &gt;
                    b: ${aa}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                    c: ${aa}+${b}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
          -----------:----------------------------------------
            q.d = 100
            q.disp()
        yields
          -----------:----------------------------------------
                    d: 100
                   aa: ${d}
                     = 100
                    b: ${aa}
                     = 100
                    c: ${aa}+${b}
                     = 200
          -----------:----------------------------------------


    Example:

        p = paramauto(b="${a}+1",c="${a}+${d}",a=1)
        p.disp()
    generates:
        WARNING: unable to interpret 1/3 expressions in "definitions"
          -----------:----------------------------------------
                    a: 1
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = &lt; undef definition "${d}" &gt;
          -----------:----------------------------------------
    setting p.d
        p.d = 2
        p.disp()
    produces
          -----------:----------------------------------------
                    a: 1
                    d: 2
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = 3
          -----------:----------------------------------------
</code></pre>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class paramauto(param):
    &#34;&#34;&#34;
    Class: `paramauto`
    ==================

    A subclass of `param` with enhanced handling for automatic sorting and evaluation
    of definitions. The `paramauto` class ensures that all fields are sorted to resolve
    dependencies, allowing seamless stacking of partially defined objects.

    ---

    ### Features
    - Inherits all functionalities of `param`.
    - Automatically sorts definitions for dependency resolution.
    - Simplifies handling of partial definitions in dynamic structures.
    - Supports safe concatenation of definitions.

    ---

    ### Examples

    #### Automatic Dependency Sorting
    Definitions are automatically sorted to resolve dependencies:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${b}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${b} (= 3)
    # --------
    ```

    #### Handling Missing Definitions
    Unresolved dependencies raise warnings but do not block execution:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------
    ```

    ---

    ### Concatenation and Inheritance
    Concatenating `paramauto` objects resolves definitions:
    ```python
    p1 = paramauto(a=1, b=&#34;${a}+2&#34;)
    p2 = paramauto(c=&#34;${b}*3&#34;)
    p3 = p1 + p2
    p3.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 2 (= 3)
    #      c: ${b} * 3 (= 9)
    # --------
    ```

    ---

    ### Utility Methods

    | Method                | Description                                            |
    |-----------------------|--------------------------------------------------------|
    | `sortdefinitions()`   | Automatically sorts fields to resolve dependencies.    |
    | `eval()`              | Evaluate all fields, resolving dependencies.           |
    | `disp()`              | Display all fields with their resolved values.         |

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `+`: Concatenates two `paramauto` objects, resolving dependencies.
    - `+=`: Updates the current object with another, resolving dependencies.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Advanced Usage

    #### Partial Definitions
    The `paramauto` class simplifies handling of partially defined fields:
    ```python
    p = paramauto(a=&#34;${d}&#34;, b=&#34;${a}+1&#34;)
    p.disp()
    # Warning: Unable to resolve dependencies.
    # --------
    #      a: ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      b: ${a} + 1 (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------

    p.d = 10
    p.disp()
    # Dependencies are resolved:
    # --------
    #      d: 10
    #      a: ${d} (= 10)
    #      b: ${a} + 1 (= 11)
    # --------
    ```

    ---

    ### Notes
    - The `paramauto` class is computationally more intensive than `param` due to automatic sorting.
    - It is ideal for managing dynamic systems with complex interdependencies.

    ### Examples
                    p = paramauto()
                    p.b = &#34;${aa}&#34;
                    p.disp()
                yields
                    WARNING: unable to interpret 1/1 expressions in &#34;definitions&#34;
                      -----------:----------------------------------------
                                b: ${aa}
                                 = &lt; undef definition &#34;${aa}&#34; &gt;
                      -----------:----------------------------------------
                      p.aa = 2
                      p.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                    -----------:----------------------------------------
                    q = paramauto(c=&#34;${aa}+${b}&#34;)+p
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                              c: ${aa}+${b}
                               = 4
                    -----------:----------------------------------------
                    q.aa = 30
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 30
                              b: ${aa}
                               = 30
                              c: ${aa}+${b}
                               = 60
                    -----------:----------------------------------------
                    q.aa = &#34;${d}&#34;
                    q.disp()
                yields multiple errors (recursion)
                WARNING: unable to interpret 3/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                           aa: ${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                            b: ${aa}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                            c: ${aa}+${b}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                  -----------:----------------------------------------
                    q.d = 100
                    q.disp()
                yields
                  -----------:----------------------------------------
                            d: 100
                           aa: ${d}
                             = 100
                            b: ${aa}
                             = 100
                            c: ${aa}+${b}
                             = 200
                  -----------:----------------------------------------


            Example:

                p = paramauto(b=&#34;${a}+1&#34;,c=&#34;${a}+${d}&#34;,a=1)
                p.disp()
            generates:
                WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                            a: 1
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                  -----------:----------------------------------------
            setting p.d
                p.d = 2
                p.disp()
            produces
                  -----------:----------------------------------------
                            a: 1
                            d: 2
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = 3
                  -----------:----------------------------------------

    &#34;&#34;&#34;

    def __add__(self,p):
        return super(param,self).__add__(p,sortdefinitions=True,raiseerror=False)

    def __iadd__(self,p):
        return super(param,self).__iadd__(p,sortdefinitions=True,raiseerror=False)

    def __repr__(self):
        self.sortdefinitions(raiseerror=False)
        #super(param,self).__repr__()
        super().__repr__()
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="forcefield.parameterforcefield" href="#forcefield.parameterforcefield">parameterforcefield</a></li>
<li>pizza.dscript.lambdaScriptdata</li>
<li>pizza.forcefield.parameterforcefield</li>
<li>pizza.region.regiondata</li>
</ul>
</dd>
<dt id="forcefield.parameterforcefield"><code class="flex name class">
<span>class <span class="ident">parameterforcefield</span></span>
<span>(</span><span>sortdefinitions=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>class of forcefields parameters, derived from param
note that conctanating two forcefields force them
to to be sorted</p>
<p>Constructor for parameterforcefield. It forces the parent's _returnerror parameter to False.</p>
<h2 id="parameters">Parameters:</h2>
<p>_protection : bool, optional
Whether to enable protection on the parameters (default: False).
_evaluation : bool, optional
Whether evaluation is enabled for the parameters (default: True).
sortdefinitions : bool, optional
Whether to sort definitions upon initialization (default: False).
**kwargs : dict
Additional keyword arguments for the parent class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class parameterforcefield(paramauto):
    &#34;&#34;&#34; class of forcefields parameters, derived from param
        note that conctanating two forcefields force them
        to to be sorted
    &#34;&#34;&#34;
    _type = &#34;FF&#34;
    _fulltype = &#34;forcefield&#34;
    _ftype = &#34;parameter&#34;
    _maxdisplay = 80

    # same strategy as used in dscript for forcing  _returnerror = False (added 2024-09-12)
    def __init__(self, _protection=False, _evaluation=True, sortdefinitions=False, **kwargs):
        &#34;&#34;&#34;
        Constructor for parameterforcefield. It forces the parent&#39;s _returnerror parameter to False.

        Parameters:
        -----------
        _protection : bool, optional
            Whether to enable protection on the parameters (default: False).
        _evaluation : bool, optional
            Whether evaluation is enabled for the parameters (default: True).
        sortdefinitions : bool, optional
            Whether to sort definitions upon initialization (default: False).
        **kwargs : dict
            Additional keyword arguments for the parent class.
        &#34;&#34;&#34;
        # Call the parent class constructor
        super().__init__(_protection=_protection, _evaluation=_evaluation, sortdefinitions=sortdefinitions, **kwargs)
        # Override the _returnerror attribute at the instance level
        self._returnerror = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.paramauto</li>
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="forcefield.rigidwall"><code class="flex name class">
<span>class <span class="ident">rigidwall</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>rigid walls (smd:none):
rigidwall()
rigidwall(beadtype=index, userid="wall", USER=&hellip;)</p>
<p>override any propery with USER.parameter (set only the parameters you want to override)
USER.rho: density in kg/m3 (default=3000)
USER.c0: speed of the sound in m/s (default=10.0)
USER.contact_scale: scaling coefficient for contact (default=1.5)
USER.contact_stiffness: contact stifness in Pa (default="2.5<em>${c0}^2</em>${rho}")</p>
<p>rigidwall forcefield:
rigidwall(beadtype=index, userid="mywall")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class rigidwall(none):
    &#34;&#34;&#34; rigid walls (smd:none):
            rigidwall()
            rigidwall(beadtype=index, userid=&#34;wall&#34;, USER=...)

            override any propery with USER.parameter (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=3000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = none.name + struct(material=&#34;walls&#34;)
    description = none.description + struct(material=&#34;rigid walls&#34;)
    userid = &#39;solidfood&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; rigidwall forcefield:
            rigidwall(beadtype=index, userid=&#34;mywall&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            rho = 3000,
            c0 = 10.0,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;,
            contact_scale = 1.5
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="forcefield.none" href="#forcefield.none">none</a></li>
<li><a title="forcefield.smd" href="#forcefield.smd">smd</a></li>
<li><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forcefield.rigidwall.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.rigidwall.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.rigidwall.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.rigidwall.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="forcefield.none" href="#forcefield.none">none</a></b></code>:
<ul class="hlist">
<li><code><a title="forcefield.none.getallattributes" href="#forcefield.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="forcefield.none.pair_diagcoeff" href="#forcefield.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="forcefield.none.pair_offdiagcoeff" href="#forcefield.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="forcefield.none.pair_style" href="#forcefield.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="forcefield.none.printheader" href="#forcefield.forcefield.printheader">printheader</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="forcefield.saltTLSPH"><code class="flex name class">
<span>class <span class="ident">saltTLSPH</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>SALTLSPH (smd:tlsph): ongoing "salting" beadtype for rheology control
saltTLSPH()
saltTLSPH(beadtype=index, userid="salt", USER=&hellip;)</p>
<p>override any property with USER.property = value</p>
<p>saltTLSPH forcefield:
saltTLSPH(beadtype=index, userid="salt")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class saltTLSPH(tlsph):
    &#34;&#34;&#34; SALTLSPH (smd:tlsph): ongoing &#34;salting&#34; beadtype for rheology control
            saltTLSPH()
            saltTLSPH(beadtype=index, userid=&#34;salt&#34;, USER=...)

            override any property with USER.property = value
    &#34;&#34;&#34;
    name = tlsph.name + struct(material=&#34;solidfood&#34;)
    description = tlsph.description + struct(material=&#34;food beads - solid behavior&#34;)
    userid = &#39;&#34;salt&#34;&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; saltTLSPH forcefield:
            saltTLSPH(beadtype=index, userid=&#34;salt&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # food-food interactions
            rho = 1000,
            c0 = 10.0,
            E = &#39;5*${c0}^2*${rho}&#39;,
            nu = 0.3,
            q1 = 1.0,
            q2 = 0.0,
            Hg = 10,
            Cp = 1.0,
            sigma_yield = &#39;0.1*${E}&#39;,
            hardening = 0,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="forcefield.tlsph" href="#forcefield.tlsph">tlsph</a></li>
<li><a title="forcefield.smd" href="#forcefield.smd">smd</a></li>
<li><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forcefield.saltTLSPH.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.saltTLSPH.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.saltTLSPH.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.saltTLSPH.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="forcefield.tlsph" href="#forcefield.tlsph">tlsph</a></b></code>:
<ul class="hlist">
<li><code><a title="forcefield.tlsph.getallattributes" href="#forcefield.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="forcefield.tlsph.pair_diagcoeff" href="#forcefield.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="forcefield.tlsph.pair_offdiagcoeff" href="#forcefield.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="forcefield.tlsph.pair_style" href="#forcefield.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="forcefield.tlsph.printheader" href="#forcefield.forcefield.printheader">printheader</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="forcefield.smd"><code class="flex name class">
<span>class <span class="ident">smd</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD forcefield</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class smd(forcefield):
    &#34;&#34;&#34; SMD forcefield &#34;&#34;&#34;
    name = forcefield.name + struct(forcefield=&#34;LAMMPS:SMD&#34;)
    description = forcefield.description + struct(forcefield=&#34;LAMMPS:SMD - solid, liquid, rigid forcefields (continuum mechanics)&#34;)

    # forcefield definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_STYLE = &#34;&#34;&#34;
    # [comment] PAIR STYLE SMD
    pair_style      hybrid/overlay smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION &amp;
                                   smd/tlsph smd/hertz ${contact_scale}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="forcefield.none" href="#forcefield.none">none</a></li>
<li><a title="forcefield.tlsph" href="#forcefield.tlsph">tlsph</a></li>
<li><a title="forcefield.ulsph" href="#forcefield.ulsph">ulsph</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forcefield.smd.PAIR_STYLE"><code class="name">var <span class="ident">PAIR_STYLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.smd.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.smd.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></b></code>:
<ul class="hlist">
<li><code><a title="forcefield.forcefield.getallattributes" href="#forcefield.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="forcefield.forcefield.pair_diagcoeff" href="#forcefield.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="forcefield.forcefield.pair_offdiagcoeff" href="#forcefield.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="forcefield.forcefield.pair_style" href="#forcefield.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="forcefield.forcefield.printheader" href="#forcefield.forcefield.printheader">printheader</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="forcefield.solidfood"><code class="flex name class">
<span>class <span class="ident">solidfood</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>solidfood material (smd:tlsph): model solid food object
solidfood()
solidfood(beadtype=index, userid="myfood", USER=&hellip;)</p>
<p>override any propery with USER.property=value (set only the parameters you want to override)
USER.rho: density in kg/m3 (default=1000)
USER.c0: speed of the sound in m/s (default=10.0)
USER.E: Young's modulus in Pa (default="5<em>${c0}^2</em>${rho}")
USER.nu: Poisson ratio (default=0.3)
USER.q1: standard artificial viscosity linear coefficient (default=1.0)
USER.q2: standard artificial viscosity quadratic coefficient (default=0)
USER.Hg: hourglass control coefficient (default=10.0)
USER.Cp: heat capacity of material &ndash; not used here (default=1.0)
USER.sigma_yield: plastic yield stress in Pa (default="0.1<em>${E}")
USER.hardening: hardening parameter (default=0)
USER.contact_scale: scaling coefficient for contact (default=1.5)
USER.contact_stiffness: contact stifness in Pa (default="2.5</em>${c0}^2*${rho}")</p>
<p>food forcefield:
solidfood(beadtype=index, userid="myfood")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class solidfood(tlsph):
    &#34;&#34;&#34; solidfood material (smd:tlsph): model solid food object
            solidfood()
            solidfood(beadtype=index, userid=&#34;myfood&#34;, USER=...)

            override any propery with USER.property=value (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=1000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.E: Young&#39;s modulus in Pa (default=&#34;5*${c0}^2*${rho}&#34;)
                USER.nu: Poisson ratio (default=0.3)
                USER.q1: standard artificial viscosity linear coefficient (default=1.0)
                USER.q2: standard artificial viscosity quadratic coefficient (default=0)
                USER.Hg: hourglass control coefficient (default=10.0)
                USER.Cp: heat capacity of material -- not used here (default=1.0)
                USER.sigma_yield: plastic yield stress in Pa (default=&#34;0.1*${E}&#34;)
                USER.hardening: hardening parameter (default=0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = tlsph.name + struct(material=&#34;solidfood&#34;)
    description = tlsph.description + struct(material=&#34;food beads - solid behavior&#34;)
    userid = &#39;solidfood&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; food forcefield:
            solidfood(beadtype=index, userid=&#34;myfood&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # food-food interactions
            rho = 1000,
            c0 = 10.0,
            E = &#34;5*${c0}^2*${rho}&#34;,
            nu = 0.3,
            q1 = 1.0,
            q2 = 0.0,
            Hg = 10.0,
            Cp = 1.0,
            sigma_yield = &#34;0.1*${E}&#34;,
            hardening = 0,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#34;2.5*${c0}^2*${rho}&#34;
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="forcefield.tlsph" href="#forcefield.tlsph">tlsph</a></li>
<li><a title="forcefield.smd" href="#forcefield.smd">smd</a></li>
<li><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forcefield.solidfood.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.solidfood.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.solidfood.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.solidfood.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="forcefield.tlsph" href="#forcefield.tlsph">tlsph</a></b></code>:
<ul class="hlist">
<li><code><a title="forcefield.tlsph.getallattributes" href="#forcefield.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="forcefield.tlsph.pair_diagcoeff" href="#forcefield.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="forcefield.tlsph.pair_offdiagcoeff" href="#forcefield.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="forcefield.tlsph.pair_style" href="#forcefield.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="forcefield.tlsph.printheader" href="#forcefield.forcefield.printheader">printheader</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="forcefield.struct"><code class="flex name class">
<span>class <span class="ident">struct</span></span>
<span>(</span><span>debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-struct">Class: <code><a title="forcefield.struct" href="#forcefield.struct">struct</a></code></h1>
<p>A lightweight class that mimics Matlab-like structures, with additional features
such as dynamic field creation, indexing, concatenation, and compatibility with
evaluated parameters (<code>param</code>).</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Dynamic creation of fields.</li>
<li>Indexing and iteration support for fields.</li>
<li>Concatenation and subtraction of structures.</li>
<li>Conversion to and from dictionaries.</li>
<li>Compatible with <code>param</code> and <code><a title="forcefield.paramauto" href="#forcefield.paramauto">paramauto</a></code> for evaluation and dependency handling.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic Usage</h4>
<pre><code class="language-python">s = struct(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
print(s.a)  # 1
s.d = 11    # Append a new field
delattr(s, 'd')  # Delete the field
</code></pre>
<h4 id="using-param-for-evaluation">Using <code>param</code> for Evaluation</h4>
<pre><code class="language-python">p = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
p.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-subtraction">Concatenation and Subtraction</h3>
<p>Fields from the right-most structure overwrite existing values.</p>
<pre><code class="language-python">a = struct(a=1, b=2)
b = struct(c=3, d=&quot;d&quot;, e=&quot;e&quot;)
c = a + b
e = c - a
</code></pre>
<hr>
<h3 id="practical-shorthands">Practical Shorthands</h3>
<h4 id="constructing-a-structure-from-keys">Constructing a Structure from Keys</h4>
<pre><code class="language-python">s = struct.fromkeys([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
# Output:
# --------
#      a: None
#      b: None
#      c: None
#      d: None
# --------
</code></pre>
<h4 id="building-a-structure-from-variables-in-a-string">Building a Structure from Variables in a String</h4>
<pre><code class="language-python">s = struct.scan(&quot;${a} + ${b} * ${c} / ${d} --- ${ee}&quot;)
s.a = 1
s.b = &quot;test&quot;
s.c = [1, &quot;a&quot;, 2]
s.generator()
# Output:
# X = struct(
#      a=1,
#      b=&quot;test&quot;,
#      c=[1, 'a', 2],
#      d=None,
#      ee=None
# )
</code></pre>
<h4 id="indexing-and-iteration">Indexing and Iteration</h4>
<p>Structures can be indexed or sliced like lists.</p>
<pre><code class="language-python">c = a + b
c[0]      # Access the first field
c[-1]     # Access the last field
c[:2]     # Slice the structure
for field in c:
    print(field)
</code></pre>
<hr>
<h3 id="dynamic-dependency-management">Dynamic Dependency Management</h3>
<p><code><a title="forcefield.struct" href="#forcefield.struct">struct</a></code> provides control over dependencies, sorting, and evaluation.</p>
<pre><code class="language-python">s = struct(d=3, e=&quot;${c} + {d}&quot;, c='${a} + ${b}', a=1, b=2)
s.sortdefinitions()
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}
#      e: ${c} + ${d}
# --------
</code></pre>
<p>For dynamic evaluation, use <code>param</code>:</p>
<pre><code class="language-python">p = param(sortdefinitions=True, d=3, e=&quot;${c} + ${d}&quot;, c='${a} + ${b}', a=1, b=2)
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}  (= 3)
#      e: ${c} + ${d}  (= 6)
# --------
</code></pre>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two structures (<code>__add__</code>).</li>
<li><code>-</code>: Subtraction of fields (<code>__sub__</code>).</li>
<li><code>len()</code>: Number of fields (<code>__len__</code>).</li>
<li><code>in</code>: Check for field existence (<code>__contains__</code>).</li>
</ul>
<h4 id="method-overview">Method Overview</h4>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>check(default)</code></td>
<td>Populate fields with defaults if missing.</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>Remove all fields.</td>
</tr>
<tr>
<td><code>dict2struct(dico)</code></td>
<td>Create a structure from a dictionary.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display the structure.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate expressions within fields.</td>
</tr>
<tr>
<td><code>fromkeys(keys)</code></td>
<td>Create a structure from a list of keys.</td>
</tr>
<tr>
<td><code>generator()</code></td>
<td>Generate Python code representing the structure.</td>
</tr>
<tr>
<td><code>items()</code></td>
<td>Return key-value pairs.</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>Return all keys in the structure.</td>
</tr>
<tr>
<td><code>read(file)</code></td>
<td>Load structure fields from a file.</td>
</tr>
<tr>
<td><code>scan(string)</code></td>
<td>Extract variables from a string and populate fields.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>struct2dict()</code></td>
<td>Convert the structure to a dictionary.</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>Return all field values.</td>
</tr>
<tr>
<td><code>write(file)</code></td>
<td>Save the structure to a file.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="dynamic-properties">Dynamic Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isempty</code></td>
<td><code>True</code> if the structure is empty.</td>
</tr>
<tr>
<td><code>isdefined</code></td>
<td><code>True</code> if all fields are defined.</td>
</tr>
</tbody>
</table>
<hr>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class struct():
    &#34;&#34;&#34;
    Class: `struct`
    ================

    A lightweight class that mimics Matlab-like structures, with additional features
    such as dynamic field creation, indexing, concatenation, and compatibility with
    evaluated parameters (`param`).

    ---

    ### Features
    - Dynamic creation of fields.
    - Indexing and iteration support for fields.
    - Concatenation and subtraction of structures.
    - Conversion to and from dictionaries.
    - Compatible with `param` and `paramauto` for evaluation and dependency handling.

    ---

    ### Examples

    #### Basic Usage
    ```python
    s = struct(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    print(s.a)  # 1
    s.d = 11    # Append a new field
    delattr(s, &#39;d&#39;)  # Delete the field
    ```

    #### Using `param` for Evaluation
    ```python
    p = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    p.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    # --------
    ```

    ---

    ### Concatenation and Subtraction
    Fields from the right-most structure overwrite existing values.
    ```python
    a = struct(a=1, b=2)
    b = struct(c=3, d=&#34;d&#34;, e=&#34;e&#34;)
    c = a + b
    e = c - a
    ```

    ---

    ### Practical Shorthands

    #### Constructing a Structure from Keys
    ```python
    s = struct.fromkeys([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;])
    # Output:
    # --------
    #      a: None
    #      b: None
    #      c: None
    #      d: None
    # --------
    ```

    #### Building a Structure from Variables in a String
    ```python
    s = struct.scan(&#34;${a} + ${b} * ${c} / ${d} --- ${ee}&#34;)
    s.a = 1
    s.b = &#34;test&#34;
    s.c = [1, &#34;a&#34;, 2]
    s.generator()
    # Output:
    # X = struct(
    #      a=1,
    #      b=&#34;test&#34;,
    #      c=[1, &#39;a&#39;, 2],
    #      d=None,
    #      ee=None
    # )
    ```

    #### Indexing and Iteration
    Structures can be indexed or sliced like lists.
    ```python
    c = a + b
    c[0]      # Access the first field
    c[-1]     # Access the last field
    c[:2]     # Slice the structure
    for field in c:
        print(field)
    ```

    ---

    ### Dynamic Dependency Management
    `struct` provides control over dependencies, sorting, and evaluation.

    ```python
    s = struct(d=3, e=&#34;${c} + {d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    s.sortdefinitions()
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}
    #      e: ${c} + ${d}
    # --------
    ```

    For dynamic evaluation, use `param`:
    ```python
    p = param(sortdefinitions=True, d=3, e=&#34;${c} + ${d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}  (= 3)
    #      e: ${c} + ${d}  (= 6)
    # --------
    ```

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two structures (`__add__`).
    - `-`: Subtraction of fields (`__sub__`).
    - `len()`: Number of fields (`__len__`).
    - `in`: Check for field existence (`__contains__`).

    #### Method Overview
    | Method                | Description                                             |
    |-----------------------|---------------------------------------------------------|
    | `check(default)`      | Populate fields with defaults if missing.               |
    | `clear()`             | Remove all fields.                                      |
    | `dict2struct(dico)`   | Create a structure from a dictionary.                   |
    | `disp()`              | Display the structure.                                  |
    | `eval()`              | Evaluate expressions within fields.                     |
    | `fromkeys(keys)`      | Create a structure from a list of keys.                 |
    | `generator()`         | Generate Python code representing the structure.        |
    | `items()`             | Return key-value pairs.                                 |
    | `keys()`              | Return all keys in the structure.                       |
    | `read(file)`          | Load structure fields from a file.                      |
    | `scan(string)`        | Extract variables from a string and populate fields.    |
    | `sortdefinitions()`   | Sort fields to resolve dependencies.                    |
    | `struct2dict()`       | Convert the structure to a dictionary.                  |
    | `values()`            | Return all field values.                                |
    | `write(file)`         | Save the structure to a file.                           |

    ---

    ### Dynamic Properties
    | Property    | Description                            |
    |-------------|----------------------------------------|
    | `isempty`   | `True` if the structure is empty.      |
    | `isdefined` | `True` if all fields are defined.      |

    ---
    &#34;&#34;&#34;

    # attributes to be overdefined
    _type = &#34;struct&#34;        # object type
    _fulltype = &#34;structure&#34; # full name
    _ftype = &#34;field&#34;        # field name
    _evalfeature = False    # true if eval() is available
    _maxdisplay = 40        # maximum number of characters to display (should be even)
    _propertyasattribute = False

    # attributes for the iterator method
    # Please keep it static, duplicate the object before changing _iter_
    _iter_ = 0

    # excluded attributes (keep the , in the Tupple if it is singleton)
    _excludedattr = {&#39;_iter_&#39;,&#39;__class__&#39;,&#39;_protection&#39;,&#39;_evaluation&#39;,&#39;_returnerror&#39;,&#39;_debug&#39;} # used by keys() and len()


    # Methods
    def __init__(self,debug=False,**kwargs):
        &#34;&#34;&#34; constructor, use debug=True to report eval errors&#34;&#34;&#34;
        # Optionally extend _excludedattr here
        self._excludedattr = self._excludedattr | {&#39;_excludedattr&#39;, &#39;_type&#39;, &#39;_fulltype&#39;,&#39;_ftype&#39;} # addition 2024-10-11
        self._debug = debug
        self.set(**kwargs)

    def zip(self):
        &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
        return zip(self.keys(),self.values())

    @staticmethod
    def dict2struct(dico,makeparam=False):
        &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
        if isinstance(dico,dict):
            s = param() if makeparam else struct()
            s.set(**dico)
            return s
        raise TypeError(&#34;the argument must be a dictionary&#34;)

    def struct2dict(self):
        &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
        return dict(self.zip())

    def struct2param(self,protection=False,evaluation=True):
        &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
        p = param(**self.struct2dict())
        for i in range(len(self)):
            if isinstance(self[i],pstr): p[i] = pstr(p[i])
        p._protection = protection
        p._evaluation = evaluation
        return p

    def set(self,**kwargs):
        &#34;&#34;&#34; initialization &#34;&#34;&#34;
        self.__dict__.update(kwargs)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value

    def getattr(self,key):
        &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
        if key in self.__dict__:
            return self.__dict__[key]
        elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
             key not in self._excludedattr and \
             key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
            # If _propertyasattribute is True and it&#39;s a property, get its value
            return self.__class__.__dict__[key].fget(self)
        else:
            raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)

    def hasattr(self, key):
        &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
        return key in self.__dict__ or (
            getattr(self, &#39;_propertyasattribute&#39;, False) and
            key not in self._excludedattr and
            key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
        )

    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return pstr.eval(self.getattr(key))

    def __setattr__(self,key,value):
        &#34;&#34;&#34; set attribute override &#34;&#34;&#34;
        self.setattr(key,value)

    def __contains__(self,item):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(item)

    def keys(self):
        &#34;&#34;&#34; return the fields &#34;&#34;&#34;
        # keys() is used by struct() and its iterator
        return [key for key in self.__dict__.keys() if key not in self._excludedattr]

    def keyssorted(self,reverse=True):
        &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
        klist = self.keys()
        l = [len(k) for k in klist]
        return [k for _,k in sorted(zip(l,klist),reverse=reverse)]

    def values(self):
        &#34;&#34;&#34; return the values &#34;&#34;&#34;
        # values() is used by struct() and its iterator
        return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]

    @staticmethod
    def fromkeysvalues(keys,values,makeparam=False):
        &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
            use makeparam = True to create a param instead of struct
        &#34;&#34;&#34;
        if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
        if not isinstance(keys,_list_types): keys = [keys]
        if not isinstance(values,_list_types): values = [values]
        nk,nv = len(keys), len(values)
        s = param() if makeparam else struct()
        if nk&gt;0 and nv&gt;0:
            iv = 0
            for ik in range(nk):
                s.setattr(keys[ik], values[iv])
                iv = min(nv-1,iv+1)
            for ik in range(nk,nv):
                s.setattr(f&#34;key{ik}&#34;, values[ik])
        return s

    def items(self):
        &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
        return self.zip()

    def __getitem__(self,idx):
        &#34;&#34;&#34;
            s[i] returns the ith element of the structure
            s[:4] returns a structure with the four first fields
            s[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.getattr(self.keys()[idx])
            raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            return struct.fromkeysvalues(self.keys()[idx], self.values()[idx])
        elif isinstance(idx,(list,tuple)):
            k,v= self.keys(), self.values()
            nk = len(k)
            s = param() if isinstance(self,param) else struct()
            for i in idx:
                if isinstance(i,int) and i&gt;=0 and i&lt;nk:
                    s.setattr(k[i],v[i])
                else:
                    raise IndexError(&#34;idx must contains only integers ranged between 0 and %d&#34; % (nk-1))
            return s
        elif isinstance(idx,str):
            return self.getattr(idx)
        else:
            raise TypeError(&#34;The index must be an integer or a slice and not a %s&#34; % type(idx).__name__)

    def __setitem__(self,idx,value):
        &#34;&#34;&#34; set the ith element of the structure  &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                self.setattr(self.keys()[idx], value)
            else:
                raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            k = self.keys()[idx]
            if len(value)&lt;=1:
                for i in range(len(k)): self.setattr(k[i], value)
            elif len(k) == len(value):
                for i in range(len(k)): self.setattr(k[i], value[i])
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of elements in the slive (%d)&#34; \
                       % (len(value),len(idx)))
        elif isinstance(idx,(list,tuple)):
            if len(value)&lt;=1:
                for i in range(len(idx)): self[idx[i]]=value
            elif len(idx) == len(value):
                for i in range(len(idx)): self[idx[i]]=value[i]
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of indices (%d)&#34; \
                                 % (len(value),len(idx)))

    def __len__(self):
        &#34;&#34;&#34; return the number of fields &#34;&#34;&#34;
        # len() is used by struct() and its iterator
        return len(self.keys())

    def __iter__(self):
        &#34;&#34;&#34; struct iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    def __next__(self):
        &#34;&#34;&#34; increment iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum {self._ftype} iteration reached {len(self)}&#34;)

    def __add__(self,s,sortdefinitions=False,raiseerror=True, silentmode=True):
        &#34;&#34;&#34; add a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        dup.__dict__.update(s.__dict__)
        if sortdefinitions: dup.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return dup

    def __iadd__(self,s,sortdefinitions=False,raiseerror=False, silentmode=True):
        &#34;&#34;&#34; iadd a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        self.__dict__.update(s.__dict__)
        if sortdefinitions: self.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return self

    def __sub__(self,s):
        &#34;&#34;&#34; sub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        listofkeys = dup.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(dup,k)
        return dup

    def __isub__(self,s):
        &#34;&#34;&#34; isub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        listofkeys = self.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(self,k)
        return self

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        if self.__dict__=={}:
            print(f&#34;empty {self._fulltype} ({self._type} object) with no {self._type}s&#34;)
            return f&#34;empty {self._fulltype}&#34;
        else:
            tmp = self.eval() if self._evalfeature else []
            keylengths = [len(key) for key in self.__dict__]
            width = max(10,max(keylengths)+2)
            fmt = &#34;%%%ss:&#34; % width
            fmteval = fmt[:-1]+&#34;=&#34;
            fmtcls =  fmt[:-1]+&#34;:&#34;
            line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
            print(line)
            for key,value in self.__dict__.items():
                if key not in self._excludedattr:
                    if isinstance(value,_numeric_types):
                        # old code (removed on 2025-01-18)
                        # if isinstance(value,pstr):
                        #     print(fmt % key,&#39;p&#34;&#39;+self.dispmax(value)+&#39;&#34;&#39;)
                        # if isinstance(value,str) and value==&#34;&#34;:
                        #     print(fmt % key,&#39;&#34;&#34;&#39;)
                        # else:
                        #     print(fmt % key,self.dispmax(value))
                        if isinstance(value,np.ndarray):
                            print(fmt % key, struct.format_array(value))
                        else:
                            print(fmt % key,self.dispmax(value))
                    elif isinstance(value,struct):
                        print(fmt % key,self.dispmax(value.__str__()))
                    elif isinstance(value,type):
                        print(fmt % key,self.dispmax(str(value)))
                    else:
                        print(fmt % key,type(value))
                        print(fmtcls % &#34;&#34;,self.dispmax(str(value)))
                    if self._evalfeature:
                        if isinstance(self,paramauto):
                            try:
                                if isinstance(value,pstr):
                                    print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                                elif isinstance(value,str):
                                    if value == &#34;&#34;:
                                        print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(tmp.getattr(key)))
                            except Exception as err:
                                print(fmteval % &#34;&#34;,err.message, err.args)
                        else:
                            if isinstance(value,pstr):
                                print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                            elif isinstance(value,str):
                                if value == &#34;&#34;:
                                    print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                else:
                                    calcvalue =tmp.getattr(key)
                                    if isinstance(calcvalue, str) and &#34;error&#34; in calcvalue.lower():
                                        print(fmteval % &#34;&#34;,calcvalue)
                                    else:
                                        if isinstance(calcvalue,np.ndarray):
                                            print(fmteval % &#34;&#34;, struct.format_array(calcvalue))
                                        else:
                                            print(fmteval % &#34;&#34;,self.dispmax(calcvalue))
            print(line)
            return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    def disp(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        self.__repr__()

    def __str__(self):
        return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    @property
    def isempty(self):
        &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
        return len(self)==0

    def clear(self):
        &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
        for k in self.keys(): delattr(self,k)

    def format(self, s, escape=False, raiseerror=True):
        &#34;&#34;&#34;
            Format a string with fields using {field} as placeholders.
            Handles expressions like ${variable1}.

            Args:
                s (str): The input string to format.
                escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
                raiseerror (bool): If True, raises errors for missing fields.

            Note:
                NumPy vectors and matrices are converted into their text representation (default behavior)
                If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

            Returns:
                str: The formatted string.
        &#34;&#34;&#34;
        tmp = self.np2str()
        if raiseerror:
            try:
                if escape:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.format_map(AttrErrorDict(self.__dict__))
                else:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
            except AttributeError as attr_err:
                # Handle AttributeError for expressions with operators
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
                return s_  # Revert to using &#39;${&#39; for unresolved expressions
            except IndexError as idx_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
                raise IndexError from idx_err
            except Exception as other_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                raise RuntimeError from other_err
        else:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except:  # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))

    def format_legacy(self,s,escape=False,raiseerror=True):
        &#34;&#34;&#34;
            format a string with field (use {field} as placeholders)
                s.replace(string), s.replace(string,escape=True)
                where:
                    s is a struct object
                    string is a string with possibly ${variable1}
                    escape is a flag to prevent ${} replaced by {}
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format(**self.__dict__)
                else:
                    return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
            except KeyError as kerr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
                return s_ # instead of s (we put back $) - OV 2023/01/27
            except Exception as othererr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                raise RuntimeError from othererr
        else:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)

    def fromkeys(self,keys):
        &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
        return self+struct(**dict.fromkeys(keys,None))

    @staticmethod
    def scan(s):
        &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
        tmp = struct()
        #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
        found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
        uniq = []
        for x in found:
            if x not in uniq: uniq.append(x)
        return tmp.fromkeys(uniq)

    @staticmethod
    def isstrexpression(s):
        &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        return re.search(r&#34;\$\{.*?\}&#34;,s) is not None

    @property
    def isexpression(self):
        &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        for k,v in self.items():
            if isinstance(v,str):
                s.setattr(k,struct.isstrexpression(v))
            else:
                s.setattr(k,False)
        return s

    @staticmethod
    def isstrdefined(s,ref):
        &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        if struct.isstrexpression(s):
            k = struct.scan(s).keys()
            allfound,i,nk = True,0,len(k)
            while (i&lt;nk) and allfound:
                allfound = k[i] in ref
                i += 1
            return allfound
        else:
            return False


    def isdefined(self,ref=None):
        &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
        nk = len(k)
        if ref is None:
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
                else:
                    s.setattr(k[i],True)
        else:
            if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],ref))
                else:
                    s.setattr(k[i],True)
        return s

    def sortdefinitions(self,raiseerror=True,silentmode=False):
        &#34;&#34;&#34; sortdefintions sorts all definitions
            so that they can be executed as param().
            If any inconsistency is found, an error message is generated.

            Flags = default values
                raiseerror=True show erros of True
                silentmode=False no warning if True
        &#34;&#34;&#34;
        find = lambda xlist: [i for i, x in enumerate(xlist) if x]
        findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
        k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
        istatic = findnot(isexpr)
        idynamic = find(isexpr)
        static = struct.fromkeysvalues(
            [ k[i] for i in istatic ],
            [ v[i] for i in istatic ],
            makeparam = False)
        dynamic = struct.fromkeysvalues(
            [ k[i] for i in idynamic ],
            [ v[i] for i in idynamic ],
            makeparam=False)
        current = static # make static the current structure
        nmissing, anychange, errorfound = len(dynamic), False, False
        while nmissing:
            itst, found = 0, False
            while itst&lt;nmissing and not found:
                teststruct = current + dynamic[[itst]] # add the test field
                found = all(list(teststruct.isdefined()))
                ifound = itst
                itst += 1
            if found:
                current = teststruct # we accept the new field
                dynamic[ifound] = []
                nmissing -= 1
                anychange = True
            else:
                if raiseerror:
                    raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                                   (nmissing,len(self),self._ftype))
                else:
                    if (not errorfound) and (not silentmode):
                        print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                              (nmissing,len(self),self._ftype))
                    current = teststruct # we accept the new field (even if it cannot be interpreted)
                    dynamic[ifound] = []
                    nmissing -= 1
                    errorfound = True
        if anychange:
            self.clear() # reset all fields and assign them in the proper order
            k,v = current.keys(), current.values()
            for i in range(len(k)):
                self.setattr(k[i],v[i])

    def generator(self):
        &#34;&#34;&#34; generate Python code of the equivalent structure &#34;&#34;&#34;
        nk = len(self)
        if nk==0:
            print(&#34;X = struct()&#34;)
        else:
            ik = 0
            fmt = &#34;%%%ss=&#34; % max(10,max([len(k) for k in self.keys()])+2)
            print(&#34;\nX = struct(&#34;)
            for k in self.keys():
                ik += 1
                end = &#34;,\n&#34; if ik&lt;nk else &#34;\n&#34;+(fmt[:-1] % &#34;)&#34;)+&#34;\n&#34;
                v = getattr(self,k)
                if isinstance(v,(int,float)) or v == None:
                    print(fmt % k,v,end=end)
                elif isinstance(v,str):
                    print(fmt % k,f&#39;&#34;{v}&#34;&#39;,end=end)
                elif isinstance(v,(list,tuple)):
                    print(fmt % k,v,end=end)
                else:
                    print(fmt % k,&#34;/* unsupported type */&#34;,end=end)

    # copy and deep copy methpds for the class
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, duplicatedeep(v, memo))
        return copie


    # write a file
    def write(self, file, overwrite=True, mkdir=False):
        &#34;&#34;&#34;
            write the equivalent structure (not recursive for nested struct)
                write(filename, overwrite=True, mkdir=False)

            Parameters:
            - file: The file path to write to.
            - overwrite: Whether to overwrite the file if it exists (default: True).
            - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()

        # Check if the directory exists or if mkdir is set to True, create it
        if mkdir:
            file_path.parent.mkdir(parents=True, exist_ok=True)
        elif not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If overwrite is False and the file already exists, raise an exception
        if not overwrite and file_path.exists():
            raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
        # Open and write to the file using the resolved path
        with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
            print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
            for k, v in self.items():
                if v is None:
                    print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
                elif isinstance(v, (int, float)):
                    print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
                elif isinstance(v, str):
                    print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
                else:
                    print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)


    # read a file
    @staticmethod
    def read(file):
        &#34;&#34;&#34;
            read the equivalent structure
                read(filename)

            Parameters:
            - file: The file path to read from.
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()
        # Check if the parent directory exists, otherwise raise an error
        if not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If the file does not exist, raise an exception
        if not file_path.exists():
            raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
        # Open and read the file
        with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            s = struct()  # Assuming struct is defined elsewhere
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                expr = line.split(sep=&#34;=&#34;)
                if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                    lhs = expr[0]
                    rhs = &#34;&#34;.join(expr[1:]).strip()
                    if len(rhs) == 0 or rhs == &#34;None&#34;:
                        v = None
                    else:
                        v = eval(rhs)
                    s.setattr(lhs, v)
        return s

    # argcheck
    def check(self,default):
        &#34;&#34;&#34;
        populate fields from a default structure
            check(defaultstruct)
            missing field, None and [] values are replaced by default ones

            Note: a.check(b) is equivalent to b+a except for [] and None values
        &#34;&#34;&#34;
        if not isinstance(default,struct):
            raise TypeError(&#34;the first argument must be a structure&#34;)
        for f in default.keys():
            ref = default.getattr(f)
            if f not in self:
                self.setattr(f, ref)
            else:
                current = self.getattr(f)
                if ((current is None)  or (current==[])) and \
                    ((ref is not None) and (ref!=[])):
                        self.setattr(f, ref)


    # update values based on key:value
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple fields at once, while protecting certain attributes.

        Parameters:
        -----------
        **kwargs : dict
            The fields to update and their new values.

        Protected attributes defined in _excludedattr are not updated.

        Usage:
        ------
        s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
        &#34;&#34;&#34;
        protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

        for key, value in kwargs.items():
            if key in protected_attributes:
                print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
            else:
                self.setattr(key, value)


    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract a sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            A new instance of the same class as the original, containing
            only the specified keys.

        Usage:
        ------
        sub_struct = s(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        # Create a new instance of the same class
        sub_struct = self.__class__()

        # Get the full type and field type for error messages
        fulltype = getattr(self, &#39;_fulltype&#39;, &#39;structure&#39;)
        ftype = getattr(self, &#39;_ftype&#39;, &#39;field&#39;)

        # Add only the specified keys to the new sub-structure
        for key in keys:
            if key in self:
                sub_struct.setattr(key, self.getattr(key))
            else:
                raise KeyError(f&#34;{fulltype} does not contain the {ftype} &#39;{key}&#39;.&#34;)

        return sub_struct


    def __delattr__(self, key):
        &#34;&#34;&#34; Delete an instance attribute if it exists and is not a class or excluded attribute. &#34;&#34;&#34;
        if key in self._excludedattr:
            raise AttributeError(f&#34;Cannot delete excluded attribute &#39;{key}&#39;&#34;)
        elif key in self.__class__.__dict__:  # Check if it&#39;s a class attribute
            raise AttributeError(f&#34;Cannot delete class attribute &#39;{key}&#39;&#34;)
        elif key in self.__dict__:  # Delete only if in instance&#39;s __dict__
            del self.__dict__[key]
        else:
            raise AttributeError(f&#34;{self._type} has no attribute &#39;{key}&#39;&#34;)


    # A la Matlab display method of vectors, matrices and ND-arrays
    @staticmethod
    def format_array(value):
        &#34;&#34;&#34;
        Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
        Args:
            value (np.ndarray): The NumPy array to format.
        Returns:
            str: A formatted string representation of the array.
        &#34;&#34;&#34;
        dtype_str = {
            np.float64: &#34;double&#34;,
            np.float32: &#34;single&#34;,
            np.int32: &#34;int32&#34;,
            np.int64: &#34;int64&#34;,
            np.complex64: &#34;complex single&#34;,
            np.complex128: &#34;complex double&#34;,
        }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

        max_display = 10  # Maximum number of elements to display

        # Handle scalar values (0D arrays)
        if value.ndim == 0 or value.size == 1:
            return f&#34;{value.item()} ({dtype_str})&#34;

        # Handle 1D arrays (row or column vectors)
        if value.ndim == 1:
            if len(value) &lt;= max_display:
                return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
            else:
                return f&#34;[{len(value)}Ã—1 {dtype_str}]&#34;

        # Handle 2D arrays (matrices)
        if value.ndim == 2:
            rows, cols = value.shape
            if cols == 1:  # Column vector
                if rows &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                else:
                    return f&#34;[{rows}Ã—1 {dtype_str}]&#34;
            elif rows == 1:  # Row vector
                if cols &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                else:
                    return f&#34;[1Ã—{cols} {dtype_str}]&#34;
            else:  # General matrix
                return f&#34;[{rows}Ã—{cols} {dtype_str}]&#34;

        # Handle higher-dimensional arrays
        shape_str = &#34;Ã—&#34;.join(map(str, value.shape))
        if value.size &lt;= max_display:  # Show full content for small arrays
            flattened = value.flatten()
            formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in flattened) + f&#34;] ({shape_str} {dtype_str})&#34;
        else:
            formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

        return formatted


    # convert all NumPy entries to &#34;nestable&#34; expressions
    def np2str(self):
        &#34;&#34;&#34; Convert all np entries of s into their string representations  &#34;&#34;&#34;
        out = struct()
        def format_numpy_result(value):
            &#34;&#34;&#34;
            Converts a NumPy array or scalar into a string representation:
            - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
            - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
            - Non-ndarray inputs are returned without modification.

            Args:
                value (np.ndarray, scalar, or other): The value to format.

            Returns:
                str or original type: A properly formatted string for NumPy arrays/scalars or the original value.
            &#34;&#34;&#34;
            if np.isscalar(value):
                # If the value is a scalar, return it directly
                return repr(value)
            elif isinstance(value, np.ndarray):
                # Check if the array has exactly one element
                if value.size == 1:
                    # Extract the scalar value
                    return repr(value.item())
                # Convert the array to a nested list
                nested_list = value.tolist()
                # Recursively format the nested list into a valid string
                def list_to_string(lst):
                    if isinstance(lst, list):
                        # Format lists with proper commas
                        return &#34;[&#34; + &#34;, &#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                    else:
                        # Format scalars in the list
                        return repr(lst)

                return list_to_string(nested_list)
            else:
                # Return the input unmodified if not a NumPy array or scalar
                return value
        # process all entries in s
        for key,value in self.items():
            out.setattr(key,format_numpy_result(value))
        return out</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.raster.collection</li>
<li>pizza.region.regioncollection</li>
<li>pizza.script.scriptobject</li>
<li>pizza.script.scriptobjectgroup</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="forcefield.struct.dict2struct"><code class="name flex">
<span>def <span class="ident">dict2struct</span></span>(<span>dico, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>create a structure from a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dict2struct(dico,makeparam=False):
    &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
    if isinstance(dico,dict):
        s = param() if makeparam else struct()
        s.set(**dico)
        return s
    raise TypeError(&#34;the argument must be a dictionary&#34;)</code></pre>
</details>
</dd>
<dt id="forcefield.struct.format_array"><code class="name flex">
<span>def <span class="ident">format_array</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The NumPy array to format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representation of the array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_array(value):
    &#34;&#34;&#34;
    Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
    Args:
        value (np.ndarray): The NumPy array to format.
    Returns:
        str: A formatted string representation of the array.
    &#34;&#34;&#34;
    dtype_str = {
        np.float64: &#34;double&#34;,
        np.float32: &#34;single&#34;,
        np.int32: &#34;int32&#34;,
        np.int64: &#34;int64&#34;,
        np.complex64: &#34;complex single&#34;,
        np.complex128: &#34;complex double&#34;,
    }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

    max_display = 10  # Maximum number of elements to display

    # Handle scalar values (0D arrays)
    if value.ndim == 0 or value.size == 1:
        return f&#34;{value.item()} ({dtype_str})&#34;

    # Handle 1D arrays (row or column vectors)
    if value.ndim == 1:
        if len(value) &lt;= max_display:
            return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
        else:
            return f&#34;[{len(value)}Ã—1 {dtype_str}]&#34;

    # Handle 2D arrays (matrices)
    if value.ndim == 2:
        rows, cols = value.shape
        if cols == 1:  # Column vector
            if rows &lt;= max_display:
                return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
            else:
                return f&#34;[{rows}Ã—1 {dtype_str}]&#34;
        elif rows == 1:  # Row vector
            if cols &lt;= max_display:
                return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
            else:
                return f&#34;[1Ã—{cols} {dtype_str}]&#34;
        else:  # General matrix
            return f&#34;[{rows}Ã—{cols} {dtype_str}]&#34;

    # Handle higher-dimensional arrays
    shape_str = &#34;Ã—&#34;.join(map(str, value.shape))
    if value.size &lt;= max_display:  # Show full content for small arrays
        flattened = value.flatten()
        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in flattened) + f&#34;] ({shape_str} {dtype_str})&#34;
    else:
        formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

    return formatted</code></pre>
</details>
</dd>
<dt id="forcefield.struct.fromkeysvalues"><code class="name flex">
<span>def <span class="ident">fromkeysvalues</span></span>(<span>keys, values, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>struct.keysvalues(keys,values) creates a structure from keys and values
use makeparam = True to create a param instead of struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromkeysvalues(keys,values,makeparam=False):
    &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
        use makeparam = True to create a param instead of struct
    &#34;&#34;&#34;
    if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
    if not isinstance(keys,_list_types): keys = [keys]
    if not isinstance(values,_list_types): values = [values]
    nk,nv = len(keys), len(values)
    s = param() if makeparam else struct()
    if nk&gt;0 and nv&gt;0:
        iv = 0
        for ik in range(nk):
            s.setattr(keys[ik], values[iv])
            iv = min(nv-1,iv+1)
        for ik in range(nk,nv):
            s.setattr(f&#34;key{ik}&#34;, values[ik])
    return s</code></pre>
</details>
</dd>
<dt id="forcefield.struct.isstrdefined"><code class="name flex">
<span>def <span class="ident">isstrdefined</span></span>(<span>s, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrdefined(string,ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrdefined(s,ref):
    &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
    if struct.isstrexpression(s):
        k = struct.scan(s).keys()
        allfound,i,nk = True,0,len(k)
        while (i&lt;nk) and allfound:
            allfound = k[i] in ref
            i += 1
        return allfound
    else:
        return False</code></pre>
</details>
</dd>
<dt id="forcefield.struct.isstrexpression"><code class="name flex">
<span>def <span class="ident">isstrexpression</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrexpression(string) returns true if s contains an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrexpression(s):
    &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    return re.search(r&#34;\$\{.*?\}&#34;,s) is not None</code></pre>
</details>
</dd>
<dt id="forcefield.struct.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>read the equivalent structure
read(filename)</p>
<p>Parameters:
- file: The file path to read from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read(file):
    &#34;&#34;&#34;
        read the equivalent structure
            read(filename)

        Parameters:
        - file: The file path to read from.
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()
    # Check if the parent directory exists, otherwise raise an error
    if not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If the file does not exist, raise an exception
    if not file_path.exists():
        raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
    # Open and read the file
    with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
        s = struct()  # Assuming struct is defined elsewhere
        while True:
            line = f.readline()
            if not line:
                break
            line = line.strip()
            expr = line.split(sep=&#34;=&#34;)
            if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                lhs = expr[0]
                rhs = &#34;&#34;.join(expr[1:]).strip()
                if len(rhs) == 0 or rhs == &#34;None&#34;:
                    v = None
                else:
                    v = eval(rhs)
                s.setattr(lhs, v)
    return s</code></pre>
</details>
</dd>
<dt id="forcefield.struct.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>scan(string) scan a string for variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def scan(s):
    &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
    tmp = struct()
    #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
    found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
    uniq = []
    for x in found:
        if x not in uniq: uniq.append(x)
    return tmp.fromkeys(uniq)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="forcefield.struct.isempty"><code class="name">var <span class="ident">isempty</span></code></dt>
<dd>
<div class="desc"><p>isempty is set to True for an empty structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isempty(self):
    &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
    return len(self)==0</code></pre>
</details>
</dd>
<dt id="forcefield.struct.isexpression"><code class="name">var <span class="ident">isexpression</span></code></dt>
<dd>
<div class="desc"><p>same structure with True if it is an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isexpression(self):
    &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    for k,v in self.items():
        if isinstance(v,str):
            s.setattr(k,struct.isstrexpression(v))
        else:
            s.setattr(k,False)
    return s</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="forcefield.struct.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, default)</span>
</code></dt>
<dd>
<div class="desc"><p>populate fields from a default structure
check(defaultstruct)
missing field, None and [] values are replaced by default ones</p>
<pre><code>Note: a.check(b) is equivalent to b+a except for [] and None values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self,default):
    &#34;&#34;&#34;
    populate fields from a default structure
        check(defaultstruct)
        missing field, None and [] values are replaced by default ones

        Note: a.check(b) is equivalent to b+a except for [] and None values
    &#34;&#34;&#34;
    if not isinstance(default,struct):
        raise TypeError(&#34;the first argument must be a structure&#34;)
    for f in default.keys():
        ref = default.getattr(f)
        if f not in self:
            self.setattr(f, ref)
        else:
            current = self.getattr(f)
            if ((current is None)  or (current==[])) and \
                ((ref is not None) and (ref!=[])):
                    self.setattr(f, ref)</code></pre>
</details>
</dd>
<dt id="forcefield.struct.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear() delete all fields while preserving the original class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
    for k in self.keys(): delattr(self,k)</code></pre>
</details>
</dd>
<dt id="forcefield.struct.disp"><code class="name flex">
<span>def <span class="ident">disp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>display method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disp(self):
    &#34;&#34;&#34; display method &#34;&#34;&#34;
    self.__repr__()</code></pre>
</details>
</dd>
<dt id="forcefield.struct.dispmax"><code class="name flex">
<span>def <span class="ident">dispmax</span></span>(<span>self, content)</span>
</code></dt>
<dd>
<div class="desc"><p>optimize display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispmax(self,content):
    &#34;&#34;&#34; optimize display &#34;&#34;&#34;
    strcontent = str(content)
    if len(strcontent)&gt;self._maxdisplay:
        nchar = round(self._maxdisplay/2)
        return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
    else:
        return content</code></pre>
</details>
</dd>
<dt id="forcefield.struct.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Format a string with fields using {field} as placeholders.
Handles expressions like ${variable1}.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>The input string to format.</dd>
<dt><strong><code>escape</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, prevents replacing '${' with '{'.</dd>
<dt><strong><code>raiseerror</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, raises errors for missing fields.</dd>
</dl>
<h2 id="note">Note</h2>
<p>NumPy vectors and matrices are converted into their text representation (default behavior)
If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, s, escape=False, raiseerror=True):
    &#34;&#34;&#34;
        Format a string with fields using {field} as placeholders.
        Handles expressions like ${variable1}.

        Args:
            s (str): The input string to format.
            escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
            raiseerror (bool): If True, raises errors for missing fields.

        Note:
            NumPy vectors and matrices are converted into their text representation (default behavior)
            If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

        Returns:
            str: The formatted string.
    &#34;&#34;&#34;
    tmp = self.np2str()
    if raiseerror:
        try:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
        except AttributeError as attr_err:
            # Handle AttributeError for expressions with operators
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
            return s_  # Revert to using &#39;${&#39; for unresolved expressions
        except IndexError as idx_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            if self._debug:
                print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
            raise IndexError from idx_err
        except Exception as other_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            raise RuntimeError from other_err
    else:
        if escape:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.format_map(AttrErrorDict(tmp.__dict__))
            except: # if an error occurs, we use the orginal content
                return s.format_map(AttrErrorDict(self.__dict__))
        else:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
            except:  # if an error occurs, we use the orginal content
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))</code></pre>
</details>
</dd>
<dt id="forcefield.struct.format_legacy"><code class="name flex">
<span>def <span class="ident">format_legacy</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>format a string with field (use {field} as placeholders)
s.replace(string), s.replace(string,escape=True)
where:
s is a struct object
string is a string with possibly ${variable1}
escape is a flag to prevent ${} replaced by {}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_legacy(self,s,escape=False,raiseerror=True):
    &#34;&#34;&#34;
        format a string with field (use {field} as placeholders)
            s.replace(string), s.replace(string,escape=True)
            where:
                s is a struct object
                string is a string with possibly ${variable1}
                escape is a flag to prevent ${} replaced by {}
    &#34;&#34;&#34;
    if raiseerror:
        try:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
        except KeyError as kerr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
            return s_ # instead of s (we put back $) - OV 2023/01/27
        except Exception as othererr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            raise RuntimeError from othererr
    else:
        if escape:
            return s.format(**self.__dict__)
        else:
            return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)</code></pre>
</details>
</dd>
<dt id="forcefield.struct.fromkeys"><code class="name flex">
<span>def <span class="ident">fromkeys</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a structure from keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromkeys(self,keys):
    &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
    return self+struct(**dict.fromkeys(keys,None))</code></pre>
</details>
</dd>
<dt id="forcefield.struct.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>generate Python code of the equivalent structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self):
    &#34;&#34;&#34; generate Python code of the equivalent structure &#34;&#34;&#34;
    nk = len(self)
    if nk==0:
        print(&#34;X = struct()&#34;)
    else:
        ik = 0
        fmt = &#34;%%%ss=&#34; % max(10,max([len(k) for k in self.keys()])+2)
        print(&#34;\nX = struct(&#34;)
        for k in self.keys():
            ik += 1
            end = &#34;,\n&#34; if ik&lt;nk else &#34;\n&#34;+(fmt[:-1] % &#34;)&#34;)+&#34;\n&#34;
            v = getattr(self,k)
            if isinstance(v,(int,float)) or v == None:
                print(fmt % k,v,end=end)
            elif isinstance(v,str):
                print(fmt % k,f&#39;&#34;{v}&#34;&#39;,end=end)
            elif isinstance(v,(list,tuple)):
                print(fmt % k,v,end=end)
            else:
                print(fmt % k,&#34;/* unsupported type */&#34;,end=end)</code></pre>
</details>
</dd>
<dt id="forcefield.struct.getattr"><code class="name flex">
<span>def <span class="ident">getattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get attribute override to access both instance attributes and properties if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getattr(self,key):
    &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
    if key in self.__dict__:
        return self.__dict__[key]
    elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
         key not in self._excludedattr and \
         key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
        # If _propertyasattribute is True and it&#39;s a property, get its value
        return self.__class__.__dict__[key].fget(self)
    else:
        raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)</code></pre>
</details>
</dd>
<dt id="forcefield.struct.hasattr"><code class="name flex">
<span>def <span class="ident">hasattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the field exists, considering properties as regular attributes if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasattr(self, key):
    &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
    return key in self.__dict__ or (
        getattr(self, &#39;_propertyasattribute&#39;, False) and
        key not in self._excludedattr and
        key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
    )</code></pre>
</details>
</dd>
<dt id="forcefield.struct.isdefined"><code class="name flex">
<span>def <span class="ident">isdefined</span></span>(<span>self, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>isdefined(ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdefined(self,ref=None):
    &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
    nk = len(k)
    if ref is None:
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
            else:
                s.setattr(k[i],True)
    else:
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],ref))
            else:
                s.setattr(k[i],True)
    return s</code></pre>
</details>
</dd>
<dt id="forcefield.struct.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all elements as iterable key, value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
    return self.zip()</code></pre>
</details>
</dd>
<dt id="forcefield.struct.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34; return the fields &#34;&#34;&#34;
    # keys() is used by struct() and its iterator
    return [key for key in self.__dict__.keys() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="forcefield.struct.keyssorted"><code class="name flex">
<span>def <span class="ident">keyssorted</span></span>(<span>self, reverse=True)</span>
</code></dt>
<dd>
<div class="desc"><p>sort keys by length()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyssorted(self,reverse=True):
    &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
    klist = self.keys()
    l = [len(k) for k in klist]
    return [k for _,k in sorted(zip(l,klist),reverse=reverse)]</code></pre>
</details>
</dd>
<dt id="forcefield.struct.np2str"><code class="name flex">
<span>def <span class="ident">np2str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all np entries of s into their string representations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def np2str(self):
    &#34;&#34;&#34; Convert all np entries of s into their string representations  &#34;&#34;&#34;
    out = struct()
    def format_numpy_result(value):
        &#34;&#34;&#34;
        Converts a NumPy array or scalar into a string representation:
        - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
        - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
        - Non-ndarray inputs are returned without modification.

        Args:
            value (np.ndarray, scalar, or other): The value to format.

        Returns:
            str or original type: A properly formatted string for NumPy arrays/scalars or the original value.
        &#34;&#34;&#34;
        if np.isscalar(value):
            # If the value is a scalar, return it directly
            return repr(value)
        elif isinstance(value, np.ndarray):
            # Check if the array has exactly one element
            if value.size == 1:
                # Extract the scalar value
                return repr(value.item())
            # Convert the array to a nested list
            nested_list = value.tolist()
            # Recursively format the nested list into a valid string
            def list_to_string(lst):
                if isinstance(lst, list):
                    # Format lists with proper commas
                    return &#34;[&#34; + &#34;, &#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                else:
                    # Format scalars in the list
                    return repr(lst)

            return list_to_string(nested_list)
        else:
            # Return the input unmodified if not a NumPy array or scalar
            return value
    # process all entries in s
    for key,value in self.items():
        out.setattr(key,format_numpy_result(value))
    return out</code></pre>
</details>
</dd>
<dt id="forcefield.struct.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self,**kwargs):
    &#34;&#34;&#34; initialization &#34;&#34;&#34;
    self.__dict__.update(kwargs)</code></pre>
</details>
</dd>
<dt id="forcefield.struct.setattr"><code class="name flex">
<span>def <span class="ident">setattr</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>set field and value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setattr(self,key,value):
    &#34;&#34;&#34; set field and value &#34;&#34;&#34;
    if isinstance(value,list) and len(value)==0 and key in self:
        delattr(self, key)
    else:
        self.__dict__[key] = value</code></pre>
</details>
</dd>
<dt id="forcefield.struct.sortdefinitions"><code class="name flex">
<span>def <span class="ident">sortdefinitions</span></span>(<span>self, raiseerror=True, silentmode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>sortdefintions sorts all definitions
so that they can be executed as param().
If any inconsistency is found, an error message is generated.</p>
<p>Flags = default values
raiseerror=True show erros of True
silentmode=False no warning if True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortdefinitions(self,raiseerror=True,silentmode=False):
    &#34;&#34;&#34; sortdefintions sorts all definitions
        so that they can be executed as param().
        If any inconsistency is found, an error message is generated.

        Flags = default values
            raiseerror=True show erros of True
            silentmode=False no warning if True
    &#34;&#34;&#34;
    find = lambda xlist: [i for i, x in enumerate(xlist) if x]
    findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
    k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
    istatic = findnot(isexpr)
    idynamic = find(isexpr)
    static = struct.fromkeysvalues(
        [ k[i] for i in istatic ],
        [ v[i] for i in istatic ],
        makeparam = False)
    dynamic = struct.fromkeysvalues(
        [ k[i] for i in idynamic ],
        [ v[i] for i in idynamic ],
        makeparam=False)
    current = static # make static the current structure
    nmissing, anychange, errorfound = len(dynamic), False, False
    while nmissing:
        itst, found = 0, False
        while itst&lt;nmissing and not found:
            teststruct = current + dynamic[[itst]] # add the test field
            found = all(list(teststruct.isdefined()))
            ifound = itst
            itst += 1
        if found:
            current = teststruct # we accept the new field
            dynamic[ifound] = []
            nmissing -= 1
            anychange = True
        else:
            if raiseerror:
                raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                               (nmissing,len(self),self._ftype))
            else:
                if (not errorfound) and (not silentmode):
                    print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                          (nmissing,len(self),self._ftype))
                current = teststruct # we accept the new field (even if it cannot be interpreted)
                dynamic[ifound] = []
                nmissing -= 1
                errorfound = True
    if anychange:
        self.clear() # reset all fields and assign them in the proper order
        k,v = current.keys(), current.values()
        for i in range(len(k)):
            self.setattr(k[i],v[i])</code></pre>
</details>
</dd>
<dt id="forcefield.struct.struct2dict"><code class="name flex">
<span>def <span class="ident">struct2dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create a dictionary from the current structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2dict(self):
    &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
    return dict(self.zip())</code></pre>
</details>
</dd>
<dt id="forcefield.struct.struct2param"><code class="name flex">
<span>def <span class="ident">struct2param</span></span>(<span>self, protection=False, evaluation=True)</span>
</code></dt>
<dd>
<div class="desc"><p>convert an object struct() to param()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2param(self,protection=False,evaluation=True):
    &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
    p = param(**self.struct2dict())
    for i in range(len(self)):
        if isinstance(self[i],pstr): p[i] = pstr(p[i])
    p._protection = protection
    p._evaluation = evaluation
    return p</code></pre>
</details>
</dd>
<dt id="forcefield.struct.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update multiple fields at once, while protecting certain attributes.</p>
<h2 id="parameters">Parameters:</h2>
<p>**kwargs : dict
The fields to update and their new values.</p>
<p>Protected attributes defined in _excludedattr are not updated.</p>
<h2 id="usage">Usage:</h2>
<p>s.update(a=10, b=[1, 2, 3], new_field="new_value")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update multiple fields at once, while protecting certain attributes.

    Parameters:
    -----------
    **kwargs : dict
        The fields to update and their new values.

    Protected attributes defined in _excludedattr are not updated.

    Usage:
    ------
    s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
    &#34;&#34;&#34;
    protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

    for key, value in kwargs.items():
        if key in protected_attributes:
            print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
        else:
            self.setattr(key, value)</code></pre>
</details>
</dd>
<dt id="forcefield.struct.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34; return the values &#34;&#34;&#34;
    # values() is used by struct() and its iterator
    return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="forcefield.struct.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, overwrite=True, mkdir=False)</span>
</code></dt>
<dd>
<div class="desc"><p>write the equivalent structure (not recursive for nested struct)
write(filename, overwrite=True, mkdir=False)</p>
<p>Parameters:
- file: The file path to write to.
- overwrite: Whether to overwrite the file if it exists (default: True).
- mkdir: Whether to create the directory if it doesn't exist (default: False).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, overwrite=True, mkdir=False):
    &#34;&#34;&#34;
        write the equivalent structure (not recursive for nested struct)
            write(filename, overwrite=True, mkdir=False)

        Parameters:
        - file: The file path to write to.
        - overwrite: Whether to overwrite the file if it exists (default: True).
        - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()

    # Check if the directory exists or if mkdir is set to True, create it
    if mkdir:
        file_path.parent.mkdir(parents=True, exist_ok=True)
    elif not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If overwrite is False and the file already exists, raise an exception
    if not overwrite and file_path.exists():
        raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
    # Open and write to the file using the resolved path
    with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
        print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
        for k, v in self.items():
            if v is None:
                print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
            elif isinstance(v, (int, float)):
                print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
            elif isinstance(v, str):
                print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
            else:
                print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="forcefield.struct.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>zip keys and values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self):
    &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
    return zip(self.keys(),self.values())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="forcefield.tlsph"><code class="flex name class">
<span>class <span class="ident">tlsph</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD:TLSPH forcefield (total Lagrangian)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tlsph(smd):
    &#34;&#34;&#34; SMD:TLSPH forcefield (total Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;tlsph&#34;)
    description = smd.description + struct(style=&#34;SMD:TLSPH - total Lagrangian for solids&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Diagonal pair coefficient tlsph
    pair_coeff      %d %d smd/tlsph *COMMON ${rho} ${E} ${nu} ${q1} ${q2} ${Hg} ${Cp} &amp;
                    *STRENGTH_LINEAR_PLASTIC ${sigma_yield} ${hardening} &amp;
                    *EOS_LINEAR &amp;
                    *END
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="forcefield.smd" href="#forcefield.smd">smd</a></li>
<li><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="forcefield.saltTLSPH" href="#forcefield.saltTLSPH">saltTLSPH</a></li>
<li><a title="forcefield.solidfood" href="#forcefield.solidfood">solidfood</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forcefield.tlsph.PAIR_DIAGCOEFF"><code class="name">var <span class="ident">PAIR_DIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.tlsph.PAIR_OFFDIAGCOEFF"><code class="name">var <span class="ident">PAIR_OFFDIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.tlsph.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.tlsph.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="forcefield.smd" href="#forcefield.smd">smd</a></b></code>:
<ul class="hlist">
<li><code><a title="forcefield.smd.getallattributes" href="#forcefield.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="forcefield.smd.pair_diagcoeff" href="#forcefield.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="forcefield.smd.pair_offdiagcoeff" href="#forcefield.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="forcefield.smd.pair_style" href="#forcefield.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="forcefield.smd.printheader" href="#forcefield.forcefield.printheader">printheader</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="forcefield.ulsph"><code class="flex name class">
<span>class <span class="ident">ulsph</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD:ULSPH forcefield (updated Lagrangian)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ulsph(smd):
    &#34;&#34;&#34; SMD:ULSPH forcefield (updated Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;ulsph&#34;)
    description = smd.description + struct(style=&#34;SMD:ULSPH - updated Lagrangian for fluids - SPH-like&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Pair diagonal coefficient ulsph
    pair_coeff      %d %d smd/ulsph *COMMON ${rho} ${c0} ${q1} ${Cp} 0 &amp;
                    *EOS_TAIT ${taitexponent} &amp;
                    *END
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="forcefield.smd" href="#forcefield.smd">smd</a></li>
<li><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="forcefield.water" href="#forcefield.water">water</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forcefield.ulsph.PAIR_DIAGCOEFF"><code class="name">var <span class="ident">PAIR_DIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.ulsph.PAIR_OFFDIAGCOEFF"><code class="name">var <span class="ident">PAIR_OFFDIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.ulsph.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.ulsph.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="forcefield.smd" href="#forcefield.smd">smd</a></b></code>:
<ul class="hlist">
<li><code><a title="forcefield.smd.getallattributes" href="#forcefield.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="forcefield.smd.pair_diagcoeff" href="#forcefield.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="forcefield.smd.pair_offdiagcoeff" href="#forcefield.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="forcefield.smd.pair_style" href="#forcefield.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="forcefield.smd.printheader" href="#forcefield.forcefield.printheader">printheader</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="forcefield.water"><code class="flex name class">
<span>class <span class="ident">water</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>water material (smd:ulsph): generic water model
water()
water(beadtype=index, userid="myfluid", USER=&hellip;)</p>
<p>override any propery with USER.parameter (set only the parameters you want to override)
USER.rho: density in kg/m3 (default=1000)
USER.c0: speed of the sound in m/s (default=10.0)
USER.q1: standard artificial viscosity linear coefficient (default=1.0)
USER.Cp: heat capacity of material &ndash; not used here (default=1.0)
USER.contact_scale: scaling coefficient for contact (default=1.5)
USER.contact_stiffness: contact stifness in Pa (default="2.5<em>${c0}^2</em>${rho}")</p>
<p>water forcefield:
water(beadtype=index, userid="myfluid")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class water(ulsph):
    &#34;&#34;&#34; water material (smd:ulsph): generic water model
            water()
            water(beadtype=index, userid=&#34;myfluid&#34;, USER=...)

            override any propery with USER.parameter (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=1000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.q1: standard artificial viscosity linear coefficient (default=1.0)
                USER.Cp: heat capacity of material -- not used here (default=1.0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = ulsph.name + struct(material=&#34;water&#34;)
    description = ulsph.description + struct(material=&#34;water beads - SPH-like&#34;)
    userid = &#39;water&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; water forcefield:
            water(beadtype=index, userid=&#34;myfluid&#34;) &#34;&#34;&#34;
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # water-water interactions
            rho = 1000,
            c0 = 10.0,
            q1 = 1.0,
            Cp = 1.0,
            taitexponent = 7,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="forcefield.ulsph" href="#forcefield.ulsph">ulsph</a></li>
<li><a title="forcefield.smd" href="#forcefield.smd">smd</a></li>
<li><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="forcefield.water.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.water.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.water.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="forcefield.water.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="forcefield.ulsph" href="#forcefield.ulsph">ulsph</a></b></code>:
<ul class="hlist">
<li><code><a title="forcefield.ulsph.getallattributes" href="#forcefield.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="forcefield.ulsph.pair_diagcoeff" href="#forcefield.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="forcefield.ulsph.pair_offdiagcoeff" href="#forcefield.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="forcefield.ulsph.pair_style" href="#forcefield.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="forcefield.ulsph.printheader" href="#forcefield.forcefield.printheader">printheader</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#synopsis-of-forcefield-class">Synopsis of forcefield Class</a><ul>
<li><a href="#key-attributes">Key Attributes:</a></li>
<li><a href="#key-methods">Key Methods:</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="forcefield.forcefield" href="#forcefield.forcefield">forcefield</a></code></h4>
<ul class="two-column">
<li><code><a title="forcefield.forcefield.beadtype" href="#forcefield.forcefield.beadtype">beadtype</a></code></li>
<li><code><a title="forcefield.forcefield.description" href="#forcefield.forcefield.description">description</a></code></li>
<li><code><a title="forcefield.forcefield.getallattributes" href="#forcefield.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="forcefield.forcefield.name" href="#forcefield.forcefield.name">name</a></code></li>
<li><code><a title="forcefield.forcefield.pair_diagcoeff" href="#forcefield.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="forcefield.forcefield.pair_offdiagcoeff" href="#forcefield.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="forcefield.forcefield.pair_style" href="#forcefield.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="forcefield.forcefield.parameters" href="#forcefield.forcefield.parameters">parameters</a></code></li>
<li><code><a title="forcefield.forcefield.printheader" href="#forcefield.forcefield.printheader">printheader</a></code></li>
<li><code><a title="forcefield.forcefield.userid" href="#forcefield.forcefield.userid">userid</a></code></li>
<li><code><a title="forcefield.forcefield.version" href="#forcefield.forcefield.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forcefield.none" href="#forcefield.none">none</a></code></h4>
<ul class="">
<li><code><a title="forcefield.none.PAIR_DIAGCOEFF" href="#forcefield.none.PAIR_DIAGCOEFF">PAIR_DIAGCOEFF</a></code></li>
<li><code><a title="forcefield.none.PAIR_OFFDIAGCOEFF" href="#forcefield.none.PAIR_OFFDIAGCOEFF">PAIR_OFFDIAGCOEFF</a></code></li>
<li><code><a title="forcefield.none.description" href="#forcefield.none.description">description</a></code></li>
<li><code><a title="forcefield.none.name" href="#forcefield.none.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forcefield.paramauto" href="#forcefield.paramauto">paramauto</a></code></h4>
</li>
<li>
<h4><code><a title="forcefield.parameterforcefield" href="#forcefield.parameterforcefield">parameterforcefield</a></code></h4>
</li>
<li>
<h4><code><a title="forcefield.rigidwall" href="#forcefield.rigidwall">rigidwall</a></code></h4>
<ul class="">
<li><code><a title="forcefield.rigidwall.description" href="#forcefield.rigidwall.description">description</a></code></li>
<li><code><a title="forcefield.rigidwall.name" href="#forcefield.rigidwall.name">name</a></code></li>
<li><code><a title="forcefield.rigidwall.userid" href="#forcefield.rigidwall.userid">userid</a></code></li>
<li><code><a title="forcefield.rigidwall.version" href="#forcefield.rigidwall.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forcefield.saltTLSPH" href="#forcefield.saltTLSPH">saltTLSPH</a></code></h4>
<ul class="">
<li><code><a title="forcefield.saltTLSPH.description" href="#forcefield.saltTLSPH.description">description</a></code></li>
<li><code><a title="forcefield.saltTLSPH.name" href="#forcefield.saltTLSPH.name">name</a></code></li>
<li><code><a title="forcefield.saltTLSPH.userid" href="#forcefield.saltTLSPH.userid">userid</a></code></li>
<li><code><a title="forcefield.saltTLSPH.version" href="#forcefield.saltTLSPH.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forcefield.smd" href="#forcefield.smd">smd</a></code></h4>
<ul class="">
<li><code><a title="forcefield.smd.PAIR_STYLE" href="#forcefield.smd.PAIR_STYLE">PAIR_STYLE</a></code></li>
<li><code><a title="forcefield.smd.description" href="#forcefield.smd.description">description</a></code></li>
<li><code><a title="forcefield.smd.name" href="#forcefield.smd.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forcefield.solidfood" href="#forcefield.solidfood">solidfood</a></code></h4>
<ul class="">
<li><code><a title="forcefield.solidfood.description" href="#forcefield.solidfood.description">description</a></code></li>
<li><code><a title="forcefield.solidfood.name" href="#forcefield.solidfood.name">name</a></code></li>
<li><code><a title="forcefield.solidfood.userid" href="#forcefield.solidfood.userid">userid</a></code></li>
<li><code><a title="forcefield.solidfood.version" href="#forcefield.solidfood.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forcefield.struct" href="#forcefield.struct">struct</a></code></h4>
<ul class="two-column">
<li><code><a title="forcefield.struct.check" href="#forcefield.struct.check">check</a></code></li>
<li><code><a title="forcefield.struct.clear" href="#forcefield.struct.clear">clear</a></code></li>
<li><code><a title="forcefield.struct.dict2struct" href="#forcefield.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="forcefield.struct.disp" href="#forcefield.struct.disp">disp</a></code></li>
<li><code><a title="forcefield.struct.dispmax" href="#forcefield.struct.dispmax">dispmax</a></code></li>
<li><code><a title="forcefield.struct.format" href="#forcefield.struct.format">format</a></code></li>
<li><code><a title="forcefield.struct.format_array" href="#forcefield.struct.format_array">format_array</a></code></li>
<li><code><a title="forcefield.struct.format_legacy" href="#forcefield.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="forcefield.struct.fromkeys" href="#forcefield.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="forcefield.struct.fromkeysvalues" href="#forcefield.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="forcefield.struct.generator" href="#forcefield.struct.generator">generator</a></code></li>
<li><code><a title="forcefield.struct.getattr" href="#forcefield.struct.getattr">getattr</a></code></li>
<li><code><a title="forcefield.struct.hasattr" href="#forcefield.struct.hasattr">hasattr</a></code></li>
<li><code><a title="forcefield.struct.isdefined" href="#forcefield.struct.isdefined">isdefined</a></code></li>
<li><code><a title="forcefield.struct.isempty" href="#forcefield.struct.isempty">isempty</a></code></li>
<li><code><a title="forcefield.struct.isexpression" href="#forcefield.struct.isexpression">isexpression</a></code></li>
<li><code><a title="forcefield.struct.isstrdefined" href="#forcefield.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="forcefield.struct.isstrexpression" href="#forcefield.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="forcefield.struct.items" href="#forcefield.struct.items">items</a></code></li>
<li><code><a title="forcefield.struct.keys" href="#forcefield.struct.keys">keys</a></code></li>
<li><code><a title="forcefield.struct.keyssorted" href="#forcefield.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="forcefield.struct.np2str" href="#forcefield.struct.np2str">np2str</a></code></li>
<li><code><a title="forcefield.struct.read" href="#forcefield.struct.read">read</a></code></li>
<li><code><a title="forcefield.struct.scan" href="#forcefield.struct.scan">scan</a></code></li>
<li><code><a title="forcefield.struct.set" href="#forcefield.struct.set">set</a></code></li>
<li><code><a title="forcefield.struct.setattr" href="#forcefield.struct.setattr">setattr</a></code></li>
<li><code><a title="forcefield.struct.sortdefinitions" href="#forcefield.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="forcefield.struct.struct2dict" href="#forcefield.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="forcefield.struct.struct2param" href="#forcefield.struct.struct2param">struct2param</a></code></li>
<li><code><a title="forcefield.struct.update" href="#forcefield.struct.update">update</a></code></li>
<li><code><a title="forcefield.struct.values" href="#forcefield.struct.values">values</a></code></li>
<li><code><a title="forcefield.struct.write" href="#forcefield.struct.write">write</a></code></li>
<li><code><a title="forcefield.struct.zip" href="#forcefield.struct.zip">zip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forcefield.tlsph" href="#forcefield.tlsph">tlsph</a></code></h4>
<ul class="">
<li><code><a title="forcefield.tlsph.PAIR_DIAGCOEFF" href="#forcefield.tlsph.PAIR_DIAGCOEFF">PAIR_DIAGCOEFF</a></code></li>
<li><code><a title="forcefield.tlsph.PAIR_OFFDIAGCOEFF" href="#forcefield.tlsph.PAIR_OFFDIAGCOEFF">PAIR_OFFDIAGCOEFF</a></code></li>
<li><code><a title="forcefield.tlsph.description" href="#forcefield.tlsph.description">description</a></code></li>
<li><code><a title="forcefield.tlsph.name" href="#forcefield.tlsph.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forcefield.ulsph" href="#forcefield.ulsph">ulsph</a></code></h4>
<ul class="">
<li><code><a title="forcefield.ulsph.PAIR_DIAGCOEFF" href="#forcefield.ulsph.PAIR_DIAGCOEFF">PAIR_DIAGCOEFF</a></code></li>
<li><code><a title="forcefield.ulsph.PAIR_OFFDIAGCOEFF" href="#forcefield.ulsph.PAIR_OFFDIAGCOEFF">PAIR_OFFDIAGCOEFF</a></code></li>
<li><code><a title="forcefield.ulsph.description" href="#forcefield.ulsph.description">description</a></code></li>
<li><code><a title="forcefield.ulsph.name" href="#forcefield.ulsph.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="forcefield.water" href="#forcefield.water">water</a></code></h4>
<ul class="">
<li><code><a title="forcefield.water.description" href="#forcefield.water.description">description</a></code></li>
<li><code><a title="forcefield.water.name" href="#forcefield.water.name">name</a></code></li>
<li><code><a title="forcefield.water.userid" href="#forcefield.water.userid">userid</a></code></li>
<li><code><a title="forcefield.water.version" href="#forcefield.water.version">version</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>