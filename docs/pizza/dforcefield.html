<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dforcefield API documentation</title>
<meta name="description" content="Synopsis of `dforcefield` Class
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dforcefield</code></h1>
</header>
<section id="section-intro">
<h1 id="synopsis-of-dforcefield-class">Synopsis of <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> Class</h1>
<p>The <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> class enables the dynamic creation and modification of forcefields at runtime,
in contrast to the static material customization approach used in the <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code> class.
Whereas the <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code> class relies on predefined material classes (e.g., in <code>pizza.generic</code>)
and supports inheritance to manage complex materials, <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> allows for flexible and
rapid creation of forcefields without a predefined library. This makes <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> ideal for
prototyping and experimenting with forcefield models.</p>
<p>The class seamlessly integrates both static and dynamic forcefields, which can be used interchangeably
to define objects built with atoms, set the interactions between those objects, and generate the
equivalent scripts. This flexibility enables users to choose between dynamic instances (<code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code>)
and static classes (<code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code>) for defining <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> interactions.</p>
<p>Moreover, dynamic forcefields can also be defined using methods from <code><a title="dforcefield.generic" href="#dforcefield.generic">generic</a></code> classes. These
<code><a title="dforcefield.generic" href="#dforcefield.generic">generic</a></code> classes allow creating high-level forcefields dynamically, providing another layer of
customization that can be combined with both static and dynamic forcefields.</p>
<h2 id="key-differences-between-forcefield-generic-and-dforcefield">Key Differences Between <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code>, <code><a title="dforcefield.generic" href="#dforcefield.generic">generic</a></code>, and <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code>:</h2>
<ul>
<li>
<p><strong><code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code></strong>:</p>
<ul>
<li>New materials are defined using classes, often within a material library (e.g., <code>pizza.generic</code>).</li>
<li>Supports inheritance to manage complex materials and extend functionality.</li>
<li>Primarily used for well-defined, library-based material management.</li>
</ul>
</li>
<li>
<p><strong><code><a title="dforcefield.generic" href="#dforcefield.generic">generic</a></code></strong>:</p>
<ul>
<li>Provides high-level forcefield definitions via methods that can be dynamically called.</li>
<li>These dynamic definitions can be used interchangeably with static forcefields.</li>
<li>Suitable for defining specialized forcefields on the fly without modifying the core library.</li>
</ul>
</li>
<li>
<p><strong><code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code></strong>:</p>
<ul>
<li>Enables dynamic definition of forcefields at runtime without needing a predefined library.</li>
<li>Ideal for rapid prototyping and testing new configurations on the fly.</li>
<li>Attributes like <code>parameters</code>, <code>beadtype</code>, and <code>userid</code> can be modified at runtime and
automatically injected into the base forcefield class for flexible interaction modeling.</li>
<li>Provides a method, <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code>, to create objects compatible with static forcefields.</li>
<li>Allows integrating high-level forcefield definitions from <code><a title="dforcefield.generic" href="#dforcefield.generic">generic</a></code> methods, enhancing
dynamic forcefield customization.</li>
</ul>
</li>
</ul>
<h2 id="key-attributes">Key Attributes:</h2>
<ul>
<li><code>base_class</code> (<code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code>): The base forcefield class (e.g., <code>ulsph</code>) from which behavior
is inherited.</li>
<li><code>parameters</code> (<code><a title="dforcefield.parameterforcefield" href="#dforcefield.parameterforcefield">parameterforcefield</a></code>): Stores interaction parameters that are dynamically
injected into the <code>base_class</code>.</li>
<li><code>beadtype</code> (int): The bead type associated with the <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance, used in
forcefield calculations.</li>
<li><code>userid</code> (str): A unique identifier for the forcefield instance, used in interaction commands.</li>
<li><code>name</code> (struct or str): A human-readable name for the <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance.</li>
<li><code>description</code> (struct or str): A brief description of the <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance.</li>
<li><code>version</code> (float): The version number of the <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance.</li>
</ul>
<h2 id="key-methods">Key Methods:</h2>
<ul>
<li><code>_inject_attributes()</code>: Injects <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> attributes (like <code>parameters</code>, <code>beadtype</code>,
and <code>userid</code>) into the <code>base_class</code> to ensure it operates with the correct attributes.</li>
<li><code>pair_style(printflag=True, raw=False)</code>: Delegates the pair style computation to the <code>base_class</code>,
ensuring it uses the current <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> attributes.</li>
<li><code>pair_diagcoeff(printflag=True, i=None, raw=False)</code>: Delegates diagonal pair coefficient
computation to the <code>base_class</code>, allowing bead type <code>i</code> to be overridden.</li>
<li><code>pair_offdiagcoeff(o=None, printflag=True, i=None, raw=False)</code>: Delegates off-diagonal pair coefficient
computation to the <code>base_class</code>, allowing bead type <code>i</code> and interacting forcefield <code>o</code> to be overridden.</li>
<li><code>scriptobject(beadtype=None, name=None, fullname=None, filename=None, group=None, style=None, USER=scriptdata())</code>:
Creates a <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> from the current <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance, making it compatible with static forcefields.</li>
<li><code>missingVariables(isimplicit_missing=True, output_aslist=False)</code>: Lists undefined variables in <code>parameters</code>,
identifying missing implicit definitions (e.g., <code>${varname}</code>).</li>
</ul>
<h2 id="usage-example">Usage Example:</h2>
<pre><code># Create a dynamic water forcefield using ulsph as the base class
dynamic_water = dforcefield(
    base_class=ulsph,
    beadtype=1,
    userid="dynamic_water",
    USER=parameterforcefield(
        rho=1000,
        c0=10.0,
        q1=1.0,
        Cp=1.0,
        taitexponent=7,
        contact_scale=1.5,
        contact_stiffness="2.5*${c0}^2*${rho}"
    )
)
print(f"Water parameters: {dynamic_water.parameters}")
print(f"Water Cp: {dynamic_water.Cp}")
dynamic_water.pair_style()  # Outputs the pair style command


# Create a dynamic solidfood forcefield using tlsph as the base class
dynamic_solidfood = dforcefield(
    base_class=tlsph,
    beadtype=2,
    userid="dynamic_solidfood",
    rho=1000,
    c0=10.0,
    E="5*${c0}^2*${rho}",
    nu=0.3,
    q1=1.0,
    q2=0.0,
    Hg=10.0,
    Cp=1.0,
    sigma_yield="0.1*${E}",
    hardening=0,
    contact_scale=1.5,
    contact_stiffness="2.5*${c0}^2*${rho}"
)
print(f"Solidfood parameters: {dynamic_solidfood.parameters}")
dynamic_solidfood.pair_style()  # Outputs the pair style command

# Create a new solidfood variant and save it
new_food = dynamic_solidfood.copy(rho=2100, q1=4, E=1000, name="new food")
new_food.save(overwrite=True)

# Load the saved forcefield and compare
loaded_food = dforcefield.load(new_food.userid + ".txt")
new_food.compare(loaded_food, printflag=True)

# Check for missing variables
missing_vars = new_food.missingVariables()
print(f"Missing variables: {missing_vars}")


# Generate a forcefield from text
ff_text = '''
# DFORCEFIELD SAVE FILE

# Forcefield attributes
base_class="tlsph"
beadtype = 2
userid = dynamic_solidfood (copy)
version = 0.1

# Description of the forcefield
description:{forcefield="LAMMPS:SMD - solid, liquid, rigid forcefields (continuum mechanics)", style="SMD:TLSPH - total Lagrangian for solids", material="dforcefield beads - SPH-like"}

# Name of the forcefield
name:{forcefield="LAMMPS:SMD", style="tlsph", material="new food"}

# Parameters for the forcefield
contact_scale = 1.5
E = 1000
nu = 0.3
q2 = 0.0
hardening = 0
Hg = 10.0
rho = 2100
Cp = 1.0
q1 = 4
c0 = 10.0
sigma_yield = 0.1*${E}
contact_stiffness = 2.5*${c0}^2*${rho}
'''

# Parse the forcefield from text
parsed_ff = dforcefield.parsesyntax(ff_text)
print(parsed_ff.script)  # Outputs the raw content from the pair_* methods

# Check missing variables
missing_vars = parsed_ff.missingVariables()
print(f"Missing variables: {missing_vars}")


# *********************************************************************************************
# Production Example: Scriptobject Creation and Combination
#
# This example demonstrates the creation and combination of &lt;code&gt;&lt;a title="dforcefield.scriptobject" href="#dforcefield.scriptobject"&gt;scriptobject&lt;/a&gt;&lt;/code&gt; instances from both
# static forcefield classes and dynamic forcefield instances (via &lt;code&gt;&lt;a title="dforcefield.dforcefield" href="#dforcefield.dforcefield"&gt;dforcefield&lt;/a&gt;&lt;/code&gt;).
#
# Key Points:
# ------------
# 1. **Static and Dynamic Forcefields**:
#    - Scriptobjects can be created using static forcefields (e.g., &lt;code&gt;rigidwall&lt;/code&gt;, &lt;code&gt;solidfood&lt;/code&gt;, etc.)
#      or dynamic forcefields generated from a &lt;code&gt;&lt;a title="dforcefield.dforcefield" href="#dforcefield.dforcefield"&gt;dforcefield&lt;/a&gt;&lt;/code&gt; instance (e.g., &lt;code&gt;waterFF&lt;/code&gt;).
#    - Dynamic forcefields can either be passed directly to the &lt;code&gt;pizza.script.scriptobject()&lt;/code&gt;
#      constructor or instantiated through the &lt;code&gt;&lt;a title="dforcefield.scriptobject" href="#dforcefield.scriptobject"&gt;scriptobject&lt;/a&gt;&lt;/code&gt; method of any &lt;code&gt;pizza.dforcefield&lt;/code&gt; object.
#
# 2. **Combining Scriptobjects**:
#    - Scriptobjects can be combined using the `+` operator to create a collection of objects.
#    - This collection of scriptobjects can then be scripted dynamically using the &lt;code&gt;script&lt;/code&gt; property
#      to generate their interaction definitions.
#
# 3. **Geometry Input**:
#    - Geometry for the scriptobjects can be provided either via an input file (using &lt;code&gt;filename&lt;/code&gt;)
#      or dynamically using &lt;code&gt;pizza.region.region()&lt;/code&gt;.
#
# **********************************************************************************************

from pizza.forcefield import rigidwall, solidfood, water

# Create a dynamic forcefield for water with a specific density (rho=900) and beadtype=1
waterFF = dforcefield(base_class="water", rho=900, beadtype=1)

# Define water beads using the dforcefield instance's scriptobject method
bwater = waterFF.scriptobject(name="water", group=["A", "D"], filename="mygeom")

# Alternatively, define water beads by passing the dynamic forcefield directly to scriptobject
bwater2 = scriptobject(name="water", group=["A", "D"], filename="mygeom", forcefield=waterFF)

# Define other dummy beads using static forcefields
b1 = scriptobject(name="bead 1", group=["A", "B", "C"], filename='myfile1', forcefield=rigidwall())
b2 = scriptobject(name="bead 2", group=["B", "C"], filename='myfile1', forcefield=rigidwall())
b3 = scriptobject(name="bead 3", group=["B", "D", "E"], forcefield=solidfood())
b4 = scriptobject(name="bead 4", group="D", beadtype=1, filename="myfile2", forcefield=water())

# Combine the scriptobjects into a collection using the '+' operator
collection = bwater + b1 + b2 + b3 + b4

# Generate the script for the interactions in the collection
collection.script

# Similarly, using the alternate water bead definition (bwater2)
collection2 = bwater2 + b1 + b2 + b3 + b4
collection2.script
</code></pre>
<p>Created on Tue Sep 10 17:11:40 2024</p>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li>Python 3.x</li>
<li>LAMMPS</li>
<li>Pizza3.pizza</li>
</ul>
<h2 id="installation">Installation</h2>
<p>To use the Pizza3.pizza module, ensure that you have Python 3.x and LAMMPS installed. You can integrate the module into your project by placing the <code>region.py</code> file in your working directory or your Python path.</p>
<h2 id="license">License</h2>
<p>This project is licensed under the terms of the GPLv3 license.</p>
<h2 id="contact">Contact</h2>
<p>For any queries or contributions, please contact the maintainer:
- Olivier Vitrac, Han Chen
- Email: olivier.vitrac@agroparistech.fr</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Synopsis of `dforcefield` Class
===============================

The `dforcefield` class enables the dynamic creation and modification of forcefields at runtime,
in contrast to the static material customization approach used in the `forcefield` class.
Whereas the `forcefield` class relies on predefined material classes (e.g., in `pizza.generic`)
and supports inheritance to manage complex materials, `dforcefield` allows for flexible and
rapid creation of forcefields without a predefined library. This makes `dforcefield` ideal for
prototyping and experimenting with forcefield models.

The class seamlessly integrates both static and dynamic forcefields, which can be used interchangeably
to define objects built with atoms, set the interactions between those objects, and generate the
equivalent scripts. This flexibility enables users to choose between dynamic instances (`dforcefield`)
and static classes (`forcefield`) for defining `scriptobject` interactions.

Moreover, dynamic forcefields can also be defined using methods from `generic` classes. These
`generic` classes allow creating high-level forcefields dynamically, providing another layer of
customization that can be combined with both static and dynamic forcefields.

Key Differences Between `forcefield`, `generic`, and `dforcefield`:
-------------------------------------------------------------------
- **`forcefield`**:
    - New materials are defined using classes, often within a material library (e.g., `pizza.generic`).
    - Supports inheritance to manage complex materials and extend functionality.
    - Primarily used for well-defined, library-based material management.

- **`generic`**:
    - Provides high-level forcefield definitions via methods that can be dynamically called.
    - These dynamic definitions can be used interchangeably with static forcefields.
    - Suitable for defining specialized forcefields on the fly without modifying the core library.

- **`dforcefield`**:
    - Enables dynamic definition of forcefields at runtime without needing a predefined library.
    - Ideal for rapid prototyping and testing new configurations on the fly.
    - Attributes like `parameters`, `beadtype`, and `userid` can be modified at runtime and
      automatically injected into the base forcefield class for flexible interaction modeling.
    - Provides a method, `scriptobject()`, to create objects compatible with static forcefields.
    - Allows integrating high-level forcefield definitions from `generic` methods, enhancing
      dynamic forcefield customization.

Key Attributes:
---------------
- `base_class` (`forcefield`): The base forcefield class (e.g., `ulsph`) from which behavior
  is inherited.
- `parameters` (`parameterforcefield`): Stores interaction parameters that are dynamically
  injected into the `base_class`.
- `beadtype` (int): The bead type associated with the `dforcefield` instance, used in
  forcefield calculations.
- `userid` (str): A unique identifier for the forcefield instance, used in interaction commands.
- `name` (struct or str): A human-readable name for the `dforcefield` instance.
- `description` (struct or str): A brief description of the `dforcefield` instance.
- `version` (float): The version number of the `dforcefield` instance.

Key Methods:
------------
- `_inject_attributes()`: Injects `dforcefield` attributes (like `parameters`, `beadtype`,
  and `userid`) into the `base_class` to ensure it operates with the correct attributes.
- `pair_style(printflag=True, raw=False)`: Delegates the pair style computation to the `base_class`,
  ensuring it uses the current `dforcefield` attributes.
- `pair_diagcoeff(printflag=True, i=None, raw=False)`: Delegates diagonal pair coefficient
  computation to the `base_class`, allowing bead type `i` to be overridden.
- `pair_offdiagcoeff(o=None, printflag=True, i=None, raw=False)`: Delegates off-diagonal pair coefficient
  computation to the `base_class`, allowing bead type `i` and interacting forcefield `o` to be overridden.
- `scriptobject(beadtype=None, name=None, fullname=None, filename=None, group=None, style=None, USER=scriptdata())`:
  Creates a `scriptobject` from the current `dforcefield` instance, making it compatible with static forcefields.
- `missingVariables(isimplicit_missing=True, output_aslist=False)`: Lists undefined variables in `parameters`,
  identifying missing implicit definitions (e.g., `${varname}`).

Usage Example:
--------------
    # Create a dynamic water forcefield using ulsph as the base class
    dynamic_water = dforcefield(
        base_class=ulsph,
        beadtype=1,
        userid=&#34;dynamic_water&#34;,
        USER=parameterforcefield(
            rho=1000,
            c0=10.0,
            q1=1.0,
            Cp=1.0,
            taitexponent=7,
            contact_scale=1.5,
            contact_stiffness=&#34;2.5*${c0}^2*${rho}&#34;
        )
    )
    print(f&#34;Water parameters: {dynamic_water.parameters}&#34;)
    print(f&#34;Water Cp: {dynamic_water.Cp}&#34;)
    dynamic_water.pair_style()  # Outputs the pair style command


    # Create a dynamic solidfood forcefield using tlsph as the base class
    dynamic_solidfood = dforcefield(
        base_class=tlsph,
        beadtype=2,
        userid=&#34;dynamic_solidfood&#34;,
        rho=1000,
        c0=10.0,
        E=&#34;5*${c0}^2*${rho}&#34;,
        nu=0.3,
        q1=1.0,
        q2=0.0,
        Hg=10.0,
        Cp=1.0,
        sigma_yield=&#34;0.1*${E}&#34;,
        hardening=0,
        contact_scale=1.5,
        contact_stiffness=&#34;2.5*${c0}^2*${rho}&#34;
    )
    print(f&#34;Solidfood parameters: {dynamic_solidfood.parameters}&#34;)
    dynamic_solidfood.pair_style()  # Outputs the pair style command

    # Create a new solidfood variant and save it
    new_food = dynamic_solidfood.copy(rho=2100, q1=4, E=1000, name=&#34;new food&#34;)
    new_food.save(overwrite=True)

    # Load the saved forcefield and compare
    loaded_food = dforcefield.load(new_food.userid + &#34;.txt&#34;)
    new_food.compare(loaded_food, printflag=True)

    # Check for missing variables
    missing_vars = new_food.missingVariables()
    print(f&#34;Missing variables: {missing_vars}&#34;)


    # Generate a forcefield from text
    ff_text = &#39;&#39;&#39;
    # DFORCEFIELD SAVE FILE

    # Forcefield attributes
    base_class=&#34;tlsph&#34;
    beadtype = 2
    userid = dynamic_solidfood (copy)
    version = 0.1

    # Description of the forcefield
    description:{forcefield=&#34;LAMMPS:SMD - solid, liquid, rigid forcefields (continuum mechanics)&#34;, style=&#34;SMD:TLSPH - total Lagrangian for solids&#34;, material=&#34;dforcefield beads - SPH-like&#34;}

    # Name of the forcefield
    name:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;new food&#34;}

    # Parameters for the forcefield
    contact_scale = 1.5
    E = 1000
    nu = 0.3
    q2 = 0.0
    hardening = 0
    Hg = 10.0
    rho = 2100
    Cp = 1.0
    q1 = 4
    c0 = 10.0
    sigma_yield = 0.1*${E}
    contact_stiffness = 2.5*${c0}^2*${rho}
    &#39;&#39;&#39;

    # Parse the forcefield from text
    parsed_ff = dforcefield.parsesyntax(ff_text)
    print(parsed_ff.script)  # Outputs the raw content from the pair_* methods

    # Check missing variables
    missing_vars = parsed_ff.missingVariables()
    print(f&#34;Missing variables: {missing_vars}&#34;)


    # *********************************************************************************************
    # Production Example: Scriptobject Creation and Combination
    #
    # This example demonstrates the creation and combination of `scriptobject` instances from both
    # static forcefield classes and dynamic forcefield instances (via `dforcefield`).
    #
    # Key Points:
    # ------------
    # 1. **Static and Dynamic Forcefields**:
    #    - Scriptobjects can be created using static forcefields (e.g., `rigidwall`, `solidfood`, etc.)
    #      or dynamic forcefields generated from a `dforcefield` instance (e.g., `waterFF`).
    #    - Dynamic forcefields can either be passed directly to the `pizza.script.scriptobject()`
    #      constructor or instantiated through the `scriptobject` method of any `pizza.dforcefield` object.
    #
    # 2. **Combining Scriptobjects**:
    #    - Scriptobjects can be combined using the `+` operator to create a collection of objects.
    #    - This collection of scriptobjects can then be scripted dynamically using the `script` property
    #      to generate their interaction definitions.
    #
    # 3. **Geometry Input**:
    #    - Geometry for the scriptobjects can be provided either via an input file (using `filename`)
    #      or dynamically using `pizza.region.region()`.
    #
    # **********************************************************************************************

    from pizza.forcefield import rigidwall, solidfood, water

    # Create a dynamic forcefield for water with a specific density (rho=900) and beadtype=1
    waterFF = dforcefield(base_class=&#34;water&#34;, rho=900, beadtype=1)

    # Define water beads using the dforcefield instance&#39;s scriptobject method
    bwater = waterFF.scriptobject(name=&#34;water&#34;, group=[&#34;A&#34;, &#34;D&#34;], filename=&#34;mygeom&#34;)

    # Alternatively, define water beads by passing the dynamic forcefield directly to scriptobject
    bwater2 = scriptobject(name=&#34;water&#34;, group=[&#34;A&#34;, &#34;D&#34;], filename=&#34;mygeom&#34;, forcefield=waterFF)

    # Define other dummy beads using static forcefields
    b1 = scriptobject(name=&#34;bead 1&#34;, group=[&#34;A&#34;, &#34;B&#34;, &#34;C&#34;], filename=&#39;myfile1&#39;, forcefield=rigidwall())
    b2 = scriptobject(name=&#34;bead 2&#34;, group=[&#34;B&#34;, &#34;C&#34;], filename=&#39;myfile1&#39;, forcefield=rigidwall())
    b3 = scriptobject(name=&#34;bead 3&#34;, group=[&#34;B&#34;, &#34;D&#34;, &#34;E&#34;], forcefield=solidfood())
    b4 = scriptobject(name=&#34;bead 4&#34;, group=&#34;D&#34;, beadtype=1, filename=&#34;myfile2&#34;, forcefield=water())

    # Combine the scriptobjects into a collection using the &#39;+&#39; operator
    collection = bwater + b1 + b2 + b3 + b4

    # Generate the script for the interactions in the collection
    collection.script

    # Similarly, using the alternate water bead definition (bwater2)
    collection2 = bwater2 + b1 + b2 + b3 + b4
    collection2.script



Created on Tue Sep 10 17:11:40 2024


Dependencies
------------
- Python 3.x
- LAMMPS
- Pizza3.pizza

Installation
------------
To use the Pizza3.pizza module, ensure that you have Python 3.x and LAMMPS installed. You can integrate the module into your project by placing the `region.py` file in your working directory or your Python path.

License
-------
This project is licensed under the terms of the GPLv3 license.

Contact
-------
For any queries or contributions, please contact the maintainer:
- Olivier Vitrac, Han Chen
- Email: olivier.vitrac@agroparistech.fr

&#34;&#34;&#34;

__project__ = &#34;Pizza3&#34;
__author__ = &#34;Olivier Vitrac, Han Chen, Joseph Fine&#34;
__copyright__ = &#34;Copyright 2024&#34;
__credits__ = [&#34;Olivier Vitrac&#34;, &#34;Han Chen&#34;, &#34;Joseph Fine&#34;]
__license__ = &#34;GPLv3&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;0.99995&#34;



# INRAE\Olivier Vitrac - rev. 2025-01-15 (community)
# contact: olivier.vitrac@agroparistech.fr, han.chen@inrae.fr

# Revision history
# 2024-09-10 release candidate
# 2024-09-12 file management and parsing
# 2024-09-14 major update fully compatible with scriptobject, script
# 2024-09-21 fully compatible with forcefields of class generic
# 2024-10-12 add |
# 2024-12-30 rename parse as generator, parsesyntax and authentificaiton (consistent with dscript)
# 2024-12-31 add base_class_name
# 2025-01-01 update the copy method to pass updated parameters
# 2025-01-15 fix error message if the base_name is not recognized


# Dependencies
import os, sys, tempfile, getpass, socket
import re, string, random
import inspect, copy
from datetime import datetime
from pizza.private.mstruct import struct
from pizza.forcefield import forcefield, parameterforcefield
from pizza.script import scriptdata, scriptobject
from pizza.generic import generic, genericdata, USERSMD

__all__ = [&#39;USERSMD&#39;, &#39;autoname&#39;, &#39;dforcefield&#39;, &#39;forcefield&#39;, &#39;generic&#39;, &#39;genericdata&#39;, &#39;parameterforcefield&#39;, &#39;remove_comments&#39;, &#39;scriptdata&#39;, &#39;scriptobject&#39;, &#39;struct&#39;]


# %% Private Functions

def autoname(numChars=8):
    &#34;&#34;&#34; generate automatically names &#34;&#34;&#34;
    return &#39;&#39;.join(random.choices(string.ascii_letters, k=numChars))  # Generates a random name of numChars letters

def remove_comments(content, split_lines=False):
    &#34;&#34;&#34;
    Removes comments from a single or multi-line string. Handles quotes and escaped characters.

    Parameters:
    -----------
    content : str
        The input string, which may contain multiple lines. Each line will be processed
        individually to remove comments, while preserving content inside quotes.
    split_lines : bool, optional (default: False)
        If True, the function will return a list of processed lines. If False, it will
        return a single string with all lines joined by newlines.

    Returns:
    --------
    str or list of str
        The processed content with comments removed. Returns a list of lines if
        `split_lines` is True, or a single string if False.
    &#34;&#34;&#34;
    def process_line(line):
        &#34;&#34;&#34;Remove comments from a single line while handling quotes and escapes.&#34;&#34;&#34;
        in_single_quote = False
        in_double_quote = False
        escaped = False
        result = []

        for i, char in enumerate(line):
            if escaped:
                result.append(char)
                escaped = False
                continue

            if char == &#39;\\&#39;:  # Handle escape character
                escaped = True
                result.append(char)
                continue

            # Toggle state for single and double quotes
            if char == &#34;&#39;&#34; and not in_double_quote:
                in_single_quote = not in_single_quote
            elif char == &#39;&#34;&#39; and not in_single_quote:
                in_double_quote = not in_double_quote

            # If we encounter a &#39;#&#39; and we&#39;re not inside quotes, it&#39;s a comment
            if char == &#39;#&#39; and not in_single_quote and not in_double_quote:
                break  # Stop processing the line when a comment is found

            result.append(char)

        return &#39;&#39;.join(result).strip()

    # Split the input content into lines
    lines = content.split(&#39;\n&#39;)

    # Process each line, skipping empty lines and those starting with #
    processed_lines = []
    for line in lines:
        stripped_line = line.strip()
        if not stripped_line or stripped_line.startswith(&#39;#&#39;):
            continue  # Skip empty lines and lines that are pure comments
        processed_line = process_line(line)
        if processed_line:  # Only add non-empty lines
            processed_lines.append(process_line(line))

    if split_lines:
        return processed_lines  # Return list of processed lines
    else:
        return &#39;\n&#39;.join(processed_lines)  # Join lines back into a single string



# %% Main class
class dforcefield:
    &#34;&#34;&#34;
    The `dforcefield` class represents a dynamic extension of a base forcefield class. It allows for dynamic inheritance,
    delegation of methods, and flexible management of forcefield-specific attributes. The class supports the customization
    and injection of forcefield parameters at runtime, making it highly versatile for scientific simulations involving
    various forcefield models like `ulsph`, `tlsph`, and others.

    Key Features:
    -------------
    - Dynamic inheritance and delegation of base class methods.
    - Merging of `name` and `description` attributes, with automatic handling of overlapping fields.
    - Detection of variables used in `pair_style`, `pair_diagcoeff`, and `pair_offdiagcoeff` outputs.
    - Automatic handling of missing variables, including implicit variable detection and assignment.
    - Supports additional modules to be dynamically loaded for forcefield definitions.
    - Management of `RULES`, `GLOBAL`, and `LOCAL` parameters, which can be updated dynamically at runtime.

    Attributes:
    -----------
    - `base_class` (forcefield): The base class for forcefield behavior, inherited from `forcefield` subclasses like `ulsph`.
    - `parameters` (parameterforcefield): Stores interaction parameters dynamically injected into the base class.
    - `beadtype` (int): The bead type identifier associated with the forcefield instance.
    - `userid` (str): A unique identifier for the forcefield instance.
    - `name` (struct or str): A human-readable name for the forcefield instance, merged with `description`.
    - `description` (struct or str): A brief description of the forcefield, merged with `name`.
    - `version` (float): Version number for the forcefield instance.
    - `RULES` (genericdata): Defines specific rules or formulae applied to forcefield calculations.
    - `GLOBAL` (genericdata): Stores global parameters that apply to the entire forcefield.
    - `LOCAL` (genericdata): Contains local parameters specific to certain forcefield interactions.
    - `USER` (scriptdata): Contains USER parameters for scriptobject
    - `base_class_name` (str): Returns the name of the base_class as a lowercase string

    Methods:
    --------
    ### High-Level Methods:
    These methods are primarily used for interacting with the `dforcefield` instance:

    - **`__init__`**: Initializes the dynamic forcefield with base class, parameters, and custom attributes.
    - **`pair_style`**: Delegates the pair style computation to the `base_class`.
    - **`pair_diagcoeff`**: Delegates diagonal pair coefficient computation to the `base_class`.
    - **`pair_offdiagcoeff`**: Delegates off-diagonal pair coefficient computation to the `base_class`.
    - **`generator`**: Generates the forcefield definition as a formatted string without traceability features.
    - **`save`**: Saves the forcefield instance to a file, with headers, attributes, and parameters.
    - **`load`**: Loads a `dforcefield` instance from a file and validates its format.
    - **`parsesyntax`**: Parses content of a forcefield file to create a new `dforcefield` instance.
    - **`copy`**: Creates a copy of the current instance, optionally overriding core attributes.
    - **`compare`**: Compares the current instance with another `dforcefield` instance, showing differences.
    - **`missingVariables`**: Lists undefined variables in `parameters`.
    - **`detectVariables`**: Detects variables in the `pair_style`, `pair_diagcoeff`, and `pair_offdiagcoeff` outputs.
    - **`to_dict`**: Serializes the forcefield instance into a dictionary.
    - **`from_dict`**: Creates a `dforcefield` instance from a dictionary of attributes.
    - **`reset`**: Resets the forcefield instance to its initial state.
    - **`validate`**: Validates the forcefield instance to ensure all required attributes are set.
    - **`base_repr`**: Returns the representation of the `base_class`.
    - **`script`**: Returns the raw outputs of pair methods as a script.
    - **`scriptobject`**: Method to return a `scriptobject` based on the current `dforcefield` instance.

    ### Low-Level Methods:
    These methods handle internal logic and lower-level operations:

    - **`_inject_attributes`**: Injects the dynamic attributes into the `base_class`.
    - **`__getattr__`**: Dynamically accesses attributes in `name`, `description`, `parameters`, or `base_class`.
    - **`__setattr__`**: Manages setting core and dynamic attributes.
    - **`_load_base_class`**: Dynamically loads the base class from a string name.
    - **`list_forcefield_subclasses`**: Lists all subclasses of `forcefield` including those from additional modules.
    - **`extract_default_parameters`**: Extracts default parameters from the base class or its ancestors.
    - **`dispmax`**: Truncates the display of long content for concise output.
    - **`__hasattr__`**: Checks if an attribute exists in the instance, parameters, or base class.
    - **`__contains__`**: Checks if an attribute exists in the instance or `parameters`.
    - **`__len__`**: Returns the number of parameters in the forcefield.
    - **`__iter__`**: Iterates over all keys, including those in `name`, `description`, `parameters`, and scalar attributes.
    - **`keys`**: Returns the keys from the merged `name`, `description`, and `parameters`.
    - **`values`**: Returns the values from the merged `name`, `description`, and `parameters`.
    - **`items`**: Returns an iterator of key-value pairs from `name`, `description`, and `parameters`.
    - **`merged_name_description`**: Merges `name` and `description` fields into a struct.
    - **`_get_available_forcefields`**: Retrieves a list of available forcefield subclasses.
    - **`__repr__`**: Custom representation of the `dforcefield` instance.
    - **`__str__`**: Returns a string representation of the `dforcefield` instance.
    - **`_convert_value`**: Converts a string value to the appropriate Python type.
    - **`_parse_global_params`**: Parses global parameters from the content between `{}`.
    - **`_parse_struct_block`**: Parses key-value pairs from `description` or `name` blocks.
    - **`__copy__`**: Creates a shallow copy of the `dforcefield` instance, copying only the attributes at the top level without duplicating nested objects.
    - **`__deepcopy__`**: Creates a deep copy of the `dforcefield` instance, fully duplicating all attributes, including nested objects, while leaving class references intact.
    - **`get_global`**: Returns the `GLOBAL` parameters.
    - **`get_local`**: Returns the `LOCAL` parameters.
    - **`get_rules`**: Returns the `RULES` parameters.
    - **`set_global`**: Updates the `GLOBAL` parameters and recalculates the combined parameters.
    - **`set_local`**: Updates the `LOCAL` parameters and recalculates the combined parameters.
    - **`set_rules`**: Updates the `RULES` parameters and recalculates the combined parameters.
    - **`combine_parameters`**: Combines `GLOBAL`, `LOCAL`, and `RULES` into the current parameter configuration.
    - **`update_parameters`**: Updates `self.parameters` after changes to `GLOBAL`, `LOCAL`, or `RULES`.

    Example Usage:
    --------------
        &gt;&gt;&gt; dynamic_ff = dforcefield(ulsph, beadtype=1, userid=&#34;dynamic_water&#34;, USER=parameterforcefield(rho=1000))
        &gt;&gt;&gt; dynamic_ff.pair_style()  # Uses attributes from the dforcefield instance
        lj/cut
        &gt;&gt;&gt; dynamic_ff.compare(another_ff_instance, printflag=True)
    &#34;&#34;&#34;


    # Display
    _maxdisplay = 40
    # Class attribute for the six specific attributes + 3 generic attributes + USER set by scriptobject
    _dforcefield_specific_attributes = {&#39;name&#39;, &#39;description&#39;, &#39;beadtype&#39;, &#39;userid&#39;, &#39;version&#39;, &#39;parameters&#39;,&#39;RULES&#39;,&#39;GLOBAL&#39;,&#39;LOCAL&#39;,&#39;USER&#39;}
    # Class attribute: construction flag is True by default for all instances
    _in_construction = True
    RULES = parameterforcefield()  # Default empty RULES at the class level

    def __init__(self, base_class=None, beadtype=1, userid=None, USER=parameterforcefield(),
                 name=None, description=None, version=0.1, additional_modules=None,
                 printflag=False, verbose=False,
                 GLOBAL=None, LOCAL=None, RULES=None, **kwargs):
        &#34;&#34;&#34;
        Initialize a dynamic forcefield with default or custom values.

        Args:
            base_class (str or class): The base class to use (e.g., &#39;ulsph&#39;, tlsph, etc.) or the actual class.
            beadtype (int): The bead type identifier. Default is 1.
            userid (str): User ID for the material. Default is None.
            name (str): Human-readable name for the forcefield. Default is None.
            description (str): Description of the forcefield. Default is None.
            version (float): Version number for the forcefield. Default is 0.1.
            USER (parameterforcefield): Custom parameters to override defaults.
            additional_modules (module or list of modules): Additional modules to search for forcefields.
            GLOBAL (parameterforcefield): Global parameters to be used. Default is None.
            LOCAL (parameterforcefield): Local parameters to be used. Default is None.
            kwargs: Additional parameters passed to the base class.
        &#34;&#34;&#34;

        # Initialize GLOBAL and LOCAL containers
        self.GLOBAL = GLOBAL if GLOBAL else genericdata()
        self.LOCAL = LOCAL if LOCAL else genericdata()
        if RULES is None:
            self.RULES = genericdata()  # Initialize RULES, to be populated later if applicable
        else:
            self.RULES = RULES # side effect are expected if the user supply non compatible data (2025-01-02)

        # Initialize USER containter (which is used by scriptobject)
        self.USER = scriptdata()

        #â€¢ Initialize print/verbose behavior
        self.printflag = printflag
        self.verbose = verbose

        # Step 1a: Handle base_class, either a string or a class reference
        print(f&#34;\nInitializing dforcefield with base_class: {base_class}&#34;)

        # Handle base_class loading (using additional_modules if needed)
        if isinstance(base_class, str):
            # Get available forcefields and short names mapping
            available_forcefields, short_name_mapping = self.list_forcefield_subclasses(
                printflag=False,
                additional_modules=additional_modules
            )
            # Check if the provided base_class name matches either the full or short name
            if base_class not in available_forcefields and base_class not in short_name_mapping:
                available_classes = &#34;, &#34;.join(short_name_mapping.keys())
                raise ValueError(
                    f&#34;Invalid base_class: &#39;{base_class}&#39;. Must be one of the available forcefields: {available_classes}&#34;
            )
            # Use the full name from the short name if necessary
            # if base_class in short_name_mapping:
            #     base_class = short_name_mapping[base_class]

            # Load the base class or method
            base_class = dforcefield._load_base_class(base_class, additional_modules=additional_modules)

        # Ensure the base_class is valid
        if not (inspect.isclass(base_class) and issubclass(base_class, forcefield)) and not (
            callable(base_class) and hasattr(base_class, &#39;__qualname__&#39;) and
            base_class.__qualname__.split(&#39;.&#39;)[0] in {cls.__name__ for cls in generic.__subclasses__()}
        ):
            raise ValueError(
                f&#34;Invalid base_class: {base_class}. It must be a valid subclass of &#39;forcefield&#39; or a callable forcefield method &#34;
                f&#34;from a &#39;generic&#39; subclass.&#34;
        )

        # Step 1b: Initialize the base_class
        # If base_class is callable (like a method), call it to get an instance; otherwise, instantiate directly
        if callable(base_class):
            # Check if the base_class is a method of a generic subclass
            qualname = base_class.__qualname__.split(&#39;.&#39;)
            parent_class_name = qualname[0] if len(qualname) &gt; 1 else None
            parent_class = next((cls for cls in generic.__subclasses__() if cls.__name__ == parent_class_name), None)

            if parent_class:
                # Instantiate the parent class and call the method on it
                parent_instance = parent_class()  # Create an instance of the parent class (e.g., USERSMD)
                self.base_class = base_class(parent_instance)  # Call the method with the instance context
            else:
                # Call the method directly if no parent class context is needed
                self.base_class = base_class()
        else:
            self.base_class = base_class()  # Instantiate the class if it&#39;s not a method

        # Ensure the base_class is valid and handle classes and methods separately
        if inspect.isclass(base_class):
            # Step 2a: Extract default parameters from the base class
            extracted_info = self.extract_default_parameters(base_class, displayflag=True)
        elif callable(base_class) and hasattr(base_class, &#39;__qualname__&#39;):
            # If base_class is a method, extract the parent class name
            parent_class_name = base_class.__qualname__.split(&#39;.&#39;)[0]
            parent_class = next(
                (cls for cls in generic.__subclasses__() if cls.__name__ == parent_class_name), None
            )
            if parent_class is None:
                raise ValueError(f&#34;Unable to find parent class &#39;{parent_class_name}&#39; for method &#39;{base_class.__name__}&#39;.&#34;)

            # Step 2b: Extract default parameters from the method within its parent class
            extracted_info = self.extract_default_parameters(parent_class, method_name=base_class.__name__, displayflag=True)
        else:
            raise ValueError(
                f&#34;Invalid base_class: {base_class}. It must be a valid subclass of &#39;forcefield&#39; or a callable forcefield method.&#34;
            )

        # Populate RULES, GLOBAL, and LOCAL if extracted
        self.RULES = extracted_info.get(&#34;RULES&#34;, genericdata())
        self.GLOBAL = extracted_info.get(&#34;GLOBAL&#34;, genericdata()) + self.GLOBAL
        self.LOCAL = extracted_info.get(&#34;LOCAL&#34;, genericdata()) + self.LOCAL

        # Step 3: Initialize the base_class
        #self.base_class = base_class()  # Instantiate the base_class if it&#39;s callable

        # Step 4: Initialize name and description
        default_name = self.base_class.name  # Access base_class.name after ensuring it&#39;s properly set

        # Handling &#39;name&#39;
        if name:
            if isinstance(name, str):
                name = default_name + struct(material=name)
            elif isinstance(name, struct):
                name = default_name + name
            else:
                raise TypeError(f&#34;name must be of type str or struct, not {type(name)}&#34;)
        else:
            name = default_name + struct(material=self.__class__.__name__.lower())

        self.name = name

        # Handling &#39;description&#39;
        default_description = self.base_class.description
        if description:
            if isinstance(description, str):
                description = default_description + struct(material=description)
            elif isinstance(description, struct):
                description = default_description + description
            else:
                raise TypeError(f&#34;description must be of type parameterforcefield, not {type(description)}&#34;)
        else:
            description = default_description + struct(material=f&#34;{self.__class__.__name__.lower()} beads - SPH-like&#34;)

        self.description = description

        # Step 5: Other properties and parameters
        self.userid = userid if userid else self.__class__.__name__.lower()
        self.version = version
        self.beadtype = beadtype

        # Ensure USER is of the correct type
        if not isinstance(USER, parameterforcefield):
            raise TypeError(f&#34;USER must be of type parameterforcefield, not {type(USER)}&#34;)

        # Merge USER and kwargs into parameters
        # If no default parameters, proceed with user parameters
        if extracted_info[&#34;parameters&#34;] is None:
            self.parameters = self.GLOBAL + self.LOCAL + self.RULES + USER + parameterforcefield(**kwargs)
        else:
            self.parameters = extracted_info[&#34;parameters&#34;] + self.GLOBAL + self.LOCAL + self.RULES + USER + parameterforcefield(**kwargs)
        # After merging parameters, ensure USER is not part of it
        # if &#39;USER&#39; in self.parameters:
        #     del self.parameters[&#39;USER&#39;]

        # End of construction
        self._in_construction = False

        # Inject dforcefield attributes into the base class
        self._inject_attributes()


    # New methods to access GLOBAL, LOCAL, and RULES

    def get_global(self):
        &#34;&#34;&#34;Return the GLOBAL parameters for this dforcefield instance.&#34;&#34;&#34;
        return self.GLOBAL

    def get_local(self):
        &#34;&#34;&#34;Return the LOCAL parameters for this dforcefield instance.&#34;&#34;&#34;
        return self.LOCAL

    def get_rules(self):
        &#34;&#34;&#34;Return the RULES parameters for this dforcefield instance.&#34;&#34;&#34;
        return self.RULES

    # Method to combine GLOBAL, LOCAL, and RULES
    def combine_parameters(self):
        &#34;&#34;&#34;
        Combine GLOBAL, LOCAL, and RULES to get the current parameter configuration.
        &#34;&#34;&#34;
        return self.GLOBAL + self.LOCAL + self.RULES


    def update_parameters(self):
        &#34;&#34;&#34;
        Update self.parameters by combining GLOBAL, LOCAL, RULES, and USER parameters.
        &#34;&#34;&#34;
        self.parameters = self.parameters + self.combine_parameters()
        self._inject_attributes()


    def set_local(self, new_local=None, **kwargs):
        &#34;&#34;&#34;
        Update the LOCAL parameters and adjust the combined parameters accordingly.

        Args:
        -----
        new_local : parameterforcefield, optional
            The new LOCAL parameters to set. If None, only the parameters in kwargs are modified.
        kwargs : dict, optional
            Keyword arguments representing individual parameters to add or modify in LOCAL.
        &#34;&#34;&#34;
        if new_local is not None and not isinstance(new_local, parameterforcefield):
            raise TypeError(f&#34;LOCAL must be of type parameterforcefield, not {type(new_local)}.&#34;)

        # Combine current LOCAL, new_local, and additional parameters in kwargs
        self.LOCAL = (self.LOCAL + (new_local or genericdata()) + genericdata(**kwargs))
        self.update_parameters()

    def set_global(self, new_global=None, **kwargs):
        &#34;&#34;&#34;
        Update the GLOBAL parameters and adjust the combined parameters accordingly.

        Args:
        -----
        new_global : parameterforcefield, optional
            The new GLOBAL parameters to set. If None, only the parameters in kwargs are modified.
        kwargs : dict, optional
            Keyword arguments representing individual parameters to add or modify in GLOBAL.
        &#34;&#34;&#34;
        if new_global is not None and not isinstance(new_global, parameterforcefield):
            raise TypeError(f&#34;GLOBAL must be of type parameterforcefield, not {type(new_global)}.&#34;)

        # Combine current GLOBAL, new_global, and additional parameters in kwargs
        self.GLOBAL = (self.GLOBAL + (new_global or genericdata()) + genericdata(**kwargs))
        self.update_parameters()

    def set_rules(self, new_rules=None, **kwargs):
        &#34;&#34;&#34;
        Update the RULES parameters and adjust the combined parameters accordingly.

        Args:
        -----
        new_rules : parameterforcefield, optional
            The new RULES parameters to set. If None, only the parameters in kwargs are modified.
        kwargs : dict, optional
            Keyword arguments representing individual parameters to add or modify in RULES.
        &#34;&#34;&#34;
        if new_rules is not None and not isinstance(new_rules, parameterforcefield):
            raise TypeError(f&#34;RULES must be of type parameterforcefield, not {type(new_rules)}.&#34;)

        # Combine current RULES, new_rules, and additional parameters in kwargs
        self.RULES = (self.RULES + (new_rules or genericdata()) + genericdata(**kwargs))
        self.update_parameters()


    @classmethod
    def _load_base_class(cls, base_class_name, additional_modules=None):
        &#34;&#34;&#34;
        Dynamically load the base class by its string name from the available forcefield subclasses
        or additional modules.

        Args:
            base_class_name (str): The name of the forcefield class or method to load.
            additional_modules (list): Optional list of additional modules to search for the base class.

        Returns:
            class or function: The base class or function if found.
        &#34;&#34;&#34;
        # Retrieve subclass information and short name mappings
        subclasses_info, short_name_mapping = cls.list_forcefield_subclasses(
            printflag=False, additional_modules=additional_modules
            )
        print(f&#34;Trying to load base_class: {base_class_name}&#34;)

        # Directly look for the exact name in the subclasses_info
        if base_class_name in subclasses_info:
            info = subclasses_info[base_class_name]
            if not info[&#39;loaded&#39;]:
                module_name = info[&#39;module&#39;]
                try:
                    print(f&#34;Attempting to import module &#39;{module_name}&#39; and load &#39;{base_class_name}&#39;&#34;)
                    module = __import__(module_name, fromlist=[base_class_name])
                    target = getattr(module, base_class_name)

                    # Check if the target is a class or method
                    if inspect.isclass(target) and issubclass(target, forcefield):
                        return target
                    elif inspect.isfunction(target):
                        return target
                    else:
                        raise ValueError(f&#34;Loaded target &#39;{base_class_name}&#39; is not a suitable forcefield class or method.&#34;)
                except (ImportError, AttributeError) as e:
                    available_classes = cls._get_available_forcefields()
                    raise ImportError(f&#34;Failed to load the target &#39;{base_class_name}&#39; from module &#39;{module_name}&#39;. &#34;
                                      f&#34;Available forcefields: {available_classes}&#34;) from e

            # If already loaded, return the class directly
            return sys.modules[info[&#39;module&#39;]].__dict__.get(base_class_name)

        # If not found directly, check for nested methods within classes
        for key, info in subclasses_info.items():
            # Check if base_class_name is a method of a class
            if &#39;.&#39; in key and key.split(&#39;.&#39;)[-1] == base_class_name:
                parent_class_name = key.split(&#39;.&#39;)[0]
                if parent_class_name in subclasses_info:
                    # Load the parent class if it hasn&#39;t been loaded yet
                    parent_class_info = subclasses_info[parent_class_name]
                    if not parent_class_info[&#39;loaded&#39;]:
                        parent_class = cls._load_base_class(parent_class_name, additional_modules=additional_modules)
                    else:
                        # Directly access the parent class from the loaded module
                        module = sys.modules[parent_class_info[&#39;module&#39;]]
                        parent_class = getattr(module, parent_class_name)

                    # Get the method from the loaded parent class
                    method = getattr(parent_class, base_class_name, None)
                    if method and callable(method):
                        return method
                    else:
                        raise ValueError(f&#34;Method &#39;{base_class_name}&#39; was not found in the parent class &#39;{parent_class_name}&#39; or is not callable.&#34;)

        # If the target is a direct class but not a method or nested class, throw an appropriate error
        raise ValueError(f&#34;Target &#39;{base_class_name}&#39; is not a recognized class or method. &#34;
                         f&#34;Available entries: {cls._get_available_forcefields()}&#34;)


    @classmethod
    def _get_available_forcefields(cls):
        &#34;&#34;&#34;
        Retrieve the list of available forcefield subclasses.

        Returns:
            list: A list of available forcefield subclass names.
        &#34;&#34;&#34;
        subclasses_info = cls.list_forcefield_subclasses(printflag=False)
        return list(subclasses_info.keys())


    @classmethod
    def extract_default_parameters(cls, base_class, method_name=None, displayflag=True):
        &#34;&#34;&#34;
        Extract default parameters from the base class or its method by instantiating the class.

        If the base class is derived from `generic`, this function will also extract RULES, LOCAL,
        and GLOBAL attributes if they are defined once the instance is created.

        Parameters:
        -----------
        base_class : class
            The base class from which to extract default parameterforcefield values or a method.
        method_name : str, optional
            The name of the method to call on the instance, if applicable (e.g., `newtonianfluid`).
        displayflag : bool, optional (default=True)
            If True, prints a message when no default parameters are found.

        Returns:
        --------
        dict
            A dictionary containing the default parameters extracted from the base class or method.
            Also includes RULES, LOCAL, and GLOBAL if applicable.
        &#34;&#34;&#34;
        extracted_info = {
            &#34;parameters&#34;: parameterforcefield(),
            &#34;RULES&#34;: genericdata(),
            &#34;GLOBAL&#34;: genericdata(),
            &#34;LOCAL&#34;: genericdata()
        }

        try:
            # Create an instance of the base class
            instance = base_class()

            # Extract parameters if the instance has them
            if hasattr(instance, &#39;parameters&#39;) and isinstance(instance.parameters, parameterforcefield):
                extracted_info[&#34;parameters&#34;] = instance.parameters

            # Extract RULES, GLOBAL, and LOCAL if they exist
            for attr in [&#34;RULES&#34;, &#34;GLOBAL&#34;, &#34;LOCAL&#34;]:
                if hasattr(instance, attr) and isinstance(getattr(instance, attr), parameterforcefield):
                    extracted_info[attr] = getattr(instance, attr)

            # If a method is specified, call it to get additional parameters
            if method_name and hasattr(instance, method_name):
                method = getattr(instance, method_name)
                if callable(method):
                    try:
                        result = method()  # Call the method (ensure it returns the desired forcefield object)
                        if hasattr(result, &#39;parameters&#39;) and isinstance(result.parameters, parameterforcefield):
                            extracted_info[&#34;parameters&#34;] = result.parameters
                    except Exception as e:
                        if displayflag:
                            print(f&#34;Error calling method {method_name} on {base_class.__name__}: {str(e)}&#34;)

        except TypeError as e:
            if displayflag:
                print(f&#34;Could not instantiate {base_class.__name__}: {str(e)}&#34;)

        # If no parameters found or cannot instantiate the class, return None
        if displayflag and not extracted_info[&#34;parameters&#34;]:
            print(f&#34;No default parameters found in {base_class.__name__} or its ancestors.&#34;)

        return extracted_info


    def _inject_attributes(self):
        &#34;&#34;&#34;Inject dforcefield attributes into the base class, bypassing __setattr__.&#34;&#34;&#34;
        if not self._in_construction:  # Prevent injection during construction
            # Check if base_class is a class (not a method)
            if inspect.isclass(self.base_class):
                self.base_class.__dict__.update({
                    &#39;name&#39;: self.name,
                    &#39;description&#39;: self.description,
                    &#39;beadtype&#39;: self.beadtype,
                    &#39;userid&#39;: self.userid,
                    &#39;version&#39;: self.version,
                    &#39;parameters&#39;: self.parameters
                })
            else:
                # For methods, set attributes on the instance itself, as methods can&#39;t have attributes directly
                # Methods are often accessed from an instance, so we update the instance&#39;s attributes instead
                self.base_class.name = self.name
                self.base_class.description = self.description
                self.base_class.beadtype = self.beadtype
                self.base_class.userid = self.userid
                self.base_class.version = self.version
                self.base_class.parameters = self.parameters


    def __getattr__(self, attr):
        &#34;&#34;&#34;
        Shorthand for accessing parameters, base class attributes, or attributes in &#39;name&#39; and &#39;description&#39;.
        If an attribute exists in both &#39;name&#39; and &#39;description&#39;, their contents are combined with a newline.
        &#34;&#34;&#34;
        # Check if the attribute exists in the instance&#39;s __dict__
        if attr in self.__dict__:
            return self.__dict__[attr]
        # Check if the attribute exists in &#39;name&#39; and &#39;description&#39;
        name_attr = getattr(self.name, attr, None) if isinstance(self.name, struct) else None
        description_attr = getattr(self.description, attr, None) if isinstance(self.description, struct) else None
        # If the attribute exists in both &#39;name&#39; and &#39;description&#39;, combine them with a newline
        if name_attr and description_attr:
            return [name_attr, description_attr]
        # If the attribute exists in &#39;name&#39; only
        if name_attr:
            return name_attr
        # If the attribute exists in &#39;description&#39; only
        if description_attr:
            return description_attr
        # Check if the attribute exists in &#39;parameters&#39;
        if hasattr(self.parameters, attr):
            return getattr(self.parameters, attr)
        # Check if the attribute exists in the &#39;base_class&#39;
        if hasattr(self.base_class, attr):
            return getattr(self.base_class, attr)
        # Raise an AttributeError if the attribute is not found
        raise AttributeError(f&#34;&#39;{self.__class__.__name__}&#39; object has no attribute &#39;{attr}&#39;&#34;)



    def __setattr__(self, attr, value):
        &#34;&#34;&#34;
        Shorthand for setting attributes. Attributes specific to dforcefield are handled separately.
        New attributes are added to parameters if they are not part of the dforcefield-specific attributes.
        &#34;&#34;&#34;
        # Handle internal attributes like _in_construction directly in the instance
        # and Check if the attribute is part of the dforcefield-specific attributes
        if hasattr(self.__class__, attr) or attr in self._dforcefield_specific_attributes:
            if attr==&#34;parameters&#34;:
                if not isinstance(value,parameterforcefield):
                    raise TypeError(&#34;parameters must be of type parameterforcefield, not of type {}&#34;.format(type(value)))
                self.__dict__[attr] = self.detectVariables() + value # check that all variables are defined
            else:
                self.__dict__[attr] = value
            if not self._in_construction and attr in self._dforcefield_specific_attributes:
                self._inject_attributes()
        # Handle dynamic setting of attributes in parameters
        elif &#39;parameters&#39; in self.__dict__:
            # Update parameters (existing or new attributes)
            setattr(self.parameters, attr, value)

            # Ensure injection occurs when parameters is updated
            if not self._in_construction:
                self._inject_attributes()
        else:
            # Fallback to default behavior if the attribute isn&#39;t part of parameters or specific attributes
            super().__setattr__(attr, value)


    def __hasattr__(self, attr):
        &#34;&#34;&#34;Check if an attribute exists in the dforcefield instance, class, parameters, or the base class.&#34;&#34;&#34;
        # Check for instance attribute
        if attr in self.__dict__:
            return True
        # Check for class attribute
        if hasattr(self.__class__, attr):
            return True
        # Check for parameters
        if attr in self.parameters.keys():
            return True
        # Check for attribute in base class
        if hasattr(self.base_class, attr):
            return True
        return False


    def __contains__(self, item):
        &#34;&#34;&#34;Check if an attribute exists in the dforcefield instance or its parameters.&#34;&#34;&#34;
        return item in self.keys()


    def __len__(self):
        &#34;&#34;&#34;
        Return the number of parameters in the forcefield.
        This will use the len method of parameters.
        &#34;&#34;&#34;
        return len(self.keys())


    @property
    def merged_name_description(self):
        &#34;&#34;&#34;
        Return a struct containing the merged content of &#39;name&#39; and &#39;description&#39;.
        If an attribute exists in both, their values are combined into a list.
        &#34;&#34;&#34;
        merged_data = {}

        # Add attributes from &#39;name&#39; if it&#39;s a struct
        if isinstance(self.name, struct):
            merged_data.update(self.name.__dict__)

        # Add/merge attributes from &#39;description&#39; if it&#39;s a struct
        if isinstance(self.description, struct):
            for key, value in self.description.__dict__.items():
                if key in merged_data:
                    # Combine the values into a list if the key already exists
                    existing_value = merged_data[key]
                    if not isinstance(existing_value, list):
                        existing_value = [existing_value]  # Convert to list if not already a list
                    merged_data[key] = existing_value + [value]  # Add the new value to the list
                else:
                    merged_data[key] = value

        # Return the merged struct
        return struct(**merged_data)



    def keys(self):
        &#34;&#34;&#34;
        Return the keys of the merged struct, parameters, and scalar attributes.
        &#34;&#34;&#34;
        keys_set = set(self.merged_name_description.__dict__.keys())
        keys_set.update(self.parameters.keys())
        keys_set.update([&#39;version&#39;, &#39;userid&#39;, &#39;beadtype&#39;])
        return list(keys_set)

    def values(self):
        &#34;&#34;&#34;
        Return the values of the merged struct, parameters, and scalar attributes.
        &#34;&#34;&#34;
        values_list = list(self.merged_name_description.__dict__.values())
        values_list.extend(self.parameters.values())
        values_list.extend([self.version, self.userid, self.beadtype])
        return values_list

    def items(self):
        &#34;&#34;&#34;
        Return an iterator over (key, value) pairs from the merged struct, parameters, and scalar attributes.
        &#34;&#34;&#34;
        # Yield items from merged struct
        for item in self.merged_name_description.__dict__.items():
            yield item

        # Yield items from parameters
        for item in self.parameters.items():
            yield item

        # Yield scalar attribute items
        yield (&#39;version&#39;, self.version)
        yield (&#39;userid&#39;, self.userid)
        yield (&#39;beadtype&#39;, self.beadtype)

    def __iter__(self):
        &#34;&#34;&#34;
        Iterate over all keys, including those in the merged struct, parameters, and scalar attributes.
        &#34;&#34;&#34;
        for key in self.merged_name_description.__dict__:
            yield key
        for key in self.parameters:
            yield key
        yield &#39;version&#39;
        yield &#39;userid&#39;
        yield &#39;beadtype&#39;


    def __repr__(self):
        &#34;&#34;&#34;
        Custom __repr__ method that provides a detailed representation of the dforcefield instance,
        excluding attributes that start with an underscore (_).
        &#34;&#34;&#34;
        base_class_name = self.base_class.__class__.__name__ if self.base_class else &#34;None&#34;
        sep = &#34;  &#34; + &#34;-&#34; * 20 + &#34;:&#34; + &#34;-&#34; * 30

        # Start building the representation string
        repr_str = f&#39;forcefield &#34;{self.userid}&#34; derived from &#34;{base_class_name}&#34;\n\n&#39;

        # [BEADTYPE] Section
        repr_str += f&#34;{sep}[ BEADTYPE ]\n&#34;
        repr_str += f&#34;  {&#39;beadtype&#39;:&lt;20}: {self.beadtype}\n\n&#34;

        # [FF CLASS (read only)] Section
        repr_str += f&#34;{sep}[ FF CLASS (read only) ]\n&#34;
        # Iterate over attributes in merged_name_description, exclude those starting with &#39;_&#39;
        for key, value in self.merged_name_description.items():
            if key.startswith(&#39;_&#39;):
                continue  # Skip private attributes

            # Handle list values (multiple entries for the same key)
            if isinstance(value, list):
                for idx, val in enumerate(value):
                    value_lines = self.dispmax(val).splitlines()
                    if idx == 0:
                        repr_str += f&#34;  {key:&lt;20}: {value_lines[0]}\n&#34;
                    else:
                        repr_str += f&#34;  {&#39;&#39;:&lt;20}  {value_lines[0]}\n&#34;
                    for line in value_lines[1:]:
                        repr_str += f&#34;  {&#39;&#39;:&lt;20}  {line}\n&#34;
            else:
                value_lines = self.dispmax(value).splitlines()
                repr_str += f&#34;  {key:&lt;20}: {value_lines[0]}\n&#34;
                for line in value_lines[1:]:
                    repr_str += f&#34;  {&#39;&#39;:&lt;20}  {line}\n&#34;

        repr_str += &#34;\n&#34;

        # [PARAMS] Section
        repr_str += f&#34;{sep}[ PARAMS ]\n&#34;
        missing = 0

        for key, value in self.parameters.items():
            # Skip private parameters
            if key.startswith(&#39;_&#39;):
                continue

            repr_str += f&#34;  {key:&lt;20}: {value}\n&#34;

            # If the value is an expression, evaluate and display the result
            if isinstance(value, str) and &#34;${&#34; in value and &#34;}&#34; in value:
                try:
                    # Replace placeholders with actual parameter values
                    expr = value
                    for param_key, param_val in self.parameters.items():
                        expr = expr.replace(f&#34;${{{param_key}}}&#34;, str(param_val))
                    # Evaluate the expression safely
                    evaluated = eval(expr, {&#34;__builtins__&#34;: {}}, {})
                    repr_str += f&#34;                        = {evaluated}\n&#34;
                except Exception:
                    # If evaluation fails, skip displaying the result
                    pass

        # Count missing definitions (assuming missing parameters are marked somehow)
        # For demonstration, we&#39;ll assume &#39;missing&#39; is already correctly set
        total_definitions = len(self.parameters)
        repr_str += f&#34;\n{sep} &gt;&gt; {total_definitions} definitions ({missing} missing)\n&#34;
        print(repr_str)
        return self.__str__()


    def base_repr(self):
        &#34;&#34;&#34;Returns the representation of the base_class.&#34;&#34;&#34;
        self.base_class.__repr__()
        return self.base_class.__str__()

    @property
    def script(self):
        &#34;&#34;&#34;
        Return the raw content of the pair_* outputs combined into a single script-like format.

        Returns:
        --------
        str
            The raw outputs from pair_style, pair_diagcoeff, and pair_offdiagcoeff concatenated into a script.
        &#34;&#34;&#34;
        # Get the raw outputs from the pair_* methods
        pair_style_output = self.pair_style(printflag=False, raw=True)
        pair_diagcoeff_output = self.pair_diagcoeff(printflag=False, raw=True)
        pair_offdiagcoeff_output = self.pair_offdiagcoeff(printflag=False, raw=True)

        # Combine the outputs into a script-like format
        script_content = &#34;\n&#34;.join([
            &#34;# Script output from dforcefield:&#34;,
            &#34;# Pair style:&#34;,
            pair_style_output,
            &#34;\n# Diagonal coefficients:&#34;,
            pair_diagcoeff_output,
            &#34;\n# Off-diagonal coefficients:&#34;,
            pair_offdiagcoeff_output
        ])

        return script_content

    def __str__(self):
        base_class_name = self.base_class.__class__.__name__ if self.base_class else &#34;None&#34;
        return f&#34;&lt;dforcefield instance with base class: {base_class_name}, userid: {self.userid}, beadtype: {self.beadtype}&gt;&#34;

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def show(self):
        &#34;&#34;&#34;Show the corresponding base_class forcefield definition &#34;&#34;&#34;
        self.base_class.__repr__()
        return self.base_class.__str__()

    def pair_style(self, printflag=None, verbose=None, raw=False):
        &#34;&#34;&#34;Delegate pair_style to the base class, ensuring it uses the correct attributes.&#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        self._inject_attributes()
        return self.base_class.pair_style(printflag=printflag, verbose=verbose, raw=raw,USER=None, beadtype=self.beadtype, userid=self.userid)


    def pair_diagcoeff(self, printflag=None, verbose=None, i=None, raw=False):
        &#34;&#34;&#34;Delegate pair_diagcoeff to the base class, ensuring it uses the correct attributes.&#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        self._inject_attributes()
        return self.base_class.pair_diagcoeff(printflag=printflag, verbose=verbose, i=i, raw=raw, USER=None, beadtype=self.beadtype, userid=self.userid)


    def pair_offdiagcoeff(self, o=None, printflag=None, verbose=None, i=None, raw=False,oname=None):
        &#34;&#34;&#34;Delegate pair_offdiagcoeff to the base class, ensuring it uses the correct attributes.&#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        self._inject_attributes()
        return self.base_class.pair_offdiagcoeff(o=o, printflag=printflag, verbose=verbose, i=i, raw=raw, USER=None, beadtype=self.beadtype, userid=self.userid,oname=oname)


    def __add__(self, other):
        &#34;&#34;&#34;Concatenate dforcefield attributes, i

        ncluding RULES, GLOBAL, and LOCAL, if different, else keep the version of self.&#34;&#34;&#34;
        if not isinstance(other, dforcefield):
            raise TypeError(f&#34;Cannot concatenate {type(other)} with dforcefield.&#34;)

        if self.base_class != other.base_class:
            raise ValueError(f&#34;Cannot concatenate dforcefield instances with different base classes ({self.base_class} != {other.base_class}).&#34;)

        # Concatenate name, description, beadtype, userid, and parameters if different, else keep self&#39;s version
        new_name = self.name if self.name == other.name else f&#34;{self.name}_{other.name}&#34;
        new_description = self.description if self.description == other.description else f&#34;{self.description} + {other.description}&#34;
        new_beadtype = self.beadtype if self.beadtype == other.beadtype else f&#34;{self.beadtype}, {other.beadtype}&#34;
        new_parameters = self.parameters + other.parameters  # Assuming parameters supports &#39;+&#39;
        new_userid = self.userid if self.userid == other.userid else f&#34;{self.userid}_{other.userid}&#34;

        # Concatenate RULES, GLOBAL, and LOCAL, preserving their combined nature
        new_rules = self.RULES + other.RULES
        new_global = self.GLOBAL + other.GLOBAL
        new_local = self.LOCAL + other.LOCAL

        # Keep the version from self
        new_version = self.version

        # Return a new dforcefield instance with concatenated attributes
        return dforcefield(
            base_class=self.base_class,
            beadtype=new_beadtype,
            userid=new_userid,
            name=new_name,
            description=new_description,
            version=new_version,
            USER=new_parameters,
            RULES=new_rules,
            GLOBAL=new_global,
            LOCAL=new_local
        )


    def __or__(self, other):
        &#34;&#34;&#34; Overload | pipe operator in dscript &#34;&#34;&#34;
        # Convert the dscript instance into a pipescript
        leftarg = self.pscript()
        # Simply use the existing pipe operator for pipescript
        return leftarg | other


    def copy(self, beadtype=None, userid=None, name=None, description=None, version=None, USER=parameterforcefield(), RULES=None, GLOBAL=None, LOCAL=None, **kwargs):
        &#34;&#34;&#34;
        Create a new instance of dforcefield with the option to override key attributes including RULES, GLOBAL, and LOCAL.
        &#34;&#34;&#34;
        # Use the current instance&#39;s values as defaults, and override if values are provided
        new_beadtype = beadtype if beadtype is not None else self.beadtype
        new_userid = userid if userid is not None else self.userid
        new_name = name if name is not None else self.name
        new_description = description if description is not None else self.description
        new_version = version if version is not None else self.version
        if new_userid == self.userid:
            new_userid = new_userid + &#34; (copy)&#34;
        # updated USER
        new_USER = self.parameters + USER
        # updated parameters
        new_parameters = self.parameters + parameterforcefield(**kwargs)
        # Combine or override RULES, GLOBAL, and LOCAL if provided
        new_rules = RULES if RULES is not None else self.RULES
        new_global = GLOBAL if GLOBAL is not None else self.GLOBAL
        new_local = LOCAL if LOCAL is not None else self.LOCAL
        # Create and return the new instance with overridden values
        return self.__class__(
            base_class=self.base_class.__class__,
            beadtype=new_beadtype,
            userid=new_userid,
            name=new_name,
            description=new_description,
            version=new_version,
            USER=new_USER,
            RULES=new_rules,
            GLOBAL=new_global,
            LOCAL=new_local,
            **new_parameters
        )


    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple attributes of the dforcefield instance at once, including RULES, GLOBAL, and LOCAL.

        Args:
            kwargs: Key-value pairs of attributes to update.
        &#34;&#34;&#34;
        for key, value in kwargs.items():
            if key == &#34;RULES&#34;:
                self.RULES = self.RULES + value if self.RULES else value
            elif key == &#34;GLOBAL&#34;:
                self.GLOBAL = self.GLOBAL + value if self.GLOBAL else value
            elif key == &#34;LOCAL&#34;:
                self.LOCAL = self.LOCAL + value if self.LOCAL else value
            else:
                setattr(self, key, value)



    def to_dict(self):
        &#34;&#34;&#34;
        Serialize the dforcefield instance to a dictionary, including RULES, GLOBAL, and LOCAL.

        Returns:
            dict: A dictionary containing all the attributes and their current values.

        Example:
            config = dynamic_water.to_dict()
            print(config)
        &#34;&#34;&#34;
        data = {
            &#34;name&#34;: self.name,
            &#34;description&#34;: self.description,
            &#34;beadtype&#34;: self.beadtype,
            &#34;userid&#34;: self.userid,
            &#34;version&#34;: self.version,
            &#34;parameters&#34;: dict(self.parameters),  # Convert parameters to a standard dict
            &#34;base_class&#34;: self.base_class.__class__.__name__,
            &#34;RULES&#34;: dict(self.RULES) if self.RULES else {},  # Include RULES if defined
            &#34;GLOBAL&#34;: dict(self.GLOBAL) if self.GLOBAL else {},  # Include GLOBAL if defined
            &#34;LOCAL&#34;: dict(self.LOCAL) if self.LOCAL else {}  # Include LOCAL if defined
        }
        return data



    @classmethod
    def from_dict(cls, data):
        &#34;&#34;&#34;
        Create a dforcefield instance from a dictionary, including RULES, GLOBAL, and LOCAL.

        Args:
            data (dict): A dictionary containing the attributes to initialize the dforcefield.

        Returns:
            dforcefield: A new dforcefield instance.

        Example:
            config = {
                &#34;name&#34;: &#34;water_ff&#34;,
                &#34;description&#34;: &#34;water forcefield&#34;,
                &#34;beadtype&#34;: 2,
                &#34;userid&#34;: &#34;water_sim&#34;,
                &#34;version&#34;: 1.0,
                &#34;parameters&#34;: {&#34;rho&#34;: 1000, &#34;sigma&#34;: 0.5},
                &#34;base_class&#34;: &#34;ulsph&#34;,
                &#34;RULES&#34;: {&#34;some_rule&#34;: &#34;value&#34;},
                &#34;GLOBAL&#34;: {&#34;global_param&#34;: 10},
                &#34;LOCAL&#34;: {&#34;local_param&#34;: 5}
            }

            new_ff = dforcefield.from_dict(config)
        &#34;&#34;&#34;
        # Extract base class information
        base_class_name = data.pop(&#34;base_class&#34;, None)
        base_class = globals().get(base_class_name) if base_class_name else None

        # Extract RULES, GLOBAL, and LOCAL from the data dictionary if they exist
        rules = data.pop(&#34;RULES&#34;, parameterforcefield())
        global_params = data.pop(&#34;GLOBAL&#34;, parameterforcefield())
        local_params = data.pop(&#34;LOCAL&#34;, parameterforcefield())

        # Create and return the new dforcefield instance with extracted or default RULES, GLOBAL, and LOCAL
        return cls(
            base_class=base_class,
            RULES=rules,
            GLOBAL=global_params,
            LOCAL=local_params,
            **data
        )


    def reset(self):
        &#34;&#34;&#34;
        Reset the dforcefield instance to its initial state, reapplying the default values
        including RULES, GLOBAL, and LOCAL.
        &#34;&#34;&#34;
        # Preserve the current RULES, GLOBAL, and LOCAL or reset them
        current_rules = self.RULES
        current_global = self.GLOBAL
        current_local = self.LOCAL

        # Reinitialize the instance with existing or reset RULES, GLOBAL, and LOCAL
        self.__init__(
            base_class=self.base_class.__class__,
            beadtype=self.beadtype,
            userid=self.userid,
            name=self.name,
            description=self.description,
            version=self.version,
            RULES=current_rules,
            GLOBAL=current_global,
            LOCAL=current_local
            )

    def validate(self):
        &#34;&#34;&#34;
        Validate the dforcefield instance to ensure all required attributes are set.

        Raises:
            ValueError: If any required attributes are missing or invalid.
        &#34;&#34;&#34;
        required_fields = self._dforcefield_specific_attributes

        for field in required_fields:
            if not getattr(self, field):
                raise ValueError(f&#34;{field} is required and not set.&#34;)

        print(&#34;Validation successful.&#34;)


    def compare(self, other, printflag=False):
        &#34;&#34;&#34;
        Compare the current instance with another dforcefield instance, including RULES, GLOBAL, and LOCAL.

        Args:
        -----
        other : dforcefield
            The other instance to compare.

        printflag : bool, optional (default: False)
            If True, prints a table showing all parameters, with differences marked by &#39;*&#39;.

        Returns:
        --------
        dict
            A dictionary showing differences between the two instances.

        Raises:
        -------
        TypeError: If the other object is not a dforcefield instance.

        Example:
        --------
        diffs = dynamic_water.compare(dynamic_salt)
        if printflag:
            Prints a comparison table with a type column and a legend at the end.
        &#34;&#34;&#34;
        # Define abbreviations for types
        type_abbreviations = {
            str: &#39;STR&#39;,
            int: &#39;INT&#39;,
            float: &#39;FLT&#39;,
            bool: &#39;BOOL&#39;,
            list: &#39;LST&#39;,
            tuple: &#39;TPL&#39;,
            dict: &#39;DCT&#39;,
            None: &#39;NON&#39;,
            &#39;missing&#39;: &#39;MIS&#39;
        }

        def get_type_abbrev(value):
            &#34;&#34;&#34;Return the abbreviation for the type of the value.&#34;&#34;&#34;
            if value is None:
                return type_abbreviations[None]
            return type_abbreviations.get(type(value), &#39;UNK&#39;)  # Use &#39;UNK&#39; for unknown types

        def format_simple_type(value):
            &#34;&#34;&#34;Format a simple value (str, number, or bool) for display.&#34;&#34;&#34;
            return self.dispmax(str(value))

        def format_iterable(value_self, value_other, key, comparison_table, difference):
            &#34;&#34;&#34;Handle lists, tuples, and other iterable types.&#34;&#34;&#34;
            max_length = max(len(value_self), len(value_other))
            for i in range(max_length):
                item_self = value_self[i] if i &lt; len(value_self) else &#39;MISSING&#39;
                item_other = value_other[i] if i &lt; len(value_other) else &#39;MISSING&#39;
                sub_difference = &#39;*&#39; if item_self != item_other else &#39; &#39;
                comparison_table.append(
                    f&#34;  {key if i == 0 else &#39;&#39;:&lt;15}: {sub_difference:^3}: {self.dispmax(str(item_self)):&lt;30}: {get_type_abbrev(item_self):&lt;5}: {self.dispmax(str(item_other)):&lt;30}: {get_type_abbrev(item_other):&lt;5}&#34;
                )

        def format_dict_like(value_self, value_other, key, comparison_table, difference):
            &#34;&#34;&#34;Handle dictionary-like objects (e.g., structs or dicts).&#34;&#34;&#34;
            comparison_table.append(f&#34;  {key:&lt;15}: {difference:^3}: &#34;)
            comparison_table.append(f&#34;  {&#39;&#39;:&lt;15}  {&#39;Self&#39;:&lt;30} {&#39;Type&#39;:&lt;5} {&#39;Other&#39;:&lt;30} {&#39;Type&#39;:&lt;5}&#34;)
            sub_sep = &#34;  &#34;+&#34;-&#34;*15+&#34;:&#34;+&#34;-&#34;*3+&#34;:&#34;+&#34;-&#34;*30+&#34;:&#34;+&#34;-&#34;*5+&#34;:&#34;+&#34;-&#34;*30+&#34;:&#34;+&#34;-&#34;*5
            comparison_table.append(sub_sep)
            sub_keys = set(value_self.keys()).union(value_other.keys())
            for sub_key in sorted(sub_keys):
                sub_value_self = value_self.get(sub_key, &#39;MISSING&#39;)
                sub_value_other = value_other.get(sub_key, &#39;MISSING&#39;)
                sub_difference = &#39;*&#39; if sub_value_self != sub_value_other else &#39; &#39;
                comparison_table.append(
                    f&#34;  {sub_key:&lt;15}: {sub_difference:^3}: {self.dispmax(str(sub_value_self)):&lt;30}: {get_type_abbrev(sub_value_self):&lt;5}: {self.dispmax(str(sub_value_other)):&lt;30}: {get_type_abbrev(sub_value_other):&lt;5}&#34;
                )
            comparison_table.append(sub_sep)

        def format_complex_type(value_self, value_other, key, comparison_table, difference):
            &#34;&#34;&#34;Handle complex types, expanding them into multiple lines.&#34;&#34;&#34;
            value_self_lines = str(value_self).splitlines()
            value_other_lines = str(value_other).splitlines()
            max_lines = max(len(value_self_lines), len(value_other_lines))
            for i in range(max_lines):
                line_self = value_self_lines[i] if i &lt; len(value_self_lines) else &#39;MISSING&#39;
                line_other = value_other_lines[i] if i &lt; len(value_other_lines) else &#39;MISSING&#39;
                comparison_table.append(
                    f&#34;  {key if i == 0 else &#39;&#39;:&lt;15}: {difference if i == 0 else &#39; &#39;:^3}: {self.dispmax(line_self):&lt;30}: {get_type_abbrev(line_self):&lt;5}: {self.dispmax(line_other):&lt;30}: {get_type_abbrev(line_other):&lt;5}&#34;
                )

        if not isinstance(other, dforcefield):
            raise TypeError(&#34;Can only compare with another dforcefield instance.&#34;)

        diffs = {}

        # Collect all keys from both instances, including RULES, GLOBAL, and LOCAL
        all_keys = set(self.keys()).union(other.keys(), {&#39;RULES&#39;, &#39;GLOBAL&#39;, &#39;LOCAL&#39;})

        # Iterate over all keys and compare the values
        for key in all_keys:
            value_self = getattr(self, key, None)
            value_other = getattr(other, key, None)

            if value_self != value_other:
                diffs[key] = {&#34;self&#34;: value_self, &#34;other&#34;: value_other}

        # If printflag is True, print the comparison in a table format
        if printflag:
            sep = &#34;  &#34;+&#34;-&#34;*15 + &#34;:&#34; + &#34;-&#34;*3 + &#34;:&#34; + &#34;-&#34;*30 + &#34;:&#34; + &#34;-&#34;*5 + &#34;:&#34; + &#34;-&#34;*30 + &#34;:&#34; + &#34;-&#34;*5
            header = f&#34;\n  {&#39;Attribute&#39;:&lt;15}: {&#39;*&#39;:^3}: {&#39;Self&#39;:&lt;30}: {&#39;Type&#39;:&lt;5}: {&#39;Other&#39;:&lt;30}: {&#39;Type&#39;:&lt;5}\n&#34; + sep
            comparison_table = [header]

            # Iterate over all parameters and mark differences with &#39;*&#39;
            for key in sorted(all_keys):  # Sort keys for a cleaner output
                value_self = getattr(self, key, &#39;MISSING&#39;)
                value_other = getattr(other, key, &#39;MISSING&#39;)
                difference = &#39;*&#39; if value_self != value_other else &#39; &#39;

                # Check if the value is a simple type (str, number, or bool)
                if isinstance(value_self, (str, int, float, bool)) and isinstance(value_other, (str, int, float, bool)):
                    comparison_table.append(
                        f&#34;  {key:&lt;15}: {difference:^3}: {format_simple_type(value_self):&lt;30}: {get_type_abbrev(value_self):&lt;5}: {format_simple_type(value_other):&lt;30}: {get_type_abbrev(value_other):&lt;5}&#34;
                    )
                # Check if the value is a list or tuple
                elif isinstance(value_self, (list, tuple)) and isinstance(value_other, (list, tuple)):
                    format_iterable(value_self, value_other, key, comparison_table, difference)
                # Check if the value is a dictionary-like object
                elif hasattr(value_self, &#39;keys&#39;) and hasattr(value_other, &#39;keys&#39;):
                    format_dict_like(value_self, value_other, key, comparison_table, difference)
                else:
                    # Handle other complex types
                    format_complex_type(value_self, value_other, key, comparison_table, difference)

            comparison_table.append(sep)
            # Add a legend for type abbreviations
            legend = &#34;\nType Legend: &#34; + &#34;, &#34;.join(f&#34;{abbrev} = {(&#39;NoneType&#39; if type_ is None else type_.__name__.upper())}&#34; for type_, abbrev in type_abbreviations.items() if type_ != &#39;missing&#39;)

            comparison_table.append(legend)

            # Print the comparison table
            print(&#34;\n&#34;.join(comparison_table))

        return diffs



    def generator(self):
        &#34;&#34;&#34;
        Generate the forcefield definition as a formatted string without traceability features.

        Returns:
        --------
        str: A string containing the formatted forcefield definition, including headers for attributes,
             descriptions, names, and parameters, but excluding traceability information such as host, date, and user.

        Example Output:
        ---------------
        base_class=&#34;tlsph&#34;
        beadtype = 1
        userid = &#34;dynamic_water&#34;
        version = 1.0

        # Description of the forcefield
        description:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;water&#34;}

        # Name of the forcefield
        name:{forcefield=&#34;LAMMPS:SMD&#34;, material=&#34;water&#34;}

        # Parameters for the forcefield
        rho = 1000
        E = &#34;5*${c0}^2*${rho}&#34;
        nu = 0.3
        &#34;&#34;&#34;
        # Construct forcefield attributes
        attributes = (
            f&#39;base_class=&#34;{self.base_class.__class__.__name__}&#34;\n&#39;
            f&#39;beadtype = {self.beadtype}\n&#39;
            f&#39;userid = &#34;{self.userid}&#34;\n&#39;
            f&#39;version = {self.version}\n\n&#39;
        )

        # Construct description
        description = (
            &#39;# Description of the forcefield\n&#39;
            f&#39;description:{{&#39; + &#39;, &#39;.join(f&#39;{key}=&#34;{value}&#34;&#39; for key, value in self.description.items()) + &#39;}\n\n&#39;
        )

        # Construct name
        name = (
            &#39;# Name of the forcefield\n&#39;
            f&#39;name:{{&#39; + &#39;, &#39;.join(f&#39;{key}=&#34;{value}&#34;&#39; for key, value in self.name.items()) + &#39;}\n\n&#39;
        )

        # Construct parameters
        parameters = &#39;# Parameters for the forcefield\n&#39;
        for key, value in self.parameters.items():
            parameters += f&#39;{key} = {value}\n&#39;

        # Combine all parts
        content = attributes + description + name + parameters
        return content



    def save(self, filename=None, foldername=None, overwrite=False, verbose=True, extension=&#34;.txt&#34;):
        &#34;&#34;&#34;
        Save the dforcefield instance to a file using the generated forcefield definition.

        Args:
        -----
        filename (str): The name of the file to save. Defaults to self.userid if not provided.
        foldername (str): The folder in which to save the file. Defaults to a temporary directory.
        overwrite (bool): Whether to overwrite the file if it already exists. Defaults to False.
        verbose (bool): Whether to include traceability features (host, date, user) in the saved file.
                        Defaults to True.
        extension (str): The file extension to use. Defaults to &#34;.txt&#34;.

        Raises:
        -------
        FileExistsError: If the file already exists and overwrite is False.

        Notes:
        ------
        The saved file will always include the mandatory line &#34;# DFORCEFIELD SAVE FILE&#34;.
        If verbose is True, a header with traceability information (host, date, user) will be included.
        The file extension can be customized via the &#39;extension&#39; parameter.

        Example Output when verbose=True:
        ---------------
        # DFORCEFIELD SAVE FILE
        # generated on 2024-12-30 by user@host
        #
        #   userid = &#34;dynamic_water&#34;

        base_class=&#34;tlsph&#34;
        beadtype = 1
        userid = &#34;dynamic_water&#34;
        version = 1.0

        # Description of the forcefield
        description:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;water&#34;}

        # Name of the forcefield
        name:{forcefield=&#34;LAMMPS:SMD&#34;, material=&#34;water&#34;}

        # Parameters for the forcefield
        rho = 1000
        E = &#34;5*${c0}^2*${rho}&#34;
        nu = 0.3

        Example Output when verbose=False:
        ---------------
        # DFORCEFIELD SAVE FILE

        base_class=&#34;tlsph&#34;
        beadtype = 1
        userid = &#34;dynamic_water&#34;
        version = 1.0

        # Description of the forcefield
        description:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;water&#34;}

        # Name of the forcefield
        name:{forcefield=&#34;LAMMPS:SMD&#34;, material=&#34;water&#34;}

        # Parameters for the forcefield
        rho = 1000
        E = &#34;5*${c0}^2*${rho}&#34;
        nu = 0.3
        &#34;&#34;&#34;
        # Determine filename
        if filename is None:
            filename = self.userid
        if not filename.endswith(extension):
            filename += extension

        # Determine foldername
        if foldername is None:
            foldername = tempfile.gettempdir()

        # Construct full file path
        if not os.path.isabs(filename):
            filepath = os.path.join(foldername, filename)
        else:
            filepath = filename

        # Check if file exists
        if os.path.exists(filepath) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

        # Generate forcefield content
        content = self.generator()

        # Initialize content with mandatory header
        final_content = &#39;# DFORCEFIELD SAVE FILE\n&#39;

        if verbose:
            user = getpass.getuser()
            host = socket.gethostname()
            date = datetime.now().strftime(&#39;%Y-%m-%d&#39;)

            # Construct traceability header
            trace_header = (
                f&#39;# generated on {date} by {user}@{host}\n&#39;
                f&#39;#\n&#39;
                f&#39;#   userid = &#34;{self.userid}&#34;\n\n&#39;
            )
            final_content += trace_header
        else:
            final_content += &#39;\n&#39;

        # Append forcefield content
        final_content += content

        # Write content to file
        with open(filepath, &#39;w&#39;) as f:
            f.write(final_content)

        print(f&#39;\nForcefield saved to {filepath}&#39;)
        return filepath



    @classmethod
    def load(cls, filename, foldername=None, authentication=True):
        &#34;&#34;&#34;
        Load a dforcefield instance from a file with more control over the folder location and file validation.

        Args:
        -----
        filename (str): The name of the file to load. The &#39;extension&#39; parameter will be used if not present.
        foldername (str): The folder from which to load the file. Defaults to a temporary directory.
        authentication (bool): Whether to authenticate the file by checking the mandatory header line.
                            Defaults to True. If False, bypasses the authentication and parses the content directly.

        Returns:
        --------
        dforcefield: A new dforcefield instance parsed from the file content.

        Raises:
        -------
        FileNotFoundError: If the file does not exist.
        ValueError: If authentication is True and the file does not start with the mandatory header.

        Notes:
        ------
        - The method checks for the mandatory line &#34;# DFORCEFIELD SAVE FILE&#34; at the beginning of the file.
        If authentication is False, this check is bypassed, allowing parsing of content generated by generate().
        - The file extension is expected to be &#39;.txt&#39; by default unless specified otherwise in the filename.

        Example Usage:
        --------------
        &gt;&gt;&gt; ff = dforcefield.load(&#34;forcefield.txt&#34;, authentication=True)
        &#34;&#34;&#34;
        # Determine file extension and ensure it ends with &#39;.txt&#39;
        if not filename.endswith(&#39;.txt&#39;):
            filename += &#39;.txt&#39;

        # Determine foldername
        if foldername is None:
            foldername = tempfile.gettempdir()

        # Construct full file path
        if not os.path.isabs(filename):
            filepath = os.path.join(foldername, filename)
        else:
            filepath = filename

        # Check if file exists
        if not os.path.exists(filepath):
            raise FileNotFoundError(f&#34;The file &#39;{filepath}&#39; does not exist.&#34;)

        # Read the file contents
        with open(filepath, &#39;r&#39;) as f:
            content = f.read()

        # Call the parse method to create a new dforcefield instance
        return cls.parsesyntax(content, authentication=authentication)



    @classmethod
    def parsesyntax(cls, content, authentication=True):
        &#34;&#34;&#34;
        Parse the string content of a forcefield file to create a dforcefield instance.

        Args:
        -----
        content (str): The string content to be parsed.
        authentication (bool): Whether to authenticate the content by checking the mandatory header line.
                               Defaults to True. If False, bypasses the authentication.

        Returns:
        --------
        dforcefield
            A new `dforcefield` instance populated with the parsed content.

        Raises:
        -------
        ValueError
            - If authentication is True and the content does not start with the correct mandatory header line.
            - If the content format is invalid.
            - If base_class is not a valid subclass of forcefield.

        Notes:
        ------
        - Handles different sections including parameters, name, and description.
        - Accepts empty lines and comments.
        - Uses { } for attributes blocks.
        - If authentication is False, it does not check for the mandatory header line.
        - Recognizes `beadtype`, `userid`, and `version` as special attributes. If they are not present,
          they are included in the `parameters`.

        Example Usage:
        --------------
        &gt;&gt;&gt; ff = dforcefield.parsesyntax(content_string, authentication=True)
        &#34;&#34;&#34;
        # Split the content into lines
        lines = content.splitlines()
        lines = [line for line in lines if line.strip()]  # Remove blank or empty lines

        # Raise an error if no content is left after removing blank lines
        if not lines:
            raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

        # Initialize containers for parsed data
        inside_global_params = False
        global_params_content = &#34;&#34;
        parameters = {}
        description = {}
        name = {}
        base_class_name = None

        # Step 1: Authenticate the file by checking the first line
        if authentication:
            if not lines[0].strip().startswith(&#34;# DFORCEFIELD SAVE FILE&#34;):
                raise ValueError(&#34;File/Content is not a valid DFORCEFIELD file.&#34;)
            # Remove the mandatory header line from processing
            lines = lines[1:]

        # Step 2: Process each line dynamically
        for line in lines:
            stripped = line.strip()

            # Ignore empty lines and comments
            if not stripped or stripped.startswith(&#34;#&#34;):
                continue

            # Remove trailing comments
            stripped = remove_comments(stripped)

            # Handle description and name blocks first to avoid parsing them as parameters
            if stripped.startswith(&#34;description:{&#34;):
                desc_content = stripped[len(&#34;description:{&#34;):].strip()
                # Check if the block ends on the same line
                if desc_content.endswith(&#34;}&#34;):
                    desc_content = desc_content[:-1].strip()
                    cls._parse_struct_block(desc_content, description)
                else:
                    # Multiline description block
                    desc_content = desc_content
                    while not stripped.endswith(&#34;}&#34;):
                        next_line = next(iter(lines), &#34;&#34;).strip()
                        stripped = next_line
                        desc_content += &#34; &#34; + cls.remove_comments(next_line)
                    desc_content = desc_content[:-1].strip()
                    cls._parse_struct_block(desc_content, description)
                continue  # Skip further processing for this line

            if stripped.startswith(&#34;name:{&#34;):
                name_content = stripped[len(&#34;name:{&#34;):].strip()
                # Check if the block ends on the same line
                if name_content.endswith(&#34;}&#34;):
                    name_content = name_content[:-1].strip()
                    cls._parse_struct_block(name_content, name)
                else:
                    # Multiline name block
                    name_content = name_content
                    while not stripped.endswith(&#34;}&#34;):
                        next_line = next(iter(lines), &#34;&#34;).strip()
                        stripped = next_line
                        name_content += &#34; &#34; + cls.remove_comments(next_line)
                    name_content = name_content[:-1].strip()
                    cls._parse_struct_block(name_content, name)
                continue  # Skip further processing for this line

            # Handle global parameters inside {...}
            if stripped.startswith(&#34;{&#34;):
                inside_global_params = True
                global_params_content = stripped[1:].strip()
                # Check if the block ends on the same line
                if &#39;}&#39; in global_params_content:
                    global_params_content = global_params_content.split(&#39;}&#39;, 1)[0].strip()
                    inside_global_params = False
                    cls._parse_global_params(global_params_content, parameters)
                    global_params_content = &#34;&#34;
                continue  # Skip further processing for this line

            if inside_global_params:
                if &#39;}&#39; in stripped:
                    global_params_content += &#34; &#34; + stripped.split(&#39;}&#39;, 1)[0].strip()
                    inside_global_params = False
                    cls._parse_global_params(global_params_content, parameters)
                    global_params_content = &#34;&#34;
                else:
                    global_params_content += &#34; &#34; + stripped
                continue  # Continue to next line

            # Handle key-value pairs
            if &#34;=&#34; in stripped:
                key, value = stripped.split(&#34;=&#34;, 1)
                key = key.strip()
                value = value.strip().strip(&#39;&#34;&#39;).strip(&#34;&#39;&#34;)
                if key == &#34;base_class&#34;:
                    # Store the class name, do not load
                    base_class_name = value
                elif key in {&#34;beadtype&#34;, &#34;userid&#34;, &#34;version&#34;}:
                    parameters[key] = cls._convert_value(value)
                else:
                    parameters[key] = cls._convert_value(value)
                continue  # Skip further processing for this line

        # Step 3: Handle special attributes (beadtype, userid, version)
        # Extract beadtype
        beadtype = parameters.pop(&#39;beadtype&#39;, None)
        if beadtype is not None:
            try:
                beadtype = int(beadtype)
            except ValueError:
                raise ValueError(f&#34;Invalid value for beadtype: {beadtype}. It must be an integer.&#34;)
        else:
            beadtype = 1  # Default value
            parameters[&#39;beadtype&#39;] = beadtype

        # Extract userid
        userid = parameters.pop(&#39;userid&#39;, None)
        if userid is not None:
            userid = str(userid)
        else:
            userid = &#34;unknown&#34;  # Default value
            parameters[&#39;userid&#39;] = userid

        # Extract version
        version = parameters.pop(&#39;version&#39;, None)
        if version is not None:
            try:
                version = float(version)
            except ValueError:
                raise ValueError(f&#34;Invalid value for version: {version}. It must be a float.&#34;)
        else:
            version = 0.1  # Default value
            parameters[&#39;version&#39;] = version

        # Step 4: Validate base_class and create a new dforcefield instance
        if base_class_name is None:
            raise ValueError(&#34;base_class must be specified and valid in the forcefield file.&#34;)

        #â™  Dynamically set the base class based on the string value (e.g., &#34;tlsph&#34;)
        resolved_base_class  = cls._load_base_class(base_class_name)
        if resolved_base_class is None or not issubclass(resolved_base_class, forcefield):
            value = str(resolved_base_class)
            raise ValueError(f&#34;Invalid base_class: &#39;{value}&#39; must be a subclass of forcefield.&#34;)

        # Step 6: Create and return the new dforcefield instance
        newFF = cls(
            base_class=resolved_base_class,
            beadtype=beadtype,
            userid=userid,
            name=struct(**name),
            description=struct(**description),
            version=version,
            USER=parameterforcefield(**parameters)
        )

        # Step 6: Detect variables in templates and propagate undefined variables
        dvars = newFF.detectVariables()
        newFF.parameters = dvars + newFF.parameters
        return newFF


    @classmethod
    def _parse_global_params(cls, content, global_params):
        &#34;&#34;&#34;Parse global parameters from the accumulated content between {}.&#34;&#34;&#34;
        lines = re.split(r&#39;,(?![^(){}\[\]]*[\)\}\]])&#39;, content)
        for line in lines:
            line = line.strip()
            match = re.match(r&#39;([\w_]+)\s*=\s*(.+)&#39;, line)
            if match:
                key, value = match.groups()
                key = key.strip()
                value = value.strip()
                global_params[key] = cls._convert_value(value)



    @classmethod
    def _parse_struct_block(cls, content, struct_block):
        &#34;&#34;&#34;
        Parse blocks like description or name with key=value pairs, handling commas inside quotes.

        Parameters:
        -----------
        content : str
            The content to parse, which contains key=value pairs.

        struct_block : dict
            A dictionary to store the parsed key-value pairs.
        &#34;&#34;&#34;
        # Split on commas that are not inside quotes
        pairs = re.split(r&#39;,\s*(?![^&#34;]*\&#34;\s*,\s*[^&#34;]*&#34;)&#39;, content)

        for pair in pairs:
            if &#39;=&#39; in pair:
                key, value = pair.split(&#39;=&#39;, 1)  # Ensure splitting only on the first &#39;=&#39;
            struct_block[key.strip()] = value.strip().strip(&#39;&#34;&#39;)



    @classmethod
    def _convert_value(cls, value):
        &#34;&#34;&#34;Convert a string representation of a value to the appropriate Python type.&#34;&#34;&#34;
        value = value.strip()

        # Boolean conversion
        if value.lower() == &#39;true&#39;:
            return True
        elif value.lower() == &#39;false&#39;:
            return False

        # Handle quoted strings
        if (value.startswith(&#39;&#34;&#39;) and value.endswith(&#39;&#34;&#39;)) or (value.startswith(&#34;&#39;&#34;) and value.endswith(&#34;&#39;&#34;)):
            return value[1:-1]

        # Handle lists
        if value.startswith(&#39;[&#39;) and value.endswith(&#39;]&#39;):
            return eval(value)  # Using eval to parse lists safely in this controlled scenario

        # Handle numbers
        try:
            if &#39;.&#39; in value:
                return float(value)
            return int(value)
        except ValueError:
            return value


    def detectVariables(self):
        &#34;&#34;&#34;
        Detects variables in the form ${variable} from the outputs of pair_style, pair_diagcoeff,
        and pair_offdiagcoeff.

        Returns:
        --------
        struct
            A struct containing the detected variable names that are not yet defined.
        &#34;&#34;&#34;
        # Extract variables from pair_style, pair_diagcoeff, and pair_offdiagcoeff
        detected_vars = set()

        # Define a regex pattern to detect variables in the form ${variable}
        pattern = r&#39;\$\{(\w+)\}&#39;

        # Detect variables in pair_style output
        pair_style_output = self.pair_style(printflag=False, raw=True)
        detected_vars.update(re.findall(pattern, pair_style_output))

        # Detect variables in pair_diagcoeff output
        pair_diagcoeff_output = self.pair_diagcoeff(printflag=False, raw=True)
        detected_vars.update(re.findall(pattern, pair_diagcoeff_output))

        # Detect variables in pair_offdiagcoeff output
        pair_offdiagcoeff_output = self.pair_offdiagcoeff(printflag=False, raw=True)
        detected_vars.update(re.findall(pattern, pair_offdiagcoeff_output))

        # Convert the detected variables into a parameterforcefield() for further propagation
        return parameterforcefield(**{var: &#34;${&#34; + var + &#34;}&#34; for var in detected_vars})


    def missingVariables(self, isimplicit_missing=True, output_aslist=False):
        &#34;&#34;&#34;
        List missing variables (undefined in parameters).

        Parameters:
        -----------
        isimplicit_missing : bool, optional (default: True)
            If True, variables defined implicitly as ${varname} in parameters are considered missing.

        output_aslist : bool, optional (default: False)
            If True, returns a list of missing variable names.
            If False, returns a parameterforcefield-like structure with implicit definitions.

        Returns:
        --------
        List of str or parameterforcefield
            If output_aslist is True, returns a list of variable names that are missing from the parameters.
            If output_aslist is False, returns a parameterforcefield-like structure with implicit definitions.
        &#34;&#34;&#34;
        # Detect all variables used in the forcefield using detectVariables
        detected_vars = self.detectVariables()

        # Initialize missing variables
        missing_vars = []

        # Initialize a dictionary to store variables as parameterforcefield when output_aslist=False
        missing_vars_struct = {}

        # Iterate over detected variables and check if they are missing in parameters
        for varname in detected_vars.keys():
            if varname not in self.parameters:
                # If the variable is missing, add it to both the list and struct
                missing_vars.append(varname)
                missing_vars_struct[varname] = &#34;${&#34; + varname + &#34;}&#34;
            elif isimplicit_missing:
                # If the variable exists but is implicitly defined as ${varname}, treat it as missing
                param_value = self.parameters.getattr(varname)
                if param_value == &#34;${&#34; + varname + &#34;}&#34;:
                    missing_vars.append(varname)
                    missing_vars_struct[varname] = &#34;${&#34; + varname + &#34;}&#34;

        # Return the result based on the output_aslist flag
        if output_aslist:
            return missing_vars
        else:
            return parameterforcefield(**missing_vars_struct)


    @classmethod
    def list_forcefield_subclasses(cls, printflag=True, additional_modules=None):
        &#34;&#34;&#34;
        Class method to list all subclasses of the `forcefield` and `generic` classes, including their methods.

        Parameters:
        -----------
        printflag : bool, optional (default=True)
            If True, prints the subclasses of `forcefield`, `generic`, their load status, and their default parameters.
        additional_modules : module or list of modules, optional
            A module or list of additional modules to search for subclasses and methods.

        Returns:
        --------
        dict
            A dictionary where keys are class names or method names and values are dictionaries containing:
            - &#34;loaded&#34;: Whether the class or method is already loaded in memory.
            - &#34;module&#34;: The module path of the class or method.
            - &#34;default_parameters&#34;: Extracted parameters, RULES, LOCAL, and GLOBAL from the class or method.
        dict
            A dictionary mapping short names to full names.
        &#34;&#34;&#34;
        subclasses = set()
        classes_to_check = [forcefield, generic]  # Start with both forcefield and generic

        # Ensure additional_modules is a list, even if it&#39;s a single module
        if additional_modules is not None and not isinstance(additional_modules, list):
            additional_modules = [additional_modules]

        # Include classes from additional modules
        if additional_modules:
            for mod in additional_modules:
                for name, obj in inspect.getmembers(mod):
                    # Add classes that are subclasses of forcefield or generic
                    if inspect.isclass(obj) and (issubclass(obj, forcefield) or issubclass(obj, generic)) and obj not in {forcefield, generic}:
                        subclasses.add(obj)
                        classes_to_check.append(obj)
                    # Also add relevant high-level methods/functions that do not start with &#39;_&#39;
                    elif (inspect.isfunction(obj) or inspect.ismethod(obj)) and not name.startswith(&#39;_&#39;):
                        # Check if the method belongs to a class derived from generic, not forcefield
                        parent_class_name = obj.__qualname__.split(&#39;.&#39;)[0]
                        parent_class = next((cls for cls in subclasses if cls.__name__ == parent_class_name), None)
                        if parent_class and issubclass(parent_class, generic) and not issubclass(parent_class, forcefield):
                            subclasses.add((parent_class, name, obj))  # Add (parent_class, method_name, function/method)

        # Traverse through all found subclasses
        while classes_to_check:
            parent_class = classes_to_check.pop()
            for subclass in parent_class.__subclasses__():
                subclasses.add(subclass)
                classes_to_check.append(subclass)

        # Prepare the output dictionary with load status flags and default parameters
        subclass_info = {}
        short_name_mapping = {}

        for subclass in subclasses:
            if inspect.isclass(subclass):
                class_name = subclass.__name__
                is_loaded = class_name in globals()  # Check if class is already loaded

                # Extract default parameters if they exist
                extracted_params = cls.extract_default_parameters(subclass, displayflag=False)
                num_defaults = len(extracted_params.get(&#39;parameters&#39;, {}).keys()) if extracted_params else None

                # Check if RULES, GLOBAL, and LOCAL are defined
                rules_defined = &#39;&#39;
                if extracted_params:
                    rules_defined += &#39;R&#39; if extracted_params[&#34;RULES&#34;] else &#39;-&#39;
                    rules_defined += &#39;G&#39; if extracted_params[&#34;GLOBAL&#34;] else &#39;-&#39;
                    rules_defined += &#39;L&#39; if extracted_params[&#34;LOCAL&#34;] else &#39;-&#39;

                # Add entry for the class
                subclass_info[class_name] = {
                    &#34;loaded&#34;: is_loaded,
                    &#34;module&#34;: subclass.__module__,
                    &#34;num_defaults&#34;: num_defaults,
                    &#34;rules_defined&#34;: rules_defined if rules_defined else &#39;---&#39;  # Display as &#39;---&#39; if none defined
                }

                # Map short name to full name
                short_name_mapping[class_name] = class_name

                # Inspect and add high-level methods from the class itself if not forcefield
                if not issubclass(subclass, forcefield):
                    for method_name, method in inspect.getmembers(subclass, predicate=inspect.isfunction):
                        if not method_name.startswith(&#39;_&#39;):  # Skip private methods
                            method_full_name = f&#34;{class_name}.{method_name}&#34;
                            extracted_method_params = cls.extract_default_parameters(subclass, method_name=method_name, displayflag=False)
                            num_defaults = len(extracted_method_params.get(&#39;parameters&#39;, {}).keys()) if extracted_method_params else None
                            rules_defined = extracted_method_params.get(&#34;rules_defined&#34;, &#34;---&#34;)
                            subclass_info[method_full_name] = {
                                &#34;loaded&#34;: True,
                                &#34;module&#34;: subclass.__module__,
                                &#34;num_defaults&#34;: num_defaults,
                                &#34;rules_defined&#34;: rules_defined
                            }
                            # Add method short name to mapping
                            short_name_mapping[method_name] = method_full_name

            else:
                # Handle function/method cases
                parent_class, func_name, func_obj = subclass
                is_loaded = func_name in globals() or parent_class.__module__ in sys.modules
                extracted_method_params = cls.extract_default_parameters(parent_class, method_name=func_name, displayflag=False)
                num_defaults = len(extracted_method_params.get(&#39;parameters&#39;, {}).keys()) if extracted_method_params else None
                rules_defined = extracted_method_params.get(&#34;rules_defined&#34;, &#34;---&#34;)
                func_full_name = f&#34;{parent_class.__name__}.{func_name}&#34;
                subclass_info[func_full_name] = {
                    &#34;loaded&#34;: is_loaded,
                    &#34;module&#34;: parent_class.__module__,
                    &#34;num_defaults&#34;: num_defaults,
                    &#34;rules_defined&#34;: rules_defined
                }
                # Add function/method to short names
                short_name_mapping[func_name] = func_full_name

        # Optionally print the subclasses and their load status with parameter info
        if printflag:
            print(&#34;List of available forcefields and relevant methods:\n&#34;)
            print(f&#34;{&#39;Short Name&#39;:&lt;15} {&#39;Class/Method Name&#39;:&lt;30} {&#39;Module Path&#39;:&lt;30} {&#39;Status&#39;:&lt;10} {&#39;Default Params&#39;:&lt;10} {&#39;RULES&#39;:&lt;5}&#34;)
            print(&#34;=&#34; * 105)
            for short_name, class_name in sorted(short_name_mapping.items(), key=lambda x: x[0]):
                info = subclass_info[class_name]
                status = &#34;Loaded&#34; if info[&#34;loaded&#34;] else &#34;Not Loaded&#34;
                num_defaults = info[&#34;num_defaults&#34;] if info[&#34;num_defaults&#34;] is not None else &#34;None&#34;
                rules_defined = info[&#34;rules_defined&#34;]
                print(f&#34;{short_name:&lt;15} {class_name:&lt;30} {info[&#39;module&#39;]:&lt;30} {status:&lt;10} {num_defaults:&lt;10} {rules_defined:&lt;5}&#34;)
            print(f&#34;\nTotal number of forcefields and methods: {len(subclass_info)}&#34;)

        return subclass_info, short_name_mapping



    def scriptobject(self, beadtype=None, name=None, userid=None, fullname=None, filename=None, group=None, style=None, USER=scriptdata()):
        &#34;&#34;&#34;
        Method to return a scriptobject based on the current dforcefield instance.

        Parameters:
        ------------
        beadtype : int, optional
            The bead type identifier. Defaults to the instance&#39;s beadtype.

        name : str, optional
            A short name for the scriptobject. If not provided, uses &#39;forcefield&#39; from self.name.

        fullname : str, optional
            A comprehensive name for the object. Defaults to &#34;beads of type {self.beadtype} | object of forcefield: {self.name.forcefield}&#34;.

        group : list, optional
            A group of scriptobjects that this object belongs to. Defaults to an empty list.

        style : str, optional
            The style of the scriptobject. Defaults to `self.description.style` if available, otherwise &#34;smd&#34;.

        USER : scriptdata, optional
            User-defined data for additional parameters. Defaults to a blank `scriptdata()` instance.

        Returns:
        --------
        scriptobject
            A scriptobject instance populated with the current `dforcefield` instance&#39;s attributes or provided arguments.
        &#34;&#34;&#34;
        # Set defaults using instance attributes if parameters are None
        if beadtype is None:
            beadtype = self.beadtype

        # Extract a meaningful name from the forcefield&#39;s name structure
        if name is None:
            if isinstance(self.name, struct) and hasattr(self.name, &#39;material&#39;):
                name = f&#34;{self.name.material} bead&#34;
            else:
                name = f&#34;beadtype_{beadtype}&#34;

        if userid is None:
            userid = name

        if fullname is None:
            fullname = f&#34;beads of type {beadtype} | object of forcefield: {self.name.forcefield if isinstance(self.name, struct) and hasattr(self.name, &#39;forcefield&#39;) else &#39;unknown&#39;}&#34;

        if group is None:
            group = []

        # Use `self.description.style` as the default for style if it exists, otherwise fall back to &#34;smd&#34;
        if style is None:
            if isinstance(self.description, struct) and hasattr(self.description, &#39;style&#39;):
                style = self.description.style
            else:
                style = &#34;undefined style&#34;

        # The current dforcefield instance behaves as the forcefield for the scriptobject
        forcefield = copy.deepcopy(self)
        forcefield.beadtype = beadtype
        forcefield.name = name
        forcefield.userid = userid

        # Apply any user-defined parameters to the forcefield
        # This is the standard behavior of scriptobject
        forcefield.parameters = forcefield.parameters + USER

        # Create and return the scriptobject instance
        return scriptobject(
            beadtype=beadtype,
            name=name,
            fullname=fullname,
            filename=filename,
            style=style,
            forcefield=forcefield,  # Use the current dforcefield instance
            group=group,
            USER=USER
        )


    def __copy__(self):
        &#34;&#34;&#34;
        Shallow copy method for dforcefield.

        Creates a shallow copy of the dforcefield instance, meaning that references
        to mutable objects like &#39;parameters&#39; will not be deeply copied.
        &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)

        # Copy the simple attributes
        copie.__dict__.update(self.__dict__)

        # Return the shallow copy
        return copie


    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        Deep copy method for dforcefield.

        Creates a deep copy of the dforcefield instance, including its complex attributes
        like &#39;parameters&#39;. This ensures that all mutable objects are fully copied, not just referenced.
        &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie

        # Recursively deep copy each attribute
        for k, v in self.__dict__.items():
            if k == &#34;base_class&#34;:
                # The base_class should not be deeply copied; it&#39;s a class reference
                setattr(copie, k, self.base_class)
            else:
                # Deep copy other attributes
                setattr(copie, k, copy.deepcopy(v, memo))

        return copie # return copied instance


    @property
    def base_class_name(self):
        &#34;&#34;&#34;
        Returns the name of the base_class as a lowercase string.

        Returns:
            str: The lowercase name of the base_class.
        &#34;&#34;&#34;
        if isinstance(self.base_class, forcefield):
            return self.base_class.__class__.__name__.lower()
        else:
            raise TypeError(&#34;base_class is not an instance of a forcefield subclass.&#34;)
# %% DEBUG
# ===================================================
# main()
# ===================================================
# for debugging purposes (code called as a script)
# the code is called from here
# ============================
if __name__ == &#39;__main__&#39;:

    # ---------------------------------------------------------------
    # The examples below reconstruct dynamycally the FF:
    #       * water from pizza.forcefield.water()
    #       * solidfood from pizza.forcefield.solidfood()
    #       * salt from pizza.forcefield.saltTLSPH()
    #       * rigidwall from pizza.forcefield.rigidwall()
    # ---------------------------------------------------------------

    # List available forcefields
    dforcefield.list_forcefield_subclasses(printflag=True,additional_modules=None) # we could add other modules

    # We reuse a high-level forcefield
    mywater = dforcefield(
        base_class=&#34;water&#34;,
        userid = &#34;my customized water&#34;,
        rho = 900,
        q1 = 0.1
        )

    # Test dynamic water class using ulsph as the base class
    dynamic_water = dforcefield(
        base_class=&#39;ulsph&#39;,
        beadtype=1,
        userid=&#34;dynamic_water&#34;,
        USER=parameterforcefield(
            rho=1000,
            c0=10.0,
            q1=1.0,
            Cp=1.0,
            taitexponent=7,
            contact_scale=1.5,
            contact_stiffness=&#34;2.5*${c0}^2*${rho}&#34;
        )
    )
    print(f&#34;Water parameters: {dynamic_water.parameters}&#34;)
    print(f&#34;Water name: {dynamic_water.name}&#34;)
    print(f&#34;Water Cp: {dynamic_water.Cp}&#34;)
    dynamic_water

    # Test dynamic solidfood class using tlsph as the base class
    dynamic_solidfood = dforcefield(
        base_class=&#39;tlsph&#39;,
        beadtype=2,
        userid=&#34;dynamic_solidfood&#34;,
        #USER=parameterforcefield( #&lt;--- note that USER is not used in this case
            rho=1000,
            c0=10.0,
            E=&#34;5*${c0}^2*${rho}&#34;,
            nu=0.3,
            q1=1.0,
            q2=0.0,
            Hg=10.0,
            Cp=1.0,
            sigma_yield=&#34;0.1*${E}&#34;,
            hardening=0,
            contact_scale=1.5,
            contact_stiffness=&#34;2.5*${c0}^2*${rho}&#34;
        #)
    )
    print(f&#34;Solidfood parameters: {dynamic_solidfood.parameters}&#34;)
    print(f&#34;Solidfood name: {dynamic_solidfood.name}&#34;)
    repr(dynamic_solidfood)

    # Test dynamic saltTLSPH class using tlsph as the base class
    dynamic_salt = dforcefield(
        base_class=&#39;tlsph&#39;,
        beadtype=3,
        userid=&#34;dynamic_salt&#34;,
        USER=parameterforcefield(
            rho=1000,
            c0=10.0,
            E=&#34;5*${c0}^2*${rho}&#34;,
            nu=0.3,
            q1=1.0,
            q2=0.0,
            Hg=10.0,
            Cp=1.0,
            sigma_yield=&#34;0.1*${E}&#34;,
            hardening=0,
            contact_scale=1.5,
            contact_stiffness=&#34;2.5*${c0}^2*${rho}&#34;
        )
    )
    print(f&#34;Salt TLSPH parameters: {dynamic_salt.parameters}&#34;)
    print(f&#34;Salt TLSPH name: {dynamic_salt.name}&#34;)
    repr(dynamic_salt)

    # Test dynamic rigidwall class using none as the base class
    dynamic_rigidwall = dforcefield(
        base_class=&#39;none&#39;,  # Assuming a class `none` exists
        beadtype=4,
        userid=&#34;dynamic_rigidwall&#34;,
        USER=parameterforcefield(
            rho=3000,
            c0=10.0,
            contact_scale=1.5,
            contact_stiffness=&#34;2.5*${c0}^2*${rho}&#34;
        )
    )
    print(f&#34;Rigidwall parameters: {dynamic_rigidwall.parameters}&#34;)
    print(f&#34;Rigidwall name: {dynamic_rigidwall.name}&#34;)
    repr(dynamic_rigidwall)


    # create a new food and save it on disk
    newfood = dynamic_solidfood.copy(rho=2100,q1=4,E=1000,name=&#34;new food&#34;)
    repr(newfood)
    newfood.base_repr()
    fname = newfood.save(overwrite=True)

    # load again the same file
    newfood2 = dforcefield.load(fname)

    # compare the content
    newfood.compare(newfood2,printflag=True)

    # note that the variables are automatically identified and added to parameters if missing
    newfood.parameters = parameterforcefield(a=1,b=2)
    missingvars = newfood.missingVariables()
    print(&#39;updated newfood:\n&#39;)
    repr(newfood)
    print(&#39;missing variables in updated newfood:\n&#39;)
    repr(missingvars)

    # compare the content
    newfood.compare(newfood2,printflag=True)

    # check the parser
    content = &#34;&#34;&#34;
# DFORCEFIELD SAVE FILE
base_class=&#34;tlsph&#34;
beadtype = 1
userid = &#34;dynamic_water&#34;
version = 1.0

description:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;water&#34;}
name:{forcefield=&#34;LAMMPS:SMD&#34;, material=&#34;water&#34;}

rho = 1000
E = &#34;5*${c0}^2*${rho}&#34;
nu = 0.3
&#34;&#34;&#34;
    parsed_forcefield = dforcefield.parsesyntax(content)
    print(parsed_forcefield.script)

    # create a script object
    obj = parsed_forcefield .scriptobject(group=&#34;A&#34;)


    # *********************************************************************************************
    # Production Example: Scriptobject Creation and Combination
    #
    # This example demonstrates the creation and combination of `scriptobject` instances from both
    # static forcefield classes and dynamic forcefield instances (via `dforcefield`).
    #
    # Key Points:
    # ------------
    # 1. **Static and Dynamic Forcefields**:
    #    - Scriptobjects can be created using static forcefields (e.g., `rigidwall`, `solidfood`, etc.)
    #      or dynamic forcefields generated from a `dforcefield` instance (e.g., `waterFF`).
    #    - Dynamic forcefields can either be passed directly to the `pizza.script.scriptobject()`
    #      constructor or instantiated through the `scriptobject` method of any `pizza.dforcefield` object.
    #
    # 2. **Combining Scriptobjects**:
    #    - Scriptobjects can be combined using the `+` operator to create a collection of objects.
    #    - This collection of scriptobjects can then be scripted dynamically using the `script` property
    #      to generate their interaction definitions.
    #
    # 3. **Geometry Input**:
    #    - Geometry for the scriptobjects can be provided either via an input file (using `filename`)
    #      or dynamically using `pizza.region.region()`.
    #
    # **********************************************************************************************

    from pizza.forcefield import rigidwall, solidfood, water

    # Create a dynamic forcefield for water with a specific density (rho=900) and beadtype=1
    waterFF = dforcefield(base_class=&#34;water&#34;, rho=900, beadtype=1)

    # Define water beads using the dforcefield instance&#39;s scriptobject method
    bwater = waterFF.scriptobject(name=&#34;water&#34;, group=[&#34;A&#34;, &#34;D&#34;], filename=&#34;mygeom&#34;)

    # Alternatively, define water beads by passing the dynamic forcefield directly to scriptobject
    bwater2 = scriptobject(name=&#34;water&#34;, group=[&#34;A&#34;, &#34;D&#34;], filename=&#34;mygeom&#34;, forcefield=waterFF)

    # Define other dummy beads using static forcefields
    b1 = scriptobject(name=&#34;bead 1&#34;, group=[&#34;A&#34;, &#34;B&#34;, &#34;C&#34;], filename=&#39;myfile1&#39;, forcefield=rigidwall())
    b2 = scriptobject(name=&#34;bead 2&#34;, group=[&#34;B&#34;, &#34;C&#34;], filename=&#39;myfile1&#39;, forcefield=rigidwall())
    b3 = scriptobject(name=&#34;bead 3&#34;, group=[&#34;B&#34;, &#34;D&#34;, &#34;E&#34;], forcefield=solidfood())
    b4 = scriptobject(name=&#34;bead 4&#34;, group=&#34;D&#34;, beadtype=1, filename=&#34;myfile2&#34;, forcefield=water())

    # Combine the scriptobjects into a collection using the &#39;+&#39; operator
    collection = bwater + b1 + b2 + b3 + b4

    # Generate the script for the interactions in the collection
    collection.script

    # Similarly, using the alternate water bead definition (bwater2)
    collection2 = bwater2 + b1 + b2 + b3 + b4
    collection2.script


    # *********************************************************************************************
    # Example: Using Dynamic Forcefields from `pizza.generic` alongside `forcefield` Classes
    #
    # This example demonstrates how to use dynamic forcefields defined within the `pizza.generic`
    # module and seamlessly integrate them with existing static `forcefield` classes for simulation scripting.
    #
    # Key Points:
    # ------------
    # 1. **Dynamic Forcefields via Generic Classes**:
    #    - The `generic` module enables the creation of dynamic forcefields using high-level methods
    #      (e.g., `newtonianfluid` from the `USERSMD` class) without the need to define them statically.
    #    - These dynamic forcefields can be instantiated using the `dforcefield` class and linked
    #      to the high-level methods in the `generic` module via `additional_modules`.
    #
    # 2. **Integration with Existing Forcefields**:
    #    - `dforcefield` instances created from `generic` methods are fully compatible with static
    #      forcefield classes such as `rigidwall`, `solidfood`, and `water`.
    #    - Scriptobjects created from dynamic instances can be combined with other forcefield-derived objects,
    #      making them versatile for complex simulations.
    #
    # 3. **Workflow**:
    #    - **Step 1**: Specify the additional modules (`additional_modules`) where the high-level forcefield
    #      definitions are located (e.g., the `generic` module).
    #    - **Step 2**: Initialize the `dforcefield` with a specific method name (e.g., `newtonianfluid`)
    #      to dynamically create the forcefield. The properties can be set directly during initialization or updated later.
    #    - **Step 3**: Use the created dynamic forcefield instance to define scriptobjects and combine them
    #      with other static forcefields in a collection for further interactive scripting.
    #
    # 4. **Adjusting Parameters Dynamically**:
    #    - `RULES`, `GLOBAL`, and `LOCAL` parameters are integral parts of the `generic` module, providing additional
    #      flexibility to modify forcefield behavior on-the-fly.
    #    - Use methods like `get_rules()`, `set_rules()`, `set_local()`, and `set_global()` to adjust these parameters
    #      dynamically according to the simulation needs.
    #
    # *********************************************************************************************

    from pizza.forcefield import rigidwall, solidfood, water
    from pizza.generic import generic

    # Step 1: Specify the additional module(s) where USERSMD and its methods are located.
    # The `additional_modules` list informs `dforcefield` where to find high-level method definitions like `newtonianfluid`.
    additional_modules = [generic]  # You can also use a string like &#34;generic&#34; if imports resolve correctly.

    # Step 2: Initialize a dynamic forcefield using `newtonianfluid` from the USERSMD class via additional_modules.
    dynamic_ff = dforcefield(
        base_class=&#34;newtonianfluid&#34;,  # Use the name of the function from USERSMD.
        beadtype=6,                   # Specify the bead type for the forcefield.
        userid=&#34;fluid_instance&#34;,      # Assign a unique identifier for the forcefield instance.
        additional_modules=additional_modules,  # Pass the module list containing high-level forcefield methods.
        rho=900,                      # Define fluid density directly during initialization.
        nu=1e-4                       # Define kinematic viscosity directly during initialization.
    )

    # Step 3: Read and update RULES parameters dynamically.
    # RULES are predefined formulas or constants that affect forcefield behavior and can be adjusted on-the-fly.
    current_RULES = dynamic_ff.get_rules()
    print(f&#34;Dynamic RULES apply to {dynamic_ff.name}:&#34;)
    repr(current_RULES)
    # Update a specific RULE, which impacts how forces are calculated in the simulation.
    current_RULES.q1 = &#34;10*${nu}/(${c0}*${h})&#34;
    dynamic_ff.set_rules(current_RULES)  # Update the RULES parameters in the dforcefield instance.

    # Step 4: Update LOCAL parameters dynamically.
    # LOCAL parameters represent properties specific to the instance, such as material properties.
    dynamic_ff.set_local(rho=1011, nu=0.00123)  # Update properties directly with keyword arguments.

    # Display the current state of the dynamic forcefield instance.
    print(&#34;\nDynamic dforcefield instance based on generic.newtonianfluid:\n&#34;)
    repr(dynamic_ff)

    # Define a scriptobject using the dynamic forcefield instance.
    # Scriptobjects represent physical entities in simulations, defined using the forcefield properties.
    bwater3 = dynamic_ff.scriptobject(name=&#34;water_newtonian&#34;, group=[&#34;A&#34;, &#34;D&#34;], filename=&#34;mygeomXX&#34;)

    # Step 5: Combine this scriptobject with an existing collection of scriptobjects.
    # Collections enable interactions and complex definitions in simulations.
    collection3 = collection2 + bwater3

    # Step 6: Generate the script for the interactions in the new collection.
    # The `script` attribute provides a formatted script ready for use in simulations.
    collection3.script</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dforcefield.autoname"><code class="name flex">
<span>def <span class="ident">autoname</span></span>(<span>numChars=8)</span>
</code></dt>
<dd>
<div class="desc"><p>generate automatically names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autoname(numChars=8):
    &#34;&#34;&#34; generate automatically names &#34;&#34;&#34;
    return &#39;&#39;.join(random.choices(string.ascii_letters, k=numChars))  # Generates a random name of numChars letters</code></pre>
</details>
</dd>
<dt id="dforcefield.remove_comments"><code class="name flex">
<span>def <span class="ident">remove_comments</span></span>(<span>content, split_lines=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes comments from a single or multi-line string. Handles quotes and escaped characters.</p>
<h2 id="parameters">Parameters:</h2>
<p>content : str
The input string, which may contain multiple lines. Each line will be processed
individually to remove comments, while preserving content inside quotes.
split_lines : bool, optional (default: False)
If True, the function will return a list of processed lines. If False, it will
return a single string with all lines joined by newlines.</p>
<h2 id="returns">Returns:</h2>
<p>str or list of str
The processed content with comments removed. Returns a list of lines if
<code>split_lines</code> is True, or a single string if False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_comments(content, split_lines=False):
    &#34;&#34;&#34;
    Removes comments from a single or multi-line string. Handles quotes and escaped characters.

    Parameters:
    -----------
    content : str
        The input string, which may contain multiple lines. Each line will be processed
        individually to remove comments, while preserving content inside quotes.
    split_lines : bool, optional (default: False)
        If True, the function will return a list of processed lines. If False, it will
        return a single string with all lines joined by newlines.

    Returns:
    --------
    str or list of str
        The processed content with comments removed. Returns a list of lines if
        `split_lines` is True, or a single string if False.
    &#34;&#34;&#34;
    def process_line(line):
        &#34;&#34;&#34;Remove comments from a single line while handling quotes and escapes.&#34;&#34;&#34;
        in_single_quote = False
        in_double_quote = False
        escaped = False
        result = []

        for i, char in enumerate(line):
            if escaped:
                result.append(char)
                escaped = False
                continue

            if char == &#39;\\&#39;:  # Handle escape character
                escaped = True
                result.append(char)
                continue

            # Toggle state for single and double quotes
            if char == &#34;&#39;&#34; and not in_double_quote:
                in_single_quote = not in_single_quote
            elif char == &#39;&#34;&#39; and not in_single_quote:
                in_double_quote = not in_double_quote

            # If we encounter a &#39;#&#39; and we&#39;re not inside quotes, it&#39;s a comment
            if char == &#39;#&#39; and not in_single_quote and not in_double_quote:
                break  # Stop processing the line when a comment is found

            result.append(char)

        return &#39;&#39;.join(result).strip()

    # Split the input content into lines
    lines = content.split(&#39;\n&#39;)

    # Process each line, skipping empty lines and those starting with #
    processed_lines = []
    for line in lines:
        stripped_line = line.strip()
        if not stripped_line or stripped_line.startswith(&#39;#&#39;):
            continue  # Skip empty lines and lines that are pure comments
        processed_line = process_line(line)
        if processed_line:  # Only add non-empty lines
            processed_lines.append(process_line(line))

    if split_lines:
        return processed_lines  # Return list of processed lines
    else:
        return &#39;\n&#39;.join(processed_lines)  # Join lines back into a single string</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dforcefield.USERSMD"><code class="flex name class">
<span>class <span class="ident">USERSMD</span></span>
<span>(</span><span>name=None, type=None, h=0.1, Ma=0.1, vmax=0.1, USER=generic data (gendata object) with 0 items)</span>
</code></dt>
<dd>
<div class="desc"><p>class helper for the module LAMMPS.USERSMD </p>
<p>generic helper constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class USERSMD(generic):
    &#34;&#34;&#34; class helper for the module LAMMPS.USERSMD &#34;&#34;&#34;

    # specific tules (add formula, missing parameters will be provided by GLOBAL or LOCAL)
    RULES = genericdata(
        # list here default forcefield rules (USER can overload these rules)
        c0 = &#34;${vmax}/${Ma}&#34;,
        q1 = &#34;8*${nu}/(${c0}*${h})&#34;,
        Cp = 1.0,
        contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;
        )

    # constructor of USERSMD (note that USER can override all definitions)
    def __init__(self, name=None, type=None, h=0.1, Ma=0.1, vmax=0.1, USER = genericdata()):
        &#34;&#34;&#34; generic helper constructor &#34;&#34;&#34;
        super().__init__()
        self.name = name
        self.type = type
        self.GLOBAL = genericdata(
            # variables which apply to all forcefields
            h = h,
            Ma = Ma,
            vmax = vmax
            ) + USER

    # forcefield derived from pizza.forcefield.water()
    def newtonianfluid(self, beadtype=1, userid = None, rho=1000.0, nu = 1e-6, mu = None, USER = genericdata()):
        &#34;&#34;&#34;
            newtonianfluid() returns a parameterized ULSPH forcefield
            with prescribed viscosity (mu [Pa.s] or nu in [m2/s])
            and density (rho).
            Based on recommendations of J. Comput. Phys 1997, 136, 214â€“226
        &#34;&#34;&#34;
        self.LOCAL = genericdata(
            rho = rho,
            nu = nu, # note that that nu is preferred as it is independent of rho
            mu = mu # dynamic viscosity (dependent on rho)
            ) + USER
        if self.LOCAL.nu is None: self.LOCAL.nu = self.LOCAL.mu / self.LOCAL.rho
        if self.LOCAL.nu is None: raise(ValueError(&#34;bad kinematic viscosity value: nu [m2/s]&#34;))
        if self.LOCAL.mu is None: self.LOCAL.mu = self.LOCAL.nu * self.LOCAL.rho
        if userid == &#34;&#34; or userid is None:
            userid = &#34;newtonianfluid rho=%0.4g [kg/m3] and nu=%0.4g [m2/s]&#34; \
                           % (self.LOCAL.rho,self.LOCAL.nu)
        # this simple line with +
        # manages inheritance (the las definition as always higher precendence)
        # sorts definitions to enable execution (struct.sortdefinitions())
        # (see pizza.forcefield.parameterforcefield())
        CURRENT = self.GLOBAL+self.LOCAL+self.RULES
        return water(beadtype=beadtype, userid=userid, USER=CURRENT)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.generic.generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dforcefield.USERSMD.RULES"><code class="name">var <span class="ident">RULES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dforcefield.USERSMD.newtonianfluid"><code class="name flex">
<span>def <span class="ident">newtonianfluid</span></span>(<span>self, beadtype=1, userid=None, rho=1000.0, nu=1e-06, mu=None, USER=generic data (gendata object) with 0 items)</span>
</code></dt>
<dd>
<div class="desc"><p>newtonianfluid() returns a parameterized ULSPH forcefield
with prescribed viscosity (mu [Pa.s] or nu in [m2/s])
and density (rho).
Based on recommendations of J. Comput. Phys 1997, 136, 214â€“226</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newtonianfluid(self, beadtype=1, userid = None, rho=1000.0, nu = 1e-6, mu = None, USER = genericdata()):
    &#34;&#34;&#34;
        newtonianfluid() returns a parameterized ULSPH forcefield
        with prescribed viscosity (mu [Pa.s] or nu in [m2/s])
        and density (rho).
        Based on recommendations of J. Comput. Phys 1997, 136, 214â€“226
    &#34;&#34;&#34;
    self.LOCAL = genericdata(
        rho = rho,
        nu = nu, # note that that nu is preferred as it is independent of rho
        mu = mu # dynamic viscosity (dependent on rho)
        ) + USER
    if self.LOCAL.nu is None: self.LOCAL.nu = self.LOCAL.mu / self.LOCAL.rho
    if self.LOCAL.nu is None: raise(ValueError(&#34;bad kinematic viscosity value: nu [m2/s]&#34;))
    if self.LOCAL.mu is None: self.LOCAL.mu = self.LOCAL.nu * self.LOCAL.rho
    if userid == &#34;&#34; or userid is None:
        userid = &#34;newtonianfluid rho=%0.4g [kg/m3] and nu=%0.4g [m2/s]&#34; \
                       % (self.LOCAL.rho,self.LOCAL.nu)
    # this simple line with +
    # manages inheritance (the las definition as always higher precendence)
    # sorts definitions to enable execution (struct.sortdefinitions())
    # (see pizza.forcefield.parameterforcefield())
    CURRENT = self.GLOBAL+self.LOCAL+self.RULES
    return water(beadtype=beadtype, userid=userid, USER=CURRENT)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dforcefield.dforcefield"><code class="flex name class">
<span>class <span class="ident">dforcefield</span></span>
<span>(</span><span>base_class=None, beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters, name=None, description=None, version=0.1, additional_modules=None, printflag=False, verbose=False, GLOBAL=None, LOCAL=None, RULES=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> class represents a dynamic extension of a base forcefield class. It allows for dynamic inheritance,
delegation of methods, and flexible management of forcefield-specific attributes. The class supports the customization
and injection of forcefield parameters at runtime, making it highly versatile for scientific simulations involving
various forcefield models like <code>ulsph</code>, <code>tlsph</code>, and others.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li>Dynamic inheritance and delegation of base class methods.</li>
<li>Merging of <code>name</code> and <code>description</code> attributes, with automatic handling of overlapping fields.</li>
<li>Detection of variables used in <code>pair_style</code>, <code>pair_diagcoeff</code>, and <code>pair_offdiagcoeff</code> outputs.</li>
<li>Automatic handling of missing variables, including implicit variable detection and assignment.</li>
<li>Supports additional modules to be dynamically loaded for forcefield definitions.</li>
<li>Management of <code>RULES</code>, <code>GLOBAL</code>, and <code>LOCAL</code> parameters, which can be updated dynamically at runtime.</li>
</ul>
<h2 id="attributes">Attributes:</h2>
<ul>
<li><code>base_class</code> (forcefield): The base class for forcefield behavior, inherited from <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code> subclasses like <code>ulsph</code>.</li>
<li><code>parameters</code> (parameterforcefield): Stores interaction parameters dynamically injected into the base class.</li>
<li><code>beadtype</code> (int): The bead type identifier associated with the forcefield instance.</li>
<li><code>userid</code> (str): A unique identifier for the forcefield instance.</li>
<li><code>name</code> (struct or str): A human-readable name for the forcefield instance, merged with <code>description</code>.</li>
<li><code>description</code> (struct or str): A brief description of the forcefield, merged with <code>name</code>.</li>
<li><code>version</code> (float): Version number for the forcefield instance.</li>
<li><code>RULES</code> (genericdata): Defines specific rules or formulae applied to forcefield calculations.</li>
<li><code>GLOBAL</code> (genericdata): Stores global parameters that apply to the entire forcefield.</li>
<li><code>LOCAL</code> (genericdata): Contains local parameters specific to certain forcefield interactions.</li>
<li><code>USER</code> (scriptdata): Contains USER parameters for scriptobject</li>
<li><code>base_class_name</code> (str): Returns the name of the base_class as a lowercase string</li>
</ul>
<h2 id="methods">Methods:</h2>
<h3 id="high-level-methods">High-Level Methods:</h3>
<p>These methods are primarily used for interacting with the <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance:</p>
<ul>
<li><strong><code>__init__</code></strong>: Initializes the dynamic forcefield with base class, parameters, and custom attributes.</li>
<li><strong><code>pair_style</code></strong>: Delegates the pair style computation to the <code>base_class</code>.</li>
<li><strong><code>pair_diagcoeff</code></strong>: Delegates diagonal pair coefficient computation to the <code>base_class</code>.</li>
<li><strong><code>pair_offdiagcoeff</code></strong>: Delegates off-diagonal pair coefficient computation to the <code>base_class</code>.</li>
<li><strong><code>generator</code></strong>: Generates the forcefield definition as a formatted string without traceability features.</li>
<li><strong><code>save</code></strong>: Saves the forcefield instance to a file, with headers, attributes, and parameters.</li>
<li><strong><code>load</code></strong>: Loads a <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance from a file and validates its format.</li>
<li><strong><code>parsesyntax</code></strong>: Parses content of a forcefield file to create a new <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance.</li>
<li><strong><code>copy</code></strong>: Creates a copy of the current instance, optionally overriding core attributes.</li>
<li><strong><code>compare</code></strong>: Compares the current instance with another <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance, showing differences.</li>
<li><strong><code>missingVariables</code></strong>: Lists undefined variables in <code>parameters</code>.</li>
<li><strong><code>detectVariables</code></strong>: Detects variables in the <code>pair_style</code>, <code>pair_diagcoeff</code>, and <code>pair_offdiagcoeff</code> outputs.</li>
<li><strong><code>to_dict</code></strong>: Serializes the forcefield instance into a dictionary.</li>
<li><strong><code>from_dict</code></strong>: Creates a <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance from a dictionary of attributes.</li>
<li><strong><code>reset</code></strong>: Resets the forcefield instance to its initial state.</li>
<li><strong><code>validate</code></strong>: Validates the forcefield instance to ensure all required attributes are set.</li>
<li><strong><code>base_repr</code></strong>: Returns the representation of the <code>base_class</code>.</li>
<li><strong><code>script</code></strong>: Returns the raw outputs of pair methods as a script.</li>
<li><strong><code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code></strong>: Method to return a <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> based on the current <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance.</li>
</ul>
<h3 id="low-level-methods">Low-Level Methods:</h3>
<p>These methods handle internal logic and lower-level operations:</p>
<ul>
<li><strong><code>_inject_attributes</code></strong>: Injects the dynamic attributes into the <code>base_class</code>.</li>
<li><strong><code>__getattr__</code></strong>: Dynamically accesses attributes in <code>name</code>, <code>description</code>, <code>parameters</code>, or <code>base_class</code>.</li>
<li><strong><code>__setattr__</code></strong>: Manages setting core and dynamic attributes.</li>
<li><strong><code>_load_base_class</code></strong>: Dynamically loads the base class from a string name.</li>
<li><strong><code>list_forcefield_subclasses</code></strong>: Lists all subclasses of <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code> including those from additional modules.</li>
<li><strong><code>extract_default_parameters</code></strong>: Extracts default parameters from the base class or its ancestors.</li>
<li><strong><code>dispmax</code></strong>: Truncates the display of long content for concise output.</li>
<li><strong><code>__hasattr__</code></strong>: Checks if an attribute exists in the instance, parameters, or base class.</li>
<li><strong><code>__contains__</code></strong>: Checks if an attribute exists in the instance or <code>parameters</code>.</li>
<li><strong><code>__len__</code></strong>: Returns the number of parameters in the forcefield.</li>
<li><strong><code>__iter__</code></strong>: Iterates over all keys, including those in <code>name</code>, <code>description</code>, <code>parameters</code>, and scalar attributes.</li>
<li><strong><code>keys</code></strong>: Returns the keys from the merged <code>name</code>, <code>description</code>, and <code>parameters</code>.</li>
<li><strong><code>values</code></strong>: Returns the values from the merged <code>name</code>, <code>description</code>, and <code>parameters</code>.</li>
<li><strong><code>items</code></strong>: Returns an iterator of key-value pairs from <code>name</code>, <code>description</code>, and <code>parameters</code>.</li>
<li><strong><code>merged_name_description</code></strong>: Merges <code>name</code> and <code>description</code> fields into a struct.</li>
<li><strong><code>_get_available_forcefields</code></strong>: Retrieves a list of available forcefield subclasses.</li>
<li><strong><code>__repr__</code></strong>: Custom representation of the <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance.</li>
<li><strong><code>__str__</code></strong>: Returns a string representation of the <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance.</li>
<li><strong><code>_convert_value</code></strong>: Converts a string value to the appropriate Python type.</li>
<li><strong><code>_parse_global_params</code></strong>: Parses global parameters from the content between <code>{}</code>.</li>
<li><strong><code>_parse_struct_block</code></strong>: Parses key-value pairs from <code>description</code> or <code>name</code> blocks.</li>
<li><strong><code>__copy__</code></strong>: Creates a shallow copy of the <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance, copying only the attributes at the top level without duplicating nested objects.</li>
<li><strong><code>__deepcopy__</code></strong>: Creates a deep copy of the <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance, fully duplicating all attributes, including nested objects, while leaving class references intact.</li>
<li><strong><code>get_global</code></strong>: Returns the <code>GLOBAL</code> parameters.</li>
<li><strong><code>get_local</code></strong>: Returns the <code>LOCAL</code> parameters.</li>
<li><strong><code>get_rules</code></strong>: Returns the <code>RULES</code> parameters.</li>
<li><strong><code>set_global</code></strong>: Updates the <code>GLOBAL</code> parameters and recalculates the combined parameters.</li>
<li><strong><code>set_local</code></strong>: Updates the <code>LOCAL</code> parameters and recalculates the combined parameters.</li>
<li><strong><code>set_rules</code></strong>: Updates the <code>RULES</code> parameters and recalculates the combined parameters.</li>
<li><strong><code>combine_parameters</code></strong>: Combines <code>GLOBAL</code>, <code>LOCAL</code>, and <code>RULES</code> into the current parameter configuration.</li>
<li><strong><code>update_parameters</code></strong>: Updates <code>self.parameters</code> after changes to <code>GLOBAL</code>, <code>LOCAL</code>, or <code>RULES</code>.</li>
</ul>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>&gt;&gt;&gt; dynamic_ff = dforcefield(ulsph, beadtype=1, userid="dynamic_water", USER=parameterforcefield(rho=1000))
&gt;&gt;&gt; dynamic_ff.pair_style()  # Uses attributes from the dforcefield instance
lj/cut
&gt;&gt;&gt; dynamic_ff.compare(another_ff_instance, printflag=True)
</code></pre>
<p>Initialize a dynamic forcefield with default or custom values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_class</code></strong> :&ensp;<code>str</code> or <code>class</code></dt>
<dd>The base class to use (e.g., 'ulsph', tlsph, etc.) or the actual class.</dd>
<dt><strong><code>beadtype</code></strong> :&ensp;<code>int</code></dt>
<dd>The bead type identifier. Default is 1.</dd>
<dt><strong><code>userid</code></strong> :&ensp;<code>str</code></dt>
<dd>User ID for the material. Default is None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Human-readable name for the forcefield. Default is None.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code></dt>
<dd>Description of the forcefield. Default is None.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>float</code></dt>
<dd>Version number for the forcefield. Default is 0.1.</dd>
<dt><strong><code>USER</code></strong> :&ensp;<code><a title="dforcefield.parameterforcefield" href="#dforcefield.parameterforcefield">parameterforcefield</a></code></dt>
<dd>Custom parameters to override defaults.</dd>
<dt><strong><code>additional_modules</code></strong> :&ensp;<code>module</code> or <code>list</code> of <code>modules</code></dt>
<dd>Additional modules to search for forcefields.</dd>
<dt><strong><code>GLOBAL</code></strong> :&ensp;<code><a title="dforcefield.parameterforcefield" href="#dforcefield.parameterforcefield">parameterforcefield</a></code></dt>
<dd>Global parameters to be used. Default is None.</dd>
<dt><strong><code>LOCAL</code></strong> :&ensp;<code><a title="dforcefield.parameterforcefield" href="#dforcefield.parameterforcefield">parameterforcefield</a></code></dt>
<dd>Local parameters to be used. Default is None.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Additional parameters passed to the base class.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dforcefield:
    &#34;&#34;&#34;
    The `dforcefield` class represents a dynamic extension of a base forcefield class. It allows for dynamic inheritance,
    delegation of methods, and flexible management of forcefield-specific attributes. The class supports the customization
    and injection of forcefield parameters at runtime, making it highly versatile for scientific simulations involving
    various forcefield models like `ulsph`, `tlsph`, and others.

    Key Features:
    -------------
    - Dynamic inheritance and delegation of base class methods.
    - Merging of `name` and `description` attributes, with automatic handling of overlapping fields.
    - Detection of variables used in `pair_style`, `pair_diagcoeff`, and `pair_offdiagcoeff` outputs.
    - Automatic handling of missing variables, including implicit variable detection and assignment.
    - Supports additional modules to be dynamically loaded for forcefield definitions.
    - Management of `RULES`, `GLOBAL`, and `LOCAL` parameters, which can be updated dynamically at runtime.

    Attributes:
    -----------
    - `base_class` (forcefield): The base class for forcefield behavior, inherited from `forcefield` subclasses like `ulsph`.
    - `parameters` (parameterforcefield): Stores interaction parameters dynamically injected into the base class.
    - `beadtype` (int): The bead type identifier associated with the forcefield instance.
    - `userid` (str): A unique identifier for the forcefield instance.
    - `name` (struct or str): A human-readable name for the forcefield instance, merged with `description`.
    - `description` (struct or str): A brief description of the forcefield, merged with `name`.
    - `version` (float): Version number for the forcefield instance.
    - `RULES` (genericdata): Defines specific rules or formulae applied to forcefield calculations.
    - `GLOBAL` (genericdata): Stores global parameters that apply to the entire forcefield.
    - `LOCAL` (genericdata): Contains local parameters specific to certain forcefield interactions.
    - `USER` (scriptdata): Contains USER parameters for scriptobject
    - `base_class_name` (str): Returns the name of the base_class as a lowercase string

    Methods:
    --------
    ### High-Level Methods:
    These methods are primarily used for interacting with the `dforcefield` instance:

    - **`__init__`**: Initializes the dynamic forcefield with base class, parameters, and custom attributes.
    - **`pair_style`**: Delegates the pair style computation to the `base_class`.
    - **`pair_diagcoeff`**: Delegates diagonal pair coefficient computation to the `base_class`.
    - **`pair_offdiagcoeff`**: Delegates off-diagonal pair coefficient computation to the `base_class`.
    - **`generator`**: Generates the forcefield definition as a formatted string without traceability features.
    - **`save`**: Saves the forcefield instance to a file, with headers, attributes, and parameters.
    - **`load`**: Loads a `dforcefield` instance from a file and validates its format.
    - **`parsesyntax`**: Parses content of a forcefield file to create a new `dforcefield` instance.
    - **`copy`**: Creates a copy of the current instance, optionally overriding core attributes.
    - **`compare`**: Compares the current instance with another `dforcefield` instance, showing differences.
    - **`missingVariables`**: Lists undefined variables in `parameters`.
    - **`detectVariables`**: Detects variables in the `pair_style`, `pair_diagcoeff`, and `pair_offdiagcoeff` outputs.
    - **`to_dict`**: Serializes the forcefield instance into a dictionary.
    - **`from_dict`**: Creates a `dforcefield` instance from a dictionary of attributes.
    - **`reset`**: Resets the forcefield instance to its initial state.
    - **`validate`**: Validates the forcefield instance to ensure all required attributes are set.
    - **`base_repr`**: Returns the representation of the `base_class`.
    - **`script`**: Returns the raw outputs of pair methods as a script.
    - **`scriptobject`**: Method to return a `scriptobject` based on the current `dforcefield` instance.

    ### Low-Level Methods:
    These methods handle internal logic and lower-level operations:

    - **`_inject_attributes`**: Injects the dynamic attributes into the `base_class`.
    - **`__getattr__`**: Dynamically accesses attributes in `name`, `description`, `parameters`, or `base_class`.
    - **`__setattr__`**: Manages setting core and dynamic attributes.
    - **`_load_base_class`**: Dynamically loads the base class from a string name.
    - **`list_forcefield_subclasses`**: Lists all subclasses of `forcefield` including those from additional modules.
    - **`extract_default_parameters`**: Extracts default parameters from the base class or its ancestors.
    - **`dispmax`**: Truncates the display of long content for concise output.
    - **`__hasattr__`**: Checks if an attribute exists in the instance, parameters, or base class.
    - **`__contains__`**: Checks if an attribute exists in the instance or `parameters`.
    - **`__len__`**: Returns the number of parameters in the forcefield.
    - **`__iter__`**: Iterates over all keys, including those in `name`, `description`, `parameters`, and scalar attributes.
    - **`keys`**: Returns the keys from the merged `name`, `description`, and `parameters`.
    - **`values`**: Returns the values from the merged `name`, `description`, and `parameters`.
    - **`items`**: Returns an iterator of key-value pairs from `name`, `description`, and `parameters`.
    - **`merged_name_description`**: Merges `name` and `description` fields into a struct.
    - **`_get_available_forcefields`**: Retrieves a list of available forcefield subclasses.
    - **`__repr__`**: Custom representation of the `dforcefield` instance.
    - **`__str__`**: Returns a string representation of the `dforcefield` instance.
    - **`_convert_value`**: Converts a string value to the appropriate Python type.
    - **`_parse_global_params`**: Parses global parameters from the content between `{}`.
    - **`_parse_struct_block`**: Parses key-value pairs from `description` or `name` blocks.
    - **`__copy__`**: Creates a shallow copy of the `dforcefield` instance, copying only the attributes at the top level without duplicating nested objects.
    - **`__deepcopy__`**: Creates a deep copy of the `dforcefield` instance, fully duplicating all attributes, including nested objects, while leaving class references intact.
    - **`get_global`**: Returns the `GLOBAL` parameters.
    - **`get_local`**: Returns the `LOCAL` parameters.
    - **`get_rules`**: Returns the `RULES` parameters.
    - **`set_global`**: Updates the `GLOBAL` parameters and recalculates the combined parameters.
    - **`set_local`**: Updates the `LOCAL` parameters and recalculates the combined parameters.
    - **`set_rules`**: Updates the `RULES` parameters and recalculates the combined parameters.
    - **`combine_parameters`**: Combines `GLOBAL`, `LOCAL`, and `RULES` into the current parameter configuration.
    - **`update_parameters`**: Updates `self.parameters` after changes to `GLOBAL`, `LOCAL`, or `RULES`.

    Example Usage:
    --------------
        &gt;&gt;&gt; dynamic_ff = dforcefield(ulsph, beadtype=1, userid=&#34;dynamic_water&#34;, USER=parameterforcefield(rho=1000))
        &gt;&gt;&gt; dynamic_ff.pair_style()  # Uses attributes from the dforcefield instance
        lj/cut
        &gt;&gt;&gt; dynamic_ff.compare(another_ff_instance, printflag=True)
    &#34;&#34;&#34;


    # Display
    _maxdisplay = 40
    # Class attribute for the six specific attributes + 3 generic attributes + USER set by scriptobject
    _dforcefield_specific_attributes = {&#39;name&#39;, &#39;description&#39;, &#39;beadtype&#39;, &#39;userid&#39;, &#39;version&#39;, &#39;parameters&#39;,&#39;RULES&#39;,&#39;GLOBAL&#39;,&#39;LOCAL&#39;,&#39;USER&#39;}
    # Class attribute: construction flag is True by default for all instances
    _in_construction = True
    RULES = parameterforcefield()  # Default empty RULES at the class level

    def __init__(self, base_class=None, beadtype=1, userid=None, USER=parameterforcefield(),
                 name=None, description=None, version=0.1, additional_modules=None,
                 printflag=False, verbose=False,
                 GLOBAL=None, LOCAL=None, RULES=None, **kwargs):
        &#34;&#34;&#34;
        Initialize a dynamic forcefield with default or custom values.

        Args:
            base_class (str or class): The base class to use (e.g., &#39;ulsph&#39;, tlsph, etc.) or the actual class.
            beadtype (int): The bead type identifier. Default is 1.
            userid (str): User ID for the material. Default is None.
            name (str): Human-readable name for the forcefield. Default is None.
            description (str): Description of the forcefield. Default is None.
            version (float): Version number for the forcefield. Default is 0.1.
            USER (parameterforcefield): Custom parameters to override defaults.
            additional_modules (module or list of modules): Additional modules to search for forcefields.
            GLOBAL (parameterforcefield): Global parameters to be used. Default is None.
            LOCAL (parameterforcefield): Local parameters to be used. Default is None.
            kwargs: Additional parameters passed to the base class.
        &#34;&#34;&#34;

        # Initialize GLOBAL and LOCAL containers
        self.GLOBAL = GLOBAL if GLOBAL else genericdata()
        self.LOCAL = LOCAL if LOCAL else genericdata()
        if RULES is None:
            self.RULES = genericdata()  # Initialize RULES, to be populated later if applicable
        else:
            self.RULES = RULES # side effect are expected if the user supply non compatible data (2025-01-02)

        # Initialize USER containter (which is used by scriptobject)
        self.USER = scriptdata()

        #â€¢ Initialize print/verbose behavior
        self.printflag = printflag
        self.verbose = verbose

        # Step 1a: Handle base_class, either a string or a class reference
        print(f&#34;\nInitializing dforcefield with base_class: {base_class}&#34;)

        # Handle base_class loading (using additional_modules if needed)
        if isinstance(base_class, str):
            # Get available forcefields and short names mapping
            available_forcefields, short_name_mapping = self.list_forcefield_subclasses(
                printflag=False,
                additional_modules=additional_modules
            )
            # Check if the provided base_class name matches either the full or short name
            if base_class not in available_forcefields and base_class not in short_name_mapping:
                available_classes = &#34;, &#34;.join(short_name_mapping.keys())
                raise ValueError(
                    f&#34;Invalid base_class: &#39;{base_class}&#39;. Must be one of the available forcefields: {available_classes}&#34;
            )
            # Use the full name from the short name if necessary
            # if base_class in short_name_mapping:
            #     base_class = short_name_mapping[base_class]

            # Load the base class or method
            base_class = dforcefield._load_base_class(base_class, additional_modules=additional_modules)

        # Ensure the base_class is valid
        if not (inspect.isclass(base_class) and issubclass(base_class, forcefield)) and not (
            callable(base_class) and hasattr(base_class, &#39;__qualname__&#39;) and
            base_class.__qualname__.split(&#39;.&#39;)[0] in {cls.__name__ for cls in generic.__subclasses__()}
        ):
            raise ValueError(
                f&#34;Invalid base_class: {base_class}. It must be a valid subclass of &#39;forcefield&#39; or a callable forcefield method &#34;
                f&#34;from a &#39;generic&#39; subclass.&#34;
        )

        # Step 1b: Initialize the base_class
        # If base_class is callable (like a method), call it to get an instance; otherwise, instantiate directly
        if callable(base_class):
            # Check if the base_class is a method of a generic subclass
            qualname = base_class.__qualname__.split(&#39;.&#39;)
            parent_class_name = qualname[0] if len(qualname) &gt; 1 else None
            parent_class = next((cls for cls in generic.__subclasses__() if cls.__name__ == parent_class_name), None)

            if parent_class:
                # Instantiate the parent class and call the method on it
                parent_instance = parent_class()  # Create an instance of the parent class (e.g., USERSMD)
                self.base_class = base_class(parent_instance)  # Call the method with the instance context
            else:
                # Call the method directly if no parent class context is needed
                self.base_class = base_class()
        else:
            self.base_class = base_class()  # Instantiate the class if it&#39;s not a method

        # Ensure the base_class is valid and handle classes and methods separately
        if inspect.isclass(base_class):
            # Step 2a: Extract default parameters from the base class
            extracted_info = self.extract_default_parameters(base_class, displayflag=True)
        elif callable(base_class) and hasattr(base_class, &#39;__qualname__&#39;):
            # If base_class is a method, extract the parent class name
            parent_class_name = base_class.__qualname__.split(&#39;.&#39;)[0]
            parent_class = next(
                (cls for cls in generic.__subclasses__() if cls.__name__ == parent_class_name), None
            )
            if parent_class is None:
                raise ValueError(f&#34;Unable to find parent class &#39;{parent_class_name}&#39; for method &#39;{base_class.__name__}&#39;.&#34;)

            # Step 2b: Extract default parameters from the method within its parent class
            extracted_info = self.extract_default_parameters(parent_class, method_name=base_class.__name__, displayflag=True)
        else:
            raise ValueError(
                f&#34;Invalid base_class: {base_class}. It must be a valid subclass of &#39;forcefield&#39; or a callable forcefield method.&#34;
            )

        # Populate RULES, GLOBAL, and LOCAL if extracted
        self.RULES = extracted_info.get(&#34;RULES&#34;, genericdata())
        self.GLOBAL = extracted_info.get(&#34;GLOBAL&#34;, genericdata()) + self.GLOBAL
        self.LOCAL = extracted_info.get(&#34;LOCAL&#34;, genericdata()) + self.LOCAL

        # Step 3: Initialize the base_class
        #self.base_class = base_class()  # Instantiate the base_class if it&#39;s callable

        # Step 4: Initialize name and description
        default_name = self.base_class.name  # Access base_class.name after ensuring it&#39;s properly set

        # Handling &#39;name&#39;
        if name:
            if isinstance(name, str):
                name = default_name + struct(material=name)
            elif isinstance(name, struct):
                name = default_name + name
            else:
                raise TypeError(f&#34;name must be of type str or struct, not {type(name)}&#34;)
        else:
            name = default_name + struct(material=self.__class__.__name__.lower())

        self.name = name

        # Handling &#39;description&#39;
        default_description = self.base_class.description
        if description:
            if isinstance(description, str):
                description = default_description + struct(material=description)
            elif isinstance(description, struct):
                description = default_description + description
            else:
                raise TypeError(f&#34;description must be of type parameterforcefield, not {type(description)}&#34;)
        else:
            description = default_description + struct(material=f&#34;{self.__class__.__name__.lower()} beads - SPH-like&#34;)

        self.description = description

        # Step 5: Other properties and parameters
        self.userid = userid if userid else self.__class__.__name__.lower()
        self.version = version
        self.beadtype = beadtype

        # Ensure USER is of the correct type
        if not isinstance(USER, parameterforcefield):
            raise TypeError(f&#34;USER must be of type parameterforcefield, not {type(USER)}&#34;)

        # Merge USER and kwargs into parameters
        # If no default parameters, proceed with user parameters
        if extracted_info[&#34;parameters&#34;] is None:
            self.parameters = self.GLOBAL + self.LOCAL + self.RULES + USER + parameterforcefield(**kwargs)
        else:
            self.parameters = extracted_info[&#34;parameters&#34;] + self.GLOBAL + self.LOCAL + self.RULES + USER + parameterforcefield(**kwargs)
        # After merging parameters, ensure USER is not part of it
        # if &#39;USER&#39; in self.parameters:
        #     del self.parameters[&#39;USER&#39;]

        # End of construction
        self._in_construction = False

        # Inject dforcefield attributes into the base class
        self._inject_attributes()


    # New methods to access GLOBAL, LOCAL, and RULES

    def get_global(self):
        &#34;&#34;&#34;Return the GLOBAL parameters for this dforcefield instance.&#34;&#34;&#34;
        return self.GLOBAL

    def get_local(self):
        &#34;&#34;&#34;Return the LOCAL parameters for this dforcefield instance.&#34;&#34;&#34;
        return self.LOCAL

    def get_rules(self):
        &#34;&#34;&#34;Return the RULES parameters for this dforcefield instance.&#34;&#34;&#34;
        return self.RULES

    # Method to combine GLOBAL, LOCAL, and RULES
    def combine_parameters(self):
        &#34;&#34;&#34;
        Combine GLOBAL, LOCAL, and RULES to get the current parameter configuration.
        &#34;&#34;&#34;
        return self.GLOBAL + self.LOCAL + self.RULES


    def update_parameters(self):
        &#34;&#34;&#34;
        Update self.parameters by combining GLOBAL, LOCAL, RULES, and USER parameters.
        &#34;&#34;&#34;
        self.parameters = self.parameters + self.combine_parameters()
        self._inject_attributes()


    def set_local(self, new_local=None, **kwargs):
        &#34;&#34;&#34;
        Update the LOCAL parameters and adjust the combined parameters accordingly.

        Args:
        -----
        new_local : parameterforcefield, optional
            The new LOCAL parameters to set. If None, only the parameters in kwargs are modified.
        kwargs : dict, optional
            Keyword arguments representing individual parameters to add or modify in LOCAL.
        &#34;&#34;&#34;
        if new_local is not None and not isinstance(new_local, parameterforcefield):
            raise TypeError(f&#34;LOCAL must be of type parameterforcefield, not {type(new_local)}.&#34;)

        # Combine current LOCAL, new_local, and additional parameters in kwargs
        self.LOCAL = (self.LOCAL + (new_local or genericdata()) + genericdata(**kwargs))
        self.update_parameters()

    def set_global(self, new_global=None, **kwargs):
        &#34;&#34;&#34;
        Update the GLOBAL parameters and adjust the combined parameters accordingly.

        Args:
        -----
        new_global : parameterforcefield, optional
            The new GLOBAL parameters to set. If None, only the parameters in kwargs are modified.
        kwargs : dict, optional
            Keyword arguments representing individual parameters to add or modify in GLOBAL.
        &#34;&#34;&#34;
        if new_global is not None and not isinstance(new_global, parameterforcefield):
            raise TypeError(f&#34;GLOBAL must be of type parameterforcefield, not {type(new_global)}.&#34;)

        # Combine current GLOBAL, new_global, and additional parameters in kwargs
        self.GLOBAL = (self.GLOBAL + (new_global or genericdata()) + genericdata(**kwargs))
        self.update_parameters()

    def set_rules(self, new_rules=None, **kwargs):
        &#34;&#34;&#34;
        Update the RULES parameters and adjust the combined parameters accordingly.

        Args:
        -----
        new_rules : parameterforcefield, optional
            The new RULES parameters to set. If None, only the parameters in kwargs are modified.
        kwargs : dict, optional
            Keyword arguments representing individual parameters to add or modify in RULES.
        &#34;&#34;&#34;
        if new_rules is not None and not isinstance(new_rules, parameterforcefield):
            raise TypeError(f&#34;RULES must be of type parameterforcefield, not {type(new_rules)}.&#34;)

        # Combine current RULES, new_rules, and additional parameters in kwargs
        self.RULES = (self.RULES + (new_rules or genericdata()) + genericdata(**kwargs))
        self.update_parameters()


    @classmethod
    def _load_base_class(cls, base_class_name, additional_modules=None):
        &#34;&#34;&#34;
        Dynamically load the base class by its string name from the available forcefield subclasses
        or additional modules.

        Args:
            base_class_name (str): The name of the forcefield class or method to load.
            additional_modules (list): Optional list of additional modules to search for the base class.

        Returns:
            class or function: The base class or function if found.
        &#34;&#34;&#34;
        # Retrieve subclass information and short name mappings
        subclasses_info, short_name_mapping = cls.list_forcefield_subclasses(
            printflag=False, additional_modules=additional_modules
            )
        print(f&#34;Trying to load base_class: {base_class_name}&#34;)

        # Directly look for the exact name in the subclasses_info
        if base_class_name in subclasses_info:
            info = subclasses_info[base_class_name]
            if not info[&#39;loaded&#39;]:
                module_name = info[&#39;module&#39;]
                try:
                    print(f&#34;Attempting to import module &#39;{module_name}&#39; and load &#39;{base_class_name}&#39;&#34;)
                    module = __import__(module_name, fromlist=[base_class_name])
                    target = getattr(module, base_class_name)

                    # Check if the target is a class or method
                    if inspect.isclass(target) and issubclass(target, forcefield):
                        return target
                    elif inspect.isfunction(target):
                        return target
                    else:
                        raise ValueError(f&#34;Loaded target &#39;{base_class_name}&#39; is not a suitable forcefield class or method.&#34;)
                except (ImportError, AttributeError) as e:
                    available_classes = cls._get_available_forcefields()
                    raise ImportError(f&#34;Failed to load the target &#39;{base_class_name}&#39; from module &#39;{module_name}&#39;. &#34;
                                      f&#34;Available forcefields: {available_classes}&#34;) from e

            # If already loaded, return the class directly
            return sys.modules[info[&#39;module&#39;]].__dict__.get(base_class_name)

        # If not found directly, check for nested methods within classes
        for key, info in subclasses_info.items():
            # Check if base_class_name is a method of a class
            if &#39;.&#39; in key and key.split(&#39;.&#39;)[-1] == base_class_name:
                parent_class_name = key.split(&#39;.&#39;)[0]
                if parent_class_name in subclasses_info:
                    # Load the parent class if it hasn&#39;t been loaded yet
                    parent_class_info = subclasses_info[parent_class_name]
                    if not parent_class_info[&#39;loaded&#39;]:
                        parent_class = cls._load_base_class(parent_class_name, additional_modules=additional_modules)
                    else:
                        # Directly access the parent class from the loaded module
                        module = sys.modules[parent_class_info[&#39;module&#39;]]
                        parent_class = getattr(module, parent_class_name)

                    # Get the method from the loaded parent class
                    method = getattr(parent_class, base_class_name, None)
                    if method and callable(method):
                        return method
                    else:
                        raise ValueError(f&#34;Method &#39;{base_class_name}&#39; was not found in the parent class &#39;{parent_class_name}&#39; or is not callable.&#34;)

        # If the target is a direct class but not a method or nested class, throw an appropriate error
        raise ValueError(f&#34;Target &#39;{base_class_name}&#39; is not a recognized class or method. &#34;
                         f&#34;Available entries: {cls._get_available_forcefields()}&#34;)


    @classmethod
    def _get_available_forcefields(cls):
        &#34;&#34;&#34;
        Retrieve the list of available forcefield subclasses.

        Returns:
            list: A list of available forcefield subclass names.
        &#34;&#34;&#34;
        subclasses_info = cls.list_forcefield_subclasses(printflag=False)
        return list(subclasses_info.keys())


    @classmethod
    def extract_default_parameters(cls, base_class, method_name=None, displayflag=True):
        &#34;&#34;&#34;
        Extract default parameters from the base class or its method by instantiating the class.

        If the base class is derived from `generic`, this function will also extract RULES, LOCAL,
        and GLOBAL attributes if they are defined once the instance is created.

        Parameters:
        -----------
        base_class : class
            The base class from which to extract default parameterforcefield values or a method.
        method_name : str, optional
            The name of the method to call on the instance, if applicable (e.g., `newtonianfluid`).
        displayflag : bool, optional (default=True)
            If True, prints a message when no default parameters are found.

        Returns:
        --------
        dict
            A dictionary containing the default parameters extracted from the base class or method.
            Also includes RULES, LOCAL, and GLOBAL if applicable.
        &#34;&#34;&#34;
        extracted_info = {
            &#34;parameters&#34;: parameterforcefield(),
            &#34;RULES&#34;: genericdata(),
            &#34;GLOBAL&#34;: genericdata(),
            &#34;LOCAL&#34;: genericdata()
        }

        try:
            # Create an instance of the base class
            instance = base_class()

            # Extract parameters if the instance has them
            if hasattr(instance, &#39;parameters&#39;) and isinstance(instance.parameters, parameterforcefield):
                extracted_info[&#34;parameters&#34;] = instance.parameters

            # Extract RULES, GLOBAL, and LOCAL if they exist
            for attr in [&#34;RULES&#34;, &#34;GLOBAL&#34;, &#34;LOCAL&#34;]:
                if hasattr(instance, attr) and isinstance(getattr(instance, attr), parameterforcefield):
                    extracted_info[attr] = getattr(instance, attr)

            # If a method is specified, call it to get additional parameters
            if method_name and hasattr(instance, method_name):
                method = getattr(instance, method_name)
                if callable(method):
                    try:
                        result = method()  # Call the method (ensure it returns the desired forcefield object)
                        if hasattr(result, &#39;parameters&#39;) and isinstance(result.parameters, parameterforcefield):
                            extracted_info[&#34;parameters&#34;] = result.parameters
                    except Exception as e:
                        if displayflag:
                            print(f&#34;Error calling method {method_name} on {base_class.__name__}: {str(e)}&#34;)

        except TypeError as e:
            if displayflag:
                print(f&#34;Could not instantiate {base_class.__name__}: {str(e)}&#34;)

        # If no parameters found or cannot instantiate the class, return None
        if displayflag and not extracted_info[&#34;parameters&#34;]:
            print(f&#34;No default parameters found in {base_class.__name__} or its ancestors.&#34;)

        return extracted_info


    def _inject_attributes(self):
        &#34;&#34;&#34;Inject dforcefield attributes into the base class, bypassing __setattr__.&#34;&#34;&#34;
        if not self._in_construction:  # Prevent injection during construction
            # Check if base_class is a class (not a method)
            if inspect.isclass(self.base_class):
                self.base_class.__dict__.update({
                    &#39;name&#39;: self.name,
                    &#39;description&#39;: self.description,
                    &#39;beadtype&#39;: self.beadtype,
                    &#39;userid&#39;: self.userid,
                    &#39;version&#39;: self.version,
                    &#39;parameters&#39;: self.parameters
                })
            else:
                # For methods, set attributes on the instance itself, as methods can&#39;t have attributes directly
                # Methods are often accessed from an instance, so we update the instance&#39;s attributes instead
                self.base_class.name = self.name
                self.base_class.description = self.description
                self.base_class.beadtype = self.beadtype
                self.base_class.userid = self.userid
                self.base_class.version = self.version
                self.base_class.parameters = self.parameters


    def __getattr__(self, attr):
        &#34;&#34;&#34;
        Shorthand for accessing parameters, base class attributes, or attributes in &#39;name&#39; and &#39;description&#39;.
        If an attribute exists in both &#39;name&#39; and &#39;description&#39;, their contents are combined with a newline.
        &#34;&#34;&#34;
        # Check if the attribute exists in the instance&#39;s __dict__
        if attr in self.__dict__:
            return self.__dict__[attr]
        # Check if the attribute exists in &#39;name&#39; and &#39;description&#39;
        name_attr = getattr(self.name, attr, None) if isinstance(self.name, struct) else None
        description_attr = getattr(self.description, attr, None) if isinstance(self.description, struct) else None
        # If the attribute exists in both &#39;name&#39; and &#39;description&#39;, combine them with a newline
        if name_attr and description_attr:
            return [name_attr, description_attr]
        # If the attribute exists in &#39;name&#39; only
        if name_attr:
            return name_attr
        # If the attribute exists in &#39;description&#39; only
        if description_attr:
            return description_attr
        # Check if the attribute exists in &#39;parameters&#39;
        if hasattr(self.parameters, attr):
            return getattr(self.parameters, attr)
        # Check if the attribute exists in the &#39;base_class&#39;
        if hasattr(self.base_class, attr):
            return getattr(self.base_class, attr)
        # Raise an AttributeError if the attribute is not found
        raise AttributeError(f&#34;&#39;{self.__class__.__name__}&#39; object has no attribute &#39;{attr}&#39;&#34;)



    def __setattr__(self, attr, value):
        &#34;&#34;&#34;
        Shorthand for setting attributes. Attributes specific to dforcefield are handled separately.
        New attributes are added to parameters if they are not part of the dforcefield-specific attributes.
        &#34;&#34;&#34;
        # Handle internal attributes like _in_construction directly in the instance
        # and Check if the attribute is part of the dforcefield-specific attributes
        if hasattr(self.__class__, attr) or attr in self._dforcefield_specific_attributes:
            if attr==&#34;parameters&#34;:
                if not isinstance(value,parameterforcefield):
                    raise TypeError(&#34;parameters must be of type parameterforcefield, not of type {}&#34;.format(type(value)))
                self.__dict__[attr] = self.detectVariables() + value # check that all variables are defined
            else:
                self.__dict__[attr] = value
            if not self._in_construction and attr in self._dforcefield_specific_attributes:
                self._inject_attributes()
        # Handle dynamic setting of attributes in parameters
        elif &#39;parameters&#39; in self.__dict__:
            # Update parameters (existing or new attributes)
            setattr(self.parameters, attr, value)

            # Ensure injection occurs when parameters is updated
            if not self._in_construction:
                self._inject_attributes()
        else:
            # Fallback to default behavior if the attribute isn&#39;t part of parameters or specific attributes
            super().__setattr__(attr, value)


    def __hasattr__(self, attr):
        &#34;&#34;&#34;Check if an attribute exists in the dforcefield instance, class, parameters, or the base class.&#34;&#34;&#34;
        # Check for instance attribute
        if attr in self.__dict__:
            return True
        # Check for class attribute
        if hasattr(self.__class__, attr):
            return True
        # Check for parameters
        if attr in self.parameters.keys():
            return True
        # Check for attribute in base class
        if hasattr(self.base_class, attr):
            return True
        return False


    def __contains__(self, item):
        &#34;&#34;&#34;Check if an attribute exists in the dforcefield instance or its parameters.&#34;&#34;&#34;
        return item in self.keys()


    def __len__(self):
        &#34;&#34;&#34;
        Return the number of parameters in the forcefield.
        This will use the len method of parameters.
        &#34;&#34;&#34;
        return len(self.keys())


    @property
    def merged_name_description(self):
        &#34;&#34;&#34;
        Return a struct containing the merged content of &#39;name&#39; and &#39;description&#39;.
        If an attribute exists in both, their values are combined into a list.
        &#34;&#34;&#34;
        merged_data = {}

        # Add attributes from &#39;name&#39; if it&#39;s a struct
        if isinstance(self.name, struct):
            merged_data.update(self.name.__dict__)

        # Add/merge attributes from &#39;description&#39; if it&#39;s a struct
        if isinstance(self.description, struct):
            for key, value in self.description.__dict__.items():
                if key in merged_data:
                    # Combine the values into a list if the key already exists
                    existing_value = merged_data[key]
                    if not isinstance(existing_value, list):
                        existing_value = [existing_value]  # Convert to list if not already a list
                    merged_data[key] = existing_value + [value]  # Add the new value to the list
                else:
                    merged_data[key] = value

        # Return the merged struct
        return struct(**merged_data)



    def keys(self):
        &#34;&#34;&#34;
        Return the keys of the merged struct, parameters, and scalar attributes.
        &#34;&#34;&#34;
        keys_set = set(self.merged_name_description.__dict__.keys())
        keys_set.update(self.parameters.keys())
        keys_set.update([&#39;version&#39;, &#39;userid&#39;, &#39;beadtype&#39;])
        return list(keys_set)

    def values(self):
        &#34;&#34;&#34;
        Return the values of the merged struct, parameters, and scalar attributes.
        &#34;&#34;&#34;
        values_list = list(self.merged_name_description.__dict__.values())
        values_list.extend(self.parameters.values())
        values_list.extend([self.version, self.userid, self.beadtype])
        return values_list

    def items(self):
        &#34;&#34;&#34;
        Return an iterator over (key, value) pairs from the merged struct, parameters, and scalar attributes.
        &#34;&#34;&#34;
        # Yield items from merged struct
        for item in self.merged_name_description.__dict__.items():
            yield item

        # Yield items from parameters
        for item in self.parameters.items():
            yield item

        # Yield scalar attribute items
        yield (&#39;version&#39;, self.version)
        yield (&#39;userid&#39;, self.userid)
        yield (&#39;beadtype&#39;, self.beadtype)

    def __iter__(self):
        &#34;&#34;&#34;
        Iterate over all keys, including those in the merged struct, parameters, and scalar attributes.
        &#34;&#34;&#34;
        for key in self.merged_name_description.__dict__:
            yield key
        for key in self.parameters:
            yield key
        yield &#39;version&#39;
        yield &#39;userid&#39;
        yield &#39;beadtype&#39;


    def __repr__(self):
        &#34;&#34;&#34;
        Custom __repr__ method that provides a detailed representation of the dforcefield instance,
        excluding attributes that start with an underscore (_).
        &#34;&#34;&#34;
        base_class_name = self.base_class.__class__.__name__ if self.base_class else &#34;None&#34;
        sep = &#34;  &#34; + &#34;-&#34; * 20 + &#34;:&#34; + &#34;-&#34; * 30

        # Start building the representation string
        repr_str = f&#39;forcefield &#34;{self.userid}&#34; derived from &#34;{base_class_name}&#34;\n\n&#39;

        # [BEADTYPE] Section
        repr_str += f&#34;{sep}[ BEADTYPE ]\n&#34;
        repr_str += f&#34;  {&#39;beadtype&#39;:&lt;20}: {self.beadtype}\n\n&#34;

        # [FF CLASS (read only)] Section
        repr_str += f&#34;{sep}[ FF CLASS (read only) ]\n&#34;
        # Iterate over attributes in merged_name_description, exclude those starting with &#39;_&#39;
        for key, value in self.merged_name_description.items():
            if key.startswith(&#39;_&#39;):
                continue  # Skip private attributes

            # Handle list values (multiple entries for the same key)
            if isinstance(value, list):
                for idx, val in enumerate(value):
                    value_lines = self.dispmax(val).splitlines()
                    if idx == 0:
                        repr_str += f&#34;  {key:&lt;20}: {value_lines[0]}\n&#34;
                    else:
                        repr_str += f&#34;  {&#39;&#39;:&lt;20}  {value_lines[0]}\n&#34;
                    for line in value_lines[1:]:
                        repr_str += f&#34;  {&#39;&#39;:&lt;20}  {line}\n&#34;
            else:
                value_lines = self.dispmax(value).splitlines()
                repr_str += f&#34;  {key:&lt;20}: {value_lines[0]}\n&#34;
                for line in value_lines[1:]:
                    repr_str += f&#34;  {&#39;&#39;:&lt;20}  {line}\n&#34;

        repr_str += &#34;\n&#34;

        # [PARAMS] Section
        repr_str += f&#34;{sep}[ PARAMS ]\n&#34;
        missing = 0

        for key, value in self.parameters.items():
            # Skip private parameters
            if key.startswith(&#39;_&#39;):
                continue

            repr_str += f&#34;  {key:&lt;20}: {value}\n&#34;

            # If the value is an expression, evaluate and display the result
            if isinstance(value, str) and &#34;${&#34; in value and &#34;}&#34; in value:
                try:
                    # Replace placeholders with actual parameter values
                    expr = value
                    for param_key, param_val in self.parameters.items():
                        expr = expr.replace(f&#34;${{{param_key}}}&#34;, str(param_val))
                    # Evaluate the expression safely
                    evaluated = eval(expr, {&#34;__builtins__&#34;: {}}, {})
                    repr_str += f&#34;                        = {evaluated}\n&#34;
                except Exception:
                    # If evaluation fails, skip displaying the result
                    pass

        # Count missing definitions (assuming missing parameters are marked somehow)
        # For demonstration, we&#39;ll assume &#39;missing&#39; is already correctly set
        total_definitions = len(self.parameters)
        repr_str += f&#34;\n{sep} &gt;&gt; {total_definitions} definitions ({missing} missing)\n&#34;
        print(repr_str)
        return self.__str__()


    def base_repr(self):
        &#34;&#34;&#34;Returns the representation of the base_class.&#34;&#34;&#34;
        self.base_class.__repr__()
        return self.base_class.__str__()

    @property
    def script(self):
        &#34;&#34;&#34;
        Return the raw content of the pair_* outputs combined into a single script-like format.

        Returns:
        --------
        str
            The raw outputs from pair_style, pair_diagcoeff, and pair_offdiagcoeff concatenated into a script.
        &#34;&#34;&#34;
        # Get the raw outputs from the pair_* methods
        pair_style_output = self.pair_style(printflag=False, raw=True)
        pair_diagcoeff_output = self.pair_diagcoeff(printflag=False, raw=True)
        pair_offdiagcoeff_output = self.pair_offdiagcoeff(printflag=False, raw=True)

        # Combine the outputs into a script-like format
        script_content = &#34;\n&#34;.join([
            &#34;# Script output from dforcefield:&#34;,
            &#34;# Pair style:&#34;,
            pair_style_output,
            &#34;\n# Diagonal coefficients:&#34;,
            pair_diagcoeff_output,
            &#34;\n# Off-diagonal coefficients:&#34;,
            pair_offdiagcoeff_output
        ])

        return script_content

    def __str__(self):
        base_class_name = self.base_class.__class__.__name__ if self.base_class else &#34;None&#34;
        return f&#34;&lt;dforcefield instance with base class: {base_class_name}, userid: {self.userid}, beadtype: {self.beadtype}&gt;&#34;

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def show(self):
        &#34;&#34;&#34;Show the corresponding base_class forcefield definition &#34;&#34;&#34;
        self.base_class.__repr__()
        return self.base_class.__str__()

    def pair_style(self, printflag=None, verbose=None, raw=False):
        &#34;&#34;&#34;Delegate pair_style to the base class, ensuring it uses the correct attributes.&#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        self._inject_attributes()
        return self.base_class.pair_style(printflag=printflag, verbose=verbose, raw=raw,USER=None, beadtype=self.beadtype, userid=self.userid)


    def pair_diagcoeff(self, printflag=None, verbose=None, i=None, raw=False):
        &#34;&#34;&#34;Delegate pair_diagcoeff to the base class, ensuring it uses the correct attributes.&#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        self._inject_attributes()
        return self.base_class.pair_diagcoeff(printflag=printflag, verbose=verbose, i=i, raw=raw, USER=None, beadtype=self.beadtype, userid=self.userid)


    def pair_offdiagcoeff(self, o=None, printflag=None, verbose=None, i=None, raw=False,oname=None):
        &#34;&#34;&#34;Delegate pair_offdiagcoeff to the base class, ensuring it uses the correct attributes.&#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        self._inject_attributes()
        return self.base_class.pair_offdiagcoeff(o=o, printflag=printflag, verbose=verbose, i=i, raw=raw, USER=None, beadtype=self.beadtype, userid=self.userid,oname=oname)


    def __add__(self, other):
        &#34;&#34;&#34;Concatenate dforcefield attributes, i

        ncluding RULES, GLOBAL, and LOCAL, if different, else keep the version of self.&#34;&#34;&#34;
        if not isinstance(other, dforcefield):
            raise TypeError(f&#34;Cannot concatenate {type(other)} with dforcefield.&#34;)

        if self.base_class != other.base_class:
            raise ValueError(f&#34;Cannot concatenate dforcefield instances with different base classes ({self.base_class} != {other.base_class}).&#34;)

        # Concatenate name, description, beadtype, userid, and parameters if different, else keep self&#39;s version
        new_name = self.name if self.name == other.name else f&#34;{self.name}_{other.name}&#34;
        new_description = self.description if self.description == other.description else f&#34;{self.description} + {other.description}&#34;
        new_beadtype = self.beadtype if self.beadtype == other.beadtype else f&#34;{self.beadtype}, {other.beadtype}&#34;
        new_parameters = self.parameters + other.parameters  # Assuming parameters supports &#39;+&#39;
        new_userid = self.userid if self.userid == other.userid else f&#34;{self.userid}_{other.userid}&#34;

        # Concatenate RULES, GLOBAL, and LOCAL, preserving their combined nature
        new_rules = self.RULES + other.RULES
        new_global = self.GLOBAL + other.GLOBAL
        new_local = self.LOCAL + other.LOCAL

        # Keep the version from self
        new_version = self.version

        # Return a new dforcefield instance with concatenated attributes
        return dforcefield(
            base_class=self.base_class,
            beadtype=new_beadtype,
            userid=new_userid,
            name=new_name,
            description=new_description,
            version=new_version,
            USER=new_parameters,
            RULES=new_rules,
            GLOBAL=new_global,
            LOCAL=new_local
        )


    def __or__(self, other):
        &#34;&#34;&#34; Overload | pipe operator in dscript &#34;&#34;&#34;
        # Convert the dscript instance into a pipescript
        leftarg = self.pscript()
        # Simply use the existing pipe operator for pipescript
        return leftarg | other


    def copy(self, beadtype=None, userid=None, name=None, description=None, version=None, USER=parameterforcefield(), RULES=None, GLOBAL=None, LOCAL=None, **kwargs):
        &#34;&#34;&#34;
        Create a new instance of dforcefield with the option to override key attributes including RULES, GLOBAL, and LOCAL.
        &#34;&#34;&#34;
        # Use the current instance&#39;s values as defaults, and override if values are provided
        new_beadtype = beadtype if beadtype is not None else self.beadtype
        new_userid = userid if userid is not None else self.userid
        new_name = name if name is not None else self.name
        new_description = description if description is not None else self.description
        new_version = version if version is not None else self.version
        if new_userid == self.userid:
            new_userid = new_userid + &#34; (copy)&#34;
        # updated USER
        new_USER = self.parameters + USER
        # updated parameters
        new_parameters = self.parameters + parameterforcefield(**kwargs)
        # Combine or override RULES, GLOBAL, and LOCAL if provided
        new_rules = RULES if RULES is not None else self.RULES
        new_global = GLOBAL if GLOBAL is not None else self.GLOBAL
        new_local = LOCAL if LOCAL is not None else self.LOCAL
        # Create and return the new instance with overridden values
        return self.__class__(
            base_class=self.base_class.__class__,
            beadtype=new_beadtype,
            userid=new_userid,
            name=new_name,
            description=new_description,
            version=new_version,
            USER=new_USER,
            RULES=new_rules,
            GLOBAL=new_global,
            LOCAL=new_local,
            **new_parameters
        )


    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple attributes of the dforcefield instance at once, including RULES, GLOBAL, and LOCAL.

        Args:
            kwargs: Key-value pairs of attributes to update.
        &#34;&#34;&#34;
        for key, value in kwargs.items():
            if key == &#34;RULES&#34;:
                self.RULES = self.RULES + value if self.RULES else value
            elif key == &#34;GLOBAL&#34;:
                self.GLOBAL = self.GLOBAL + value if self.GLOBAL else value
            elif key == &#34;LOCAL&#34;:
                self.LOCAL = self.LOCAL + value if self.LOCAL else value
            else:
                setattr(self, key, value)



    def to_dict(self):
        &#34;&#34;&#34;
        Serialize the dforcefield instance to a dictionary, including RULES, GLOBAL, and LOCAL.

        Returns:
            dict: A dictionary containing all the attributes and their current values.

        Example:
            config = dynamic_water.to_dict()
            print(config)
        &#34;&#34;&#34;
        data = {
            &#34;name&#34;: self.name,
            &#34;description&#34;: self.description,
            &#34;beadtype&#34;: self.beadtype,
            &#34;userid&#34;: self.userid,
            &#34;version&#34;: self.version,
            &#34;parameters&#34;: dict(self.parameters),  # Convert parameters to a standard dict
            &#34;base_class&#34;: self.base_class.__class__.__name__,
            &#34;RULES&#34;: dict(self.RULES) if self.RULES else {},  # Include RULES if defined
            &#34;GLOBAL&#34;: dict(self.GLOBAL) if self.GLOBAL else {},  # Include GLOBAL if defined
            &#34;LOCAL&#34;: dict(self.LOCAL) if self.LOCAL else {}  # Include LOCAL if defined
        }
        return data



    @classmethod
    def from_dict(cls, data):
        &#34;&#34;&#34;
        Create a dforcefield instance from a dictionary, including RULES, GLOBAL, and LOCAL.

        Args:
            data (dict): A dictionary containing the attributes to initialize the dforcefield.

        Returns:
            dforcefield: A new dforcefield instance.

        Example:
            config = {
                &#34;name&#34;: &#34;water_ff&#34;,
                &#34;description&#34;: &#34;water forcefield&#34;,
                &#34;beadtype&#34;: 2,
                &#34;userid&#34;: &#34;water_sim&#34;,
                &#34;version&#34;: 1.0,
                &#34;parameters&#34;: {&#34;rho&#34;: 1000, &#34;sigma&#34;: 0.5},
                &#34;base_class&#34;: &#34;ulsph&#34;,
                &#34;RULES&#34;: {&#34;some_rule&#34;: &#34;value&#34;},
                &#34;GLOBAL&#34;: {&#34;global_param&#34;: 10},
                &#34;LOCAL&#34;: {&#34;local_param&#34;: 5}
            }

            new_ff = dforcefield.from_dict(config)
        &#34;&#34;&#34;
        # Extract base class information
        base_class_name = data.pop(&#34;base_class&#34;, None)
        base_class = globals().get(base_class_name) if base_class_name else None

        # Extract RULES, GLOBAL, and LOCAL from the data dictionary if they exist
        rules = data.pop(&#34;RULES&#34;, parameterforcefield())
        global_params = data.pop(&#34;GLOBAL&#34;, parameterforcefield())
        local_params = data.pop(&#34;LOCAL&#34;, parameterforcefield())

        # Create and return the new dforcefield instance with extracted or default RULES, GLOBAL, and LOCAL
        return cls(
            base_class=base_class,
            RULES=rules,
            GLOBAL=global_params,
            LOCAL=local_params,
            **data
        )


    def reset(self):
        &#34;&#34;&#34;
        Reset the dforcefield instance to its initial state, reapplying the default values
        including RULES, GLOBAL, and LOCAL.
        &#34;&#34;&#34;
        # Preserve the current RULES, GLOBAL, and LOCAL or reset them
        current_rules = self.RULES
        current_global = self.GLOBAL
        current_local = self.LOCAL

        # Reinitialize the instance with existing or reset RULES, GLOBAL, and LOCAL
        self.__init__(
            base_class=self.base_class.__class__,
            beadtype=self.beadtype,
            userid=self.userid,
            name=self.name,
            description=self.description,
            version=self.version,
            RULES=current_rules,
            GLOBAL=current_global,
            LOCAL=current_local
            )

    def validate(self):
        &#34;&#34;&#34;
        Validate the dforcefield instance to ensure all required attributes are set.

        Raises:
            ValueError: If any required attributes are missing or invalid.
        &#34;&#34;&#34;
        required_fields = self._dforcefield_specific_attributes

        for field in required_fields:
            if not getattr(self, field):
                raise ValueError(f&#34;{field} is required and not set.&#34;)

        print(&#34;Validation successful.&#34;)


    def compare(self, other, printflag=False):
        &#34;&#34;&#34;
        Compare the current instance with another dforcefield instance, including RULES, GLOBAL, and LOCAL.

        Args:
        -----
        other : dforcefield
            The other instance to compare.

        printflag : bool, optional (default: False)
            If True, prints a table showing all parameters, with differences marked by &#39;*&#39;.

        Returns:
        --------
        dict
            A dictionary showing differences between the two instances.

        Raises:
        -------
        TypeError: If the other object is not a dforcefield instance.

        Example:
        --------
        diffs = dynamic_water.compare(dynamic_salt)
        if printflag:
            Prints a comparison table with a type column and a legend at the end.
        &#34;&#34;&#34;
        # Define abbreviations for types
        type_abbreviations = {
            str: &#39;STR&#39;,
            int: &#39;INT&#39;,
            float: &#39;FLT&#39;,
            bool: &#39;BOOL&#39;,
            list: &#39;LST&#39;,
            tuple: &#39;TPL&#39;,
            dict: &#39;DCT&#39;,
            None: &#39;NON&#39;,
            &#39;missing&#39;: &#39;MIS&#39;
        }

        def get_type_abbrev(value):
            &#34;&#34;&#34;Return the abbreviation for the type of the value.&#34;&#34;&#34;
            if value is None:
                return type_abbreviations[None]
            return type_abbreviations.get(type(value), &#39;UNK&#39;)  # Use &#39;UNK&#39; for unknown types

        def format_simple_type(value):
            &#34;&#34;&#34;Format a simple value (str, number, or bool) for display.&#34;&#34;&#34;
            return self.dispmax(str(value))

        def format_iterable(value_self, value_other, key, comparison_table, difference):
            &#34;&#34;&#34;Handle lists, tuples, and other iterable types.&#34;&#34;&#34;
            max_length = max(len(value_self), len(value_other))
            for i in range(max_length):
                item_self = value_self[i] if i &lt; len(value_self) else &#39;MISSING&#39;
                item_other = value_other[i] if i &lt; len(value_other) else &#39;MISSING&#39;
                sub_difference = &#39;*&#39; if item_self != item_other else &#39; &#39;
                comparison_table.append(
                    f&#34;  {key if i == 0 else &#39;&#39;:&lt;15}: {sub_difference:^3}: {self.dispmax(str(item_self)):&lt;30}: {get_type_abbrev(item_self):&lt;5}: {self.dispmax(str(item_other)):&lt;30}: {get_type_abbrev(item_other):&lt;5}&#34;
                )

        def format_dict_like(value_self, value_other, key, comparison_table, difference):
            &#34;&#34;&#34;Handle dictionary-like objects (e.g., structs or dicts).&#34;&#34;&#34;
            comparison_table.append(f&#34;  {key:&lt;15}: {difference:^3}: &#34;)
            comparison_table.append(f&#34;  {&#39;&#39;:&lt;15}  {&#39;Self&#39;:&lt;30} {&#39;Type&#39;:&lt;5} {&#39;Other&#39;:&lt;30} {&#39;Type&#39;:&lt;5}&#34;)
            sub_sep = &#34;  &#34;+&#34;-&#34;*15+&#34;:&#34;+&#34;-&#34;*3+&#34;:&#34;+&#34;-&#34;*30+&#34;:&#34;+&#34;-&#34;*5+&#34;:&#34;+&#34;-&#34;*30+&#34;:&#34;+&#34;-&#34;*5
            comparison_table.append(sub_sep)
            sub_keys = set(value_self.keys()).union(value_other.keys())
            for sub_key in sorted(sub_keys):
                sub_value_self = value_self.get(sub_key, &#39;MISSING&#39;)
                sub_value_other = value_other.get(sub_key, &#39;MISSING&#39;)
                sub_difference = &#39;*&#39; if sub_value_self != sub_value_other else &#39; &#39;
                comparison_table.append(
                    f&#34;  {sub_key:&lt;15}: {sub_difference:^3}: {self.dispmax(str(sub_value_self)):&lt;30}: {get_type_abbrev(sub_value_self):&lt;5}: {self.dispmax(str(sub_value_other)):&lt;30}: {get_type_abbrev(sub_value_other):&lt;5}&#34;
                )
            comparison_table.append(sub_sep)

        def format_complex_type(value_self, value_other, key, comparison_table, difference):
            &#34;&#34;&#34;Handle complex types, expanding them into multiple lines.&#34;&#34;&#34;
            value_self_lines = str(value_self).splitlines()
            value_other_lines = str(value_other).splitlines()
            max_lines = max(len(value_self_lines), len(value_other_lines))
            for i in range(max_lines):
                line_self = value_self_lines[i] if i &lt; len(value_self_lines) else &#39;MISSING&#39;
                line_other = value_other_lines[i] if i &lt; len(value_other_lines) else &#39;MISSING&#39;
                comparison_table.append(
                    f&#34;  {key if i == 0 else &#39;&#39;:&lt;15}: {difference if i == 0 else &#39; &#39;:^3}: {self.dispmax(line_self):&lt;30}: {get_type_abbrev(line_self):&lt;5}: {self.dispmax(line_other):&lt;30}: {get_type_abbrev(line_other):&lt;5}&#34;
                )

        if not isinstance(other, dforcefield):
            raise TypeError(&#34;Can only compare with another dforcefield instance.&#34;)

        diffs = {}

        # Collect all keys from both instances, including RULES, GLOBAL, and LOCAL
        all_keys = set(self.keys()).union(other.keys(), {&#39;RULES&#39;, &#39;GLOBAL&#39;, &#39;LOCAL&#39;})

        # Iterate over all keys and compare the values
        for key in all_keys:
            value_self = getattr(self, key, None)
            value_other = getattr(other, key, None)

            if value_self != value_other:
                diffs[key] = {&#34;self&#34;: value_self, &#34;other&#34;: value_other}

        # If printflag is True, print the comparison in a table format
        if printflag:
            sep = &#34;  &#34;+&#34;-&#34;*15 + &#34;:&#34; + &#34;-&#34;*3 + &#34;:&#34; + &#34;-&#34;*30 + &#34;:&#34; + &#34;-&#34;*5 + &#34;:&#34; + &#34;-&#34;*30 + &#34;:&#34; + &#34;-&#34;*5
            header = f&#34;\n  {&#39;Attribute&#39;:&lt;15}: {&#39;*&#39;:^3}: {&#39;Self&#39;:&lt;30}: {&#39;Type&#39;:&lt;5}: {&#39;Other&#39;:&lt;30}: {&#39;Type&#39;:&lt;5}\n&#34; + sep
            comparison_table = [header]

            # Iterate over all parameters and mark differences with &#39;*&#39;
            for key in sorted(all_keys):  # Sort keys for a cleaner output
                value_self = getattr(self, key, &#39;MISSING&#39;)
                value_other = getattr(other, key, &#39;MISSING&#39;)
                difference = &#39;*&#39; if value_self != value_other else &#39; &#39;

                # Check if the value is a simple type (str, number, or bool)
                if isinstance(value_self, (str, int, float, bool)) and isinstance(value_other, (str, int, float, bool)):
                    comparison_table.append(
                        f&#34;  {key:&lt;15}: {difference:^3}: {format_simple_type(value_self):&lt;30}: {get_type_abbrev(value_self):&lt;5}: {format_simple_type(value_other):&lt;30}: {get_type_abbrev(value_other):&lt;5}&#34;
                    )
                # Check if the value is a list or tuple
                elif isinstance(value_self, (list, tuple)) and isinstance(value_other, (list, tuple)):
                    format_iterable(value_self, value_other, key, comparison_table, difference)
                # Check if the value is a dictionary-like object
                elif hasattr(value_self, &#39;keys&#39;) and hasattr(value_other, &#39;keys&#39;):
                    format_dict_like(value_self, value_other, key, comparison_table, difference)
                else:
                    # Handle other complex types
                    format_complex_type(value_self, value_other, key, comparison_table, difference)

            comparison_table.append(sep)
            # Add a legend for type abbreviations
            legend = &#34;\nType Legend: &#34; + &#34;, &#34;.join(f&#34;{abbrev} = {(&#39;NoneType&#39; if type_ is None else type_.__name__.upper())}&#34; for type_, abbrev in type_abbreviations.items() if type_ != &#39;missing&#39;)

            comparison_table.append(legend)

            # Print the comparison table
            print(&#34;\n&#34;.join(comparison_table))

        return diffs



    def generator(self):
        &#34;&#34;&#34;
        Generate the forcefield definition as a formatted string without traceability features.

        Returns:
        --------
        str: A string containing the formatted forcefield definition, including headers for attributes,
             descriptions, names, and parameters, but excluding traceability information such as host, date, and user.

        Example Output:
        ---------------
        base_class=&#34;tlsph&#34;
        beadtype = 1
        userid = &#34;dynamic_water&#34;
        version = 1.0

        # Description of the forcefield
        description:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;water&#34;}

        # Name of the forcefield
        name:{forcefield=&#34;LAMMPS:SMD&#34;, material=&#34;water&#34;}

        # Parameters for the forcefield
        rho = 1000
        E = &#34;5*${c0}^2*${rho}&#34;
        nu = 0.3
        &#34;&#34;&#34;
        # Construct forcefield attributes
        attributes = (
            f&#39;base_class=&#34;{self.base_class.__class__.__name__}&#34;\n&#39;
            f&#39;beadtype = {self.beadtype}\n&#39;
            f&#39;userid = &#34;{self.userid}&#34;\n&#39;
            f&#39;version = {self.version}\n\n&#39;
        )

        # Construct description
        description = (
            &#39;# Description of the forcefield\n&#39;
            f&#39;description:{{&#39; + &#39;, &#39;.join(f&#39;{key}=&#34;{value}&#34;&#39; for key, value in self.description.items()) + &#39;}\n\n&#39;
        )

        # Construct name
        name = (
            &#39;# Name of the forcefield\n&#39;
            f&#39;name:{{&#39; + &#39;, &#39;.join(f&#39;{key}=&#34;{value}&#34;&#39; for key, value in self.name.items()) + &#39;}\n\n&#39;
        )

        # Construct parameters
        parameters = &#39;# Parameters for the forcefield\n&#39;
        for key, value in self.parameters.items():
            parameters += f&#39;{key} = {value}\n&#39;

        # Combine all parts
        content = attributes + description + name + parameters
        return content



    def save(self, filename=None, foldername=None, overwrite=False, verbose=True, extension=&#34;.txt&#34;):
        &#34;&#34;&#34;
        Save the dforcefield instance to a file using the generated forcefield definition.

        Args:
        -----
        filename (str): The name of the file to save. Defaults to self.userid if not provided.
        foldername (str): The folder in which to save the file. Defaults to a temporary directory.
        overwrite (bool): Whether to overwrite the file if it already exists. Defaults to False.
        verbose (bool): Whether to include traceability features (host, date, user) in the saved file.
                        Defaults to True.
        extension (str): The file extension to use. Defaults to &#34;.txt&#34;.

        Raises:
        -------
        FileExistsError: If the file already exists and overwrite is False.

        Notes:
        ------
        The saved file will always include the mandatory line &#34;# DFORCEFIELD SAVE FILE&#34;.
        If verbose is True, a header with traceability information (host, date, user) will be included.
        The file extension can be customized via the &#39;extension&#39; parameter.

        Example Output when verbose=True:
        ---------------
        # DFORCEFIELD SAVE FILE
        # generated on 2024-12-30 by user@host
        #
        #   userid = &#34;dynamic_water&#34;

        base_class=&#34;tlsph&#34;
        beadtype = 1
        userid = &#34;dynamic_water&#34;
        version = 1.0

        # Description of the forcefield
        description:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;water&#34;}

        # Name of the forcefield
        name:{forcefield=&#34;LAMMPS:SMD&#34;, material=&#34;water&#34;}

        # Parameters for the forcefield
        rho = 1000
        E = &#34;5*${c0}^2*${rho}&#34;
        nu = 0.3

        Example Output when verbose=False:
        ---------------
        # DFORCEFIELD SAVE FILE

        base_class=&#34;tlsph&#34;
        beadtype = 1
        userid = &#34;dynamic_water&#34;
        version = 1.0

        # Description of the forcefield
        description:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;water&#34;}

        # Name of the forcefield
        name:{forcefield=&#34;LAMMPS:SMD&#34;, material=&#34;water&#34;}

        # Parameters for the forcefield
        rho = 1000
        E = &#34;5*${c0}^2*${rho}&#34;
        nu = 0.3
        &#34;&#34;&#34;
        # Determine filename
        if filename is None:
            filename = self.userid
        if not filename.endswith(extension):
            filename += extension

        # Determine foldername
        if foldername is None:
            foldername = tempfile.gettempdir()

        # Construct full file path
        if not os.path.isabs(filename):
            filepath = os.path.join(foldername, filename)
        else:
            filepath = filename

        # Check if file exists
        if os.path.exists(filepath) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

        # Generate forcefield content
        content = self.generator()

        # Initialize content with mandatory header
        final_content = &#39;# DFORCEFIELD SAVE FILE\n&#39;

        if verbose:
            user = getpass.getuser()
            host = socket.gethostname()
            date = datetime.now().strftime(&#39;%Y-%m-%d&#39;)

            # Construct traceability header
            trace_header = (
                f&#39;# generated on {date} by {user}@{host}\n&#39;
                f&#39;#\n&#39;
                f&#39;#   userid = &#34;{self.userid}&#34;\n\n&#39;
            )
            final_content += trace_header
        else:
            final_content += &#39;\n&#39;

        # Append forcefield content
        final_content += content

        # Write content to file
        with open(filepath, &#39;w&#39;) as f:
            f.write(final_content)

        print(f&#39;\nForcefield saved to {filepath}&#39;)
        return filepath



    @classmethod
    def load(cls, filename, foldername=None, authentication=True):
        &#34;&#34;&#34;
        Load a dforcefield instance from a file with more control over the folder location and file validation.

        Args:
        -----
        filename (str): The name of the file to load. The &#39;extension&#39; parameter will be used if not present.
        foldername (str): The folder from which to load the file. Defaults to a temporary directory.
        authentication (bool): Whether to authenticate the file by checking the mandatory header line.
                            Defaults to True. If False, bypasses the authentication and parses the content directly.

        Returns:
        --------
        dforcefield: A new dforcefield instance parsed from the file content.

        Raises:
        -------
        FileNotFoundError: If the file does not exist.
        ValueError: If authentication is True and the file does not start with the mandatory header.

        Notes:
        ------
        - The method checks for the mandatory line &#34;# DFORCEFIELD SAVE FILE&#34; at the beginning of the file.
        If authentication is False, this check is bypassed, allowing parsing of content generated by generate().
        - The file extension is expected to be &#39;.txt&#39; by default unless specified otherwise in the filename.

        Example Usage:
        --------------
        &gt;&gt;&gt; ff = dforcefield.load(&#34;forcefield.txt&#34;, authentication=True)
        &#34;&#34;&#34;
        # Determine file extension and ensure it ends with &#39;.txt&#39;
        if not filename.endswith(&#39;.txt&#39;):
            filename += &#39;.txt&#39;

        # Determine foldername
        if foldername is None:
            foldername = tempfile.gettempdir()

        # Construct full file path
        if not os.path.isabs(filename):
            filepath = os.path.join(foldername, filename)
        else:
            filepath = filename

        # Check if file exists
        if not os.path.exists(filepath):
            raise FileNotFoundError(f&#34;The file &#39;{filepath}&#39; does not exist.&#34;)

        # Read the file contents
        with open(filepath, &#39;r&#39;) as f:
            content = f.read()

        # Call the parse method to create a new dforcefield instance
        return cls.parsesyntax(content, authentication=authentication)



    @classmethod
    def parsesyntax(cls, content, authentication=True):
        &#34;&#34;&#34;
        Parse the string content of a forcefield file to create a dforcefield instance.

        Args:
        -----
        content (str): The string content to be parsed.
        authentication (bool): Whether to authenticate the content by checking the mandatory header line.
                               Defaults to True. If False, bypasses the authentication.

        Returns:
        --------
        dforcefield
            A new `dforcefield` instance populated with the parsed content.

        Raises:
        -------
        ValueError
            - If authentication is True and the content does not start with the correct mandatory header line.
            - If the content format is invalid.
            - If base_class is not a valid subclass of forcefield.

        Notes:
        ------
        - Handles different sections including parameters, name, and description.
        - Accepts empty lines and comments.
        - Uses { } for attributes blocks.
        - If authentication is False, it does not check for the mandatory header line.
        - Recognizes `beadtype`, `userid`, and `version` as special attributes. If they are not present,
          they are included in the `parameters`.

        Example Usage:
        --------------
        &gt;&gt;&gt; ff = dforcefield.parsesyntax(content_string, authentication=True)
        &#34;&#34;&#34;
        # Split the content into lines
        lines = content.splitlines()
        lines = [line for line in lines if line.strip()]  # Remove blank or empty lines

        # Raise an error if no content is left after removing blank lines
        if not lines:
            raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

        # Initialize containers for parsed data
        inside_global_params = False
        global_params_content = &#34;&#34;
        parameters = {}
        description = {}
        name = {}
        base_class_name = None

        # Step 1: Authenticate the file by checking the first line
        if authentication:
            if not lines[0].strip().startswith(&#34;# DFORCEFIELD SAVE FILE&#34;):
                raise ValueError(&#34;File/Content is not a valid DFORCEFIELD file.&#34;)
            # Remove the mandatory header line from processing
            lines = lines[1:]

        # Step 2: Process each line dynamically
        for line in lines:
            stripped = line.strip()

            # Ignore empty lines and comments
            if not stripped or stripped.startswith(&#34;#&#34;):
                continue

            # Remove trailing comments
            stripped = remove_comments(stripped)

            # Handle description and name blocks first to avoid parsing them as parameters
            if stripped.startswith(&#34;description:{&#34;):
                desc_content = stripped[len(&#34;description:{&#34;):].strip()
                # Check if the block ends on the same line
                if desc_content.endswith(&#34;}&#34;):
                    desc_content = desc_content[:-1].strip()
                    cls._parse_struct_block(desc_content, description)
                else:
                    # Multiline description block
                    desc_content = desc_content
                    while not stripped.endswith(&#34;}&#34;):
                        next_line = next(iter(lines), &#34;&#34;).strip()
                        stripped = next_line
                        desc_content += &#34; &#34; + cls.remove_comments(next_line)
                    desc_content = desc_content[:-1].strip()
                    cls._parse_struct_block(desc_content, description)
                continue  # Skip further processing for this line

            if stripped.startswith(&#34;name:{&#34;):
                name_content = stripped[len(&#34;name:{&#34;):].strip()
                # Check if the block ends on the same line
                if name_content.endswith(&#34;}&#34;):
                    name_content = name_content[:-1].strip()
                    cls._parse_struct_block(name_content, name)
                else:
                    # Multiline name block
                    name_content = name_content
                    while not stripped.endswith(&#34;}&#34;):
                        next_line = next(iter(lines), &#34;&#34;).strip()
                        stripped = next_line
                        name_content += &#34; &#34; + cls.remove_comments(next_line)
                    name_content = name_content[:-1].strip()
                    cls._parse_struct_block(name_content, name)
                continue  # Skip further processing for this line

            # Handle global parameters inside {...}
            if stripped.startswith(&#34;{&#34;):
                inside_global_params = True
                global_params_content = stripped[1:].strip()
                # Check if the block ends on the same line
                if &#39;}&#39; in global_params_content:
                    global_params_content = global_params_content.split(&#39;}&#39;, 1)[0].strip()
                    inside_global_params = False
                    cls._parse_global_params(global_params_content, parameters)
                    global_params_content = &#34;&#34;
                continue  # Skip further processing for this line

            if inside_global_params:
                if &#39;}&#39; in stripped:
                    global_params_content += &#34; &#34; + stripped.split(&#39;}&#39;, 1)[0].strip()
                    inside_global_params = False
                    cls._parse_global_params(global_params_content, parameters)
                    global_params_content = &#34;&#34;
                else:
                    global_params_content += &#34; &#34; + stripped
                continue  # Continue to next line

            # Handle key-value pairs
            if &#34;=&#34; in stripped:
                key, value = stripped.split(&#34;=&#34;, 1)
                key = key.strip()
                value = value.strip().strip(&#39;&#34;&#39;).strip(&#34;&#39;&#34;)
                if key == &#34;base_class&#34;:
                    # Store the class name, do not load
                    base_class_name = value
                elif key in {&#34;beadtype&#34;, &#34;userid&#34;, &#34;version&#34;}:
                    parameters[key] = cls._convert_value(value)
                else:
                    parameters[key] = cls._convert_value(value)
                continue  # Skip further processing for this line

        # Step 3: Handle special attributes (beadtype, userid, version)
        # Extract beadtype
        beadtype = parameters.pop(&#39;beadtype&#39;, None)
        if beadtype is not None:
            try:
                beadtype = int(beadtype)
            except ValueError:
                raise ValueError(f&#34;Invalid value for beadtype: {beadtype}. It must be an integer.&#34;)
        else:
            beadtype = 1  # Default value
            parameters[&#39;beadtype&#39;] = beadtype

        # Extract userid
        userid = parameters.pop(&#39;userid&#39;, None)
        if userid is not None:
            userid = str(userid)
        else:
            userid = &#34;unknown&#34;  # Default value
            parameters[&#39;userid&#39;] = userid

        # Extract version
        version = parameters.pop(&#39;version&#39;, None)
        if version is not None:
            try:
                version = float(version)
            except ValueError:
                raise ValueError(f&#34;Invalid value for version: {version}. It must be a float.&#34;)
        else:
            version = 0.1  # Default value
            parameters[&#39;version&#39;] = version

        # Step 4: Validate base_class and create a new dforcefield instance
        if base_class_name is None:
            raise ValueError(&#34;base_class must be specified and valid in the forcefield file.&#34;)

        #â™  Dynamically set the base class based on the string value (e.g., &#34;tlsph&#34;)
        resolved_base_class  = cls._load_base_class(base_class_name)
        if resolved_base_class is None or not issubclass(resolved_base_class, forcefield):
            value = str(resolved_base_class)
            raise ValueError(f&#34;Invalid base_class: &#39;{value}&#39; must be a subclass of forcefield.&#34;)

        # Step 6: Create and return the new dforcefield instance
        newFF = cls(
            base_class=resolved_base_class,
            beadtype=beadtype,
            userid=userid,
            name=struct(**name),
            description=struct(**description),
            version=version,
            USER=parameterforcefield(**parameters)
        )

        # Step 6: Detect variables in templates and propagate undefined variables
        dvars = newFF.detectVariables()
        newFF.parameters = dvars + newFF.parameters
        return newFF


    @classmethod
    def _parse_global_params(cls, content, global_params):
        &#34;&#34;&#34;Parse global parameters from the accumulated content between {}.&#34;&#34;&#34;
        lines = re.split(r&#39;,(?![^(){}\[\]]*[\)\}\]])&#39;, content)
        for line in lines:
            line = line.strip()
            match = re.match(r&#39;([\w_]+)\s*=\s*(.+)&#39;, line)
            if match:
                key, value = match.groups()
                key = key.strip()
                value = value.strip()
                global_params[key] = cls._convert_value(value)



    @classmethod
    def _parse_struct_block(cls, content, struct_block):
        &#34;&#34;&#34;
        Parse blocks like description or name with key=value pairs, handling commas inside quotes.

        Parameters:
        -----------
        content : str
            The content to parse, which contains key=value pairs.

        struct_block : dict
            A dictionary to store the parsed key-value pairs.
        &#34;&#34;&#34;
        # Split on commas that are not inside quotes
        pairs = re.split(r&#39;,\s*(?![^&#34;]*\&#34;\s*,\s*[^&#34;]*&#34;)&#39;, content)

        for pair in pairs:
            if &#39;=&#39; in pair:
                key, value = pair.split(&#39;=&#39;, 1)  # Ensure splitting only on the first &#39;=&#39;
            struct_block[key.strip()] = value.strip().strip(&#39;&#34;&#39;)



    @classmethod
    def _convert_value(cls, value):
        &#34;&#34;&#34;Convert a string representation of a value to the appropriate Python type.&#34;&#34;&#34;
        value = value.strip()

        # Boolean conversion
        if value.lower() == &#39;true&#39;:
            return True
        elif value.lower() == &#39;false&#39;:
            return False

        # Handle quoted strings
        if (value.startswith(&#39;&#34;&#39;) and value.endswith(&#39;&#34;&#39;)) or (value.startswith(&#34;&#39;&#34;) and value.endswith(&#34;&#39;&#34;)):
            return value[1:-1]

        # Handle lists
        if value.startswith(&#39;[&#39;) and value.endswith(&#39;]&#39;):
            return eval(value)  # Using eval to parse lists safely in this controlled scenario

        # Handle numbers
        try:
            if &#39;.&#39; in value:
                return float(value)
            return int(value)
        except ValueError:
            return value


    def detectVariables(self):
        &#34;&#34;&#34;
        Detects variables in the form ${variable} from the outputs of pair_style, pair_diagcoeff,
        and pair_offdiagcoeff.

        Returns:
        --------
        struct
            A struct containing the detected variable names that are not yet defined.
        &#34;&#34;&#34;
        # Extract variables from pair_style, pair_diagcoeff, and pair_offdiagcoeff
        detected_vars = set()

        # Define a regex pattern to detect variables in the form ${variable}
        pattern = r&#39;\$\{(\w+)\}&#39;

        # Detect variables in pair_style output
        pair_style_output = self.pair_style(printflag=False, raw=True)
        detected_vars.update(re.findall(pattern, pair_style_output))

        # Detect variables in pair_diagcoeff output
        pair_diagcoeff_output = self.pair_diagcoeff(printflag=False, raw=True)
        detected_vars.update(re.findall(pattern, pair_diagcoeff_output))

        # Detect variables in pair_offdiagcoeff output
        pair_offdiagcoeff_output = self.pair_offdiagcoeff(printflag=False, raw=True)
        detected_vars.update(re.findall(pattern, pair_offdiagcoeff_output))

        # Convert the detected variables into a parameterforcefield() for further propagation
        return parameterforcefield(**{var: &#34;${&#34; + var + &#34;}&#34; for var in detected_vars})


    def missingVariables(self, isimplicit_missing=True, output_aslist=False):
        &#34;&#34;&#34;
        List missing variables (undefined in parameters).

        Parameters:
        -----------
        isimplicit_missing : bool, optional (default: True)
            If True, variables defined implicitly as ${varname} in parameters are considered missing.

        output_aslist : bool, optional (default: False)
            If True, returns a list of missing variable names.
            If False, returns a parameterforcefield-like structure with implicit definitions.

        Returns:
        --------
        List of str or parameterforcefield
            If output_aslist is True, returns a list of variable names that are missing from the parameters.
            If output_aslist is False, returns a parameterforcefield-like structure with implicit definitions.
        &#34;&#34;&#34;
        # Detect all variables used in the forcefield using detectVariables
        detected_vars = self.detectVariables()

        # Initialize missing variables
        missing_vars = []

        # Initialize a dictionary to store variables as parameterforcefield when output_aslist=False
        missing_vars_struct = {}

        # Iterate over detected variables and check if they are missing in parameters
        for varname in detected_vars.keys():
            if varname not in self.parameters:
                # If the variable is missing, add it to both the list and struct
                missing_vars.append(varname)
                missing_vars_struct[varname] = &#34;${&#34; + varname + &#34;}&#34;
            elif isimplicit_missing:
                # If the variable exists but is implicitly defined as ${varname}, treat it as missing
                param_value = self.parameters.getattr(varname)
                if param_value == &#34;${&#34; + varname + &#34;}&#34;:
                    missing_vars.append(varname)
                    missing_vars_struct[varname] = &#34;${&#34; + varname + &#34;}&#34;

        # Return the result based on the output_aslist flag
        if output_aslist:
            return missing_vars
        else:
            return parameterforcefield(**missing_vars_struct)


    @classmethod
    def list_forcefield_subclasses(cls, printflag=True, additional_modules=None):
        &#34;&#34;&#34;
        Class method to list all subclasses of the `forcefield` and `generic` classes, including their methods.

        Parameters:
        -----------
        printflag : bool, optional (default=True)
            If True, prints the subclasses of `forcefield`, `generic`, their load status, and their default parameters.
        additional_modules : module or list of modules, optional
            A module or list of additional modules to search for subclasses and methods.

        Returns:
        --------
        dict
            A dictionary where keys are class names or method names and values are dictionaries containing:
            - &#34;loaded&#34;: Whether the class or method is already loaded in memory.
            - &#34;module&#34;: The module path of the class or method.
            - &#34;default_parameters&#34;: Extracted parameters, RULES, LOCAL, and GLOBAL from the class or method.
        dict
            A dictionary mapping short names to full names.
        &#34;&#34;&#34;
        subclasses = set()
        classes_to_check = [forcefield, generic]  # Start with both forcefield and generic

        # Ensure additional_modules is a list, even if it&#39;s a single module
        if additional_modules is not None and not isinstance(additional_modules, list):
            additional_modules = [additional_modules]

        # Include classes from additional modules
        if additional_modules:
            for mod in additional_modules:
                for name, obj in inspect.getmembers(mod):
                    # Add classes that are subclasses of forcefield or generic
                    if inspect.isclass(obj) and (issubclass(obj, forcefield) or issubclass(obj, generic)) and obj not in {forcefield, generic}:
                        subclasses.add(obj)
                        classes_to_check.append(obj)
                    # Also add relevant high-level methods/functions that do not start with &#39;_&#39;
                    elif (inspect.isfunction(obj) or inspect.ismethod(obj)) and not name.startswith(&#39;_&#39;):
                        # Check if the method belongs to a class derived from generic, not forcefield
                        parent_class_name = obj.__qualname__.split(&#39;.&#39;)[0]
                        parent_class = next((cls for cls in subclasses if cls.__name__ == parent_class_name), None)
                        if parent_class and issubclass(parent_class, generic) and not issubclass(parent_class, forcefield):
                            subclasses.add((parent_class, name, obj))  # Add (parent_class, method_name, function/method)

        # Traverse through all found subclasses
        while classes_to_check:
            parent_class = classes_to_check.pop()
            for subclass in parent_class.__subclasses__():
                subclasses.add(subclass)
                classes_to_check.append(subclass)

        # Prepare the output dictionary with load status flags and default parameters
        subclass_info = {}
        short_name_mapping = {}

        for subclass in subclasses:
            if inspect.isclass(subclass):
                class_name = subclass.__name__
                is_loaded = class_name in globals()  # Check if class is already loaded

                # Extract default parameters if they exist
                extracted_params = cls.extract_default_parameters(subclass, displayflag=False)
                num_defaults = len(extracted_params.get(&#39;parameters&#39;, {}).keys()) if extracted_params else None

                # Check if RULES, GLOBAL, and LOCAL are defined
                rules_defined = &#39;&#39;
                if extracted_params:
                    rules_defined += &#39;R&#39; if extracted_params[&#34;RULES&#34;] else &#39;-&#39;
                    rules_defined += &#39;G&#39; if extracted_params[&#34;GLOBAL&#34;] else &#39;-&#39;
                    rules_defined += &#39;L&#39; if extracted_params[&#34;LOCAL&#34;] else &#39;-&#39;

                # Add entry for the class
                subclass_info[class_name] = {
                    &#34;loaded&#34;: is_loaded,
                    &#34;module&#34;: subclass.__module__,
                    &#34;num_defaults&#34;: num_defaults,
                    &#34;rules_defined&#34;: rules_defined if rules_defined else &#39;---&#39;  # Display as &#39;---&#39; if none defined
                }

                # Map short name to full name
                short_name_mapping[class_name] = class_name

                # Inspect and add high-level methods from the class itself if not forcefield
                if not issubclass(subclass, forcefield):
                    for method_name, method in inspect.getmembers(subclass, predicate=inspect.isfunction):
                        if not method_name.startswith(&#39;_&#39;):  # Skip private methods
                            method_full_name = f&#34;{class_name}.{method_name}&#34;
                            extracted_method_params = cls.extract_default_parameters(subclass, method_name=method_name, displayflag=False)
                            num_defaults = len(extracted_method_params.get(&#39;parameters&#39;, {}).keys()) if extracted_method_params else None
                            rules_defined = extracted_method_params.get(&#34;rules_defined&#34;, &#34;---&#34;)
                            subclass_info[method_full_name] = {
                                &#34;loaded&#34;: True,
                                &#34;module&#34;: subclass.__module__,
                                &#34;num_defaults&#34;: num_defaults,
                                &#34;rules_defined&#34;: rules_defined
                            }
                            # Add method short name to mapping
                            short_name_mapping[method_name] = method_full_name

            else:
                # Handle function/method cases
                parent_class, func_name, func_obj = subclass
                is_loaded = func_name in globals() or parent_class.__module__ in sys.modules
                extracted_method_params = cls.extract_default_parameters(parent_class, method_name=func_name, displayflag=False)
                num_defaults = len(extracted_method_params.get(&#39;parameters&#39;, {}).keys()) if extracted_method_params else None
                rules_defined = extracted_method_params.get(&#34;rules_defined&#34;, &#34;---&#34;)
                func_full_name = f&#34;{parent_class.__name__}.{func_name}&#34;
                subclass_info[func_full_name] = {
                    &#34;loaded&#34;: is_loaded,
                    &#34;module&#34;: parent_class.__module__,
                    &#34;num_defaults&#34;: num_defaults,
                    &#34;rules_defined&#34;: rules_defined
                }
                # Add function/method to short names
                short_name_mapping[func_name] = func_full_name

        # Optionally print the subclasses and their load status with parameter info
        if printflag:
            print(&#34;List of available forcefields and relevant methods:\n&#34;)
            print(f&#34;{&#39;Short Name&#39;:&lt;15} {&#39;Class/Method Name&#39;:&lt;30} {&#39;Module Path&#39;:&lt;30} {&#39;Status&#39;:&lt;10} {&#39;Default Params&#39;:&lt;10} {&#39;RULES&#39;:&lt;5}&#34;)
            print(&#34;=&#34; * 105)
            for short_name, class_name in sorted(short_name_mapping.items(), key=lambda x: x[0]):
                info = subclass_info[class_name]
                status = &#34;Loaded&#34; if info[&#34;loaded&#34;] else &#34;Not Loaded&#34;
                num_defaults = info[&#34;num_defaults&#34;] if info[&#34;num_defaults&#34;] is not None else &#34;None&#34;
                rules_defined = info[&#34;rules_defined&#34;]
                print(f&#34;{short_name:&lt;15} {class_name:&lt;30} {info[&#39;module&#39;]:&lt;30} {status:&lt;10} {num_defaults:&lt;10} {rules_defined:&lt;5}&#34;)
            print(f&#34;\nTotal number of forcefields and methods: {len(subclass_info)}&#34;)

        return subclass_info, short_name_mapping



    def scriptobject(self, beadtype=None, name=None, userid=None, fullname=None, filename=None, group=None, style=None, USER=scriptdata()):
        &#34;&#34;&#34;
        Method to return a scriptobject based on the current dforcefield instance.

        Parameters:
        ------------
        beadtype : int, optional
            The bead type identifier. Defaults to the instance&#39;s beadtype.

        name : str, optional
            A short name for the scriptobject. If not provided, uses &#39;forcefield&#39; from self.name.

        fullname : str, optional
            A comprehensive name for the object. Defaults to &#34;beads of type {self.beadtype} | object of forcefield: {self.name.forcefield}&#34;.

        group : list, optional
            A group of scriptobjects that this object belongs to. Defaults to an empty list.

        style : str, optional
            The style of the scriptobject. Defaults to `self.description.style` if available, otherwise &#34;smd&#34;.

        USER : scriptdata, optional
            User-defined data for additional parameters. Defaults to a blank `scriptdata()` instance.

        Returns:
        --------
        scriptobject
            A scriptobject instance populated with the current `dforcefield` instance&#39;s attributes or provided arguments.
        &#34;&#34;&#34;
        # Set defaults using instance attributes if parameters are None
        if beadtype is None:
            beadtype = self.beadtype

        # Extract a meaningful name from the forcefield&#39;s name structure
        if name is None:
            if isinstance(self.name, struct) and hasattr(self.name, &#39;material&#39;):
                name = f&#34;{self.name.material} bead&#34;
            else:
                name = f&#34;beadtype_{beadtype}&#34;

        if userid is None:
            userid = name

        if fullname is None:
            fullname = f&#34;beads of type {beadtype} | object of forcefield: {self.name.forcefield if isinstance(self.name, struct) and hasattr(self.name, &#39;forcefield&#39;) else &#39;unknown&#39;}&#34;

        if group is None:
            group = []

        # Use `self.description.style` as the default for style if it exists, otherwise fall back to &#34;smd&#34;
        if style is None:
            if isinstance(self.description, struct) and hasattr(self.description, &#39;style&#39;):
                style = self.description.style
            else:
                style = &#34;undefined style&#34;

        # The current dforcefield instance behaves as the forcefield for the scriptobject
        forcefield = copy.deepcopy(self)
        forcefield.beadtype = beadtype
        forcefield.name = name
        forcefield.userid = userid

        # Apply any user-defined parameters to the forcefield
        # This is the standard behavior of scriptobject
        forcefield.parameters = forcefield.parameters + USER

        # Create and return the scriptobject instance
        return scriptobject(
            beadtype=beadtype,
            name=name,
            fullname=fullname,
            filename=filename,
            style=style,
            forcefield=forcefield,  # Use the current dforcefield instance
            group=group,
            USER=USER
        )


    def __copy__(self):
        &#34;&#34;&#34;
        Shallow copy method for dforcefield.

        Creates a shallow copy of the dforcefield instance, meaning that references
        to mutable objects like &#39;parameters&#39; will not be deeply copied.
        &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)

        # Copy the simple attributes
        copie.__dict__.update(self.__dict__)

        # Return the shallow copy
        return copie


    def __deepcopy__(self, memo):
        &#34;&#34;&#34;
        Deep copy method for dforcefield.

        Creates a deep copy of the dforcefield instance, including its complex attributes
        like &#39;parameters&#39;. This ensures that all mutable objects are fully copied, not just referenced.
        &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie

        # Recursively deep copy each attribute
        for k, v in self.__dict__.items():
            if k == &#34;base_class&#34;:
                # The base_class should not be deeply copied; it&#39;s a class reference
                setattr(copie, k, self.base_class)
            else:
                # Deep copy other attributes
                setattr(copie, k, copy.deepcopy(v, memo))

        return copie # return copied instance


    @property
    def base_class_name(self):
        &#34;&#34;&#34;
        Returns the name of the base_class as a lowercase string.

        Returns:
            str: The lowercase name of the base_class.
        &#34;&#34;&#34;
        if isinstance(self.base_class, forcefield):
            return self.base_class.__class__.__name__.lower()
        else:
            raise TypeError(&#34;base_class is not an instance of a forcefield subclass.&#34;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dforcefield.dforcefield.RULES"><code class="name">var <span class="ident">RULES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dforcefield.dforcefield.extract_default_parameters"><code class="name flex">
<span>def <span class="ident">extract_default_parameters</span></span>(<span>base_class, method_name=None, displayflag=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract default parameters from the base class or its method by instantiating the class.</p>
<p>If the base class is derived from <code><a title="dforcefield.generic" href="#dforcefield.generic">generic</a></code>, this function will also extract RULES, LOCAL,
and GLOBAL attributes if they are defined once the instance is created.</p>
<h2 id="parameters">Parameters:</h2>
<p>base_class : class
The base class from which to extract default parameterforcefield values or a method.
method_name : str, optional
The name of the method to call on the instance, if applicable (e.g., <code>newtonianfluid</code>).
displayflag : bool, optional (default=True)
If True, prints a message when no default parameters are found.</p>
<h2 id="returns">Returns:</h2>
<p>dict
A dictionary containing the default parameters extracted from the base class or method.
Also includes RULES, LOCAL, and GLOBAL if applicable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def extract_default_parameters(cls, base_class, method_name=None, displayflag=True):
    &#34;&#34;&#34;
    Extract default parameters from the base class or its method by instantiating the class.

    If the base class is derived from `generic`, this function will also extract RULES, LOCAL,
    and GLOBAL attributes if they are defined once the instance is created.

    Parameters:
    -----------
    base_class : class
        The base class from which to extract default parameterforcefield values or a method.
    method_name : str, optional
        The name of the method to call on the instance, if applicable (e.g., `newtonianfluid`).
    displayflag : bool, optional (default=True)
        If True, prints a message when no default parameters are found.

    Returns:
    --------
    dict
        A dictionary containing the default parameters extracted from the base class or method.
        Also includes RULES, LOCAL, and GLOBAL if applicable.
    &#34;&#34;&#34;
    extracted_info = {
        &#34;parameters&#34;: parameterforcefield(),
        &#34;RULES&#34;: genericdata(),
        &#34;GLOBAL&#34;: genericdata(),
        &#34;LOCAL&#34;: genericdata()
    }

    try:
        # Create an instance of the base class
        instance = base_class()

        # Extract parameters if the instance has them
        if hasattr(instance, &#39;parameters&#39;) and isinstance(instance.parameters, parameterforcefield):
            extracted_info[&#34;parameters&#34;] = instance.parameters

        # Extract RULES, GLOBAL, and LOCAL if they exist
        for attr in [&#34;RULES&#34;, &#34;GLOBAL&#34;, &#34;LOCAL&#34;]:
            if hasattr(instance, attr) and isinstance(getattr(instance, attr), parameterforcefield):
                extracted_info[attr] = getattr(instance, attr)

        # If a method is specified, call it to get additional parameters
        if method_name and hasattr(instance, method_name):
            method = getattr(instance, method_name)
            if callable(method):
                try:
                    result = method()  # Call the method (ensure it returns the desired forcefield object)
                    if hasattr(result, &#39;parameters&#39;) and isinstance(result.parameters, parameterforcefield):
                        extracted_info[&#34;parameters&#34;] = result.parameters
                except Exception as e:
                    if displayflag:
                        print(f&#34;Error calling method {method_name} on {base_class.__name__}: {str(e)}&#34;)

    except TypeError as e:
        if displayflag:
            print(f&#34;Could not instantiate {base_class.__name__}: {str(e)}&#34;)

    # If no parameters found or cannot instantiate the class, return None
    if displayflag and not extracted_info[&#34;parameters&#34;]:
        print(f&#34;No default parameters found in {base_class.__name__} or its ancestors.&#34;)

    return extracted_info</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a dforcefield instance from a dictionary, including RULES, GLOBAL, and LOCAL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the attributes to initialize the dforcefield.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code></dt>
<dd>A new dforcefield instance.</dd>
</dl>
<h2 id="example">Example</h2>
<p>config = {
"name": "water_ff",
"description": "water forcefield",
"beadtype": 2,
"userid": "water_sim",
"version": 1.0,
"parameters": {"rho": 1000, "sigma": 0.5},
"base_class": "ulsph",
"RULES": {"some_rule": "value"},
"GLOBAL": {"global_param": 10},
"LOCAL": {"local_param": 5}
}</p>
<p>new_ff = dforcefield.from_dict(config)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls, data):
    &#34;&#34;&#34;
    Create a dforcefield instance from a dictionary, including RULES, GLOBAL, and LOCAL.

    Args:
        data (dict): A dictionary containing the attributes to initialize the dforcefield.

    Returns:
        dforcefield: A new dforcefield instance.

    Example:
        config = {
            &#34;name&#34;: &#34;water_ff&#34;,
            &#34;description&#34;: &#34;water forcefield&#34;,
            &#34;beadtype&#34;: 2,
            &#34;userid&#34;: &#34;water_sim&#34;,
            &#34;version&#34;: 1.0,
            &#34;parameters&#34;: {&#34;rho&#34;: 1000, &#34;sigma&#34;: 0.5},
            &#34;base_class&#34;: &#34;ulsph&#34;,
            &#34;RULES&#34;: {&#34;some_rule&#34;: &#34;value&#34;},
            &#34;GLOBAL&#34;: {&#34;global_param&#34;: 10},
            &#34;LOCAL&#34;: {&#34;local_param&#34;: 5}
        }

        new_ff = dforcefield.from_dict(config)
    &#34;&#34;&#34;
    # Extract base class information
    base_class_name = data.pop(&#34;base_class&#34;, None)
    base_class = globals().get(base_class_name) if base_class_name else None

    # Extract RULES, GLOBAL, and LOCAL from the data dictionary if they exist
    rules = data.pop(&#34;RULES&#34;, parameterforcefield())
    global_params = data.pop(&#34;GLOBAL&#34;, parameterforcefield())
    local_params = data.pop(&#34;LOCAL&#34;, parameterforcefield())

    # Create and return the new dforcefield instance with extracted or default RULES, GLOBAL, and LOCAL
    return cls(
        base_class=base_class,
        RULES=rules,
        GLOBAL=global_params,
        LOCAL=local_params,
        **data
    )</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.list_forcefield_subclasses"><code class="name flex">
<span>def <span class="ident">list_forcefield_subclasses</span></span>(<span>printflag=True, additional_modules=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class method to list all subclasses of the <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code> and <code><a title="dforcefield.generic" href="#dforcefield.generic">generic</a></code> classes, including their methods.</p>
<h2 id="parameters">Parameters:</h2>
<p>printflag : bool, optional (default=True)
If True, prints the subclasses of <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code>, <code><a title="dforcefield.generic" href="#dforcefield.generic">generic</a></code>, their load status, and their default parameters.
additional_modules : module or list of modules, optional
A module or list of additional modules to search for subclasses and methods.</p>
<h2 id="returns">Returns:</h2>
<p>dict
A dictionary where keys are class names or method names and values are dictionaries containing:
- "loaded": Whether the class or method is already loaded in memory.
- "module": The module path of the class or method.
- "default_parameters": Extracted parameters, RULES, LOCAL, and GLOBAL from the class or method.
dict
A dictionary mapping short names to full names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def list_forcefield_subclasses(cls, printflag=True, additional_modules=None):
    &#34;&#34;&#34;
    Class method to list all subclasses of the `forcefield` and `generic` classes, including their methods.

    Parameters:
    -----------
    printflag : bool, optional (default=True)
        If True, prints the subclasses of `forcefield`, `generic`, their load status, and their default parameters.
    additional_modules : module or list of modules, optional
        A module or list of additional modules to search for subclasses and methods.

    Returns:
    --------
    dict
        A dictionary where keys are class names or method names and values are dictionaries containing:
        - &#34;loaded&#34;: Whether the class or method is already loaded in memory.
        - &#34;module&#34;: The module path of the class or method.
        - &#34;default_parameters&#34;: Extracted parameters, RULES, LOCAL, and GLOBAL from the class or method.
    dict
        A dictionary mapping short names to full names.
    &#34;&#34;&#34;
    subclasses = set()
    classes_to_check = [forcefield, generic]  # Start with both forcefield and generic

    # Ensure additional_modules is a list, even if it&#39;s a single module
    if additional_modules is not None and not isinstance(additional_modules, list):
        additional_modules = [additional_modules]

    # Include classes from additional modules
    if additional_modules:
        for mod in additional_modules:
            for name, obj in inspect.getmembers(mod):
                # Add classes that are subclasses of forcefield or generic
                if inspect.isclass(obj) and (issubclass(obj, forcefield) or issubclass(obj, generic)) and obj not in {forcefield, generic}:
                    subclasses.add(obj)
                    classes_to_check.append(obj)
                # Also add relevant high-level methods/functions that do not start with &#39;_&#39;
                elif (inspect.isfunction(obj) or inspect.ismethod(obj)) and not name.startswith(&#39;_&#39;):
                    # Check if the method belongs to a class derived from generic, not forcefield
                    parent_class_name = obj.__qualname__.split(&#39;.&#39;)[0]
                    parent_class = next((cls for cls in subclasses if cls.__name__ == parent_class_name), None)
                    if parent_class and issubclass(parent_class, generic) and not issubclass(parent_class, forcefield):
                        subclasses.add((parent_class, name, obj))  # Add (parent_class, method_name, function/method)

    # Traverse through all found subclasses
    while classes_to_check:
        parent_class = classes_to_check.pop()
        for subclass in parent_class.__subclasses__():
            subclasses.add(subclass)
            classes_to_check.append(subclass)

    # Prepare the output dictionary with load status flags and default parameters
    subclass_info = {}
    short_name_mapping = {}

    for subclass in subclasses:
        if inspect.isclass(subclass):
            class_name = subclass.__name__
            is_loaded = class_name in globals()  # Check if class is already loaded

            # Extract default parameters if they exist
            extracted_params = cls.extract_default_parameters(subclass, displayflag=False)
            num_defaults = len(extracted_params.get(&#39;parameters&#39;, {}).keys()) if extracted_params else None

            # Check if RULES, GLOBAL, and LOCAL are defined
            rules_defined = &#39;&#39;
            if extracted_params:
                rules_defined += &#39;R&#39; if extracted_params[&#34;RULES&#34;] else &#39;-&#39;
                rules_defined += &#39;G&#39; if extracted_params[&#34;GLOBAL&#34;] else &#39;-&#39;
                rules_defined += &#39;L&#39; if extracted_params[&#34;LOCAL&#34;] else &#39;-&#39;

            # Add entry for the class
            subclass_info[class_name] = {
                &#34;loaded&#34;: is_loaded,
                &#34;module&#34;: subclass.__module__,
                &#34;num_defaults&#34;: num_defaults,
                &#34;rules_defined&#34;: rules_defined if rules_defined else &#39;---&#39;  # Display as &#39;---&#39; if none defined
            }

            # Map short name to full name
            short_name_mapping[class_name] = class_name

            # Inspect and add high-level methods from the class itself if not forcefield
            if not issubclass(subclass, forcefield):
                for method_name, method in inspect.getmembers(subclass, predicate=inspect.isfunction):
                    if not method_name.startswith(&#39;_&#39;):  # Skip private methods
                        method_full_name = f&#34;{class_name}.{method_name}&#34;
                        extracted_method_params = cls.extract_default_parameters(subclass, method_name=method_name, displayflag=False)
                        num_defaults = len(extracted_method_params.get(&#39;parameters&#39;, {}).keys()) if extracted_method_params else None
                        rules_defined = extracted_method_params.get(&#34;rules_defined&#34;, &#34;---&#34;)
                        subclass_info[method_full_name] = {
                            &#34;loaded&#34;: True,
                            &#34;module&#34;: subclass.__module__,
                            &#34;num_defaults&#34;: num_defaults,
                            &#34;rules_defined&#34;: rules_defined
                        }
                        # Add method short name to mapping
                        short_name_mapping[method_name] = method_full_name

        else:
            # Handle function/method cases
            parent_class, func_name, func_obj = subclass
            is_loaded = func_name in globals() or parent_class.__module__ in sys.modules
            extracted_method_params = cls.extract_default_parameters(parent_class, method_name=func_name, displayflag=False)
            num_defaults = len(extracted_method_params.get(&#39;parameters&#39;, {}).keys()) if extracted_method_params else None
            rules_defined = extracted_method_params.get(&#34;rules_defined&#34;, &#34;---&#34;)
            func_full_name = f&#34;{parent_class.__name__}.{func_name}&#34;
            subclass_info[func_full_name] = {
                &#34;loaded&#34;: is_loaded,
                &#34;module&#34;: parent_class.__module__,
                &#34;num_defaults&#34;: num_defaults,
                &#34;rules_defined&#34;: rules_defined
            }
            # Add function/method to short names
            short_name_mapping[func_name] = func_full_name

    # Optionally print the subclasses and their load status with parameter info
    if printflag:
        print(&#34;List of available forcefields and relevant methods:\n&#34;)
        print(f&#34;{&#39;Short Name&#39;:&lt;15} {&#39;Class/Method Name&#39;:&lt;30} {&#39;Module Path&#39;:&lt;30} {&#39;Status&#39;:&lt;10} {&#39;Default Params&#39;:&lt;10} {&#39;RULES&#39;:&lt;5}&#34;)
        print(&#34;=&#34; * 105)
        for short_name, class_name in sorted(short_name_mapping.items(), key=lambda x: x[0]):
            info = subclass_info[class_name]
            status = &#34;Loaded&#34; if info[&#34;loaded&#34;] else &#34;Not Loaded&#34;
            num_defaults = info[&#34;num_defaults&#34;] if info[&#34;num_defaults&#34;] is not None else &#34;None&#34;
            rules_defined = info[&#34;rules_defined&#34;]
            print(f&#34;{short_name:&lt;15} {class_name:&lt;30} {info[&#39;module&#39;]:&lt;30} {status:&lt;10} {num_defaults:&lt;10} {rules_defined:&lt;5}&#34;)
        print(f&#34;\nTotal number of forcefields and methods: {len(subclass_info)}&#34;)

    return subclass_info, short_name_mapping</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filename, foldername=None, authentication=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a dforcefield instance from a file with more control over the folder location and file validation.</p>
<h2 id="args">Args:</h2>
<p>filename (str): The name of the file to load. The 'extension' parameter will be used if not present.
foldername (str): The folder from which to load the file. Defaults to a temporary directory.
authentication (bool): Whether to authenticate the file by checking the mandatory header line.
Defaults to True. If False, bypasses the authentication and parses the content directly.</p>
<h2 id="returns">Returns:</h2>
<p>dforcefield: A new dforcefield instance parsed from the file content.</p>
<h2 id="raises">Raises:</h2>
<p>FileNotFoundError: If the file does not exist.
ValueError: If authentication is True and the file does not start with the mandatory header.</p>
<h2 id="notes">Notes:</h2>
<ul>
<li>The method checks for the mandatory line "# DFORCEFIELD SAVE FILE" at the beginning of the file.
If authentication is False, this check is bypassed, allowing parsing of content generated by generate().</li>
<li>The file extension is expected to be '.txt' by default unless specified otherwise in the filename.</li>
</ul>
<h2 id="example-usage">Example Usage:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ff = dforcefield.load(&quot;forcefield.txt&quot;, authentication=True)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, filename, foldername=None, authentication=True):
    &#34;&#34;&#34;
    Load a dforcefield instance from a file with more control over the folder location and file validation.

    Args:
    -----
    filename (str): The name of the file to load. The &#39;extension&#39; parameter will be used if not present.
    foldername (str): The folder from which to load the file. Defaults to a temporary directory.
    authentication (bool): Whether to authenticate the file by checking the mandatory header line.
                        Defaults to True. If False, bypasses the authentication and parses the content directly.

    Returns:
    --------
    dforcefield: A new dforcefield instance parsed from the file content.

    Raises:
    -------
    FileNotFoundError: If the file does not exist.
    ValueError: If authentication is True and the file does not start with the mandatory header.

    Notes:
    ------
    - The method checks for the mandatory line &#34;# DFORCEFIELD SAVE FILE&#34; at the beginning of the file.
    If authentication is False, this check is bypassed, allowing parsing of content generated by generate().
    - The file extension is expected to be &#39;.txt&#39; by default unless specified otherwise in the filename.

    Example Usage:
    --------------
    &gt;&gt;&gt; ff = dforcefield.load(&#34;forcefield.txt&#34;, authentication=True)
    &#34;&#34;&#34;
    # Determine file extension and ensure it ends with &#39;.txt&#39;
    if not filename.endswith(&#39;.txt&#39;):
        filename += &#39;.txt&#39;

    # Determine foldername
    if foldername is None:
        foldername = tempfile.gettempdir()

    # Construct full file path
    if not os.path.isabs(filename):
        filepath = os.path.join(foldername, filename)
    else:
        filepath = filename

    # Check if file exists
    if not os.path.exists(filepath):
        raise FileNotFoundError(f&#34;The file &#39;{filepath}&#39; does not exist.&#34;)

    # Read the file contents
    with open(filepath, &#39;r&#39;) as f:
        content = f.read()

    # Call the parse method to create a new dforcefield instance
    return cls.parsesyntax(content, authentication=authentication)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.parsesyntax"><code class="name flex">
<span>def <span class="ident">parsesyntax</span></span>(<span>content, authentication=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the string content of a forcefield file to create a dforcefield instance.</p>
<h2 id="args">Args:</h2>
<p>content (str): The string content to be parsed.
authentication (bool): Whether to authenticate the content by checking the mandatory header line.
Defaults to True. If False, bypasses the authentication.</p>
<h2 id="returns">Returns:</h2>
<p>dforcefield
A new <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance populated with the parsed content.</p>
<h2 id="raises">Raises:</h2>
<p>ValueError
- If authentication is True and the content does not start with the correct mandatory header line.
- If the content format is invalid.
- If base_class is not a valid subclass of forcefield.</p>
<h2 id="notes">Notes:</h2>
<ul>
<li>Handles different sections including parameters, name, and description.</li>
<li>Accepts empty lines and comments.</li>
<li>Uses { } for attributes blocks.</li>
<li>If authentication is False, it does not check for the mandatory header line.</li>
<li>Recognizes <code>beadtype</code>, <code>userid</code>, and <code>version</code> as special attributes. If they are not present,
they are included in the <code>parameters</code>.</li>
</ul>
<h2 id="example-usage">Example Usage:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ff = dforcefield.parsesyntax(content_string, authentication=True)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parsesyntax(cls, content, authentication=True):
    &#34;&#34;&#34;
    Parse the string content of a forcefield file to create a dforcefield instance.

    Args:
    -----
    content (str): The string content to be parsed.
    authentication (bool): Whether to authenticate the content by checking the mandatory header line.
                           Defaults to True. If False, bypasses the authentication.

    Returns:
    --------
    dforcefield
        A new `dforcefield` instance populated with the parsed content.

    Raises:
    -------
    ValueError
        - If authentication is True and the content does not start with the correct mandatory header line.
        - If the content format is invalid.
        - If base_class is not a valid subclass of forcefield.

    Notes:
    ------
    - Handles different sections including parameters, name, and description.
    - Accepts empty lines and comments.
    - Uses { } for attributes blocks.
    - If authentication is False, it does not check for the mandatory header line.
    - Recognizes `beadtype`, `userid`, and `version` as special attributes. If they are not present,
      they are included in the `parameters`.

    Example Usage:
    --------------
    &gt;&gt;&gt; ff = dforcefield.parsesyntax(content_string, authentication=True)
    &#34;&#34;&#34;
    # Split the content into lines
    lines = content.splitlines()
    lines = [line for line in lines if line.strip()]  # Remove blank or empty lines

    # Raise an error if no content is left after removing blank lines
    if not lines:
        raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

    # Initialize containers for parsed data
    inside_global_params = False
    global_params_content = &#34;&#34;
    parameters = {}
    description = {}
    name = {}
    base_class_name = None

    # Step 1: Authenticate the file by checking the first line
    if authentication:
        if not lines[0].strip().startswith(&#34;# DFORCEFIELD SAVE FILE&#34;):
            raise ValueError(&#34;File/Content is not a valid DFORCEFIELD file.&#34;)
        # Remove the mandatory header line from processing
        lines = lines[1:]

    # Step 2: Process each line dynamically
    for line in lines:
        stripped = line.strip()

        # Ignore empty lines and comments
        if not stripped or stripped.startswith(&#34;#&#34;):
            continue

        # Remove trailing comments
        stripped = remove_comments(stripped)

        # Handle description and name blocks first to avoid parsing them as parameters
        if stripped.startswith(&#34;description:{&#34;):
            desc_content = stripped[len(&#34;description:{&#34;):].strip()
            # Check if the block ends on the same line
            if desc_content.endswith(&#34;}&#34;):
                desc_content = desc_content[:-1].strip()
                cls._parse_struct_block(desc_content, description)
            else:
                # Multiline description block
                desc_content = desc_content
                while not stripped.endswith(&#34;}&#34;):
                    next_line = next(iter(lines), &#34;&#34;).strip()
                    stripped = next_line
                    desc_content += &#34; &#34; + cls.remove_comments(next_line)
                desc_content = desc_content[:-1].strip()
                cls._parse_struct_block(desc_content, description)
            continue  # Skip further processing for this line

        if stripped.startswith(&#34;name:{&#34;):
            name_content = stripped[len(&#34;name:{&#34;):].strip()
            # Check if the block ends on the same line
            if name_content.endswith(&#34;}&#34;):
                name_content = name_content[:-1].strip()
                cls._parse_struct_block(name_content, name)
            else:
                # Multiline name block
                name_content = name_content
                while not stripped.endswith(&#34;}&#34;):
                    next_line = next(iter(lines), &#34;&#34;).strip()
                    stripped = next_line
                    name_content += &#34; &#34; + cls.remove_comments(next_line)
                name_content = name_content[:-1].strip()
                cls._parse_struct_block(name_content, name)
            continue  # Skip further processing for this line

        # Handle global parameters inside {...}
        if stripped.startswith(&#34;{&#34;):
            inside_global_params = True
            global_params_content = stripped[1:].strip()
            # Check if the block ends on the same line
            if &#39;}&#39; in global_params_content:
                global_params_content = global_params_content.split(&#39;}&#39;, 1)[0].strip()
                inside_global_params = False
                cls._parse_global_params(global_params_content, parameters)
                global_params_content = &#34;&#34;
            continue  # Skip further processing for this line

        if inside_global_params:
            if &#39;}&#39; in stripped:
                global_params_content += &#34; &#34; + stripped.split(&#39;}&#39;, 1)[0].strip()
                inside_global_params = False
                cls._parse_global_params(global_params_content, parameters)
                global_params_content = &#34;&#34;
            else:
                global_params_content += &#34; &#34; + stripped
            continue  # Continue to next line

        # Handle key-value pairs
        if &#34;=&#34; in stripped:
            key, value = stripped.split(&#34;=&#34;, 1)
            key = key.strip()
            value = value.strip().strip(&#39;&#34;&#39;).strip(&#34;&#39;&#34;)
            if key == &#34;base_class&#34;:
                # Store the class name, do not load
                base_class_name = value
            elif key in {&#34;beadtype&#34;, &#34;userid&#34;, &#34;version&#34;}:
                parameters[key] = cls._convert_value(value)
            else:
                parameters[key] = cls._convert_value(value)
            continue  # Skip further processing for this line

    # Step 3: Handle special attributes (beadtype, userid, version)
    # Extract beadtype
    beadtype = parameters.pop(&#39;beadtype&#39;, None)
    if beadtype is not None:
        try:
            beadtype = int(beadtype)
        except ValueError:
            raise ValueError(f&#34;Invalid value for beadtype: {beadtype}. It must be an integer.&#34;)
    else:
        beadtype = 1  # Default value
        parameters[&#39;beadtype&#39;] = beadtype

    # Extract userid
    userid = parameters.pop(&#39;userid&#39;, None)
    if userid is not None:
        userid = str(userid)
    else:
        userid = &#34;unknown&#34;  # Default value
        parameters[&#39;userid&#39;] = userid

    # Extract version
    version = parameters.pop(&#39;version&#39;, None)
    if version is not None:
        try:
            version = float(version)
        except ValueError:
            raise ValueError(f&#34;Invalid value for version: {version}. It must be a float.&#34;)
    else:
        version = 0.1  # Default value
        parameters[&#39;version&#39;] = version

    # Step 4: Validate base_class and create a new dforcefield instance
    if base_class_name is None:
        raise ValueError(&#34;base_class must be specified and valid in the forcefield file.&#34;)

    #â™  Dynamically set the base class based on the string value (e.g., &#34;tlsph&#34;)
    resolved_base_class  = cls._load_base_class(base_class_name)
    if resolved_base_class is None or not issubclass(resolved_base_class, forcefield):
        value = str(resolved_base_class)
        raise ValueError(f&#34;Invalid base_class: &#39;{value}&#39; must be a subclass of forcefield.&#34;)

    # Step 6: Create and return the new dforcefield instance
    newFF = cls(
        base_class=resolved_base_class,
        beadtype=beadtype,
        userid=userid,
        name=struct(**name),
        description=struct(**description),
        version=version,
        USER=parameterforcefield(**parameters)
    )

    # Step 6: Detect variables in templates and propagate undefined variables
    dvars = newFF.detectVariables()
    newFF.parameters = dvars + newFF.parameters
    return newFF</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dforcefield.dforcefield.base_class_name"><code class="name">var <span class="ident">base_class_name</span></code></dt>
<dd>
<div class="desc"><p>Returns the name of the base_class as a lowercase string.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The lowercase name of the base_class.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def base_class_name(self):
    &#34;&#34;&#34;
    Returns the name of the base_class as a lowercase string.

    Returns:
        str: The lowercase name of the base_class.
    &#34;&#34;&#34;
    if isinstance(self.base_class, forcefield):
        return self.base_class.__class__.__name__.lower()
    else:
        raise TypeError(&#34;base_class is not an instance of a forcefield subclass.&#34;)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.merged_name_description"><code class="name">var <span class="ident">merged_name_description</span></code></dt>
<dd>
<div class="desc"><p>Return a struct containing the merged content of 'name' and 'description'.
If an attribute exists in both, their values are combined into a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def merged_name_description(self):
    &#34;&#34;&#34;
    Return a struct containing the merged content of &#39;name&#39; and &#39;description&#39;.
    If an attribute exists in both, their values are combined into a list.
    &#34;&#34;&#34;
    merged_data = {}

    # Add attributes from &#39;name&#39; if it&#39;s a struct
    if isinstance(self.name, struct):
        merged_data.update(self.name.__dict__)

    # Add/merge attributes from &#39;description&#39; if it&#39;s a struct
    if isinstance(self.description, struct):
        for key, value in self.description.__dict__.items():
            if key in merged_data:
                # Combine the values into a list if the key already exists
                existing_value = merged_data[key]
                if not isinstance(existing_value, list):
                    existing_value = [existing_value]  # Convert to list if not already a list
                merged_data[key] = existing_value + [value]  # Add the new value to the list
            else:
                merged_data[key] = value

    # Return the merged struct
    return struct(**merged_data)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.script"><code class="name">var <span class="ident">script</span></code></dt>
<dd>
<div class="desc"><p>Return the raw content of the pair_* outputs combined into a single script-like format.</p>
<h2 id="returns">Returns:</h2>
<p>str
The raw outputs from pair_style, pair_diagcoeff, and pair_offdiagcoeff concatenated into a script.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def script(self):
    &#34;&#34;&#34;
    Return the raw content of the pair_* outputs combined into a single script-like format.

    Returns:
    --------
    str
        The raw outputs from pair_style, pair_diagcoeff, and pair_offdiagcoeff concatenated into a script.
    &#34;&#34;&#34;
    # Get the raw outputs from the pair_* methods
    pair_style_output = self.pair_style(printflag=False, raw=True)
    pair_diagcoeff_output = self.pair_diagcoeff(printflag=False, raw=True)
    pair_offdiagcoeff_output = self.pair_offdiagcoeff(printflag=False, raw=True)

    # Combine the outputs into a script-like format
    script_content = &#34;\n&#34;.join([
        &#34;# Script output from dforcefield:&#34;,
        &#34;# Pair style:&#34;,
        pair_style_output,
        &#34;\n# Diagonal coefficients:&#34;,
        pair_diagcoeff_output,
        &#34;\n# Off-diagonal coefficients:&#34;,
        pair_offdiagcoeff_output
    ])

    return script_content</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dforcefield.dforcefield.base_repr"><code class="name flex">
<span>def <span class="ident">base_repr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the representation of the base_class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_repr(self):
    &#34;&#34;&#34;Returns the representation of the base_class.&#34;&#34;&#34;
    self.base_class.__repr__()
    return self.base_class.__str__()</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.combine_parameters"><code class="name flex">
<span>def <span class="ident">combine_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine GLOBAL, LOCAL, and RULES to get the current parameter configuration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_parameters(self):
    &#34;&#34;&#34;
    Combine GLOBAL, LOCAL, and RULES to get the current parameter configuration.
    &#34;&#34;&#34;
    return self.GLOBAL + self.LOCAL + self.RULES</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, other, printflag=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare the current instance with another dforcefield instance, including RULES, GLOBAL, and LOCAL.</p>
<h2 id="args">Args:</h2>
<p>other : dforcefield
The other instance to compare.</p>
<p>printflag : bool, optional (default: False)
If True, prints a table showing all parameters, with differences marked by '*'.</p>
<h2 id="returns">Returns:</h2>
<p>dict
A dictionary showing differences between the two instances.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError: If the other object is not a dforcefield instance.</p>
<h2 id="example">Example:</h2>
<p>diffs = dynamic_water.compare(dynamic_salt)
if printflag:
Prints a comparison table with a type column and a legend at the end.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare(self, other, printflag=False):
    &#34;&#34;&#34;
    Compare the current instance with another dforcefield instance, including RULES, GLOBAL, and LOCAL.

    Args:
    -----
    other : dforcefield
        The other instance to compare.

    printflag : bool, optional (default: False)
        If True, prints a table showing all parameters, with differences marked by &#39;*&#39;.

    Returns:
    --------
    dict
        A dictionary showing differences between the two instances.

    Raises:
    -------
    TypeError: If the other object is not a dforcefield instance.

    Example:
    --------
    diffs = dynamic_water.compare(dynamic_salt)
    if printflag:
        Prints a comparison table with a type column and a legend at the end.
    &#34;&#34;&#34;
    # Define abbreviations for types
    type_abbreviations = {
        str: &#39;STR&#39;,
        int: &#39;INT&#39;,
        float: &#39;FLT&#39;,
        bool: &#39;BOOL&#39;,
        list: &#39;LST&#39;,
        tuple: &#39;TPL&#39;,
        dict: &#39;DCT&#39;,
        None: &#39;NON&#39;,
        &#39;missing&#39;: &#39;MIS&#39;
    }

    def get_type_abbrev(value):
        &#34;&#34;&#34;Return the abbreviation for the type of the value.&#34;&#34;&#34;
        if value is None:
            return type_abbreviations[None]
        return type_abbreviations.get(type(value), &#39;UNK&#39;)  # Use &#39;UNK&#39; for unknown types

    def format_simple_type(value):
        &#34;&#34;&#34;Format a simple value (str, number, or bool) for display.&#34;&#34;&#34;
        return self.dispmax(str(value))

    def format_iterable(value_self, value_other, key, comparison_table, difference):
        &#34;&#34;&#34;Handle lists, tuples, and other iterable types.&#34;&#34;&#34;
        max_length = max(len(value_self), len(value_other))
        for i in range(max_length):
            item_self = value_self[i] if i &lt; len(value_self) else &#39;MISSING&#39;
            item_other = value_other[i] if i &lt; len(value_other) else &#39;MISSING&#39;
            sub_difference = &#39;*&#39; if item_self != item_other else &#39; &#39;
            comparison_table.append(
                f&#34;  {key if i == 0 else &#39;&#39;:&lt;15}: {sub_difference:^3}: {self.dispmax(str(item_self)):&lt;30}: {get_type_abbrev(item_self):&lt;5}: {self.dispmax(str(item_other)):&lt;30}: {get_type_abbrev(item_other):&lt;5}&#34;
            )

    def format_dict_like(value_self, value_other, key, comparison_table, difference):
        &#34;&#34;&#34;Handle dictionary-like objects (e.g., structs or dicts).&#34;&#34;&#34;
        comparison_table.append(f&#34;  {key:&lt;15}: {difference:^3}: &#34;)
        comparison_table.append(f&#34;  {&#39;&#39;:&lt;15}  {&#39;Self&#39;:&lt;30} {&#39;Type&#39;:&lt;5} {&#39;Other&#39;:&lt;30} {&#39;Type&#39;:&lt;5}&#34;)
        sub_sep = &#34;  &#34;+&#34;-&#34;*15+&#34;:&#34;+&#34;-&#34;*3+&#34;:&#34;+&#34;-&#34;*30+&#34;:&#34;+&#34;-&#34;*5+&#34;:&#34;+&#34;-&#34;*30+&#34;:&#34;+&#34;-&#34;*5
        comparison_table.append(sub_sep)
        sub_keys = set(value_self.keys()).union(value_other.keys())
        for sub_key in sorted(sub_keys):
            sub_value_self = value_self.get(sub_key, &#39;MISSING&#39;)
            sub_value_other = value_other.get(sub_key, &#39;MISSING&#39;)
            sub_difference = &#39;*&#39; if sub_value_self != sub_value_other else &#39; &#39;
            comparison_table.append(
                f&#34;  {sub_key:&lt;15}: {sub_difference:^3}: {self.dispmax(str(sub_value_self)):&lt;30}: {get_type_abbrev(sub_value_self):&lt;5}: {self.dispmax(str(sub_value_other)):&lt;30}: {get_type_abbrev(sub_value_other):&lt;5}&#34;
            )
        comparison_table.append(sub_sep)

    def format_complex_type(value_self, value_other, key, comparison_table, difference):
        &#34;&#34;&#34;Handle complex types, expanding them into multiple lines.&#34;&#34;&#34;
        value_self_lines = str(value_self).splitlines()
        value_other_lines = str(value_other).splitlines()
        max_lines = max(len(value_self_lines), len(value_other_lines))
        for i in range(max_lines):
            line_self = value_self_lines[i] if i &lt; len(value_self_lines) else &#39;MISSING&#39;
            line_other = value_other_lines[i] if i &lt; len(value_other_lines) else &#39;MISSING&#39;
            comparison_table.append(
                f&#34;  {key if i == 0 else &#39;&#39;:&lt;15}: {difference if i == 0 else &#39; &#39;:^3}: {self.dispmax(line_self):&lt;30}: {get_type_abbrev(line_self):&lt;5}: {self.dispmax(line_other):&lt;30}: {get_type_abbrev(line_other):&lt;5}&#34;
            )

    if not isinstance(other, dforcefield):
        raise TypeError(&#34;Can only compare with another dforcefield instance.&#34;)

    diffs = {}

    # Collect all keys from both instances, including RULES, GLOBAL, and LOCAL
    all_keys = set(self.keys()).union(other.keys(), {&#39;RULES&#39;, &#39;GLOBAL&#39;, &#39;LOCAL&#39;})

    # Iterate over all keys and compare the values
    for key in all_keys:
        value_self = getattr(self, key, None)
        value_other = getattr(other, key, None)

        if value_self != value_other:
            diffs[key] = {&#34;self&#34;: value_self, &#34;other&#34;: value_other}

    # If printflag is True, print the comparison in a table format
    if printflag:
        sep = &#34;  &#34;+&#34;-&#34;*15 + &#34;:&#34; + &#34;-&#34;*3 + &#34;:&#34; + &#34;-&#34;*30 + &#34;:&#34; + &#34;-&#34;*5 + &#34;:&#34; + &#34;-&#34;*30 + &#34;:&#34; + &#34;-&#34;*5
        header = f&#34;\n  {&#39;Attribute&#39;:&lt;15}: {&#39;*&#39;:^3}: {&#39;Self&#39;:&lt;30}: {&#39;Type&#39;:&lt;5}: {&#39;Other&#39;:&lt;30}: {&#39;Type&#39;:&lt;5}\n&#34; + sep
        comparison_table = [header]

        # Iterate over all parameters and mark differences with &#39;*&#39;
        for key in sorted(all_keys):  # Sort keys for a cleaner output
            value_self = getattr(self, key, &#39;MISSING&#39;)
            value_other = getattr(other, key, &#39;MISSING&#39;)
            difference = &#39;*&#39; if value_self != value_other else &#39; &#39;

            # Check if the value is a simple type (str, number, or bool)
            if isinstance(value_self, (str, int, float, bool)) and isinstance(value_other, (str, int, float, bool)):
                comparison_table.append(
                    f&#34;  {key:&lt;15}: {difference:^3}: {format_simple_type(value_self):&lt;30}: {get_type_abbrev(value_self):&lt;5}: {format_simple_type(value_other):&lt;30}: {get_type_abbrev(value_other):&lt;5}&#34;
                )
            # Check if the value is a list or tuple
            elif isinstance(value_self, (list, tuple)) and isinstance(value_other, (list, tuple)):
                format_iterable(value_self, value_other, key, comparison_table, difference)
            # Check if the value is a dictionary-like object
            elif hasattr(value_self, &#39;keys&#39;) and hasattr(value_other, &#39;keys&#39;):
                format_dict_like(value_self, value_other, key, comparison_table, difference)
            else:
                # Handle other complex types
                format_complex_type(value_self, value_other, key, comparison_table, difference)

        comparison_table.append(sep)
        # Add a legend for type abbreviations
        legend = &#34;\nType Legend: &#34; + &#34;, &#34;.join(f&#34;{abbrev} = {(&#39;NoneType&#39; if type_ is None else type_.__name__.upper())}&#34; for type_, abbrev in type_abbreviations.items() if type_ != &#39;missing&#39;)

        comparison_table.append(legend)

        # Print the comparison table
        print(&#34;\n&#34;.join(comparison_table))

    return diffs</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, beadtype=None, userid=None, name=None, description=None, version=None, USER=forcefield (FF object) with 0 parameters, RULES=None, GLOBAL=None, LOCAL=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new instance of dforcefield with the option to override key attributes including RULES, GLOBAL, and LOCAL.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, beadtype=None, userid=None, name=None, description=None, version=None, USER=parameterforcefield(), RULES=None, GLOBAL=None, LOCAL=None, **kwargs):
    &#34;&#34;&#34;
    Create a new instance of dforcefield with the option to override key attributes including RULES, GLOBAL, and LOCAL.
    &#34;&#34;&#34;
    # Use the current instance&#39;s values as defaults, and override if values are provided
    new_beadtype = beadtype if beadtype is not None else self.beadtype
    new_userid = userid if userid is not None else self.userid
    new_name = name if name is not None else self.name
    new_description = description if description is not None else self.description
    new_version = version if version is not None else self.version
    if new_userid == self.userid:
        new_userid = new_userid + &#34; (copy)&#34;
    # updated USER
    new_USER = self.parameters + USER
    # updated parameters
    new_parameters = self.parameters + parameterforcefield(**kwargs)
    # Combine or override RULES, GLOBAL, and LOCAL if provided
    new_rules = RULES if RULES is not None else self.RULES
    new_global = GLOBAL if GLOBAL is not None else self.GLOBAL
    new_local = LOCAL if LOCAL is not None else self.LOCAL
    # Create and return the new instance with overridden values
    return self.__class__(
        base_class=self.base_class.__class__,
        beadtype=new_beadtype,
        userid=new_userid,
        name=new_name,
        description=new_description,
        version=new_version,
        USER=new_USER,
        RULES=new_rules,
        GLOBAL=new_global,
        LOCAL=new_local,
        **new_parameters
    )</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.detectVariables"><code class="name flex">
<span>def <span class="ident">detectVariables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects variables in the form ${variable} from the outputs of pair_style, pair_diagcoeff,
and pair_offdiagcoeff.</p>
<h2 id="returns">Returns:</h2>
<p>struct
A struct containing the detected variable names that are not yet defined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detectVariables(self):
    &#34;&#34;&#34;
    Detects variables in the form ${variable} from the outputs of pair_style, pair_diagcoeff,
    and pair_offdiagcoeff.

    Returns:
    --------
    struct
        A struct containing the detected variable names that are not yet defined.
    &#34;&#34;&#34;
    # Extract variables from pair_style, pair_diagcoeff, and pair_offdiagcoeff
    detected_vars = set()

    # Define a regex pattern to detect variables in the form ${variable}
    pattern = r&#39;\$\{(\w+)\}&#39;

    # Detect variables in pair_style output
    pair_style_output = self.pair_style(printflag=False, raw=True)
    detected_vars.update(re.findall(pattern, pair_style_output))

    # Detect variables in pair_diagcoeff output
    pair_diagcoeff_output = self.pair_diagcoeff(printflag=False, raw=True)
    detected_vars.update(re.findall(pattern, pair_diagcoeff_output))

    # Detect variables in pair_offdiagcoeff output
    pair_offdiagcoeff_output = self.pair_offdiagcoeff(printflag=False, raw=True)
    detected_vars.update(re.findall(pattern, pair_offdiagcoeff_output))

    # Convert the detected variables into a parameterforcefield() for further propagation
    return parameterforcefield(**{var: &#34;${&#34; + var + &#34;}&#34; for var in detected_vars})</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.dispmax"><code class="name flex">
<span>def <span class="ident">dispmax</span></span>(<span>self, content)</span>
</code></dt>
<dd>
<div class="desc"><p>optimize display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispmax(self,content):
    &#34;&#34;&#34; optimize display &#34;&#34;&#34;
    strcontent = str(content)
    if len(strcontent)&gt;self._maxdisplay:
        nchar = round(self._maxdisplay/2)
        return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
    else:
        return content</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the forcefield definition as a formatted string without traceability features.</p>
<h2 id="returns">Returns:</h2>
<p>str: A string containing the formatted forcefield definition, including headers for attributes,
descriptions, names, and parameters, but excluding traceability information such as host, date, and user.</p>
<h2 id="example-output">Example Output:</h2>
<p>base_class="tlsph"
beadtype = 1
userid = "dynamic_water"
version = 1.0</p>
<h1 id="description-of-the-forcefield">Description of the forcefield</h1>
<p>description:{forcefield="LAMMPS:SMD", style="tlsph", material="water"}</p>
<h1 id="name-of-the-forcefield">Name of the forcefield</h1>
<p>name:{forcefield="LAMMPS:SMD", material="water"}</p>
<h1 id="parameters-for-the-forcefield">Parameters for the forcefield</h1>
<p>rho = 1000
E = "5<em>${c0}^2</em>${rho}"
nu = 0.3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self):
    &#34;&#34;&#34;
    Generate the forcefield definition as a formatted string without traceability features.

    Returns:
    --------
    str: A string containing the formatted forcefield definition, including headers for attributes,
         descriptions, names, and parameters, but excluding traceability information such as host, date, and user.

    Example Output:
    ---------------
    base_class=&#34;tlsph&#34;
    beadtype = 1
    userid = &#34;dynamic_water&#34;
    version = 1.0

    # Description of the forcefield
    description:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;water&#34;}

    # Name of the forcefield
    name:{forcefield=&#34;LAMMPS:SMD&#34;, material=&#34;water&#34;}

    # Parameters for the forcefield
    rho = 1000
    E = &#34;5*${c0}^2*${rho}&#34;
    nu = 0.3
    &#34;&#34;&#34;
    # Construct forcefield attributes
    attributes = (
        f&#39;base_class=&#34;{self.base_class.__class__.__name__}&#34;\n&#39;
        f&#39;beadtype = {self.beadtype}\n&#39;
        f&#39;userid = &#34;{self.userid}&#34;\n&#39;
        f&#39;version = {self.version}\n\n&#39;
    )

    # Construct description
    description = (
        &#39;# Description of the forcefield\n&#39;
        f&#39;description:{{&#39; + &#39;, &#39;.join(f&#39;{key}=&#34;{value}&#34;&#39; for key, value in self.description.items()) + &#39;}\n\n&#39;
    )

    # Construct name
    name = (
        &#39;# Name of the forcefield\n&#39;
        f&#39;name:{{&#39; + &#39;, &#39;.join(f&#39;{key}=&#34;{value}&#34;&#39; for key, value in self.name.items()) + &#39;}\n\n&#39;
    )

    # Construct parameters
    parameters = &#39;# Parameters for the forcefield\n&#39;
    for key, value in self.parameters.items():
        parameters += f&#39;{key} = {value}\n&#39;

    # Combine all parts
    content = attributes + description + name + parameters
    return content</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.get_global"><code class="name flex">
<span>def <span class="ident">get_global</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the GLOBAL parameters for this dforcefield instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global(self):
    &#34;&#34;&#34;Return the GLOBAL parameters for this dforcefield instance.&#34;&#34;&#34;
    return self.GLOBAL</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.get_local"><code class="name flex">
<span>def <span class="ident">get_local</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the LOCAL parameters for this dforcefield instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_local(self):
    &#34;&#34;&#34;Return the LOCAL parameters for this dforcefield instance.&#34;&#34;&#34;
    return self.LOCAL</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.get_rules"><code class="name flex">
<span>def <span class="ident">get_rules</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the RULES parameters for this dforcefield instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rules(self):
    &#34;&#34;&#34;Return the RULES parameters for this dforcefield instance.&#34;&#34;&#34;
    return self.RULES</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an iterator over (key, value) pairs from the merged struct, parameters, and scalar attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34;
    Return an iterator over (key, value) pairs from the merged struct, parameters, and scalar attributes.
    &#34;&#34;&#34;
    # Yield items from merged struct
    for item in self.merged_name_description.__dict__.items():
        yield item

    # Yield items from parameters
    for item in self.parameters.items():
        yield item

    # Yield scalar attribute items
    yield (&#39;version&#39;, self.version)
    yield (&#39;userid&#39;, self.userid)
    yield (&#39;beadtype&#39;, self.beadtype)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the keys of the merged struct, parameters, and scalar attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34;
    Return the keys of the merged struct, parameters, and scalar attributes.
    &#34;&#34;&#34;
    keys_set = set(self.merged_name_description.__dict__.keys())
    keys_set.update(self.parameters.keys())
    keys_set.update([&#39;version&#39;, &#39;userid&#39;, &#39;beadtype&#39;])
    return list(keys_set)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.missingVariables"><code class="name flex">
<span>def <span class="ident">missingVariables</span></span>(<span>self, isimplicit_missing=True, output_aslist=False)</span>
</code></dt>
<dd>
<div class="desc"><p>List missing variables (undefined in parameters).</p>
<h2 id="parameters">Parameters:</h2>
<p>isimplicit_missing : bool, optional (default: True)
If True, variables defined implicitly as ${varname} in parameters are considered missing.</p>
<p>output_aslist : bool, optional (default: False)
If True, returns a list of missing variable names.
If False, returns a parameterforcefield-like structure with implicit definitions.</p>
<h2 id="returns">Returns:</h2>
<p>List of str or parameterforcefield
If output_aslist is True, returns a list of variable names that are missing from the parameters.
If output_aslist is False, returns a parameterforcefield-like structure with implicit definitions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def missingVariables(self, isimplicit_missing=True, output_aslist=False):
    &#34;&#34;&#34;
    List missing variables (undefined in parameters).

    Parameters:
    -----------
    isimplicit_missing : bool, optional (default: True)
        If True, variables defined implicitly as ${varname} in parameters are considered missing.

    output_aslist : bool, optional (default: False)
        If True, returns a list of missing variable names.
        If False, returns a parameterforcefield-like structure with implicit definitions.

    Returns:
    --------
    List of str or parameterforcefield
        If output_aslist is True, returns a list of variable names that are missing from the parameters.
        If output_aslist is False, returns a parameterforcefield-like structure with implicit definitions.
    &#34;&#34;&#34;
    # Detect all variables used in the forcefield using detectVariables
    detected_vars = self.detectVariables()

    # Initialize missing variables
    missing_vars = []

    # Initialize a dictionary to store variables as parameterforcefield when output_aslist=False
    missing_vars_struct = {}

    # Iterate over detected variables and check if they are missing in parameters
    for varname in detected_vars.keys():
        if varname not in self.parameters:
            # If the variable is missing, add it to both the list and struct
            missing_vars.append(varname)
            missing_vars_struct[varname] = &#34;${&#34; + varname + &#34;}&#34;
        elif isimplicit_missing:
            # If the variable exists but is implicitly defined as ${varname}, treat it as missing
            param_value = self.parameters.getattr(varname)
            if param_value == &#34;${&#34; + varname + &#34;}&#34;:
                missing_vars.append(varname)
                missing_vars_struct[varname] = &#34;${&#34; + varname + &#34;}&#34;

    # Return the result based on the output_aslist flag
    if output_aslist:
        return missing_vars
    else:
        return parameterforcefield(**missing_vars_struct)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.pair_diagcoeff"><code class="name flex">
<span>def <span class="ident">pair_diagcoeff</span></span>(<span>self, printflag=None, verbose=None, i=None, raw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Delegate pair_diagcoeff to the base class, ensuring it uses the correct attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_diagcoeff(self, printflag=None, verbose=None, i=None, raw=False):
    &#34;&#34;&#34;Delegate pair_diagcoeff to the base class, ensuring it uses the correct attributes.&#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = self.verbose if verbose is None else verbose
    self._inject_attributes()
    return self.base_class.pair_diagcoeff(printflag=printflag, verbose=verbose, i=i, raw=raw, USER=None, beadtype=self.beadtype, userid=self.userid)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.pair_offdiagcoeff"><code class="name flex">
<span>def <span class="ident">pair_offdiagcoeff</span></span>(<span>self, o=None, printflag=None, verbose=None, i=None, raw=False, oname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Delegate pair_offdiagcoeff to the base class, ensuring it uses the correct attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_offdiagcoeff(self, o=None, printflag=None, verbose=None, i=None, raw=False,oname=None):
    &#34;&#34;&#34;Delegate pair_offdiagcoeff to the base class, ensuring it uses the correct attributes.&#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = self.verbose if verbose is None else verbose
    self._inject_attributes()
    return self.base_class.pair_offdiagcoeff(o=o, printflag=printflag, verbose=verbose, i=i, raw=raw, USER=None, beadtype=self.beadtype, userid=self.userid,oname=oname)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.pair_style"><code class="name flex">
<span>def <span class="ident">pair_style</span></span>(<span>self, printflag=None, verbose=None, raw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Delegate pair_style to the base class, ensuring it uses the correct attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_style(self, printflag=None, verbose=None, raw=False):
    &#34;&#34;&#34;Delegate pair_style to the base class, ensuring it uses the correct attributes.&#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = self.verbose if verbose is None else verbose
    self._inject_attributes()
    return self.base_class.pair_style(printflag=printflag, verbose=verbose, raw=raw,USER=None, beadtype=self.beadtype, userid=self.userid)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the dforcefield instance to its initial state, reapplying the default values
including RULES, GLOBAL, and LOCAL.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;
    Reset the dforcefield instance to its initial state, reapplying the default values
    including RULES, GLOBAL, and LOCAL.
    &#34;&#34;&#34;
    # Preserve the current RULES, GLOBAL, and LOCAL or reset them
    current_rules = self.RULES
    current_global = self.GLOBAL
    current_local = self.LOCAL

    # Reinitialize the instance with existing or reset RULES, GLOBAL, and LOCAL
    self.__init__(
        base_class=self.base_class.__class__,
        beadtype=self.beadtype,
        userid=self.userid,
        name=self.name,
        description=self.description,
        version=self.version,
        RULES=current_rules,
        GLOBAL=current_global,
        LOCAL=current_local
        )</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename=None, foldername=None, overwrite=False, verbose=True, extension='.txt')</span>
</code></dt>
<dd>
<div class="desc"><p>Save the dforcefield instance to a file using the generated forcefield definition.</p>
<h2 id="args">Args:</h2>
<p>filename (str): The name of the file to save. Defaults to self.userid if not provided.
foldername (str): The folder in which to save the file. Defaults to a temporary directory.
overwrite (bool): Whether to overwrite the file if it already exists. Defaults to False.
verbose (bool): Whether to include traceability features (host, date, user) in the saved file.
Defaults to True.
extension (str): The file extension to use. Defaults to ".txt".</p>
<h2 id="raises">Raises:</h2>
<p>FileExistsError: If the file already exists and overwrite is False.</p>
<h2 id="notes">Notes:</h2>
<p>The saved file will always include the mandatory line "# DFORCEFIELD SAVE FILE".
If verbose is True, a header with traceability information (host, date, user) will be included.
The file extension can be customized via the 'extension' parameter.</p>
<h2 id="example-output-when-verbosetrue">Example Output when verbose=True:</h2>
<h1 id="dforcefield-save-file">DFORCEFIELD SAVE FILE</h1>
<h1 id="generated-on-2024-12-30-by-userhost">generated on 2024-12-30 by user@host</h1>
<h1 id="_1"></h1>
<h1 id="userid-dynamic_water">userid = "dynamic_water"</h1>
<p>base_class="tlsph"
beadtype = 1
userid = "dynamic_water"
version = 1.0</p>
<h1 id="description-of-the-forcefield">Description of the forcefield</h1>
<p>description:{forcefield="LAMMPS:SMD", style="tlsph", material="water"}</p>
<h1 id="name-of-the-forcefield">Name of the forcefield</h1>
<p>name:{forcefield="LAMMPS:SMD", material="water"}</p>
<h1 id="parameters-for-the-forcefield">Parameters for the forcefield</h1>
<p>rho = 1000
E = "5<em>${c0}^2</em>${rho}"
nu = 0.3</p>
<h2 id="example-output-when-verbosefalse">Example Output when verbose=False:</h2>
<h1 id="dforcefield-save-file_1">DFORCEFIELD SAVE FILE</h1>
<p>base_class="tlsph"
beadtype = 1
userid = "dynamic_water"
version = 1.0</p>
<h1 id="description-of-the-forcefield_1">Description of the forcefield</h1>
<p>description:{forcefield="LAMMPS:SMD", style="tlsph", material="water"}</p>
<h1 id="name-of-the-forcefield_1">Name of the forcefield</h1>
<p>name:{forcefield="LAMMPS:SMD", material="water"}</p>
<h1 id="parameters-for-the-forcefield_1">Parameters for the forcefield</h1>
<p>rho = 1000
E = "5<em>${c0}^2</em>${rho}"
nu = 0.3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename=None, foldername=None, overwrite=False, verbose=True, extension=&#34;.txt&#34;):
    &#34;&#34;&#34;
    Save the dforcefield instance to a file using the generated forcefield definition.

    Args:
    -----
    filename (str): The name of the file to save. Defaults to self.userid if not provided.
    foldername (str): The folder in which to save the file. Defaults to a temporary directory.
    overwrite (bool): Whether to overwrite the file if it already exists. Defaults to False.
    verbose (bool): Whether to include traceability features (host, date, user) in the saved file.
                    Defaults to True.
    extension (str): The file extension to use. Defaults to &#34;.txt&#34;.

    Raises:
    -------
    FileExistsError: If the file already exists and overwrite is False.

    Notes:
    ------
    The saved file will always include the mandatory line &#34;# DFORCEFIELD SAVE FILE&#34;.
    If verbose is True, a header with traceability information (host, date, user) will be included.
    The file extension can be customized via the &#39;extension&#39; parameter.

    Example Output when verbose=True:
    ---------------
    # DFORCEFIELD SAVE FILE
    # generated on 2024-12-30 by user@host
    #
    #   userid = &#34;dynamic_water&#34;

    base_class=&#34;tlsph&#34;
    beadtype = 1
    userid = &#34;dynamic_water&#34;
    version = 1.0

    # Description of the forcefield
    description:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;water&#34;}

    # Name of the forcefield
    name:{forcefield=&#34;LAMMPS:SMD&#34;, material=&#34;water&#34;}

    # Parameters for the forcefield
    rho = 1000
    E = &#34;5*${c0}^2*${rho}&#34;
    nu = 0.3

    Example Output when verbose=False:
    ---------------
    # DFORCEFIELD SAVE FILE

    base_class=&#34;tlsph&#34;
    beadtype = 1
    userid = &#34;dynamic_water&#34;
    version = 1.0

    # Description of the forcefield
    description:{forcefield=&#34;LAMMPS:SMD&#34;, style=&#34;tlsph&#34;, material=&#34;water&#34;}

    # Name of the forcefield
    name:{forcefield=&#34;LAMMPS:SMD&#34;, material=&#34;water&#34;}

    # Parameters for the forcefield
    rho = 1000
    E = &#34;5*${c0}^2*${rho}&#34;
    nu = 0.3
    &#34;&#34;&#34;
    # Determine filename
    if filename is None:
        filename = self.userid
    if not filename.endswith(extension):
        filename += extension

    # Determine foldername
    if foldername is None:
        foldername = tempfile.gettempdir()

    # Construct full file path
    if not os.path.isabs(filename):
        filepath = os.path.join(foldername, filename)
    else:
        filepath = filename

    # Check if file exists
    if os.path.exists(filepath) and not overwrite:
        raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

    # Generate forcefield content
    content = self.generator()

    # Initialize content with mandatory header
    final_content = &#39;# DFORCEFIELD SAVE FILE\n&#39;

    if verbose:
        user = getpass.getuser()
        host = socket.gethostname()
        date = datetime.now().strftime(&#39;%Y-%m-%d&#39;)

        # Construct traceability header
        trace_header = (
            f&#39;# generated on {date} by {user}@{host}\n&#39;
            f&#39;#\n&#39;
            f&#39;#   userid = &#34;{self.userid}&#34;\n\n&#39;
        )
        final_content += trace_header
    else:
        final_content += &#39;\n&#39;

    # Append forcefield content
    final_content += content

    # Write content to file
    with open(filepath, &#39;w&#39;) as f:
        f.write(final_content)

    print(f&#39;\nForcefield saved to {filepath}&#39;)
    return filepath</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.scriptobject"><code class="name flex">
<span>def <span class="ident">scriptobject</span></span>(<span>self, beadtype=None, name=None, userid=None, fullname=None, filename=None, group=None, style=None, USER=script data (SD object) with 0 definitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to return a scriptobject based on the current dforcefield instance.</p>
<h2 id="parameters">Parameters:</h2>
<p>beadtype : int, optional
The bead type identifier. Defaults to the instance's beadtype.</p>
<p>name : str, optional
A short name for the scriptobject. If not provided, uses 'forcefield' from self.name.</p>
<p>fullname : str, optional
A comprehensive name for the object. Defaults to "beads of type {self.beadtype} | object of forcefield: {self.name.forcefield}".</p>
<p>group : list, optional
A group of scriptobjects that this object belongs to. Defaults to an empty list.</p>
<p>style : str, optional
The style of the scriptobject. Defaults to <code>self.description.style</code> if available, otherwise "smd".</p>
<p>USER : scriptdata, optional
User-defined data for additional parameters. Defaults to a blank <code><a title="dforcefield.scriptdata" href="#dforcefield.scriptdata">scriptdata</a></code> instance.</p>
<h2 id="returns">Returns:</h2>
<p>scriptobject
A scriptobject instance populated with the current <code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code> instance's attributes or provided arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scriptobject(self, beadtype=None, name=None, userid=None, fullname=None, filename=None, group=None, style=None, USER=scriptdata()):
    &#34;&#34;&#34;
    Method to return a scriptobject based on the current dforcefield instance.

    Parameters:
    ------------
    beadtype : int, optional
        The bead type identifier. Defaults to the instance&#39;s beadtype.

    name : str, optional
        A short name for the scriptobject. If not provided, uses &#39;forcefield&#39; from self.name.

    fullname : str, optional
        A comprehensive name for the object. Defaults to &#34;beads of type {self.beadtype} | object of forcefield: {self.name.forcefield}&#34;.

    group : list, optional
        A group of scriptobjects that this object belongs to. Defaults to an empty list.

    style : str, optional
        The style of the scriptobject. Defaults to `self.description.style` if available, otherwise &#34;smd&#34;.

    USER : scriptdata, optional
        User-defined data for additional parameters. Defaults to a blank `scriptdata()` instance.

    Returns:
    --------
    scriptobject
        A scriptobject instance populated with the current `dforcefield` instance&#39;s attributes or provided arguments.
    &#34;&#34;&#34;
    # Set defaults using instance attributes if parameters are None
    if beadtype is None:
        beadtype = self.beadtype

    # Extract a meaningful name from the forcefield&#39;s name structure
    if name is None:
        if isinstance(self.name, struct) and hasattr(self.name, &#39;material&#39;):
            name = f&#34;{self.name.material} bead&#34;
        else:
            name = f&#34;beadtype_{beadtype}&#34;

    if userid is None:
        userid = name

    if fullname is None:
        fullname = f&#34;beads of type {beadtype} | object of forcefield: {self.name.forcefield if isinstance(self.name, struct) and hasattr(self.name, &#39;forcefield&#39;) else &#39;unknown&#39;}&#34;

    if group is None:
        group = []

    # Use `self.description.style` as the default for style if it exists, otherwise fall back to &#34;smd&#34;
    if style is None:
        if isinstance(self.description, struct) and hasattr(self.description, &#39;style&#39;):
            style = self.description.style
        else:
            style = &#34;undefined style&#34;

    # The current dforcefield instance behaves as the forcefield for the scriptobject
    forcefield = copy.deepcopy(self)
    forcefield.beadtype = beadtype
    forcefield.name = name
    forcefield.userid = userid

    # Apply any user-defined parameters to the forcefield
    # This is the standard behavior of scriptobject
    forcefield.parameters = forcefield.parameters + USER

    # Create and return the scriptobject instance
    return scriptobject(
        beadtype=beadtype,
        name=name,
        fullname=fullname,
        filename=filename,
        style=style,
        forcefield=forcefield,  # Use the current dforcefield instance
        group=group,
        USER=USER
    )</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.set_global"><code class="name flex">
<span>def <span class="ident">set_global</span></span>(<span>self, new_global=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the GLOBAL parameters and adjust the combined parameters accordingly.</p>
<h2 id="args">Args:</h2>
<p>new_global : parameterforcefield, optional
The new GLOBAL parameters to set. If None, only the parameters in kwargs are modified.
kwargs : dict, optional
Keyword arguments representing individual parameters to add or modify in GLOBAL.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_global(self, new_global=None, **kwargs):
    &#34;&#34;&#34;
    Update the GLOBAL parameters and adjust the combined parameters accordingly.

    Args:
    -----
    new_global : parameterforcefield, optional
        The new GLOBAL parameters to set. If None, only the parameters in kwargs are modified.
    kwargs : dict, optional
        Keyword arguments representing individual parameters to add or modify in GLOBAL.
    &#34;&#34;&#34;
    if new_global is not None and not isinstance(new_global, parameterforcefield):
        raise TypeError(f&#34;GLOBAL must be of type parameterforcefield, not {type(new_global)}.&#34;)

    # Combine current GLOBAL, new_global, and additional parameters in kwargs
    self.GLOBAL = (self.GLOBAL + (new_global or genericdata()) + genericdata(**kwargs))
    self.update_parameters()</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.set_local"><code class="name flex">
<span>def <span class="ident">set_local</span></span>(<span>self, new_local=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the LOCAL parameters and adjust the combined parameters accordingly.</p>
<h2 id="args">Args:</h2>
<p>new_local : parameterforcefield, optional
The new LOCAL parameters to set. If None, only the parameters in kwargs are modified.
kwargs : dict, optional
Keyword arguments representing individual parameters to add or modify in LOCAL.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_local(self, new_local=None, **kwargs):
    &#34;&#34;&#34;
    Update the LOCAL parameters and adjust the combined parameters accordingly.

    Args:
    -----
    new_local : parameterforcefield, optional
        The new LOCAL parameters to set. If None, only the parameters in kwargs are modified.
    kwargs : dict, optional
        Keyword arguments representing individual parameters to add or modify in LOCAL.
    &#34;&#34;&#34;
    if new_local is not None and not isinstance(new_local, parameterforcefield):
        raise TypeError(f&#34;LOCAL must be of type parameterforcefield, not {type(new_local)}.&#34;)

    # Combine current LOCAL, new_local, and additional parameters in kwargs
    self.LOCAL = (self.LOCAL + (new_local or genericdata()) + genericdata(**kwargs))
    self.update_parameters()</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.set_rules"><code class="name flex">
<span>def <span class="ident">set_rules</span></span>(<span>self, new_rules=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the RULES parameters and adjust the combined parameters accordingly.</p>
<h2 id="args">Args:</h2>
<p>new_rules : parameterforcefield, optional
The new RULES parameters to set. If None, only the parameters in kwargs are modified.
kwargs : dict, optional
Keyword arguments representing individual parameters to add or modify in RULES.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rules(self, new_rules=None, **kwargs):
    &#34;&#34;&#34;
    Update the RULES parameters and adjust the combined parameters accordingly.

    Args:
    -----
    new_rules : parameterforcefield, optional
        The new RULES parameters to set. If None, only the parameters in kwargs are modified.
    kwargs : dict, optional
        Keyword arguments representing individual parameters to add or modify in RULES.
    &#34;&#34;&#34;
    if new_rules is not None and not isinstance(new_rules, parameterforcefield):
        raise TypeError(f&#34;RULES must be of type parameterforcefield, not {type(new_rules)}.&#34;)

    # Combine current RULES, new_rules, and additional parameters in kwargs
    self.RULES = (self.RULES + (new_rules or genericdata()) + genericdata(**kwargs))
    self.update_parameters()</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the corresponding base_class forcefield definition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self):
    &#34;&#34;&#34;Show the corresponding base_class forcefield definition &#34;&#34;&#34;
    self.base_class.__repr__()
    return self.base_class.__str__()</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize the dforcefield instance to a dictionary, including RULES, GLOBAL, and LOCAL.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing all the attributes and their current values.</dd>
</dl>
<h2 id="example">Example</h2>
<p>config = dynamic_water.to_dict()
print(config)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    &#34;&#34;&#34;
    Serialize the dforcefield instance to a dictionary, including RULES, GLOBAL, and LOCAL.

    Returns:
        dict: A dictionary containing all the attributes and their current values.

    Example:
        config = dynamic_water.to_dict()
        print(config)
    &#34;&#34;&#34;
    data = {
        &#34;name&#34;: self.name,
        &#34;description&#34;: self.description,
        &#34;beadtype&#34;: self.beadtype,
        &#34;userid&#34;: self.userid,
        &#34;version&#34;: self.version,
        &#34;parameters&#34;: dict(self.parameters),  # Convert parameters to a standard dict
        &#34;base_class&#34;: self.base_class.__class__.__name__,
        &#34;RULES&#34;: dict(self.RULES) if self.RULES else {},  # Include RULES if defined
        &#34;GLOBAL&#34;: dict(self.GLOBAL) if self.GLOBAL else {},  # Include GLOBAL if defined
        &#34;LOCAL&#34;: dict(self.LOCAL) if self.LOCAL else {}  # Include LOCAL if defined
    }
    return data</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update multiple attributes of the dforcefield instance at once, including RULES, GLOBAL, and LOCAL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Key-value pairs of attributes to update.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update multiple attributes of the dforcefield instance at once, including RULES, GLOBAL, and LOCAL.

    Args:
        kwargs: Key-value pairs of attributes to update.
    &#34;&#34;&#34;
    for key, value in kwargs.items():
        if key == &#34;RULES&#34;:
            self.RULES = self.RULES + value if self.RULES else value
        elif key == &#34;GLOBAL&#34;:
            self.GLOBAL = self.GLOBAL + value if self.GLOBAL else value
        elif key == &#34;LOCAL&#34;:
            self.LOCAL = self.LOCAL + value if self.LOCAL else value
        else:
            setattr(self, key, value)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.update_parameters"><code class="name flex">
<span>def <span class="ident">update_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update self.parameters by combining GLOBAL, LOCAL, RULES, and USER parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_parameters(self):
    &#34;&#34;&#34;
    Update self.parameters by combining GLOBAL, LOCAL, RULES, and USER parameters.
    &#34;&#34;&#34;
    self.parameters = self.parameters + self.combine_parameters()
    self._inject_attributes()</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the dforcefield instance to ensure all required attributes are set.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If any required attributes are missing or invalid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self):
    &#34;&#34;&#34;
    Validate the dforcefield instance to ensure all required attributes are set.

    Raises:
        ValueError: If any required attributes are missing or invalid.
    &#34;&#34;&#34;
    required_fields = self._dforcefield_specific_attributes

    for field in required_fields:
        if not getattr(self, field):
            raise ValueError(f&#34;{field} is required and not set.&#34;)

    print(&#34;Validation successful.&#34;)</code></pre>
</details>
</dd>
<dt id="dforcefield.dforcefield.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the values of the merged struct, parameters, and scalar attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34;
    Return the values of the merged struct, parameters, and scalar attributes.
    &#34;&#34;&#34;
    values_list = list(self.merged_name_description.__dict__.values())
    values_list.extend(self.parameters.values())
    values_list.extend([self.version, self.userid, self.beadtype])
    return values_list</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dforcefield.forcefield"><code class="flex name class">
<span>class <span class="ident">forcefield</span></span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code> class represents the core implementation of a forcefield model,
defining interaction parameters and coefficients for simulations. This class provides
methods to handle pair styles, diagonal pair coefficients, and off-diagonal pair coefficients,
which are essential for simulating inter-particle interactions in molecular dynamics or
other physics-based simulations.</p>
<h2 id="attributes">Attributes:</h2>
<p>PAIR_STYLE : str
The default pair style command for the forcefield interactions.</p>
<p>PAIR_DIAGCOEFF : str
The default command for calculating diagonal pair coefficients.</p>
<p>PAIR_OFFDIAGCOEFF : str
The default command for calculating off-diagonal pair coefficients.</p>
<p>parameters : parameterforcefield
An instance of <code><a title="dforcefield.parameterforcefield" href="#dforcefield.parameterforcefield">parameterforcefield</a></code> that stores the parameters for
evaluating interaction commands.</p>
<p>beadtype : int
The bead type associated with the current forcefield instance.</p>
<p>userid : str
A unique identifier for the forcefield instance, used in interaction commands.</p>
<h2 id="methods">Methods:</h2>
<p>pair_style(printflag=True):
Generate and return the pair style command based on the current parameters,
beadtype, and userid.</p>
<p>pair_diagcoeff(printflag=True, i=None):
Generate and return the diagonal pair coefficients based on the current parameters,
beadtype, and userid. The bead type <code>i</code> can be overridden with an optional argument.</p>
<p>pair_offdiagcoeff(o=None, printflag=True, i=None):
Generate and return the off-diagonal pair coefficients between two different
bead types or forcefield objects. The bead type <code>i</code> can be overridden, and the
interaction with another forcefield object <code>o</code> can also be specified.</p>
<h2 id="notes">Notes:</h2>
<ul>
<li>This class is intended to be extended by specific forcefield types such as <code>ulsph</code>.</li>
<li>The parameters used in the interaction commands are dynamically evaluated using
the <code><a title="dforcefield.parameterforcefield" href="#dforcefield.parameterforcefield">parameterforcefield</a></code> class, which provides the required values during runtime.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class forcefield():
    &#34;&#34;&#34;
    The `forcefield` class represents the core implementation of a forcefield model,
    defining interaction parameters and coefficients for simulations. This class provides
    methods to handle pair styles, diagonal pair coefficients, and off-diagonal pair coefficients,
    which are essential for simulating inter-particle interactions in molecular dynamics or
    other physics-based simulations.

    Attributes:
    -----------
    PAIR_STYLE : str
        The default pair style command for the forcefield interactions.

    PAIR_DIAGCOEFF : str
        The default command for calculating diagonal pair coefficients.

    PAIR_OFFDIAGCOEFF : str
        The default command for calculating off-diagonal pair coefficients.

    parameters : parameterforcefield
        An instance of `parameterforcefield` that stores the parameters for
        evaluating interaction commands.

    beadtype : int
        The bead type associated with the current forcefield instance.

    userid : str
        A unique identifier for the forcefield instance, used in interaction commands.

    Methods:
    --------
    pair_style(printflag=True):
        Generate and return the pair style command based on the current parameters,
        beadtype, and userid.

    pair_diagcoeff(printflag=True, i=None):
        Generate and return the diagonal pair coefficients based on the current parameters,
        beadtype, and userid. The bead type `i` can be overridden with an optional argument.

    pair_offdiagcoeff(o=None, printflag=True, i=None):
        Generate and return the off-diagonal pair coefficients between two different
        bead types or forcefield objects. The bead type `i` can be overridden, and the
        interaction with another forcefield object `o` can also be specified.

    Notes:
    ------
    - This class is intended to be extended by specific forcefield types such as `ulsph`.
    - The parameters used in the interaction commands are dynamically evaluated using
      the `parameterforcefield` class, which provides the required values during runtime.
    &#34;&#34;&#34;

    # Main attributes (instance independent)
    name = struct(forcefield=&#34;undefined&#34;, style=&#34;undefined&#34;, material=&#34;undefined&#34;)
    description = struct(forcefield=&#34;missing&#34;, style=&#34;missing&#34;, material=&#34;missing&#34;)
    beadtype = 1  # default bead type
    parameters = parameterforcefield() # empty parameters object
    userid = &#34;undefined&#34;
    version = 0

    # print method for headers (static, no implicit argument)
    @staticmethod
    def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
        &#34;&#34;&#34; print header &#34;&#34;&#34;
        if txt==&#34;&#34;:
            print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
        else:
            print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))

    # Display/representation method
    # The method provides full help for the end-user
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        stamp = self.name.forcefield+&#34;:&#34;+self.name.style+&#34;:&#34;+self.name.material
        self.printheader(&#34;%s | version=%0.3g&#34; % (self.userid,self.version),filler=&#34;=&#34;)
        print(&#34;  Bead of type %d = [%s]&#34; % (self.beadtype,stamp))
        print(self.parameters)
        self.printheader(&#34;description&#34;,filler=&#34;.&#34;)
        print(&#34;\t# \t%s&#34; % self.description.forcefield)
        print(&#34;\t# \t%s&#34; % self.description.style)
        print(&#34;\t# \t%s&#34; % self.description.material)
        self.printheader(&#34;methods&#34;)
        print(&#34;\t   &gt;&gt;&gt; replace FFi,FFj by your variable names &lt;&lt;&lt;&#34;)
        print(&#34;\tTo assign a type, use: FFi.beadtype = integer value&#34;)
        print(&#34;\tUse the methods FFi.pair_style() and FFi.pair_coeff(FFj)&#34;)
        print(&#34;\tNote for pairs: the caller object is i (FFi), the argument is j (FFj or j)&#34;)
        self.printheader(&#34;template&#34;)
        self.pair_style()
        self.pair_diagcoeff()
        self.pair_offdiagcoeff()
        self.printheader(&#34;&#34;)
        return stamp

    # Extract attributes within the class
    def getallattributes(self):
        &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
        return {k: getattr(self, k) for k in dir(self) \
                if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}


    # Forcefield Methods: pair_style(), pair_coeff()
    # the substitution of LAMMPS variables is carried out with the method
    # parameters.format() method implemented in struct and inherited by parameterforcefield()
    def pair_style(self,printflag=False,verbose=True, raw=False,USER=None,beadtype=None,userid=None):
        &#34;&#34;&#34;
        Generate and return the pair style command for the current forcefield instance.

        This method creates a formatted pair style command based on the interaction parameters
        stored in the `parameters` attribute. It allows customization of the command using the
        `beadtype` and `userid` arguments. The behavior can be altered by passing a `USER` object
        or opting for the raw command template.

        Parameters:
        -----------
        printflag : bool, optional, default=False
            If True, the generated pair style command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        raw : bool, optional, default=False
            If True, returns the raw template of the pair style without any interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier used in the generated command. If not provided, the
            instance&#39;s beadtype is used.
        userid : str, optional, default=None
            The user identifier to include in the formatted command. Defaults to the instance&#39;s
            userid if not specified.

        Returns:
        --------
        str
            The formatted pair style command string.

        Raises:
        -------
        TypeError
            If `USER` is provided but is not of type `struct` or derived from `struct`.
        &#34;&#34;&#34;
        # raw format
        if raw:
            return self.PAIR_STYLE
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # cmd
        cmd = parameters.formateval(self.PAIR_STYLE)
        # Replace [comment] with the formatted comment (e.g., &#34;[2:my_user_id]&#34;)
        cmd = cmd.replace(&#34;[comment]&#34;,&#34;[%d:%s]&#34; % (beadtype, userid) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


    def pair_diagcoeff(self,printflag=False,verbose=True, i=None,raw=False,USER=None,beadtype=None,userid=None):
        &#34;&#34;&#34;
        Generate and return the diagonal pair coefficients for the current forcefield instance.

        This method evaluates the diagonal pair coefficients based on the interaction parameters,
        the bead type (`beadtype`), and the user identifier (`userid`). The bead type `i` can
        be overridden by passing it as an argument. The method supports returning the raw template
        without evaluation and modifying parameters using a `USER` object.

        Parameters:
        -----------
        printflag : bool, optional, default=False
            If True, the generated diagonal pair coefficient command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        i : int, optional, default=None
            The bead type used for evaluating the diagonal pair coefficients. If not provided,
            defaults to the instance&#39;s bead type (`self.beadtype`).
        raw : bool, optional, default=False
            If True, returns the raw template for the diagonal pair coefficients without interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier to use in the command. Defaults to the instance&#39;s beadtype
            if not provided.
        userid : str, optional, default=None
            The user identifier to include in the formatted command. Defaults to the instance&#39;s
            userid if not specified.

        Returns:
        --------
        str
            The formatted diagonal pair coefficient command string.

        Raises:
        -------
        TypeError
            If `USER` is provided but is not of type `struct` or derived from `struct`.
        &#34;&#34;&#34;
        # raw format
        if raw:
            return self.PAIR_DIAGCOEFF
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # diagonal index
        i = i if i is not None else beadtype
        # cmd
        cmd = parameters.formateval(self.PAIR_DIAGCOEFF) % (i,i)
        # Replace [comment] with the formatted string, without using .format()
        cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, userid, i, userid) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


    def pair_offdiagcoeff(self,o=None,printflag=False,verbose=True,i=None,raw=False,USER=None,beadtype=None,userid=None,oname=None):
        &#34;&#34;&#34;
        Generate and return the off-diagonal pair coefficients for the current forcefield instance.

        This method evaluates the off-diagonal pair coefficients between two different bead types
        or forcefield objects, using the interaction parameters, bead type, and user identifier.
        The bead type `i` can be overridden, and the interaction with another forcefield object `o`
        can also be specified.

        Parameters:
        -----------
        o : forcefield or int, optional, default=None
            The second forcefield object or bead type used for calculating the off-diagonal
            pair coefficients. If not provided, the method assumes interactions between
            beads of the same type.
        printflag : bool, optional, default=False
            If True, the generated off-diagonal pair coefficient command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        i : int, optional, default=None
            The bead type used for the current forcefield instance. If not provided,
            defaults to the instance&#39;s bead type (`self.beadtype`).
        raw : bool, optional, default=False
            If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier used in the command. Defaults to the instance&#39;s beadtype
            if not provided.
        userid : str, optional, default=None
            The user identifier included in the formatted command. Defaults to the instance&#39;s
            userid if not specified.
        oname : str, optional, default=None
            The user identifier for the second forcefield or bead type. If not provided, it
            defaults to `&#34;none&#34;`.

        Returns:
        --------
        str
            The formatted off-diagonal pair coefficient command string.

        Raises:
        -------
        TypeError
            If `USER` is not of type `struct` or derived from `struct`.
        IndexError
            If the first argument `o` is not a forcefield object or an integer.
        &#34;&#34;&#34;

        # raw format
        if raw:
            return self.PAIR_OFFDIAGCOEFF
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
            i = i if i is not None else beadtype
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # Determine the first bead type (i)
        i = i if i is not None else beadtype
        # Determine the second bead type (j) based on o
        if o is None:
            j = i
        elif hasattr(o, &#39;beadtype&#39;):
            j = o.beadtype
        elif isinstance(o, (float, int)):
            j = int(o)
        else:
            raise IndexError(&#34;The first argument should be a forcefield object or an integer representing bead type.&#34;)
        # Adjust j if it matches i (to ensure off-diagonal interaction)
        if j == i:
            j = i - 1 if i &gt; 1 else i + 1
        oname = oname if oname is not None else o.userid if hasattr(o, &#34;userid&#34;) else &#34;none&#34;
        # cmd
        cmd = parameters.formateval(self.PAIR_OFFDIAGCOEFF) % (min(i,j),max(j,i))
        # Replace [comment] with the formatted string, without using .format()
        cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, self.userid, j, oname) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.tlsphalone</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dforcefield.forcefield.beadtype"><code class="name">var <span class="ident">beadtype</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dforcefield.forcefield.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dforcefield.forcefield.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dforcefield.forcefield.parameters"><code class="name">var <span class="ident">parameters</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dforcefield.forcefield.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dforcefield.forcefield.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="dforcefield.forcefield.printheader"><code class="name flex">
<span>def <span class="ident">printheader</span></span>(<span>txt, align='^', width=80, filler='~')</span>
</code></dt>
<dd>
<div class="desc"><p>print header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
    &#34;&#34;&#34; print header &#34;&#34;&#34;
    if txt==&#34;&#34;:
        print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
    else:
        print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dforcefield.forcefield.getallattributes"><code class="name flex">
<span>def <span class="ident">getallattributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>advanced method to get all attributes including class ones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getallattributes(self):
    &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
    return {k: getattr(self, k) for k in dir(self) \
            if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}</code></pre>
</details>
</dd>
<dt id="dforcefield.forcefield.pair_diagcoeff"><code class="name flex">
<span>def <span class="ident">pair_diagcoeff</span></span>(<span>self, printflag=False, verbose=True, i=None, raw=False, USER=None, beadtype=None, userid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the diagonal pair coefficients for the current forcefield instance.</p>
<p>This method evaluates the diagonal pair coefficients based on the interaction parameters,
the bead type (<code>beadtype</code>), and the user identifier (<code>userid</code>). The bead type <code>i</code> can
be overridden by passing it as an argument. The method supports returning the raw template
without evaluation and modifying parameters using a <code>USER</code> object.</p>
<h2 id="parameters">Parameters:</h2>
<p>printflag : bool, optional, default=False
If True, the generated diagonal pair coefficient command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
i : int, optional, default=None
The bead type used for evaluating the diagonal pair coefficients. If not provided,
defaults to the instance's bead type (<code>self.beadtype</code>).
raw : bool, optional, default=False
If True, returns the raw template for the diagonal pair coefficients without interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier to use in the command. Defaults to the instance's beadtype
if not provided.
userid : str, optional, default=None
The user identifier to include in the formatted command. Defaults to the instance's
userid if not specified.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted diagonal pair coefficient command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is provided but is not of type <code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a></code> or derived from <code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_diagcoeff(self,printflag=False,verbose=True, i=None,raw=False,USER=None,beadtype=None,userid=None):
    &#34;&#34;&#34;
    Generate and return the diagonal pair coefficients for the current forcefield instance.

    This method evaluates the diagonal pair coefficients based on the interaction parameters,
    the bead type (`beadtype`), and the user identifier (`userid`). The bead type `i` can
    be overridden by passing it as an argument. The method supports returning the raw template
    without evaluation and modifying parameters using a `USER` object.

    Parameters:
    -----------
    printflag : bool, optional, default=False
        If True, the generated diagonal pair coefficient command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    i : int, optional, default=None
        The bead type used for evaluating the diagonal pair coefficients. If not provided,
        defaults to the instance&#39;s bead type (`self.beadtype`).
    raw : bool, optional, default=False
        If True, returns the raw template for the diagonal pair coefficients without interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier to use in the command. Defaults to the instance&#39;s beadtype
        if not provided.
    userid : str, optional, default=None
        The user identifier to include in the formatted command. Defaults to the instance&#39;s
        userid if not specified.

    Returns:
    --------
    str
        The formatted diagonal pair coefficient command string.

    Raises:
    -------
    TypeError
        If `USER` is provided but is not of type `struct` or derived from `struct`.
    &#34;&#34;&#34;
    # raw format
    if raw:
        return self.PAIR_DIAGCOEFF
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # diagonal index
    i = i if i is not None else beadtype
    # cmd
    cmd = parameters.formateval(self.PAIR_DIAGCOEFF) % (i,i)
    # Replace [comment] with the formatted string, without using .format()
    cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, userid, i, userid) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="dforcefield.forcefield.pair_offdiagcoeff"><code class="name flex">
<span>def <span class="ident">pair_offdiagcoeff</span></span>(<span>self, o=None, printflag=False, verbose=True, i=None, raw=False, USER=None, beadtype=None, userid=None, oname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the off-diagonal pair coefficients for the current forcefield instance.</p>
<p>This method evaluates the off-diagonal pair coefficients between two different bead types
or forcefield objects, using the interaction parameters, bead type, and user identifier.
The bead type <code>i</code> can be overridden, and the interaction with another forcefield object <code>o</code>
can also be specified.</p>
<h2 id="parameters">Parameters:</h2>
<p>o : forcefield or int, optional, default=None
The second forcefield object or bead type used for calculating the off-diagonal
pair coefficients. If not provided, the method assumes interactions between
beads of the same type.
printflag : bool, optional, default=False
If True, the generated off-diagonal pair coefficient command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
i : int, optional, default=None
The bead type used for the current forcefield instance. If not provided,
defaults to the instance's bead type (<code>self.beadtype</code>).
raw : bool, optional, default=False
If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier used in the command. Defaults to the instance's beadtype
if not provided.
userid : str, optional, default=None
The user identifier included in the formatted command. Defaults to the instance's
userid if not specified.
oname : str, optional, default=None
The user identifier for the second forcefield or bead type. If not provided, it
defaults to <code>"none"</code>.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted off-diagonal pair coefficient command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is not of type <code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a></code> or derived from <code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a></code>.
IndexError
If the first argument <code>o</code> is not a forcefield object or an integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_offdiagcoeff(self,o=None,printflag=False,verbose=True,i=None,raw=False,USER=None,beadtype=None,userid=None,oname=None):
    &#34;&#34;&#34;
    Generate and return the off-diagonal pair coefficients for the current forcefield instance.

    This method evaluates the off-diagonal pair coefficients between two different bead types
    or forcefield objects, using the interaction parameters, bead type, and user identifier.
    The bead type `i` can be overridden, and the interaction with another forcefield object `o`
    can also be specified.

    Parameters:
    -----------
    o : forcefield or int, optional, default=None
        The second forcefield object or bead type used for calculating the off-diagonal
        pair coefficients. If not provided, the method assumes interactions between
        beads of the same type.
    printflag : bool, optional, default=False
        If True, the generated off-diagonal pair coefficient command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    i : int, optional, default=None
        The bead type used for the current forcefield instance. If not provided,
        defaults to the instance&#39;s bead type (`self.beadtype`).
    raw : bool, optional, default=False
        If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier used in the command. Defaults to the instance&#39;s beadtype
        if not provided.
    userid : str, optional, default=None
        The user identifier included in the formatted command. Defaults to the instance&#39;s
        userid if not specified.
    oname : str, optional, default=None
        The user identifier for the second forcefield or bead type. If not provided, it
        defaults to `&#34;none&#34;`.

    Returns:
    --------
    str
        The formatted off-diagonal pair coefficient command string.

    Raises:
    -------
    TypeError
        If `USER` is not of type `struct` or derived from `struct`.
    IndexError
        If the first argument `o` is not a forcefield object or an integer.
    &#34;&#34;&#34;

    # raw format
    if raw:
        return self.PAIR_OFFDIAGCOEFF
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
        i = i if i is not None else beadtype
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # Determine the first bead type (i)
    i = i if i is not None else beadtype
    # Determine the second bead type (j) based on o
    if o is None:
        j = i
    elif hasattr(o, &#39;beadtype&#39;):
        j = o.beadtype
    elif isinstance(o, (float, int)):
        j = int(o)
    else:
        raise IndexError(&#34;The first argument should be a forcefield object or an integer representing bead type.&#34;)
    # Adjust j if it matches i (to ensure off-diagonal interaction)
    if j == i:
        j = i - 1 if i &gt; 1 else i + 1
    oname = oname if oname is not None else o.userid if hasattr(o, &#34;userid&#34;) else &#34;none&#34;
    # cmd
    cmd = parameters.formateval(self.PAIR_OFFDIAGCOEFF) % (min(i,j),max(j,i))
    # Replace [comment] with the formatted string, without using .format()
    cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, self.userid, j, oname) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="dforcefield.forcefield.pair_style"><code class="name flex">
<span>def <span class="ident">pair_style</span></span>(<span>self, printflag=False, verbose=True, raw=False, USER=None, beadtype=None, userid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the pair style command for the current forcefield instance.</p>
<p>This method creates a formatted pair style command based on the interaction parameters
stored in the <code>parameters</code> attribute. It allows customization of the command using the
<code>beadtype</code> and <code>userid</code> arguments. The behavior can be altered by passing a <code>USER</code> object
or opting for the raw command template.</p>
<h2 id="parameters">Parameters:</h2>
<p>printflag : bool, optional, default=False
If True, the generated pair style command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
raw : bool, optional, default=False
If True, returns the raw template of the pair style without any interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier used in the generated command. If not provided, the
instance's beadtype is used.
userid : str, optional, default=None
The user identifier to include in the formatted command. Defaults to the instance's
userid if not specified.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted pair style command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is provided but is not of type <code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a></code> or derived from <code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_style(self,printflag=False,verbose=True, raw=False,USER=None,beadtype=None,userid=None):
    &#34;&#34;&#34;
    Generate and return the pair style command for the current forcefield instance.

    This method creates a formatted pair style command based on the interaction parameters
    stored in the `parameters` attribute. It allows customization of the command using the
    `beadtype` and `userid` arguments. The behavior can be altered by passing a `USER` object
    or opting for the raw command template.

    Parameters:
    -----------
    printflag : bool, optional, default=False
        If True, the generated pair style command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    raw : bool, optional, default=False
        If True, returns the raw template of the pair style without any interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier used in the generated command. If not provided, the
        instance&#39;s beadtype is used.
    userid : str, optional, default=None
        The user identifier to include in the formatted command. Defaults to the instance&#39;s
        userid if not specified.

    Returns:
    --------
    str
        The formatted pair style command string.

    Raises:
    -------
    TypeError
        If `USER` is provided but is not of type `struct` or derived from `struct`.
    &#34;&#34;&#34;
    # raw format
    if raw:
        return self.PAIR_STYLE
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # cmd
    cmd = parameters.formateval(self.PAIR_STYLE)
    # Replace [comment] with the formatted comment (e.g., &#34;[2:my_user_id]&#34;)
    cmd = cmd.replace(&#34;[comment]&#34;,&#34;[%d:%s]&#34; % (beadtype, userid) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dforcefield.generic"><code class="flex name class">
<span>class <span class="ident">generic</span></span>
</code></dt>
<dd>
<div class="desc"><p>generic helper class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class generic:
    &#34;&#34;&#34; generic helper class &#34;&#34;&#34;
    _version = 0.1
    _description = &#34;generic helper for forcefield parameterization&#34;
    RULES = genericdata()

    def __init__(self):
        self.name = None
        self.type = None

    def __repr__(self):
        &#34;&#34;&#34; representation of generic() &#34;&#34;&#34;
        id = &#34;&#34;
        if self.type is not None: id = str(self.type)+&#34;:&#34;
        if self.name is not None: id = id+str(self.name)
        if id !=&#34;&#34;: id = &#39;&#34;&#39;+id+&#39;&#34;&#39;
        idstr = &#39;  generic helper: %s\n\t (class &#34;%s&#34;)&#39; % (id,self.__class__)
        print(&#34;%s&#34; % idstr)
        if len(self.GLOBAL):
            print(&#34;  with GLOBAL data&#34;)
            self.GLOBAL.__repr__()
        return idstr</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.generic.USERSMD</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dforcefield.generic.RULES"><code class="name">var <span class="ident">RULES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="dforcefield.genericdata"><code class="flex name class">
<span>class <span class="ident">genericdata</span></span>
<span>(</span><span>sortdefinitions=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>generic data class to be used along with pizza.generic </p>
<p>Constructor for parameterforcefield. It forces the parent's _returnerror parameter to False.</p>
<h2 id="parameters">Parameters:</h2>
<p>_protection : bool, optional
Whether to enable protection on the parameters (default: False).
_evaluation : bool, optional
Whether evaluation is enabled for the parameters (default: True).
sortdefinitions : bool, optional
Whether to sort definitions upon initialization (default: False).
**kwargs : dict
Additional keyword arguments for the parent class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class genericdata(parameterforcefield):
    &#34;&#34;&#34; generic data class to be used along with pizza.generic &#34;&#34;&#34;
    _type = &#34;gendata&#34;        # object type
    _fulltype = &#34;generic data&#34; # full name
    _ftype = &#34;item&#34;        # field name
    _maxdisplay = 80</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.parameterforcefield</li>
<li>pizza.private.mstruct.paramauto</li>
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="dforcefield.parameterforcefield"><code class="flex name class">
<span>class <span class="ident">parameterforcefield</span></span>
<span>(</span><span>sortdefinitions=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>class of forcefields parameters, derived from param
note that conctanating two forcefields force them
to to be sorted</p>
<p>Constructor for parameterforcefield. It forces the parent's _returnerror parameter to False.</p>
<h2 id="parameters">Parameters:</h2>
<p>_protection : bool, optional
Whether to enable protection on the parameters (default: False).
_evaluation : bool, optional
Whether evaluation is enabled for the parameters (default: True).
sortdefinitions : bool, optional
Whether to sort definitions upon initialization (default: False).
**kwargs : dict
Additional keyword arguments for the parent class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class parameterforcefield(paramauto):
    &#34;&#34;&#34; class of forcefields parameters, derived from param
        note that conctanating two forcefields force them
        to to be sorted
    &#34;&#34;&#34;
    _type = &#34;FF&#34;
    _fulltype = &#34;forcefield&#34;
    _ftype = &#34;parameter&#34;
    _maxdisplay = 80

    # same strategy as used in dscript for forcing  _returnerror = False (added 2024-09-12)
    def __init__(self, _protection=False, _evaluation=True, sortdefinitions=False, **kwargs):
        &#34;&#34;&#34;
        Constructor for parameterforcefield. It forces the parent&#39;s _returnerror parameter to False.

        Parameters:
        -----------
        _protection : bool, optional
            Whether to enable protection on the parameters (default: False).
        _evaluation : bool, optional
            Whether evaluation is enabled for the parameters (default: True).
        sortdefinitions : bool, optional
            Whether to sort definitions upon initialization (default: False).
        **kwargs : dict
            Additional keyword arguments for the parent class.
        &#34;&#34;&#34;
        # Call the parent class constructor
        super().__init__(_protection=_protection, _evaluation=_evaluation, sortdefinitions=sortdefinitions, **kwargs)
        # Override the _returnerror attribute at the instance level
        self._returnerror = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.paramauto</li>
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.generic.genericdata</li>
</ul>
</dd>
<dt id="dforcefield.scriptdata"><code class="flex name class">
<span>class <span class="ident">scriptdata</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>class of script parameters
Typical constructor:
DEFINITIONS = scriptdata(
var1 = value1,
var2 = value2
)
See script, struct, param to get review all methods attached to it</p>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scriptdata(param):
    &#34;&#34;&#34;
        class of script parameters
            Typical constructor:
                DEFINITIONS = scriptdata(
                    var1 = value1,
                    var2 = value2
                    )
        See script, struct, param to get review all methods attached to it
    &#34;&#34;&#34;
    _type = &#34;SD&#34;
    _fulltype = &#34;script data&#34;
    _ftype = &#34;definition&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="dforcefield.scriptobject"><code class="flex name class">
<span>class <span class="ident">scriptobject</span></span>
<span>(</span><span>beadtype=1, name=None, fullname='', filename='', style='smd', mass=1.0, forcefield=LAMMPS:SMD:none:walls, group=[], USER=script data (SD object) with 0 definitions)</span>
</code></dt>
<dd>
<div class="desc"><p>scriptobject: A Class for Managing Script Objects in LAMMPS</p>
<p>The <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> class is designed to represent individual objects in LAMMPS scripts,
such as beads, atoms, or other components. Each object is associated with a <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code>
instance that defines the physical interactions of the object, and the class supports
a variety of properties for detailed object definition. Additionally, <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code>
instances can be grouped together and compared based on their properties, such as
<code>beadtype</code> and <code>name</code>.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Forcefield Integration</strong>: Each <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> is associated with a <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code>
instance, allowing for customized physical interactions. Forcefields can be passed
via the <code>USER</code> keyword for dynamic parameterization.</li>
<li><strong>Grouping</strong>: Multiple <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> instances can be combined into a
<code>scriptobjectgroup</code> using the <code>+</code> operator, allowing for complex collections of objects.</li>
<li><strong>Object Comparison</strong>: <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> instances can be compared and sorted based on
their <code>beadtype</code> and <code>name</code>, enabling efficient organization and manipulation of objects.</li>
<li><strong>Piping and Execution</strong>: Supports the pipe (<code>|</code>) operator, allowing <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code>
instances to be used in script pipelines alongside other script elements.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>Object Definition in LAMMPS</strong>: Use <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> to represent individual objects in
a simulation, including their properties and associated forcefields.</li>
<li><strong>Forcefield Parameterization</strong>: Pass customized parameters to the forcefield via the
<code>USER</code> keyword to dynamically adjust the physical interactions.</li>
<li><strong>Grouping and Sorting</strong>: Combine multiple objects into groups, or sort them based
on their properties (e.g., <code>beadtype</code>) for easier management in complex simulations.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, beadtype=1, name="undefined", fullname="", filename="", style="smd",
forcefield=rigidwall(), group=[], USER=scriptdata()):
Initializes a new <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> with the specified properties, including <code>beadtype</code>,
<code>name</code>, <code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code>, and optional <code>group</code>.</p>
<p><strong>str</strong>(self):
Returns a string representation of the <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code>, showing its <code>beadtype</code> and <code>name</code>.</p>
<p><strong>add</strong>(self, SO):
Combines two <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> instances or a <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> with a <code>scriptobjectgroup</code>.
Raises an error if the two objects have the same <code>name</code> or if the second operand is not
a valid <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> or <code>scriptobjectgroup</code>.</p>
<p><strong>or</strong>(self, pipe):
Overloads the pipe (<code>|</code>) operator to integrate the <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> into a pipeline.</p>
<p><strong>eq</strong>(self, SO):
Compares two <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> instances, returning <code>True</code> if they have the same
<code>beadtype</code> and <code>name</code>.</p>
<p><strong>ne</strong>(self, SO):
Returns <code>True</code> if the two <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> instances differ in either <code>beadtype</code> or <code>name</code>.</p>
<p><strong>lt</strong>(self, SO):
Compares the <code>beadtype</code> of two <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> instances, returning <code>True</code> if the
left object's <code>beadtype</code> is less than the right object's.</p>
<p><strong>gt</strong>(self, SO):
Compares the <code>beadtype</code> of two <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> instances, returning <code>True</code> if the
left object's <code>beadtype</code> is greater than the right object's.</p>
<p><strong>le</strong>(self, SO):
Returns <code>True</code> if the <code>beadtype</code> of the left <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> is less than or equal to
the right <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code>.</p>
<p><strong>ge</strong>(self, SO):
Returns <code>True</code> if the <code>beadtype</code> of the left <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> is greater than or equal
to the right <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code>.</p>
<h2 id="attributes">Attributes:</h2>
<p>beadtype : int
The type of bead or object, used for distinguishing between different types in the simulation.
name : str
A short name for the object, useful for quick identification.
fullname : str
A comprehensive name for the object. If not provided, defaults to the <code>name</code> with "object definition".
filename : str
The path to the file containing the input data for the object.
style : str
The style of the object (e.g., "smd" for smoothed dynamics).
forcefield : forcefield
The forcefield instance associated with the object, defining its physical interactions.
group : list
A list of other <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> instances that are grouped with this object.
USER : scriptdata
A collection of user-defined variables for customizing the forcefield or other properties.</p>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> class enables the definition of objects within LAMMPS scripts, providing:
- <strong>Beadtype and Naming</strong>: Objects are distinguished by their <code>beadtype</code> and <code>name</code>, allowing
for comparison and sorting based on these properties.
- <strong>Forcefield Support</strong>: Objects are linked to a forcefield instance, and user-defined forcefield
parameters can be passed through the <code>USER</code> keyword.
- <strong>Group Management</strong>: Multiple objects can be grouped together using the <code>+</code> operator, forming
a <code>scriptobjectgroup</code>.
- <strong>Comparison Operators</strong>: Objects can be compared based on their <code>beadtype</code> and <code>name</code>, using
standard comparison operators (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, etc.).
- <strong>Pipelines</strong>: <code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code> instances can be integrated into pipelines, supporting the <code>|</code>
operator for use in sequential script execution.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>from pizza.scriptobject import scriptobject, rigidwall, scriptdata

# Define a script object with custom properties
obj1 = scriptobject(beadtype=1, name=&quot;bead1&quot;, forcefield=rigidwall(USER=scriptdata(param1=10)))

# Combine two objects into a group
obj2 = scriptobject(beadtype=2, name=&quot;bead2&quot;)
group = obj1 + obj2

# Print object information
print(obj1)
print(group)
</code></pre>
<p>The output will be:</p>
<pre><code>script object | type=1 | name=bead1
scriptobjectgroup containing 2 objects
</code></pre>
<h2 id="overview">Overview</h2>
<pre><code>class of script object
    OBJ = scriptobject(...)
    Implemented properties:
        beadtype=1,2,...
        name="short name"
        fullname = "comprehensive name"
        filename = "/path/to/your/inputfile"
        style = "smd"
        forcefield = any valid forcefield instance (default = rigidwall())
        mass = 1.0

note: use a forcefield instance with the keywork USER to pass user FF parameters
examples:   rigidwall(USER=scriptdata(...))
            solidfood(USER==scriptdata(...))
            water(USER==scriptdata(...))

group objects with OBJ1+OBJ2... into scriptobjectgroups

objects can be compared and sorted based on beadtype and name
</code></pre>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scriptobject(struct):
    &#34;&#34;&#34;
    scriptobject: A Class for Managing Script Objects in LAMMPS

    The `scriptobject` class is designed to represent individual objects in LAMMPS scripts,
    such as beads, atoms, or other components. Each object is associated with a `forcefield`
    instance that defines the physical interactions of the object, and the class supports
    a variety of properties for detailed object definition. Additionally, `scriptobject`
    instances can be grouped together and compared based on their properties, such as
    `beadtype` and `name`.

    Key Features:
    -------------
    - **Forcefield Integration**: Each `scriptobject` is associated with a `forcefield`
      instance, allowing for customized physical interactions. Forcefields can be passed
      via the `USER` keyword for dynamic parameterization.
    - **Grouping**: Multiple `scriptobject` instances can be combined into a
      `scriptobjectgroup` using the `+` operator, allowing for complex collections of objects.
    - **Object Comparison**: `scriptobject` instances can be compared and sorted based on
      their `beadtype` and `name`, enabling efficient organization and manipulation of objects.
    - **Piping and Execution**: Supports the pipe (`|`) operator, allowing `scriptobject`
      instances to be used in script pipelines alongside other script elements.

    Practical Use Cases:
    --------------------
    - **Object Definition in LAMMPS**: Use `scriptobject` to represent individual objects in
      a simulation, including their properties and associated forcefields.
    - **Forcefield Parameterization**: Pass customized parameters to the forcefield via the
      `USER` keyword to dynamically adjust the physical interactions.
    - **Grouping and Sorting**: Combine multiple objects into groups, or sort them based
      on their properties (e.g., `beadtype`) for easier management in complex simulations.

    Methods:
    --------
    __init__(self, beadtype=1, name=&#34;undefined&#34;, fullname=&#34;&#34;, filename=&#34;&#34;, style=&#34;smd&#34;,
             forcefield=rigidwall(), group=[], USER=scriptdata()):
        Initializes a new `scriptobject` with the specified properties, including `beadtype`,
        `name`, `forcefield`, and optional `group`.

    __str__(self):
        Returns a string representation of the `scriptobject`, showing its `beadtype` and `name`.

    __add__(self, SO):
        Combines two `scriptobject` instances or a `scriptobject` with a `scriptobjectgroup`.
        Raises an error if the two objects have the same `name` or if the second operand is not
        a valid `scriptobject` or `scriptobjectgroup`.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the `scriptobject` into a pipeline.

    __eq__(self, SO):
        Compares two `scriptobject` instances, returning `True` if they have the same
        `beadtype` and `name`.

    __ne__(self, SO):
        Returns `True` if the two `scriptobject` instances differ in either `beadtype` or `name`.

    __lt__(self, SO):
        Compares the `beadtype` of two `scriptobject` instances, returning `True` if the
        left object&#39;s `beadtype` is less than the right object&#39;s.

    __gt__(self, SO):
        Compares the `beadtype` of two `scriptobject` instances, returning `True` if the
        left object&#39;s `beadtype` is greater than the right object&#39;s.

    __le__(self, SO):
        Returns `True` if the `beadtype` of the left `scriptobject` is less than or equal to
        the right `scriptobject`.

    __ge__(self, SO):
        Returns `True` if the `beadtype` of the left `scriptobject` is greater than or equal
        to the right `scriptobject`.

    Attributes:
    -----------
    beadtype : int
        The type of bead or object, used for distinguishing between different types in the simulation.
    name : str
        A short name for the object, useful for quick identification.
    fullname : str
        A comprehensive name for the object. If not provided, defaults to the `name` with &#34;object definition&#34;.
    filename : str
        The path to the file containing the input data for the object.
    style : str
        The style of the object (e.g., &#34;smd&#34; for smoothed dynamics).
    forcefield : forcefield
        The forcefield instance associated with the object, defining its physical interactions.
    group : list
        A list of other `scriptobject` instances that are grouped with this object.
    USER : scriptdata
        A collection of user-defined variables for customizing the forcefield or other properties.

    Original Content:
    -----------------
    The `scriptobject` class enables the definition of objects within LAMMPS scripts, providing:
    - **Beadtype and Naming**: Objects are distinguished by their `beadtype` and `name`, allowing
      for comparison and sorting based on these properties.
    - **Forcefield Support**: Objects are linked to a forcefield instance, and user-defined forcefield
      parameters can be passed through the `USER` keyword.
    - **Group Management**: Multiple objects can be grouped together using the `+` operator, forming
      a `scriptobjectgroup`.
    - **Comparison Operators**: Objects can be compared based on their `beadtype` and `name`, using
      standard comparison operators (`==`, `&lt;`, `&gt;`, etc.).
    - **Pipelines**: `scriptobject` instances can be integrated into pipelines, supporting the `|`
      operator for use in sequential script execution.

    Example Usage:
    --------------
    ```
    from pizza.scriptobject import scriptobject, rigidwall, scriptdata

    # Define a script object with custom properties
    obj1 = scriptobject(beadtype=1, name=&#34;bead1&#34;, forcefield=rigidwall(USER=scriptdata(param1=10)))

    # Combine two objects into a group
    obj2 = scriptobject(beadtype=2, name=&#34;bead2&#34;)
    group = obj1 + obj2

    # Print object information
    print(obj1)
    print(group)
    ```

    The output will be:
    ```
    script object | type=1 | name=bead1
    scriptobjectgroup containing 2 objects
    ```

    OVERVIEW
    --------------

        class of script object
            OBJ = scriptobject(...)
            Implemented properties:
                beadtype=1,2,...
                name=&#34;short name&#34;
                fullname = &#34;comprehensive name&#34;
                filename = &#34;/path/to/your/inputfile&#34;
                style = &#34;smd&#34;
                forcefield = any valid forcefield instance (default = rigidwall())
                mass = 1.0

        note: use a forcefield instance with the keywork USER to pass user FF parameters
        examples:   rigidwall(USER=scriptdata(...))
                    solidfood(USER==scriptdata(...))
                    water(USER==scriptdata(...))

        group objects with OBJ1+OBJ2... into scriptobjectgroups

        objects can be compared and sorted based on beadtype and name

    &#34;&#34;&#34;
    _type = &#34;SO&#34;
    _fulltype = &#34;script object&#34;
    _ftype = &#34;propertie&#34;

    def __init__(self,
                 beadtype = 1,
                 name = None,
                 fullname=&#34;&#34;,
                 filename=&#34;&#34;,
                 style=&#34;smd&#34;,
                 mass=1.0, # added on 2024-11-29
                 forcefield=rigidwall(),
                 group=[],
                 USER = scriptdata()
                 ):
        name = f&#34;beadtype={beadtype}&#34; if name is None else name
        if not isinstance(name,str):
            TypeError(f&#34;name must a string or None got {type(name)}&#34;)
        if fullname==&#34;&#34;: fullname = name + &#34; object definition&#34;
        if not isinstance(group,list): group = [group]
        forcefield.beadtype = beadtype
        forcefield.userid = name
        forcefield.USER = USER
        super(scriptobject,self).__init__(
              beadtype = beadtype,
                  name = name,
              fullname = fullname,
              filename = filename,
                 style = style,
            forcefield = forcefield,
                  mass = mass,
                 group = group,
                  USER = USER
                 )

    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self._fulltype} | type={self.beadtype} | name={self.name}&#34;

    def __add__(self, SO):
        if isinstance(SO,scriptobject):
            if SO.name != self.name:
                if SO.beadtype == self.beadtype:
                   SO.beadtype =  self.beadtype+1
                return scriptobjectgroup(self,SO)
            else:
                raise ValueError(&#39;the object &#34;%s&#34; already exists&#39; % SO.name)
        elif isinstance(SO,scriptobjectgroup):
            return scriptobjectgroup(self)+SO
        else:
            return ValueError(&#34;The object should a script object or its container&#34;)

    def __or__(self, pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        if isinstance(pipe,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self) | pipe
        else:
            raise ValueError(&#34;the argument must a pipescript, a scriptobject or a scriptobjectgroup&#34;)

    def __eq__(self, SO):
        return isinstance(SO,scriptobject) and (self.beadtype == SO.beadtype) and (self.mass == SO.mass) \
            and (self.name == SO.name)

    def __ne__(self, SO):
        return not isinstance(SO,scriptobject) or (self.beadtype != SO.beadtype) or (self.mass != SO.mass) or (self.name != SO.name)

    def __lt__(self, SO):
        return self.beadtype &lt; SO.beadtype

    def __gt__(self, SO):
        return self.beadtype &gt; SO.beadtype

    def __le__(self, SO):
        return self.beadtype &lt;= SO.beadtype

    def __ge__(self, SO):
        return self.beadtype &gt;= SO.beadtype</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="dforcefield.struct"><code class="flex name class">
<span>class <span class="ident">struct</span></span>
<span>(</span><span>debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-struct">Class: <code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a></code></h1>
<p>A lightweight class that mimics Matlab-like structures, with additional features
such as dynamic field creation, indexing, concatenation, and compatibility with
evaluated parameters (<code>param</code>).</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Dynamic creation of fields.</li>
<li>Indexing and iteration support for fields.</li>
<li>Concatenation and subtraction of structures.</li>
<li>Conversion to and from dictionaries.</li>
<li>Compatible with <code>param</code> and <code>paramauto</code> for evaluation and dependency handling.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic Usage</h4>
<pre><code class="language-python">s = struct(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
print(s.a)  # 1
s.d = 11    # Append a new field
delattr(s, 'd')  # Delete the field
</code></pre>
<h4 id="using-param-for-evaluation">Using <code>param</code> for Evaluation</h4>
<pre><code class="language-python">p = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
p.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-subtraction">Concatenation and Subtraction</h3>
<p>Fields from the right-most structure overwrite existing values.</p>
<pre><code class="language-python">a = struct(a=1, b=2)
b = struct(c=3, d=&quot;d&quot;, e=&quot;e&quot;)
c = a + b
e = c - a
</code></pre>
<hr>
<h3 id="practical-shorthands">Practical Shorthands</h3>
<h4 id="constructing-a-structure-from-keys">Constructing a Structure from Keys</h4>
<pre><code class="language-python">s = struct.fromkeys([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
# Output:
# --------
#      a: None
#      b: None
#      c: None
#      d: None
# --------
</code></pre>
<h4 id="building-a-structure-from-variables-in-a-string">Building a Structure from Variables in a String</h4>
<pre><code class="language-python">s = struct.scan(&quot;${a} + ${b} * ${c} / ${d} --- ${ee}&quot;)
s.a = 1
s.b = &quot;test&quot;
s.c = [1, &quot;a&quot;, 2]
s.generator()
# Output:
# X = struct(
#      a=1,
#      b=&quot;test&quot;,
#      c=[1, 'a', 2],
#      d=None,
#      ee=None
# )
</code></pre>
<h4 id="indexing-and-iteration">Indexing and Iteration</h4>
<p>Structures can be indexed or sliced like lists.</p>
<pre><code class="language-python">c = a + b
c[0]      # Access the first field
c[-1]     # Access the last field
c[:2]     # Slice the structure
for field in c:
    print(field)
</code></pre>
<hr>
<h3 id="dynamic-dependency-management">Dynamic Dependency Management</h3>
<p><code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a></code> provides control over dependencies, sorting, and evaluation.</p>
<pre><code class="language-python">s = struct(d=3, e=&quot;${c} + {d}&quot;, c='${a} + ${b}', a=1, b=2)
s.sortdefinitions()
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}
#      e: ${c} + ${d}
# --------
</code></pre>
<p>For dynamic evaluation, use <code>param</code>:</p>
<pre><code class="language-python">p = param(sortdefinitions=True, d=3, e=&quot;${c} + ${d}&quot;, c='${a} + ${b}', a=1, b=2)
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}  (= 3)
#      e: ${c} + ${d}  (= 6)
# --------
</code></pre>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two structures (<code>__add__</code>).</li>
<li><code>-</code>: Subtraction of fields (<code>__sub__</code>).</li>
<li><code>&lt;&lt;</code>: Import values from another structure (<code>__lshift__</code>)</li>
<li><code>len()</code>: Number of fields (<code>__len__</code>).</li>
<li><code>in</code>: Check for field existence (<code>__contains__</code>).</li>
</ul>
<h4 id="method-overview">Method Overview</h4>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>check(default)</code></td>
<td>Populate fields with defaults if missing.</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>Remove all fields.</td>
</tr>
<tr>
<td><code>dict2struct(dico)</code></td>
<td>Create a structure from a dictionary.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display the structure.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate expressions within fields.</td>
</tr>
<tr>
<td><code>fromkeys(keys)</code></td>
<td>Create a structure from a list of keys.</td>
</tr>
<tr>
<td><code>generator()</code></td>
<td>Generate Python code representing the structure.</td>
</tr>
<tr>
<td><code>importfrom()</code></td>
<td>Import undefined values from another struct or dict.</td>
</tr>
<tr>
<td><code>items()</code></td>
<td>Return key-value pairs.</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>Return all keys in the structure.</td>
</tr>
<tr>
<td><code>read(file)</code></td>
<td>Load structure fields from a file.</td>
</tr>
<tr>
<td><code>scan(string)</code></td>
<td>Extract variables from a string and populate fields.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>struct2dict()</code></td>
<td>Convert the structure to a dictionary.</td>
</tr>
<tr>
<td><code>validkeys()</code></td>
<td>Return valid keys</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>Return all field values.</td>
</tr>
<tr>
<td><code>write(file)</code></td>
<td>Save the structure to a file.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="dynamic-properties">Dynamic Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isempty</code></td>
<td><code>True</code> if the structure is empty.</td>
</tr>
<tr>
<td><code>isdefined</code></td>
<td><code>True</code> if all fields are defined.</td>
</tr>
</tbody>
</table>
<hr>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class struct():
    &#34;&#34;&#34;
    Class: `struct`
    ================

    A lightweight class that mimics Matlab-like structures, with additional features
    such as dynamic field creation, indexing, concatenation, and compatibility with
    evaluated parameters (`param`).

    ---

    ### Features
    - Dynamic creation of fields.
    - Indexing and iteration support for fields.
    - Concatenation and subtraction of structures.
    - Conversion to and from dictionaries.
    - Compatible with `param` and `paramauto` for evaluation and dependency handling.

    ---

    ### Examples

    #### Basic Usage
    ```python
    s = struct(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    print(s.a)  # 1
    s.d = 11    # Append a new field
    delattr(s, &#39;d&#39;)  # Delete the field
    ```

    #### Using `param` for Evaluation
    ```python
    p = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    p.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    # --------
    ```

    ---

    ### Concatenation and Subtraction
    Fields from the right-most structure overwrite existing values.
    ```python
    a = struct(a=1, b=2)
    b = struct(c=3, d=&#34;d&#34;, e=&#34;e&#34;)
    c = a + b
    e = c - a
    ```

    ---

    ### Practical Shorthands

    #### Constructing a Structure from Keys
    ```python
    s = struct.fromkeys([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;])
    # Output:
    # --------
    #      a: None
    #      b: None
    #      c: None
    #      d: None
    # --------
    ```

    #### Building a Structure from Variables in a String
    ```python
    s = struct.scan(&#34;${a} + ${b} * ${c} / ${d} --- ${ee}&#34;)
    s.a = 1
    s.b = &#34;test&#34;
    s.c = [1, &#34;a&#34;, 2]
    s.generator()
    # Output:
    # X = struct(
    #      a=1,
    #      b=&#34;test&#34;,
    #      c=[1, &#39;a&#39;, 2],
    #      d=None,
    #      ee=None
    # )
    ```

    #### Indexing and Iteration
    Structures can be indexed or sliced like lists.
    ```python
    c = a + b
    c[0]      # Access the first field
    c[-1]     # Access the last field
    c[:2]     # Slice the structure
    for field in c:
        print(field)
    ```

    ---

    ### Dynamic Dependency Management
    `struct` provides control over dependencies, sorting, and evaluation.

    ```python
    s = struct(d=3, e=&#34;${c} + {d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    s.sortdefinitions()
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}
    #      e: ${c} + ${d}
    # --------
    ```

    For dynamic evaluation, use `param`:
    ```python
    p = param(sortdefinitions=True, d=3, e=&#34;${c} + ${d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}  (= 3)
    #      e: ${c} + ${d}  (= 6)
    # --------
    ```

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two structures (`__add__`).
    - `-`: Subtraction of fields (`__sub__`).
    - `&lt;&lt;`: Import values from another structure (`__lshift__`)
    - `len()`: Number of fields (`__len__`).
    - `in`: Check for field existence (`__contains__`).

    #### Method Overview
    | Method                | Description                                             |
    |-----------------------|---------------------------------------------------------|
    | `check(default)`      | Populate fields with defaults if missing.               |
    | `clear()`             | Remove all fields.                                      |
    | `dict2struct(dico)`   | Create a structure from a dictionary.                   |
    | `disp()`              | Display the structure.                                  |
    | `eval()`              | Evaluate expressions within fields.                     |
    | `fromkeys(keys)`      | Create a structure from a list of keys.                 |
    | `generator()`         | Generate Python code representing the structure.        |
    | `importfrom()`        | Import undefined values from another struct or dict.    |
    | `items()`             | Return key-value pairs.                                 |
    | `keys()`              | Return all keys in the structure.                       |
    | `read(file)`          | Load structure fields from a file.                      |
    | `scan(string)`        | Extract variables from a string and populate fields.    |
    | `sortdefinitions()`   | Sort fields to resolve dependencies.                    |
    | `struct2dict()`       | Convert the structure to a dictionary.                  |
    | `validkeys()`         | Return valid keys                                       |
    | `values()`            | Return all field values.                                |
    | `write(file)`         | Save the structure to a file.                           |

    ---

    ### Dynamic Properties
    | Property    | Description                            |
    |-------------|----------------------------------------|
    | `isempty`   | `True` if the structure is empty.      |
    | `isdefined` | `True` if all fields are defined.      |

    ---
    &#34;&#34;&#34;

    # attributes to be overdefined
    _type = &#34;struct&#34;        # object type
    _fulltype = &#34;structure&#34; # full name
    _ftype = &#34;field&#34;        # field name
    _evalfeature = False    # true if eval() is available
    _maxdisplay = 40        # maximum number of characters to display (should be even)
    _propertyasattribute = False
    _precision = 4

    # attributes for the iterator method
    # Please keep it static, duplicate the object before changing _iter_
    _iter_ = 0

    # excluded attributes (keep the , in the Tupple if it is singleton)
    _excludedattr = {&#39;_iter_&#39;,&#39;__class__&#39;,&#39;_protection&#39;,&#39;_evaluation&#39;,&#39;_returnerror&#39;,&#39;_debug&#39;,&#39;_precision&#39;} # used by keys() and len()


    # Methods
    def __init__(self,debug=False,**kwargs):
        &#34;&#34;&#34; constructor, use debug=True to report eval errors&#34;&#34;&#34;
        # Optionally extend _excludedattr here
        self._excludedattr = self._excludedattr | {&#39;_excludedattr&#39;, &#39;_type&#39;, &#39;_fulltype&#39;,&#39;_ftype&#39;} # addition 2024-10-11
        self._debug = debug
        self.set(**kwargs)

    def zip(self):
        &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
        return zip(self.keys(),self.values())

    @staticmethod
    def dict2struct(dico,makeparam=False):
        &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
        if isinstance(dico,dict):
            s = param() if makeparam else struct()
            s.set(**dico)
            return s
        raise TypeError(&#34;the argument must be a dictionary&#34;)

    def struct2dict(self):
        &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
        return dict(self.zip())

    def struct2param(self,protection=False,evaluation=True):
        &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
        p = param(**self.struct2dict())
        for i in range(len(self)):
            if isinstance(self[i],pstr): p[i] = pstr(p[i])
        p._protection = protection
        p._evaluation = evaluation
        return p

    def set(self,**kwargs):
        &#34;&#34;&#34; initialization &#34;&#34;&#34;
        self.__dict__.update(kwargs)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value

    def getattr(self,key):
        &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
        if key in self.__dict__:
            return self.__dict__[key]
        elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
             key not in self._excludedattr and \
             key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
            # If _propertyasattribute is True and it&#39;s a property, get its value
            return self.__class__.__dict__[key].fget(self)
        else:
            raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)

    def hasattr(self, key):
        &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
        return key in self.__dict__ or (
            getattr(self, &#39;_propertyasattribute&#39;, False) and
            key not in self._excludedattr and
            key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
        )

    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return pstr.eval(self.getattr(key))

    def __setattr__(self,key,value):
        &#34;&#34;&#34; set attribute override &#34;&#34;&#34;
        self.setattr(key,value)

    def __contains__(self,item):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(item)

    def keys(self):
        &#34;&#34;&#34; return the fields &#34;&#34;&#34;
        # keys() is used by struct() and its iterator
        return [key for key in self.__dict__.keys() if key not in self._excludedattr]

    def keyssorted(self,reverse=True):
        &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
        klist = self.keys()
        l = [len(k) for k in klist]
        return [k for _,k in sorted(zip(l,klist),reverse=reverse)]

    def values(self):
        &#34;&#34;&#34; return the values &#34;&#34;&#34;
        # values() is used by struct() and its iterator
        return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]

    @staticmethod
    def fromkeysvalues(keys,values,makeparam=False):
        &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
            use makeparam = True to create a param instead of struct
        &#34;&#34;&#34;
        if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
        if not isinstance(keys,_list_types): keys = [keys]
        if not isinstance(values,_list_types): values = [values]
        nk,nv = len(keys), len(values)
        s = param() if makeparam else struct()
        if nk&gt;0 and nv&gt;0:
            iv = 0
            for ik in range(nk):
                s.setattr(keys[ik], values[iv])
                iv = min(nv-1,iv+1)
            for ik in range(nk,nv):
                s.setattr(f&#34;key{ik}&#34;, values[ik])
        return s

    def items(self):
        &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
        return self.zip()

    def __getitem__(self,idx):
        &#34;&#34;&#34;
            s[i] returns the ith element of the structure
            s[:4] returns a structure with the four first fields
            s[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.getattr(self.keys()[idx])
            raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            out = struct.fromkeysvalues(self.keys()[idx], self.values()[idx])
            if isinstance(self,paramauto):
                return paramauto(**out)
            elif isinstance(self,param):
                return param(**out)
            else:
                return out
        elif isinstance(idx,(list,tuple)):
            k,v= self.keys(), self.values()
            nk = len(k)
            s = param() if isinstance(self,param) else struct()
            for i in idx:
                if isinstance(i,int):
                    if -nk &lt;= i &lt; nk:  # Allow standard Python negative indexing
                        i = i % nk  # Convert negative index to positive equivalent
                        s.setattr(k[i],v[i])
                    else:
                        raise IndexError(f&#34;idx must contain integers in range [-{nk}, {nk-1}], not {i}&#34;)
                elif isinstance(i,str):
                    if i in self:
                        s.setattr(i, self.getattr(i))
                    else:
                        raise KeyError((f&#39;idx &#34;{idx}&#34; is not a valid key&#39;))
                else:
                    TypeError(&#34;idx must contain only integers or strings&#34;)
            return s
        elif isinstance(idx,str):
            return self.getattr(idx)
        else:
            raise TypeError(&#34;The index must be an integer or a slice and not a %s&#34; % type(idx).__name__)

    def __setitem__(self,idx,value):
        &#34;&#34;&#34; set the ith element of the structure  &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                self.setattr(self.keys()[idx], value)
            else:
                raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            k = self.keys()[idx]
            if len(value)&lt;=1:
                for i in range(len(k)): self.setattr(k[i], value)
            elif len(k) == len(value):
                for i in range(len(k)): self.setattr(k[i], value[i])
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of elements in the slice (%d)&#34; \
                       % (len(value),len(idx)))
        elif isinstance(idx,(list,tuple)):
            if len(value)&lt;=1:
                for i in range(len(idx)): self[idx[i]]=value
            elif len(idx) == len(value):
                for i in range(len(idx)): self[idx[i]]=value[i]
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of indices (%d)&#34; \
                                 % (len(value),len(idx)))

    def __len__(self):
        &#34;&#34;&#34; return the number of fields &#34;&#34;&#34;
        # len() is used by struct() and its iterator
        return len(self.keys())

    def __iter__(self):
        &#34;&#34;&#34; struct iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    def __next__(self):
        &#34;&#34;&#34; increment iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum {self._ftype} iteration reached {len(self)}&#34;)

    def __add__(self, s, sortdefinitions=False, raiseerror=True, silentmode=True):
        &#34;&#34;&#34;
        Add two structure objects, with precedence as follows:

          paramauto &gt; param &gt; struct

        In c = a + b, if b has a higher precedence than a then c will be of b&#39;s class,
        otherwise it will be of a&#39;s class.

        The new instance is created by copying the fields from the left-hand operand (a)
        and then updating with the fields from the right-hand operand (b).
        &#34;&#34;&#34;
        if not isinstance(s, struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)

        # Define a helper to assign a precedence value.
        def get_precedence(obj):
            if isinstance(obj, paramauto):
                return 2
            elif isinstance(obj, param):
                return 1
            elif isinstance(obj, struct):
                return 0
            else:
                return 0  # fallback for unknown derivations

        # Determine which class to use for the duplicate.
        # If s (b) has a higher precedence than self (a), use s&#39;s class; otherwise, use self&#39;s.
        hi_class = self.__class__ if get_precedence(self) &gt;= get_precedence(s) else s.__class__
        # Create a new instance of the chosen class by copying self&#39;s fields.
        dup = hi_class(**self)
        # Update with the fields from s.
        dup.update(**s)
        if sortdefinitions:
            dup.sortdefinitions(raiseerror=raiseerror, silentmode=silentmode)
        return dup

    def __iadd__(self,s,sortdefinitions=False,raiseerror=False, silentmode=True):
        &#34;&#34;&#34; iadd a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        self.update(**s)
        if sortdefinitions: self.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return self

    def __sub__(self,s):
        &#34;&#34;&#34; sub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        listofkeys = dup.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(dup,k)
        return dup

    def __isub__(self,s):
        &#34;&#34;&#34; isub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        listofkeys = self.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(self,k)
        return self

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        if self.__dict__=={}:
            print(f&#34;empty {self._fulltype} ({self._type} object) with no {self._type}s&#34;)
            return f&#34;empty {self._fulltype}&#34;
        else:
            numfmt = f&#34;.{self._precision}g&#34;
            tmp = self.eval() if self._evalfeature else []
            keylengths = [len(key) for key in self.__dict__]
            width = max(10,max(keylengths)+2)
            fmt = &#34;%%%ss:&#34; % width
            fmteval = fmt[:-1]+&#34;=&#34;
            fmtcls =  fmt[:-1]+&#34;:&#34;
            line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
            print(line)
            for key,value in self.__dict__.items():
                if key not in self._excludedattr:
                    if isinstance(value,_numeric_types):
                        # old code (removed on 2025-01-18)
                        # if isinstance(value,pstr):
                        #     print(fmt % key,&#39;p&#34;&#39;+self.dispmax(value)+&#39;&#34;&#39;)
                        # if isinstance(value,str) and value==&#34;&#34;:
                        #     print(fmt % key,&#39;&#34;&#34;&#39;)
                        # else:
                        #     print(fmt % key,self.dispmax(value))
                        if isinstance(value,np.ndarray):
                            print(fmt % key, struct.format_array(value,numfmt=numfmt))
                        else:
                            print(fmt % key,self.dispmax(value))
                    elif isinstance(value,struct):
                        print(fmt % key,self.dispmax(value.__str__()))
                    elif isinstance(value,(type,dict)):
                        print(fmt % key,self.dispmax(str(value)))
                    else:
                        print(fmt % key,type(value))
                        print(fmtcls % &#34;&#34;,self.dispmax(str(value)))
                    if self._evalfeature:
                        if isinstance(self,paramauto):
                            try:
                                if isinstance(value,pstr):
                                    print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                                elif isinstance(value,str):
                                    if value == &#34;&#34;:
                                        print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(tmp.getattr(key)))
                            except Exception as err:
                                print(fmteval % &#34;&#34;,err.message, err.args)
                        else:
                            if isinstance(value,pstr):
                                print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                            elif isinstance(value,str):
                                if value == &#34;&#34;:
                                    print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                else:
                                    calcvalue =tmp.getattr(key)
                                    if isinstance(calcvalue, str) and &#34;error&#34; in calcvalue.lower():
                                        print(fmteval % &#34;&#34;,calcvalue)
                                    else:
                                        if isinstance(calcvalue,np.ndarray):
                                            print(fmteval % &#34;&#34;, struct.format_array(calcvalue,numfmt=numfmt))
                                        else:
                                            print(fmteval % &#34;&#34;,self.dispmax(calcvalue))
                            elif isinstance(value,list):
                                calcvalue =tmp.getattr(key)
                                print(fmteval % &#34;&#34;,self.dispmax(str(calcvalue)))
            print(line)
            return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    def disp(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        self.__repr__()

    def __str__(self):
        return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    @property
    def isempty(self):
        &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
        return len(self)==0

    def clear(self):
        &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
        for k in self.keys(): delattr(self,k)

    def format(self, s, escape=False, raiseerror=True):
        &#34;&#34;&#34;
            Format a string with fields using {field} as placeholders.
            Handles expressions like ${variable1}.

            Args:
                s (str): The input string to format.
                escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
                raiseerror (bool): If True, raises errors for missing fields.

            Note:
                NumPy vectors and matrices are converted into their text representation (default behavior)
                If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

            Returns:
                str: The formatted string.
        &#34;&#34;&#34;
        tmp = self.np2str()
        if raiseerror:
            try:
                if escape:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.format_map(AttrErrorDict(self.__dict__))
                else:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
            except AttributeError as attr_err:
                # Handle AttributeError for expressions with operators
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
                return s_  # Revert to using &#39;${&#39; for unresolved expressions
            except IndexError as idx_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
                raise IndexError from idx_err
            except Exception as other_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                raise RuntimeError from other_err
        else:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except:  # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))

    def format_legacy(self,s,escape=False,raiseerror=True):
        &#34;&#34;&#34;
            format a string with field (use {field} as placeholders)
                s.replace(string), s.replace(string,escape=True)
                where:
                    s is a struct object
                    string is a string with possibly ${variable1}
                    escape is a flag to prevent ${} replaced by {}
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format(**self.__dict__)
                else:
                    return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
            except KeyError as kerr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
                return s_ # instead of s (we put back $) - OV 2023/01/27
            except Exception as othererr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                raise RuntimeError from othererr
        else:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)

    def fromkeys(self,keys):
        &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
        return self+struct(**dict.fromkeys(keys,None))

    @staticmethod
    def scan(s):
        &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
        tmp = struct()
        #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
        found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
        uniq = []
        for x in found:
            if x not in uniq: uniq.append(x)
        return tmp.fromkeys(uniq)

    @staticmethod
    def isstrexpression(s):
        &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        return re.search(r&#34;\$\{.*?\}&#34;,s) is not None

    @property
    def isexpression(self):
        &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        for k,v in self.items():
            if isinstance(v,str):
                s.setattr(k,struct.isstrexpression(v))
            else:
                s.setattr(k,False)
        return s

    @staticmethod
    def isstrdefined(s,ref):
        &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        if struct.isstrexpression(s):
            k = struct.scan(s).keys()
            allfound,i,nk = True,0,len(k)
            while (i&lt;nk) and allfound:
                allfound = k[i] in ref
                i += 1
            return allfound
        else:
            return False


    def isdefined(self,ref=None):
        &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
        nk = len(k)
        if ref is None:
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
                else:
                    s.setattr(k[i],True)
        else:
            if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],ref))
                else:
                    s.setattr(k[i],True)
        return s

    def sortdefinitions(self,raiseerror=True,silentmode=False):
        &#34;&#34;&#34; sortdefintions sorts all definitions
            so that they can be executed as param().
            If any inconsistency is found, an error message is generated.

            Flags = default values
                raiseerror=True show erros of True
                silentmode=False no warning if True
        &#34;&#34;&#34;
        find = lambda xlist: [i for i, x in enumerate(xlist) if x]
        findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
        k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
        istatic = findnot(isexpr)
        idynamic = find(isexpr)
        static = struct.fromkeysvalues(
            [ k[i] for i in istatic ],
            [ v[i] for i in istatic ],
            makeparam = False)
        dynamic = struct.fromkeysvalues(
            [ k[i] for i in idynamic ],
            [ v[i] for i in idynamic ],
            makeparam=False)
        current = static # make static the current structure
        nmissing, anychange, errorfound = len(dynamic), False, False
        while nmissing:
            itst, found = 0, False
            while itst&lt;nmissing and not found:
                teststruct = current + dynamic[[itst]] # add the test field
                found = all(list(teststruct.isdefined()))
                ifound = itst
                itst += 1
            if found:
                current = teststruct # we accept the new field
                dynamic[ifound] = []
                nmissing -= 1
                anychange = True
            else:
                if raiseerror:
                    raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                                   (nmissing,len(self),self._ftype))
                else:
                    if (not errorfound) and (not silentmode):
                        print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                              (nmissing,len(self),self._ftype))
                    current = teststruct # we accept the new field (even if it cannot be interpreted)
                    dynamic[ifound] = []
                    nmissing -= 1
                    errorfound = True
        if anychange:
            self.clear() # reset all fields and assign them in the proper order
            k,v = current.keys(), current.values()
            for i in range(len(k)):
                self.setattr(k[i],v[i])


    def generator(self, printout=False):
        &#34;&#34;&#34;
        Generate Python code of the equivalent structure.

        This method converts the current structure (an instance of `param`, `paramauto`, or `struct`)
        into Python code that, when executed, recreates an equivalent structure. The generated code is
        formatted with one field per line.

        By default (when `printout` is False), the generated code is returned as a raw string that starts
        directly with, for example, `param(` (or `paramauto(` or `struct(`), with no &#34;X = &#34; prefix or leading
        newline. When `printout` is True, the generated code is printed to standard output and includes a prefix
        &#34;X = &#34; to indicate the variable name.

        Parameters:
            printout (bool): If True, the generated code is printed to standard output with the &#34;X = &#34; prefix.
                             If False (default), the code is returned as a raw string starting with, e.g.,
                             `param(`.

        Returns:
            str: The generated Python code representing the structure (regardless of whether it was printed).
        &#34;&#34;&#34;
        nk = len(self)
        tmp = self.np2str()
        # Compute the field format based on the maximum key length (with a minimum width of 10)
        fmt = &#34;%%%ss =&#34; % max(10, max([len(k) for k in self.keys()]) + 2)
        # Determine the appropriate class string for the current instance.
        if isinstance(self, param):
            classstr = &#34;param&#34;
        elif &#39;paramauto&#39; in globals() and isinstance(self, paramauto):
            classstr = &#34;paramauto&#34;
        else:
            classstr = &#34;struct&#34;

        lines = []
        if nk == 0:
            # For an empty structure.
            if printout:
                lines.append(f&#34;X = {classstr}()&#34;)
            else:
                lines.append(f&#34;{classstr}()&#34;)
        else:
            # Header: include &#34;X = &#34; only if printing.
            if printout:
                header = f&#34;X = {classstr}(&#34;
            else:
                header = f&#34;{classstr}(&#34;
            lines.append(header)
            # Iterate over keys to generate each field line.
            for i, k in enumerate(self.keys()):
                v = getattr(self, k)
                if isinstance(v, np.ndarray):
                    vtmp = getattr(tmp, k)
                    field = fmt % k + &#34; &#34; + vtmp
                elif isinstance(v, (int, float)) or v is None:
                    field = fmt % k + &#34; &#34; + str(v)
                elif isinstance(v, str):
                    field = fmt % k + &#34; &#34; + f&#39;&#34;{v}&#34;&#39;
                elif isinstance(v, (list, tuple, dict)):
                    field = fmt % k + &#34; &#34; + str(v)
                else:
                    field = fmt % k + &#34; &#34; + &#34;/* unsupported type */&#34;
                # Append a comma after each field except the last one.
                if i &lt; nk - 1:
                    field += &#34;,&#34;
                lines.append(field)
            # Create a closing line that aligns the closing parenthesis.
            closing_line = fmt[:-1] % &#34;)&#34;
            lines.append(closing_line)
        result = &#34;\n&#34;.join(lines)
        if printout:
            print(result)
            return None
        return result


    # copy and deep copy methpds for the class
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, duplicatedeep(v, memo))
        return copie


    # write a file
    def write(self, file, overwrite=True, mkdir=False):
        &#34;&#34;&#34;
            write the equivalent structure (not recursive for nested struct)
                write(filename, overwrite=True, mkdir=False)

            Parameters:
            - file: The file path to write to.
            - overwrite: Whether to overwrite the file if it exists (default: True).
            - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()

        # Check if the directory exists or if mkdir is set to True, create it
        if mkdir:
            file_path.parent.mkdir(parents=True, exist_ok=True)
        elif not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If overwrite is False and the file already exists, raise an exception
        if not overwrite and file_path.exists():
            raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
        # Convert to static if needed
        if isinstance(p,(param,paramauto)):
            tmp = self.tostatic()
        else:
            tmp = self
        # Open and write to the file using the resolved path
        with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
            print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
            for k, v in tmp.items():
                if v is None:
                    print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
                elif isinstance(v, (int, float)):
                    print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
                elif isinstance(v, str):
                    print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
                else:
                    print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)


    # read a file
    @staticmethod
    def read(file):
        &#34;&#34;&#34;
            read the equivalent structure
                read(filename)

            Parameters:
            - file: The file path to read from.
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()
        # Check if the parent directory exists, otherwise raise an error
        if not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If the file does not exist, raise an exception
        if not file_path.exists():
            raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
        # Open and read the file
        with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            s = struct()  # Assuming struct is defined elsewhere
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                expr = line.split(sep=&#34;=&#34;)
                if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                    lhs = expr[0]
                    rhs = &#34;&#34;.join(expr[1:]).strip()
                    if len(rhs) == 0 or rhs == &#34;None&#34;:
                        v = None
                    else:
                        v = eval(rhs)
                    s.setattr(lhs, v)
        return s

    # argcheck
    def check(self,default):
        &#34;&#34;&#34;
        populate fields from a default structure
            check(defaultstruct)
            missing field, None and [] values are replaced by default ones

            Note: a.check(b) is equivalent to b+a except for [] and None values
        &#34;&#34;&#34;
        if not isinstance(default,struct):
            raise TypeError(&#34;the first argument must be a structure&#34;)
        for f in default.keys():
            ref = default.getattr(f)
            if f not in self:
                self.setattr(f, ref)
            else:
                current = self.getattr(f)
                if ((current is None)  or (current==[])) and \
                    ((ref is not None) and (ref!=[])):
                        self.setattr(f, ref)


    # update values based on key:value
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple fields at once, while protecting certain attributes.

        Parameters:
        -----------
        **kwargs : dict
            The fields to update and their new values.

        Protected attributes defined in _excludedattr are not updated.

        Usage:
        ------
        s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
        &#34;&#34;&#34;
        protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

        for key, value in kwargs.items():
            if key in protected_attributes:
                print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
            else:
                self.setattr(key, value)


    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract a sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            A new instance of the same class as the original, containing
            only the specified keys.

        Usage:
        ------
        sub_struct = s(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        # Create a new instance of the same class
        sub_struct = self.__class__()

        # Get the full type and field type for error messages
        fulltype = getattr(self, &#39;_fulltype&#39;, &#39;structure&#39;)
        ftype = getattr(self, &#39;_ftype&#39;, &#39;field&#39;)

        # Add only the specified keys to the new sub-structure
        for key in keys:
            if key in self:
                sub_struct.setattr(key, self.getattr(key))
            else:
                raise KeyError(f&#34;{fulltype} does not contain the {ftype} &#39;{key}&#39;.&#34;)

        return sub_struct


    def __delattr__(self, key):
        &#34;&#34;&#34; Delete an instance attribute if it exists and is not a class or excluded attribute. &#34;&#34;&#34;
        if key in self._excludedattr:
            raise AttributeError(f&#34;Cannot delete excluded attribute &#39;{key}&#39;&#34;)
        elif key in self.__class__.__dict__:  # Check if it&#39;s a class attribute
            raise AttributeError(f&#34;Cannot delete class attribute &#39;{key}&#39;&#34;)
        elif key in self.__dict__:  # Delete only if in instance&#39;s __dict__
            del self.__dict__[key]
        else:
            raise AttributeError(f&#34;{self._type} has no attribute &#39;{key}&#39;&#34;)


    # A la Matlab display method of vectors, matrices and ND-arrays
    @staticmethod
    def format_array(value,numfmt=&#34;.4g&#34;):
        &#34;&#34;&#34;
        Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
        Recursively formats multi-dimensional arrays without introducing unwanted commas.

        Args:
            value (np.ndarray): The NumPy array to format.
            numfmt: numeric format to be used for the string conversion (default=&#34;.4g&#34;)

        Returns:
            str: A formatted string representation of the array.
        &#34;&#34;&#34;
        dtype_str = {
            np.float64: &#34;double&#34;,
            np.float32: &#34;single&#34;,
            np.int32: &#34;int32&#34;,
            np.int64: &#34;int64&#34;,
            np.complex64: &#34;complex single&#34;,
            np.complex128: &#34;complex double&#34;,
        }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

        max_display = 10  # Maximum number of elements to display

        def format_recursive(arr):
            &#34;&#34;&#34;
            Recursively formats the array based on its dimensions.

            Args:
                arr (np.ndarray): The array or sub-array to format.

            Returns:
                str: Formatted string of the array.
            &#34;&#34;&#34;
            if arr.ndim == 0:
                return f&#34;{arr.item()}&#34;

            if arr.ndim == 1:
                if len(arr) &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr) + &#34;]&#34;
                else:
                    return f&#34;[{len(arr)} elements]&#34;

            if arr.ndim == 2:
                if arr.shape[1] == 1:
                    # Column vector
                    if arr.shape[0] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in arr) + &#34;]T&#34;
                    else:
                        return f&#34;[{arr.shape[0]}Ã—1 vector]&#34;
                elif arr.shape[0] == 1:
                    # Row vector
                    if arr.shape[1] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr[0]) + &#34;]&#34;
                    else:
                        return f&#34;[1Ã—{arr.shape[1]} vector]&#34;
                else:
                    # General matrix
                    return f&#34;[{arr.shape[0]}Ã—{arr.shape[1]} matrix]&#34;

            # For higher dimensions
            shape_str = &#34;Ã—&#34;.join(map(str, arr.shape))
            if arr.size &lt;= max_display:
                # Show full content
                if arr.ndim &gt; 2:
                    # Represent multi-dimensional arrays with nested brackets
                    return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
            return f&#34;[{shape_str} array ({dtype_str})]&#34;

        if value.size == 0:
            return &#34;[]&#34;

        if value.ndim == 0 or value.size == 1:
            return f&#34;{value.item()} ({dtype_str})&#34;

        if value.ndim == 1 or value.ndim == 2:
            # Use existing logic for vectors and matrices
            if value.ndim == 1:
                if len(value) &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{len(value)}Ã—1 {dtype_str}]&#34;
            elif value.ndim == 2:
                rows, cols = value.shape
                if cols == 1:  # Column vector
                    if rows &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[{rows}Ã—1 {dtype_str}]&#34;
                elif rows == 1:  # Row vector
                    if cols &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[1Ã—{cols} {dtype_str}]&#34;
                else:  # General matrix
                    formatted = f&#34;[{rows}Ã—{cols} {dtype_str}]&#34;
            return formatted

        # For higher-dimensional arrays
        if value.size &lt;= max_display:
            formatted = format_recursive(value)
        else:
            shape_str = &#34;Ã—&#34;.join(map(str, value.shape))
            formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

        return formatted


    # convert all NumPy entries to &#34;nestable&#34; expressions
    def np2str(self):
        &#34;&#34;&#34; Convert all NumPy entries of s into their string representations, handling both lists and dictionaries. &#34;&#34;&#34;
        out = struct()
        def format_numpy_result(value):
            &#34;&#34;&#34;
            Converts a NumPy array or scalar into a string representation:
            - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
            - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
            - If the value is a list or dict, the conversion is applied recursively.
            - Non-ndarray inputs that are not list/dict are returned without modification.

            Args:
                value (np.ndarray, scalar, list, dict, or other): The value to format.

            Returns:
                str, list, dict, or original type: A properly formatted string for NumPy arrays/scalars,
                a recursively converted list/dict, or the original value.
            &#34;&#34;&#34;
            if isinstance(value, dict):
                # Recursively process each key in the dictionary.
                new_dict = {}
                for k, v in value.items():
                    new_dict[k] = format_numpy_result(v)
                return new_dict
            elif isinstance(value, list):
                # Recursively process each element in the list.
                return [format_numpy_result(x) for x in value]
            elif isinstance(value, tuple):
                return tuple(format_numpy_result(x) for x in value)
            elif isinstance(value, struct):
                return value.npstr()
            elif np.isscalar(value):
                # For scalars: if numeric, use str() to avoid extra quotes.
                if isinstance(value, (int, float, complex, str)) or value is None:
                    return value
                else:
                    return repr(value)
            elif isinstance(value, np.ndarray):
                # Check if the array has exactly one element.
                if value.size == 1:
                    # Extract the scalar value.
                    return repr(value.item())
                # Convert the array to a nested list.
                nested_list = value.tolist()
                # Recursively format the nested list into a valid string.
                def list_to_string(lst):
                    if isinstance(lst, list):
                        return &#34;[&#34; + &#34;,&#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                    else:
                        return repr(lst)
                return list_to_string(nested_list)
            else:
                # Return the input unmodified if not a NumPy array, list, dict, or scalar.
                return str(value) # str() preferred over repr() for concision
        # Process all entries in self.
        for key, value in self.items():
            out.setattr(key, format_numpy_result(value))
        return out

    # minimal replacement of placeholders by numbers or their string representations
    def numrepl(self, text):
        r&#34;&#34;&#34;
        Replace all placeholders of the form ${key} in the given text by the corresponding
        numeric value from the instance fields, under the following conditions:

        1. &#39;key&#39; must be a valid field in self (i.e., if key in self).
        2. The value corresponding to &#39;key&#39; is either:
             - an int,
             - a float, or
             - a string that represents a valid number (e.g., &#34;1&#34; or &#34;1.0&#34;).

        Only when these conditions are met, the placeholder is substituted.
        The conversion preserves the original type: if the stored value is int, then the
        substitution will be done as an integer (e.g., 1 and not 1.0). Otherwise, if it is
        a float then it will be substituted as a float.

        Any placeholder for which the above conditions are not met remains unchanged.

        Placeholders are recognized by the pattern &#34;${&lt;key&gt;}&#34; where &lt;key&gt; is captured as all
        text until the next &#34;}&#34; (optionally allowing whitespace inside the braces).
        &#34;&#34;&#34;
        # Pattern: match &#34;${&#34;, then optional whitespace, capture all characters until &#34;}&#34;,
        # then optional whitespace, then &#34;}&#34;.
        placeholder_pattern = re.compile(r&#34;\$\{\s*([^}]+?)\s*\}&#34;)

        def replace_match(match):
            key = match.group(1)
            # Check if the key exists in self.
            if key in self:
                value = self[key]
                # If the value is already numeric, substitute directly.
                if isinstance(value, (int, float)):
                    return str(value)
                # If the value is a string, try to interpret it as a numeric value.
                elif isinstance(value, str):
                    s = value.strip()
                    # Check if s is a valid integer representation.
                    if re.fullmatch(r&#34;[+-]?\d+&#34;, s):
                        try:
                            num = int(s)
                            return str(num)
                        except ValueError:
                            # Should not occur because the regex already matched.
                            return match.group(0)
                    # Check if s is a valid float representation (including scientific notation).
                    elif re.fullmatch(r&#34;[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?&#34;, s):
                        try:
                            num = float(s)
                            return str(num)
                        except ValueError:
                            return match.group(0)
            # If key not in self or value is not numeric (or numeric string), leave placeholder intact.
            return match.group(0)

        # Replace all placeholders in the text using the replacer function.
        return placeholder_pattern.sub(replace_match, text)

    # import method
    def importfrom(self, s, nonempty=True, replacedefaultvar=True):
        &#34;&#34;&#34;
        Import values from &#39;s&#39; into self according to the following rules:

        - Only fields that already exist in self are considered.
        - If s is a dictionary, it is converted to a struct via struct(**s).
        - If the current value of a field in self is empty (None, &#34;&#34;, [] or ()),
          then that field is updated from s.
        - If nonempty is True (default), then only non-empty values from s are imported.
        - If replacedefaultvar is True (default), then if a field in self exactly equals
          &#34;${key}&#34; (with key being the field name), it is replaced by the corresponding
          value from s if it is empty.
        - Raises a TypeError if s is not a dict or struct (i.e. if it doesnâ€™t support keys()).
        &#34;&#34;&#34;
        # If s is a dictionary, convert it to a struct instance.
        if isinstance(s, dict):
            s = struct(**s)
        elif not hasattr(s, &#34;keys&#34;):
            raise TypeError(f&#34;s must be a struct or a dictionary not a type {type(s).__name__}&#34;)

        for key in self.keys():
            if key in s:
                s_value = getattr(s, key)
                current_value = getattr(self, key)
                if is_empty(current_value) or (replacedefaultvar and current_value == &#34;${&#34; + key + &#34;}&#34;):
                    if nonempty:
                        if not is_empty(s_value):
                            setattr(self, key, s_value)
                    else:
                        setattr(self, key, s_value)

    # importfrom with copy
    def __lshift__(self, other):
        &#34;&#34;&#34;
        Allows the syntax:

            s = s1 &lt;&lt; s2

        where a new instance is created as a copy of s1 (preserving its type, whether
        struct, param, or paramauto) and then updated with the values from s2 using
        importfrom.
        &#34;&#34;&#34;
        # Create a new instance preserving the type of self.
        new_instance = type(self)(**{k: getattr(self, k) for k in self.keys()})
        # Import values from other (s2) into the new instance.
        new_instance.importfrom(other)
        return new_instance

    # returns only valid keys
    def validkeys(self, list_of_keys):
        &#34;&#34;&#34;
        Validate and return the subset of keys from the provided list that are valid in the instance.

        Parameters:
        -----------
        list_of_keys : list
            A list of keys (as strings) to check against the instanceâ€™s attributes.

        Returns:
        --------
        list
            A list of keys from list_of_keys that are valid (i.e., exist as attributes in the instance).

        Raises:
        -------
        TypeError
            If list_of_keys is not a list or if any element in list_of_keys is not a string.

        Example:
        --------
        &gt;&gt;&gt; s = struct()
        &gt;&gt;&gt; s.foo = 42
        &gt;&gt;&gt; s.bar = &#34;hello&#34;
        &gt;&gt;&gt; valid = s.validkeys([&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;])
        &gt;&gt;&gt; print(valid)   # Output: [&#39;foo&#39;, &#39;bar&#39;] assuming &#39;baz&#39; is not defined in s
        &#34;&#34;&#34;
        # Check that list_of_keys is a list
        if not isinstance(list_of_keys, list):
            raise TypeError(&#34;list_of_keys must be a list&#34;)

        # Check that every entry in the list is a string
        for key in list_of_keys:
            if not isinstance(key, str):
                raise TypeError(&#34;Each key in list_of_keys must be a string&#34;)

        # Assuming valid keys are those present in the instance&#39;s __dict__
        return [key for key in list_of_keys if key in self]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.raster.collection</li>
<li>pizza.region.regioncollection</li>
<li>pizza.script.scriptobject</li>
<li>pizza.script.scriptobjectgroup</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dforcefield.struct.dict2struct"><code class="name flex">
<span>def <span class="ident">dict2struct</span></span>(<span>dico, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>create a structure from a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dict2struct(dico,makeparam=False):
    &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
    if isinstance(dico,dict):
        s = param() if makeparam else struct()
        s.set(**dico)
        return s
    raise TypeError(&#34;the argument must be a dictionary&#34;)</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.format_array"><code class="name flex">
<span>def <span class="ident">format_array</span></span>(<span>value, numfmt='.4g')</span>
</code></dt>
<dd>
<div class="desc"><p>Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
Recursively formats multi-dimensional arrays without introducing unwanted commas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The NumPy array to format.</dd>
<dt><strong><code>numfmt</code></strong></dt>
<dd>numeric format to be used for the string conversion (default=".4g")</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representation of the array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_array(value,numfmt=&#34;.4g&#34;):
    &#34;&#34;&#34;
    Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
    Recursively formats multi-dimensional arrays without introducing unwanted commas.

    Args:
        value (np.ndarray): The NumPy array to format.
        numfmt: numeric format to be used for the string conversion (default=&#34;.4g&#34;)

    Returns:
        str: A formatted string representation of the array.
    &#34;&#34;&#34;
    dtype_str = {
        np.float64: &#34;double&#34;,
        np.float32: &#34;single&#34;,
        np.int32: &#34;int32&#34;,
        np.int64: &#34;int64&#34;,
        np.complex64: &#34;complex single&#34;,
        np.complex128: &#34;complex double&#34;,
    }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

    max_display = 10  # Maximum number of elements to display

    def format_recursive(arr):
        &#34;&#34;&#34;
        Recursively formats the array based on its dimensions.

        Args:
            arr (np.ndarray): The array or sub-array to format.

        Returns:
            str: Formatted string of the array.
        &#34;&#34;&#34;
        if arr.ndim == 0:
            return f&#34;{arr.item()}&#34;

        if arr.ndim == 1:
            if len(arr) &lt;= max_display:
                return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr) + &#34;]&#34;
            else:
                return f&#34;[{len(arr)} elements]&#34;

        if arr.ndim == 2:
            if arr.shape[1] == 1:
                # Column vector
                if arr.shape[0] &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in arr) + &#34;]T&#34;
                else:
                    return f&#34;[{arr.shape[0]}Ã—1 vector]&#34;
            elif arr.shape[0] == 1:
                # Row vector
                if arr.shape[1] &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr[0]) + &#34;]&#34;
                else:
                    return f&#34;[1Ã—{arr.shape[1]} vector]&#34;
            else:
                # General matrix
                return f&#34;[{arr.shape[0]}Ã—{arr.shape[1]} matrix]&#34;

        # For higher dimensions
        shape_str = &#34;Ã—&#34;.join(map(str, arr.shape))
        if arr.size &lt;= max_display:
            # Show full content
            if arr.ndim &gt; 2:
                # Represent multi-dimensional arrays with nested brackets
                return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
        return f&#34;[{shape_str} array ({dtype_str})]&#34;

    if value.size == 0:
        return &#34;[]&#34;

    if value.ndim == 0 or value.size == 1:
        return f&#34;{value.item()} ({dtype_str})&#34;

    if value.ndim == 1 or value.ndim == 2:
        # Use existing logic for vectors and matrices
        if value.ndim == 1:
            if len(value) &lt;= max_display:
                formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
            else:
                formatted = f&#34;[{len(value)}Ã—1 {dtype_str}]&#34;
        elif value.ndim == 2:
            rows, cols = value.shape
            if cols == 1:  # Column vector
                if rows &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{rows}Ã—1 {dtype_str}]&#34;
            elif rows == 1:  # Row vector
                if cols &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[1Ã—{cols} {dtype_str}]&#34;
            else:  # General matrix
                formatted = f&#34;[{rows}Ã—{cols} {dtype_str}]&#34;
        return formatted

    # For higher-dimensional arrays
    if value.size &lt;= max_display:
        formatted = format_recursive(value)
    else:
        shape_str = &#34;Ã—&#34;.join(map(str, value.shape))
        formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

    return formatted</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.fromkeysvalues"><code class="name flex">
<span>def <span class="ident">fromkeysvalues</span></span>(<span>keys, values, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>struct.keysvalues(keys,values) creates a structure from keys and values
use makeparam = True to create a param instead of struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromkeysvalues(keys,values,makeparam=False):
    &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
        use makeparam = True to create a param instead of struct
    &#34;&#34;&#34;
    if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
    if not isinstance(keys,_list_types): keys = [keys]
    if not isinstance(values,_list_types): values = [values]
    nk,nv = len(keys), len(values)
    s = param() if makeparam else struct()
    if nk&gt;0 and nv&gt;0:
        iv = 0
        for ik in range(nk):
            s.setattr(keys[ik], values[iv])
            iv = min(nv-1,iv+1)
        for ik in range(nk,nv):
            s.setattr(f&#34;key{ik}&#34;, values[ik])
    return s</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.isstrdefined"><code class="name flex">
<span>def <span class="ident">isstrdefined</span></span>(<span>s, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrdefined(string,ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrdefined(s,ref):
    &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
    if struct.isstrexpression(s):
        k = struct.scan(s).keys()
        allfound,i,nk = True,0,len(k)
        while (i&lt;nk) and allfound:
            allfound = k[i] in ref
            i += 1
        return allfound
    else:
        return False</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.isstrexpression"><code class="name flex">
<span>def <span class="ident">isstrexpression</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrexpression(string) returns true if s contains an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrexpression(s):
    &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    return re.search(r&#34;\$\{.*?\}&#34;,s) is not None</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>read the equivalent structure
read(filename)</p>
<p>Parameters:
- file: The file path to read from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read(file):
    &#34;&#34;&#34;
        read the equivalent structure
            read(filename)

        Parameters:
        - file: The file path to read from.
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()
    # Check if the parent directory exists, otherwise raise an error
    if not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If the file does not exist, raise an exception
    if not file_path.exists():
        raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
    # Open and read the file
    with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
        s = struct()  # Assuming struct is defined elsewhere
        while True:
            line = f.readline()
            if not line:
                break
            line = line.strip()
            expr = line.split(sep=&#34;=&#34;)
            if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                lhs = expr[0]
                rhs = &#34;&#34;.join(expr[1:]).strip()
                if len(rhs) == 0 or rhs == &#34;None&#34;:
                    v = None
                else:
                    v = eval(rhs)
                s.setattr(lhs, v)
    return s</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>scan(string) scan a string for variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def scan(s):
    &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
    tmp = struct()
    #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
    found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
    uniq = []
    for x in found:
        if x not in uniq: uniq.append(x)
    return tmp.fromkeys(uniq)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dforcefield.struct.isempty"><code class="name">var <span class="ident">isempty</span></code></dt>
<dd>
<div class="desc"><p>isempty is set to True for an empty structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isempty(self):
    &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
    return len(self)==0</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.isexpression"><code class="name">var <span class="ident">isexpression</span></code></dt>
<dd>
<div class="desc"><p>same structure with True if it is an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isexpression(self):
    &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    for k,v in self.items():
        if isinstance(v,str):
            s.setattr(k,struct.isstrexpression(v))
        else:
            s.setattr(k,False)
    return s</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dforcefield.struct.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, default)</span>
</code></dt>
<dd>
<div class="desc"><p>populate fields from a default structure
check(defaultstruct)
missing field, None and [] values are replaced by default ones</p>
<pre><code>Note: a.check(b) is equivalent to b+a except for [] and None values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self,default):
    &#34;&#34;&#34;
    populate fields from a default structure
        check(defaultstruct)
        missing field, None and [] values are replaced by default ones

        Note: a.check(b) is equivalent to b+a except for [] and None values
    &#34;&#34;&#34;
    if not isinstance(default,struct):
        raise TypeError(&#34;the first argument must be a structure&#34;)
    for f in default.keys():
        ref = default.getattr(f)
        if f not in self:
            self.setattr(f, ref)
        else:
            current = self.getattr(f)
            if ((current is None)  or (current==[])) and \
                ((ref is not None) and (ref!=[])):
                    self.setattr(f, ref)</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear() delete all fields while preserving the original class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
    for k in self.keys(): delattr(self,k)</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.disp"><code class="name flex">
<span>def <span class="ident">disp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>display method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disp(self):
    &#34;&#34;&#34; display method &#34;&#34;&#34;
    self.__repr__()</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.dispmax"><code class="name flex">
<span>def <span class="ident">dispmax</span></span>(<span>self, content)</span>
</code></dt>
<dd>
<div class="desc"><p>optimize display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispmax(self,content):
    &#34;&#34;&#34; optimize display &#34;&#34;&#34;
    strcontent = str(content)
    if len(strcontent)&gt;self._maxdisplay:
        nchar = round(self._maxdisplay/2)
        return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
    else:
        return content</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Format a string with fields using {field} as placeholders.
Handles expressions like ${variable1}.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>The input string to format.</dd>
<dt><strong><code>escape</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, prevents replacing '${' with '{'.</dd>
<dt><strong><code>raiseerror</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, raises errors for missing fields.</dd>
</dl>
<h2 id="note">Note</h2>
<p>NumPy vectors and matrices are converted into their text representation (default behavior)
If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, s, escape=False, raiseerror=True):
    &#34;&#34;&#34;
        Format a string with fields using {field} as placeholders.
        Handles expressions like ${variable1}.

        Args:
            s (str): The input string to format.
            escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
            raiseerror (bool): If True, raises errors for missing fields.

        Note:
            NumPy vectors and matrices are converted into their text representation (default behavior)
            If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

        Returns:
            str: The formatted string.
    &#34;&#34;&#34;
    tmp = self.np2str()
    if raiseerror:
        try:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
        except AttributeError as attr_err:
            # Handle AttributeError for expressions with operators
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            if self._debug:
                print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
            return s_  # Revert to using &#39;${&#39; for unresolved expressions
        except IndexError as idx_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            if self._debug:
                print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
            raise IndexError from idx_err
        except Exception as other_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            raise RuntimeError from other_err
    else:
        if escape:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.format_map(AttrErrorDict(tmp.__dict__))
            except: # if an error occurs, we use the orginal content
                return s.format_map(AttrErrorDict(self.__dict__))
        else:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
            except:  # if an error occurs, we use the orginal content
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.format_legacy"><code class="name flex">
<span>def <span class="ident">format_legacy</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>format a string with field (use {field} as placeholders)
s.replace(string), s.replace(string,escape=True)
where:
s is a struct object
string is a string with possibly ${variable1}
escape is a flag to prevent ${} replaced by {}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_legacy(self,s,escape=False,raiseerror=True):
    &#34;&#34;&#34;
        format a string with field (use {field} as placeholders)
            s.replace(string), s.replace(string,escape=True)
            where:
                s is a struct object
                string is a string with possibly ${variable1}
                escape is a flag to prevent ${} replaced by {}
    &#34;&#34;&#34;
    if raiseerror:
        try:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
        except KeyError as kerr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
            return s_ # instead of s (we put back $) - OV 2023/01/27
        except Exception as othererr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            raise RuntimeError from othererr
    else:
        if escape:
            return s.format(**self.__dict__)
        else:
            return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.fromkeys"><code class="name flex">
<span>def <span class="ident">fromkeys</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a structure from keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromkeys(self,keys):
    &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
    return self+struct(**dict.fromkeys(keys,None))</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self, printout=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Python code of the equivalent structure.</p>
<p>This method converts the current structure (an instance of <code>param</code>, <code>paramauto</code>, or <code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a></code>)
into Python code that, when executed, recreates an equivalent structure. The generated code is
formatted with one field per line.</p>
<p>By default (when <code>printout</code> is False), the generated code is returned as a raw string that starts
directly with, for example, <code>param(</code> (or <code>paramauto(</code> or <code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a>(</code>), with no "X = " prefix or leading
newline. When <code>printout</code> is True, the generated code is printed to standard output and includes a prefix
"X = " to indicate the variable name.</p>
<h2 id="parameters">Parameters</h2>
<p>printout (bool): If True, the generated code is printed to standard output with the "X = " prefix.
If False (default), the code is returned as a raw string starting with, e.g.,
<code>param(</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated Python code representing the structure (regardless of whether it was printed).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self, printout=False):
    &#34;&#34;&#34;
    Generate Python code of the equivalent structure.

    This method converts the current structure (an instance of `param`, `paramauto`, or `struct`)
    into Python code that, when executed, recreates an equivalent structure. The generated code is
    formatted with one field per line.

    By default (when `printout` is False), the generated code is returned as a raw string that starts
    directly with, for example, `param(` (or `paramauto(` or `struct(`), with no &#34;X = &#34; prefix or leading
    newline. When `printout` is True, the generated code is printed to standard output and includes a prefix
    &#34;X = &#34; to indicate the variable name.

    Parameters:
        printout (bool): If True, the generated code is printed to standard output with the &#34;X = &#34; prefix.
                         If False (default), the code is returned as a raw string starting with, e.g.,
                         `param(`.

    Returns:
        str: The generated Python code representing the structure (regardless of whether it was printed).
    &#34;&#34;&#34;
    nk = len(self)
    tmp = self.np2str()
    # Compute the field format based on the maximum key length (with a minimum width of 10)
    fmt = &#34;%%%ss =&#34; % max(10, max([len(k) for k in self.keys()]) + 2)
    # Determine the appropriate class string for the current instance.
    if isinstance(self, param):
        classstr = &#34;param&#34;
    elif &#39;paramauto&#39; in globals() and isinstance(self, paramauto):
        classstr = &#34;paramauto&#34;
    else:
        classstr = &#34;struct&#34;

    lines = []
    if nk == 0:
        # For an empty structure.
        if printout:
            lines.append(f&#34;X = {classstr}()&#34;)
        else:
            lines.append(f&#34;{classstr}()&#34;)
    else:
        # Header: include &#34;X = &#34; only if printing.
        if printout:
            header = f&#34;X = {classstr}(&#34;
        else:
            header = f&#34;{classstr}(&#34;
        lines.append(header)
        # Iterate over keys to generate each field line.
        for i, k in enumerate(self.keys()):
            v = getattr(self, k)
            if isinstance(v, np.ndarray):
                vtmp = getattr(tmp, k)
                field = fmt % k + &#34; &#34; + vtmp
            elif isinstance(v, (int, float)) or v is None:
                field = fmt % k + &#34; &#34; + str(v)
            elif isinstance(v, str):
                field = fmt % k + &#34; &#34; + f&#39;&#34;{v}&#34;&#39;
            elif isinstance(v, (list, tuple, dict)):
                field = fmt % k + &#34; &#34; + str(v)
            else:
                field = fmt % k + &#34; &#34; + &#34;/* unsupported type */&#34;
            # Append a comma after each field except the last one.
            if i &lt; nk - 1:
                field += &#34;,&#34;
            lines.append(field)
        # Create a closing line that aligns the closing parenthesis.
        closing_line = fmt[:-1] % &#34;)&#34;
        lines.append(closing_line)
    result = &#34;\n&#34;.join(lines)
    if printout:
        print(result)
        return None
    return result</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.getattr"><code class="name flex">
<span>def <span class="ident">getattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get attribute override to access both instance attributes and properties if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getattr(self,key):
    &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
    if key in self.__dict__:
        return self.__dict__[key]
    elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
         key not in self._excludedattr and \
         key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
        # If _propertyasattribute is True and it&#39;s a property, get its value
        return self.__class__.__dict__[key].fget(self)
    else:
        raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.hasattr"><code class="name flex">
<span>def <span class="ident">hasattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the field exists, considering properties as regular attributes if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasattr(self, key):
    &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
    return key in self.__dict__ or (
        getattr(self, &#39;_propertyasattribute&#39;, False) and
        key not in self._excludedattr and
        key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
    )</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.importfrom"><code class="name flex">
<span>def <span class="ident">importfrom</span></span>(<span>self, s, nonempty=True, replacedefaultvar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Import values from 's' into self according to the following rules:</p>
<ul>
<li>Only fields that already exist in self are considered.</li>
<li>If s is a dictionary, it is converted to a struct via struct(**s).</li>
<li>If the current value of a field in self is empty (None, "", [] or ()),
then that field is updated from s.</li>
<li>If nonempty is True (default), then only non-empty values from s are imported.</li>
<li>If replacedefaultvar is True (default), then if a field in self exactly equals
"${key}" (with key being the field name), it is replaced by the corresponding
value from s if it is empty.</li>
<li>Raises a TypeError if s is not a dict or struct (i.e. if it doesnâ€™t support keys()).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importfrom(self, s, nonempty=True, replacedefaultvar=True):
    &#34;&#34;&#34;
    Import values from &#39;s&#39; into self according to the following rules:

    - Only fields that already exist in self are considered.
    - If s is a dictionary, it is converted to a struct via struct(**s).
    - If the current value of a field in self is empty (None, &#34;&#34;, [] or ()),
      then that field is updated from s.
    - If nonempty is True (default), then only non-empty values from s are imported.
    - If replacedefaultvar is True (default), then if a field in self exactly equals
      &#34;${key}&#34; (with key being the field name), it is replaced by the corresponding
      value from s if it is empty.
    - Raises a TypeError if s is not a dict or struct (i.e. if it doesnâ€™t support keys()).
    &#34;&#34;&#34;
    # If s is a dictionary, convert it to a struct instance.
    if isinstance(s, dict):
        s = struct(**s)
    elif not hasattr(s, &#34;keys&#34;):
        raise TypeError(f&#34;s must be a struct or a dictionary not a type {type(s).__name__}&#34;)

    for key in self.keys():
        if key in s:
            s_value = getattr(s, key)
            current_value = getattr(self, key)
            if is_empty(current_value) or (replacedefaultvar and current_value == &#34;${&#34; + key + &#34;}&#34;):
                if nonempty:
                    if not is_empty(s_value):
                        setattr(self, key, s_value)
                else:
                    setattr(self, key, s_value)</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.isdefined"><code class="name flex">
<span>def <span class="ident">isdefined</span></span>(<span>self, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>isdefined(ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdefined(self,ref=None):
    &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
    nk = len(k)
    if ref is None:
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
            else:
                s.setattr(k[i],True)
    else:
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],ref))
            else:
                s.setattr(k[i],True)
    return s</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all elements as iterable key, value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
    return self.zip()</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34; return the fields &#34;&#34;&#34;
    # keys() is used by struct() and its iterator
    return [key for key in self.__dict__.keys() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.keyssorted"><code class="name flex">
<span>def <span class="ident">keyssorted</span></span>(<span>self, reverse=True)</span>
</code></dt>
<dd>
<div class="desc"><p>sort keys by length()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyssorted(self,reverse=True):
    &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
    klist = self.keys()
    l = [len(k) for k in klist]
    return [k for _,k in sorted(zip(l,klist),reverse=reverse)]</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.np2str"><code class="name flex">
<span>def <span class="ident">np2str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all NumPy entries of s into their string representations, handling both lists and dictionaries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def np2str(self):
    &#34;&#34;&#34; Convert all NumPy entries of s into their string representations, handling both lists and dictionaries. &#34;&#34;&#34;
    out = struct()
    def format_numpy_result(value):
        &#34;&#34;&#34;
        Converts a NumPy array or scalar into a string representation:
        - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
        - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
        - If the value is a list or dict, the conversion is applied recursively.
        - Non-ndarray inputs that are not list/dict are returned without modification.

        Args:
            value (np.ndarray, scalar, list, dict, or other): The value to format.

        Returns:
            str, list, dict, or original type: A properly formatted string for NumPy arrays/scalars,
            a recursively converted list/dict, or the original value.
        &#34;&#34;&#34;
        if isinstance(value, dict):
            # Recursively process each key in the dictionary.
            new_dict = {}
            for k, v in value.items():
                new_dict[k] = format_numpy_result(v)
            return new_dict
        elif isinstance(value, list):
            # Recursively process each element in the list.
            return [format_numpy_result(x) for x in value]
        elif isinstance(value, tuple):
            return tuple(format_numpy_result(x) for x in value)
        elif isinstance(value, struct):
            return value.npstr()
        elif np.isscalar(value):
            # For scalars: if numeric, use str() to avoid extra quotes.
            if isinstance(value, (int, float, complex, str)) or value is None:
                return value
            else:
                return repr(value)
        elif isinstance(value, np.ndarray):
            # Check if the array has exactly one element.
            if value.size == 1:
                # Extract the scalar value.
                return repr(value.item())
            # Convert the array to a nested list.
            nested_list = value.tolist()
            # Recursively format the nested list into a valid string.
            def list_to_string(lst):
                if isinstance(lst, list):
                    return &#34;[&#34; + &#34;,&#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                else:
                    return repr(lst)
            return list_to_string(nested_list)
        else:
            # Return the input unmodified if not a NumPy array, list, dict, or scalar.
            return str(value) # str() preferred over repr() for concision
    # Process all entries in self.
    for key, value in self.items():
        out.setattr(key, format_numpy_result(value))
    return out</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.numrepl"><code class="name flex">
<span>def <span class="ident">numrepl</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace all placeholders of the form ${key} in the given text by the corresponding
numeric value from the instance fields, under the following conditions:</p>
<ol>
<li>'key' must be a valid field in self (i.e., if key in self).</li>
<li>The value corresponding to 'key' is either:<ul>
<li>an int,</li>
<li>a float, or</li>
<li>a string that represents a valid number (e.g., "1" or "1.0").</li>
</ul>
</li>
</ol>
<p>Only when these conditions are met, the placeholder is substituted.
The conversion preserves the original type: if the stored value is int, then the
substitution will be done as an integer (e.g., 1 and not 1.0). Otherwise, if it is
a float then it will be substituted as a float.</p>
<p>Any placeholder for which the above conditions are not met remains unchanged.</p>
<p>Placeholders are recognized by the pattern "${<key>}" where <key> is captured as all
text until the next "}" (optionally allowing whitespace inside the braces).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numrepl(self, text):
    r&#34;&#34;&#34;
    Replace all placeholders of the form ${key} in the given text by the corresponding
    numeric value from the instance fields, under the following conditions:

    1. &#39;key&#39; must be a valid field in self (i.e., if key in self).
    2. The value corresponding to &#39;key&#39; is either:
         - an int,
         - a float, or
         - a string that represents a valid number (e.g., &#34;1&#34; or &#34;1.0&#34;).

    Only when these conditions are met, the placeholder is substituted.
    The conversion preserves the original type: if the stored value is int, then the
    substitution will be done as an integer (e.g., 1 and not 1.0). Otherwise, if it is
    a float then it will be substituted as a float.

    Any placeholder for which the above conditions are not met remains unchanged.

    Placeholders are recognized by the pattern &#34;${&lt;key&gt;}&#34; where &lt;key&gt; is captured as all
    text until the next &#34;}&#34; (optionally allowing whitespace inside the braces).
    &#34;&#34;&#34;
    # Pattern: match &#34;${&#34;, then optional whitespace, capture all characters until &#34;}&#34;,
    # then optional whitespace, then &#34;}&#34;.
    placeholder_pattern = re.compile(r&#34;\$\{\s*([^}]+?)\s*\}&#34;)

    def replace_match(match):
        key = match.group(1)
        # Check if the key exists in self.
        if key in self:
            value = self[key]
            # If the value is already numeric, substitute directly.
            if isinstance(value, (int, float)):
                return str(value)
            # If the value is a string, try to interpret it as a numeric value.
            elif isinstance(value, str):
                s = value.strip()
                # Check if s is a valid integer representation.
                if re.fullmatch(r&#34;[+-]?\d+&#34;, s):
                    try:
                        num = int(s)
                        return str(num)
                    except ValueError:
                        # Should not occur because the regex already matched.
                        return match.group(0)
                # Check if s is a valid float representation (including scientific notation).
                elif re.fullmatch(r&#34;[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?&#34;, s):
                    try:
                        num = float(s)
                        return str(num)
                    except ValueError:
                        return match.group(0)
        # If key not in self or value is not numeric (or numeric string), leave placeholder intact.
        return match.group(0)

    # Replace all placeholders in the text using the replacer function.
    return placeholder_pattern.sub(replace_match, text)</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self,**kwargs):
    &#34;&#34;&#34; initialization &#34;&#34;&#34;
    self.__dict__.update(kwargs)</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.setattr"><code class="name flex">
<span>def <span class="ident">setattr</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>set field and value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setattr(self,key,value):
    &#34;&#34;&#34; set field and value &#34;&#34;&#34;
    if isinstance(value,list) and len(value)==0 and key in self:
        delattr(self, key)
    else:
        self.__dict__[key] = value</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.sortdefinitions"><code class="name flex">
<span>def <span class="ident">sortdefinitions</span></span>(<span>self, raiseerror=True, silentmode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>sortdefintions sorts all definitions
so that they can be executed as param().
If any inconsistency is found, an error message is generated.</p>
<p>Flags = default values
raiseerror=True show erros of True
silentmode=False no warning if True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortdefinitions(self,raiseerror=True,silentmode=False):
    &#34;&#34;&#34; sortdefintions sorts all definitions
        so that they can be executed as param().
        If any inconsistency is found, an error message is generated.

        Flags = default values
            raiseerror=True show erros of True
            silentmode=False no warning if True
    &#34;&#34;&#34;
    find = lambda xlist: [i for i, x in enumerate(xlist) if x]
    findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
    k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
    istatic = findnot(isexpr)
    idynamic = find(isexpr)
    static = struct.fromkeysvalues(
        [ k[i] for i in istatic ],
        [ v[i] for i in istatic ],
        makeparam = False)
    dynamic = struct.fromkeysvalues(
        [ k[i] for i in idynamic ],
        [ v[i] for i in idynamic ],
        makeparam=False)
    current = static # make static the current structure
    nmissing, anychange, errorfound = len(dynamic), False, False
    while nmissing:
        itst, found = 0, False
        while itst&lt;nmissing and not found:
            teststruct = current + dynamic[[itst]] # add the test field
            found = all(list(teststruct.isdefined()))
            ifound = itst
            itst += 1
        if found:
            current = teststruct # we accept the new field
            dynamic[ifound] = []
            nmissing -= 1
            anychange = True
        else:
            if raiseerror:
                raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                               (nmissing,len(self),self._ftype))
            else:
                if (not errorfound) and (not silentmode):
                    print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                          (nmissing,len(self),self._ftype))
                current = teststruct # we accept the new field (even if it cannot be interpreted)
                dynamic[ifound] = []
                nmissing -= 1
                errorfound = True
    if anychange:
        self.clear() # reset all fields and assign them in the proper order
        k,v = current.keys(), current.values()
        for i in range(len(k)):
            self.setattr(k[i],v[i])</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.struct2dict"><code class="name flex">
<span>def <span class="ident">struct2dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create a dictionary from the current structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2dict(self):
    &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
    return dict(self.zip())</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.struct2param"><code class="name flex">
<span>def <span class="ident">struct2param</span></span>(<span>self, protection=False, evaluation=True)</span>
</code></dt>
<dd>
<div class="desc"><p>convert an object struct() to param()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2param(self,protection=False,evaluation=True):
    &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
    p = param(**self.struct2dict())
    for i in range(len(self)):
        if isinstance(self[i],pstr): p[i] = pstr(p[i])
    p._protection = protection
    p._evaluation = evaluation
    return p</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update multiple fields at once, while protecting certain attributes.</p>
<h2 id="parameters">Parameters:</h2>
<p>**kwargs : dict
The fields to update and their new values.</p>
<p>Protected attributes defined in _excludedattr are not updated.</p>
<h2 id="usage">Usage:</h2>
<p>s.update(a=10, b=[1, 2, 3], new_field="new_value")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update multiple fields at once, while protecting certain attributes.

    Parameters:
    -----------
    **kwargs : dict
        The fields to update and their new values.

    Protected attributes defined in _excludedattr are not updated.

    Usage:
    ------
    s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
    &#34;&#34;&#34;
    protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

    for key, value in kwargs.items():
        if key in protected_attributes:
            print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
        else:
            self.setattr(key, value)</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.validkeys"><code class="name flex">
<span>def <span class="ident">validkeys</span></span>(<span>self, list_of_keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate and return the subset of keys from the provided list that are valid in the instance.</p>
<h2 id="parameters">Parameters:</h2>
<p>list_of_keys : list
A list of keys (as strings) to check against the instanceâ€™s attributes.</p>
<h2 id="returns">Returns:</h2>
<p>list
A list of keys from list_of_keys that are valid (i.e., exist as attributes in the instance).</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If list_of_keys is not a list or if any element in list_of_keys is not a string.</p>
<h2 id="example">Example:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; s = struct()
&gt;&gt;&gt; s.foo = 42
&gt;&gt;&gt; s.bar = &quot;hello&quot;
&gt;&gt;&gt; valid = s.validkeys([&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;])
&gt;&gt;&gt; print(valid)   # Output: ['foo', 'bar'] assuming 'baz' is not defined in s
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validkeys(self, list_of_keys):
    &#34;&#34;&#34;
    Validate and return the subset of keys from the provided list that are valid in the instance.

    Parameters:
    -----------
    list_of_keys : list
        A list of keys (as strings) to check against the instanceâ€™s attributes.

    Returns:
    --------
    list
        A list of keys from list_of_keys that are valid (i.e., exist as attributes in the instance).

    Raises:
    -------
    TypeError
        If list_of_keys is not a list or if any element in list_of_keys is not a string.

    Example:
    --------
    &gt;&gt;&gt; s = struct()
    &gt;&gt;&gt; s.foo = 42
    &gt;&gt;&gt; s.bar = &#34;hello&#34;
    &gt;&gt;&gt; valid = s.validkeys([&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;])
    &gt;&gt;&gt; print(valid)   # Output: [&#39;foo&#39;, &#39;bar&#39;] assuming &#39;baz&#39; is not defined in s
    &#34;&#34;&#34;
    # Check that list_of_keys is a list
    if not isinstance(list_of_keys, list):
        raise TypeError(&#34;list_of_keys must be a list&#34;)

    # Check that every entry in the list is a string
    for key in list_of_keys:
        if not isinstance(key, str):
            raise TypeError(&#34;Each key in list_of_keys must be a string&#34;)

    # Assuming valid keys are those present in the instance&#39;s __dict__
    return [key for key in list_of_keys if key in self]</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34; return the values &#34;&#34;&#34;
    # values() is used by struct() and its iterator
    return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, overwrite=True, mkdir=False)</span>
</code></dt>
<dd>
<div class="desc"><p>write the equivalent structure (not recursive for nested struct)
write(filename, overwrite=True, mkdir=False)</p>
<p>Parameters:
- file: The file path to write to.
- overwrite: Whether to overwrite the file if it exists (default: True).
- mkdir: Whether to create the directory if it doesn't exist (default: False).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, overwrite=True, mkdir=False):
    &#34;&#34;&#34;
        write the equivalent structure (not recursive for nested struct)
            write(filename, overwrite=True, mkdir=False)

        Parameters:
        - file: The file path to write to.
        - overwrite: Whether to overwrite the file if it exists (default: True).
        - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()

    # Check if the directory exists or if mkdir is set to True, create it
    if mkdir:
        file_path.parent.mkdir(parents=True, exist_ok=True)
    elif not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If overwrite is False and the file already exists, raise an exception
    if not overwrite and file_path.exists():
        raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
    # Convert to static if needed
    if isinstance(p,(param,paramauto)):
        tmp = self.tostatic()
    else:
        tmp = self
    # Open and write to the file using the resolved path
    with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
        print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
        for k, v in tmp.items():
            if v is None:
                print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
            elif isinstance(v, (int, float)):
                print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
            elif isinstance(v, str):
                print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
            else:
                print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="dforcefield.struct.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>zip keys and values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self):
    &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
    return zip(self.keys(),self.values())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#synopsis-of-dforcefield-class">Synopsis of dforcefield Class</a><ul>
<li><a href="#key-differences-between-forcefield-generic-and-dforcefield">Key Differences Between forcefield, generic, and dforcefield:</a></li>
<li><a href="#key-attributes">Key Attributes:</a></li>
<li><a href="#key-methods">Key Methods:</a></li>
<li><a href="#usage-example">Usage Example:</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#license">License</a></li>
<li><a href="#contact">Contact</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dforcefield.autoname" href="#dforcefield.autoname">autoname</a></code></li>
<li><code><a title="dforcefield.remove_comments" href="#dforcefield.remove_comments">remove_comments</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dforcefield.USERSMD" href="#dforcefield.USERSMD">USERSMD</a></code></h4>
<ul class="">
<li><code><a title="dforcefield.USERSMD.RULES" href="#dforcefield.USERSMD.RULES">RULES</a></code></li>
<li><code><a title="dforcefield.USERSMD.newtonianfluid" href="#dforcefield.USERSMD.newtonianfluid">newtonianfluid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dforcefield.dforcefield" href="#dforcefield.dforcefield">dforcefield</a></code></h4>
<ul class="">
<li><code><a title="dforcefield.dforcefield.RULES" href="#dforcefield.dforcefield.RULES">RULES</a></code></li>
<li><code><a title="dforcefield.dforcefield.base_class_name" href="#dforcefield.dforcefield.base_class_name">base_class_name</a></code></li>
<li><code><a title="dforcefield.dforcefield.base_repr" href="#dforcefield.dforcefield.base_repr">base_repr</a></code></li>
<li><code><a title="dforcefield.dforcefield.combine_parameters" href="#dforcefield.dforcefield.combine_parameters">combine_parameters</a></code></li>
<li><code><a title="dforcefield.dforcefield.compare" href="#dforcefield.dforcefield.compare">compare</a></code></li>
<li><code><a title="dforcefield.dforcefield.copy" href="#dforcefield.dforcefield.copy">copy</a></code></li>
<li><code><a title="dforcefield.dforcefield.detectVariables" href="#dforcefield.dforcefield.detectVariables">detectVariables</a></code></li>
<li><code><a title="dforcefield.dforcefield.dispmax" href="#dforcefield.dforcefield.dispmax">dispmax</a></code></li>
<li><code><a title="dforcefield.dforcefield.extract_default_parameters" href="#dforcefield.dforcefield.extract_default_parameters">extract_default_parameters</a></code></li>
<li><code><a title="dforcefield.dforcefield.from_dict" href="#dforcefield.dforcefield.from_dict">from_dict</a></code></li>
<li><code><a title="dforcefield.dforcefield.generator" href="#dforcefield.dforcefield.generator">generator</a></code></li>
<li><code><a title="dforcefield.dforcefield.get_global" href="#dforcefield.dforcefield.get_global">get_global</a></code></li>
<li><code><a title="dforcefield.dforcefield.get_local" href="#dforcefield.dforcefield.get_local">get_local</a></code></li>
<li><code><a title="dforcefield.dforcefield.get_rules" href="#dforcefield.dforcefield.get_rules">get_rules</a></code></li>
<li><code><a title="dforcefield.dforcefield.items" href="#dforcefield.dforcefield.items">items</a></code></li>
<li><code><a title="dforcefield.dforcefield.keys" href="#dforcefield.dforcefield.keys">keys</a></code></li>
<li><code><a title="dforcefield.dforcefield.list_forcefield_subclasses" href="#dforcefield.dforcefield.list_forcefield_subclasses">list_forcefield_subclasses</a></code></li>
<li><code><a title="dforcefield.dforcefield.load" href="#dforcefield.dforcefield.load">load</a></code></li>
<li><code><a title="dforcefield.dforcefield.merged_name_description" href="#dforcefield.dforcefield.merged_name_description">merged_name_description</a></code></li>
<li><code><a title="dforcefield.dforcefield.missingVariables" href="#dforcefield.dforcefield.missingVariables">missingVariables</a></code></li>
<li><code><a title="dforcefield.dforcefield.pair_diagcoeff" href="#dforcefield.dforcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="dforcefield.dforcefield.pair_offdiagcoeff" href="#dforcefield.dforcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="dforcefield.dforcefield.pair_style" href="#dforcefield.dforcefield.pair_style">pair_style</a></code></li>
<li><code><a title="dforcefield.dforcefield.parsesyntax" href="#dforcefield.dforcefield.parsesyntax">parsesyntax</a></code></li>
<li><code><a title="dforcefield.dforcefield.reset" href="#dforcefield.dforcefield.reset">reset</a></code></li>
<li><code><a title="dforcefield.dforcefield.save" href="#dforcefield.dforcefield.save">save</a></code></li>
<li><code><a title="dforcefield.dforcefield.script" href="#dforcefield.dforcefield.script">script</a></code></li>
<li><code><a title="dforcefield.dforcefield.scriptobject" href="#dforcefield.dforcefield.scriptobject">scriptobject</a></code></li>
<li><code><a title="dforcefield.dforcefield.set_global" href="#dforcefield.dforcefield.set_global">set_global</a></code></li>
<li><code><a title="dforcefield.dforcefield.set_local" href="#dforcefield.dforcefield.set_local">set_local</a></code></li>
<li><code><a title="dforcefield.dforcefield.set_rules" href="#dforcefield.dforcefield.set_rules">set_rules</a></code></li>
<li><code><a title="dforcefield.dforcefield.show" href="#dforcefield.dforcefield.show">show</a></code></li>
<li><code><a title="dforcefield.dforcefield.to_dict" href="#dforcefield.dforcefield.to_dict">to_dict</a></code></li>
<li><code><a title="dforcefield.dforcefield.update" href="#dforcefield.dforcefield.update">update</a></code></li>
<li><code><a title="dforcefield.dforcefield.update_parameters" href="#dforcefield.dforcefield.update_parameters">update_parameters</a></code></li>
<li><code><a title="dforcefield.dforcefield.validate" href="#dforcefield.dforcefield.validate">validate</a></code></li>
<li><code><a title="dforcefield.dforcefield.values" href="#dforcefield.dforcefield.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dforcefield.forcefield" href="#dforcefield.forcefield">forcefield</a></code></h4>
<ul class="two-column">
<li><code><a title="dforcefield.forcefield.beadtype" href="#dforcefield.forcefield.beadtype">beadtype</a></code></li>
<li><code><a title="dforcefield.forcefield.description" href="#dforcefield.forcefield.description">description</a></code></li>
<li><code><a title="dforcefield.forcefield.getallattributes" href="#dforcefield.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="dforcefield.forcefield.name" href="#dforcefield.forcefield.name">name</a></code></li>
<li><code><a title="dforcefield.forcefield.pair_diagcoeff" href="#dforcefield.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="dforcefield.forcefield.pair_offdiagcoeff" href="#dforcefield.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="dforcefield.forcefield.pair_style" href="#dforcefield.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="dforcefield.forcefield.parameters" href="#dforcefield.forcefield.parameters">parameters</a></code></li>
<li><code><a title="dforcefield.forcefield.printheader" href="#dforcefield.forcefield.printheader">printheader</a></code></li>
<li><code><a title="dforcefield.forcefield.userid" href="#dforcefield.forcefield.userid">userid</a></code></li>
<li><code><a title="dforcefield.forcefield.version" href="#dforcefield.forcefield.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dforcefield.generic" href="#dforcefield.generic">generic</a></code></h4>
<ul class="">
<li><code><a title="dforcefield.generic.RULES" href="#dforcefield.generic.RULES">RULES</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dforcefield.genericdata" href="#dforcefield.genericdata">genericdata</a></code></h4>
</li>
<li>
<h4><code><a title="dforcefield.parameterforcefield" href="#dforcefield.parameterforcefield">parameterforcefield</a></code></h4>
</li>
<li>
<h4><code><a title="dforcefield.scriptdata" href="#dforcefield.scriptdata">scriptdata</a></code></h4>
</li>
<li>
<h4><code><a title="dforcefield.scriptobject" href="#dforcefield.scriptobject">scriptobject</a></code></h4>
</li>
<li>
<h4><code><a title="dforcefield.struct" href="#dforcefield.struct">struct</a></code></h4>
<ul class="two-column">
<li><code><a title="dforcefield.struct.check" href="#dforcefield.struct.check">check</a></code></li>
<li><code><a title="dforcefield.struct.clear" href="#dforcefield.struct.clear">clear</a></code></li>
<li><code><a title="dforcefield.struct.dict2struct" href="#dforcefield.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="dforcefield.struct.disp" href="#dforcefield.struct.disp">disp</a></code></li>
<li><code><a title="dforcefield.struct.dispmax" href="#dforcefield.struct.dispmax">dispmax</a></code></li>
<li><code><a title="dforcefield.struct.format" href="#dforcefield.struct.format">format</a></code></li>
<li><code><a title="dforcefield.struct.format_array" href="#dforcefield.struct.format_array">format_array</a></code></li>
<li><code><a title="dforcefield.struct.format_legacy" href="#dforcefield.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="dforcefield.struct.fromkeys" href="#dforcefield.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="dforcefield.struct.fromkeysvalues" href="#dforcefield.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="dforcefield.struct.generator" href="#dforcefield.struct.generator">generator</a></code></li>
<li><code><a title="dforcefield.struct.getattr" href="#dforcefield.struct.getattr">getattr</a></code></li>
<li><code><a title="dforcefield.struct.hasattr" href="#dforcefield.struct.hasattr">hasattr</a></code></li>
<li><code><a title="dforcefield.struct.importfrom" href="#dforcefield.struct.importfrom">importfrom</a></code></li>
<li><code><a title="dforcefield.struct.isdefined" href="#dforcefield.struct.isdefined">isdefined</a></code></li>
<li><code><a title="dforcefield.struct.isempty" href="#dforcefield.struct.isempty">isempty</a></code></li>
<li><code><a title="dforcefield.struct.isexpression" href="#dforcefield.struct.isexpression">isexpression</a></code></li>
<li><code><a title="dforcefield.struct.isstrdefined" href="#dforcefield.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="dforcefield.struct.isstrexpression" href="#dforcefield.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="dforcefield.struct.items" href="#dforcefield.struct.items">items</a></code></li>
<li><code><a title="dforcefield.struct.keys" href="#dforcefield.struct.keys">keys</a></code></li>
<li><code><a title="dforcefield.struct.keyssorted" href="#dforcefield.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="dforcefield.struct.np2str" href="#dforcefield.struct.np2str">np2str</a></code></li>
<li><code><a title="dforcefield.struct.numrepl" href="#dforcefield.struct.numrepl">numrepl</a></code></li>
<li><code><a title="dforcefield.struct.read" href="#dforcefield.struct.read">read</a></code></li>
<li><code><a title="dforcefield.struct.scan" href="#dforcefield.struct.scan">scan</a></code></li>
<li><code><a title="dforcefield.struct.set" href="#dforcefield.struct.set">set</a></code></li>
<li><code><a title="dforcefield.struct.setattr" href="#dforcefield.struct.setattr">setattr</a></code></li>
<li><code><a title="dforcefield.struct.sortdefinitions" href="#dforcefield.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="dforcefield.struct.struct2dict" href="#dforcefield.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="dforcefield.struct.struct2param" href="#dforcefield.struct.struct2param">struct2param</a></code></li>
<li><code><a title="dforcefield.struct.update" href="#dforcefield.struct.update">update</a></code></li>
<li><code><a title="dforcefield.struct.validkeys" href="#dforcefield.struct.validkeys">validkeys</a></code></li>
<li><code><a title="dforcefield.struct.values" href="#dforcefield.struct.values">values</a></code></li>
<li><code><a title="dforcefield.struct.write" href="#dforcefield.struct.write">write</a></code></li>
<li><code><a title="dforcefield.struct.zip" href="#dforcefield.struct.zip">zip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>