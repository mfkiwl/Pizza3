<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>script API documentation</title>
<meta name="description" content="The class script() and derived facilitate the coding in LAMMPS
Each section is remplaced by a template as a class inherited from script() …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>script</code></h1>
</header>
<section id="section-intro">
<p>The class script() and derived facilitate the coding in LAMMPS
Each section is remplaced by a template as a class inherited from script()</p>
<pre><code>The class include two important attribues:
    TEMPLATE is a string  efines between  the LAMMPS code
    The variables used by TEMPLATE are stored in DEFINITIONS.
    DEFINITIONS is a scripdata() object accepting scalar, mathematical expressions,
    text almost as in LAMMPS.

    Variables can be inherited between sections using + or += operator

Toy example
    G = globalsection()
    print(G)
    c = initializesection()
    print(c)
    g = geometrysection()
    print(g)
    d = discretizationsection()
    print(d)
    b = boundarysection()
    print(b)
    i = interactionsection()
    print(i)
    t = integrationsection()
    print(t)
    d = dumpsection()
    print(d)
    s = statussection()
    print(s)
    r = runsection()
    print(r)

    # all sections as a single script
    myscript = G+c+g+d+b+i+t+d+s+r
    print("
</code></pre>
<p>"<em>4,'='</em>80,'</p>
<p>this is the full script</p>
<p>','='*80,'
')
print(myscript.do())</p>
<pre><code>Additional classes: scriptobject(), scriptobjectgroup(), pipescript()
They generate dynamic scripts from objects, collection of objects or scripts

Variables (DEFINITIONS and USER) are stored in scriptdata() objects


How the variables are stored and used.
     STATIC: set in the script class (with the attribute DEFINITIONS)
     GLOBAL: set in the instance of the script during construction
             or within the USER scriptdata(). These values can be changed
             at runtime but the values are overwritten if the script are
             combined with the operator +
      LOCAL: set (bypass) in the pipeline with the keyword USER[step]

Example with pipelines:
    Build pipelines with:
        p = G | c | g # using the symbol pipe "|"
        p = pipescript(G)*4 # using the constructor pipescript()

            Pipeline with 4 scripts and
            D(STATIC:GLOBAL:LOCAL) DEFINITIONS
              ------------:----------------------------------------
              [-]  00: script:global:example with D(19: 0: 0)
              [-]  01: script:global:example with D(19: 0: 0)
              [-]  02: script:global:example with D(19: 0: 0)
              [-]  03: script:global:example with D(19: 0: 0)
              ------------:----------------------------------------

Change the GLOBAL variables for script with idx=0
    p.scripts[0].USER.a=1  # set a=1 for all scripts onwards
    p.scripts[0].USER.b=2  # set b=2
Change the LOCAL variables for script with idx=0
    p.USER[0].a=10        # set a=10 for the script 00

            ------------:----------------------------------------
            [-]  00: script:global:example with D(19: 2: 1)
            [-]  01: script:global:example with D(19: 0: 0)
            [-]  02: script:global:example with D(19: 0: 0)
            [-]  03: script:global:example with D(19: 0: 0)
            ------------:----------------------------------------

Summary of pipeline indexing and scripting
    p[i], p[i:j], p[[i,j]] copy pipeline segments
    LOCAL: p.USER[i],p.USER[i].variable modify the user space of only p[i]
    GLOBAL: p.scripts[i].USER.var to modify the user space from p[i] and onwards
    STATIC: p.scripts[i].DEFINITIONS
    p.rename(idx=range(2),name=["A","B"]), p.clear(idx=[0,3,4])
    p.script(), p.script(idx=range(5)), p[0:5].script()
</code></pre>
<p>Created on Sat Feb 19 11:00:43 2022</p>
<p>@author: olivi</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;

    The class script() and derived facilitate the coding in LAMMPS
    Each section is remplaced by a template as a class inherited from script()

    The class include two important attribues:
        TEMPLATE is a string  efines between &#34;&#34;&#34; &#34;&#34;&#34; the LAMMPS code
        The variables used by TEMPLATE are stored in DEFINITIONS.
        DEFINITIONS is a scripdata() object accepting scalar, mathematical expressions,
        text almost as in LAMMPS.

        Variables can be inherited between sections using + or += operator

    Toy example
        G = globalsection()
        print(G)
        c = initializesection()
        print(c)
        g = geometrysection()
        print(g)
        d = discretizationsection()
        print(d)
        b = boundarysection()
        print(b)
        i = interactionsection()
        print(i)
        t = integrationsection()
        print(t)
        d = dumpsection()
        print(d)
        s = statussection()
        print(s)
        r = runsection()
        print(r)

        # all sections as a single script
        myscript = G+c+g+d+b+i+t+d+s+r
        print(&#34;\n&#34;*4,&#39;=&#39;*80,&#39;\n\n this is the full script\n\n&#39;,&#39;=&#39;*80,&#39;\n&#39;)
        print(myscript.do())

    Additional classes: scriptobject(), scriptobjectgroup(), pipescript()
    They generate dynamic scripts from objects, collection of objects or scripts

    Variables (DEFINITIONS and USER) are stored in scriptdata() objects


    How the variables are stored and used.
         STATIC: set in the script class (with the attribute DEFINITIONS)
         GLOBAL: set in the instance of the script during construction
                 or within the USER scriptdata(). These values can be changed
                 at runtime but the values are overwritten if the script are
                 combined with the operator +
          LOCAL: set (bypass) in the pipeline with the keyword USER[step]

    Example with pipelines:
        Build pipelines with:
            p = G | c | g # using the symbol pipe &#34;|&#34;
            p = pipescript(G)*4 # using the constructor pipescript()

                Pipeline with 4 scripts and
                D(STATIC:GLOBAL:LOCAL) DEFINITIONS
                  ------------:----------------------------------------
                  [-]  00: script:global:example with D(19: 0: 0)
                  [-]  01: script:global:example with D(19: 0: 0)
                  [-]  02: script:global:example with D(19: 0: 0)
                  [-]  03: script:global:example with D(19: 0: 0)
                  ------------:----------------------------------------

    Change the GLOBAL variables for script with idx=0
        p.scripts[0].USER.a=1  # set a=1 for all scripts onwards
        p.scripts[0].USER.b=2  # set b=2
    Change the LOCAL variables for script with idx=0
        p.USER[0].a=10        # set a=10 for the script 00

                ------------:----------------------------------------
                [-]  00: script:global:example with D(19: 2: 1)
                [-]  01: script:global:example with D(19: 0: 0)
                [-]  02: script:global:example with D(19: 0: 0)
                [-]  03: script:global:example with D(19: 0: 0)
                ------------:----------------------------------------

    Summary of pipeline indexing and scripting
        p[i], p[i:j], p[[i,j]] copy pipeline segments
        LOCAL: p.USER[i],p.USER[i].variable modify the user space of only p[i]
        GLOBAL: p.scripts[i].USER.var to modify the user space from p[i] and onwards
        STATIC: p.scripts[i].DEFINITIONS
        p.rename(idx=range(2),name=[&#34;A&#34;,&#34;B&#34;]), p.clear(idx=[0,3,4])
        p.script(), p.script(idx=range(5)), p[0:5].script()

Created on Sat Feb 19 11:00:43 2022

@author: olivi
&#34;&#34;&#34;

__project__ = &#34;Pizza3&#34;
__author__ = &#34;Olivier Vitrac&#34;
__copyright__ = &#34;Copyright 2022&#34;
__credits__ = [&#34;Olivier Vitrac&#34;]
__license__ = &#34;GPLv3&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;1.003&#34;



# INRAE\Olivier Vitrac - rev. 2025-01-17 (community)
# contact: olivier.vitrac@agroparistech.fr


# Revision history
# 2022-02-20 RC with documentation and 10 section templates
# 2022-02-21 add + += operators, expand help
# 2022-02-26 add USER to enable instance variables with higher precendence
# 2022-02-27 add write() method and overload &amp; operator
# 2022-02-28 overload * (+ expansion) and ** (&amp; expansion) operators
# 2022-03-01 expand lists (with space as separator) and tupples (with ,)
# 2022-03-02 first implementation of scriptobject(), object container pending
# 2022-03-03 extensions of scriptobject() and scriptobjectgroup()
# 2022-03-04 consolidation of scriptobject() and scriptobjectgroup()
# 2022-03-05 [major update] scriptobjectgroup() can generate scripts for loading, setting groups and forcefields
# 2022-03-12 [major update] pipescript() enables to store scripts in dynamic pipelines
# 2022-03-15 implement a userspace within the pipeline
# 2022-03-15 fix scriptobject | pipescript, smooth and document syntaxes with pipescripts
# 2022-03-16 overload +=, *, several fixes and update help for pipescript
# 2022-03-18 modification to script method, \ttype specified for groups
# 2022-03-19 standardized pizza path
# 2023-01-09 update __repr__() for scripts to show both DEFINITIONS and USER if verbose = True
# 2023-01-19 fix do() for pipescripts when the pipe has been already fully executed (statically)
# 2023-01-20 add picker() and possibility to get list indices in pipe
# 2023-01-26 add pipescript.join()
# 2023-01-27 add tmpwrite()
# 2023-01-27 use % instead of $ for lists in script.do(), in line with the new feature implemented in param.eval()
# 2023-01-31 fix the temporary file on Linux
# 2023-07-14 add and implement persistentfile and peristenfolder in scripts
# 2023-07-20 add header to script.tmpwrite()
# 2023-07-20 add a persident script.preview.clean copy
# 2023-08-17 fix span() when vector is &#34;&#34; or str
# 2024-04-16 fix the method tmpwrite(self) on windows with proper error handling
# 2024-04-18 fix scriptobjectgroup.script for empty and None filename
# 2024-09-01 script accepts persistentfolder=None for inheritance
# 2024-10-09 verbosity handling with script.do() and pscript.do() methods, remove_comments moved to script from dscript (circular reference)
# 2024-10-12 implement | for dscript objects
# 2024-10-14 finalization of dscript integration, improved doc
# 2024-10-18 add dscript() method to generate a dscript object from a pipescript
# 2024-10-19 script.do() convert literal \\n back to \n
# 2024-10-22 fix | for non-native pipescript objects
# 2024-11-12 add flexibility to remove_comments(), comment_chars=&#34;#%&#34;, continuation_marker=&#34;...&#34;
# 2024-11-23 improve write and do() methods (the old pipescript.do() method is available as pipescript.do_legacy() )
# 2024-11-25 clear distinction between pipescript and scrupt headers
# 2024-11-29 improved save features
# 2024-12-01 standarize scripting features, automatically call script/pscript methods
# 2024-12-02 standardize script.header(), pscript.header() and dscript.header()
# 2024-12-09 get-metadata() use globals()
# 2025-01-02 improve + and | for script and pipescript
# 2025-01-04 add VariableOccurrences, pipescript.list_values(), pipescript.list_multiple_values(), pipescript.plot_value_distribution()
# 2025-01-06 script.dscript() forces autorefresh=False to prevent automatic assignement of variables not definet yet (see dscript.ScriptTemplate constructor)
# 2025-01-07 add VariableOccurrences.export() in Markdown and HTML, pipescript.generate_report() (version 1.0)
# 2025-01-18 consistent implementation of do() between dscript and script for indexed variables

# %% Dependencies
import os, sys, datetime, socket, getpass, tempfile, types, re, inspect
from copy import copy as duplicate
from copy import deepcopy as deepduplicate
from shutil import copy as copyfile
# To facilitate data review with `VariableOccurrences` class
from collections import defaultdict
import matplotlib.pyplot as plt


# All forcefield parameters are stored à la Matlab in a structure
from pizza.private.mstruct import param,struct
from pizza.forcefield import *

__all__ = [&#39;CallableScript&#39;, &#39;VariableOccurrences&#39;, &#39;boundarysection&#39;, &#39;discretizationsection&#39;, &#39;dumpsection&#39;, &#39;forcefield&#39;, &#39;frame_header&#39;, &#39;geometrysection&#39;, &#39;get_metadata&#39;, &#39;get_tmp_location&#39;, &#39;globalsection&#39;, &#39;initializesection&#39;, &#39;integrationsection&#39;, &#39;interactionsection&#39;, &#39;is_scalar&#39;, &#39;make_hashable&#39;, &#39;none&#39;, &#39;param&#39;, &#39;paramauto&#39;, &#39;parameterforcefield&#39;, &#39;picker&#39;, &#39;pipescript&#39;, &#39;remove_comments&#39;, &#39;rigidwall&#39;, &#39;runsection&#39;, &#39;saltTLSPH&#39;, &#39;script&#39;, &#39;scriptdata&#39;, &#39;scriptobject&#39;, &#39;scriptobjectgroup&#39;, &#39;smd&#39;, &#39;solidfood&#39;, &#39;span&#39;, &#39;statussection&#39;, &#39;struct&#39;, &#39;tlsph&#39;, &#39;ulsph&#39;, &#39;water&#39;]



# span vector into a single string
def span(vector,sep=&#34; &#34;,left=&#34;&#34;,right=&#34;&#34;):
    return left + (vector if isinstance(vector, str) else sep.join(map(str, vector))) + right if vector is not None else &#34;&#34;

# select elements from a list L based on indices as L(indices) in Matlab
def picker(L,indices): return [L[i] for i in indices if (i&gt;=0 and i&lt;len(L))]

# Get the location of the `tmp` directory, in a system-independent way.
get_tmp_location = lambda: tempfile.gettempdir()

# UTF-8 encoded Byte Order Mark (sequence: 0xef, 0xbb, 0xbf)
BOM_UTF8 = b&#39;\xef\xbb\xbf&#39;


# %% Private functions and classes
def remove_comments(content, split_lines=False, emptylines=False, comment_chars=&#34;#&#34;, continuation_marker=&#34;\\\\&#34;, remove_continuation_marker=False):
    &#34;&#34;&#34;
    Removes comments from a single or multi-line string, handling quotes, escaped characters, and line continuation.

    Parameters:
    -----------
    content : str
        The input string, which may contain multiple lines. Each line will be processed
        individually to remove comments, while preserving content inside quotes.
    split_lines : bool, optional (default: False)
        If True, the function will return a list of processed lines. If False, it will
        return a single string with all lines joined by newlines.
    emptylines : bool, optional (default: False)
        If True, empty lines will be preserved in the output. If False, empty lines
        will be removed from the output.
    comment_chars : str, optional (default: &#34;#&#34;)
        A string containing characters to identify the start of a comment.
        Any of these characters will mark the beginning of a comment unless within quotes.
    continuation_marker : str or None, optional (default: &#34;\\\\&#34;)
        A string containing characters to indicate line continuation (use `\\` to specify).
        Any characters after the continuation marker are ignored as a comment. If set to `None`
        or an empty string, line continuation will not be processed.
    remove_continuation_marker : bool, optional (default: False)
        If True, the continuation marker itself is removed from the processed line, keeping
        only the characters before it. If False, the marker is retained as part of the line.

    Returns:
    --------
    str or list of str
        The processed content with comments removed. Returns a list of lines if
        `split_lines` is True, or a single string if False.
    &#34;&#34;&#34;
    def process_line(line):
        &#34;&#34;&#34;Remove comments and handle line continuation within a single line while managing quotes and escapes.&#34;&#34;&#34;
        in_single_quote = False
        in_double_quote = False
        escaped = False
        result = []

        i = 0
        while i &lt; len(line):
            char = line[i]

            if escaped:
                result.append(char)
                escaped = False
                i += 1
                continue

            # Handle escape character within quoted strings
            if char == &#39;\\&#39; and (in_single_quote or in_double_quote):
                escaped = True
                result.append(char)
                i += 1
                continue

            # Toggle state for single and double quotes
            if char == &#34;&#39;&#34; and not in_double_quote:
                in_single_quote = not in_single_quote
            elif char == &#39;&#34;&#39; and not in_single_quote:
                in_double_quote = not in_double_quote

            # Check for line continuation marker if it&#39;s set and outside of quotes
            if continuation_marker and not in_single_quote and not in_double_quote:
                # Check if the remaining part of the line matches the continuation marker
                if line[i:].startswith(continuation_marker):
                    # Optionally remove the continuation marker
                    if remove_continuation_marker:
                        result.append(line[:i].rstrip())  # Keep everything before the marker
                    else:
                        result.append(line[:i + len(continuation_marker)].rstrip())  # Include the marker itself
                    return &#39;&#39;.join(result).strip()

            # Check for comment start characters outside of quotes
            if char in comment_chars and not in_single_quote and not in_double_quote:
                break  # Stop processing the line when a comment is found

            result.append(char)
            i += 1

        return &#39;&#39;.join(result).strip()

    # Split the input content into lines
    lines = content.split(&#39;\n&#39;)

    # Process each line, considering the emptylines flag
    processed_lines = []
    for line in lines:
        stripped_line = line.strip()
        if not stripped_line and not emptylines:
            continue  # Skip empty lines if emptylines is False
        if any(stripped_line.startswith(c) for c in comment_chars):
            continue  # Skip lines that are pure comments
        processed_line = process_line(line)
        if processed_line or emptylines:  # Only add non-empty lines if emptylines is False
            processed_lines.append(processed_line)

    if split_lines:
        return processed_lines  # Return list of processed lines
    else:
        return &#39;\n&#39;.join(processed_lines)  # Join lines back into a single string


# returns the metadata
def get_metadata():
    &#34;&#34;&#34;Return a dictionary of explicitly defined metadata.&#34;&#34;&#34;
    # Define the desired metadata keys
    metadata_keys = [
        &#34;__project__&#34;,
        &#34;__author__&#34;,
        &#34;__copyright__&#34;,
        &#34;__credits__&#34;,
        &#34;__license__&#34;,
        &#34;__maintainer__&#34;,
        &#34;__email__&#34;,
        &#34;__version__&#34;,
    ]
    # Filter only the desired keys from the current module&#39;s globals
    return {key.strip(&#34;_&#34;): globals()[key] for key in metadata_keys if key in globals()}


# frames headers
def frame_header(
    lines,
    padding=2,
    style=1,
    corner_symbols=None,  # Can be a string or a tuple
    horizontal_symbol=None,
    vertical_symbol=None,
    empty_line_symbol=None,
    line_fill_symbol=None,
    comment=&#34;#&#34;
):
    &#34;&#34;&#34;
    Format the header content into an ASCII framed box with customizable properties.

    Parameters:
        lines (list or tuple): The lines to include in the header.
            - Empty strings &#34;&#34; are replaced with lines of `line_fill_symbol`.
            - None values are treated as empty lines.

        padding (int, optional): Number of spaces to pad on each side of the content. Default is 2.
        style (int, optional): Style index (1 to 6) for predefined frame styles. Default is 1.
        corner_symbols (str or tuple, optional): Symbols for the corners (top-left, top-right, bottom-left, bottom-right).
                                                 Can be a string (e.g., &#34;+&#34;) for uniform corners.
        horizontal_symbol (str, optional): Symbol to use for horizontal lines.
        vertical_symbol (str, optional): Symbol to use for vertical lines.
        empty_line_symbol (str, optional): Symbol to use for empty lines inside the frame.
        line_fill_symbol (str, optional): Symbol to fill lines that replace empty strings.
        comment (str, optional): Comment symbol to prefix each line. Can be multiple characters. Default is &#34;#&#34;.

    Returns:
        str: The formatted header as a string.

    Raises:
        ValueError: If the specified style is undefined or `corner_symbols` is invalid.
    &#34;&#34;&#34;
    # Predefined styles
    styles = {
        1: {
            &#34;corner_symbols&#34;: (&#34;+&#34;, &#34;+&#34;, &#34;+&#34;, &#34;+&#34;),
            &#34;horizontal_symbol&#34;: &#34;-&#34;,
            &#34;vertical_symbol&#34;: &#34;|&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;-&#34;
        },
        2: {
            &#34;corner_symbols&#34;: (&#34;╔&#34;, &#34;╗&#34;, &#34;╚&#34;, &#34;╝&#34;),
            &#34;horizontal_symbol&#34;: &#34;═&#34;,
            &#34;vertical_symbol&#34;: &#34;║&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;═&#34;
        },
        3: {
            &#34;corner_symbols&#34;: (&#34;.&#34;, &#34;.&#34;, &#34;&#39;&#34;, &#34;&#39;&#34;),
            &#34;horizontal_symbol&#34;: &#34;-&#34;,
            &#34;vertical_symbol&#34;: &#34;|&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;-&#34;
        },
        4: {
            &#34;corner_symbols&#34;: (&#34;#&#34;, &#34;#&#34;, &#34;#&#34;, &#34;#&#34;),
            &#34;horizontal_symbol&#34;: &#34;=&#34;,
            &#34;vertical_symbol&#34;: &#34;#&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;=&#34;
        },
        5: {
            &#34;corner_symbols&#34;: (&#34;┌&#34;, &#34;┐&#34;, &#34;└&#34;, &#34;┘&#34;),
            &#34;horizontal_symbol&#34;: &#34;─&#34;,
            &#34;vertical_symbol&#34;: &#34;│&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;─&#34;
        },
        6: {
            &#34;corner_symbols&#34;: (&#34;.&#34;, &#34;.&#34;, &#34;.&#34;, &#34;.&#34;),
            &#34;horizontal_symbol&#34;: &#34;.&#34;,
            &#34;vertical_symbol&#34;: &#34;:&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;.&#34;
        }
    }

    # Validate style and set defaults
    if style not in styles:
        raise ValueError(f&#34;Undefined style {style}. Valid styles are {list(styles.keys())}.&#34;)

    selected_style = styles[style]

    # Convert corner_symbols to a tuple of 4 values
    if isinstance(corner_symbols, str):
        corner_symbols = (corner_symbols,) * 4
    elif isinstance(corner_symbols, (list, tuple)) and len(corner_symbols) == 1:
        corner_symbols = tuple(corner_symbols * 4)
    elif isinstance(corner_symbols, (list, tuple)) and len(corner_symbols) == 2:
        corner_symbols = (corner_symbols[0], corner_symbols[1], corner_symbols[0], corner_symbols[1])
    elif corner_symbols is None:
        corner_symbols = selected_style[&#34;corner_symbols&#34;]
    elif not isinstance(corner_symbols, (list, tuple)) or len(corner_symbols) != 4:
        raise ValueError(&#34;corner_symbols must be a string or a tuple/list of 1, 2, or 4 elements.&#34;)

    # Apply overrides or defaults
    horizontal_symbol = horizontal_symbol or selected_style[&#34;horizontal_symbol&#34;]
    vertical_symbol = vertical_symbol or selected_style[&#34;vertical_symbol&#34;]
    empty_line_symbol = empty_line_symbol or selected_style[&#34;empty_line_symbol&#34;]
    line_fill_symbol = line_fill_symbol or selected_style[&#34;line_fill_symbol&#34;]

    # Process lines: Replace &#34;&#34; with line_fill placeholders, None with empty lines
    processed_lines = []
    max_content_width = 0
    for line in lines:
        if line == &#34;&#34;:
            processed_lines.append(&#34;&lt;LINE_FILL&gt;&#34;)
        elif line is None:
            processed_lines.append(None)
        else:
            processed_lines.append(line)
            max_content_width = max(max_content_width, len(line))

    # Adjust width for padding
    frame_width = max_content_width + padding * 2

    # Build the top border
    top_border = f&#34;{corner_symbols[0]}{horizontal_symbol * frame_width}{corner_symbols[1]}&#34;

    # Build content lines with vertical borders
    framed_lines = [top_border]
    for line in processed_lines:
        if line is None:
            empty_line = f&#34;{vertical_symbol}{empty_line_symbol * frame_width}{vertical_symbol}&#34;
            framed_lines.append(empty_line)
        elif line == &#34;&lt;LINE_FILL&gt;&#34;:
            fill_line = f&#34;{vertical_symbol}{line_fill_symbol * frame_width}{vertical_symbol}&#34;
            framed_lines.append(fill_line)
        else:
            content = line.center(frame_width)
            framed_line = f&#34;{vertical_symbol}{content}{vertical_symbol}&#34;
            framed_lines.append(framed_line)

    # Build the bottom border
    bottom_border = f&#34;{corner_symbols[2]}{horizontal_symbol * frame_width}{corner_symbols[3]}&#34;
    framed_lines.append(bottom_border)

    # Ensure all lines start with the comment symbol
    commented_lines = [
        line if line.startswith(comment) else f&#34;{comment} {line}&#34; for line in framed_lines
    ]

    return &#34;\n&#34;.join(commented_lines)+&#34;\n&#34;


def make_hashable(val):
    &#34;&#34;&#34;
    Recursively converts lists and dictionaries to tuples to make them hashable.
    &#34;&#34;&#34;
    if isinstance(val, list):
        return tuple(make_hashable(item) for item in val)
    elif isinstance(val, dict):
        return tuple(sorted((k, make_hashable(v)) for k, v in val.items()))
    return val

def is_scalar(val):
    &#34;&#34;&#34;
    Determines if a value is scalar (not a list, dict, or tuple).
    &#34;&#34;&#34;
    return not isinstance(val, (list, dict, tuple))


# descriptor for callable script
class CallableScript:
    &#34;&#34;&#34;
    A descriptor that allows the method Interactions to be accessed both as a property and as a callable function.

    This class enables a method to behave like a property when accessed without parentheses,
    returning a function that can be called with default parameters. It also allows the method
    to be called directly with optional parameters, providing flexibility in usage.

    Attributes:
    -----------
    func : function
        The original function that is decorated, which will be used for both property access
        and direct calls.

    Methods:
    --------
    __get__(self, instance, owner)
        Returns a lambda function to call the original function with default parameters
        when accessed as a property.

    __call__(self, instance, printflag=False, verbosity=2)
        Allows the original function to be called directly with specified parameters.
    &#34;&#34;&#34;
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        # When accessed as a property, return a lambda that calls the original function
        return lambda printflag=False, verbosity=2, verbose=None: self.func(instance, printflag=printflag, verbosity=verbosity, verbose=verbose)

    def __call__(self, instance, printflag=False, verbosity=2, verbose=None):
        # Allow calling the function directly with specified parameters
        return self.func(instance, printflag=printflag, verbosity=verbosity)



# This class encapsulates the raw data and provides utility methods for analyzing variable occurrences.
class VariableOccurrences:
    &#34;&#34;&#34;
    The `VariableOccurrences` class encapsulates raw data and provides utility methods for analyzing variable occurrences
    across various scopes. It is designed to handle both single and multiple variables, supporting flexible data structures
    and analysis operations.

    Class Methods:
    --------------
    - `__init__(data, variables=None)`: Initializes the class with raw data and optional variable names.
    - `_determine_scopes()`: Determines the unique scopes present across all variables.
    - `get_raw_data()`: Returns the raw data as provided during initialization.
    - `get_steps_with_value(value, within_list=False)`: Retrieves steps where the variable equals the specified value.
    - `get_all_values()`: Retrieves all unique values of the variable(s).
    - `get_all_elements_in_lists()`: Retrieves all unique elements within list-type variable values.
    - `get_usage_count(value, within_list=False)`: Counts occurrences of a specific value.
    - `get_steps_with_value_in_scope(variable, scope, value, within_list=False)`: Retrieves steps where a variable equals a value within a specific scope.
    - `summarize()`: Summarizes the occurrences of variables, including counts and unique elements.
    - `export(filename=None, scopes=&#39;all&#39;, variables=&#39;all&#39;, include_headers=True, return_content=False)`:
      Exports variable occurrences as Markdown, plain text, or HTML.

    Attributes:
    -----------
    - `data`: Dictionary containing the raw variable data.
      - Single variable: `{&#39;scope1&#39;: [...], &#39;scope2&#39;: [...]}`.
      - Multiple variables: `{&#39;var1&#39;: {...}, &#39;var2&#39;: {...}, ...}`.
    - `variables`: List of variable names managed by the instance.
    - `scopes`: List of unique scopes across all variables.

    Usage:
    ------
    The class is useful for tracking and analyzing variable values across different contexts, such as configuration files,
    programming environments, or simulation data. It supports advanced querying, summary generation, and export functionality.

    Example:
    --------
    # Initialize with single variable
    data = {&#39;global&#39;: [(0, 1), (1, 2)], &#39;local&#39;: [(0, 3), (1, 4)]}
    vo = VariableOccurrences(data, variables=&#34;var1&#34;)

    # Initialize with multiple variables
    data = {
        &#34;var1&#34;: {&#34;global&#34;: [(0, 1), (1, 2)], &#34;local&#34;: [(0, 3), (1, 4)]},
        &#34;var2&#34;: {&#34;global&#34;: [1, 2], &#34;local&#34;: [3, 4]},
    }
    vo = VariableOccurrences(data)

    # Query steps where a value is present
    steps = vo.get_steps_with_value(2)

    # Export data to a Markdown file
    vo.export(&#34;output.md&#34;)
    &#34;&#34;&#34;

    def __init__(self, data, variables=None):
        &#34;&#34;&#34;
        Initializes the VariableOccurrences object.

        Parameters:
        - data:
            - For single variable: dict with scopes as keys and lists of values or a single value.
            - For multiple variables: dict mapping variable names to their respective scope data.
        - variables (str or list/tuple, optional):
            - If single variable: string representing the variable name.
            - If multiple variables: list or tuple of variable names.
            - If None: assumes data is for multiple variables without specifying names.
        &#34;&#34;&#34;
        if variables is None:
            # Assume data is a dict mapping variable names to their scope data
            if not isinstance(data, dict):
                raise ValueError(&#34;For multiple variables, data must be a dict mapping variable names to their scope data.&#34;)
            self.variables = list(data.keys())
            self.data = data  # {var1: {scope1: [...], scope2: [...]}, var2: {...}, ...}
        elif isinstance(variables, str):
            # Single variable case
            self.variables = [variables]
            if not isinstance(data, dict):
                raise ValueError(&#34;For single variable, data must be a dict with scopes as keys and lists of values or single values as values.&#34;)
            self.data = {variables: data}  # {var: {scope1: [...], scope2: [...], ...}}
        elif isinstance(variables, (list, tuple)):
            # Multiple variables specified
            if not isinstance(data, dict):
                raise ValueError(&#34;For multiple variables, data must be a dict mapping variable names to their scope data.&#34;)
            if set(variables) &gt; set(data.keys()):
                missing_vars = set(variables) - set(data.keys())
                raise ValueError(f&#34;Data does not contain entries for variables: {&#39;, &#39;.join(missing_vars)}&#34;)
            self.variables = list(variables)
            self.data = {var: data[var] for var in variables}  # {var1: {...}, var2: {...}, ...}
        else:
            raise ValueError(&#34;Parameter &#39;variables&#39; must be a string, list, tuple, or None.&#34;)

        self.scopes = self._determine_scopes()

    def _determine_scopes(self):
        &#34;&#34;&#34;Determines the unique scopes present across all variables.&#34;&#34;&#34;
        scopes = set()
        for var in self.variables:
            var_scopes = self.data[var].keys()
            scopes.update(scope.lower() for scope in var_scopes)
        return sorted(list(scopes))

    def get_raw_data(self):
        &#34;&#34;&#34;
        Returns the raw data.

        Returns:
        - The raw data as provided during initialization.
        &#34;&#34;&#34;
        return self.data

    def get_steps_with_value(self, value, within_list=False):
        &#34;&#34;&#34;
        Retrieves the steps where the variable equals the specified value.

        Parameters:
        - value: The value to search for.
        - within_list (bool): If True, searches for the value within list-type variable values.

        Returns:
        - If single variable:
            - A dict with scopes as keys and lists of step indices or values as values.
        - If multiple variables:
            - A dict mapping each variable name to their respective scope-step/value mappings.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_result = {}
            for scope, occurrences in self.data[var].items():
                if is_scalar(occurrences):
                    # Scalar value
                    if within_list:
                        continue  # Cannot search within a scalar
                    if occurrences == value:
                        var_result[scope] = occurrences
                elif isinstance(occurrences, list):
                    # List of values or list of tuples
                    steps = []
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            step, val = item
                            if within_list:
                                if isinstance(val, list) and value in val:
                                    steps.append(step)
                            else:
                                if val == value:
                                    steps.append(step)
                        else:
                            # List of values
                            if within_list:
                                if isinstance(item, list) and value in item:
                                    steps.append(item)
                            else:
                                if item == value:
                                    steps.append(item)
                    if steps:
                        var_result[scope] = steps
                else:
                    # Other types (e.g., dict), can be extended as needed
                    pass
            if var_result:
                result[var] = var_result
        return result

    def get_all_values(self):
        &#34;&#34;&#34;
        Retrieves all unique values of the variable(s).

        Returns:
        - A dict mapping each variable to its set of unique values per scope.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_unique = {}
            for scope, occurrences in self.data[var].items():
                unique_vals = set()
                if is_scalar(occurrences):
                    unique_vals.add(occurrences)
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            _, val = item
                            hashable_val = make_hashable(val)
                            unique_vals.add(hashable_val)
                        else:
                            hashable_val = make_hashable(item)
                            unique_vals.add(hashable_val)
                var_unique[scope] = unique_vals
            result[var] = var_unique
        return result

    def get_all_elements_in_lists(self):
        &#34;&#34;&#34;
        Retrieves all unique elements within list-type variable values.

        Returns:
        - A dict mapping each variable to its set of unique elements in lists per scope.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_elements = {}
            for scope, occurrences in self.data[var].items():
                unique_elems = set()
                if is_scalar(occurrences):
                    if isinstance(occurrences, list):
                        unique_elems.update(occurrences)
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            _, val = item
                            if isinstance(val, list):
                                unique_elems.update(val)
                        elif isinstance(item, list):
                            unique_elems.update(item)
                var_elements[scope] = unique_elems
            result[var] = var_elements
        return result

    def get_usage_count(self, value, within_list=False):
        &#34;&#34;&#34;
        Counts how many times a specific value is used.

        Parameters:
        - value: The value to count.
        - within_list (bool): If True, counts occurrences within list-type variable values.

        Returns:
        - If single variable:
            - A dict with scopes as keys and integer counts or counts of values as values.
        - If multiple variables:
            - A dict mapping each variable name to their respective scope-count/value mappings.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_count = {}
            for scope, occurrences in self.data[var].items():
                count = 0
                if is_scalar(occurrences):
                    if within_list:
                        if isinstance(occurrences, list) and value in occurrences:
                            count += 1
                    else:
                        if occurrences == value:
                            count += 1
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            _, val = item
                            if within_list:
                                if isinstance(val, list) and value in val:
                                    count += 1
                            else:
                                if val == value:
                                    count += 1
                        else:
                            if within_list:
                                if isinstance(item, list) and value in item:
                                    count += 1
                            else:
                                if item == value:
                                    count += 1
                if count &gt; 0:
                    var_count[scope] = count
            if var_count:
                result[var] = var_count
        return result

    def get_steps_with_value_in_scope(self, variable, scope, value, within_list=False):
        &#34;&#34;&#34;
        Retrieves the steps within a specific scope where the variable equals the specified value.

        Parameters:
        - variable (str): The variable name.
        - scope (str): The scope to search within (&#34;static&#34;, &#34;global&#34;, &#34;local&#34;).
        - value: The value to search for.
        - within_list (bool): If True, searches for the value within list-type variable values.

        Returns:
        - A list of step indices or values where the variable equals the value within the specified scope.
        &#34;&#34;&#34;
        if variable not in self.variables:
            raise ValueError(f&#34;Variable &#39;{variable}&#39; is not managed by this instance.&#34;)

        scope = scope.lower()
        occurrences = self.data[variable].get(scope, [])
        steps = []

        if is_scalar(occurrences):
            if within_list:
                if isinstance(occurrences, list) and value in occurrences:
                    steps.append(occurrences)
            else:
                if occurrences == value:
                    steps.append(occurrences)
        elif isinstance(occurrences, list):
            for item in occurrences:
                if isinstance(item, tuple) and len(item) == 2:
                    step, val = item
                    if within_list:
                        if isinstance(val, list) and value in val:
                            steps.append(step)
                    else:
                        if val == value:
                            steps.append(step)
                else:
                    if within_list:
                        if isinstance(item, list) and value in item:
                            steps.append(item)
                    else:
                        if item == value:
                            steps.append(item)
        return steps

    def summarize(self):
        &#34;&#34;&#34;
        Provides a summary of the variable occurrences.

        Returns:
        - A dict mapping each variable to their respective summaries per scope.
        &#34;&#34;&#34;
        summary = {}
        for var in self.variables:
            var_summary = {}
            for scope, occurrences in self.data[var].items():
                unique_vals = set()
                unique_elements = set()
                value_counts = defaultdict(int)
                element_counts = defaultdict(int)

                if is_scalar(occurrences):
                    # Scalar value
                    hashable_val = make_hashable(occurrences)
                    unique_vals.add(hashable_val)
                    value_counts[hashable_val] += 1
                    if isinstance(occurrences, list):
                        unique_elements.update(occurrences)
                        for elem in occurrences:
                            element_counts[elem] += 1
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            # Tuple: (step, value)
                            step, val = item
                            hashable_val = make_hashable(val)
                            unique_vals.add(hashable_val)
                            value_counts[hashable_val] += 1
                            if isinstance(val, list):
                                unique_elements.update(val)
                                for elem in val:
                                    element_counts[elem] += 1
                            elif isinstance(val, dict):
                                # Handle nested dictionaries if necessary
                                for sub_val in val.values():
                                    if isinstance(sub_val, list):
                                        unique_elements.update(sub_val)
                                        for elem in sub_val:
                                            element_counts[elem] += 1
                        else:
                            # Direct value
                            hashable_val = make_hashable(item)
                            unique_vals.add(hashable_val)
                            value_counts[hashable_val] += 1
                            if isinstance(item, list):
                                unique_elements.update(item)
                                for elem in item:
                                    element_counts[elem] += 1
                            elif isinstance(item, dict):
                                for sub_val in item.values():
                                    if isinstance(sub_val, list):
                                        unique_elements.update(sub_val)
                                        for elem in sub_val:
                                            element_counts[elem] += 1
                else:
                    # Other types can be handled here if needed
                    pass

                var_summary[scope] = {
                    &#34;total_occurrences&#34;: len(occurrences),
                    &#34;unique_values&#34;: unique_vals,
                    &#34;unique_elements_in_lists&#34;: unique_elements,
                    &#34;value_counts&#34;: dict(value_counts),
                    &#34;element_counts_in_lists&#34;: dict(element_counts)
                }
            summary[var] = var_summary
        return summary

    def export(self, filename=None, scopes=&#39;all&#39;, variables=&#39;all&#39;, include_headers=True, return_content=False):
        &#34;&#34;&#34;
        Exports the variable occurrences to a file or returns the content as a string.

        Parameters:
        - filename (str, optional): Path to the output file. Must end with .md, .txt, or .html. Required if return_content is False.
        - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.
        - variables (str or list/tuple, optional): &#39;all&#39;, a single variable string, or a list of variable strings. Defaults to &#39;all&#39;.
        - include_headers (bool, optional): If True, includes headers in the exported content. Defaults to True.
        - return_content (bool, optional): If True, returns the content as a string instead of writing to a file. Defaults to False.

        Returns:
        - str: The exported content as a string if return_content is True.
        - None: Writes to file if return_content is False.

        Raises:
        - ValueError: If &#39;filename&#39; is not provided when return_content is False.
        - ValueError: If &#39;scopes&#39; or &#39;variables&#39; are of incorrect types.
        &#34;&#34;&#34;
        # Determine file extension if filename is provided
        if filename:
            _, ext = os.path.splitext(filename)
            ext = ext.lower()

            if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
                export_format = &#39;markdown&#39;
            elif ext == &#39;.html&#39;:
                export_format = &#39;html&#39;
            else:
                raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)
        elif not return_content:
            raise ValueError(&#34;Filename must be provided if return_content is False.&#34;)

        # Determine scopes
        if isinstance(scopes, str):
            if scopes.lower() == &#39;all&#39;:
                selected_scopes = self.scopes
            else:
                selected_scopes = [scopes.lower()]
        elif isinstance(scopes, (list, tuple)):
            scopes_lower = [s.lower() for s in scopes]
            if &#39;all&#39; in scopes_lower:
                selected_scopes = self.scopes
            else:
                selected_scopes = scopes_lower
        else:
            raise ValueError(&#34;Parameter &#39;scopes&#39; must be a string or a list/tuple of strings.&#34;)

        # Determine variables
        if isinstance(variables, str):
            if variables.lower() == &#39;all&#39;:
                selected_variables = self.variables
            else:
                if variables not in self.variables:
                    print(f&#34;Warning: Variable &#39;{variables}&#39; not managed by this instance.&#34;)
                    selected_variables = []
                else:
                    selected_variables = [variables]
        elif isinstance(variables, (list, tuple)):
            variables_lower = [v for v in variables]
            selected_variables = [v for v in variables_lower if v in self.variables]
            missing_vars = set(variables_lower) - set(selected_variables)
            if missing_vars:
                print(f&#34;Warning: Variables &#39;{&#39;, &#39;.join(missing_vars)}&#39; not managed by this instance.&#34;)
        else:
            raise ValueError(&#34;Parameter &#39;variables&#39; must be a string or a list/tuple of strings.&#34;)

        # Generate content
        content = &#34;&#34;
        if include_headers:
            if export_format == &#39;markdown&#39;:
                content += f&#34;## Variable: `{self.variables[0]}`\n\n&#34; if len(self.variables) == 1 else &#34;&#34;
            elif export_format == &#39;html&#39;:
                content += f&#34;&lt;h2&gt;Variable: {self.variables[0]}&lt;/h2&gt;\n&#34; if len(self.variables) == 1 else &#34;&#34;

        summary = self.summarize()
        for var in selected_variables:
            if include_headers:
                if export_format == &#39;markdown&#39;:
                    content += f&#34;### Variable: `{var}`\n\n&#34;
                elif export_format == &#39;html&#39;:
                    content += f&#34;&lt;h3&gt;Variable: {var}&lt;/h3&gt;\n&#34;
            var_summary = summary[var]
            for scope, details in var_summary.items():
                if scope not in selected_scopes:
                    continue
                if include_headers or True:
                    if export_format == &#39;markdown&#39;:
                        content += f&#34;#### Scope: {scope.capitalize()}\n\n&#34;
                    elif export_format == &#39;html&#39;:
                        content += f&#34;&lt;h4&gt;Scope: {scope.capitalize()}&lt;/h4&gt;\n&#34;
                # Add content based on format
                if export_format == &#39;markdown&#39;:
                    content += f&#34;- **Total Occurrences**: {details[&#39;total_occurrences&#39;]}\n&#34;
                    unique_vals_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_values&#39;]))
                    content += f&#34;- **Unique Values**: {unique_vals_formatted}\n&#34;
                    if details[&#39;unique_elements_in_lists&#39;]:
                        unique_elems_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_elements_in_lists&#39;]))
                        content += f&#34;- **Unique Elements in Lists**: {unique_elems_formatted}\n\n&#34;
                        # Element Counts Table
                        content += &#34;**Element Counts in Lists:**\n\n&#34;
                        content += &#34;| Element | Count |\n&#34;
                        content += &#34;|---------|-------|\n&#34;
                        for elem, count in details[&#39;element_counts_in_lists&#39;].items():
                            content += f&#34;| {elem} | {count} |\n&#34;
                        content += &#34;\n&#34;
                elif export_format == &#39;html&#39;:
                    content += &#34;&lt;ul&gt;&#34;
                    content += f&#34;&lt;li&gt;&lt;strong&gt;Total Occurrences&lt;/strong&gt;: {details[&#39;total_occurrences&#39;]}&lt;/li&gt;&#34;
                    unique_vals_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_values&#39;]))
                    content += f&#34;&lt;li&gt;&lt;strong&gt;Unique Values&lt;/strong&gt;: {unique_vals_formatted}&lt;/li&gt;&#34;
                    if details[&#39;unique_elements_in_lists&#39;]:
                        unique_elems_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_elements_in_lists&#39;]))
                        content += f&#34;&lt;li&gt;&lt;strong&gt;Unique Elements in Lists&lt;/strong&gt;: {unique_elems_formatted}&lt;/li&gt;&#34;
                    content += &#34;&lt;/ul&gt;\n&#34;

                    if details[&#39;element_counts_in_lists&#39;]:
                        content += &#34;&lt;h5&gt;Element Counts in Lists:&lt;/h5&gt;\n&#34;
                        content += &#34;&lt;table&gt;\n&lt;tr&gt;&lt;th&gt;Element&lt;/th&gt;&lt;th&gt;Count&lt;/th&gt;&lt;/tr&gt;\n&#34;
                        for elem, count in details[&#39;element_counts_in_lists&#39;].items():
                            content += f&#34;&lt;tr&gt;&lt;td&gt;{elem}&lt;/td&gt;&lt;td&gt;{count}&lt;/td&gt;&lt;/tr&gt;\n&#34;
                        content += &#34;&lt;/table&gt;\n&#34;

            # Add a horizontal line between variables
            if include_headers and len(selected_variables) &gt; 1:
                if export_format == &#39;markdown&#39;:
                    content += &#34;\n---\n\n&#34;
                elif export_format == &#39;html&#39;:
                    content += &#34;&lt;hr/&gt;\n&#34;

        # Handle format-specific headers
        if return_content:
            if export_format == &#39;markdown&#39;:
                return content
            elif export_format == &#39;html&#39;:
                return f&#34;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#39;UTF-8&#39;&gt;&lt;title&gt;Variable Report&lt;/title&gt;&lt;/head&gt;&lt;body&gt;{content}&lt;/body&gt;&lt;/html&gt;&#34;
        else:
            if not filename:
                raise ValueError(&#34;Filename must be provided if return_content is False.&#34;)

            # Determine export format based on file extension
            if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
                export_format = &#39;markdown&#39;
            elif ext == &#39;.html&#39;:
                export_format = &#39;html&#39;
            else:
                raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

            # Prepare full content for HTML
            if export_format == &#39;html&#39; and not include_headers:
                full_content = f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Variable Report&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n{content}\n&lt;/body&gt;\n&lt;/html&gt;&#34;
            else:
                full_content = content

            # Write to file
            try:
                with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                    file.write(full_content)
                print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
            except Exception as e:
                raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)


# %% Top generic classes for storing script data and objects
# they are not intended to be used outside script data and objects

class scriptdata(param):
    &#34;&#34;&#34;
        class of script parameters
            Typical constructor:
                DEFINITIONS = scriptdata(
                    var1 = value1,
                    var2 = value2
                    )
        See script, struct, param to get review all methods attached to it
    &#34;&#34;&#34;
    _type = &#34;SD&#34;
    _fulltype = &#34;script data&#34;
    _ftype = &#34;definition&#34;


# object data (for scripts)
class scriptobject(struct):
    &#34;&#34;&#34;
    scriptobject: A Class for Managing Script Objects in LAMMPS

    The `scriptobject` class is designed to represent individual objects in LAMMPS scripts,
    such as beads, atoms, or other components. Each object is associated with a `forcefield`
    instance that defines the physical interactions of the object, and the class supports
    a variety of properties for detailed object definition. Additionally, `scriptobject`
    instances can be grouped together and compared based on their properties, such as
    `beadtype` and `name`.

    Key Features:
    -------------
    - **Forcefield Integration**: Each `scriptobject` is associated with a `forcefield`
      instance, allowing for customized physical interactions. Forcefields can be passed
      via the `USER` keyword for dynamic parameterization.
    - **Grouping**: Multiple `scriptobject` instances can be combined into a
      `scriptobjectgroup` using the `+` operator, allowing for complex collections of objects.
    - **Object Comparison**: `scriptobject` instances can be compared and sorted based on
      their `beadtype` and `name`, enabling efficient organization and manipulation of objects.
    - **Piping and Execution**: Supports the pipe (`|`) operator, allowing `scriptobject`
      instances to be used in script pipelines alongside other script elements.

    Practical Use Cases:
    --------------------
    - **Object Definition in LAMMPS**: Use `scriptobject` to represent individual objects in
      a simulation, including their properties and associated forcefields.
    - **Forcefield Parameterization**: Pass customized parameters to the forcefield via the
      `USER` keyword to dynamically adjust the physical interactions.
    - **Grouping and Sorting**: Combine multiple objects into groups, or sort them based
      on their properties (e.g., `beadtype`) for easier management in complex simulations.

    Methods:
    --------
    __init__(self, beadtype=1, name=&#34;undefined&#34;, fullname=&#34;&#34;, filename=&#34;&#34;, style=&#34;smd&#34;,
             forcefield=rigidwall(), group=[], USER=scriptdata()):
        Initializes a new `scriptobject` with the specified properties, including `beadtype`,
        `name`, `forcefield`, and optional `group`.

    __str__(self):
        Returns a string representation of the `scriptobject`, showing its `beadtype` and `name`.

    __add__(self, SO):
        Combines two `scriptobject` instances or a `scriptobject` with a `scriptobjectgroup`.
        Raises an error if the two objects have the same `name` or if the second operand is not
        a valid `scriptobject` or `scriptobjectgroup`.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the `scriptobject` into a pipeline.

    __eq__(self, SO):
        Compares two `scriptobject` instances, returning `True` if they have the same
        `beadtype` and `name`.

    __ne__(self, SO):
        Returns `True` if the two `scriptobject` instances differ in either `beadtype` or `name`.

    __lt__(self, SO):
        Compares the `beadtype` of two `scriptobject` instances, returning `True` if the
        left object&#39;s `beadtype` is less than the right object&#39;s.

    __gt__(self, SO):
        Compares the `beadtype` of two `scriptobject` instances, returning `True` if the
        left object&#39;s `beadtype` is greater than the right object&#39;s.

    __le__(self, SO):
        Returns `True` if the `beadtype` of the left `scriptobject` is less than or equal to
        the right `scriptobject`.

    __ge__(self, SO):
        Returns `True` if the `beadtype` of the left `scriptobject` is greater than or equal
        to the right `scriptobject`.

    Attributes:
    -----------
    beadtype : int
        The type of bead or object, used for distinguishing between different types in the simulation.
    name : str
        A short name for the object, useful for quick identification.
    fullname : str
        A comprehensive name for the object. If not provided, defaults to the `name` with &#34;object definition&#34;.
    filename : str
        The path to the file containing the input data for the object.
    style : str
        The style of the object (e.g., &#34;smd&#34; for smoothed dynamics).
    forcefield : forcefield
        The forcefield instance associated with the object, defining its physical interactions.
    group : list
        A list of other `scriptobject` instances that are grouped with this object.
    USER : scriptdata
        A collection of user-defined variables for customizing the forcefield or other properties.

    Original Content:
    -----------------
    The `scriptobject` class enables the definition of objects within LAMMPS scripts, providing:
    - **Beadtype and Naming**: Objects are distinguished by their `beadtype` and `name`, allowing
      for comparison and sorting based on these properties.
    - **Forcefield Support**: Objects are linked to a forcefield instance, and user-defined forcefield
      parameters can be passed through the `USER` keyword.
    - **Group Management**: Multiple objects can be grouped together using the `+` operator, forming
      a `scriptobjectgroup`.
    - **Comparison Operators**: Objects can be compared based on their `beadtype` and `name`, using
      standard comparison operators (`==`, `&lt;`, `&gt;`, etc.).
    - **Pipelines**: `scriptobject` instances can be integrated into pipelines, supporting the `|`
      operator for use in sequential script execution.

    Example Usage:
    --------------
    ```
    from pizza.scriptobject import scriptobject, rigidwall, scriptdata

    # Define a script object with custom properties
    obj1 = scriptobject(beadtype=1, name=&#34;bead1&#34;, forcefield=rigidwall(USER=scriptdata(param1=10)))

    # Combine two objects into a group
    obj2 = scriptobject(beadtype=2, name=&#34;bead2&#34;)
    group = obj1 + obj2

    # Print object information
    print(obj1)
    print(group)
    ```

    The output will be:
    ```
    script object | type=1 | name=bead1
    scriptobjectgroup containing 2 objects
    ```

    OVERVIEW
    --------------

        class of script object
            OBJ = scriptobject(...)
            Implemented properties:
                beadtype=1,2,...
                name=&#34;short name&#34;
                fullname = &#34;comprehensive name&#34;
                filename = &#34;/path/to/your/inputfile&#34;
                style = &#34;smd&#34;
                forcefield = any valid forcefield instance (default = rigidwall())
                mass = 1.0

        note: use a forcefield instance with the keywork USER to pass user FF parameters
        examples:   rigidwall(USER=scriptdata(...))
                    solidfood(USER==scriptdata(...))
                    water(USER==scriptdata(...))

        group objects with OBJ1+OBJ2... into scriptobjectgroups

        objects can be compared and sorted based on beadtype and name

    &#34;&#34;&#34;
    _type = &#34;SO&#34;
    _fulltype = &#34;script object&#34;
    _ftype = &#34;propertie&#34;

    def __init__(self,
                 beadtype = 1,
                 name = None,
                 fullname=&#34;&#34;,
                 filename=&#34;&#34;,
                 style=&#34;smd&#34;,
                 mass=1.0, # added on 2024-11-29
                 forcefield=rigidwall(),
                 group=[],
                 USER = scriptdata()
                 ):
        name = f&#34;beadtype={beadtype}&#34; if name is None else name
        if not isinstance(name,str):
            TypeError(f&#34;name must a string or None got {type(name)}&#34;)
        if fullname==&#34;&#34;: fullname = name + &#34; object definition&#34;
        if not isinstance(group,list): group = [group]
        forcefield.beadtype = beadtype
        forcefield.userid = name
        forcefield.USER = USER
        super(scriptobject,self).__init__(
              beadtype = beadtype,
                  name = name,
              fullname = fullname,
              filename = filename,
                 style = style,
            forcefield = forcefield,
                  mass = mass,
                 group = group,
                  USER = USER
                 )

    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self._fulltype} | type={self.beadtype} | name={self.name}&#34;

    def __add__(self, SO):
        if isinstance(SO,scriptobject):
            if SO.name != self.name:
                if SO.beadtype == self.beadtype:
                   SO.beadtype =  self.beadtype+1
                return scriptobjectgroup(self,SO)
            else:
                raise ValueError(&#39;the object &#34;%s&#34; already exists&#39; % SO.name)
        elif isinstance(SO,scriptobjectgroup):
            return scriptobjectgroup(self)+SO
        else:
            return ValueError(&#34;The object should a script object or its container&#34;)

    def __or__(self, pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        if isinstance(pipe,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self) | pipe
        else:
            raise ValueError(&#34;the argument must a pipescript, a scriptobject or a scriptobjectgroup&#34;)

    def __eq__(self, SO):
        return isinstance(SO,scriptobject) and (self.beadtype == SO.beadtype) and (self.mass == SO.mass) \
            and (self.name == SO.name)

    def __ne__(self, SO):
        return not isinstance(SO,scriptobject) or (self.beadtype != SO.beadtype) or (self.mass != SO.mass) or (self.name != SO.name)

    def __lt__(self, SO):
        return self.beadtype &lt; SO.beadtype

    def __gt__(self, SO):
        return self.beadtype &gt; SO.beadtype

    def __le__(self, SO):
        return self.beadtype &lt;= SO.beadtype

    def __ge__(self, SO):
        return self.beadtype &gt;= SO.beadtype


# group of script objects  (special kind of list)
class scriptobjectgroup(struct):
    &#34;&#34;&#34;
    scriptobjectgroup: A Class for Managing Groups of Script Objects in LAMMPS

    The `scriptobjectgroup` class is designed to represent a group of `scriptobject` instances,
    such as beads or atoms in a simulation. This class allows users to group objects together
    based on their properties (e.g., beadtype, name), and provides tools to generate scripts
    that define interactions, groups, and forcefields for these objects in LAMMPS.

    Key Features:
    -------------
    - **Group Management**: Objects can be combined into a group, where each `beadtype` occurs
      once. The class ensures that objects are uniquely identified by their `beadtype` and `name`.
    - **Dynamic Properties**: The group’s properties (e.g., `beadtype`, `name`, `groupname`)
      are dynamically calculated, ensuring that the group reflects the current state of the objects.
    - **Script Generation**: Provides methods to generate scripts based on the group&#39;s objects,
      including interaction forcefields and group definitions.
    - **Interaction Accumulation**: Automatically accumulates and updates all forcefield
      interactions for the objects in the group.

    Practical Use Cases:
    --------------------
    - **LAMMPS Group Definitions**: Define groups of objects for use in LAMMPS simulations,
      based on properties like `beadtype` and `groupname`.
    - **Forcefield Management**: Automatically manage and update interaction forcefields for
      objects in the group.
    - **Script Generation**: Generate LAMMPS-compatible scripts that include group definitions,
      input file handling, and interaction forcefields.

    Methods:
    --------
    __init__(self, *SOgroup):
        Initializes a new `scriptobjectgroup` with one or more `scriptobject` instances.

    __str__(self):
        Returns a string representation of the `scriptobjectgroup`, showing the number of objects
        in the group and their `beadtypes`.

    __add__(self, SOgroup):
        Combines two `scriptobjectgroup` instances or a `scriptobject` with an existing group,
        ensuring that `beadtype` values are unique.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the group into a pipeline.

    select(self, beadtype=None):
        Selects and returns a subset of the group based on the specified `beadtype`.

    script(self, printflag=False, verbosity=2, verbose=None):
        Generates a script based on the current collection of objects, including input file
        handling, group definitions, and interaction forcefields.

    interactions(self, printflag=False, verbosity=2, verbose=None):
        Updates and accumulates all forcefields for the objects in the group.

    group_generator(self, name=None):
        Generates and returns a `group` object, based on the existing group structure.

    Properties:
    -----------
    - list : Converts the group into a sorted list of objects.
    - zip : Returns a sorted list of tuples containing `beadtype`, `name`, `group`, and `filename`
      for each object.
    - n : Returns the number of objects in the group.
    - beadtype : Returns a list of the `beadtypes` for all objects in the group.
    - name : Returns a list of the `names` for all objects in the group.
    - groupname : Returns a list of all group names (synonyms).
    - filename : Returns a dictionary mapping filenames to the objects that use them.
    - str : Returns a string representation of the group&#39;s `beadtypes`.
    - min : Returns the minimum `beadtype` in the group.
    - max : Returns the maximum `beadtype` in the group.
    - minmax : Returns a tuple of the minimum and maximum `beadtypes` in the group.
    - forcefield : Returns the interaction forcefields for the group.

    Original Content:
    -----------------
    The `scriptobjectgroup` class enables the collection and management of multiple
    `scriptobject` instances, providing the following functionalities:
    - **Group Creation**: Groups are automatically formed by combining individual objects
      using the `+` operator. Each `beadtype` occurs only once in the group, and errors are
      raised if an object with the same `name` or `beadtype` already exists.
    - **Dynamic Properties**: Properties such as `beadtype`, `name`, `groupname`, and `filename`
      are dynamically calculated, reflecting the current state of the objects.
    - **Forcefield Handling**: Forcefields are automatically managed for the objects in the group,
      including diagonal and off-diagonal terms for pair interactions.
    - **Script Generation**: Scripts are generated to define the interactions, groups, and
      input file handling for LAMMPS.

    Example Usage:
    --------------
    ```
    from pizza.scriptobject import scriptobject, scriptobjectgroup, rigidwall, solidfood, water

    # Define some script objects
    b1 = scriptobject(name=&#34;bead 1&#34;, group=[&#34;A&#34;, &#34;B&#34;, &#34;C&#34;], filename=&#39;myfile1&#39;, forcefield=rigidwall())
    b2 = scriptobject(name=&#34;bead 2&#34;, group=[&#34;B&#34;, &#34;C&#34;], filename=&#39;myfile1&#39;, forcefield=rigidwall())
    b3 = scriptobject(name=&#34;bead 3&#34;, group=[&#34;B&#34;, &#34;D&#34;, &#34;E&#34;], forcefield=solidfood())
    b4 = scriptobject(name=&#34;bead 4&#34;, group=&#34;D&#34;, beadtype=1, filename=&#34;myfile2&#34;, forcefield=water())

    # Combine objects into a group
    collection = b1 + b2 + b3 + b4

    # Select a subset of objects and generate a script
    grp_typ1 = collection.select(1)
    grpB = collection.group.B
    script12 = collection.select([1, 2]).script()
    ```

    Output:
    ```
    script object group with 4 objects (1 2 3 4)
    script
    ```

    OVERVIEW:
    --------------


        class of script object group
            script object groups are built from script objects OBJ1, OBJ2,..
            GRP = scriptobjectgroup(OBJ1,OBJ2,...)
            GRP = OBJ1+OBJ2+...

        note: each beadtype occurs once in the group (if not an error message is generated)

        List of methods
            struct() converts data as structure
            select([1,2,4]) selects objects with matching beadtypes

        List of properties (dynamically calculated)
            converted data: list, str, zip, beadtype, name, groupname, group, filename
            numeric: len, min, max, minmax
            forcefield related: interactions, forcefield
            script: generate the script (load,group,forcefield)

        Full syntax (toy example)

    b1 = scriptobject(name=&#34;bead 1&#34;,group = [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;],filename=&#39;myfile1&#39;,forcefield=rigidwall())
    b2 = scriptobject(name=&#34;bead 2&#34;, group = [&#34;B&#34;, &#34;C&#34;],filename = &#39;myfile1&#39;,forcefield=rigidwall())
    b3 = scriptobject(name=&#34;bead 3&#34;, group = [&#34;B&#34;, &#34;D&#34;, &#34;E&#34;],forcefield=solidfood())
    b4 = scriptobject(name=&#34;bead 4&#34;, group = &#34;D&#34;,beadtype = 1,filename=&#34;myfile2&#34;,forcefield=water())

        note: beadtype are incremented during the collection (effect of order)

            # generate a collection, select a typ 1 and a subgroup, generate the script for 1,2

            collection = b1+b2+b3+b4
            grp_typ1 = collection.select(1)
            grpB = collection.group.B
            script12 = collection.select([1,2]).script

        note: collection.group.B returns a strcture with 6 fields
        -----------:----------------------------------------
            groupid: 2 &lt;-- automatic group numbering
        groupidname: B &lt;-- group name
          groupname: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] &lt;--- snonyms
           beadtype: [1, 2, 3] &lt;-- beads belonging to B
               name: [&#39;bead 1&#39;, &#39;bead 2&#39;, &#39;bead 3&#39;] &lt;-- their names
                str: group B 1 2 3 &lt;-- LAMMPS syntax
        -----------:----------------------------------------

    &#34;&#34;&#34;
    _type = &#34;SOG&#34;
    _fulltype = &#34;script object group&#34;
    _ftype = &#34;object&#34;
    _propertyasattribute = True

    def __init__(self,*SOgroup):
        &#34;&#34;&#34; SOG constructor &#34;&#34;&#34;
        super(scriptobjectgroup,self).__init__()
        beadtypemax = 0
        names = []
        for k in range(len(SOgroup)):
            if isinstance(SOgroup[k],scriptobject):
                if SOgroup[k].beadtype&lt;beadtypemax or SOgroup[k].beadtype==None:
                    beadtypemax +=1
                    SOgroup[k].beadtype = beadtypemax
                if SOgroup[k].name not in names:
                    self.setattr(SOgroup[k].name,SOgroup[k])
                    beadtypemax = SOgroup[k].beadtype
                else:
                    raise ValueError(&#39;the script object &#34;%s&#34; already exists&#39; % SOgroup[k].name)
                names.append(SOgroup[k].name)
            else:
                raise ValueError(&#34;the argument #%d is not a script object&#34;)

    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self._fulltype} with {len(self)} {self._ftype}s ({span(self.beadtype)})&#34;

    def __add__(self, SOgroup):
        &#34;&#34;&#34; overload + &#34;&#34;&#34;
        beadlist = self.beadtype
        dup = duplicate(self)
        if isinstance(SOgroup,scriptobject):
            if SOgroup.name not in self.keys():
                if SOgroup.beadtype in beadlist and \
                  (SOgroup.beadtype==None or SOgroup.beadtype==self.min):
                      SOgroup.beadtype = self.max+1
                if SOgroup.beadtype not in beadlist:
                    dup.setattr(SOgroup.name, SOgroup)
                    beadlist.append(SOgroup.beadtype)
                    return dup
                else:
                    raise ValueError(&#39;%s (beadtype=%d) is already in use, same beadtype&#39; \
                                     % (SOgroup.name,SOgroup.beadtype))
            else:
                raise ValueError(&#39;the object &#34;%s&#34; is already in the list&#39; % SOgroup.name)
        elif isinstance(SOgroup,scriptobjectgroup):
            for k in SOgroup.keys():
                if k not in dup.keys():
                    if SOgroup.getattr(k).beadtype not in beadlist:
                        dup.setattr(k,SOgroup.getattr(k))
                        beadlist.append(SOgroup.getattr(k).beadtype)
                    else:
                        raise ValueError(&#39;%s (beadtype=%d) is already in use, same beadtype&#39; \
                                         % (k,SOgroup.getattr(k).beadtype))
                else:
                    raise ValueError(&#39;the object &#34;%s&#34; is already in the list&#39; % k)
            return dup
        else:
            raise ValueError(&#34;the argument #%d is not a script object or a script object group&#34;)

    def __or__(self, pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        if isinstance(pipe,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self) | pipe
        else:
            raise ValueError(&#34;the argument must a pipescript, a scriptobject or a scriptobjectgroup&#34;)

    @property
    def list(self):
        &#34;&#34;&#34; convert into a list &#34;&#34;&#34;
        return sorted(self)

    @property
    def zip(self):
        &#34;&#34;&#34; zip beadtypes and names &#34;&#34;&#34;
        return sorted( \
            [(self.getattr(k).beadtype,self.getattr(k).name,self.getattr(k).group,self.getattr(k).filename) \
            for k in self.keys()])

    @property
    def n(self):
        &#34;&#34;&#34; returns the number of bead types &#34;&#34;&#34;
        return len(self)

    @property
    def beadtype(self):
        &#34;&#34;&#34; returns the beads in the group &#34;&#34;&#34;
        return [x for x,_,_,_ in self.zip]

    @property
    def name(self):
        &#34;&#34;&#34; &#34;return the list of names &#34;&#34;&#34;
        return [x for _,x,_,_ in self.zip]

    @property
    def groupname(self):
        &#34;&#34;&#34; &#34;return the list of groupnames &#34;&#34;&#34;
        grp = []
        for _,_,glist,_ in self.zip:
            for g in glist:
                if g not in grp: grp.append(g)
        return grp

    @property
    def filename(self):
        &#34;&#34;&#34; &#34;return the list of names as a dictionary &#34;&#34;&#34;
        files = {}
        for _,n,_,fn in self.zip:
            if fn != &#34;&#34;:
                if fn not in files:
                    files[fn] = [n]
                else:
                    files[fn].append(n)
        return files

    @property
    def str(self):
        return span(self.beadtype)

    def struct(self,groupid=1,groupidname=&#34;undef&#34;):
        &#34;&#34;&#34; create a group with name &#34;&#34;&#34;
        return struct(
                groupid = groupid,
            groupidname = groupidname,
              groupname = self.groupname, # meaning is synonyms
               beadtype = self.beadtype,
                   name = self.name,
                    str = &#34;group %s %s&#34; % (groupidname, span(self.beadtype))
               )

    @property
    def minmax(self):
        &#34;&#34;&#34; returns the min,max of beadtype &#34;&#34;&#34;
        return self.min,self.max

    @property
    def min(self):
        &#34;&#34;&#34; returns the min of beadtype &#34;&#34;&#34;
        return min(self.beadtype)

    @property
    def max(self):
        &#34;&#34;&#34; returns the max of beadtype &#34;&#34;&#34;
        return max(self.beadtype)

    def select(self,beadtype=None):
        &#34;&#34;&#34; select bead from a keep beadlist &#34;&#34;&#34;
        if beadtype==None: beadtype = list(range(self.min,self.max+1))
        if not isinstance(beadtype,(list,tuple)): beadtype = [beadtype]
        dup = scriptobjectgroup()
        for b,n,_,_ in self.zip:
            if b in beadtype:
                dup = dup + self.getattr(n)
                dup.getattr(n).USER = self.getattr(n).USER
                dup.getattr(n).forcefield = self.getattr(n).forcefield
        return dup

    @property
    def group(self):
        &#34;&#34;&#34; build groups from group (groupname contains synonyms) &#34;&#34;&#34;
        groupdef = struct()
        gid = 0
        bng = self.zip
        for g in self.groupname:
            gid +=1
            b =[x for x,_,gx,_ in bng if g in gx]
            groupdef.setattr(g,self.select(b).struct(groupid = gid, groupidname = g))
        return groupdef

    @CallableScript
    def interactions(self, printflag=False, verbosity=2, verbose=None):
        &#34;&#34;&#34; update and accumulate all forcefields &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        FF = []
        for b in self.beadtype:
            selection = deepduplicate(self.select(b)[0])
            selection.forcefield.beadtype = selection.beadtype
            selection.forcefield.userid = selection.name
            FF.append(selection.forcefield)
        # initialize interactions with pair_style
        TEMPLATE = &#34;\n# ===== [ BEGIN FORCEFIELD SECTION ] &#34;+&#34;=&#34;*80 if verbosity&gt;0 else &#34;&#34;
        TEMPLATE = FF[0].pair_style(verbose=verbosity&gt;0)
        # pair diagonal terms
        for i in range(len(FF)):
            TEMPLATE += FF[i].pair_diagcoeff(verbose=verbosity&gt;0)
        # pair off-diagonal terms
        for j in range(1,len(FF)):
            for i in range(0,j):
                TEMPLATE += FF[i].pair_offdiagcoeff(o=FF[j],verbose=verbosity&gt;0)
        # end
        TEMPLATE += &#34;\n# ===== [ END FORCEFIELD SECTION ] &#34;+&#34;=&#34;*82+&#34;\n&#34;  if verbosity&gt;0 else &#34;&#34;
        return FF,TEMPLATE

    @property
    def forcefield(self):
        &#34;&#34;&#34; interaction forcefields &#34;&#34;&#34;
        FF,_ = self.interactions
        return FF

    @CallableScript
    def script(self, printflag=False, verbosity=None, verbose=None):
        &#34;&#34;&#34;
            Generate a script based on the current collection of script objects

            Parameters:
            -----------
            printflag : bool, optional, default=False
                If True, prints the generated script.
            verbosity (int, optional): Controls the level of detail in the generated script.
                - 0: Minimal output, no comments.
                - 1: Basic comments for run steps.
                - 2: Detailed comments with additional information.
                Default is 2

            Returns:
            --------
            script
                The generated script describing the interactions between script objects.
        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if verbose is False else verbosity
        TEMPFILES = &#34;&#34;
        isfirst = True
        files_added = False
        if self.filename:
            for fn, cfn in self.filename.items():
                if fn and cfn:
                    if not files_added:
                        files_added = True
                        TEMPFILES += &#34;\n# ===== [ BEGIN INPUT FILES SECTION ] &#34; + &#34;=&#34; * 79 + &#34;\n&#34; if verbosity&gt;0 else &#34;&#34;
                    TEMPFILES += span(cfn, sep=&#34;, &#34;, left=&#34;\n# load files for objects: &#34;, right=&#34;\n&#34;) if verbosity&gt;1 else &#34;&#34;
                    if isfirst:
                        isfirst = False
                        TEMPFILES += f&#34;\tread_data {fn}\n&#34;  # First file, no append
                    else:
                        TEMPFILES += f&#34;\tread_data {fn} add append\n&#34;  # Subsequent files, append
        # define groups
        TEMPGRP = &#34;\n# ===== [ BEGIN GROUP SECTION ] &#34;+&#34;=&#34;*85 + &#34;\n&#34; if verbosity&gt;0 else &#34;&#34;
        for g in self.group:
            TEMPGRP += f&#39;\n\t#\tDefinition of group {g.groupid}:{g.groupidname}\n&#39; if verbosity&gt;1 else &#34;&#34;
            TEMPGRP += f&#39;\t#\t={span(g.name,sep=&#34;, &#34;)}\n&#39; if verbosity&gt;1 else &#34;&#34;
            TEMPGRP += f&#39;\t#\tSimilar groups: {span(g.groupname,sep=&#34;, &#34;)}\n&#39; if verbosity&gt;1 else &#34;&#34;
            TEMPGRP += f&#39;\tgroup \t {g.groupidname} \ttype \t {span(g.beadtype)}\n&#39;
        TEMPGRP += &#34;\n# ===== [ END GROUP SECTION ] &#34;+&#34;=&#34;*87+&#34;\n\n&#34; if verbosity&gt;0 else &#34;&#34;
        # define interactions
        _,TEMPFF = self.interactions(printflag=printflag, verbosity=verbosity)
        # chain strings into a script
        tscript = script(printflag=False,verbose=verbosity&gt;1)
        tscript.name = &#34;scriptobject script&#34;        # name
        tscript.description = str(self)             # description
        tscript.userid = &#34;scriptobject&#34;             # user name
        tscript.TEMPLATE = TEMPFILES+TEMPGRP+TEMPFF
        if verbosity==0:
            tscript.TEMPLATE = remove_comments(tscript.TEMPLATE)
        if printflag:
            repr(tscript)
        return tscript

    def group_generator(self, name=None):
        &#34;&#34;&#34;
        Generate and return a group object.

        This method creates a new `group` object, optionally with a specified name.
        If no name is provided, it generates a default name based on the current
        instance&#39;s `name` attribute, formatted with the `span` function. The method
        then iterates through the existing groups in `self.group`, adding each group
        to the new `group` object based on its `groupidname` and `beadtype`.

        Parameters:
        -----------
        name : str, optional
            The name for the generated group object. If not provided, a default name
            is generated based on the current instance&#39;s `name`.

        Returns:
        --------
        group
            A newly created `group` object with criteria set based on the existing groups.
        &#34;&#34;&#34;
        from pizza.group import group
        # Use the provided name or generate a default name using the span function
        G = group(name=name if name is not None else span(self.name, &#34;,&#34;, &#34;[&#34;, &#34;]&#34;))
        # Add criteria for each group in self.group
        for g in self.group:
            G.add_group_criteria(g.groupidname, type=g.beadtype)
        return G


    def mass(self, name=None, default_mass=&#34;${mass}&#34;, printflag=False, verbosity=2, verbose=True):
        &#34;&#34;&#34;
        Generates LAMMPS mass commands for each unique beadtype in the collection.

        The method iterates through all `scriptobjectgroup` instances in the collection,
        collects unique beadtypes, and ensures that each beadtype has a consistent mass.
        If a beadtype has `mass=None`, it assigns a default mass as specified by `default_mass`.

        ### Parameters:
            name (str, optional):
                The name to assign to the resulting `script` object. Defaults to a generated name.
            default_mass (str, int, or float, optional):
                The default mass value to assign when a beadtype&#39;s mass is `None`.
                Can be a string, integer, or floating-point value. Defaults to `&#34;${mass}&#34;`.
            printflag (bool, optional):
                If `True`, prints the representation of the resulting `script` object. Defaults to `False`.
            verbosity (int, optional):
                The verbosity level for logging or debugging. Higher values indicate more detailed output.
                Defaults to `2`.
            verbose (bool, optional):
                If `True`, includes a comment header in the output. Overrides `verbosity` when `False`.
                Defaults to `True`.

        ### Returns:
            script: A `script` object containing the mass commands for each beadtype, formatted as follows:
                     ```
                     mass 1 1.0
                     mass 2 ${mass}
                     mass 3 2.5
                     ```
                     The `TEMPLATE` attribute of the `script` object holds the formatted mass commands as a single string.

        ### Raises:
            ValueError: If a beadtype has inconsistent mass values across different `scriptobjectgroup` instances.

        ### Example:
            ```python
            # Create scriptobjectgroup instances
            obj1 = scriptobjectgroup(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
            obj2 = scriptobjectgroup(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
            obj3 = scriptobjectgroup(beadtype=3, group=&#34;C&#34;, mass=2.5)

            # Initialize a script group with the scriptobjectgroup instances
            G = scriptobjectgroup([obj1, obj2, obj3])

            # Generate mass commands
            M = G.mass()
            print(M.do())
            ```

            **Output:**
            ```
            # &lt;script:group:mass&gt; definitions for 3 beads
            mass 1 1.0
            mass 2 ${mass}
            mass 3 2.5
            ```
        &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        beadtype_mass = {}
        for iobj in range(0,len(self)):
            obj = self[iobj]
            bt = obj.beadtype
            mass = obj.mass if obj.mass is not None else default_mass
            if bt in beadtype_mass:
                if beadtype_mass[bt] != mass:
                    raise ValueError(
                        f&#34;Inconsistent masses for beadtype {bt}: {beadtype_mass[bt]} vs {mass}&#34;
                    )
            else:
                beadtype_mass[bt] = mass
        # Sort beadtypes for consistent ordering
        sorted_beadtypes = sorted(beadtype_mass.keys())
        # Generate mass commands
        lines = [f&#34;mass {bt} {beadtype_mass[bt]}&#34; for bt in sorted_beadtypes]
        # return a script object
        nameid = f&#34;&lt;script:group:{self.name}:mass&gt;&#34;
        description = f&#34;{nameid} definitions for {len(self)} beads&#34;
        if verbose:
            lines.insert(0, &#34;# &#34;+description)
        mscript = script(printflag=False,verbose=verbosity&gt;1)
        mscript.name = nameid if name is None else name
        mscript.description = description
        mscript.userid = &#34;scriptobject&#34;             # user name
        mscript.TEMPLATE = &#34;\n&#34;.join(lines)
        mscript.DEFINITIONS.mass = default_mass
        if printflag:
            repr(mscript)
        return mscript


# %% script core class
# note: please derive this class when you use it, do not alter it
class script:
    &#34;&#34;&#34;
    script: A Core Class for Flexible LAMMPS Script Generation

    The `script` class provides a flexible framework for generating dynamic LAMMPS
    script sections. It supports various LAMMPS sections such as &#34;GLOBAL&#34;, &#34;INITIALIZE&#34;,
    &#34;GEOMETRY&#34;, &#34;INTERACTIONS&#34;, and more, while allowing users to define custom sections
    with variable definitions, templates, and dynamic evaluation of script content.

    Key Features:
    -------------
    - **Dynamic Script Generation**: Easily define and manage script sections,
      using templates and definitions to dynamically generate LAMMPS-compatible scripts.
    - **Script Concatenation**: Combine multiple script sections while managing
      variable precedence and ensuring that definitions propagate as expected.
    - **Flexible Variable Management**: Separate `DEFINITIONS` for static variables and
      `USER` for user-defined variables, with clear rules for inheritance and precedence.
    - **Operators for Advanced Script Handling**: Use `+`, `&amp;`, `&gt;&gt;`, `|`, and `**` operators
      for script merging, static execution, right-shifting of definitions, and more.
    - **Pipeline Support**: Integrate scripts into pipelines, with full support for
      staged execution, variable inheritance, and reordering of script sections.

    Practical Use Cases:
    --------------------
    - **LAMMPS Automation**: Automate the generation of complex LAMMPS scripts by defining
      reusable script sections with variables and templates.
    - **Multi-Step Simulations**: Manage multi-step simulations by splitting large scripts
      into smaller, manageable sections and combining them as needed.
    - **Advanced Script Control**: Dynamically modify script behavior by overriding variables
      or using advanced operators to concatenate, pipe, or merge scripts.

    Methods:
    --------
    __init__(self, persistentfile=True, persistentfolder=None, printflag=False, verbose=False, **userdefinitions):
        Initializes a new `script` object, with optional user-defined variables
        passed as `userdefinitions`.

    do(self, printflag=None, verbose=None):
        Generates the LAMMPS script based on the current configuration, evaluating
        templates and definitions to produce the final output.

    script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Generate the final LAMMPS script from the pipeline or a subset of the pipeline.

    add(self, s):
        Overloads the `+` operator to concatenate script objects, merging definitions
        and templates while maintaining variable precedence.

    and(self, s):
        Overloads the `&amp;` operator for static execution, combining the generated scripts
        of two script objects without merging their definitions.

    __mul__(self, ntimes):
        Overloads the `*` operator to repeat the script `ntimes`, returning a new script
        object with repeated sections.

    __pow__(self, ntimes):
        Overloads the `**` operator to concatenate the script with itself `ntimes`,
        similar to the `&amp;` operator, but repeated.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the script into a pipeline,
        returning a `pipescript` object.

    write(self, file, printflag=True, verbose=False):
        Writes the generated script to a file, including headers with metadata.

    tmpwrite(self):
        Writes the script to a temporary file, creating both a full version and a clean
        version without comments.

    printheader(txt, align=&#34;^&#34;, width=80, filler=&#34;~&#34;):
        Static method to print formatted headers, useful for organizing output.

    __copy__(self):
        Creates a shallow copy of the script object.

    __deepcopy__(self, memo):
        Creates a deep copy of the script object, duplicating all internal variables.

    Additional Features:
    --------------------
    - **Customizable Templates**: Use string templates with variable placeholders
      (e.g., `${value}`) to dynamically generate script lines.
    - **Static and User-Defined Variables**: Manage global `DEFINITIONS` for static
      variables and `USER` variables for dynamic, user-defined settings.
    - **Advanced Operators**: Leverage a range of operators (`+`, `&gt;&gt;`, `|`, `&amp;`) to
      manipulate script content, inherit definitions, and control variable precedence.
    - **Verbose Output**: Control verbosity to include detailed comments and debugging
      information in generated scripts.

    Original Content:
    -----------------
    The `script` class supports LAMMPS section generation and variable management with
    features such as:
    - **Dynamic Evaluation of Scripts**: Definitions and templates are evaluated at runtime,
      allowing for flexible and reusable scripts.
    - **Inheritance of Definitions**: Variable definitions can be inherited from previous
      sections, allowing for modular script construction.
    - **Precedence Rules for Variables**: When scripts are concatenated, definitions from
      the left take precedence, ensuring that the first defined values are preserved.
    - **Instance and Global Variables**: Instance variables are set via the `USER` object,
      while global variables (shared across instances) are managed in `DEFINITIONS`.
    - **Script Pipelines**: Scripts can be integrated into pipelines for sequential execution
      and dynamic variable propagation.
    - **Flexible Output Formats**: Lists are expanded into space-separated strings, while
      tuples are expanded with commas, making the output more readable.

    Example Usage:
    --------------
    ```
    from pizza.script import script, scriptdata

    class example_section(script):
        DEFINITIONS = scriptdata(
            X = 10,
            Y = 20,
            result = &#34;${X} + ${Y}&#34;
        )
        TEMPLATE = &#34;${result} = ${X} + ${Y}&#34;

    s1 = example_section()
    s1.USER.X = 5
    s1.do()
    ```

    The output for `s1.do()` will be:
    ```
    25 = 5 + 20
    ```

    With additional sections, scripts can be concatenated and executed as a single
    entity, with inheritance of variables and customizable behavior.


        --------------------------------------
           OVERVIEW ANDE DETAILED FEATURES
        --------------------------------------

        The class script enables to generate dynamically LAMMPS sections
        &#34;NONE&#34;,&#34;GLOBAL&#34;,&#34;INITIALIZE&#34;,&#34;GEOMETRY&#34;,&#34;DISCRETIZATION&#34;,
        &#34;BOUNDARY&#34;,&#34;INTERACTIONS&#34;,&#34;INTEGRATION&#34;,&#34;DUMP&#34;,&#34;STATUS&#34;,&#34;RUN&#34;


        # %% This the typical construction for a class
        class XXXXsection(script):
            &#34;&#34; &#34; LAMMPS script: XXXX session &#34;&#34; &#34;
            name = &#34;XXXXXX&#34;
            description = name+&#34; section&#34;
            position = 0
            section = 0
            userid = &#34;example&#34;
            version = 0.1

            DEFINITIONS = scriptdata(
                 value= 1,
            expression= &#34;${value+1}&#34;,
                  text= &#34;$my text&#34;
                )

            TEMPLATE = &#34;&#34; &#34;
        # :UNDEF SECTION:
        #   to be defined
        LAMMPS code with ${value}, ${expression}, ${text}
            &#34;&#34; &#34;

        DEFINTIONS can be inherited from a previous section
        DEFINITIONS = previousection.DEFINTIONS + scriptdata(
                 value= 1,
            expression= &#34;${value+1}&#34;,
                  text= &#34;$my text&#34;
            )


        Recommandation: Split a large script into a small classes or actions
        An example of use could be:
            move1 = translation(displacement=10)+rotation(angle=30)
            move2 = shear(rate=0.1)+rotation(angle=20)
            bigmove = move1+move2+move1
            script = bigmove.do() generates the script

        NOTE1: Use the print() and the method do() to get the script interpreted

        NOTE2: DEFINITIONS can be pretified using DEFINITIONS.generator()

        NOTE3: Variables can extracted from a template using TEMPLATE.scan()

        NOTE4: Scripts can be joined (from top down to bottom).
        The first definitions keep higher precedence. Please do not use
        a variable twice with different contents.

        myscript = s1 + s2 + s3 will propagate the definitions
        without overwritting previous values). myscript will be
        defined as s1 (same name, position, userid, etc.)

        myscript += s appends the script section s to myscript

        NOTE5: rules of precedence when script are concatenated
        The attributes from the class (name, description...) are kept from the left
        The values of the right overwrite all DEFINITIONS

        NOTE6: user variables (instance variables) can set with USER or at the construction
        myclass_instance = myclass(myvariable = myvalue)
        myclass_instance.USER.myvariable = myvalue

        NOTE7: how to change variables for all instances at once?
        In the example below, let x is a global variable (instance independent)
        and y a local variable (instance dependent)
        instance1 = myclass(y=1) --&gt; y=1 in instance1
        instance2 = myclass(y=2) --&gt; y=2 in instance2
        instance3.USER.y=3 --&gt; y=3 in instance3
        instance1.DEFINITIONS.x = 10 --&gt; x=10 in all instances (1,2,3)

        If x is also defined in the USER section, its value will be used
        Setting instance3.USER.x = 30 will assign x=30 only in instance3

        NOTE8: if a the script is used with different values for a same parameter
        use the operator &amp; to concatenate the results instead of the script
        example: load(file=&#34;myfile1&#34;) &amp; load(file=&#34;myfile2) &amp; load(file=&#34;myfile3&#34;)+...

        NOTE9: lists (e.g., [1,2,&#39;a&#39;,3] are expanded (&#34;1 2 a 3&#34;)
               tuples (e.g. (1,2)) are expanded (&#34;1,2&#34;)
               It is easier to read [&#34;lost&#34;,&#34;ignore&#34;] than &#34;$ lost ignore&#34;

        NOTE 10: New operators &gt;&gt; and || extend properties
            + merge all scripts but overwrite definitions
            &amp; execute statically script content
            &gt;&gt; pass only DEFINITIONS but not TEMPLATE to the right
            | pipe execution such as in Bash, the result is a pipeline

        NOTE 11: Scripts in pipelines are very flexible, they support
        full indexing à la Matlab, including staged executions
            method do(idx) generates the script corresponding to indices idx
            method script(idx) generates the corresponding script object

        --------------------------[ FULL EXAMPLE ]-----------------------------

        # Import the class
        from pizza.script import *

        # Override the class globalsection
        class scriptexample(globalsection):
            description = &#34;demonstrate commutativity of additions&#34;
            verbose = True

            DEFINITIONS = scriptdata(
                X = 10,
                Y = 20,
                R1 = &#34;${X}+${Y}&#34;,
                R2 = &#34;${Y}+${X}&#34;
                )
            TEMPLATE = &#34;&#34; &#34;
            # Property of the addition
            ${R1} = ${X} + ${Y}
            ${R2} = ${Y} + ${X}
         &#34;&#34; &#34;

        # derived from scriptexample, X and Y are reused
        class scriptexample2(scriptexample):
            description = &#34;demonstrate commutativity of multiplications&#34;
            verbose = True
            DEFINITIONS = scriptexample.DEFINITIONS + scriptdata(
                R3 = &#34;${X} * ${Y}&#34;,
                R4 = &#34;${Y} * ${X}&#34;,
                )
            TEMPLATE = &#34;&#34; &#34;
            # Property of the multiplication
            ${R3} = ${X} * ${Y}
            ${R4} = ${Y} * ${X}
         &#34;&#34; &#34;

        # call the first class and override the values X and Y
        s1 = scriptexample()
        s1.USER.X = 1  # method 1 of override
        s1.USER.Y = 2
        s1.do()
        # call the second class and override the values X and Y
        s2 = scriptexample2(X=1000,Y=2000) # method 2
        s2.do()
        # Merge the two scripts
        s = s1+s2
        print(&#34;this is my full script&#34;)
        s.description
        s.do()

        # The result for s1 is
            3 = 1 + 2
            3 = 2 + 1
        # The result for s2 is
            2000000 = 1000 * 2000
            2000000 = 2000 * 1000
        # The result for s=s1+s2 is
            # Property of the addition
            3000 = 1000 + 2000
            3000 = 2000 + 1000
            # Property of the multiplication
            2000000 = 1000 * 2000
            2000000 = 2000 * 1000

    &#34;&#34;&#34;

    # metadata
    metadata = get_metadata()               # retrieve all metadata

    type = &#34;script&#34;                         # type (class name)
    name = &#34;empty script&#34;                   # name
    description = &#34;it is an empty script&#34;   # description
    position = 0                            # 0 = root
    section = 0                             # section (0=undef)
    userid = &#34;undefined&#34;                    # user name
    version = metadata[&#34;version&#34;]           # version
    license = metadata[&#34;license&#34;]
    email = metadata[&#34;email&#34;]               # email

    verbose = False                         # set it to True to force verbosity
    _contact = (&#34;INRAE\SAYFOOD\olivier.vitrac@agroparistech.fr&#34;,
                &#34;INRAE\SAYFOOD\william.jenkinson@agroparistech.fr&#34;,
                &#34;INRAE\SAYFOOD\han.chen@inrae.fr&#34;)

    SECTIONS = [&#34;NONE&#34;,&#34;GLOBAL&#34;,&#34;INITIALIZE&#34;,&#34;GEOMETRY&#34;,&#34;DISCRETIZATION&#34;,
                &#34;BOUNDARY&#34;,&#34;INTERACTIONS&#34;,&#34;INTEGRATION&#34;,&#34;DUMP&#34;,&#34;STATUS&#34;,&#34;RUN&#34;]

    # Main class variables
    # These definitions are for instances
    DEFINITIONS = scriptdata()
    TEMPLATE = &#34;&#34;&#34;
        # empty LAMMPS script
    &#34;&#34;&#34;

    # constructor
    def __init__(self,persistentfile=True,
                 persistentfolder = None,
                 printflag = False,
                 verbose = False,
                 verbosity = None,
                 **userdefinitions):
        &#34;&#34;&#34; constructor adding instance definitions stored in USER &#34;&#34;&#34;
        if persistentfolder is None: persistentfolder = get_tmp_location()
        self.persistentfile = persistentfile
        self.persistentfolder = persistentfolder
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.USER = scriptdata(**userdefinitions)

    # print method for headers (static, no implicit argument)
    @staticmethod
    def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
        &#34;&#34;&#34; print header &#34;&#34;&#34;
        if txt==&#34;&#34;:
            print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
        else:
            print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))

    # String representation
    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self.type}:{self.name}:{self.userid}&#34;

    # Display/representation method
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        stamp = str(self)
        self.printheader(f&#34;{stamp} | version={self.version}&#34;,filler=&#34;/&#34;)
        self.printheader(&#34;POSITION &amp; DESCRIPTION&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        print(f&#34;     position: {self.position}&#34;)
        print(f&#34;         role: {self.role} (section={self.section})&#34;)
        print(f&#34;  description: {self.description}&#34;)
        self.printheader(&#34;DEFINITIONS&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        if len(self.DEFINITIONS)&lt;15:
            self.DEFINITIONS.__repr__()
        else:
            print(&#34;too many definitions: &#34;,self.DEFINITIONS)
        if self.verbose:
            self.printheader(&#34;USER&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
            self.USER.__repr__()
            self.printheader(&#34;TEMPLATE&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
            print(self.TEMPLATE)
            self.printheader(&#34;SCRIPT&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        print(self.do(printflag=False))
        self.printheader(&#34;&#34;)
        return stamp

    # Extract attributes within the class
    def getallattributes(self):
        &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
        return {k: getattr(self, k) for k in dir(self) \
                if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}

    # Generate the script
    def do(self,printflag=None,verbose=None):
        &#34;&#34;&#34;
        Generate the LAMMPS script based on the current configuration.

        This method generates a LAMMPS-compatible script from the templates and definitions
        stored in the `script` object. The generated script can be displayed, returned,
        and optionally include comments for debugging or clarity.

        Parameters:
        -----------
        - printflag (bool, optional): If True, the generated script is printed to the console.
                                      Default is True.
        - verbose (bool, optional): If True, comments and additional information are included
                                    in the generated script. If False, comments are removed.
                                    Default is True.

        Returns:
        ---------
        - str: The generated LAMMPS script.

        Method Behavior:
        - The method first collects all key-value pairs from `DEFINITIONS` and `USER` objects,
          which store the configuration data for the script.
        - Lists and tuples in the collected data are formatted into a readable string with proper
          separators (space for lists, comma for tuples) and prefixed with a &#39;%&#39; to indicate comments.
        - The generated command template is formatted and evaluated using the collected data.
        - If `verbose` is set to False, comments in the generated script are removed.
        - The script is then printed if `printflag` is True.
        - Finally, the formatted script is returned as a string.


        Example Usage:
        --------------
        &gt;&gt;&gt; s = script()
        &gt;&gt;&gt; s.do(printflag=True, verbose=True)
        units           si
        dimension       3
        boundary        f f f
        # Additional script commands...

        &gt;&gt;&gt; s.do(printflag=False, verbose=False)
        &#39;units si\ndimension 3\nboundary f f f\n# Additional script commands...&#39;

        Notes:
        - Comments are indicated in the script with &#39;%&#39; or &#39;#&#39;.
        - The [position {self.position}:{self.userid}] marker is inserted for tracking
          script sections or modifications.


        Known Issues for indexed variables
        ----------------------------------
        List and tupples used indexed in templates, such as varlist[1], are not converted into strings so that
        each element can be considered as a variable and accessed as ${varlist[1]}. If varlist is also used in
        full, such as ${varlist}. Then it is preferable to define varlist as a string:
            &#34;![v1,v2,...]&#34; where v1,v2,v3 can be int, float, static str or evaluable str (i.e., subjected to nested
             evaluation).
        The control character ! in lists, such as in var=![v1,v2,v3] preserves the Pythonic definition by do()
        at later stages during the evaluation so that its content can be indexed.

        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        inputs = self.DEFINITIONS + self.USER
        usedvariables = self.detect_variables(with_index=False,only_indexed=False)
        variables_used_with_index = self.detect_variables(with_index=False,only_indexed=True)
        usedvariables_withoutindex = [ var for var in usedvariables if var not in variables_used_with_index ]
        for k in inputs.keys():
            if k in usedvariables_withoutindex:
                if isinstance(inputs.getattr(k),list):
                    inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k)))
                elif isinstance(inputs.getattr(k),tuple):
                    inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k),sep=&#34;,&#34;))
        cmd = inputs.formateval(self.TEMPLATE)
        cmd = cmd.replace(&#34;[comment]&#34;,f&#34;[position {self.position}:{self.userid}]&#34;)
        if not verbose: cmd=remove_comments(cmd)
        if printflag: print(cmd)
        return cmd

    # Return the role of the script (based on section)
    @property
    def role(self):
        &#34;&#34;&#34; convert section index into a role (section name) &#34;&#34;&#34;
        if self.section in range(len(self.SECTIONS)):
            return self.SECTIONS[self.section]
        else:
            return &#34;&#34;

    # override +
    def __add__(self,s):
        &#34;&#34;&#34; overload addition operator &#34;&#34;&#34;
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        if isinstance(s,script):
            dup = duplicate(self)
            dup.DEFINITIONS = dup.DEFINITIONS + s.DEFINITIONS
            dup.USER = dup.USER + s.USER
            dup.TEMPLATE = &#34;\n&#34;.join([dup.TEMPLATE,s.TEMPLATE])
            return dup
        elif isinstance(s,pipescript):
            return pipescript(self, printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity) | s
        elif isinstance(s,dscript):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        elif isinstance(s, scriptobjectgroup):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s, group):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        elif isinstance(s, groupcollection):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s,region):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        raise TypeError(f&#34;the second operand in + must a script, pipescript, scriptobjectgroup,\n group, groupcollection or region object not {type(s)}&#34;)

    # override +=
    def _iadd__(self,s):
        &#34;&#34;&#34; overload addition operator &#34;&#34;&#34;
        if isinstance(s,script):
            self.DEFINITIONS = self.DEFINITIONS + s.DEFINITIONS
            self.USER = self.USER + s.USER
            self.TEMPLATE = &#34;\n&#34;.join([self.TEMPLATE,s.TEMPLATE])
        else:
            raise TypeError(&#34;the second operand must a script object&#34;)

    # override &gt;&gt;
    def __rshift__(self,s):
        &#34;&#34;&#34; overload right  shift operator (keep only the last template) &#34;&#34;&#34;
        if isinstance(s,script):
            dup = duplicate(self)
            dup.DEFINITIONS = dup.DEFINITIONS + s.DEFINITIONS
            dup.USER = dup.USER + s.USER
            dup.TEMPLATE = s.TEMPLATE
            return dup
        else:
            raise TypeError(f&#34;the second operand in &gt;&gt; must a script object not {type(s)}&#34;)

    # override &amp;
    def __and__(self,s):
        &#34;&#34;&#34; overload and operator &#34;&#34;&#34;
        if isinstance(s,script):
            dup = duplicate(self)
            dup.TEMPLATE = &#34;\n&#34;.join([self.do(printflag=False,verbose=False),s.do(printflag=False,verbose=False)])
            return dup
        raise TypeError(f&#34;the second operand in &amp; must a script object not {type(s)}&#34;)

    # override *
    def __mul__(self,ntimes):
        &#34;&#34;&#34; overload * operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
           res = duplicate(self)
           if ntimes&gt;1:
               for n in range(1,ntimes): res += self
           return res
        raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)

    # override **
    def __pow__(self,ntimes):
        &#34;&#34;&#34; overload ** operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
           res = duplicate(self)
           if ntimes&gt;1:
               for n in range(1,ntimes): res = res &amp; self
           return res
        raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)

    # pipe scripts
    def __or__(self,pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        if isinstance(pipe, dscript):
            rightarg = pipe.pipescript(printflag=pipe.printflag,verbose=pipe.verbose,verbosity=pipe.verbosity)
        elif isinstance(pipe,group):
            rightarg = pipe.script(printflag=pipe.printflag,verbose=pipe.verbose,verbosity=pipe.verbosity)
        elif isinstance(pipe,groupcollection):
            rightarg = pipe.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(pipe,region):
            rightarg = pipe.pscript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        else:
            rightarg = pipe
        if isinstance(rightarg,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | rightarg
        else:
            raise ValueError(&#34;the argument in | must a pipescript, a scriptobject or a scriptobjectgroup not {type(s)}&#34;)


    def header(self, verbose=True, verbosity=None, style=2):
        &#34;&#34;&#34;
        Generate a formatted header for the script file.

        Parameters:
            verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                        Defaults to the instance&#39;s `verbose`.
            style (int from 1 to 6, optional): ASCII style to frame the header (default=2)

        Returns:
            str: A formatted string representing the script&#39;s metadata and initialization details.
                 Returns an empty string if verbosity is False.

        The header includes:
            - Script version, license, and contact email.
            - User ID and the number of initialized definitions.
            - Current system user, hostname, and working directory.
            - Persistent filename and folder path.
            - Timestamp of the header generation.
        &#34;&#34;&#34;
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        if not verbose:
            return &#34;&#34;
        # Prepare the header content
        lines = [
            f&#34;PIZZA.SCRIPT FILE v{script.version} | License: {script.license} | Email: {script.email}&#34;,
            &#34;&#34;,
            f&#34;&lt;{str(self)}&gt;&#34;,
            f&#34;Initialized with {len(self.USER)} definitions | Verbosity: {verbosity}&#34;,
            f&#34;Persistent file: \&#34;{self.persistentfile}\&#34; | Folder: \&#34;{self.persistentfolder}\&#34;&#34;,
            &#34;&#34;,
            f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
            f&#34;{datetime.datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
        ]
        # Use the shared method to format the header
        return frame_header(lines,style=style)


    # write file
    def write(self, file, printflag=True, verbose=False, overwrite=False, style=2):
        &#34;&#34;&#34;
        Write the script to a file.

        Parameters:
            - file (str): The file path where the script will be saved.
            - printflag (bool): Flag to enable/disable printing of details.
            - verbose (bool): Flag to enable/disable verbose mode.
            - overwrite (bool): Whether to overwrite the file if it already exists.
            - style (int, optional):
                Defines the ASCII frame style for the header.
                Valid values are integers from 1 to 6, corresponding to predefined styles:
                    1. Basic box with `+`, `-`, and `|`
                    2. Double-line frame with `╔`, `═`, and `║`
                    3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                    4. Thick outer frame with `#`, `=`, and `#`
                    5. Box drawing characters with `┌`, `─`, and `│`
                    6. Minimalist dotted frame with `.`, `:`, and `.`
                Default is `2` (frame with rounded corners).

        Returns:
            str: The full absolute path of the file written.

        Raises:
            FileExistsError: If the file already exists and overwrite is False.
        &#34;&#34;&#34;
        # Resolve full path
        full_path = os.path.abspath(file)
        if os.path.exists(full_path) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{full_path}&#39; already exists. Use overwrite=True to overwrite it.&#34;)
        if os.path.exists(full_path) and overwrite and verbose:
            print(f&#34;Warning: Overwriting the existing file &#39;{full_path}&#39;.&#34;)
        # Generate the script and write to the file
        cmd = self.do(printflag=printflag, verbose=verbose)
        with open(full_path, &#34;w&#34;) as f:
            print(self.header(verbosity=verbose, style=style), &#34;\n&#34;, file=f)
            print(cmd, file=f)
        # Return the full path of the written file
        return full_path

    def tmpwrite(self, verbose=False, style=1):
        &#34;&#34;&#34;
        Write the script to a temporary file and create optional persistent copies.

        Parameters:
            verbose (bool, optional): Controls verbosity during script generation. Defaults to False.

        The method:
            - Creates a temporary file for the script, with platform-specific behavior:
                - On Windows (`os.name == &#39;nt&#39;`), the file is not automatically deleted.
                - On other systems, the file is temporary and deleted upon closure.
            - Writes a header and the script content into the temporary file.
            - Optionally creates a persistent copy in the `self.persistentfolder` directory:
                - `script.preview.&lt;suffix&gt;`: A persistent copy of the temporary file.
                - `script.preview.clean.&lt;suffix&gt;`: A clean copy with comments and empty lines removed.
            - Handles cleanup and exceptions gracefully to avoid leaving orphaned files.
            - style (int, optional):
                Defines the ASCII frame style for the header.
                Valid values are integers from 1 to 6, corresponding to predefined styles:
                    1. Basic box with `+`, `-`, and `|`
                    2. Double-line frame with `╔`, `═`, and `║`
                    3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                    4. Thick outer frame with `#`, `=`, and `#`
                    5. Box drawing characters with `┌`, `─`, and `│`
                    6. Minimalist dotted frame with `.`, `:`, and `.`
                Default is `1` (basic box).

        Returns:
            TemporaryFile: The temporary file handle (non-Windows systems only).
            None: On Windows, the file is closed and not returned.

        Raises:
            Exception: If there is an error creating or writing to the temporary file.
        &#34;&#34;&#34;
        try:
            # OS-specific temporary file behavior
            if os.name == &#39;nt&#39;:  # Windows
                ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;, delete=False)
            else:  # Other platforms
                ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;)

            # Generate header and content
            header = (
                f&#34;# TEMPORARY PIZZA.SCRIPT FILE\n&#34;
                f&#34;# {&#39;-&#39; * 40}\n&#34;
                f&#34;{self.header(verbosity=verbose, style=style)}&#34;
            )
            content = (
                header
                + &#34;\n# This is a temporary file (it will be deleted automatically)\n\n&#34;
                + self.do(printflag=False, verbose=verbose)
            )

            # Write content to the temporary file
            ftmp.write(BOM_UTF8 + content.encode(&#39;utf-8&#39;))
            ftmp.seek(0)  # Reset file pointer to the beginning

        except Exception as e:
            # Handle errors gracefully
            ftmp.close()
            os.remove(ftmp.name)  # Clean up the temporary file
            raise Exception(f&#34;Failed to write to or handle the temporary file: {e}&#34;) from None

        print(&#34;\nTemporary File Header:\n&#34;, header, &#34;\n&#34;)
        print(&#34;A temporary file has been generated here:\n&#34;, ftmp.name)

        # Persistent copy creation
        if self.persistentfile:
            ftmpname = os.path.basename(ftmp.name)
            fcopyname = os.path.join(self.persistentfolder, f&#34;script.preview.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
            copyfile(ftmp.name, fcopyname)
            print(&#34;A persistent copy has been created here:\n&#34;, fcopyname)

            # Create a clean copy without empty lines or comments
            with open(ftmp.name, &#34;r&#34;) as f:
                lines = f.readlines()
            bom_utf8_str = BOM_UTF8.decode(&#34;utf-8&#34;)
            clean_lines = [
                line for line in lines
                if line.strip() and not line.lstrip().startswith(&#34;#&#34;) and not line.startswith(bom_utf8_str)
            ]
            fcleanname = os.path.join(self.persistentfolder, f&#34;script.preview.clean.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
            with open(fcleanname, &#34;w&#34;) as f:
                f.writelines(clean_lines)
            print(&#34;A clean copy has been created here:\n&#34;, fcleanname)

            # Handle file closure for Windows
            if os.name == &#39;nt&#39;:
                ftmp.close()
                return None
            else:
                return ftmp


    # Note that it was not the original intent to copy scripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo))
        return copie


    def detect_variables(self, with_index=False, only_indexed=False):
        &#34;&#34;&#34;
        Detects variables in the content of the template using an extended pattern
        to include indexed variables (e.g., ${var[i]}) if `with_index` is True.

        Parameters:
        -----------
        with_index : bool, optional
            If True, include indexed variables with their indices (e.g., ${var[i]}). Default is False.
        only_indexed : bool, optional
            If True, target only variables that are used with an index (e.g., ${var[i]}). Default is False.

        Returns:
        --------
        list
            A list of unique variable names detected in the content based on the flags.
        &#34;&#34;&#34;
        # Regular expression to match variables with optional indexing
        variable_pattern = re.compile(r&#39;\$\{(\w+)(\[\w+\])?\}&#39;)
        # Ensure TEMPLATE is iterable (split string into lines if needed)
        if isinstance(self.TEMPLATE, str):
            lines = self.TEMPLATE.splitlines()  # Split string into lines
        elif isinstance(self.TEMPLATE, list):
            lines = self.TEMPLATE
        else:
            raise TypeError(&#34;TEMPLATE must be a string or a list of strings.&#34;)
        # Detect variables from all lines
        detected_vars = set()
        for line in lines:
            matches = variable_pattern.findall(line)
            for match in matches:
                variable_name = match[0]  # Base variable name
                index = match[1]          # Optional index (e.g., &#39;[i]&#39;)
                if only_indexed and not index:
                    continue  # Skip non-indexed variables if targeting only indexed ones
                if with_index and index:
                    detected_vars.add(f&#34;{variable_name}{index}&#34;)  # Include the full indexed variable
                elif not with_index:
                    detected_vars.add(variable_name)  # Include only the base variable

        # Return the list of unique variables
        return list(detected_vars)


# %% pipe script
class pipescript:
    &#34;&#34;&#34;
    pipescript: A Class for Managing Script Pipelines

    The `pipescript` class stores scripts in a pipeline where multiple scripts,
    script objects, or script object groups can be combined and executed
    sequentially. Scripts in the pipeline are executed using the pipe (`|`) operator,
    allowing for dynamic control over execution order, script concatenation, and
    variable management.

    Key Features:
    -------------
    - **Pipeline Construction**: Create pipelines of scripts, combining multiple
      script objects, `script`, `scriptobject`, or `scriptobjectgroup` instances.
      The pipe operator (`|`) is overloaded to concatenate scripts.
    - **Sequential Execution**: Execute all scripts in the pipeline in the order
      they were added, with support for reordering, selective execution, and
      clearing of individual steps.
    - **User and Definition Spaces**: Manage local and global user-defined variables
      (`USER` space) and static definitions for each script in the pipeline.
      Global definitions apply to all scripts in the pipeline, while local variables
      apply to specific steps.
    - **Flexible Script Handling**: Indexing, slicing, reordering, and renaming
      scripts in the pipeline are supported. Scripts can be accessed, replaced,
      and modified like array elements.

    Practical Use Cases:
    --------------------
    - **LAMMPS Script Automation**: Automate the generation of multi-step simulation
      scripts for LAMMPS, combining different simulation setups into a single pipeline.
    - **Script Management**: Combine and manage multiple scripts, tracking user
      variables and ensuring that execution order can be adjusted easily.
    - **Advanced Script Execution**: Perform partial pipeline execution, reorder
      steps, or clear completed steps while maintaining the original pipeline structure.

    Methods:
    --------
    __init__(self, s=None):
        Initializes a new `pipescript` object, optionally starting with a script
        or script-like object (`script`, `scriptobject`, `scriptobjectgroup`).

    setUSER(self, idx, key, value):
        Set a user-defined variable (`USER`) for the script at the specified index.

    getUSER(self, idx, key):
        Get the value of a user-defined variable (`USER`) for the script at the
        specified index.

    clear(self, idx=None):
        Clear the execution status of scripts in the pipeline, allowing them to
        be executed again.

    do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Execute the pipeline or a subset of the pipeline, generating a combined
        LAMMPS-compatible script.

    script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Generate the final LAMMPS script from the pipeline or a subset of the pipeline.

    rename(self, name=&#34;&#34;, idx=None):
        Rename the scripts in the pipeline, assigning new names to specific
        indices or all scripts.

    write(self, file, printflag=True, verbosity=2, verbose=None):
        Write the generated script to a file.

    dscript(self, verbose=None, **USER)
        Convert the current pipescript into a dscript object

    header(self, verbose=True,verbosity=None, style=4):
        Generate a formatted header for the pipescript file.

    list_values(self, varname, what=&#34;all&#34;):
        List all occurrences and values of a variable across the pipeline scripts.

    list_multiple_values(self, varnames, what=&#34;all&#34;):
        List all occurrences and values of multiple variables across the pipeline scripts.

    plot_value_distribution(self, varname, what=&#34;all&#34;):
        Plot the distribution of values for a given variable across specified scopes.

    generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
        Generate a comprehensive report for specified variables and writes it to a file.


    Static Methods:
    ---------------
    join(liste):
        Combine a list of `script` and `pipescript` objects into a single pipeline.

    Additional Features:
    --------------------
    - **Indexing and Slicing**: Use array-like indexing (`p[0]`, `p[1:3]`) to access
      and manipulate scripts in the pipeline.
    - **Deep Copy Support**: The pipeline supports deep copying, preserving the
      entire pipeline structure and its scripts.
    - **Verbose and Print Options**: Control verbosity and printing behavior for
      generated scripts, allowing for detailed output or minimal script generation.

    Original Content:
    -----------------
    The `pipescript` class supports a variety of pipeline operations, including:
    - Sequential execution with `cmd = p.do()`.
    - Reordering pipelines with `p[[2, 0, 1]]`.
    - Deleting steps with `p[[0, 1]] = []`.
    - Accessing local and global user space variables via `p.USER[idx].var` and
      `p.scripts[idx].USER.var`.
    - Managing static definitions for each script in the pipeline.
    - Example usage:
      ```
      p = pipescript()
      p | i
      p = G | c | g | d | b | i | t | d | s | r
      p.rename([&#34;G&#34;, &#34;c&#34;, &#34;g&#34;, &#34;d&#34;, &#34;b&#34;, &#34;i&#34;, &#34;t&#34;, &#34;d&#34;, &#34;s&#34;, &#34;r&#34;])
      cmd = p.do([0, 1, 4, 7])
      sp = p.script([0, 1, 4, 7])
      ```
    - Scripts in the pipeline are executed sequentially, and definitions propagate
      from left to right. The `USER` space and `DEFINITIONS` are managed separately
      for each script in the pipeline.

    OVERVIEW
    -----------------
        Pipescript class stores scripts in pipelines
            By assuming: s0, s1, s2... scripts, scriptobject or scriptobjectgroup
            p = s0 | s1 | s2 generates a pipe script

            Example of pipeline:
          ------------:----------------------------------------
          [-]  00: G with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  01: c with (0&gt;&gt;0&gt;&gt;10) DEFINITIONS
          [-]  02: g with (0&gt;&gt;0&gt;&gt;26) DEFINITIONS
          [-]  03: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  04: b with (0&gt;&gt;0&gt;&gt;28) DEFINITIONS
          [-]  05: i with (0&gt;&gt;0&gt;&gt;49) DEFINITIONS
          [-]  06: t with (0&gt;&gt;0&gt;&gt;2) DEFINITIONS
          [-]  07: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  08: s with (0&gt;&gt;0&gt;&gt;1) DEFINITIONS
          [-]  09: r with (0&gt;&gt;0&gt;&gt;20) DEFINITIONS
          ------------:----------------------------------------
        Out[35]: pipescript containing 11 scripts with 8 executed[*]

        note: XX&gt;&gt;YY&gt;&gt;ZZ represents the number of stored variables
             and the direction of propagation (inheritance from left)
             XX: number of definitions in the pipeline USER space
             YY: number of definitions in the script instance (frozen in the pipeline)
             ZZ: number of definitions in the script (frozen space)

            pipelines are executed sequentially (i.e. parameters can be multivalued)
                cmd = p.do()
                fullscript = p.script()

            pipelines are indexed
                cmd = p[[0,2]].do()
                cmd = p[0:2].do()
                cmd = p.do([0,2])

            pipelines can be reordered
                q = p[[2,0,1]]

            steps can be deleted
                p[[0,1]] = []

            clear all executions with
                p.clear()
                p.clear(idx=1,2)

            local USER space can be accessed via
            (affects only the considered step)
                p.USER[0].a = 1
                p.USER[0].b = [1 2]
                p.USER[0].c = &#34;$ hello world&#34;

            global USER space can accessed via
            (affects all steps onward)
                p.scripts[0].USER.a = 10
                p.scripts[0].USER.b = [10 20]
                p.scripts[0].USER.c = &#34;$ bye bye&#34;

            static definitions
                p.scripts[0].DEFINITIONS

            steps can be renamed with the method rename()

            syntaxes are à la Matlab:
                p = pipescript()
                p | i
                p = collection | G
                p[0]
                q = p | p
                q[0] = []
                p[0:1] = q[0:1]
                p = G | c | g | d | b | i | t | d | s | r
                p.rename([&#34;G&#34;,&#34;c&#34;,&#34;g&#34;,&#34;d&#34;,&#34;b&#34;,&#34;i&#34;,&#34;t&#34;,&#34;d&#34;,&#34;s&#34;,&#34;r&#34;])
                cmd = p.do([0,1,4,7])
                sp = p.script([0,1,4,7])
                r = collection | p

            join joins a list (static method)
                p = pipescript.join([p1,p2,s3,s4])


            Pending: mechanism to store LAMMPS results (dump3) in the pipeline
    &#34;&#34;&#34;

    def __init__(self,s=None, name=None, printflag=False, verbose=True, verbosity = None):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        self.globalscript = None
        self.listscript = []
        self.listUSER = []
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.cmd = &#34;&#34;
        if isinstance(s,script):
            self.listscript = [duplicate(s)]
            self.listUSER = [scriptdata()]
        elif isinstance(s,scriptobject):
            self.listscript = [scriptobjectgroup(s).script]
            self.listUSER = [scriptdata()]
        elif isinstance(s,scriptobjectgroup):
            self.listscript = [s.script]
            self.listUSER = [scriptdata()]
        else:
            ValueError(&#34;the argument should be a scriptobject or scriptobjectgroup&#34;)
        if s != None:
            self.name = [str(s)]
            self.executed = [False]
        else:
            self.name = []
            self.executed = []

    def setUSER(self,idx,key,value):
        &#34;&#34;&#34;
            setUSER sets USER variables
            setUSER(idx,varname,varvalue)
        &#34;&#34;&#34;
        if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
            self.listUSER[idx].setattr(key,value)
        else:
            raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)

    def getUSER(self,idx,key):
        &#34;&#34;&#34;
            getUSER get USER variable
            getUSER(idx,varname)
        &#34;&#34;&#34;
        if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
            self.listUSER[idx].getattr(key)
        else:
            raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)

    @property
    def USER(self):
        &#34;&#34;&#34;
            p.USER[idx].var returns the value of the USER variable var
            p.USER[idx].var = val assigns the value val to the USER variable var
        &#34;&#34;&#34;
        return self.listUSER  # override listuser

    @property
    def scripts(self):
        &#34;&#34;&#34;
            p.scripts[idx].USER.var returns the value of the USER variable var
            p.scripts[idx].USER.var = val assigns the value val to the USER variable var
        &#34;&#34;&#34;
        return self.listscript # override listuser

    def __add__(self,s):
        &#34;&#34;&#34; overload + as pipe with copy &#34;&#34;&#34;
        from pizza.dscript import dscript
        if isinstance(s,(pipescript,script)):
            dup = deepduplicate(self)
            return dup | s      # + or | are synonyms
        elif isinstance(s,scriptobject):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s,dscript):
            return self + s.pipescript(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        else:
            raise TypeError(f&#34;The operand should be a pipescript/script/dscript/scriptobjectgroup and not &#39;{type(s).__name__}&#39;&#34;)

    def __iadd__(self,s):
        &#34;&#34;&#34; overload += as pipe without copy &#34;&#34;&#34;
        if isinstance(s,pipescript):
            return self | s      # + or | are synonyms
        else:
            raise TypeError(f&#34;The operand should be a pipescript and not &#39;{type(s).__name__}&#39;&#34;)

    def __mul__(self,ntimes):
        &#34;&#34;&#34; overload * as multiple pipes with copy &#34;&#34;&#34;
        if isinstance(self,pipescript):
            res = deepduplicate(self)
            if ntimes&gt;1:
                for n in range(1,ntimes): res += self
            return res
        else:
            raise TypeError(f&#34;The operand should be a pipescript and not &#39;{type(s).__name__}&#39;&#34;)



    def __or__(self, s):
        &#34;&#34;&#34; Overload | pipe operator in pipescript &#34;&#34;&#34;
        leftarg = deepduplicate(self)  # Make a deep copy of the current object
        # Local import only when dscript type needs to be checked
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        # Convert rightarg to pipescript if needed
        if isinstance(s, dscript):
            rightarg = s.pipescript(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the dscript object to a pipescript
            native = False
        elif isinstance(s,script):
            rightarg = pipescript(s,printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s,(scriptobject,scriptobjectgroup)):
            rightarg = pipescript(s,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, group):
            stmp = s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
            rightarg = pipescript(stmp,printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, groupcollection):
            stmp = s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
            rightarg = pipescript(stmp,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, region):
            rightarg = s.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s,pipescript):
            rightarg = s
            native = True
        else:
            raise TypeError(f&#34;The operand should be a pipescript, dscript, script, scriptobject, scriptobjectgroup, group or groupcollection not {type(s)}&#34;)
        # Native piping
        if native:
            leftarg.listscript = leftarg.listscript + rightarg.listscript
            leftarg.listUSER = leftarg.listUSER + rightarg.listUSER
            leftarg.name = leftarg.name + rightarg.name
            for i in range(len(rightarg)):
                rightarg.executed[i] = False
            leftarg.executed = leftarg.executed + rightarg.executed
            return leftarg
        # Piping for non-native objects (dscript or script-like objects)
        else:
            # Loop through all items in rightarg and concatenate them
            for i in range(rightarg.n):
                leftarg.listscript.append(rightarg.listscript[i])
                leftarg.listUSER.append(rightarg.listUSER[i])
                leftarg.name.append(rightarg.name[i])
                leftarg.executed.append(False)
            return leftarg



    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;pipescript containing {self.n} scripts with {self.nrun} executed[*]&#34;


    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        line = &#34;  &#34;+&#34;-&#34;*12+&#34;:&#34;+&#34;-&#34;*40
        if self.verbose:
            print(&#34;&#34;,&#34;Pipeline with %d scripts and&#34; % self.n,
                  &#34;D(STATIC:GLOBAL:LOCAL) DEFINITIONS&#34;,line,sep=&#34;\n&#34;)
        else:
            print(line)
        for i in range(len(self)):
            if self.executed[i]:
                state = &#34;*&#34;
            else:
                state = &#34;-&#34;
            print(&#34;%10s&#34; % (&#34;[%s]  %02d:&#34; % (state,i)),
                  self.name[i],&#34;with D(%2d:%2d:%2d)&#34; % (
                       len(self.listscript[i].DEFINITIONS),
                       len(self.listscript[i].USER),
                       len(self.listUSER[i])                 )
                  )
        if self.verbose:
            print(line,&#34;::: notes :::&#34;,&#34;p[i], p[i:j], p[[i,j]] copy pipeline segments&#34;,
                  &#34;LOCAL: p.USER[i],p.USER[i].variable modify the user space of only p[i]&#34;,
                  &#34;GLOBAL: p.scripts[i].USER.var to modify the user space from p[i] and onwards&#34;,
                  &#34;STATIC: p.scripts[i].DEFINITIONS&#34;,
                  &#39;p.rename(idx=range(2),name=[&#34;A&#34;,&#34;B&#34;]), p.clear(idx=[0,3,4])&#39;,
                  &#34;p.script(), p.script(idx=range(5)), p[0:5].script()&#34;,&#34;&#34;,sep=&#34;\n&#34;)
        else:
             print(line)
        return str(self)

    def __len__(self):
        &#34;&#34;&#34; len() method &#34;&#34;&#34;
        return len(self.listscript)

    @property
    def n(self):
        &#34;&#34;&#34; number of scripts &#34;&#34;&#34;
        return len(self)

    @property
    def nrun(self):
        &#34;&#34;&#34; number of scripts executed continuously from origin &#34;&#34;&#34;
        n, nmax  = 0, len(self)
        while n&lt;nmax and self.executed[n]: n+=1
        return n

    def __getitem__(self,idx):
        &#34;&#34;&#34; return the ith or slice element(s) of the pipe  &#34;&#34;&#34;
        dup = deepduplicate(self)
        if isinstance(idx,slice):
            dup.listscript = dup.listscript[idx]
            dup.listUSER = dup.listUSER[idx]
            dup.name = dup.name[idx]
            dup.executed = dup.executed[idx]
        elif isinstance(idx,int):
            if idx&lt;len(self):
                dup.listscript = dup.listscript[idx:idx+1]
                dup.listUSER = dup.listUSER[idx:idx+1]
                dup.name = dup.name[idx:idx+1]
                dup.executed = dup.executed[idx:idx+1]
            else:
                raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,list):
            dup.listscript = picker(dup.listscript,idx)
            dup.listUSER = picker(dup.listUSER,idx)
            dup.name = picker(dup.name,idx)
            dup.executed = picker(dup.executed,idx)
        else:
            raise IndexError(&#34;the index needs to be a slice or an integer&#34;)
        return dup

    def __setitem__(self,idx,s):
        &#34;&#34;&#34;
            modify the ith element of the pipe
                p[4] = [] removes the 4th element
                p[4:7] = [] removes the elements from position 4 to 6
                p[2:4] = p[0:2] copy the elements 0 and 1 in positions 2 and 3
                p[[3,4]]=p[0]
        &#34;&#34;&#34;
        if isinstance(s,(script,scriptobject,scriptobjectgroup)):
            dup = pipescript(s)
        elif isinstance(s,pipescript):
            dup = s
        elif s==[]:
            dup = []
        else:
            raise ValueError(&#34;the value must be a pipescript, script, scriptobject, scriptobjectgroup&#34;)
        if len(s)&lt;1: # remove (delete)
            if isinstance(idx,slice) or idx&lt;len(self):
                del self.listscript[idx]
                del self.listUSER[idx]
                del self.name[idx]
                del self.executed[idx]
            else:
                raise IndexError(&#34;the index must be a slice or an integer&#34;)
        elif len(s)==1: # scalar
            if isinstance(idx,int):
                if idx&lt;len(self):
                    self.listscript[idx] = dup.listscript[0]
                    self.listUSER[idx] = dup.listUSER[0]
                    self.name[idx] = dup.name[0]
                    self.executed[idx] = False
                elif idx==len(self):
                    self.listscript.append(dup.listscript[0])
                    self.listUSER.append(dup.listUSER[0])
                    self.name.append(dup.name[0])
                    self.executed.append(False)
                else:
                    raise IndexError(f&#34;the index must be ranged between 0 and {self.n}&#34;)
            elif isinstance(idx,list):
                for i in range(len(idx)):
                    self.__setitem__(idx[i], s) # call as a scalar
            elif isinstance(idx,slice):
                for i in range(*idx.indices(len(self)+1)):
                    self.__setitem__(i, s)
            else:
                raise IndexError(&#34;unrocognized index value, the index should be an integer or a slice&#34;)
        else: # many values
            if isinstance(idx,list): # list call à la Matlab
                if len(idx)==len(s):
                    for i in range(len(s)):
                        self.__setitem__(idx[i], s[i]) # call as a scalar
                else:
                    raise IndexError(f&#34;the number of indices {len(list)} does not match the number of values {len(s)}&#34;)
            elif isinstance(idx,slice):
                ilist = list(range(*idx.indices(len(self)+len(s))))
                self.__setitem__(ilist, s) # call as a list
            else:
                raise IndexError(&#34;unrocognized index value, the index should be an integer or a slice&#34;)

    def rename(self,name=&#34;&#34;,idx=None):
        &#34;&#34;&#34;
            rename scripts in the pipe
                p.rename(idx=[0,2,3],name=[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;])
        &#34;&#34;&#34;
        if isinstance(name,list):
            if len(name)==len(self) and idx==None:
                self.name = name
            elif len(name) == len(idx):
                for i in range(len(idx)):
                    self.rename(name[i],idx[i])
            else:
                IndexError(f&#34;the number of indices {len(idx)} does not match the number of names {len(name)}&#34;)
        elif idx !=None and idx&lt;len(self) and name!=&#34;&#34;:
            self.name[idx] = name
        else:
            raise ValueError(&#34;provide a non empty name and valid index&#34;)

    def clear(self,idx=None):
        if len(self)&gt;0:
            if idx==None:
                for i in range(len(self)):
                    self.clear(i)
            else:
                if isinstance(idx,(range,list)):
                    for i in idx:
                        self.clear(idx=i)
                elif isinstance(idx,int) and idx&lt;len(self):
                    self.executed[idx] = False
                else:
                    raise IndexError(f&#34;the index should be ranged between 0 and {self.n-1}&#34;)
            if not self.executed[0]:
                self.globalscript = None
                self.cmd = &#34;&#34;



    def do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        &#34;&#34;&#34;
        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        Parameters:
            idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
            printflag (bool, optional): Whether to print the script for each step. Default is True.
            verbosity (int, optional): Level of verbosity for the output.
            verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
            forced (bool, optional): If True, forces the pipeline to regenerate all scripts.

        Returns:
            str: Combined LAMMPS script for the specified pipeline steps.

            Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

            This method processes the pipeline of script objects, executing each step to generate
            a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
            or for a specified range of indices. The generated script can include comments and
            metadata based on the verbosity level.


        Method Workflow:
            - The method first checks if there are any script objects in the pipeline.
              If the pipeline is empty, it returns a message indicating that there is nothing to execute.
            - It determines the start and stop indices for the range of steps to execute.
              If idx is not provided, it defaults to executing all steps from the last executed position.
            - If a specific index or list of indices is provided, it executes only those steps.
            - The pipeline steps are executed in order, combining the scripts using the
              &gt;&gt; operator for sequential execution.
            - The generated script includes comments indicating the current run step and pipeline range,
              based on the specified verbosity level.
            - The final combined script is returned as a string.

        Example Usage:
        --------------
            &gt;&gt;&gt; p = pipescript()
            &gt;&gt;&gt; # Execute the entire pipeline
            &gt;&gt;&gt; full_script = p.do()
            &gt;&gt;&gt; # Execute steps 0 and 2 only
            &gt;&gt;&gt; partial_script = p.do([0, 2])
            &gt;&gt;&gt; # Execute step 1 with minimal verbosity
            &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

            Notes:
            - The method uses modular arithmetic to handle index wrapping, allowing
              for cyclic execution of pipeline steps.
            - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
            - The globalscript is initialized or updated with each step&#39;s script,
              and the USER definitions are accumulated across the steps.
            - The command string self.cmd is updated with the generated script for
              each step in the specified range.

            Raises:
            - None: The method does not raise exceptions directly, but an empty pipeline will
                    result in the return of &#34;# empty pipe - nothing to do&#34;.
        &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        if len(self) == 0:
            return &#34;# empty pipe - nothing to do&#34;

        # Check if not all steps are executed or if there are gaps
        not_all_executed = not all(self.executed[:self.nrun])  # Check up to the last executed step

        # Determine pipeline range
        total_steps = len(self)
        if self.globalscript is None or forced or not_all_executed:
            start = 0
            self.cmd = &#34;&#34;
        else:
            start = self.nrun
            self.cmd = self.cmd.rstrip(&#34;\n&#34;) + &#34;\n\n&#34;

        if idx is None:
            idx = range(start, total_steps)
        if isinstance(idx, int):
            idx = [idx]
        if isinstance(idx, range):
            idx = list(idx)

        idx = [i % total_steps for i in idx]
        start, stop = min(idx), max(idx)

        # Prevent re-executing already completed steps
        if not forced:
            idx = [step for step in idx if not self.executed[step]]

        # Execute pipeline steps
        for step in idx:
            step_wrapped = step % total_steps

            # Combine scripts
            if step_wrapped == 0:
                self.globalscript = self.listscript[step_wrapped]
            else:
                self.globalscript = self.globalscript &gt;&gt; self.listscript[step_wrapped]

            # Step label
            step_name = f&#34;&lt;{self.name[step]}&gt;&#34;
            step_label = f&#34;# [{step+1} of {total_steps} from {start}:{stop}] {step_name}&#34;

            # Get script content for the step
            step_output = self.globalscript.do(printflag=printflag, verbose=verbosity &gt; 1)

            # Add comments and content
            if step_output.strip():
                self.cmd += f&#34;{step_label}\n{step_output.strip()}\n\n&#34;
            elif verbosity &gt; 0:
                self.cmd += f&#34;{step_label} :: no content\n\n&#34;

            # Update USER definitions
            self.globalscript.USER += self.listUSER[step]
            self.executed[step] = True

        # Clean up and finalize script
        self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;).strip()  # Remove literal \\n and extra spaces
        self.cmd += &#34;\n&#34;  # Ensure trailing newline
        return remove_comments(self.cmd) if verbosity == 0 else self.cmd


    def do_legacy(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        &#34;&#34;&#34;
        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        This method processes the pipeline of script objects, executing each step to generate
        a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
        or for a specified range of indices. The generated script can include comments and
        metadata based on the verbosity level.

        Parameters:
        - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                               If None, all steps from the current position to
                                               the end are executed. A list of indices can be
                                               provided to execute specific steps, or a single
                                               integer can be passed to execute a specific step.
                                               Default is None.
        - printflag (bool, optional): If True, the generated script for each step is printed
                                      to the console. Default is True.
        - verbosity (int, optional): Controls the level of detail in the generated script.
                                     - 0: Minimal output, no comments.
                                     - 1: Basic comments for run steps.
                                     - 2: Detailed comments with additional information.
                                     Default is 2.
        - forced (bool, optional): If True, all scripts are regenerated

        Returns:
        - str: The combined LAMMPS script generated from the specified steps of the pipeline.

        Method Workflow:
        - The method first checks if there are any script objects in the pipeline.
          If the pipeline is empty, it returns a message indicating that there is nothing to execute.
        - It determines the start and stop indices for the range of steps to execute.
          If idx is not provided, it defaults to executing all steps from the last executed position.
        - If a specific index or list of indices is provided, it executes only those steps.
        - The pipeline steps are executed in order, combining the scripts using the
          &gt;&gt; operator for sequential execution.
        - The generated script includes comments indicating the current run step and pipeline range,
          based on the specified verbosity level.
        - The final combined script is returned as a string.

        Example Usage:
        --------------
        &gt;&gt;&gt; p = pipescript()
        &gt;&gt;&gt; # Execute the entire pipeline
        &gt;&gt;&gt; full_script = p.do()
        &gt;&gt;&gt; # Execute steps 0 and 2 only
        &gt;&gt;&gt; partial_script = p.do([0, 2])
        &gt;&gt;&gt; # Execute step 1 with minimal verbosity
        &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

        Notes:
        - The method uses modular arithmetic to handle index wrapping, allowing
          for cyclic execution of pipeline steps.
        - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
        - The globalscript is initialized or updated with each step&#39;s script,
          and the USER definitions are accumulated across the steps.
        - The command string self.cmd is updated with the generated script for
          each step in the specified range.

        Raises:
        - None: The method does not raise exceptions directly, but an empty pipeline will
                result in the return of &#34;# empty pipe - nothing to do&#34;.
        &#34;&#34;&#34;

        verbosity = 0 if verbose is False else verbosity
        if len(self)&gt;0:
            # ranges
            ntot = len(self)
            stop = ntot-1
            if (self.globalscript == None) or (self.globalscript == []) or not self.executed[0] or forced:
                start = 0
                self.cmd = &#34;&#34;
            else:
                start = self.nrun
            if start&gt;stop: return self.cmd
            if idx is None: idx = range(start,stop+1)
            if isinstance(idx,range): idx = list(idx)
            if isinstance(idx,int): idx = [idx]
            start,stop = min(idx),max(idx)
            # do
            for i in idx:
                j = i % ntot
                if j==0:
                    self.globalscript = self.listscript[j]
                else:
                    self.globalscript = self.globalscript &gt;&gt; self.listscript[j]
                name = &#34;  &#34;+self.name[i]+&#34;  &#34;
                if verbosity&gt;0:
                    self.cmd += &#34;\n\n#\t --- run step [%d/%d] --- [%s]  %20s\n&#34; % \
                            (j,ntot-1,name.center(50,&#34;=&#34;),&#34;pipeline [%d]--&gt;[%d]&#34; %(start,stop))
                else:
                    self.cmd +=&#34;\n&#34;
                self.globalscript.USER = self.globalscript.USER + self.listUSER[j]
                self.cmd += self.globalscript.do(printflag=printflag,verbose=verbosity&gt;1)
                self.executed[i] = True
            self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;) # remove literal \\n if any (dscript.save add \\n)
            return remove_comments(self.cmd) if verbosity==0 else self.cmd
        else:
            return &#34;# empty pipe - nothing to do&#34;


    def script(self,idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4):
        &#34;&#34;&#34;
            script the pipeline or parts of the pipeline
                s = p.script()
                s = p.script([0,2])

        Parameters:
        - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                               If None, all steps from the current position to
                                               the end are executed. A list of indices can be
                                               provided to execute specific steps, or a single
                                               integer can be passed to execute a specific step.
                                               Default is None.
        - printflag (bool, optional): If True, the generated script for each step is printed
                                      to the console. Default is True.
        - verbosity (int, optional): Controls the level of detail in the generated script.
                                     - 0: Minimal output, no comments.
                                     - 1: Basic comments for run steps.
                                     - 2: Detailed comments with additional information.
                                     Default is 2.
        - forced (bool, optional): If True, all scripts are regenerated
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with `╔`, `═`, and `║`
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with `┌`, `─`, and `│`
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `4` (thick outer frame).

        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity=0 if verbose is False else verbosity
        s = script(printflag=printflag, verbose=verbosity&gt;0)
        s.name = &#34;pipescript&#34;
        s.description = &#34;pipeline with %d scripts&#34; % len(self)
        if len(self)&gt;1:
            s.userid = self.name[0]+&#34;-&gt;&#34;+self.name[-1]
        elif len(self)==1:
            s.userid = self.name[0]
        else:
            s.userid = &#34;empty pipeline&#34;
        s.TEMPLATE = self.header(verbosity=verbosity, style=style) + &#34;\n&#34; +\
            self.do(idx, printflag=printflag, verbosity=verbosity, verbose=verbose, forced=forced)
        s.DEFINITIONS = duplicate(self.globalscript.DEFINITIONS)
        s.USER = duplicate(self.globalscript.USER)
        return s

    @staticmethod
    def join(liste):
        &#34;&#34;&#34;
            join a combination scripts and pipescripts within a pipescript
                p = pipescript.join([s1,s2,p3,p4,p5...])
        &#34;&#34;&#34;
        if not isinstance(liste,list):
            raise ValueError(&#34;the argument should be a list&#34;)
        ok = True
        for i in range(len(liste)):
            ok = ok and isinstance(liste[i],(script,pipescript))
            if not ok:
                raise ValueError(f&#34;the entry [{i}] should be a script or pipescript&#34;)
        if len(liste)&lt;1:
            return liste
        out = liste[0]
        for i in range(1,len(liste)):
            out = out | liste[i]
        return out

    # Note that it was not the original intent to copy pipescripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo))
        return copie

    # write file
    def write(self, file, printflag=False, verbosity=2, verbose=None, overwrite=False):
       &#34;&#34;&#34;
       Write the combined script to a file.

       Parameters:
           file (str): The file path where the script will be saved.
           printflag (bool): Flag to enable/disable printing of details.
           verbosity (int): Level of verbosity for the script generation.
           verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance&#39;s verbosity.
           overwrite (bool): Whether to overwrite the file if it already exists. Default is False.

        Returns:
            str: The full absolute path of the file written.

       Raises:
           FileExistsError: If the file already exists and overwrite is False.

       Notes:
           - This method combines the individual scripts within the `pipescript` object
             and saves the resulting script to the specified file.
           - If `overwrite` is False and the file exists, an error is raised.
           - If `verbose` is True and the file is overwritten, a warning is displayed.
       &#34;&#34;&#34;
       # Generate the combined script
       myscript = self.script(printflag=printflag, verbosity=verbosity, verbose=verbose, forced=True)
       # Call the script&#39;s write method with the overwrite parameter
       return myscript.write(file, printflag=printflag, verbose=verbose, overwrite=overwrite)


    def dscript(self, name=None, printflag=None, verbose=None, verbosity=None, clean=&#34;fixing&#34;, **USER):
        &#34;&#34;&#34;
        Convert the current pipescript object to a dscript object.

        This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
        in the pipescript into a single dynamic script per step in the dscript.
        Each step in the pipescript is transformed into a dynamic script in the dscript,
        where variable spaces are combined using the following order:

        1. STATIC: Definitions specific to each script in the pipescript.
        2. GLOBAL: User variables shared across steps from a specific point onwards.
        3. LOCAL: User variables for each individual step.

        Parameters:
        -----------
        verbose : bool, optional
            Controls verbosity of the dynamic scripts in the resulting dscript object.
            If None, the verbosity setting of the pipescript will be used.

        clean : &#34;fixing&#34; or &#34;removing&#34;
            - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
            - &#39;fixing&#39;: Replace the content of the empty step with a comment.

        **USER : scriptobjectdata(), optional
            Additional user-defined variables that can override existing static variables
            in the dscript object or be added to it.

        Returns:
        --------
        outd : dscript
            A dscript object that contains all steps of the pipescript as dynamic scripts.
            Each step from the pipescript is added as a dynamic script with the same content
            and combined variable spaces.
        &#34;&#34;&#34;
        # Local imports
        from pizza.dscript import dscript, ScriptTemplate, lambdaScriptdata

        # verbosity
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity

        # Adjust name
        if name is None:
            if isinstance(self.name, str):
                name = self.name
            elif isinstance(self.name, list):
                name = (
                    self.name[0] if len(self.name) == 1 else self.name[0] + &#34;...&#34; + self.name[-1]
                )

        # Create the dscript container with the pipescript name as the userid
        outd = dscript(userid=name, verbose=self.verbose, **USER)

        # Initialize static merged definitions
        staticmerged_definitions = lambdaScriptdata()

        # Track used variables per step
        step_used_variables = []

        # Loop over each step in the pipescript
        for i, script in enumerate(self.listscript):
            # Merge STATIC, GLOBAL, and LOCAL variables for the current step
            static_vars = self.listUSER[i] # script.DEFINITIONS
            global_vars = script.DEFINITIONS # self.scripts[i].USER
            local_vars = script.USER # self.USER[i]
            refreshed_globalvars = static_vars + global_vars

            # Detect variables used in the current template
            used_variables = set(script.detect_variables())
            step_used_variables.append(used_variables)  # Track used variables for this step

            # Copy all current variables to local_static_updates and remove matching variables from staticmerged_definitions
            local_static_updates = lambdaScriptdata(**local_vars)

            for var, value in refreshed_globalvars.items():
                if var in staticmerged_definitions:
                    if (getattr(staticmerged_definitions, var) != value) and (var not in local_vars):
                        setattr(local_static_updates, var, value)
                else:
                    setattr(staticmerged_definitions, var, value)

           # Create the dynamic script for this step using the method in dscript
            key_name = i  # Use the index &#39;i&#39; as the key in TEMPLATE
            content = script.TEMPLATE

            # Use the helper method in dscript to add this dynamic script
            outd.add_dynamic_script(
                key=key_name,
                content=content,
                definitions = lambdaScriptdata(**local_static_updates),
                verbose=self.verbose if verbose is None else verbose,
                userid=self.name[i],
                autorefresh=False # prevent the replacement by default values ${}
            )

            # Set eval=True only if variables are detected in the template
            if outd.TEMPLATE[key_name].detect_variables():
                outd.TEMPLATE[key_name].eval = True

        # Compute the union of all used variables across all steps
        global_used_variables = set().union(*step_used_variables)

        # Filter staticmerged_definitions to keep only variables that are used
        filtered_definitions = {
            var: value for var, value in staticmerged_definitions.items() if var in global_used_variables
        }

        # Assign the filtered definitions along with USER variables to outd.DEFINITIONS
        outd.DEFINITIONS = lambdaScriptdata(**filtered_definitions)

        # Clean the entries for empty templates
        outd.clean(verbose=verbose,behavior=clean)

        return outd



    def header(self, verbose=True,verbosity=None, style=4):
        &#34;&#34;&#34;
        Generate a formatted header for the pipescript file.

        Parameters:
            verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                        Defaults to the instance&#39;s `verbose`.
            style (int from 1 to 6, optional): ASCII style to frame the header (default=4)

        Returns:
            str: A formatted string representing the pipescript object.
                 Returns an empty string if verbosity is False.

        The header includes:
            - Total number of scripts in the pipeline.
            - The verbosity setting.
            - The range of scripts from the first to the last script.
            - All enclosed within an ASCII frame that adjusts to the content.
        &#34;&#34;&#34;
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        if not verbosity:
            return &#34;&#34;

        # Prepare the header content
        lines = [
            f&#34;PIPESCRIPT with {self.n} scripts | Verbosity: {verbosity}&#34;,
            &#34;&#34;,
            f&#34;From: &lt;{str(self.scripts[0])}&gt; To: &lt;{str(self.scripts[-1])}&gt;&#34;,
        ]

        # Use the shared method to format the header
        return frame_header(lines,style=style)



    def list_values(self, varname=None, what=&#34;all&#34;):
        &#34;&#34;&#34;
        Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.

        Parameters:
        - varname (str, optional): The name of the variable to search for. If None, all variables are listed.
        - what (str or list/tuple, optional): Specifies the scopes to search in.
                                             Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                             or a list/tuple of any combination of these.

        Returns:
        - VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
        - dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.
        &#34;&#34;&#34;
        # Normalize &#39;what&#39; to a list for uniform processing
        if isinstance(what, str):
            if what.lower() == &#34;all&#34;:
                scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
            else:
                scopes = [what.lower()]
        elif isinstance(what, (list, tuple)):
            scopes_lower = [s.lower() for s in what]
            if &#39;all&#39; in scopes_lower:
                scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
            else:
                scopes = scopes_lower
        else:
            raise ValueError(&#34;Parameter &#39;what&#39; must be a string or a list/tuple of strings.&#34;)

        # Initialize data structures
        if varname:
            # Single variable case
            if len(scopes) == 1:
                data = []
            else:
                data = {}
                for scope in scopes:
                    data[scope] = []

            # Iterate over each script in the pipeline
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                # Check each requested scope
                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    if varname in vars_dict.keys():
                        value = getattr(vars_dict,varname)
                        if len(scopes) == 1:
                            data.append((i, value))
                        else:
                            data[scope].append((i, value))

            # Return a VariableOccurrences instance for the specified variable
            return VariableOccurrences(data, variables=varname)

        else:
            # All variables case
            all_vars = set()

            # First, collect all variable names across specified scopes and scripts
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    all_vars.update(vars_dict.keys())

            # Initialize a dictionary to hold VariableOccurrences for each variable
            variables_data = {}
            for var in all_vars:
                var_data = {}
                for scope in scopes:
                    var_data[scope] = []
                variables_data[var] = var_data

            # Iterate again to populate the data for each variable
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    for var, value in vars_dict.items():
                        variables_data[var][scope].append((i, value))

            # Convert each variable&#39;s data into a VariableOccurrences instance
            variables_occurrences = {}
            for var, data in variables_data.items():
                variables_occurrences[var] = VariableOccurrences(data, variables=var)

            return variables_occurrences



    def list_multiple_values(self, varnames, what=&#34;all&#34;):
        &#34;&#34;&#34;
        Lists all occurrences and values of multiple variables across the pipeline scripts.

        Parameters:
        - varnames (list): A list of variable names to search for.
        - what (str or list/tuple): Specifies the scopes to search in.
                                     Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                     or a list/tuple of any combination of these.

        Returns:
        - dict: A dictionary mapping each variable name to its VariableOccurrences object.
        &#34;&#34;&#34;
        if not isinstance(varnames, (list, tuple)):
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

        return self.list_values(varname=varnames, what=what)



    def plot_multiple_value_distributions(self, varnames, what=&#34;all&#34;, separate_plots=True):
        &#34;&#34;&#34;
        Plots the distribution of elements for multiple variables across specified scopes.

        Parameters:
        - varnames (list): A list of variable names to plot.
        - what (str or list/tuple): Specifies the scopes to include in the plot.
                                     Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                     or a list/tuple of any combination of these.
        - separate_plots (bool): If True, plots each variable in a separate subplot.
                                 If False, combines all variables in a single plot for comparison.
        &#34;&#34;&#34;
        if not isinstance(varnames, (list, tuple)):
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

        # Retrieve VariableOccurrences instances
        multiple_vars = self.list_multiple_values(varnames, what=what)

        if separate_plots:
            num_vars = len(multiple_vars)
            fig, axes = plt.subplots(num_vars, 1, figsize=(10, 5 * num_vars))
            if num_vars == 1:
                axes = [axes]  # Make it iterable

            for ax, (var, vo) in zip(axes, multiple_vars.items()):
                summary = vo.summarize()[var]
                for scope, details in summary.items():
                    elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                    counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                    ax.bar(elements, counts, label=scope)
                ax.set_xlabel(&#39;Element&#39;)
                ax.set_ylabel(&#39;Count&#39;)
                ax.set_title(f&#34;Distribution of elements in &#39;{var}&#39;&#34;)
                ax.legend()

            plt.tight_layout()
            plt.show()

        else:
            plt.figure(figsize=(12, 8))
            for var, vo in multiple_vars.items():
                summary = vo.summarize()[var]
                for scope, details in summary.items():
                    elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                    counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                    plt.bar([f&#34;{var}_{elem}&#34; for elem in elements], counts, label=f&#34;{var} - {scope}&#34;)

            plt.xlabel(&#39;Element&#39;)
            plt.ylabel(&#39;Count&#39;)
            plt.title(&#34;Distribution of elements in multiple variables&#34;)
            plt.legend()
            plt.xticks(rotation=45, ha=&#39;right&#39;)
            plt.tight_layout()
            plt.show()


    def generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
        &#34;&#34;&#34;
        Generates a comprehensive report for specified variables and writes it to a file.

        Parameters:
        - filename (str): Path to the output report file. Must end with .md, .txt, or .html.
        - varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to &#39;all&#39;.
        - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.

        Raises:
        - ValueError: If &#39;filename&#39; has an unsupported extension.
        - Exception: For other unforeseen errors.
        &#34;&#34;&#34;
        # Validate filename extension
        _, ext = os.path.splitext(filename)
        ext = ext.lower()

        if ext not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;]:
            raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

        # Determine format based on extension
        if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
            export_format = &#39;markdown&#39;
        elif ext == &#39;.html&#39;:
            export_format = &#39;html&#39;

        # Determine variables to include
        if varnames is None or (isinstance(varnames, (list, tuple)) and len(varnames) == 0):
            variables = &#39;all&#39;
        else:
            variables = varnames  # Can be a string or a list/tuple

        # Retrieve VariableOccurrences instances
        if variables == &#39;all&#39;:
            variables_occurrences = self.list_values(varname=None, what=scopes)
        else:
            # Normalize varnames to a list
            if isinstance(variables, str):
                variables = [variables]
            elif isinstance(variables, (list, tuple)):
                variables = list(variables)
            else:
                raise ValueError(&#34;Parameter &#39;varnames&#39; must be a string or a list/tuple of strings.&#34;)

            variables_occurrences = {}
            for var in variables:
                vo = self.list_values(varname=var, what=scopes)
                if vo and var in vo.variables:
                    variables_occurrences[var] = vo
                else:
                    print(f&#34;Warning: Variable &#39;{var}&#39; not found in the specified scopes.&#34;)

        # Initialize report content
        report_content = &#34;&#34;
        timestamp = datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        caller = &#34;generate_report&#34;

        # Add report header
        if export_format == &#39;markdown&#39;:
            report_content += f&#34;# Comprehensive Variable Report\n\n&#34;
            report_content += f&#34;**Generated on {timestamp} by {caller}**\n\n&#34;
        elif export_format == &#39;html&#39;:
            # Define CSS for HTML
            css = &#34;&#34;&#34;
            &lt;style&gt;
                body {
                    font-family: Arial, sans-serif;
                    margin: 20px;
                }
                h1, h2, h3, h4, h5 {
                    color: #333;
                }
                table {
                    border-collapse: collapse;
                    width: 100%;
                    margin-bottom: 40px;
                }
                th, td {
                    border: 1px solid #ddd;
                    padding: 8px;
                    text-align: left;
                }
                th {
                    background-color: #4CAF50;
                    color: white;
                }
                tr:nth-child(even){background-color: #f2f2f2;}
                tr:hover {background-color: #ddd;}
            &lt;/style&gt;
            &#34;&#34;&#34;
            report_content += f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Comprehensive Variable Report&lt;/title&gt;\n{css}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;
            report_content += f&#34;&lt;h1&gt;Comprehensive Variable Report&lt;/h1&gt;\n&#34;
            report_content += f&#34;&lt;h2&gt;Generated on {timestamp} by {caller}&lt;/h2&gt;\n&#34;

        # Assemble report content using VariableOccurrences.export()
        for var, vo in variables_occurrences.items():
            # Export content without headers and get as string
            var_content = vo.export(filename=filename, # use to identify the format based on its extension
                                    scopes=scopes,
                                    variables=var,
                                    include_headers=False,
                                    return_content=True)

            if export_format == &#39;markdown&#39;:
                # Add variable header
                report_content += f&#34;## Variable: `{var}`\n\n&#34;
                report_content += var_content + &#34;\n\n&#34;
                report_content += &#34;---\n\n&#34;  # Horizontal line between variables
            elif export_format == &#39;html&#39;:
                # Add variable header
                report_content += f&#34;&lt;h2&gt;Variable: {var}&lt;/h2&gt;\n&#34;
                report_content += var_content + &#34;\n&lt;hr/&gt;\n&#34;  # Horizontal line between variables

        # Finalize HTML content
        if export_format == &#39;html&#39;:
            report_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

        # Write report to file
        try:
            with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                file.write(report_content)
            print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
        except Exception as e:
            raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)



# %% Child classes of script sessions (to be derived)
# navigate with the outline tab through the different classes
#   globalsection()
#   initializesection()
#   geometrysection()
#   discretizationsection()
#   interactionsection()
#   integrationsection()
#   dumpsection()
#   statussection()
#   runsection()

# %% Global section template
class globalsection(script):
    &#34;&#34;&#34; LAMMPS script: global session &#34;&#34;&#34;
    name = &#34;global&#34;
    description = name+&#34; section&#34;
    position = 0
    section = 1
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = scriptdata(
  outputfile= &#34;$dump.mouthfeel_v5_long    # from the project of the same name&#34;,
        tsim= &#34;500000                     # may be too long&#34;,
     outstep= 10
        )

    MATERIALS = scriptdata(
         rho_saliva= &#34;1000 # mass density saliva&#34;,
            rho_obj= &#34;1300 # mass density solid objects&#34;,
                 c0= &#34;10.0 # speed of sound for saliva&#34;,
                  E= &#34;5*${c0}*${c0}*${rho_saliva} # Young&#39;s modulus for solid objects&#34;,
           Etongue1= &#34;10*${E} # Young&#39;s modulus for tongue&#34;,
           Etongue2= &#34;2*${Etongue1} # Young&#39;s modulus for tongue&#34;,
                 nu= &#34;0.3 # Poisson ratio for solid objects&#34;,
        sigma_yield= &#34;0.1*${E} # plastic yield stress for solid objects&#34;,
     hardening_food= &#34;0 # plastic hardening parameter for solid food&#34;,
   hardening_tongue= &#34;1 # plastic hardening parameter for solid tongue&#34;,
  contact_stiffness= &#34;2.5*${c0}^2*${rho_saliva} # contact force amplitude&#34;,
       contact_wall= &#34;100*${contact_stiffness} # contact with wall (avoid interpenetration)&#34;,
                 q1= &#34;1.0 # artificial viscosity&#34;,
                 q2= &#34;0.0 # artificial viscosity&#34;,
                 Hg= &#34;10 # Hourglass control coefficient for solid objects&#34;,
                 Cp= &#34;1.0 # heat capacity -- not used here&#34;
                  )

    DEFINITIONS += MATERIALS # append MATERIALS data

    TEMPLATE = &#34;&#34;&#34;
# :GLOBAL SECTION:
#   avoid to set variables in LAMMPS script
#   use DEFINITIONS field to set properties.
#   If you need to define them, use the following syntax


    # ####################################################################################################
    # # GLOBAL
    # ####################################################################################################
     variable outputfile string &#34;${outputfile}&#34;
     variable tsim equal ${tsim}
     variable outstep equal ${outstep}

    # ####################################################################################################
    # # MATERIAL PARAMETERS
    # ####################################################################################################
    # variable        rho_saliva equal 1000 # mass density saliva
    # variable        rho_obj equal 1300 # mass density solid objects
    # variable        c0 equal 10.0 # speed of sound for saliva
    # variable        E equal 5*${c0}*${c0}*${rho_saliva} # Young&#39;s modulus for solid objects
    # variable        Etongue1 equal 10*${E} # Young&#39;s modulus for tongue
    # variable        Etongue2 equal 2*${Etongue1} # Young&#39;s modulus for tongue
    # variable        nu equal 0.3 # Poisson ratio for solid objects
    # variable        sigma_yield equal 0.1*${E} # plastic yield stress for solid objects
    # variable        hardening_food equal 0 # plastic hardening parameter for solid food
    # variable        hardening_tongue equal 1 # plastic hardening parameter for solid tongue
    # variable        contact_stiffness equal 2.5*${c0}^2*${rho_saliva} # contact force amplitude
    # variable        contact_wall equal 100*${contact_stiffness} # contact with wall (avoid interpenetration)
    # variable        q1 equal 1.0 # artificial viscosity
    # variable        q2 equal 0.0 # artificial viscosity
    # variable        Hg equal 10 # Hourglass control coefficient for solid objects
    # variable        Cp equal 1.0 # heat capacity -- not used here
    &#34;&#34;&#34;

# %% Initialize section template
class initializesection(script):
    &#34;&#34;&#34; LAMMPS script: global session &#34;&#34;&#34;
    name = &#34;initialize&#34;
    description = name+&#34; section&#34;
    position = 1
    section = 2
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = scriptdata(
               units= &#34;$ si&#34;,
           dimension= 2,
            boundary= &#34;$ sm sm p&#34;,
          atom_style= &#34;$smd&#34;,
  neigh_modify_every= 5,
  neigh_modify_delay= 0,
         comm_modify= &#34;$ vel yes&#34;,
              newton= &#34;$ off&#34;,
         atom_modify= &#34;$ map array&#34;,
          comm_style= &#34;$ tiled&#34;
        )

    TEMPLATE = &#34;&#34;&#34;
# :INITIALIZE SECTION:
#   initialize styles, dimensions, boundaries and communivation

    ####################################################################################################
    # INITIALIZE LAMMPS
    ####################################################################################################
    units           ${units}
    dimension       ${dimension}
    boundary        ${boundary}
    atom_style      ${atom_style}
    neigh_modify    every ${neigh_modify_every} delay ${neigh_modify_delay} check yes
    comm_modify     ${comm_modify}
    newton          ${newton}
    atom_modify     ${atom_modify}
    comm_style      ${comm_style}
    &#34;&#34;&#34;

# %% Geometry section template
class geometrysection(script):
    &#34;&#34;&#34; LAMMPS script: global session &#34;&#34;&#34;
    name = &#34;geometry&#34;
    description = name+&#34; section&#34;
    position = 2
    section = 3
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = scriptdata(
         l0= 0.05,
       hgap= &#34;0.25        # gap to prevent direct contact at t=0 (too much enery)&#34;,
  hsmallgap= &#34;0.1   # gap to prevent direct contact at t=0 (too much enery)&#34;,
       hto1= &#34;0.8         # height of to1 (the tongue to1, note 1 not l)&#34;,
       hto2= &#34;0.5         # height of to2 (the tongue to2)&#34;,
       rsph= &#34;0.3         # radius of spherical food particles&#34;,
       lpar= &#34;0.6         # size of prismatic particles &#34;,
    yfloor1= &#34;${hgap}  # bottom position of to1, position of the first floor&#34;,
     yroof1= &#34;${yfloor1}+${hto1} # bottom position of to1, position of the first floor&#34;,
   yfloor2a= &#34;${yroof1}+${hsmallgap}  # position of the second floor / level a&#34;,
    yroof2a= &#34;${yfloor2a}+${lpar}      # position of the second floor / level a&#34;,
   yfloor2b= &#34;${yroof2a}+${hsmallgap} # position of the second floor / level b&#34;,
    yroof2b= &#34;${yfloor2b}+${lpar}      # position of the second floor / level b&#34;,
   yfloor2c= &#34;${yfloor2a}+${rsph}     # position of the second floor / level c&#34;,
    yroof2c= &#34;${yfloor2c}+${rsph}      # position of the second floor / level c&#34;,
   yfloor2d= &#34;${yroof2c}+${rsph}+${hsmallgap} # position of the second floor / level d&#34;,
    yroof2d= &#34;${yfloor2d}+${rsph}      # position of the second floor / level d&#34;,
    yfloor3= 5.0,
     yroof3= &#34;${yfloor3}+${hto2} # bottom position of to1&#34;,
   yfloor3a= &#34;${yfloor3}-0.6&#34;,
    yroof3a= &#34;${yfloor3}&#34;,
    crunchl= &#34;${yfloor3}-${yfloor2a}-0.8&#34;,
    crunchp= 3,
    crunchw= &#34;2*pi/${crunchp}&#34;,
    crunchd= &#34;2*(sin((${crunchp}*${crunchw})/4)^2)/${crunchw}&#34;,
    crunchv= &#34;${crunchl}/${crunchd}&#34;
        )

    TEMPLATE = &#34;&#34;&#34;
# :GEOMETRY SECTION:
#   Build geometry (very specific example)

    ####################################################################################################
    # CREATE INITIAL GEOMETRY
    # note there are 4 groups (create_box 5 box)
    # groupID 1 = saliva
    # groupID 2 = food
    # groupID 3 = mouth walls
    # groupID 4 = tongue alike (part1)
    # groupID 5 = also tongue but palate infact (part2)
    ####################################################################################################
    # create simulation box, a mouth, and a saliva column
    region          box block 0 12 0 8 -0.01 0.01 units box
    create_box      5 box
    region          saliva1 block 0.25 1.8 1.25 3.5 EDGE EDGE units box
    region          saliva2 block 10 11.65 1.25 4 EDGE EDGE units box
    region          mouth block 0.15 11.85 0.15 8 -0.01 0.01 units box side out # mouth
    lattice         sq ${l0}
    create_atoms    1 region saliva1
    create_atoms    1 region saliva2
    group           saliva type 1
    create_atoms    3 region mouth
    group           mouth type 3

    print &#34;Crunch distance:${crunchl}&#34;  # 3.65
    print &#34;Crunch distance:${crunchv}&#34;  # 0.1147


    # bottom part of the tongue: to1 (real tongue)
    # warning: all displacements are relative to the bottom part
    region          to1 block 1 11 ${yfloor1} ${yroof1} EDGE EDGE units box
    region          to2part1 block 0.5 11.5 ${yfloor3} ${yroof3} EDGE EDGE units box
    region          to2part2 block 5.5 6 ${yfloor3a} ${yroof3a} EDGE EDGE units box
    region          to2 union 2 to2part1 to2part2
    create_atoms    4 region to1
    create_atoms    5 region to2
    group           tongue1 type 4
    group           tongue2 type 5

    # create some solid objects to be pushed around
    region          pr1 prism 2 2.6 ${yfloor2a} ${yroof2a} EDGE EDGE 0.3 0 0 units box
    region          bl1 block 3 3.6 ${yfloor2a} ${yroof2a} EDGE EDGE units box
    region          sp1 sphere 4.3 ${yfloor2c} 0 ${rsph} units box
    region          sp2 sphere 5 ${yfloor2c} 0 ${rsph} units box
    region          sp3 sphere 5.7 ${yfloor2c} 0 ${rsph} units box
    region          sp4 sphere 6.4 ${yfloor2c} 0 ${rsph} units box
    region          sp5 sphere 7.1 ${yfloor2c} 0 ${rsph} units box
    region          sp6 sphere 6.05 ${yfloor2d} 0 ${rsph} units box
    region          br2 block 3 3.6 ${yfloor2b} ${yroof2b} EDGE EDGE units box

    # fill the regions with atoms (note that atoms = smoothed hydrodynamics particles)
    create_atoms    2 region pr1
    create_atoms    2 region bl1
    create_atoms    2 region sp1
    create_atoms    2 region sp2
    create_atoms    2 region sp3
    create_atoms    2 region sp4
    create_atoms    2 region sp5
    create_atoms    2 region sp6
    create_atoms    2 region br2

    # atoms of objects are grouped with two id
    # fix apply only to groups
    group           solidfoods type 2
    group           tlsph type 2

    # group heavy
    group           allheavy type 1:4


    &#34;&#34;&#34;


# %% Discretization section template
class discretizationsection(script):
    &#34;&#34;&#34; LAMMPS script: discretization session &#34;&#34;&#34;
    name = &#34;discretization&#34;
    description = name+&#34; section&#34;
    position = 3
    section = 4
    userid = &#34;example&#34;
    version = 0.1

    # inherit properties from geometrysection
    DEFINITIONS = geometrysection.DEFINITIONS + scriptdata(
              h= &#34;2.5*${l0} # SPH kernel diameter&#34;,
        vol_one= &#34;${l0}^2 # initial particle volume for 2d simulation&#34;,
     rho_saliva= 1000,
        rho_obj= 1300,
           skin= &#34;${h} # Verlet list range&#34;,
  contact_scale= 1.5
        )

    TEMPLATE = &#34;&#34;&#34;
# :DISCRETIZATION SECTION:
#   discretization

    ####################################################################################################
    # DISCRETIZATION PARAMETERS
    ####################################################################################################
    set             group all diameter ${h}
    set             group all smd/contact/radius ${l0}
    set             group all volume  ${vol_one}
    set             group all smd/mass/density ${rho_saliva}
    set             group solidfoods smd/mass/density ${rho_obj}
    set             group tongue1 smd/mass/density ${rho_obj}
    set             group tongue2 smd/mass/density ${rho_obj}
    neighbor        ${skin} bin

    &#34;&#34;&#34;


# %% Boundary section template
class boundarysection(script):
    &#34;&#34;&#34; LAMMPS script: boundary session &#34;&#34;&#34;
    name = &#34;boundary&#34;
    description = name+&#34; section&#34;
    position = 4
    section = 5
    userid = &#34;example&#34;
    version = 0.1

    # inherit properties from geometrysection
    DEFINITIONS = geometrysection.DEFINITIONS + scriptdata(
        gravity = -9.81,
        vector = &#34;$ 0 1 0&#34;
        )

    TEMPLATE = &#34;&#34;&#34;
# :BOUNDARY SECTION:
#   boundary section

    ####################################################################################################
    # DEFINE BOUNDARY CONDITIONS
    #
    # note that the the particles constituting the mouth are simply not integrated in time,
    # thus these particles never move. This is equivalent to a fixed displacement boundary condition.
    ####################################################################################################
    fix             gfix allheavy gravity ${gravity} vector ${vector} # add gravity


    ####################################################################################################
    # moving top &#34;tongue&#34; (to2)
    ####################################################################################################
    variable vmouth equal -${crunchv}*sin(${crunchw}*time)
    fix             move_fix_tongue2 tongue2 smd/setvel 0 v_vmouth 0

    &#34;&#34;&#34;

# %% Interactions section template
class interactionsection(script):
    &#34;&#34;&#34; LAMMPS script: interaction session &#34;&#34;&#34;
    name = &#34;interactions&#34;
    description = name+&#34; section&#34;
    position = 5
    section = 6
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = globalsection.DEFINITIONS + \
                  geometrysection.DEFINITIONS + \
                  discretizationsection.DEFINITIONS

    TEMPLATE = &#34;&#34;&#34;
# :INTERACTIONS SECTION:
#   Please use forcefield() to make a robust code

    ####################################################################################################
    # INTERACTION PHYSICS / MATERIAL MODEL
    # 3 different pair styles are used:
    #     - updated Lagrangian SPH for saliva
    #     - total Lagrangian SPH for solid objects
    #     - a repulsive Hertzian potential for contact forces between different physical bodies
    ####################################################################################################
    pair_style      hybrid/overlay smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION &amp;
                                   smd/tlsph smd/hertz ${contact_scale}
    pair_coeff      1 1 smd/ulsph *COMMON ${rho_saliva} ${c0} ${q1} ${Cp} 0 &amp;
                    *EOS_TAIT 7.0 &amp;
                    *END
    pair_coeff      2 2 smd/tlsph *COMMON ${rho_obj} ${E} ${nu} ${q1} ${q2} ${Hg} ${Cp} &amp;
                    *STRENGTH_LINEAR_PLASTIC ${sigma_yield} ${hardening_food} &amp;
                    *EOS_LINEAR &amp;
                    *END
    pair_coeff      4 4 smd/tlsph *COMMON ${rho_obj} ${Etongue1} ${nu} ${q1} ${q2} ${Hg} ${Cp} &amp;
                    *STRENGTH_LINEAR_PLASTIC ${sigma_yield} ${hardening_tongue} &amp;
                    *EOS_LINEAR &amp;
                    *END
    pair_coeff      5 5 smd/tlsph *COMMON ${rho_obj} ${Etongue2} ${nu} ${q1} ${q2} ${Hg} ${Cp} &amp;
                    *STRENGTH_LINEAR_PLASTIC ${sigma_yield} ${hardening_tongue} &amp;
                    *EOS_LINEAR &amp;
                    *END

    pair_coeff      3 3 none   # wall-wall
    pair_coeff      1 2 smd/hertz ${contact_stiffness} # saliva-food
    pair_coeff      1 3 smd/hertz ${contact_wall} # saliva-wall
    pair_coeff      2 3 smd/hertz ${contact_wall} # food-wall
    pair_coeff      2 2 smd/hertz ${contact_stiffness} # food-food
    # add 4 (to1)
    pair_coeff      1 4 smd/hertz ${contact_stiffness} # saliva-tongue1
    pair_coeff      2 4 smd/hertz ${contact_stiffness} # food-tongue1
    pair_coeff      3 4 smd/hertz ${contact_wall} # wall-tongue1
    pair_coeff      4 4 smd/hertz ${contact_stiffness} # tongue1-tongue1
    # add 5 (to2)
    pair_coeff      1 5 smd/hertz ${contact_stiffness} # saliva-tongue2
    pair_coeff      2 5 smd/hertz ${contact_stiffness} # food-tongue2
    pair_coeff      3 5 smd/hertz ${contact_wall} # wall-tongue2
    pair_coeff      4 5 smd/hertz ${contact_stiffness} # tongue1-tongue2
    pair_coeff      5 5 smd/hertz ${contact_stiffness} # tongue2-tongue2

    &#34;&#34;&#34;


# %% Time integration section template
class integrationsection(script):
    &#34;&#34;&#34; LAMMPS script: time integration session &#34;&#34;&#34;
    name = &#34;time integration&#34;
    description = name+&#34; section&#34;
    position = 6
    section = 7
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = scriptdata(
              dt = 0.1,
   adjust_redius = &#34;$ 1.01 10 15&#34;
        )

    TEMPLATE = &#34;&#34;&#34;
# :INTEGRATION SECTION:
#   Time integration conditions

    fix             dtfix tlsph smd/adjust_dt ${dt} # dynamically adjust time increment every step
    fix             integration_fix_water saliva smd/integrate_ulsph adjust_radius ${adjust_redius}
    fix             integration_fix_solids solidfoods smd/integrate_tlsph
    fix             integration_fix_tongue1 tongue1 smd/integrate_tlsph
    fix             integration_fix_tongue2 tongue2 smd/integrate_tlsph

    &#34;&#34;&#34;


# %% Dump section template
class dumpsection(script):
    &#34;&#34;&#34; LAMMPS script: dump session &#34;&#34;&#34;
    name = &#34;dump&#34;
    description = name+&#34; section&#34;
    position = 7
    section = 8
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = globalsection().DEFINITIONS

    TEMPLATE = &#34;&#34;&#34;
# :DUMP SECTION:
#   Dump configuration

    ####################################################################################################
    # SPECIFY TRAJECTORY OUTPUT
    ####################################################################################################
    compute         eint all smd/internal/energy
    compute         contact_radius all smd/contact/radius
    compute         S solidfoods smd/tlsph/stress
    compute         nn saliva smd/ulsph/num/neighs
    compute         epl solidfoods smd/plastic/strain
    compute         vol all smd/vol
    compute         rho all smd/rho

    dump            dump_id all custom ${outstep} ${outputfile} id type x y &amp;
                    fx fy vx vy c_eint c_contact_radius mol &amp;
                    c_S[1] c_S[2] c_S[4] mass radius c_epl c_vol c_rho c_nn proc
    dump_modify     dump_id first yes

    &#34;&#34;&#34;


# %% Status section template
class statussection(script):
    &#34;&#34;&#34; LAMMPS script: status session &#34;&#34;&#34;
    name = &#34;status&#34;
    description = name+&#34; section&#34;
    position = 8
    section = 9
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = scriptdata(
        thermo = 100
        )

    TEMPLATE = &#34;&#34;&#34;
# :STATUS SECTION:
#   Status configuration

    ####################################################################################################
    # STATUS OUTPUT
    ####################################################################################################
    compute         alleint all reduce sum c_eint
    variable        etot equal pe+ke+c_alleint+f_gfix # total energy of the system
    thermo          ${thermo}
    thermo_style    custom step ke pe v_etot c_alleint f_dtfix dt
    thermo_modify   lost ignore

    &#34;&#34;&#34;


# %% Run section template
class runsection(script):
    &#34;&#34;&#34; LAMMPS script: run session &#34;&#34;&#34;
    name = &#34;run&#34;
    description = name+&#34; section&#34;
    position = 9
    section = 10
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = globalsection.DEFINITIONS + scriptdata(
        balance = &#34;$ 500 0.9 rcb&#34;
        )

    TEMPLATE = &#34;&#34;&#34;
# :RUN SECTION:
#   run configuration

    ####################################################################################################
    # RUN SIMULATION
    ####################################################################################################
    fix             balance_fix all balance ${balance} # load balancing for MPI
    run             ${tsim}
    &#34;&#34;&#34;

# %% DEBUG
# ===================================================
# main()
# ===================================================
# for debugging purposes (code called as a script)
# the code is called from here
# ===================================================
if __name__ == &#39;__main__&#39;:

    # example for debugging
    # from pizza.region import region
    # R = region(name=&#34;my region&#34;)
    # R.ellipsoid(0,0,0,1,1,1,name=&#34;E2&#34;,side=&#34;out&#34;,move=[&#34;left&#34;,&#34;${up}*3&#34;,None],up=0.1)
    # R.E2.VARIABLES.left = &#39;&#34;swiggle(%s,%s,%s)&#34;%(${a},${b},${c})&#39;
    # R.E2.VARIABLES.a=&#34;${b}-5&#34;
    # R.E2.VARIABLES.b=5
    # R.E2.VARIABLES.c=100
    # code2 = R.E2.do()
    # p = R.E2.script
    # code = p.do(0)

    # example of scriptobject()
    b1 = scriptobject(name=&#34;bead 1&#34;,group = [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;],filename=&#39;myfile1&#39;,forcefield=rigidwall())
    b2 = scriptobject(name=&#34;bead 2&#34;, group = [&#34;B&#34;, &#34;C&#34;],filename = &#39;myfile1&#39;,forcefield=rigidwall())
    b3 = scriptobject(name=&#34;bead 3&#34;, group = [&#34;B&#34;, &#34;D&#34;, &#34;E&#34;],forcefield=solidfood())
    b4 = scriptobject(name=&#34;bead 4&#34;, group = &#34;D&#34;,beadtype = 1,filename=&#34;myfile2&#34;,forcefield=water())

    collection = b1+b2+b3+b4
    grp_typ1 = collection.select(1)
    grpB = collection.group.B

    collection.interactions

    # main example of script()
    G = globalsection()
    print(G)
    c = initializesection()
    print(c)
    g = geometrysection()
    print(g)
    d = discretizationsection()
    print(d)
    b = boundarysection()
    print(b)
    i = interactionsection()
    print(i)
    t = integrationsection()
    print(t)
    d = dumpsection()
    print(d)
    s = statussection()
    print(s)
    r = runsection()
    print(r)

    # # all sections as a single script
    myscript = G+c+g+d+b+i+t+d+s+r
    p = pipescript()
    p | i
    p = collection | G
    p | i
    p[0]
    q = p | p
    q[0] = []
    p[0:1] = q[0:1]
    print(&#34;\n&#34;*4,&#39;=&#39;*80,&#39;\n\n this is the full script\n\n&#39;,&#39;=&#39;*80,&#39;\n&#39;)
    print(myscript.do())

    # pipe full demo
    p = G | c | g | d | b | i | t | d | s | r
    p.rename([&#34;G&#34;,&#34;c&#34;,&#34;g&#34;,&#34;d&#34;,&#34;b&#34;,&#34;i&#34;,&#34;t&#34;,&#34;d&#34;,&#34;s&#34;,&#34;r&#34;])
    cmd = p.do([0,1,4,7])
    sp = p.script([0,1,4,7])
    r = collection | p
    p[0:2]=p[0]*2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="script.frame_header"><code class="name flex">
<span>def <span class="ident">frame_header</span></span>(<span>lines, padding=2, style=1, corner_symbols=None, horizontal_symbol=None, vertical_symbol=None, empty_line_symbol=None, line_fill_symbol=None, comment='#')</span>
</code></dt>
<dd>
<div class="desc"><p>Format the header content into an ASCII framed box with customizable properties.</p>
<h2 id="parameters">Parameters</h2>
<p>lines (list or tuple): The lines to include in the header.
- Empty strings "" are replaced with lines of <code>line_fill_symbol</code>.
- None values are treated as empty lines.</p>
<p>padding (int, optional): Number of spaces to pad on each side of the content. Default is 2.
style (int, optional): Style index (1 to 6) for predefined frame styles. Default is 1.
corner_symbols (str or tuple, optional): Symbols for the corners (top-left, top-right, bottom-left, bottom-right).
Can be a string (e.g., "+") for uniform corners.
horizontal_symbol (str, optional): Symbol to use for horizontal lines.
vertical_symbol (str, optional): Symbol to use for vertical lines.
empty_line_symbol (str, optional): Symbol to use for empty lines inside the frame.
line_fill_symbol (str, optional): Symbol to fill lines that replace empty strings.
comment (str, optional): Comment symbol to prefix each line. Can be multiple characters. Default is "#".</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted header as a string.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the specified style is undefined or <code>corner_symbols</code> is invalid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frame_header(
    lines,
    padding=2,
    style=1,
    corner_symbols=None,  # Can be a string or a tuple
    horizontal_symbol=None,
    vertical_symbol=None,
    empty_line_symbol=None,
    line_fill_symbol=None,
    comment=&#34;#&#34;
):
    &#34;&#34;&#34;
    Format the header content into an ASCII framed box with customizable properties.

    Parameters:
        lines (list or tuple): The lines to include in the header.
            - Empty strings &#34;&#34; are replaced with lines of `line_fill_symbol`.
            - None values are treated as empty lines.

        padding (int, optional): Number of spaces to pad on each side of the content. Default is 2.
        style (int, optional): Style index (1 to 6) for predefined frame styles. Default is 1.
        corner_symbols (str or tuple, optional): Symbols for the corners (top-left, top-right, bottom-left, bottom-right).
                                                 Can be a string (e.g., &#34;+&#34;) for uniform corners.
        horizontal_symbol (str, optional): Symbol to use for horizontal lines.
        vertical_symbol (str, optional): Symbol to use for vertical lines.
        empty_line_symbol (str, optional): Symbol to use for empty lines inside the frame.
        line_fill_symbol (str, optional): Symbol to fill lines that replace empty strings.
        comment (str, optional): Comment symbol to prefix each line. Can be multiple characters. Default is &#34;#&#34;.

    Returns:
        str: The formatted header as a string.

    Raises:
        ValueError: If the specified style is undefined or `corner_symbols` is invalid.
    &#34;&#34;&#34;
    # Predefined styles
    styles = {
        1: {
            &#34;corner_symbols&#34;: (&#34;+&#34;, &#34;+&#34;, &#34;+&#34;, &#34;+&#34;),
            &#34;horizontal_symbol&#34;: &#34;-&#34;,
            &#34;vertical_symbol&#34;: &#34;|&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;-&#34;
        },
        2: {
            &#34;corner_symbols&#34;: (&#34;╔&#34;, &#34;╗&#34;, &#34;╚&#34;, &#34;╝&#34;),
            &#34;horizontal_symbol&#34;: &#34;═&#34;,
            &#34;vertical_symbol&#34;: &#34;║&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;═&#34;
        },
        3: {
            &#34;corner_symbols&#34;: (&#34;.&#34;, &#34;.&#34;, &#34;&#39;&#34;, &#34;&#39;&#34;),
            &#34;horizontal_symbol&#34;: &#34;-&#34;,
            &#34;vertical_symbol&#34;: &#34;|&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;-&#34;
        },
        4: {
            &#34;corner_symbols&#34;: (&#34;#&#34;, &#34;#&#34;, &#34;#&#34;, &#34;#&#34;),
            &#34;horizontal_symbol&#34;: &#34;=&#34;,
            &#34;vertical_symbol&#34;: &#34;#&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;=&#34;
        },
        5: {
            &#34;corner_symbols&#34;: (&#34;┌&#34;, &#34;┐&#34;, &#34;└&#34;, &#34;┘&#34;),
            &#34;horizontal_symbol&#34;: &#34;─&#34;,
            &#34;vertical_symbol&#34;: &#34;│&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;─&#34;
        },
        6: {
            &#34;corner_symbols&#34;: (&#34;.&#34;, &#34;.&#34;, &#34;.&#34;, &#34;.&#34;),
            &#34;horizontal_symbol&#34;: &#34;.&#34;,
            &#34;vertical_symbol&#34;: &#34;:&#34;,
            &#34;empty_line_symbol&#34;: &#34; &#34;,
            &#34;line_fill_symbol&#34;: &#34;.&#34;
        }
    }

    # Validate style and set defaults
    if style not in styles:
        raise ValueError(f&#34;Undefined style {style}. Valid styles are {list(styles.keys())}.&#34;)

    selected_style = styles[style]

    # Convert corner_symbols to a tuple of 4 values
    if isinstance(corner_symbols, str):
        corner_symbols = (corner_symbols,) * 4
    elif isinstance(corner_symbols, (list, tuple)) and len(corner_symbols) == 1:
        corner_symbols = tuple(corner_symbols * 4)
    elif isinstance(corner_symbols, (list, tuple)) and len(corner_symbols) == 2:
        corner_symbols = (corner_symbols[0], corner_symbols[1], corner_symbols[0], corner_symbols[1])
    elif corner_symbols is None:
        corner_symbols = selected_style[&#34;corner_symbols&#34;]
    elif not isinstance(corner_symbols, (list, tuple)) or len(corner_symbols) != 4:
        raise ValueError(&#34;corner_symbols must be a string or a tuple/list of 1, 2, or 4 elements.&#34;)

    # Apply overrides or defaults
    horizontal_symbol = horizontal_symbol or selected_style[&#34;horizontal_symbol&#34;]
    vertical_symbol = vertical_symbol or selected_style[&#34;vertical_symbol&#34;]
    empty_line_symbol = empty_line_symbol or selected_style[&#34;empty_line_symbol&#34;]
    line_fill_symbol = line_fill_symbol or selected_style[&#34;line_fill_symbol&#34;]

    # Process lines: Replace &#34;&#34; with line_fill placeholders, None with empty lines
    processed_lines = []
    max_content_width = 0
    for line in lines:
        if line == &#34;&#34;:
            processed_lines.append(&#34;&lt;LINE_FILL&gt;&#34;)
        elif line is None:
            processed_lines.append(None)
        else:
            processed_lines.append(line)
            max_content_width = max(max_content_width, len(line))

    # Adjust width for padding
    frame_width = max_content_width + padding * 2

    # Build the top border
    top_border = f&#34;{corner_symbols[0]}{horizontal_symbol * frame_width}{corner_symbols[1]}&#34;

    # Build content lines with vertical borders
    framed_lines = [top_border]
    for line in processed_lines:
        if line is None:
            empty_line = f&#34;{vertical_symbol}{empty_line_symbol * frame_width}{vertical_symbol}&#34;
            framed_lines.append(empty_line)
        elif line == &#34;&lt;LINE_FILL&gt;&#34;:
            fill_line = f&#34;{vertical_symbol}{line_fill_symbol * frame_width}{vertical_symbol}&#34;
            framed_lines.append(fill_line)
        else:
            content = line.center(frame_width)
            framed_line = f&#34;{vertical_symbol}{content}{vertical_symbol}&#34;
            framed_lines.append(framed_line)

    # Build the bottom border
    bottom_border = f&#34;{corner_symbols[2]}{horizontal_symbol * frame_width}{corner_symbols[3]}&#34;
    framed_lines.append(bottom_border)

    # Ensure all lines start with the comment symbol
    commented_lines = [
        line if line.startswith(comment) else f&#34;{comment} {line}&#34; for line in framed_lines
    ]

    return &#34;\n&#34;.join(commented_lines)+&#34;\n&#34;</code></pre>
</details>
</dd>
<dt id="script.get_metadata"><code class="name flex">
<span>def <span class="ident">get_metadata</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary of explicitly defined metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metadata():
    &#34;&#34;&#34;Return a dictionary of explicitly defined metadata.&#34;&#34;&#34;
    # Define the desired metadata keys
    metadata_keys = [
        &#34;__project__&#34;,
        &#34;__author__&#34;,
        &#34;__copyright__&#34;,
        &#34;__credits__&#34;,
        &#34;__license__&#34;,
        &#34;__maintainer__&#34;,
        &#34;__email__&#34;,
        &#34;__version__&#34;,
    ]
    # Filter only the desired keys from the current module&#39;s globals
    return {key.strip(&#34;_&#34;): globals()[key] for key in metadata_keys if key in globals()}</code></pre>
</details>
</dd>
<dt id="script.get_tmp_location"><code class="name flex">
<span>def <span class="ident">get_tmp_location</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">get_tmp_location = lambda: tempfile.gettempdir()</code></pre>
</details>
</dd>
<dt id="script.is_scalar"><code class="name flex">
<span>def <span class="ident">is_scalar</span></span>(<span>val)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if a value is scalar (not a list, dict, or tuple).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_scalar(val):
    &#34;&#34;&#34;
    Determines if a value is scalar (not a list, dict, or tuple).
    &#34;&#34;&#34;
    return not isinstance(val, (list, dict, tuple))</code></pre>
</details>
</dd>
<dt id="script.make_hashable"><code class="name flex">
<span>def <span class="ident">make_hashable</span></span>(<span>val)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively converts lists and dictionaries to tuples to make them hashable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_hashable(val):
    &#34;&#34;&#34;
    Recursively converts lists and dictionaries to tuples to make them hashable.
    &#34;&#34;&#34;
    if isinstance(val, list):
        return tuple(make_hashable(item) for item in val)
    elif isinstance(val, dict):
        return tuple(sorted((k, make_hashable(v)) for k, v in val.items()))
    return val</code></pre>
</details>
</dd>
<dt id="script.picker"><code class="name flex">
<span>def <span class="ident">picker</span></span>(<span>L, indices)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def picker(L,indices): return [L[i] for i in indices if (i&gt;=0 and i&lt;len(L))]</code></pre>
</details>
</dd>
<dt id="script.remove_comments"><code class="name flex">
<span>def <span class="ident">remove_comments</span></span>(<span>content, split_lines=False, emptylines=False, comment_chars='#', continuation_marker='\\\\', remove_continuation_marker=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes comments from a single or multi-line string, handling quotes, escaped characters, and line continuation.</p>
<h2 id="parameters">Parameters:</h2>
<p>content : str
The input string, which may contain multiple lines. Each line will be processed
individually to remove comments, while preserving content inside quotes.
split_lines : bool, optional (default: False)
If True, the function will return a list of processed lines. If False, it will
return a single string with all lines joined by newlines.
emptylines : bool, optional (default: False)
If True, empty lines will be preserved in the output. If False, empty lines
will be removed from the output.
comment_chars : str, optional (default: "#")
A string containing characters to identify the start of a comment.
Any of these characters will mark the beginning of a comment unless within quotes.
continuation_marker : str or None, optional (default: "\")
A string containing characters to indicate line continuation (use <code>\</code> to specify).
Any characters after the continuation marker are ignored as a comment. If set to <code>None</code>
or an empty string, line continuation will not be processed.
remove_continuation_marker : bool, optional (default: False)
If True, the continuation marker itself is removed from the processed line, keeping
only the characters before it. If False, the marker is retained as part of the line.</p>
<h2 id="returns">Returns:</h2>
<p>str or list of str
The processed content with comments removed. Returns a list of lines if
<code>split_lines</code> is True, or a single string if False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_comments(content, split_lines=False, emptylines=False, comment_chars=&#34;#&#34;, continuation_marker=&#34;\\\\&#34;, remove_continuation_marker=False):
    &#34;&#34;&#34;
    Removes comments from a single or multi-line string, handling quotes, escaped characters, and line continuation.

    Parameters:
    -----------
    content : str
        The input string, which may contain multiple lines. Each line will be processed
        individually to remove comments, while preserving content inside quotes.
    split_lines : bool, optional (default: False)
        If True, the function will return a list of processed lines. If False, it will
        return a single string with all lines joined by newlines.
    emptylines : bool, optional (default: False)
        If True, empty lines will be preserved in the output. If False, empty lines
        will be removed from the output.
    comment_chars : str, optional (default: &#34;#&#34;)
        A string containing characters to identify the start of a comment.
        Any of these characters will mark the beginning of a comment unless within quotes.
    continuation_marker : str or None, optional (default: &#34;\\\\&#34;)
        A string containing characters to indicate line continuation (use `\\` to specify).
        Any characters after the continuation marker are ignored as a comment. If set to `None`
        or an empty string, line continuation will not be processed.
    remove_continuation_marker : bool, optional (default: False)
        If True, the continuation marker itself is removed from the processed line, keeping
        only the characters before it. If False, the marker is retained as part of the line.

    Returns:
    --------
    str or list of str
        The processed content with comments removed. Returns a list of lines if
        `split_lines` is True, or a single string if False.
    &#34;&#34;&#34;
    def process_line(line):
        &#34;&#34;&#34;Remove comments and handle line continuation within a single line while managing quotes and escapes.&#34;&#34;&#34;
        in_single_quote = False
        in_double_quote = False
        escaped = False
        result = []

        i = 0
        while i &lt; len(line):
            char = line[i]

            if escaped:
                result.append(char)
                escaped = False
                i += 1
                continue

            # Handle escape character within quoted strings
            if char == &#39;\\&#39; and (in_single_quote or in_double_quote):
                escaped = True
                result.append(char)
                i += 1
                continue

            # Toggle state for single and double quotes
            if char == &#34;&#39;&#34; and not in_double_quote:
                in_single_quote = not in_single_quote
            elif char == &#39;&#34;&#39; and not in_single_quote:
                in_double_quote = not in_double_quote

            # Check for line continuation marker if it&#39;s set and outside of quotes
            if continuation_marker and not in_single_quote and not in_double_quote:
                # Check if the remaining part of the line matches the continuation marker
                if line[i:].startswith(continuation_marker):
                    # Optionally remove the continuation marker
                    if remove_continuation_marker:
                        result.append(line[:i].rstrip())  # Keep everything before the marker
                    else:
                        result.append(line[:i + len(continuation_marker)].rstrip())  # Include the marker itself
                    return &#39;&#39;.join(result).strip()

            # Check for comment start characters outside of quotes
            if char in comment_chars and not in_single_quote and not in_double_quote:
                break  # Stop processing the line when a comment is found

            result.append(char)
            i += 1

        return &#39;&#39;.join(result).strip()

    # Split the input content into lines
    lines = content.split(&#39;\n&#39;)

    # Process each line, considering the emptylines flag
    processed_lines = []
    for line in lines:
        stripped_line = line.strip()
        if not stripped_line and not emptylines:
            continue  # Skip empty lines if emptylines is False
        if any(stripped_line.startswith(c) for c in comment_chars):
            continue  # Skip lines that are pure comments
        processed_line = process_line(line)
        if processed_line or emptylines:  # Only add non-empty lines if emptylines is False
            processed_lines.append(processed_line)

    if split_lines:
        return processed_lines  # Return list of processed lines
    else:
        return &#39;\n&#39;.join(processed_lines)  # Join lines back into a single string</code></pre>
</details>
</dd>
<dt id="script.span"><code class="name flex">
<span>def <span class="ident">span</span></span>(<span>vector, sep=' ', left='', right='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def span(vector,sep=&#34; &#34;,left=&#34;&#34;,right=&#34;&#34;):
    return left + (vector if isinstance(vector, str) else sep.join(map(str, vector))) + right if vector is not None else &#34;&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="script.CallableScript"><code class="flex name class">
<span>class <span class="ident">CallableScript</span></span>
<span>(</span><span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>A descriptor that allows the method Interactions to be accessed both as a property and as a callable function.</p>
<p>This class enables a method to behave like a property when accessed without parentheses,
returning a function that can be called with default parameters. It also allows the method
to be called directly with optional parameters, providing flexibility in usage.</p>
<h2 id="attributes">Attributes:</h2>
<p>func : function
The original function that is decorated, which will be used for both property access
and direct calls.</p>
<h2 id="methods">Methods:</h2>
<p><strong>get</strong>(self, instance, owner)
Returns a lambda function to call the original function with default parameters
when accessed as a property.</p>
<p><strong>call</strong>(self, instance, printflag=False, verbosity=2)
Allows the original function to be called directly with specified parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CallableScript:
    &#34;&#34;&#34;
    A descriptor that allows the method Interactions to be accessed both as a property and as a callable function.

    This class enables a method to behave like a property when accessed without parentheses,
    returning a function that can be called with default parameters. It also allows the method
    to be called directly with optional parameters, providing flexibility in usage.

    Attributes:
    -----------
    func : function
        The original function that is decorated, which will be used for both property access
        and direct calls.

    Methods:
    --------
    __get__(self, instance, owner)
        Returns a lambda function to call the original function with default parameters
        when accessed as a property.

    __call__(self, instance, printflag=False, verbosity=2)
        Allows the original function to be called directly with specified parameters.
    &#34;&#34;&#34;
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        # When accessed as a property, return a lambda that calls the original function
        return lambda printflag=False, verbosity=2, verbose=None: self.func(instance, printflag=printflag, verbosity=verbosity, verbose=verbose)

    def __call__(self, instance, printflag=False, verbosity=2, verbose=None):
        # Allow calling the function directly with specified parameters
        return self.func(instance, printflag=printflag, verbosity=verbosity)</code></pre>
</details>
</dd>
<dt id="script.VariableOccurrences"><code class="flex name class">
<span>class <span class="ident">VariableOccurrences</span></span>
<span>(</span><span>data, variables=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="script.VariableOccurrences" href="#script.VariableOccurrences">VariableOccurrences</a></code> class encapsulates raw data and provides utility methods for analyzing variable occurrences
across various scopes. It is designed to handle both single and multiple variables, supporting flexible data structures
and analysis operations.</p>
<h2 id="class-methods">Class Methods:</h2>
<ul>
<li><code>__init__(data, variables=None)</code>: Initializes the class with raw data and optional variable names.</li>
<li><code>_determine_scopes()</code>: Determines the unique scopes present across all variables.</li>
<li><code>get_raw_data()</code>: Returns the raw data as provided during initialization.</li>
<li><code>get_steps_with_value(value, within_list=False)</code>: Retrieves steps where the variable equals the specified value.</li>
<li><code>get_all_values()</code>: Retrieves all unique values of the variable(s).</li>
<li><code>get_all_elements_in_lists()</code>: Retrieves all unique elements within list-type variable values.</li>
<li><code>get_usage_count(value, within_list=False)</code>: Counts occurrences of a specific value.</li>
<li><code>get_steps_with_value_in_scope(variable, scope, value, within_list=False)</code>: Retrieves steps where a variable equals a value within a specific scope.</li>
<li><code>summarize()</code>: Summarizes the occurrences of variables, including counts and unique elements.</li>
<li><code>export(filename=None, scopes='all', variables='all', include_headers=True, return_content=False)</code>:
Exports variable occurrences as Markdown, plain text, or HTML.</li>
</ul>
<h2 id="attributes">Attributes:</h2>
<ul>
<li><code>data</code>: Dictionary containing the raw variable data.</li>
<li>Single variable: <code>{'scope1': [...], 'scope2': [...]}</code>.</li>
<li>Multiple variables: <code>{'var1': {...}, 'var2': {...}, ...}</code>.</li>
<li><code>variables</code>: List of variable names managed by the instance.</li>
<li><code>scopes</code>: List of unique scopes across all variables.</li>
</ul>
<h2 id="usage">Usage:</h2>
<p>The class is useful for tracking and analyzing variable values across different contexts, such as configuration files,
programming environments, or simulation data. It supports advanced querying, summary generation, and export functionality.</p>
<h2 id="example">Example:</h2>
<h1 id="initialize-with-single-variable">Initialize with single variable</h1>
<p>data = {'global': [(0, 1), (1, 2)], 'local': [(0, 3), (1, 4)]}
vo = VariableOccurrences(data, variables="var1")</p>
<h1 id="initialize-with-multiple-variables">Initialize with multiple variables</h1>
<p>data = {
"var1": {"global": [(0, 1), (1, 2)], "local": [(0, 3), (1, 4)]},
"var2": {"global": [1, 2], "local": [3, 4]},
}
vo = VariableOccurrences(data)</p>
<h1 id="query-steps-where-a-value-is-present">Query steps where a value is present</h1>
<p>steps = vo.get_steps_with_value(2)</p>
<h1 id="export-data-to-a-markdown-file">Export data to a Markdown file</h1>
<p>vo.export("output.md")</p>
<p>Initializes the VariableOccurrences object.</p>
<p>Parameters:
- data:
- For single variable: dict with scopes as keys and lists of values or a single value.
- For multiple variables: dict mapping variable names to their respective scope data.
- variables (str or list/tuple, optional):
- If single variable: string representing the variable name.
- If multiple variables: list or tuple of variable names.
- If None: assumes data is for multiple variables without specifying names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariableOccurrences:
    &#34;&#34;&#34;
    The `VariableOccurrences` class encapsulates raw data and provides utility methods for analyzing variable occurrences
    across various scopes. It is designed to handle both single and multiple variables, supporting flexible data structures
    and analysis operations.

    Class Methods:
    --------------
    - `__init__(data, variables=None)`: Initializes the class with raw data and optional variable names.
    - `_determine_scopes()`: Determines the unique scopes present across all variables.
    - `get_raw_data()`: Returns the raw data as provided during initialization.
    - `get_steps_with_value(value, within_list=False)`: Retrieves steps where the variable equals the specified value.
    - `get_all_values()`: Retrieves all unique values of the variable(s).
    - `get_all_elements_in_lists()`: Retrieves all unique elements within list-type variable values.
    - `get_usage_count(value, within_list=False)`: Counts occurrences of a specific value.
    - `get_steps_with_value_in_scope(variable, scope, value, within_list=False)`: Retrieves steps where a variable equals a value within a specific scope.
    - `summarize()`: Summarizes the occurrences of variables, including counts and unique elements.
    - `export(filename=None, scopes=&#39;all&#39;, variables=&#39;all&#39;, include_headers=True, return_content=False)`:
      Exports variable occurrences as Markdown, plain text, or HTML.

    Attributes:
    -----------
    - `data`: Dictionary containing the raw variable data.
      - Single variable: `{&#39;scope1&#39;: [...], &#39;scope2&#39;: [...]}`.
      - Multiple variables: `{&#39;var1&#39;: {...}, &#39;var2&#39;: {...}, ...}`.
    - `variables`: List of variable names managed by the instance.
    - `scopes`: List of unique scopes across all variables.

    Usage:
    ------
    The class is useful for tracking and analyzing variable values across different contexts, such as configuration files,
    programming environments, or simulation data. It supports advanced querying, summary generation, and export functionality.

    Example:
    --------
    # Initialize with single variable
    data = {&#39;global&#39;: [(0, 1), (1, 2)], &#39;local&#39;: [(0, 3), (1, 4)]}
    vo = VariableOccurrences(data, variables=&#34;var1&#34;)

    # Initialize with multiple variables
    data = {
        &#34;var1&#34;: {&#34;global&#34;: [(0, 1), (1, 2)], &#34;local&#34;: [(0, 3), (1, 4)]},
        &#34;var2&#34;: {&#34;global&#34;: [1, 2], &#34;local&#34;: [3, 4]},
    }
    vo = VariableOccurrences(data)

    # Query steps where a value is present
    steps = vo.get_steps_with_value(2)

    # Export data to a Markdown file
    vo.export(&#34;output.md&#34;)
    &#34;&#34;&#34;

    def __init__(self, data, variables=None):
        &#34;&#34;&#34;
        Initializes the VariableOccurrences object.

        Parameters:
        - data:
            - For single variable: dict with scopes as keys and lists of values or a single value.
            - For multiple variables: dict mapping variable names to their respective scope data.
        - variables (str or list/tuple, optional):
            - If single variable: string representing the variable name.
            - If multiple variables: list or tuple of variable names.
            - If None: assumes data is for multiple variables without specifying names.
        &#34;&#34;&#34;
        if variables is None:
            # Assume data is a dict mapping variable names to their scope data
            if not isinstance(data, dict):
                raise ValueError(&#34;For multiple variables, data must be a dict mapping variable names to their scope data.&#34;)
            self.variables = list(data.keys())
            self.data = data  # {var1: {scope1: [...], scope2: [...]}, var2: {...}, ...}
        elif isinstance(variables, str):
            # Single variable case
            self.variables = [variables]
            if not isinstance(data, dict):
                raise ValueError(&#34;For single variable, data must be a dict with scopes as keys and lists of values or single values as values.&#34;)
            self.data = {variables: data}  # {var: {scope1: [...], scope2: [...], ...}}
        elif isinstance(variables, (list, tuple)):
            # Multiple variables specified
            if not isinstance(data, dict):
                raise ValueError(&#34;For multiple variables, data must be a dict mapping variable names to their scope data.&#34;)
            if set(variables) &gt; set(data.keys()):
                missing_vars = set(variables) - set(data.keys())
                raise ValueError(f&#34;Data does not contain entries for variables: {&#39;, &#39;.join(missing_vars)}&#34;)
            self.variables = list(variables)
            self.data = {var: data[var] for var in variables}  # {var1: {...}, var2: {...}, ...}
        else:
            raise ValueError(&#34;Parameter &#39;variables&#39; must be a string, list, tuple, or None.&#34;)

        self.scopes = self._determine_scopes()

    def _determine_scopes(self):
        &#34;&#34;&#34;Determines the unique scopes present across all variables.&#34;&#34;&#34;
        scopes = set()
        for var in self.variables:
            var_scopes = self.data[var].keys()
            scopes.update(scope.lower() for scope in var_scopes)
        return sorted(list(scopes))

    def get_raw_data(self):
        &#34;&#34;&#34;
        Returns the raw data.

        Returns:
        - The raw data as provided during initialization.
        &#34;&#34;&#34;
        return self.data

    def get_steps_with_value(self, value, within_list=False):
        &#34;&#34;&#34;
        Retrieves the steps where the variable equals the specified value.

        Parameters:
        - value: The value to search for.
        - within_list (bool): If True, searches for the value within list-type variable values.

        Returns:
        - If single variable:
            - A dict with scopes as keys and lists of step indices or values as values.
        - If multiple variables:
            - A dict mapping each variable name to their respective scope-step/value mappings.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_result = {}
            for scope, occurrences in self.data[var].items():
                if is_scalar(occurrences):
                    # Scalar value
                    if within_list:
                        continue  # Cannot search within a scalar
                    if occurrences == value:
                        var_result[scope] = occurrences
                elif isinstance(occurrences, list):
                    # List of values or list of tuples
                    steps = []
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            step, val = item
                            if within_list:
                                if isinstance(val, list) and value in val:
                                    steps.append(step)
                            else:
                                if val == value:
                                    steps.append(step)
                        else:
                            # List of values
                            if within_list:
                                if isinstance(item, list) and value in item:
                                    steps.append(item)
                            else:
                                if item == value:
                                    steps.append(item)
                    if steps:
                        var_result[scope] = steps
                else:
                    # Other types (e.g., dict), can be extended as needed
                    pass
            if var_result:
                result[var] = var_result
        return result

    def get_all_values(self):
        &#34;&#34;&#34;
        Retrieves all unique values of the variable(s).

        Returns:
        - A dict mapping each variable to its set of unique values per scope.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_unique = {}
            for scope, occurrences in self.data[var].items():
                unique_vals = set()
                if is_scalar(occurrences):
                    unique_vals.add(occurrences)
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            _, val = item
                            hashable_val = make_hashable(val)
                            unique_vals.add(hashable_val)
                        else:
                            hashable_val = make_hashable(item)
                            unique_vals.add(hashable_val)
                var_unique[scope] = unique_vals
            result[var] = var_unique
        return result

    def get_all_elements_in_lists(self):
        &#34;&#34;&#34;
        Retrieves all unique elements within list-type variable values.

        Returns:
        - A dict mapping each variable to its set of unique elements in lists per scope.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_elements = {}
            for scope, occurrences in self.data[var].items():
                unique_elems = set()
                if is_scalar(occurrences):
                    if isinstance(occurrences, list):
                        unique_elems.update(occurrences)
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            _, val = item
                            if isinstance(val, list):
                                unique_elems.update(val)
                        elif isinstance(item, list):
                            unique_elems.update(item)
                var_elements[scope] = unique_elems
            result[var] = var_elements
        return result

    def get_usage_count(self, value, within_list=False):
        &#34;&#34;&#34;
        Counts how many times a specific value is used.

        Parameters:
        - value: The value to count.
        - within_list (bool): If True, counts occurrences within list-type variable values.

        Returns:
        - If single variable:
            - A dict with scopes as keys and integer counts or counts of values as values.
        - If multiple variables:
            - A dict mapping each variable name to their respective scope-count/value mappings.
        &#34;&#34;&#34;
        result = {}
        for var in self.variables:
            var_count = {}
            for scope, occurrences in self.data[var].items():
                count = 0
                if is_scalar(occurrences):
                    if within_list:
                        if isinstance(occurrences, list) and value in occurrences:
                            count += 1
                    else:
                        if occurrences == value:
                            count += 1
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            _, val = item
                            if within_list:
                                if isinstance(val, list) and value in val:
                                    count += 1
                            else:
                                if val == value:
                                    count += 1
                        else:
                            if within_list:
                                if isinstance(item, list) and value in item:
                                    count += 1
                            else:
                                if item == value:
                                    count += 1
                if count &gt; 0:
                    var_count[scope] = count
            if var_count:
                result[var] = var_count
        return result

    def get_steps_with_value_in_scope(self, variable, scope, value, within_list=False):
        &#34;&#34;&#34;
        Retrieves the steps within a specific scope where the variable equals the specified value.

        Parameters:
        - variable (str): The variable name.
        - scope (str): The scope to search within (&#34;static&#34;, &#34;global&#34;, &#34;local&#34;).
        - value: The value to search for.
        - within_list (bool): If True, searches for the value within list-type variable values.

        Returns:
        - A list of step indices or values where the variable equals the value within the specified scope.
        &#34;&#34;&#34;
        if variable not in self.variables:
            raise ValueError(f&#34;Variable &#39;{variable}&#39; is not managed by this instance.&#34;)

        scope = scope.lower()
        occurrences = self.data[variable].get(scope, [])
        steps = []

        if is_scalar(occurrences):
            if within_list:
                if isinstance(occurrences, list) and value in occurrences:
                    steps.append(occurrences)
            else:
                if occurrences == value:
                    steps.append(occurrences)
        elif isinstance(occurrences, list):
            for item in occurrences:
                if isinstance(item, tuple) and len(item) == 2:
                    step, val = item
                    if within_list:
                        if isinstance(val, list) and value in val:
                            steps.append(step)
                    else:
                        if val == value:
                            steps.append(step)
                else:
                    if within_list:
                        if isinstance(item, list) and value in item:
                            steps.append(item)
                    else:
                        if item == value:
                            steps.append(item)
        return steps

    def summarize(self):
        &#34;&#34;&#34;
        Provides a summary of the variable occurrences.

        Returns:
        - A dict mapping each variable to their respective summaries per scope.
        &#34;&#34;&#34;
        summary = {}
        for var in self.variables:
            var_summary = {}
            for scope, occurrences in self.data[var].items():
                unique_vals = set()
                unique_elements = set()
                value_counts = defaultdict(int)
                element_counts = defaultdict(int)

                if is_scalar(occurrences):
                    # Scalar value
                    hashable_val = make_hashable(occurrences)
                    unique_vals.add(hashable_val)
                    value_counts[hashable_val] += 1
                    if isinstance(occurrences, list):
                        unique_elements.update(occurrences)
                        for elem in occurrences:
                            element_counts[elem] += 1
                elif isinstance(occurrences, list):
                    for item in occurrences:
                        if isinstance(item, tuple) and len(item) == 2:
                            # Tuple: (step, value)
                            step, val = item
                            hashable_val = make_hashable(val)
                            unique_vals.add(hashable_val)
                            value_counts[hashable_val] += 1
                            if isinstance(val, list):
                                unique_elements.update(val)
                                for elem in val:
                                    element_counts[elem] += 1
                            elif isinstance(val, dict):
                                # Handle nested dictionaries if necessary
                                for sub_val in val.values():
                                    if isinstance(sub_val, list):
                                        unique_elements.update(sub_val)
                                        for elem in sub_val:
                                            element_counts[elem] += 1
                        else:
                            # Direct value
                            hashable_val = make_hashable(item)
                            unique_vals.add(hashable_val)
                            value_counts[hashable_val] += 1
                            if isinstance(item, list):
                                unique_elements.update(item)
                                for elem in item:
                                    element_counts[elem] += 1
                            elif isinstance(item, dict):
                                for sub_val in item.values():
                                    if isinstance(sub_val, list):
                                        unique_elements.update(sub_val)
                                        for elem in sub_val:
                                            element_counts[elem] += 1
                else:
                    # Other types can be handled here if needed
                    pass

                var_summary[scope] = {
                    &#34;total_occurrences&#34;: len(occurrences),
                    &#34;unique_values&#34;: unique_vals,
                    &#34;unique_elements_in_lists&#34;: unique_elements,
                    &#34;value_counts&#34;: dict(value_counts),
                    &#34;element_counts_in_lists&#34;: dict(element_counts)
                }
            summary[var] = var_summary
        return summary

    def export(self, filename=None, scopes=&#39;all&#39;, variables=&#39;all&#39;, include_headers=True, return_content=False):
        &#34;&#34;&#34;
        Exports the variable occurrences to a file or returns the content as a string.

        Parameters:
        - filename (str, optional): Path to the output file. Must end with .md, .txt, or .html. Required if return_content is False.
        - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.
        - variables (str or list/tuple, optional): &#39;all&#39;, a single variable string, or a list of variable strings. Defaults to &#39;all&#39;.
        - include_headers (bool, optional): If True, includes headers in the exported content. Defaults to True.
        - return_content (bool, optional): If True, returns the content as a string instead of writing to a file. Defaults to False.

        Returns:
        - str: The exported content as a string if return_content is True.
        - None: Writes to file if return_content is False.

        Raises:
        - ValueError: If &#39;filename&#39; is not provided when return_content is False.
        - ValueError: If &#39;scopes&#39; or &#39;variables&#39; are of incorrect types.
        &#34;&#34;&#34;
        # Determine file extension if filename is provided
        if filename:
            _, ext = os.path.splitext(filename)
            ext = ext.lower()

            if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
                export_format = &#39;markdown&#39;
            elif ext == &#39;.html&#39;:
                export_format = &#39;html&#39;
            else:
                raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)
        elif not return_content:
            raise ValueError(&#34;Filename must be provided if return_content is False.&#34;)

        # Determine scopes
        if isinstance(scopes, str):
            if scopes.lower() == &#39;all&#39;:
                selected_scopes = self.scopes
            else:
                selected_scopes = [scopes.lower()]
        elif isinstance(scopes, (list, tuple)):
            scopes_lower = [s.lower() for s in scopes]
            if &#39;all&#39; in scopes_lower:
                selected_scopes = self.scopes
            else:
                selected_scopes = scopes_lower
        else:
            raise ValueError(&#34;Parameter &#39;scopes&#39; must be a string or a list/tuple of strings.&#34;)

        # Determine variables
        if isinstance(variables, str):
            if variables.lower() == &#39;all&#39;:
                selected_variables = self.variables
            else:
                if variables not in self.variables:
                    print(f&#34;Warning: Variable &#39;{variables}&#39; not managed by this instance.&#34;)
                    selected_variables = []
                else:
                    selected_variables = [variables]
        elif isinstance(variables, (list, tuple)):
            variables_lower = [v for v in variables]
            selected_variables = [v for v in variables_lower if v in self.variables]
            missing_vars = set(variables_lower) - set(selected_variables)
            if missing_vars:
                print(f&#34;Warning: Variables &#39;{&#39;, &#39;.join(missing_vars)}&#39; not managed by this instance.&#34;)
        else:
            raise ValueError(&#34;Parameter &#39;variables&#39; must be a string or a list/tuple of strings.&#34;)

        # Generate content
        content = &#34;&#34;
        if include_headers:
            if export_format == &#39;markdown&#39;:
                content += f&#34;## Variable: `{self.variables[0]}`\n\n&#34; if len(self.variables) == 1 else &#34;&#34;
            elif export_format == &#39;html&#39;:
                content += f&#34;&lt;h2&gt;Variable: {self.variables[0]}&lt;/h2&gt;\n&#34; if len(self.variables) == 1 else &#34;&#34;

        summary = self.summarize()
        for var in selected_variables:
            if include_headers:
                if export_format == &#39;markdown&#39;:
                    content += f&#34;### Variable: `{var}`\n\n&#34;
                elif export_format == &#39;html&#39;:
                    content += f&#34;&lt;h3&gt;Variable: {var}&lt;/h3&gt;\n&#34;
            var_summary = summary[var]
            for scope, details in var_summary.items():
                if scope not in selected_scopes:
                    continue
                if include_headers or True:
                    if export_format == &#39;markdown&#39;:
                        content += f&#34;#### Scope: {scope.capitalize()}\n\n&#34;
                    elif export_format == &#39;html&#39;:
                        content += f&#34;&lt;h4&gt;Scope: {scope.capitalize()}&lt;/h4&gt;\n&#34;
                # Add content based on format
                if export_format == &#39;markdown&#39;:
                    content += f&#34;- **Total Occurrences**: {details[&#39;total_occurrences&#39;]}\n&#34;
                    unique_vals_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_values&#39;]))
                    content += f&#34;- **Unique Values**: {unique_vals_formatted}\n&#34;
                    if details[&#39;unique_elements_in_lists&#39;]:
                        unique_elems_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_elements_in_lists&#39;]))
                        content += f&#34;- **Unique Elements in Lists**: {unique_elems_formatted}\n\n&#34;
                        # Element Counts Table
                        content += &#34;**Element Counts in Lists:**\n\n&#34;
                        content += &#34;| Element | Count |\n&#34;
                        content += &#34;|---------|-------|\n&#34;
                        for elem, count in details[&#39;element_counts_in_lists&#39;].items():
                            content += f&#34;| {elem} | {count} |\n&#34;
                        content += &#34;\n&#34;
                elif export_format == &#39;html&#39;:
                    content += &#34;&lt;ul&gt;&#34;
                    content += f&#34;&lt;li&gt;&lt;strong&gt;Total Occurrences&lt;/strong&gt;: {details[&#39;total_occurrences&#39;]}&lt;/li&gt;&#34;
                    unique_vals_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_values&#39;]))
                    content += f&#34;&lt;li&gt;&lt;strong&gt;Unique Values&lt;/strong&gt;: {unique_vals_formatted}&lt;/li&gt;&#34;
                    if details[&#39;unique_elements_in_lists&#39;]:
                        unique_elems_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_elements_in_lists&#39;]))
                        content += f&#34;&lt;li&gt;&lt;strong&gt;Unique Elements in Lists&lt;/strong&gt;: {unique_elems_formatted}&lt;/li&gt;&#34;
                    content += &#34;&lt;/ul&gt;\n&#34;

                    if details[&#39;element_counts_in_lists&#39;]:
                        content += &#34;&lt;h5&gt;Element Counts in Lists:&lt;/h5&gt;\n&#34;
                        content += &#34;&lt;table&gt;\n&lt;tr&gt;&lt;th&gt;Element&lt;/th&gt;&lt;th&gt;Count&lt;/th&gt;&lt;/tr&gt;\n&#34;
                        for elem, count in details[&#39;element_counts_in_lists&#39;].items():
                            content += f&#34;&lt;tr&gt;&lt;td&gt;{elem}&lt;/td&gt;&lt;td&gt;{count}&lt;/td&gt;&lt;/tr&gt;\n&#34;
                        content += &#34;&lt;/table&gt;\n&#34;

            # Add a horizontal line between variables
            if include_headers and len(selected_variables) &gt; 1:
                if export_format == &#39;markdown&#39;:
                    content += &#34;\n---\n\n&#34;
                elif export_format == &#39;html&#39;:
                    content += &#34;&lt;hr/&gt;\n&#34;

        # Handle format-specific headers
        if return_content:
            if export_format == &#39;markdown&#39;:
                return content
            elif export_format == &#39;html&#39;:
                return f&#34;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#39;UTF-8&#39;&gt;&lt;title&gt;Variable Report&lt;/title&gt;&lt;/head&gt;&lt;body&gt;{content}&lt;/body&gt;&lt;/html&gt;&#34;
        else:
            if not filename:
                raise ValueError(&#34;Filename must be provided if return_content is False.&#34;)

            # Determine export format based on file extension
            if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
                export_format = &#39;markdown&#39;
            elif ext == &#39;.html&#39;:
                export_format = &#39;html&#39;
            else:
                raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

            # Prepare full content for HTML
            if export_format == &#39;html&#39; and not include_headers:
                full_content = f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Variable Report&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n{content}\n&lt;/body&gt;\n&lt;/html&gt;&#34;
            else:
                full_content = content

            # Write to file
            try:
                with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                    file.write(full_content)
                print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
            except Exception as e:
                raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="script.VariableOccurrences.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, filename=None, scopes='all', variables='all', include_headers=True, return_content=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Exports the variable occurrences to a file or returns the content as a string.</p>
<p>Parameters:
- filename (str, optional): Path to the output file. Must end with .md, .txt, or .html. Required if return_content is False.
- scopes (str or list/tuple, optional): 'all', a single scope string, or a list of scope strings. Defaults to 'all'.
- variables (str or list/tuple, optional): 'all', a single variable string, or a list of variable strings. Defaults to 'all'.
- include_headers (bool, optional): If True, includes headers in the exported content. Defaults to True.
- return_content (bool, optional): If True, returns the content as a string instead of writing to a file. Defaults to False.</p>
<p>Returns:
- str: The exported content as a string if return_content is True.
- None: Writes to file if return_content is False.</p>
<p>Raises:
- ValueError: If 'filename' is not provided when return_content is False.
- ValueError: If 'scopes' or 'variables' are of incorrect types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, filename=None, scopes=&#39;all&#39;, variables=&#39;all&#39;, include_headers=True, return_content=False):
    &#34;&#34;&#34;
    Exports the variable occurrences to a file or returns the content as a string.

    Parameters:
    - filename (str, optional): Path to the output file. Must end with .md, .txt, or .html. Required if return_content is False.
    - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.
    - variables (str or list/tuple, optional): &#39;all&#39;, a single variable string, or a list of variable strings. Defaults to &#39;all&#39;.
    - include_headers (bool, optional): If True, includes headers in the exported content. Defaults to True.
    - return_content (bool, optional): If True, returns the content as a string instead of writing to a file. Defaults to False.

    Returns:
    - str: The exported content as a string if return_content is True.
    - None: Writes to file if return_content is False.

    Raises:
    - ValueError: If &#39;filename&#39; is not provided when return_content is False.
    - ValueError: If &#39;scopes&#39; or &#39;variables&#39; are of incorrect types.
    &#34;&#34;&#34;
    # Determine file extension if filename is provided
    if filename:
        _, ext = os.path.splitext(filename)
        ext = ext.lower()

        if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
            export_format = &#39;markdown&#39;
        elif ext == &#39;.html&#39;:
            export_format = &#39;html&#39;
        else:
            raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)
    elif not return_content:
        raise ValueError(&#34;Filename must be provided if return_content is False.&#34;)

    # Determine scopes
    if isinstance(scopes, str):
        if scopes.lower() == &#39;all&#39;:
            selected_scopes = self.scopes
        else:
            selected_scopes = [scopes.lower()]
    elif isinstance(scopes, (list, tuple)):
        scopes_lower = [s.lower() for s in scopes]
        if &#39;all&#39; in scopes_lower:
            selected_scopes = self.scopes
        else:
            selected_scopes = scopes_lower
    else:
        raise ValueError(&#34;Parameter &#39;scopes&#39; must be a string or a list/tuple of strings.&#34;)

    # Determine variables
    if isinstance(variables, str):
        if variables.lower() == &#39;all&#39;:
            selected_variables = self.variables
        else:
            if variables not in self.variables:
                print(f&#34;Warning: Variable &#39;{variables}&#39; not managed by this instance.&#34;)
                selected_variables = []
            else:
                selected_variables = [variables]
    elif isinstance(variables, (list, tuple)):
        variables_lower = [v for v in variables]
        selected_variables = [v for v in variables_lower if v in self.variables]
        missing_vars = set(variables_lower) - set(selected_variables)
        if missing_vars:
            print(f&#34;Warning: Variables &#39;{&#39;, &#39;.join(missing_vars)}&#39; not managed by this instance.&#34;)
    else:
        raise ValueError(&#34;Parameter &#39;variables&#39; must be a string or a list/tuple of strings.&#34;)

    # Generate content
    content = &#34;&#34;
    if include_headers:
        if export_format == &#39;markdown&#39;:
            content += f&#34;## Variable: `{self.variables[0]}`\n\n&#34; if len(self.variables) == 1 else &#34;&#34;
        elif export_format == &#39;html&#39;:
            content += f&#34;&lt;h2&gt;Variable: {self.variables[0]}&lt;/h2&gt;\n&#34; if len(self.variables) == 1 else &#34;&#34;

    summary = self.summarize()
    for var in selected_variables:
        if include_headers:
            if export_format == &#39;markdown&#39;:
                content += f&#34;### Variable: `{var}`\n\n&#34;
            elif export_format == &#39;html&#39;:
                content += f&#34;&lt;h3&gt;Variable: {var}&lt;/h3&gt;\n&#34;
        var_summary = summary[var]
        for scope, details in var_summary.items():
            if scope not in selected_scopes:
                continue
            if include_headers or True:
                if export_format == &#39;markdown&#39;:
                    content += f&#34;#### Scope: {scope.capitalize()}\n\n&#34;
                elif export_format == &#39;html&#39;:
                    content += f&#34;&lt;h4&gt;Scope: {scope.capitalize()}&lt;/h4&gt;\n&#34;
            # Add content based on format
            if export_format == &#39;markdown&#39;:
                content += f&#34;- **Total Occurrences**: {details[&#39;total_occurrences&#39;]}\n&#34;
                unique_vals_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_values&#39;]))
                content += f&#34;- **Unique Values**: {unique_vals_formatted}\n&#34;
                if details[&#39;unique_elements_in_lists&#39;]:
                    unique_elems_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_elements_in_lists&#39;]))
                    content += f&#34;- **Unique Elements in Lists**: {unique_elems_formatted}\n\n&#34;
                    # Element Counts Table
                    content += &#34;**Element Counts in Lists:**\n\n&#34;
                    content += &#34;| Element | Count |\n&#34;
                    content += &#34;|---------|-------|\n&#34;
                    for elem, count in details[&#39;element_counts_in_lists&#39;].items():
                        content += f&#34;| {elem} | {count} |\n&#34;
                    content += &#34;\n&#34;
            elif export_format == &#39;html&#39;:
                content += &#34;&lt;ul&gt;&#34;
                content += f&#34;&lt;li&gt;&lt;strong&gt;Total Occurrences&lt;/strong&gt;: {details[&#39;total_occurrences&#39;]}&lt;/li&gt;&#34;
                unique_vals_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_values&#39;]))
                content += f&#34;&lt;li&gt;&lt;strong&gt;Unique Values&lt;/strong&gt;: {unique_vals_formatted}&lt;/li&gt;&#34;
                if details[&#39;unique_elements_in_lists&#39;]:
                    unique_elems_formatted = &#39;, &#39;.join(map(str, details[&#39;unique_elements_in_lists&#39;]))
                    content += f&#34;&lt;li&gt;&lt;strong&gt;Unique Elements in Lists&lt;/strong&gt;: {unique_elems_formatted}&lt;/li&gt;&#34;
                content += &#34;&lt;/ul&gt;\n&#34;

                if details[&#39;element_counts_in_lists&#39;]:
                    content += &#34;&lt;h5&gt;Element Counts in Lists:&lt;/h5&gt;\n&#34;
                    content += &#34;&lt;table&gt;\n&lt;tr&gt;&lt;th&gt;Element&lt;/th&gt;&lt;th&gt;Count&lt;/th&gt;&lt;/tr&gt;\n&#34;
                    for elem, count in details[&#39;element_counts_in_lists&#39;].items():
                        content += f&#34;&lt;tr&gt;&lt;td&gt;{elem}&lt;/td&gt;&lt;td&gt;{count}&lt;/td&gt;&lt;/tr&gt;\n&#34;
                    content += &#34;&lt;/table&gt;\n&#34;

        # Add a horizontal line between variables
        if include_headers and len(selected_variables) &gt; 1:
            if export_format == &#39;markdown&#39;:
                content += &#34;\n---\n\n&#34;
            elif export_format == &#39;html&#39;:
                content += &#34;&lt;hr/&gt;\n&#34;

    # Handle format-specific headers
    if return_content:
        if export_format == &#39;markdown&#39;:
            return content
        elif export_format == &#39;html&#39;:
            return f&#34;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#39;UTF-8&#39;&gt;&lt;title&gt;Variable Report&lt;/title&gt;&lt;/head&gt;&lt;body&gt;{content}&lt;/body&gt;&lt;/html&gt;&#34;
    else:
        if not filename:
            raise ValueError(&#34;Filename must be provided if return_content is False.&#34;)

        # Determine export format based on file extension
        if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
            export_format = &#39;markdown&#39;
        elif ext == &#39;.html&#39;:
            export_format = &#39;html&#39;
        else:
            raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

        # Prepare full content for HTML
        if export_format == &#39;html&#39; and not include_headers:
            full_content = f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Variable Report&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n{content}\n&lt;/body&gt;\n&lt;/html&gt;&#34;
        else:
            full_content = content

        # Write to file
        try:
            with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                file.write(full_content)
            print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
        except Exception as e:
            raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="script.VariableOccurrences.get_all_elements_in_lists"><code class="name flex">
<span>def <span class="ident">get_all_elements_in_lists</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves all unique elements within list-type variable values.</p>
<p>Returns:
- A dict mapping each variable to its set of unique elements in lists per scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_elements_in_lists(self):
    &#34;&#34;&#34;
    Retrieves all unique elements within list-type variable values.

    Returns:
    - A dict mapping each variable to its set of unique elements in lists per scope.
    &#34;&#34;&#34;
    result = {}
    for var in self.variables:
        var_elements = {}
        for scope, occurrences in self.data[var].items():
            unique_elems = set()
            if is_scalar(occurrences):
                if isinstance(occurrences, list):
                    unique_elems.update(occurrences)
            elif isinstance(occurrences, list):
                for item in occurrences:
                    if isinstance(item, tuple) and len(item) == 2:
                        _, val = item
                        if isinstance(val, list):
                            unique_elems.update(val)
                    elif isinstance(item, list):
                        unique_elems.update(item)
            var_elements[scope] = unique_elems
        result[var] = var_elements
    return result</code></pre>
</details>
</dd>
<dt id="script.VariableOccurrences.get_all_values"><code class="name flex">
<span>def <span class="ident">get_all_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves all unique values of the variable(s).</p>
<p>Returns:
- A dict mapping each variable to its set of unique values per scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_values(self):
    &#34;&#34;&#34;
    Retrieves all unique values of the variable(s).

    Returns:
    - A dict mapping each variable to its set of unique values per scope.
    &#34;&#34;&#34;
    result = {}
    for var in self.variables:
        var_unique = {}
        for scope, occurrences in self.data[var].items():
            unique_vals = set()
            if is_scalar(occurrences):
                unique_vals.add(occurrences)
            elif isinstance(occurrences, list):
                for item in occurrences:
                    if isinstance(item, tuple) and len(item) == 2:
                        _, val = item
                        hashable_val = make_hashable(val)
                        unique_vals.add(hashable_val)
                    else:
                        hashable_val = make_hashable(item)
                        unique_vals.add(hashable_val)
            var_unique[scope] = unique_vals
        result[var] = var_unique
    return result</code></pre>
</details>
</dd>
<dt id="script.VariableOccurrences.get_raw_data"><code class="name flex">
<span>def <span class="ident">get_raw_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the raw data.</p>
<p>Returns:
- The raw data as provided during initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_data(self):
    &#34;&#34;&#34;
    Returns the raw data.

    Returns:
    - The raw data as provided during initialization.
    &#34;&#34;&#34;
    return self.data</code></pre>
</details>
</dd>
<dt id="script.VariableOccurrences.get_steps_with_value"><code class="name flex">
<span>def <span class="ident">get_steps_with_value</span></span>(<span>self, value, within_list=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the steps where the variable equals the specified value.</p>
<p>Parameters:
- value: The value to search for.
- within_list (bool): If True, searches for the value within list-type variable values.</p>
<p>Returns:
- If single variable:
- A dict with scopes as keys and lists of step indices or values as values.
- If multiple variables:
- A dict mapping each variable name to their respective scope-step/value mappings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_steps_with_value(self, value, within_list=False):
    &#34;&#34;&#34;
    Retrieves the steps where the variable equals the specified value.

    Parameters:
    - value: The value to search for.
    - within_list (bool): If True, searches for the value within list-type variable values.

    Returns:
    - If single variable:
        - A dict with scopes as keys and lists of step indices or values as values.
    - If multiple variables:
        - A dict mapping each variable name to their respective scope-step/value mappings.
    &#34;&#34;&#34;
    result = {}
    for var in self.variables:
        var_result = {}
        for scope, occurrences in self.data[var].items():
            if is_scalar(occurrences):
                # Scalar value
                if within_list:
                    continue  # Cannot search within a scalar
                if occurrences == value:
                    var_result[scope] = occurrences
            elif isinstance(occurrences, list):
                # List of values or list of tuples
                steps = []
                for item in occurrences:
                    if isinstance(item, tuple) and len(item) == 2:
                        step, val = item
                        if within_list:
                            if isinstance(val, list) and value in val:
                                steps.append(step)
                        else:
                            if val == value:
                                steps.append(step)
                    else:
                        # List of values
                        if within_list:
                            if isinstance(item, list) and value in item:
                                steps.append(item)
                        else:
                            if item == value:
                                steps.append(item)
                if steps:
                    var_result[scope] = steps
            else:
                # Other types (e.g., dict), can be extended as needed
                pass
        if var_result:
            result[var] = var_result
    return result</code></pre>
</details>
</dd>
<dt id="script.VariableOccurrences.get_steps_with_value_in_scope"><code class="name flex">
<span>def <span class="ident">get_steps_with_value_in_scope</span></span>(<span>self, variable, scope, value, within_list=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the steps within a specific scope where the variable equals the specified value.</p>
<p>Parameters:
- variable (str): The variable name.
- scope (str): The scope to search within ("static", "global", "local").
- value: The value to search for.
- within_list (bool): If True, searches for the value within list-type variable values.</p>
<p>Returns:
- A list of step indices or values where the variable equals the value within the specified scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_steps_with_value_in_scope(self, variable, scope, value, within_list=False):
    &#34;&#34;&#34;
    Retrieves the steps within a specific scope where the variable equals the specified value.

    Parameters:
    - variable (str): The variable name.
    - scope (str): The scope to search within (&#34;static&#34;, &#34;global&#34;, &#34;local&#34;).
    - value: The value to search for.
    - within_list (bool): If True, searches for the value within list-type variable values.

    Returns:
    - A list of step indices or values where the variable equals the value within the specified scope.
    &#34;&#34;&#34;
    if variable not in self.variables:
        raise ValueError(f&#34;Variable &#39;{variable}&#39; is not managed by this instance.&#34;)

    scope = scope.lower()
    occurrences = self.data[variable].get(scope, [])
    steps = []

    if is_scalar(occurrences):
        if within_list:
            if isinstance(occurrences, list) and value in occurrences:
                steps.append(occurrences)
        else:
            if occurrences == value:
                steps.append(occurrences)
    elif isinstance(occurrences, list):
        for item in occurrences:
            if isinstance(item, tuple) and len(item) == 2:
                step, val = item
                if within_list:
                    if isinstance(val, list) and value in val:
                        steps.append(step)
                else:
                    if val == value:
                        steps.append(step)
            else:
                if within_list:
                    if isinstance(item, list) and value in item:
                        steps.append(item)
                else:
                    if item == value:
                        steps.append(item)
    return steps</code></pre>
</details>
</dd>
<dt id="script.VariableOccurrences.get_usage_count"><code class="name flex">
<span>def <span class="ident">get_usage_count</span></span>(<span>self, value, within_list=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Counts how many times a specific value is used.</p>
<p>Parameters:
- value: The value to count.
- within_list (bool): If True, counts occurrences within list-type variable values.</p>
<p>Returns:
- If single variable:
- A dict with scopes as keys and integer counts or counts of values as values.
- If multiple variables:
- A dict mapping each variable name to their respective scope-count/value mappings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_usage_count(self, value, within_list=False):
    &#34;&#34;&#34;
    Counts how many times a specific value is used.

    Parameters:
    - value: The value to count.
    - within_list (bool): If True, counts occurrences within list-type variable values.

    Returns:
    - If single variable:
        - A dict with scopes as keys and integer counts or counts of values as values.
    - If multiple variables:
        - A dict mapping each variable name to their respective scope-count/value mappings.
    &#34;&#34;&#34;
    result = {}
    for var in self.variables:
        var_count = {}
        for scope, occurrences in self.data[var].items():
            count = 0
            if is_scalar(occurrences):
                if within_list:
                    if isinstance(occurrences, list) and value in occurrences:
                        count += 1
                else:
                    if occurrences == value:
                        count += 1
            elif isinstance(occurrences, list):
                for item in occurrences:
                    if isinstance(item, tuple) and len(item) == 2:
                        _, val = item
                        if within_list:
                            if isinstance(val, list) and value in val:
                                count += 1
                        else:
                            if val == value:
                                count += 1
                    else:
                        if within_list:
                            if isinstance(item, list) and value in item:
                                count += 1
                        else:
                            if item == value:
                                count += 1
            if count &gt; 0:
                var_count[scope] = count
        if var_count:
            result[var] = var_count
    return result</code></pre>
</details>
</dd>
<dt id="script.VariableOccurrences.summarize"><code class="name flex">
<span>def <span class="ident">summarize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides a summary of the variable occurrences.</p>
<p>Returns:
- A dict mapping each variable to their respective summaries per scope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summarize(self):
    &#34;&#34;&#34;
    Provides a summary of the variable occurrences.

    Returns:
    - A dict mapping each variable to their respective summaries per scope.
    &#34;&#34;&#34;
    summary = {}
    for var in self.variables:
        var_summary = {}
        for scope, occurrences in self.data[var].items():
            unique_vals = set()
            unique_elements = set()
            value_counts = defaultdict(int)
            element_counts = defaultdict(int)

            if is_scalar(occurrences):
                # Scalar value
                hashable_val = make_hashable(occurrences)
                unique_vals.add(hashable_val)
                value_counts[hashable_val] += 1
                if isinstance(occurrences, list):
                    unique_elements.update(occurrences)
                    for elem in occurrences:
                        element_counts[elem] += 1
            elif isinstance(occurrences, list):
                for item in occurrences:
                    if isinstance(item, tuple) and len(item) == 2:
                        # Tuple: (step, value)
                        step, val = item
                        hashable_val = make_hashable(val)
                        unique_vals.add(hashable_val)
                        value_counts[hashable_val] += 1
                        if isinstance(val, list):
                            unique_elements.update(val)
                            for elem in val:
                                element_counts[elem] += 1
                        elif isinstance(val, dict):
                            # Handle nested dictionaries if necessary
                            for sub_val in val.values():
                                if isinstance(sub_val, list):
                                    unique_elements.update(sub_val)
                                    for elem in sub_val:
                                        element_counts[elem] += 1
                    else:
                        # Direct value
                        hashable_val = make_hashable(item)
                        unique_vals.add(hashable_val)
                        value_counts[hashable_val] += 1
                        if isinstance(item, list):
                            unique_elements.update(item)
                            for elem in item:
                                element_counts[elem] += 1
                        elif isinstance(item, dict):
                            for sub_val in item.values():
                                if isinstance(sub_val, list):
                                    unique_elements.update(sub_val)
                                    for elem in sub_val:
                                        element_counts[elem] += 1
            else:
                # Other types can be handled here if needed
                pass

            var_summary[scope] = {
                &#34;total_occurrences&#34;: len(occurrences),
                &#34;unique_values&#34;: unique_vals,
                &#34;unique_elements_in_lists&#34;: unique_elements,
                &#34;value_counts&#34;: dict(value_counts),
                &#34;element_counts_in_lists&#34;: dict(element_counts)
            }
        summary[var] = var_summary
    return summary</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="script.boundarysection"><code class="flex name class">
<span>class <span class="ident">boundarysection</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>LAMMPS script: boundary session </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class boundarysection(script):
    &#34;&#34;&#34; LAMMPS script: boundary session &#34;&#34;&#34;
    name = &#34;boundary&#34;
    description = name+&#34; section&#34;
    position = 4
    section = 5
    userid = &#34;example&#34;
    version = 0.1

    # inherit properties from geometrysection
    DEFINITIONS = geometrysection.DEFINITIONS + scriptdata(
        gravity = -9.81,
        vector = &#34;$ 0 1 0&#34;
        )

    TEMPLATE = &#34;&#34;&#34;
# :BOUNDARY SECTION:
#   boundary section

    ####################################################################################################
    # DEFINE BOUNDARY CONDITIONS
    #
    # note that the the particles constituting the mouth are simply not integrated in time,
    # thus these particles never move. This is equivalent to a fixed displacement boundary condition.
    ####################################################################################################
    fix             gfix allheavy gravity ${gravity} vector ${vector} # add gravity


    ####################################################################################################
    # moving top &#34;tongue&#34; (to2)
    ####################################################################################################
    variable vmouth equal -${crunchv}*sin(${crunchw}*time)
    fix             move_fix_tongue2 tongue2 smd/setvel 0 v_vmouth 0

    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="script.script" href="#script.script">script</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.boundarysection.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.boundarysection.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.boundarysection.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.boundarysection.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.boundarysection.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.boundarysection.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.boundarysection.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.boundarysection.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="script.script" href="#script.script">script</a></b></code>:
<ul class="hlist">
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="script.discretizationsection"><code class="flex name class">
<span>class <span class="ident">discretizationsection</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>LAMMPS script: discretization session </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class discretizationsection(script):
    &#34;&#34;&#34; LAMMPS script: discretization session &#34;&#34;&#34;
    name = &#34;discretization&#34;
    description = name+&#34; section&#34;
    position = 3
    section = 4
    userid = &#34;example&#34;
    version = 0.1

    # inherit properties from geometrysection
    DEFINITIONS = geometrysection.DEFINITIONS + scriptdata(
              h= &#34;2.5*${l0} # SPH kernel diameter&#34;,
        vol_one= &#34;${l0}^2 # initial particle volume for 2d simulation&#34;,
     rho_saliva= 1000,
        rho_obj= 1300,
           skin= &#34;${h} # Verlet list range&#34;,
  contact_scale= 1.5
        )

    TEMPLATE = &#34;&#34;&#34;
# :DISCRETIZATION SECTION:
#   discretization

    ####################################################################################################
    # DISCRETIZATION PARAMETERS
    ####################################################################################################
    set             group all diameter ${h}
    set             group all smd/contact/radius ${l0}
    set             group all volume  ${vol_one}
    set             group all smd/mass/density ${rho_saliva}
    set             group solidfoods smd/mass/density ${rho_obj}
    set             group tongue1 smd/mass/density ${rho_obj}
    set             group tongue2 smd/mass/density ${rho_obj}
    neighbor        ${skin} bin

    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="script.script" href="#script.script">script</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.discretizationsection.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.discretizationsection.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.discretizationsection.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.discretizationsection.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.discretizationsection.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.discretizationsection.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.discretizationsection.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.discretizationsection.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="script.script" href="#script.script">script</a></b></code>:
<ul class="hlist">
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="script.dumpsection"><code class="flex name class">
<span>class <span class="ident">dumpsection</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>LAMMPS script: dump session </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dumpsection(script):
    &#34;&#34;&#34; LAMMPS script: dump session &#34;&#34;&#34;
    name = &#34;dump&#34;
    description = name+&#34; section&#34;
    position = 7
    section = 8
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = globalsection().DEFINITIONS

    TEMPLATE = &#34;&#34;&#34;
# :DUMP SECTION:
#   Dump configuration

    ####################################################################################################
    # SPECIFY TRAJECTORY OUTPUT
    ####################################################################################################
    compute         eint all smd/internal/energy
    compute         contact_radius all smd/contact/radius
    compute         S solidfoods smd/tlsph/stress
    compute         nn saliva smd/ulsph/num/neighs
    compute         epl solidfoods smd/plastic/strain
    compute         vol all smd/vol
    compute         rho all smd/rho

    dump            dump_id all custom ${outstep} ${outputfile} id type x y &amp;
                    fx fy vx vy c_eint c_contact_radius mol &amp;
                    c_S[1] c_S[2] c_S[4] mass radius c_epl c_vol c_rho c_nn proc
    dump_modify     dump_id first yes

    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="script.script" href="#script.script">script</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.dumpsection.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.dumpsection.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.dumpsection.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.dumpsection.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.dumpsection.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.dumpsection.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.dumpsection.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.dumpsection.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="script.script" href="#script.script">script</a></b></code>:
<ul class="hlist">
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="script.forcefield"><code class="flex name class">
<span>class <span class="ident">forcefield</span></span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="script.forcefield" href="#script.forcefield">forcefield</a></code> class represents the core implementation of a forcefield model,
defining interaction parameters and coefficients for simulations. This class provides
methods to handle pair styles, diagonal pair coefficients, and off-diagonal pair coefficients,
which are essential for simulating inter-particle interactions in molecular dynamics or
other physics-based simulations.</p>
<h2 id="attributes">Attributes:</h2>
<p>PAIR_STYLE : str
The default pair style command for the forcefield interactions.</p>
<p>PAIR_DIAGCOEFF : str
The default command for calculating diagonal pair coefficients.</p>
<p>PAIR_OFFDIAGCOEFF : str
The default command for calculating off-diagonal pair coefficients.</p>
<p>parameters : parameterforcefield
An instance of <code><a title="script.parameterforcefield" href="#script.parameterforcefield">parameterforcefield</a></code> that stores the parameters for
evaluating interaction commands.</p>
<p>beadtype : int
The bead type associated with the current forcefield instance.</p>
<p>userid : str
A unique identifier for the forcefield instance, used in interaction commands.</p>
<h2 id="methods">Methods:</h2>
<p>pair_style(printflag=True):
Generate and return the pair style command based on the current parameters,
beadtype, and userid.</p>
<p>pair_diagcoeff(printflag=True, i=None):
Generate and return the diagonal pair coefficients based on the current parameters,
beadtype, and userid. The bead type <code>i</code> can be overridden with an optional argument.</p>
<p>pair_offdiagcoeff(o=None, printflag=True, i=None):
Generate and return the off-diagonal pair coefficients between two different
bead types or forcefield objects. The bead type <code>i</code> can be overridden, and the
interaction with another forcefield object <code>o</code> can also be specified.</p>
<h2 id="notes">Notes:</h2>
<ul>
<li>This class is intended to be extended by specific forcefield types such as <code><a title="script.ulsph" href="#script.ulsph">ulsph</a></code>.</li>
<li>The parameters used in the interaction commands are dynamically evaluated using
the <code><a title="script.parameterforcefield" href="#script.parameterforcefield">parameterforcefield</a></code> class, which provides the required values during runtime.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class forcefield():
    &#34;&#34;&#34;
    The `forcefield` class represents the core implementation of a forcefield model,
    defining interaction parameters and coefficients for simulations. This class provides
    methods to handle pair styles, diagonal pair coefficients, and off-diagonal pair coefficients,
    which are essential for simulating inter-particle interactions in molecular dynamics or
    other physics-based simulations.

    Attributes:
    -----------
    PAIR_STYLE : str
        The default pair style command for the forcefield interactions.

    PAIR_DIAGCOEFF : str
        The default command for calculating diagonal pair coefficients.

    PAIR_OFFDIAGCOEFF : str
        The default command for calculating off-diagonal pair coefficients.

    parameters : parameterforcefield
        An instance of `parameterforcefield` that stores the parameters for
        evaluating interaction commands.

    beadtype : int
        The bead type associated with the current forcefield instance.

    userid : str
        A unique identifier for the forcefield instance, used in interaction commands.

    Methods:
    --------
    pair_style(printflag=True):
        Generate and return the pair style command based on the current parameters,
        beadtype, and userid.

    pair_diagcoeff(printflag=True, i=None):
        Generate and return the diagonal pair coefficients based on the current parameters,
        beadtype, and userid. The bead type `i` can be overridden with an optional argument.

    pair_offdiagcoeff(o=None, printflag=True, i=None):
        Generate and return the off-diagonal pair coefficients between two different
        bead types or forcefield objects. The bead type `i` can be overridden, and the
        interaction with another forcefield object `o` can also be specified.

    Notes:
    ------
    - This class is intended to be extended by specific forcefield types such as `ulsph`.
    - The parameters used in the interaction commands are dynamically evaluated using
      the `parameterforcefield` class, which provides the required values during runtime.
    &#34;&#34;&#34;

    # Main attributes (instance independent)
    name = struct(forcefield=&#34;undefined&#34;, style=&#34;undefined&#34;, material=&#34;undefined&#34;)
    description = struct(forcefield=&#34;missing&#34;, style=&#34;missing&#34;, material=&#34;missing&#34;)
    beadtype = 1  # default bead type
    parameters = parameterforcefield() # empty parameters object
    userid = &#34;undefined&#34;
    version = 0

    # print method for headers (static, no implicit argument)
    @staticmethod
    def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
        &#34;&#34;&#34; print header &#34;&#34;&#34;
        if txt==&#34;&#34;:
            print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
        else:
            print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))

    # Display/representation method
    # The method provides full help for the end-user
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        stamp = self.name.forcefield+&#34;:&#34;+self.name.style+&#34;:&#34;+self.name.material
        self.printheader(&#34;%s | version=%0.3g&#34; % (self.userid,self.version),filler=&#34;=&#34;)
        print(&#34;  Bead of type %d = [%s]&#34; % (self.beadtype,stamp))
        print(self.parameters)
        self.printheader(&#34;description&#34;,filler=&#34;.&#34;)
        print(&#34;\t# \t%s&#34; % self.description.forcefield)
        print(&#34;\t# \t%s&#34; % self.description.style)
        print(&#34;\t# \t%s&#34; % self.description.material)
        self.printheader(&#34;methods&#34;)
        print(&#34;\t   &gt;&gt;&gt; replace FFi,FFj by your variable names &lt;&lt;&lt;&#34;)
        print(&#34;\tTo assign a type, use: FFi.beadtype = integer value&#34;)
        print(&#34;\tUse the methods FFi.pair_style() and FFi.pair_coeff(FFj)&#34;)
        print(&#34;\tNote for pairs: the caller object is i (FFi), the argument is j (FFj or j)&#34;)
        self.printheader(&#34;template&#34;)
        self.pair_style()
        self.pair_diagcoeff()
        self.pair_offdiagcoeff()
        self.printheader(&#34;&#34;)
        return stamp

    # Extract attributes within the class
    def getallattributes(self):
        &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
        return {k: getattr(self, k) for k in dir(self) \
                if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}


    # Forcefield Methods: pair_style(), pair_coeff()
    # the substitution of LAMMPS variables is carried out with the method
    # parameters.format() method implemented in struct and inherited by parameterforcefield()
    def pair_style(self,printflag=False,verbose=True, raw=False,USER=None,beadtype=None,userid=None):
        &#34;&#34;&#34;
        Generate and return the pair style command for the current forcefield instance.

        This method creates a formatted pair style command based on the interaction parameters
        stored in the `parameters` attribute. It allows customization of the command using the
        `beadtype` and `userid` arguments. The behavior can be altered by passing a `USER` object
        or opting for the raw command template.

        Parameters:
        -----------
        printflag : bool, optional, default=False
            If True, the generated pair style command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        raw : bool, optional, default=False
            If True, returns the raw template of the pair style without any interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier used in the generated command. If not provided, the
            instance&#39;s beadtype is used.
        userid : str, optional, default=None
            The user identifier to include in the formatted command. Defaults to the instance&#39;s
            userid if not specified.

        Returns:
        --------
        str
            The formatted pair style command string.

        Raises:
        -------
        TypeError
            If `USER` is provided but is not of type `struct` or derived from `struct`.
        &#34;&#34;&#34;
        # raw format
        if raw:
            return self.PAIR_STYLE
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # cmd
        cmd = parameters.formateval(self.PAIR_STYLE)
        # Replace [comment] with the formatted comment (e.g., &#34;[2:my_user_id]&#34;)
        cmd = cmd.replace(&#34;[comment]&#34;,&#34;[%d:%s]&#34; % (beadtype, userid) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


    def pair_diagcoeff(self,printflag=False,verbose=True, i=None,raw=False,USER=None,beadtype=None,userid=None):
        &#34;&#34;&#34;
        Generate and return the diagonal pair coefficients for the current forcefield instance.

        This method evaluates the diagonal pair coefficients based on the interaction parameters,
        the bead type (`beadtype`), and the user identifier (`userid`). The bead type `i` can
        be overridden by passing it as an argument. The method supports returning the raw template
        without evaluation and modifying parameters using a `USER` object.

        Parameters:
        -----------
        printflag : bool, optional, default=False
            If True, the generated diagonal pair coefficient command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        i : int, optional, default=None
            The bead type used for evaluating the diagonal pair coefficients. If not provided,
            defaults to the instance&#39;s bead type (`self.beadtype`).
        raw : bool, optional, default=False
            If True, returns the raw template for the diagonal pair coefficients without interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier to use in the command. Defaults to the instance&#39;s beadtype
            if not provided.
        userid : str, optional, default=None
            The user identifier to include in the formatted command. Defaults to the instance&#39;s
            userid if not specified.

        Returns:
        --------
        str
            The formatted diagonal pair coefficient command string.

        Raises:
        -------
        TypeError
            If `USER` is provided but is not of type `struct` or derived from `struct`.
        &#34;&#34;&#34;
        # raw format
        if raw:
            return self.PAIR_DIAGCOEFF
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # diagonal index
        i = i if i is not None else beadtype
        # cmd
        cmd = parameters.formateval(self.PAIR_DIAGCOEFF) % (i,i)
        # Replace [comment] with the formatted string, without using .format()
        cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, userid, i, userid) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


    def pair_offdiagcoeff(self,o=None,printflag=False,verbose=True,i=None,raw=False,USER=None,beadtype=None,userid=None,oname=None):
        &#34;&#34;&#34;
        Generate and return the off-diagonal pair coefficients for the current forcefield instance.

        This method evaluates the off-diagonal pair coefficients between two different bead types
        or forcefield objects, using the interaction parameters, bead type, and user identifier.
        The bead type `i` can be overridden, and the interaction with another forcefield object `o`
        can also be specified.

        Parameters:
        -----------
        o : forcefield or int, optional, default=None
            The second forcefield object or bead type used for calculating the off-diagonal
            pair coefficients. If not provided, the method assumes interactions between
            beads of the same type.
        printflag : bool, optional, default=False
            If True, the generated off-diagonal pair coefficient command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        i : int, optional, default=None
            The bead type used for the current forcefield instance. If not provided,
            defaults to the instance&#39;s bead type (`self.beadtype`).
        raw : bool, optional, default=False
            If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier used in the command. Defaults to the instance&#39;s beadtype
            if not provided.
        userid : str, optional, default=None
            The user identifier included in the formatted command. Defaults to the instance&#39;s
            userid if not specified.
        oname : str, optional, default=None
            The user identifier for the second forcefield or bead type. If not provided, it
            defaults to `&#34;none&#34;`.

        Returns:
        --------
        str
            The formatted off-diagonal pair coefficient command string.

        Raises:
        -------
        TypeError
            If `USER` is not of type `struct` or derived from `struct`.
        IndexError
            If the first argument `o` is not a forcefield object or an integer.
        &#34;&#34;&#34;

        # raw format
        if raw:
            return self.PAIR_OFFDIAGCOEFF
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
            i = i if i is not None else beadtype
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # Determine the first bead type (i)
        i = i if i is not None else beadtype
        # Determine the second bead type (j) based on o
        if o is None:
            j = i
        elif hasattr(o, &#39;beadtype&#39;):
            j = o.beadtype
        elif isinstance(o, (float, int)):
            j = int(o)
        else:
            raise IndexError(&#34;The first argument should be a forcefield object or an integer representing bead type.&#34;)
        # Adjust j if it matches i (to ensure off-diagonal interaction)
        if j == i:
            j = i - 1 if i &gt; 1 else i + 1
        oname = oname if oname is not None else o.userid if hasattr(o, &#34;userid&#34;) else &#34;none&#34;
        # cmd
        cmd = parameters.formateval(self.PAIR_OFFDIAGCOEFF) % (min(i,j),max(j,i))
        # Replace [comment] with the formatted string, without using .format()
        cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, self.userid, j, oname) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.smd</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.forcefield.beadtype"><code class="name">var <span class="ident">beadtype</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.forcefield.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.forcefield.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.forcefield.parameters"><code class="name">var <span class="ident">parameters</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.forcefield.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.forcefield.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="script.forcefield.printheader"><code class="name flex">
<span>def <span class="ident">printheader</span></span>(<span>txt, align='^', width=80, filler='~')</span>
</code></dt>
<dd>
<div class="desc"><p>print header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
    &#34;&#34;&#34; print header &#34;&#34;&#34;
    if txt==&#34;&#34;:
        print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
    else:
        print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="script.forcefield.getallattributes"><code class="name flex">
<span>def <span class="ident">getallattributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>advanced method to get all attributes including class ones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getallattributes(self):
    &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
    return {k: getattr(self, k) for k in dir(self) \
            if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}</code></pre>
</details>
</dd>
<dt id="script.forcefield.pair_diagcoeff"><code class="name flex">
<span>def <span class="ident">pair_diagcoeff</span></span>(<span>self, printflag=False, verbose=True, i=None, raw=False, USER=None, beadtype=None, userid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the diagonal pair coefficients for the current forcefield instance.</p>
<p>This method evaluates the diagonal pair coefficients based on the interaction parameters,
the bead type (<code>beadtype</code>), and the user identifier (<code>userid</code>). The bead type <code>i</code> can
be overridden by passing it as an argument. The method supports returning the raw template
without evaluation and modifying parameters using a <code>USER</code> object.</p>
<h2 id="parameters">Parameters:</h2>
<p>printflag : bool, optional, default=False
If True, the generated diagonal pair coefficient command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
i : int, optional, default=None
The bead type used for evaluating the diagonal pair coefficients. If not provided,
defaults to the instance's bead type (<code>self.beadtype</code>).
raw : bool, optional, default=False
If True, returns the raw template for the diagonal pair coefficients without interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier to use in the command. Defaults to the instance's beadtype
if not provided.
userid : str, optional, default=None
The user identifier to include in the formatted command. Defaults to the instance's
userid if not specified.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted diagonal pair coefficient command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is provided but is not of type <code><a title="script.struct" href="#script.struct">struct</a></code> or derived from <code><a title="script.struct" href="#script.struct">struct</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_diagcoeff(self,printflag=False,verbose=True, i=None,raw=False,USER=None,beadtype=None,userid=None):
    &#34;&#34;&#34;
    Generate and return the diagonal pair coefficients for the current forcefield instance.

    This method evaluates the diagonal pair coefficients based on the interaction parameters,
    the bead type (`beadtype`), and the user identifier (`userid`). The bead type `i` can
    be overridden by passing it as an argument. The method supports returning the raw template
    without evaluation and modifying parameters using a `USER` object.

    Parameters:
    -----------
    printflag : bool, optional, default=False
        If True, the generated diagonal pair coefficient command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    i : int, optional, default=None
        The bead type used for evaluating the diagonal pair coefficients. If not provided,
        defaults to the instance&#39;s bead type (`self.beadtype`).
    raw : bool, optional, default=False
        If True, returns the raw template for the diagonal pair coefficients without interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier to use in the command. Defaults to the instance&#39;s beadtype
        if not provided.
    userid : str, optional, default=None
        The user identifier to include in the formatted command. Defaults to the instance&#39;s
        userid if not specified.

    Returns:
    --------
    str
        The formatted diagonal pair coefficient command string.

    Raises:
    -------
    TypeError
        If `USER` is provided but is not of type `struct` or derived from `struct`.
    &#34;&#34;&#34;
    # raw format
    if raw:
        return self.PAIR_DIAGCOEFF
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # diagonal index
    i = i if i is not None else beadtype
    # cmd
    cmd = parameters.formateval(self.PAIR_DIAGCOEFF) % (i,i)
    # Replace [comment] with the formatted string, without using .format()
    cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, userid, i, userid) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="script.forcefield.pair_offdiagcoeff"><code class="name flex">
<span>def <span class="ident">pair_offdiagcoeff</span></span>(<span>self, o=None, printflag=False, verbose=True, i=None, raw=False, USER=None, beadtype=None, userid=None, oname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the off-diagonal pair coefficients for the current forcefield instance.</p>
<p>This method evaluates the off-diagonal pair coefficients between two different bead types
or forcefield objects, using the interaction parameters, bead type, and user identifier.
The bead type <code>i</code> can be overridden, and the interaction with another forcefield object <code>o</code>
can also be specified.</p>
<h2 id="parameters">Parameters:</h2>
<p>o : forcefield or int, optional, default=None
The second forcefield object or bead type used for calculating the off-diagonal
pair coefficients. If not provided, the method assumes interactions between
beads of the same type.
printflag : bool, optional, default=False
If True, the generated off-diagonal pair coefficient command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
i : int, optional, default=None
The bead type used for the current forcefield instance. If not provided,
defaults to the instance's bead type (<code>self.beadtype</code>).
raw : bool, optional, default=False
If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier used in the command. Defaults to the instance's beadtype
if not provided.
userid : str, optional, default=None
The user identifier included in the formatted command. Defaults to the instance's
userid if not specified.
oname : str, optional, default=None
The user identifier for the second forcefield or bead type. If not provided, it
defaults to <code>"none"</code>.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted off-diagonal pair coefficient command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is not of type <code><a title="script.struct" href="#script.struct">struct</a></code> or derived from <code><a title="script.struct" href="#script.struct">struct</a></code>.
IndexError
If the first argument <code>o</code> is not a forcefield object or an integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_offdiagcoeff(self,o=None,printflag=False,verbose=True,i=None,raw=False,USER=None,beadtype=None,userid=None,oname=None):
    &#34;&#34;&#34;
    Generate and return the off-diagonal pair coefficients for the current forcefield instance.

    This method evaluates the off-diagonal pair coefficients between two different bead types
    or forcefield objects, using the interaction parameters, bead type, and user identifier.
    The bead type `i` can be overridden, and the interaction with another forcefield object `o`
    can also be specified.

    Parameters:
    -----------
    o : forcefield or int, optional, default=None
        The second forcefield object or bead type used for calculating the off-diagonal
        pair coefficients. If not provided, the method assumes interactions between
        beads of the same type.
    printflag : bool, optional, default=False
        If True, the generated off-diagonal pair coefficient command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    i : int, optional, default=None
        The bead type used for the current forcefield instance. If not provided,
        defaults to the instance&#39;s bead type (`self.beadtype`).
    raw : bool, optional, default=False
        If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier used in the command. Defaults to the instance&#39;s beadtype
        if not provided.
    userid : str, optional, default=None
        The user identifier included in the formatted command. Defaults to the instance&#39;s
        userid if not specified.
    oname : str, optional, default=None
        The user identifier for the second forcefield or bead type. If not provided, it
        defaults to `&#34;none&#34;`.

    Returns:
    --------
    str
        The formatted off-diagonal pair coefficient command string.

    Raises:
    -------
    TypeError
        If `USER` is not of type `struct` or derived from `struct`.
    IndexError
        If the first argument `o` is not a forcefield object or an integer.
    &#34;&#34;&#34;

    # raw format
    if raw:
        return self.PAIR_OFFDIAGCOEFF
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
        i = i if i is not None else beadtype
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # Determine the first bead type (i)
    i = i if i is not None else beadtype
    # Determine the second bead type (j) based on o
    if o is None:
        j = i
    elif hasattr(o, &#39;beadtype&#39;):
        j = o.beadtype
    elif isinstance(o, (float, int)):
        j = int(o)
    else:
        raise IndexError(&#34;The first argument should be a forcefield object or an integer representing bead type.&#34;)
    # Adjust j if it matches i (to ensure off-diagonal interaction)
    if j == i:
        j = i - 1 if i &gt; 1 else i + 1
    oname = oname if oname is not None else o.userid if hasattr(o, &#34;userid&#34;) else &#34;none&#34;
    # cmd
    cmd = parameters.formateval(self.PAIR_OFFDIAGCOEFF) % (min(i,j),max(j,i))
    # Replace [comment] with the formatted string, without using .format()
    cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, self.userid, j, oname) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="script.forcefield.pair_style"><code class="name flex">
<span>def <span class="ident">pair_style</span></span>(<span>self, printflag=False, verbose=True, raw=False, USER=None, beadtype=None, userid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the pair style command for the current forcefield instance.</p>
<p>This method creates a formatted pair style command based on the interaction parameters
stored in the <code>parameters</code> attribute. It allows customization of the command using the
<code>beadtype</code> and <code>userid</code> arguments. The behavior can be altered by passing a <code>USER</code> object
or opting for the raw command template.</p>
<h2 id="parameters">Parameters:</h2>
<p>printflag : bool, optional, default=False
If True, the generated pair style command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
raw : bool, optional, default=False
If True, returns the raw template of the pair style without any interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier used in the generated command. If not provided, the
instance's beadtype is used.
userid : str, optional, default=None
The user identifier to include in the formatted command. Defaults to the instance's
userid if not specified.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted pair style command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is provided but is not of type <code><a title="script.struct" href="#script.struct">struct</a></code> or derived from <code><a title="script.struct" href="#script.struct">struct</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_style(self,printflag=False,verbose=True, raw=False,USER=None,beadtype=None,userid=None):
    &#34;&#34;&#34;
    Generate and return the pair style command for the current forcefield instance.

    This method creates a formatted pair style command based on the interaction parameters
    stored in the `parameters` attribute. It allows customization of the command using the
    `beadtype` and `userid` arguments. The behavior can be altered by passing a `USER` object
    or opting for the raw command template.

    Parameters:
    -----------
    printflag : bool, optional, default=False
        If True, the generated pair style command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    raw : bool, optional, default=False
        If True, returns the raw template of the pair style without any interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier used in the generated command. If not provided, the
        instance&#39;s beadtype is used.
    userid : str, optional, default=None
        The user identifier to include in the formatted command. Defaults to the instance&#39;s
        userid if not specified.

    Returns:
    --------
    str
        The formatted pair style command string.

    Raises:
    -------
    TypeError
        If `USER` is provided but is not of type `struct` or derived from `struct`.
    &#34;&#34;&#34;
    # raw format
    if raw:
        return self.PAIR_STYLE
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # cmd
    cmd = parameters.formateval(self.PAIR_STYLE)
    # Replace [comment] with the formatted comment (e.g., &#34;[2:my_user_id]&#34;)
    cmd = cmd.replace(&#34;[comment]&#34;,&#34;[%d:%s]&#34; % (beadtype, userid) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="script.geometrysection"><code class="flex name class">
<span>class <span class="ident">geometrysection</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>LAMMPS script: global session </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class geometrysection(script):
    &#34;&#34;&#34; LAMMPS script: global session &#34;&#34;&#34;
    name = &#34;geometry&#34;
    description = name+&#34; section&#34;
    position = 2
    section = 3
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = scriptdata(
         l0= 0.05,
       hgap= &#34;0.25        # gap to prevent direct contact at t=0 (too much enery)&#34;,
  hsmallgap= &#34;0.1   # gap to prevent direct contact at t=0 (too much enery)&#34;,
       hto1= &#34;0.8         # height of to1 (the tongue to1, note 1 not l)&#34;,
       hto2= &#34;0.5         # height of to2 (the tongue to2)&#34;,
       rsph= &#34;0.3         # radius of spherical food particles&#34;,
       lpar= &#34;0.6         # size of prismatic particles &#34;,
    yfloor1= &#34;${hgap}  # bottom position of to1, position of the first floor&#34;,
     yroof1= &#34;${yfloor1}+${hto1} # bottom position of to1, position of the first floor&#34;,
   yfloor2a= &#34;${yroof1}+${hsmallgap}  # position of the second floor / level a&#34;,
    yroof2a= &#34;${yfloor2a}+${lpar}      # position of the second floor / level a&#34;,
   yfloor2b= &#34;${yroof2a}+${hsmallgap} # position of the second floor / level b&#34;,
    yroof2b= &#34;${yfloor2b}+${lpar}      # position of the second floor / level b&#34;,
   yfloor2c= &#34;${yfloor2a}+${rsph}     # position of the second floor / level c&#34;,
    yroof2c= &#34;${yfloor2c}+${rsph}      # position of the second floor / level c&#34;,
   yfloor2d= &#34;${yroof2c}+${rsph}+${hsmallgap} # position of the second floor / level d&#34;,
    yroof2d= &#34;${yfloor2d}+${rsph}      # position of the second floor / level d&#34;,
    yfloor3= 5.0,
     yroof3= &#34;${yfloor3}+${hto2} # bottom position of to1&#34;,
   yfloor3a= &#34;${yfloor3}-0.6&#34;,
    yroof3a= &#34;${yfloor3}&#34;,
    crunchl= &#34;${yfloor3}-${yfloor2a}-0.8&#34;,
    crunchp= 3,
    crunchw= &#34;2*pi/${crunchp}&#34;,
    crunchd= &#34;2*(sin((${crunchp}*${crunchw})/4)^2)/${crunchw}&#34;,
    crunchv= &#34;${crunchl}/${crunchd}&#34;
        )

    TEMPLATE = &#34;&#34;&#34;
# :GEOMETRY SECTION:
#   Build geometry (very specific example)

    ####################################################################################################
    # CREATE INITIAL GEOMETRY
    # note there are 4 groups (create_box 5 box)
    # groupID 1 = saliva
    # groupID 2 = food
    # groupID 3 = mouth walls
    # groupID 4 = tongue alike (part1)
    # groupID 5 = also tongue but palate infact (part2)
    ####################################################################################################
    # create simulation box, a mouth, and a saliva column
    region          box block 0 12 0 8 -0.01 0.01 units box
    create_box      5 box
    region          saliva1 block 0.25 1.8 1.25 3.5 EDGE EDGE units box
    region          saliva2 block 10 11.65 1.25 4 EDGE EDGE units box
    region          mouth block 0.15 11.85 0.15 8 -0.01 0.01 units box side out # mouth
    lattice         sq ${l0}
    create_atoms    1 region saliva1
    create_atoms    1 region saliva2
    group           saliva type 1
    create_atoms    3 region mouth
    group           mouth type 3

    print &#34;Crunch distance:${crunchl}&#34;  # 3.65
    print &#34;Crunch distance:${crunchv}&#34;  # 0.1147


    # bottom part of the tongue: to1 (real tongue)
    # warning: all displacements are relative to the bottom part
    region          to1 block 1 11 ${yfloor1} ${yroof1} EDGE EDGE units box
    region          to2part1 block 0.5 11.5 ${yfloor3} ${yroof3} EDGE EDGE units box
    region          to2part2 block 5.5 6 ${yfloor3a} ${yroof3a} EDGE EDGE units box
    region          to2 union 2 to2part1 to2part2
    create_atoms    4 region to1
    create_atoms    5 region to2
    group           tongue1 type 4
    group           tongue2 type 5

    # create some solid objects to be pushed around
    region          pr1 prism 2 2.6 ${yfloor2a} ${yroof2a} EDGE EDGE 0.3 0 0 units box
    region          bl1 block 3 3.6 ${yfloor2a} ${yroof2a} EDGE EDGE units box
    region          sp1 sphere 4.3 ${yfloor2c} 0 ${rsph} units box
    region          sp2 sphere 5 ${yfloor2c} 0 ${rsph} units box
    region          sp3 sphere 5.7 ${yfloor2c} 0 ${rsph} units box
    region          sp4 sphere 6.4 ${yfloor2c} 0 ${rsph} units box
    region          sp5 sphere 7.1 ${yfloor2c} 0 ${rsph} units box
    region          sp6 sphere 6.05 ${yfloor2d} 0 ${rsph} units box
    region          br2 block 3 3.6 ${yfloor2b} ${yroof2b} EDGE EDGE units box

    # fill the regions with atoms (note that atoms = smoothed hydrodynamics particles)
    create_atoms    2 region pr1
    create_atoms    2 region bl1
    create_atoms    2 region sp1
    create_atoms    2 region sp2
    create_atoms    2 region sp3
    create_atoms    2 region sp4
    create_atoms    2 region sp5
    create_atoms    2 region sp6
    create_atoms    2 region br2

    # atoms of objects are grouped with two id
    # fix apply only to groups
    group           solidfoods type 2
    group           tlsph type 2

    # group heavy
    group           allheavy type 1:4


    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="script.script" href="#script.script">script</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.geometrysection.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.geometrysection.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.geometrysection.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.geometrysection.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.geometrysection.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.geometrysection.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.geometrysection.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.geometrysection.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="script.script" href="#script.script">script</a></b></code>:
<ul class="hlist">
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="script.globalsection"><code class="flex name class">
<span>class <span class="ident">globalsection</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>LAMMPS script: global session </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class globalsection(script):
    &#34;&#34;&#34; LAMMPS script: global session &#34;&#34;&#34;
    name = &#34;global&#34;
    description = name+&#34; section&#34;
    position = 0
    section = 1
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = scriptdata(
  outputfile= &#34;$dump.mouthfeel_v5_long    # from the project of the same name&#34;,
        tsim= &#34;500000                     # may be too long&#34;,
     outstep= 10
        )

    MATERIALS = scriptdata(
         rho_saliva= &#34;1000 # mass density saliva&#34;,
            rho_obj= &#34;1300 # mass density solid objects&#34;,
                 c0= &#34;10.0 # speed of sound for saliva&#34;,
                  E= &#34;5*${c0}*${c0}*${rho_saliva} # Young&#39;s modulus for solid objects&#34;,
           Etongue1= &#34;10*${E} # Young&#39;s modulus for tongue&#34;,
           Etongue2= &#34;2*${Etongue1} # Young&#39;s modulus for tongue&#34;,
                 nu= &#34;0.3 # Poisson ratio for solid objects&#34;,
        sigma_yield= &#34;0.1*${E} # plastic yield stress for solid objects&#34;,
     hardening_food= &#34;0 # plastic hardening parameter for solid food&#34;,
   hardening_tongue= &#34;1 # plastic hardening parameter for solid tongue&#34;,
  contact_stiffness= &#34;2.5*${c0}^2*${rho_saliva} # contact force amplitude&#34;,
       contact_wall= &#34;100*${contact_stiffness} # contact with wall (avoid interpenetration)&#34;,
                 q1= &#34;1.0 # artificial viscosity&#34;,
                 q2= &#34;0.0 # artificial viscosity&#34;,
                 Hg= &#34;10 # Hourglass control coefficient for solid objects&#34;,
                 Cp= &#34;1.0 # heat capacity -- not used here&#34;
                  )

    DEFINITIONS += MATERIALS # append MATERIALS data

    TEMPLATE = &#34;&#34;&#34;
# :GLOBAL SECTION:
#   avoid to set variables in LAMMPS script
#   use DEFINITIONS field to set properties.
#   If you need to define them, use the following syntax


    # ####################################################################################################
    # # GLOBAL
    # ####################################################################################################
     variable outputfile string &#34;${outputfile}&#34;
     variable tsim equal ${tsim}
     variable outstep equal ${outstep}

    # ####################################################################################################
    # # MATERIAL PARAMETERS
    # ####################################################################################################
    # variable        rho_saliva equal 1000 # mass density saliva
    # variable        rho_obj equal 1300 # mass density solid objects
    # variable        c0 equal 10.0 # speed of sound for saliva
    # variable        E equal 5*${c0}*${c0}*${rho_saliva} # Young&#39;s modulus for solid objects
    # variable        Etongue1 equal 10*${E} # Young&#39;s modulus for tongue
    # variable        Etongue2 equal 2*${Etongue1} # Young&#39;s modulus for tongue
    # variable        nu equal 0.3 # Poisson ratio for solid objects
    # variable        sigma_yield equal 0.1*${E} # plastic yield stress for solid objects
    # variable        hardening_food equal 0 # plastic hardening parameter for solid food
    # variable        hardening_tongue equal 1 # plastic hardening parameter for solid tongue
    # variable        contact_stiffness equal 2.5*${c0}^2*${rho_saliva} # contact force amplitude
    # variable        contact_wall equal 100*${contact_stiffness} # contact with wall (avoid interpenetration)
    # variable        q1 equal 1.0 # artificial viscosity
    # variable        q2 equal 0.0 # artificial viscosity
    # variable        Hg equal 10 # Hourglass control coefficient for solid objects
    # variable        Cp equal 1.0 # heat capacity -- not used here
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="script.script" href="#script.script">script</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.globalsection.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.globalsection.MATERIALS"><code class="name">var <span class="ident">MATERIALS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.globalsection.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.globalsection.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.globalsection.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.globalsection.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.globalsection.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.globalsection.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.globalsection.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="script.script" href="#script.script">script</a></b></code>:
<ul class="hlist">
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="script.initializesection"><code class="flex name class">
<span>class <span class="ident">initializesection</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>LAMMPS script: global session </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class initializesection(script):
    &#34;&#34;&#34; LAMMPS script: global session &#34;&#34;&#34;
    name = &#34;initialize&#34;
    description = name+&#34; section&#34;
    position = 1
    section = 2
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = scriptdata(
               units= &#34;$ si&#34;,
           dimension= 2,
            boundary= &#34;$ sm sm p&#34;,
          atom_style= &#34;$smd&#34;,
  neigh_modify_every= 5,
  neigh_modify_delay= 0,
         comm_modify= &#34;$ vel yes&#34;,
              newton= &#34;$ off&#34;,
         atom_modify= &#34;$ map array&#34;,
          comm_style= &#34;$ tiled&#34;
        )

    TEMPLATE = &#34;&#34;&#34;
# :INITIALIZE SECTION:
#   initialize styles, dimensions, boundaries and communivation

    ####################################################################################################
    # INITIALIZE LAMMPS
    ####################################################################################################
    units           ${units}
    dimension       ${dimension}
    boundary        ${boundary}
    atom_style      ${atom_style}
    neigh_modify    every ${neigh_modify_every} delay ${neigh_modify_delay} check yes
    comm_modify     ${comm_modify}
    newton          ${newton}
    atom_modify     ${atom_modify}
    comm_style      ${comm_style}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="script.script" href="#script.script">script</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.initializesection.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.initializesection.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.initializesection.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.initializesection.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.initializesection.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.initializesection.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.initializesection.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.initializesection.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="script.script" href="#script.script">script</a></b></code>:
<ul class="hlist">
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="script.integrationsection"><code class="flex name class">
<span>class <span class="ident">integrationsection</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>LAMMPS script: time integration session </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class integrationsection(script):
    &#34;&#34;&#34; LAMMPS script: time integration session &#34;&#34;&#34;
    name = &#34;time integration&#34;
    description = name+&#34; section&#34;
    position = 6
    section = 7
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = scriptdata(
              dt = 0.1,
   adjust_redius = &#34;$ 1.01 10 15&#34;
        )

    TEMPLATE = &#34;&#34;&#34;
# :INTEGRATION SECTION:
#   Time integration conditions

    fix             dtfix tlsph smd/adjust_dt ${dt} # dynamically adjust time increment every step
    fix             integration_fix_water saliva smd/integrate_ulsph adjust_radius ${adjust_redius}
    fix             integration_fix_solids solidfoods smd/integrate_tlsph
    fix             integration_fix_tongue1 tongue1 smd/integrate_tlsph
    fix             integration_fix_tongue2 tongue2 smd/integrate_tlsph

    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="script.script" href="#script.script">script</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.integrationsection.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.integrationsection.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.integrationsection.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.integrationsection.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.integrationsection.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.integrationsection.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.integrationsection.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.integrationsection.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="script.script" href="#script.script">script</a></b></code>:
<ul class="hlist">
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="script.interactionsection"><code class="flex name class">
<span>class <span class="ident">interactionsection</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>LAMMPS script: interaction session </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class interactionsection(script):
    &#34;&#34;&#34; LAMMPS script: interaction session &#34;&#34;&#34;
    name = &#34;interactions&#34;
    description = name+&#34; section&#34;
    position = 5
    section = 6
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = globalsection.DEFINITIONS + \
                  geometrysection.DEFINITIONS + \
                  discretizationsection.DEFINITIONS

    TEMPLATE = &#34;&#34;&#34;
# :INTERACTIONS SECTION:
#   Please use forcefield() to make a robust code

    ####################################################################################################
    # INTERACTION PHYSICS / MATERIAL MODEL
    # 3 different pair styles are used:
    #     - updated Lagrangian SPH for saliva
    #     - total Lagrangian SPH for solid objects
    #     - a repulsive Hertzian potential for contact forces between different physical bodies
    ####################################################################################################
    pair_style      hybrid/overlay smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION &amp;
                                   smd/tlsph smd/hertz ${contact_scale}
    pair_coeff      1 1 smd/ulsph *COMMON ${rho_saliva} ${c0} ${q1} ${Cp} 0 &amp;
                    *EOS_TAIT 7.0 &amp;
                    *END
    pair_coeff      2 2 smd/tlsph *COMMON ${rho_obj} ${E} ${nu} ${q1} ${q2} ${Hg} ${Cp} &amp;
                    *STRENGTH_LINEAR_PLASTIC ${sigma_yield} ${hardening_food} &amp;
                    *EOS_LINEAR &amp;
                    *END
    pair_coeff      4 4 smd/tlsph *COMMON ${rho_obj} ${Etongue1} ${nu} ${q1} ${q2} ${Hg} ${Cp} &amp;
                    *STRENGTH_LINEAR_PLASTIC ${sigma_yield} ${hardening_tongue} &amp;
                    *EOS_LINEAR &amp;
                    *END
    pair_coeff      5 5 smd/tlsph *COMMON ${rho_obj} ${Etongue2} ${nu} ${q1} ${q2} ${Hg} ${Cp} &amp;
                    *STRENGTH_LINEAR_PLASTIC ${sigma_yield} ${hardening_tongue} &amp;
                    *EOS_LINEAR &amp;
                    *END

    pair_coeff      3 3 none   # wall-wall
    pair_coeff      1 2 smd/hertz ${contact_stiffness} # saliva-food
    pair_coeff      1 3 smd/hertz ${contact_wall} # saliva-wall
    pair_coeff      2 3 smd/hertz ${contact_wall} # food-wall
    pair_coeff      2 2 smd/hertz ${contact_stiffness} # food-food
    # add 4 (to1)
    pair_coeff      1 4 smd/hertz ${contact_stiffness} # saliva-tongue1
    pair_coeff      2 4 smd/hertz ${contact_stiffness} # food-tongue1
    pair_coeff      3 4 smd/hertz ${contact_wall} # wall-tongue1
    pair_coeff      4 4 smd/hertz ${contact_stiffness} # tongue1-tongue1
    # add 5 (to2)
    pair_coeff      1 5 smd/hertz ${contact_stiffness} # saliva-tongue2
    pair_coeff      2 5 smd/hertz ${contact_stiffness} # food-tongue2
    pair_coeff      3 5 smd/hertz ${contact_wall} # wall-tongue2
    pair_coeff      4 5 smd/hertz ${contact_stiffness} # tongue1-tongue2
    pair_coeff      5 5 smd/hertz ${contact_stiffness} # tongue2-tongue2

    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="script.script" href="#script.script">script</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.interactionsection.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.interactionsection.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.interactionsection.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.interactionsection.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.interactionsection.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.interactionsection.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.interactionsection.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.interactionsection.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="script.script" href="#script.script">script</a></b></code>:
<ul class="hlist">
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="script.none"><code class="flex name class">
<span>class <span class="ident">none</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD:TLSPH forcefield (updated Lagrangian)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class none(smd):
    &#34;&#34;&#34; SMD:TLSPH forcefield (updated Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;none&#34;)
    description = smd.description + struct(style=&#34;no interactions&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Diagonal pair coefficient tlsph
    pair_coeff      %d %d none
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.rigidwall</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.none.PAIR_DIAGCOEFF"><code class="name">var <span class="ident">PAIR_DIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.none.PAIR_OFFDIAGCOEFF"><code class="name">var <span class="ident">PAIR_OFFDIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.none.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.none.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="script.param"><code class="flex name class">
<span>class <span class="ident">param</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-param">Class: <code><a title="script.param" href="#script.param">param</a></code></h1>
<p>A class derived from <code><a title="script.struct" href="#script.struct">struct</a></code> that introduces dynamic evaluation of field values.
The <code><a title="script.param" href="#script.param">param</a></code> class acts as a container for evaluated parameters, allowing expressions
to depend on other fields. It supports advanced evaluation, sorting of dependencies,
and text formatting.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Inherits all functionalities of <code><a title="script.struct" href="#script.struct">struct</a></code>.</li>
<li>Supports dynamic evaluation of field expressions.</li>
<li>Automatically resolves dependencies between fields.</li>
<li>Includes utility methods for text formatting and evaluation.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage-with-evaluation">Basic Usage with Evaluation</h4>
<pre><code class="language-python">s = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can', d=&quot;$this is a string&quot;, e=&quot;1000 # this is my number&quot;)
s.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
#      d: $this is a string (= this is a string)
#      e: 1000 # this is my number (= 1000)
# --------

s.a = 10
s.eval()
# Output:
# --------
#      a: 10
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 12)
#      d: $this is a string (= this is a string)
#      e: 1000 # this is my number (= 1000)
# --------
</code></pre>
<h4 id="handling-text-parameters">Handling Text Parameters</h4>
<pre><code class="language-python">s = param()
s.mypath = &quot;$/this/folder&quot;
s.myfile = &quot;$file&quot;
s.myext = &quot;$ext&quot;
s.fullfile = &quot;$${mypath}/${myfile}.${myext}&quot;
s.eval()
# Output:
# --------
#    mypath: $/this/folder (= /this/folder)
#    myfile: $file (= file)
#     myext: $ext (= ext)
#  fullfile: $${mypath}/${myfile}.${myext} (= /this/folder/file.ext)
# --------
</code></pre>
<hr>
<h3 id="text-evaluation-and-formatting">Text Evaluation and Formatting</h3>
<h4 id="evaluate-strings">Evaluate Strings</h4>
<pre><code class="language-python">s = param(a=1, b=2)
result = s.eval(&quot;this is a string with ${a} and ${b}&quot;)
print(result)  # &quot;this is a string with 1 and 2&quot;
</code></pre>
<h4 id="prevent-evaluation">Prevent Evaluation</h4>
<pre><code class="language-python">definitions = param(a=1, b=&quot;${a}*10+${a}&quot;, c=&quot;\${a}+10&quot;, d='\${myparam}')
text = definitions.formateval(&quot;this is my text ${a}, ${b}, \${myvar}=${c}+${d}&quot;)
print(text)  # &quot;this is my text 1, 11, \${myvar}=\${a}+10+${myparam}&quot;
</code></pre>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="rearranging-and-sorting-definitions">Rearranging and Sorting Definitions</h4>
<pre><code class="language-python">s = param(
    a=1,
    f=&quot;${e}/3&quot;,
    e=&quot;${a}*${c}&quot;,
    c=&quot;${a}+${b}&quot;,
    b=2,
    d=&quot;${c}*2&quot;
)
s.sortdefinitions()
s.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} (= 3)
#      d: ${c} * 2 (= 6)
#      e: ${a} * ${c} (= 3)
#      f: ${e} / 3 (= 1.0)
# --------
</code></pre>
<h4 id="internal-evaluation-and-recursion-with">Internal Evaluation and Recursion with !</h4>
<pre><code class="language-python">p=param()
p.a = [0,1,2]
p.b = '![1,2,&quot;test&quot;,&quot;${a[1]}&quot;]'
p
# Output:
#  -------------:----------------------------------------
#          a: [0, 1, 2]
#          b: ![1,2,&quot;test&quot;,&quot;${a[1]}&quot;]
#           = [1, 2, 'test', '1']
#  -------------:----------------------------------------
# Out: parameter list (param object) with 2 definitions
</code></pre>
<h4 id="error-handling">Error Handling</h4>
<pre><code class="language-python">p = param(b=&quot;${a}+1&quot;, c=&quot;${a}+${d}&quot;, a=1)
p.disp()
# Output:
# --------
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
#      a: 1
# --------
</code></pre>
<p>Sorting unresolved definitions raises errors unless explicitly suppressed:</p>
<pre><code class="language-python">p.sortdefinitions(raiseerror=False)
# WARNING: unable to interpret 1/3 expressions in &quot;definitions&quot;
</code></pre>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eval()</code></td>
<td>Evaluate all field expressions.</td>
</tr>
<tr>
<td><code>formateval(string)</code></td>
<td>Format and evaluate a string with field placeholders.</td>
</tr>
<tr>
<td><code>protect(string)</code></td>
<td>Escape variable placeholders in a string.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort definitions to resolve dependencies.</td>
</tr>
<tr>
<td><code>escape(string)</code></td>
<td>Protect escaped variables in a string.</td>
</tr>
<tr>
<td><code>safe_fstring(string)</code></td>
<td>evaluate safely complex mathemical expressions.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two parameter lists, sorting definitions.</li>
<li><code>-</code>: Subtraction of fields.</li>
<li><code>len()</code>: Number of fields.</li>
<li><code>in</code>: Check for field existence.</li>
</ul>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>The <code><a title="script.paramauto" href="#script.paramauto">paramauto</a></code> class simplifies handling of partial definitions and inherits from <code><a title="script.param" href="#script.param">param</a></code>.</li>
<li>Use <code><a title="script.paramauto" href="#script.paramauto">paramauto</a></code> when definitions need to be stacked irrespective of execution order.</li>
</ul>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class param(struct):
    &#34;&#34;&#34;
    Class: `param`
    ==============

    A class derived from `struct` that introduces dynamic evaluation of field values.
    The `param` class acts as a container for evaluated parameters, allowing expressions
    to depend on other fields. It supports advanced evaluation, sorting of dependencies,
    and text formatting.

    ---

    ### Features
    - Inherits all functionalities of `struct`.
    - Supports dynamic evaluation of field expressions.
    - Automatically resolves dependencies between fields.
    - Includes utility methods for text formatting and evaluation.

    ---

    ### Examples

    #### Basic Usage with Evaluation
    ```python
    s = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;, d=&#34;$this is a string&#34;, e=&#34;1000 # this is my number&#34;)
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------

    s.a = 10
    s.eval()
    # Output:
    # --------
    #      a: 10
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 12)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------
    ```

    #### Handling Text Parameters
    ```python
    s = param()
    s.mypath = &#34;$/this/folder&#34;
    s.myfile = &#34;$file&#34;
    s.myext = &#34;$ext&#34;
    s.fullfile = &#34;$${mypath}/${myfile}.${myext}&#34;
    s.eval()
    # Output:
    # --------
    #    mypath: $/this/folder (= /this/folder)
    #    myfile: $file (= file)
    #     myext: $ext (= ext)
    #  fullfile: $${mypath}/${myfile}.${myext} (= /this/folder/file.ext)
    # --------
    ```

    ---

    ### Text Evaluation and Formatting

    #### Evaluate Strings
    ```python
    s = param(a=1, b=2)
    result = s.eval(&#34;this is a string with ${a} and ${b}&#34;)
    print(result)  # &#34;this is a string with 1 and 2&#34;
    ```

    #### Prevent Evaluation
    ```python
    definitions = param(a=1, b=&#34;${a}*10+${a}&#34;, c=&#34;\${a}+10&#34;, d=&#39;\${myparam}&#39;)
    text = definitions.formateval(&#34;this is my text ${a}, ${b}, \${myvar}=${c}+${d}&#34;)
    print(text)  # &#34;this is my text 1, 11, \${myvar}=\${a}+10+${myparam}&#34;
    ```

    ---

    ### Advanced Usage

    #### Rearranging and Sorting Definitions
    ```python
    s = param(
        a=1,
        f=&#34;${e}/3&#34;,
        e=&#34;${a}*${c}&#34;,
        c=&#34;${a}+${b}&#34;,
        b=2,
        d=&#34;${c}*2&#34;
    )
    s.sortdefinitions()
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} (= 3)
    #      d: ${c} * 2 (= 6)
    #      e: ${a} * ${c} (= 3)
    #      f: ${e} / 3 (= 1.0)
    # --------
    ```

    #### Internal Evaluation and Recursion with !
    ```python
    p=param()
    p.a = [0,1,2]
    p.b = &#39;![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]&#39;
    p
    # Output:
    #  -------------:----------------------------------------
    #          a: [0, 1, 2]
    #          b: ![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]
    #           = [1, 2, &#39;test&#39;, &#39;1&#39;]
    #  -------------:----------------------------------------
    # Out: parameter list (param object) with 2 definitions
    ```

    #### Error Handling
    ```python
    p = param(b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;, a=1)
    p.disp()
    # Output:
    # --------
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      a: 1
    # --------
    ```

    Sorting unresolved definitions raises errors unless explicitly suppressed:
    ```python
    p.sortdefinitions(raiseerror=False)
    # WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
    ```

    ---

    ### Utility Methods
    | Method                 | Description                                             |
    |------------------------|---------------------------------------------------------|
    | `eval()`               | Evaluate all field expressions.                         |
    | `formateval(string)`   | Format and evaluate a string with field placeholders.   |
    | `protect(string)`      | Escape variable placeholders in a string.               |
    | `sortdefinitions()`    | Sort definitions to resolve dependencies.               |
    | `escape(string)`       | Protect escaped variables in a string.                  |
    | `safe_fstring(string)` | evaluate safely complex mathemical expressions.         |

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two parameter lists, sorting definitions.
    - `-`: Subtraction of fields.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Notes
    - The `paramauto` class simplifies handling of partial definitions and inherits from `param`.
    - Use `paramauto` when definitions need to be stacked irrespective of execution order.
    &#34;&#34;&#34;

    # override
    _type = &#34;param&#34;
    _fulltype = &#34;parameter list&#34;
    _ftype = &#34;definition&#34;
    _evalfeature = True    # This class can be evaluated with .eval()
    _returnerror = True    # This class returns an error in the evaluation string (added on 2024-09-06)

    # magic constructor
    def __init__(self,_protection=False,_evaluation=True,
                 sortdefinitions=False,debug=False,**kwargs):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        super().__init__(debug=debug,**kwargs)
        self._protection = _protection
        self._evaluation = _evaluation
        if sortdefinitions: self.sortdefinitions()

    # escape definitions if needed
    @staticmethod
    def escape(s):
        &#34;&#34;&#34;
            escape \${} as ${{}} --&gt; keep variable names
            convert ${} as {} --&gt; prepare Python replacement

            Examples:
                escape(&#34;\${a}&#34;)
                returns (&#39;${{a}}&#39;, True)

                escape(&#34;  \${abc} ${a} \${bc}&#34;)
                returns (&#39;  ${{abc}} {a} ${{bc}}&#39;, True)

                escape(&#34;${a}&#34;)
                Out[94]: (&#39;{a}&#39;, False)

                escape(&#34;${tata}&#34;)
                returns (&#39;{tata}&#39;, False)

        &#34;&#34;&#34;
        if not isinstance(s,str):
            raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)
        se, start, found = &#34;&#34;, 0, True
        while found:
            pos0 = s.find(&#34;\${&#34;,start)
            found = pos0&gt;=0
            if found:
                pos1 = s.find(&#34;}&#34;,pos0)
                found = pos1&gt;=0
                if found:
                    se += s[start:pos0].replace(&#34;${&#34;,&#34;{&#34;)+&#34;${{&#34;+s[pos0+3:pos1]+&#34;}}&#34;
                    start=pos1+1
        result = se+s[start:].replace(&#34;${&#34;,&#34;{&#34;)
        if isinstance(s,pstr): result = pstr(result)
        return result,start&gt;0

    # protect variables in a string
    def protect(self,s=&#34;&#34;):
        &#34;&#34;&#34; protect $variable as ${variable} &#34;&#34;&#34;
        if isinstance(s,str):
            t = s.replace(&#34;\$&#34;,&#34;££&#34;) # &amp;&amp; is a placeholder
            escape = t!=s
            for k in self.keyssorted():
                t = t.replace(&#34;$&#34;+k,&#34;${&#34;+k+&#34;}&#34;)
            if escape: t = t.replace(&#34;££&#34;,&#34;\$&#34;)
            if isinstance(s,pstr): t = pstr(t)
            return t, escape
        raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)


    # lines starting with # (hash) are interpreted as comments
    # ${variable} or {variable} are substituted by variable.value
    # any line starting with $ is assumed to be a string (no interpretation)
    # ^ is accepted in formula(replaced by **))
    def eval(self,s=&#34;&#34;,protection=False):
        &#34;&#34;&#34;
            Eval method for structure such as MS.alias

                s = p.eval() or s = p.eval(string)

                where :
                    p is a param object
                    s is a structure with evaluated fields
                    string is only used to determine whether definitions have been forgotten

        &#34;&#34;&#34;
        # Evaluate all DEFINITIONS
        # the argument s is only used by formateval() for error management
        tmp = struct()
        for key,value in self.items():
            # strings are assumed to be expressions on one single line
            if isinstance(value,str):
                # replace ${variable} (Bash, Lammps syntax) by {variable} (Python syntax)
                # use \${variable} to prevent replacement (espace with \)
                # Protect variables if required
                ispstr = isinstance(value,pstr)
                valuesafe = pstr.eval(value,ispstr=ispstr) # value.strip()
                if valuesafe==&#34;${&#34;+key+&#34;}&#34;: # circular reference (it cannot be evaluated)
                    continue
                if protection or self._protection:
                    valuesafe, escape0 = self.protect(valuesafe)
                else:
                    escape0 = False
                # replace ${var} by {var}
                valuesafe_priorescape = valuesafe
                valuesafe, escape = param.escape(valuesafe)
                escape = escape or escape0
                # replace &#34;^&#34; (Matlab, Lammps exponent) by &#34;**&#34; (Python syntax)
                valuesafe = pstr.eval(valuesafe.replace(&#34;^&#34;,&#34;**&#34;),ispstr=ispstr)
                # Remove all content after #
                # if the first character is &#39;#&#39;, it is not comment (e.g. MarkDown titles)
                poscomment = valuesafe.find(&#34;#&#34;)
                if poscomment&gt;0: valuesafe = valuesafe[0:poscomment].strip()
                # Matrix shorthand replacement
                # $[[1,2,${a}]]+$[[10,20,30]] --&gt; np.array([[1,2,${a}]])+np.array([[10,20,30]])
                valuesafe = param.replace_matrix_shorthand(valuesafe)
                # Literal string starts with $ (no interpretation), ! (evaluation)
                if not self._evaluation:
                    tmp.setattr(key, pstr.eval(tmp.format(valuesafe,escape),ispstr=ispstr))
                elif valuesafe.startswith(&#34;!&#34;):
                    try:
                        vtmp = ast.literal_eval(valuesafe[1:])
                        if isinstance(vtmp,list):
                            for i,item in enumerate(vtmp):
                                if isinstance(item,str) and not item.strip().startswith(&#34;$&#34;):
                                    try:
                                        vtmp[i] = tmp.format(item, raiseerror=False)
                                    except Exception as ve:
                                        vtmp[i] = f&#34;Error in &lt;{item}&gt;: {ve.__class__.__name__} - {str(ve)}&#34;
                        tmp.setattr(key,vtmp)
                    except (SyntaxError, ValueError) as e:
                        tmp.setattr(key, f&#34;Error: {e.__class__.__name__} - {str(e)}&#34;)
                elif valuesafe.startswith(&#34;$&#34;) and not escape:
                    tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard $
                elif valuesafe.startswith(&#34;%&#34;):
                    tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard %
                else: # string empty or which can be evaluated
                    if valuesafe==&#34;&#34;:
                        tmp.setattr(key,valuesafe) # empty content
                    else:
                        if isinstance(value,pstr): # keep path
                            tmp.setattr(key, pstr.topath(tmp.format(valuesafe,escape=escape)))
                        elif escape:  # partial evaluation
                            tmp.setattr(key, tmp.format(valuesafe,escape=True))
                        else: # full evaluation (if it fails the last string content is returned)
                            try:
                                resstr = tmp.format(valuesafe,raiseerror=False)
                            except (KeyError,NameError) as nameerr:
                                if self._returnerror: # added on 2024-09-06
                                    strnameerr = str(nameerr).replace(&#34;&#39;&#34;,&#34;&#34;)
                                    tmp.setattr(key,&#39;&lt; undef %s &#34;${%s}&#34; &gt;&#39; % \
                                            (self._ftype,strnameerr))
                                else:
                                    tmp.setattr(key,value) #we keep the original value
                            except (SyntaxError,TypeError,ValueError) as commonerr:
                                tmp.setattr(key,&#34;ERROR &lt; %s &gt;&#34; % commonerr)
                            except (IndexError,AttributeError):
                                try:
                                    resstr = param.safe_fstring(
                                        param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                                except Exception as fstrerr:
                                    tmp.setattr(key,&#34;Index Error &lt; %s &gt;&#34; % fstrerr)
                                else:
                                    try:
                                        # reseval = eval(resstr)
                                        # reseval = ast.literal_eval(resstr)
                                        # Use SafeEvaluator to evaluate the final expression
                                        evaluator = SafeEvaluator(tmp)
                                        reseval = evaluator.evaluate(resstr)
                                    except Exception as othererr:
                                        #tmp.setattr(key,&#34;Mathematical Error around/in ${}: &lt; %s &gt;&#34; % othererr)
                                        if self._debug:
                                            print(f&#34;DEBUG {key}: Error in Evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                        tmp.setattr(key,resstr)
                                    else:
                                        tmp.setattr(key,reseval)
                            except Exception as othererr:
                                tmp.setattr(key,&#34;Error in ${}: &lt; %s &gt;&#34; % othererr)
                            else:
                                try:
                                    # reseval = eval(resstr)
                                    evaluator = SafeEvaluator(tmp)
                                    reseval = evaluator.evaluate(resstr)
                                except Exception as othererr:
                                    #tmp.setattr(key,&#34;Eval Error &lt; %s &gt;&#34; % othererr)
                                    if self._debug:
                                        print(f&#34;DEBUG {key}: Error in Evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                    tmp.setattr(key,resstr.replace(&#34;\n&#34;,&#34;,&#34;)) # \n replaced by ,
                                else:
                                    tmp.setattr(key,reseval)
            elif isinstance(value,_numeric_types): # already a number
                tmp.setattr(key, value) # store the value with the key
            else: # unsupported types
                if s.find(&#34;{&#34;+key+&#34;}&#34;)&gt;=0:
                    print(f&#39;*** WARNING ***\n\tIn the {self._ftype}:&#34;\n{s}\n&#34;&#39;)
                else:
                    print(f&#39;unable to interpret the &#34;{key}&#34; of type {type(value)}&#39;)
        return tmp

    # formateval obeys to following rules
    # lines starting with # (hash) are interpreted as comments
    def formateval(self,s,protection=False,fullevaluation=True):
        &#34;&#34;&#34;
            format method with evaluation feature

                txt = p.formateval(&#34;this my text with ${variable1}, ${variable2} &#34;)

                where:
                    p is a param object

                Example:
                    definitions = param(a=1,b=&#34;${a}&#34;,c=&#34;\${a}&#34;)
                    text = definitions.formateval(&#34;this my text ${a}, ${b}, ${c}&#34;)
                    print(text)

        &#34;&#34;&#34;
        tmp = self.eval(s,protection=protection)
        evaluator = SafeEvaluator(tmp) # used when fullevaluation=True
        # Do all replacements in s (keep comments)
        if len(tmp)==0:
            return s
        else:
            ispstr = isinstance(s,pstr)
            ssafe, escape = param.escape(s)
            slines = ssafe.split(&#34;\n&#34;)
            for i in range(len(slines)):
                poscomment = slines[i].find(&#34;#&#34;)
                if poscomment&gt;=0:
                    while (poscomment&gt;0) and (slines[i][poscomment-1]==&#34; &#34;):
                        poscomment -= 1
                    comment = slines[i][poscomment:len(slines[i])]
                    slines[i]  = slines[i][0:poscomment]
                else:
                    comment = &#34;&#34;
                # Protect variables if required
                if protection or self._protection:
                    slines[i], escape2 = self.protect(slines[i])
                # conversion
                if ispstr:
                    slines[i] = pstr.eval(tmp.format(slines[i],escape=escape),ispstr=ispstr)
                else:
                    if fullevaluation:
                        try:
                            resstr =tmp.format(slines[i],escape=escape)
                        except:
                            resstr = param.safe_fstring(slines[i],tmp,varprefix=&#34;&#34;)
                        try:
                            reseval = evaluator.evaluate(resstr)
                            slines[i] = str(reseval)+&#34; &#34;+comment if comment else str(reseval)
                        except:
                            slines[i] = resstr + comment
                    else:
                        slines[i] = tmp.format(slines[i],escape=escape)+comment
                # convert starting % into # to authorize replacement in comments
                if len(slines[i])&gt;0:
                    if slines[i][0] == &#34;%&#34;: slines[i]=&#34;#&#34;+slines[i][1:]
            return &#34;\n&#34;.join(slines)

    # returns the equivalent structure evaluated
    def tostruct(self,protection=False):
        &#34;&#34;&#34;
            generate the evaluated structure
                tostruct(protection=False)
        &#34;&#34;&#34;
        return self.eval(protection=protection)

    # returns the equivalent structure evaluated
    def tostatic(self):
        &#34;&#34;&#34; convert dynamic a param() object to a static struct() object.
            note: no interpretation
            note: use tostruct() to interpret them and convert it to struct
            note: tostatic().struct2param() makes it reversible
        &#34;&#34;&#34;
        return struct.fromkeysvalues(self.keys(),self.values(),makeparam=False)

    # Matlab vector/list conversion
    def expand_ranges(text):
        &#34;&#34;&#34;
        Expands MATLAB-style ranges in a string.

        Args:
            text: The input string containing ranges.

        Returns:
            The string with ranges expanded, or the original string if no valid ranges are found
            or if expansion leads to more than 100 elements. Returns an error message if the input
            format is invalid.
        &#34;&#34;&#34;
        def expand_range(match):
            try:
                parts = match.group(1).split(&#39;:&#39;)
                if len(parts) == 2:
                    start, stop = map(float, parts)
                    step = 1.0
                elif len(parts) == 3:
                    start, step, stop = map(float, parts)
                else:
                    return match.group(0)  # Return original if format is invalid
                if step == 0:
                    return &#34;Error: &lt;Step cannot be zero.&gt;&#34;
                if (stop - start) / step &gt; 1e6:
                    return &#34;Error: &lt;Range is too large.&gt;&#34;
                if step &gt; 0:
                    num_elements = int(np.floor((stop - start)/step)+1)
                else:
                     num_elements = int(np.floor((start - stop)/-step)+1)
                if num_elements &gt; 100:
                    return match.group(0)  # Return original if too many elements
                expanded_range = np.arange(start, stop + np.sign(step)*1e-9, step) #adding a small number to include the stop in case of integer steps
                return &#39;[&#39; + &#39;,&#39;.join(f&#39;{x:.4g}&#39; for x in expanded_range) + &#39;]&#39;
            except ValueError:
                return &#34;Error: &lt;Invalid range format.&gt;&#34;
        pattern = r&#39;(\b(?:-?\d+(?:\.\d*)?|-?\.\d+)(?::(?:-?\d+(?:\.\d*)?|-?\.\d+)){1,2})\b&#39;
        expanded_text = re.sub(pattern, expand_range, text)
        #check for errors generated by the function
        if &#34;Error:&#34; in expanded_text:
            return expanded_text
        return expanded_text

    # Matlab syntax conversion
    @staticmethod
    def convert_matlab_like_arrays(text):
        &#34;&#34;&#34;
        Converts Matlab-like array syntax (including hybrid notations) into
        a NumPy-esque list syntax in multiple passes.

        Steps:
          1) Convert 2D Matlab arrays (containing semicolons) into Python-like nested lists.
          2) Convert bracketed row vectors (no semicolons or nested brackets) into double-bracket format.
          3) Replace spaces with commas under specific conditions and remove duplicates.

        Args:
            text (str): Input string that may contain Matlab-like arrays.

        Returns:
            str: Transformed text with arrays converted to a Python/NumPy-like syntax.

        Examples:

            examples = [
                &#34;[1, 2  ${var1}          ; 4, 5     ${var2}]&#34;,
                &#34;[1,2,3]&#34;,
                &#34;[1 2 ,  3]&#34;,
                &#34;[1;2; 3]&#34;,
                &#34;[[-0.5, 0.5;-0.5, 0.5],[ -0.5,  0.5; -0.5,  0.5]]&#34;,
                &#34;[[1,2;3,4],[5,6; 7,8]]&#34;,
                &#34;[1, 2, 3; 4, 5, 6]&#34;,  # Hybrid
                &#34;[[Already, in, Python]]&#34;,  # Already Python-like?
                &#34;Not an array&#34;
            ]

            for ex in examples:
                converted = param.convert_matlab_like_arrays(ex)
                print(f&#34;Matlab: {ex}\nNumPy : {converted}\n&#34;)

        &#34;&#34;&#34;
        # --------------------------------------------------------------------------
        # Step 1: Detect innermost [ ... ; ... ] blocks and convert them
        # --------------------------------------------------------------------------
        def convert_matrices_with_semicolons(txt):
            &#34;&#34;&#34;
            Repeatedly find the innermost bracket pair that contains a semicolon
            and convert it to a Python-style nested list, row by row.
            &#34;&#34;&#34;
            # Pattern to find innermost [ ... ; ... ] without nested brackets
            pattern = r&#39;\[[^\[\]]*?;[^\[\]]*?\]&#39;
            while True:
                match = re.search(pattern, txt)
                if not match:
                    break  # No more [ ... ; ... ] blocks to convert
                inner_block = match.group(0)
                # Remove the outer brackets
                inner_content = inner_block[1:-1].strip()
                # Split into rows by semicolon
                rows = [row.strip() for row in inner_content.split(&#39;;&#39;)]
                converted_rows = []
                for row in rows:
                    # Replace multiple spaces with a single space
                    row_clean = re.sub(r&#39;\s+&#39;, &#39; &#39;, row)
                    # Split row by commas or spaces
                    row_elems = re.split(r&#39;[,\s]+&#39;, row_clean)
                    row_elems = [elem for elem in row_elems if elem]  # Remove empty strings
                    # Join elements with commas and encapsulate in brackets
                    converted_rows.append(&#34;[&#34; + &#34;,&#34;.join(row_elems) + &#34;]&#34;)
                # Join the row lists and encapsulate them in brackets
                replacement = &#34;[&#34; + &#34;,&#34;.join(converted_rows) + &#34;]&#34;
                # Replace the original Matlab matrix with the Python list
                txt = txt[:match.start()] + replacement + txt[match.end():]
            return txt
        # --------------------------------------------------------------------------
        # Step 2: Convert row vectors without semicolons or nested brackets
        #         into double-bracket format, e.g. [1,2,3] -&gt; [[1,2,3]]
        # --------------------------------------------------------------------------
        def convert_row_vectors(txt):
            &#34;&#34;&#34;
            Convert [1,2,3] or [1 2 3] into [[1,2,3]] if the bracket does not contain
            semicolons, nor nested brackets. We do this iteratively, skipping any
            bracket blocks that don&#39;t qualify, rather than stopping.
            &#34;&#34;&#34;
            # We only want bracket blocks that are NOT preceded by &#39;[&#39; or &#39;,&#39;
            # do not contain semicolons or nested brackets
            # and are not followed by &#39;]&#39; or &#39;,&#39;
            pattern = r&#34;(?&lt;!\[)(?&lt;!,)\([^();]*\)(?!\s*\])(?!\s*\,)&#34;
            startpos = 0
            while True:
                match = re.search(pattern, txt[startpos:])
                if not match:
                    break  # No more bracket blocks to check
                # Compute absolute positions in txt
                mstart = startpos + match.start()
                mend   = startpos + match.end()
                block  = txt[mstart:mend]
                # we need to be sure that [ ] are present around the block even if separated by spaces
                if mstart == 0 or mend == len(txt) - 1:
                    break
                if not (re.match(r&#34;\[\s*$&#34;, txt[:mstart]) and re.match(r&#34;^\s*\]&#34;, txt[mend+1:])):
                    break
                # Double-check that this bracket does not contain semicolons or nested brackets
                # If it does, we skip it (just advance the search) to avoid messing up matrices.
                # That is, we do not transform it into double brackets.
                if &#39;;&#39; in block or &#39;[&#39; in block[1:-1] or &#39;]&#39; in block[1:-1]:
                    # Move beyond this match and keep searching
                    startpos = mend
                    continue
                # It&#39;s a pure row vector (no semicolons, no nested brackets)
                new_block = &#34;[&#34; + block + &#34;]&#34;  # e.g. [1,2,3] -&gt; [[1,2,3]]
                txt = txt[:mstart] + new_block + txt[mend:]
                # Update search position to avoid re-matching inside the newly inserted text
                startpos = mstart + len(new_block)
            return txt
        # --------------------------------------------------------------------------
        # Step 3: Replace spaces with commas under specific conditions and clean up
        # --------------------------------------------------------------------------
        def replace_spaces_safely(txt):
            &#34;&#34;&#34;
            Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas.
            Then remove multiple consecutive commas and trailing commas before closing brackets.
            &#34;&#34;&#34;
            # 1) Replace spaces with commas if not preceded by [,\s
            #    and followed by digit or $
            txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
            # 2) Remove multiple consecutive commas
            txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
            # 3) Remove trailing commas before closing brackets
            txt = re.sub(r&#39;,+\]&#39;, &#39;]&#39;, txt)
            return txt
        # --------------------------------------------------------------------------
        # Apply Step 1: Convert matrices with semicolons
        # --------------------------------------------------------------------------
        text = convert_matrices_with_semicolons(text)
        # --------------------------------------------------------------------------
        # Apply Step 2: Convert row vectors (no semicolons/nested brackets)
        # --------------------------------------------------------------------------
        text = convert_row_vectors(text)
        # --------------------------------------------------------------------------
        # Apply Step 3: Replace spaces with commas and clean up
        # --------------------------------------------------------------------------
        text = replace_spaces_safely(text)
        return text



    @staticmethod
    def replace_matrix_shorthand(valuesafe):
        &#34;&#34;&#34;
        Transforms custom shorthand notations for NumPy arrays within a string into valid NumPy array constructors.
        Supports up to 4-dimensional arrays and handles variable references.

        **Shorthand Patterns:**
        - **1D**: `$[1 2 3]` → `np.atleast_2d(np.array([1,2,3]))`
        - **2D**: `$[[1 2],[3 4]]` → `np.array([[1,2],[3,4]])`
        - **3D**: `$[[[1 2],[3 4]],[[5 6],[7 8]]]` → `np.array([[[1,2],[3,4]],[[5,6],[7,8]]])`
        - **4D**: `$[[[[1 2]]]]` → `np.array([[[[1,2]]]])`
        - **Variable References**: `@{var}` → `np.atleast_2d(np.array(${var}))`

        **Parameters:**
        ----------
        valuesafe : str
            The input string containing shorthand notations for NumPy arrays and variable references.

        **Returns:**
        -------
        str
            The transformed string with shorthands replaced by valid NumPy array constructors.

        **Raises:**
        -------
        ValueError
            If there are unmatched brackets in any shorthand.

        **Examples:**
        --------
        &gt;&gt;&gt; # 1D shorthand
        &gt;&gt;&gt; s = &#34;$[1 2 3]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.atleast_2d(np.array([1,2,3]))&#39;

        &gt;&gt;&gt; # 2D shorthand with mixed spacing
        &gt;&gt;&gt; s = &#34;$[[1, 2], [3 4]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[1,2],[3,4]])&#39;

        &gt;&gt;&gt; # 3D array with partial spacing
        &gt;&gt;&gt; s = &#34;$[[[1  2], [3 4]], [[5 6], [7 8]]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[1,2],[3,4]],[[5,6],[7,8]]])&#39;

        &gt;&gt;&gt; # 4D array
        &gt;&gt;&gt; s = &#34;$[[[[1 2]]]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[[1,2]]]])&#39;

        &gt;&gt;&gt; # Combined with variable references
        &gt;&gt;&gt; s = &#34;@{a} + $[[${b}, 2],[ 3  4]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.atleast_2d(np.array(${a})) + np.array([[${b},2],[3,4]])&#39;

        &gt;&gt;&gt; # Complex ND array with scaling
        &gt;&gt;&gt; s = &#39;$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*0.001&#39;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[-0.5,-0.5],[-0.5,-0.5]],[[0.5,0.5],[0.5,0.5]]])*0.001&#39;
        &#34;&#34;&#34;
        def replace_spaces_with_commas(txt):
            &#34;&#34;&#34;
            Replaces spaces with commas only when they&#39;re not preceded by a comma, opening bracket, or whitespace,
            and are followed by a digit or &#39;$&#39;. Also collapses multiple commas into one and strips leading/trailing commas.

            Parameters:
            ----------
            txt : str
                The text to process.

            Returns:
            -------
            str
                The processed text with appropriate commas.
            &#34;&#34;&#34;
            # Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas
            txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
            # Remove multiple consecutive commas
            txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
            return txt.strip(&#39;,&#39;)

        def build_pass_list(string):
            &#34;&#34;&#34;
            Determines which dimensions (1D..4D) appear in the string by searching for:
             - 4D: $[[[[
             - 3D: $[[[
             - 2D: $[[
             - 1D: $[

            Returns a sorted list in descending order, e.g., [4, 3, 2, 1].

            Parameters:
            ----------
            string : str
                The input string to scan.

            Returns:
            -------
            list
                A list of integers representing the dimensions found, sorted descending.
            &#34;&#34;&#34;
            dims_found = set()
            if re.search(r&#39;\$\[\[\[\[&#39;, string):
                dims_found.add(4)
            if re.search(r&#39;\$\[\[\[&#39;, string):
                dims_found.add(3)
            if re.search(r&#39;\$\[\[&#39;, string):
                dims_found.add(2)
            if re.search(r&#39;\$\[&#39;, string):
                dims_found.add(1)
            return sorted(dims_found, reverse=True)

        # Step 0: convert eventual Matlab syntax for row and column vectors into NumPy syntax
        valuesafe = param.expand_ranges(valuesafe)  # expands start:stop and start:step:stop syntax
        valuesafe = param.convert_matlab_like_arrays(valuesafe) # vectors and matrices conversion
        # Step 1: Handle @{var} -&gt; np.atleast_2d(np.array(${var}))
        valuesafe = re.sub(r&#39;@\{([^\{\}]+)\}&#39;, r&#39;np.atleast_2d(np.array(${\1}))&#39;, valuesafe)
        # Step 2: Build pass list from largest dimension to smallest
        pass_list = build_pass_list(valuesafe)
        # Step 3: Define patterns and replacements for each dimension
        dimension_patterns = {
            4: (r&#39;\$\[\[\[\[(.*?)\]\]\]\]&#39;, &#39;np.array([[[[{content}]]]])&#39;),   # 4D
            3: (r&#39;\$\[\[\[(.*?)\]\]\]&#39;, &#39;np.array([[[{content}]]])&#39;),         # 3D
            2: (r&#39;\$\[\[(.*?)\]\]&#39;, &#39;np.array([[{content}]])&#39;),               # 2D
            1: (r&#39;\$\[(.*?)\]&#39;, &#39;np.atleast_2d(np.array([{content}]))&#39;)       # 1D
        }
        # Step 4: Iterate over each dimension and perform replacements
        for dim in pass_list:
            pattern, replacement_fmt = dimension_patterns[dim]
            # Find all non-overlapping matches for the current dimension
            matches = list(re.finditer(pattern, valuesafe))
            for match in matches:
                full_match = match.group(0)       # Entire matched shorthand
                inner_content = match.group(1)    # Content inside the brackets
                # Replace spaces with commas as per rules
                processed_content = replace_spaces_with_commas(inner_content.strip())
                # Create the replacement string
                replacement = replacement_fmt.format(content=processed_content)
                # Replace the shorthand in the string
                valuesafe = valuesafe.replace(full_match, replacement)
        # Step 5: Verify that all shorthands have been replaced by checking for remaining &#39;$[&#39;
        if re.search(r&#39;\$\[&#39;, valuesafe):
            raise ValueError(&#34;Unmatched or improperly formatted brackets detected in the input string.&#34;)
        return valuesafe



    # Safe fstring
    @staticmethod
    def safe_fstring(template, context,varprefix=&#34;$&#34;):
        &#34;&#34;&#34;Safely evaluate expressions in ${} using SafeEvaluator.&#34;&#34;&#34;
        evaluator = SafeEvaluator(context)
        # Process template string in combination with safe_fstring()
        # it is required to have an output compatible with eval()

        def process_template(valuesafe):
            &#34;&#34;&#34;
            Processes the input string by:
            1. Stripping leading and trailing whitespace.
            2. Removing comments (any text after &#39;#&#39; unless &#39;#&#39; is the first character).
            3. Replacing &#39;^&#39; with &#39;**&#39;.
            4. Replacing &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;. &lt;-- not applied anymore (brings confusion)

            Args:
                valuesafe (str): The input string to process.

            Returns:
                str: The processed string.
            &#34;&#34;&#34;
            # Step 1: Strip leading and trailing whitespace
            valuesafe = valuesafe.strip()
            # Step 2: Remove comments
            # This regex removes &#39;#&#39; and everything after it if &#39;#&#39; is not the first character
            # (?&lt;!^) is a negative lookbehind that ensures &#39;#&#39; is not at the start of the string
            valuesafe = re.sub(r&#39;(?&lt;!^)\#.*&#39;, &#39;&#39;, valuesafe)
            # Step 3: Replace &#39;^&#39; with &#39;**&#39;
            valuesafe = re.sub(r&#39;\^&#39;, &#39;**&#39;, valuesafe)
            # Step 4: Replace &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;
            # (?&lt;!\$)\{ matches &#39;{&#39; not preceded by &#39;$&#39;
            # valuesafe = re.sub(r&#39;(?&lt;!\$)\{&#39;, &#39;${&#39;, valuesafe)
            # Optional: Strip again to remove any trailing whitespace left after removing comments
            valuesafe = valuesafe.strip()
            return valuesafe

        # Adjusted display for NumPy arrays
        def serialize_result(result):
            &#34;&#34;&#34;
            Serialize the result into a string that can be evaluated in Python.
            Handles NumPy arrays by converting them to lists with commas.
            Handles other iterable types appropriately.
            &#34;&#34;&#34;
            if isinstance(result, np.ndarray):
                return str(result.tolist())
            elif isinstance(result, (list, tuple, dict)):
                return str(result)
            else:
                return str(result)
        # Regular expression to find ${expr} patterns
        escaped_varprefix = re.escape(varprefix)
        pattern = re.compile(escaped_varprefix+r&#39;\{([^{}]+)\}&#39;)
        def replacer(match):
            expr = match.group(1)
            try:
                result = evaluator.evaluate(expr)
                serialized = serialize_result(result)
                return serialized
            except Exception as e:
                return f&#34;&lt;Error: {e}&gt;&#34;
        return pattern.sub(replacer, process_template(template))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.private.mstruct.paramauto</li>
<li>pizza.script.scriptdata</li>
<li><a title="script.scriptdata" href="#script.scriptdata">scriptdata</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="script.param.convert_matlab_like_arrays"><code class="name flex">
<span>def <span class="ident">convert_matlab_like_arrays</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts Matlab-like array syntax (including hybrid notations) into
a NumPy-esque list syntax in multiple passes.</p>
<pre><code>    Steps:
      1) Convert 2D Matlab arrays (containing semicolons) into Python-like nested lists.
      2) Convert bracketed row vectors (no semicolons or nested brackets) into double-bracket format.
      3) Replace spaces with commas under specific conditions and remove duplicates.

    Args:
        text (str): Input string that may contain Matlab-like arrays.

    Returns:
        str: Transformed text with arrays converted to a Python/NumPy-like syntax.

    Examples:

        examples = [
            "[1, 2  ${var1}          ; 4, 5     ${var2}]",
            "[1,2,3]",
            "[1 2 ,  3]",
            "[1;2; 3]",
            "[[-0.5, 0.5;-0.5, 0.5],[ -0.5,  0.5; -0.5,  0.5]]",
            "[[1,2;3,4],[5,6; 7,8]]",
            "[1, 2, 3; 4, 5, 6]",  # Hybrid
            "[[Already, in, Python]]",  # Already Python-like?
            "Not an array"
        ]

        for ex in examples:
            converted = param.convert_matlab_like_arrays(ex)
            print(f"Matlab: {ex}
</code></pre>
<p>NumPy : {converted}
")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convert_matlab_like_arrays(text):
    &#34;&#34;&#34;
    Converts Matlab-like array syntax (including hybrid notations) into
    a NumPy-esque list syntax in multiple passes.

    Steps:
      1) Convert 2D Matlab arrays (containing semicolons) into Python-like nested lists.
      2) Convert bracketed row vectors (no semicolons or nested brackets) into double-bracket format.
      3) Replace spaces with commas under specific conditions and remove duplicates.

    Args:
        text (str): Input string that may contain Matlab-like arrays.

    Returns:
        str: Transformed text with arrays converted to a Python/NumPy-like syntax.

    Examples:

        examples = [
            &#34;[1, 2  ${var1}          ; 4, 5     ${var2}]&#34;,
            &#34;[1,2,3]&#34;,
            &#34;[1 2 ,  3]&#34;,
            &#34;[1;2; 3]&#34;,
            &#34;[[-0.5, 0.5;-0.5, 0.5],[ -0.5,  0.5; -0.5,  0.5]]&#34;,
            &#34;[[1,2;3,4],[5,6; 7,8]]&#34;,
            &#34;[1, 2, 3; 4, 5, 6]&#34;,  # Hybrid
            &#34;[[Already, in, Python]]&#34;,  # Already Python-like?
            &#34;Not an array&#34;
        ]

        for ex in examples:
            converted = param.convert_matlab_like_arrays(ex)
            print(f&#34;Matlab: {ex}\nNumPy : {converted}\n&#34;)

    &#34;&#34;&#34;
    # --------------------------------------------------------------------------
    # Step 1: Detect innermost [ ... ; ... ] blocks and convert them
    # --------------------------------------------------------------------------
    def convert_matrices_with_semicolons(txt):
        &#34;&#34;&#34;
        Repeatedly find the innermost bracket pair that contains a semicolon
        and convert it to a Python-style nested list, row by row.
        &#34;&#34;&#34;
        # Pattern to find innermost [ ... ; ... ] without nested brackets
        pattern = r&#39;\[[^\[\]]*?;[^\[\]]*?\]&#39;
        while True:
            match = re.search(pattern, txt)
            if not match:
                break  # No more [ ... ; ... ] blocks to convert
            inner_block = match.group(0)
            # Remove the outer brackets
            inner_content = inner_block[1:-1].strip()
            # Split into rows by semicolon
            rows = [row.strip() for row in inner_content.split(&#39;;&#39;)]
            converted_rows = []
            for row in rows:
                # Replace multiple spaces with a single space
                row_clean = re.sub(r&#39;\s+&#39;, &#39; &#39;, row)
                # Split row by commas or spaces
                row_elems = re.split(r&#39;[,\s]+&#39;, row_clean)
                row_elems = [elem for elem in row_elems if elem]  # Remove empty strings
                # Join elements with commas and encapsulate in brackets
                converted_rows.append(&#34;[&#34; + &#34;,&#34;.join(row_elems) + &#34;]&#34;)
            # Join the row lists and encapsulate them in brackets
            replacement = &#34;[&#34; + &#34;,&#34;.join(converted_rows) + &#34;]&#34;
            # Replace the original Matlab matrix with the Python list
            txt = txt[:match.start()] + replacement + txt[match.end():]
        return txt
    # --------------------------------------------------------------------------
    # Step 2: Convert row vectors without semicolons or nested brackets
    #         into double-bracket format, e.g. [1,2,3] -&gt; [[1,2,3]]
    # --------------------------------------------------------------------------
    def convert_row_vectors(txt):
        &#34;&#34;&#34;
        Convert [1,2,3] or [1 2 3] into [[1,2,3]] if the bracket does not contain
        semicolons, nor nested brackets. We do this iteratively, skipping any
        bracket blocks that don&#39;t qualify, rather than stopping.
        &#34;&#34;&#34;
        # We only want bracket blocks that are NOT preceded by &#39;[&#39; or &#39;,&#39;
        # do not contain semicolons or nested brackets
        # and are not followed by &#39;]&#39; or &#39;,&#39;
        pattern = r&#34;(?&lt;!\[)(?&lt;!,)\([^();]*\)(?!\s*\])(?!\s*\,)&#34;
        startpos = 0
        while True:
            match = re.search(pattern, txt[startpos:])
            if not match:
                break  # No more bracket blocks to check
            # Compute absolute positions in txt
            mstart = startpos + match.start()
            mend   = startpos + match.end()
            block  = txt[mstart:mend]
            # we need to be sure that [ ] are present around the block even if separated by spaces
            if mstart == 0 or mend == len(txt) - 1:
                break
            if not (re.match(r&#34;\[\s*$&#34;, txt[:mstart]) and re.match(r&#34;^\s*\]&#34;, txt[mend+1:])):
                break
            # Double-check that this bracket does not contain semicolons or nested brackets
            # If it does, we skip it (just advance the search) to avoid messing up matrices.
            # That is, we do not transform it into double brackets.
            if &#39;;&#39; in block or &#39;[&#39; in block[1:-1] or &#39;]&#39; in block[1:-1]:
                # Move beyond this match and keep searching
                startpos = mend
                continue
            # It&#39;s a pure row vector (no semicolons, no nested brackets)
            new_block = &#34;[&#34; + block + &#34;]&#34;  # e.g. [1,2,3] -&gt; [[1,2,3]]
            txt = txt[:mstart] + new_block + txt[mend:]
            # Update search position to avoid re-matching inside the newly inserted text
            startpos = mstart + len(new_block)
        return txt
    # --------------------------------------------------------------------------
    # Step 3: Replace spaces with commas under specific conditions and clean up
    # --------------------------------------------------------------------------
    def replace_spaces_safely(txt):
        &#34;&#34;&#34;
        Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas.
        Then remove multiple consecutive commas and trailing commas before closing brackets.
        &#34;&#34;&#34;
        # 1) Replace spaces with commas if not preceded by [,\s
        #    and followed by digit or $
        txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
        # 2) Remove multiple consecutive commas
        txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
        # 3) Remove trailing commas before closing brackets
        txt = re.sub(r&#39;,+\]&#39;, &#39;]&#39;, txt)
        return txt
    # --------------------------------------------------------------------------
    # Apply Step 1: Convert matrices with semicolons
    # --------------------------------------------------------------------------
    text = convert_matrices_with_semicolons(text)
    # --------------------------------------------------------------------------
    # Apply Step 2: Convert row vectors (no semicolons/nested brackets)
    # --------------------------------------------------------------------------
    text = convert_row_vectors(text)
    # --------------------------------------------------------------------------
    # Apply Step 3: Replace spaces with commas and clean up
    # --------------------------------------------------------------------------
    text = replace_spaces_safely(text)
    return text</code></pre>
</details>
</dd>
<dt id="script.param.escape"><code class="name flex">
<span>def <span class="ident">escape</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>escape \${} as ${{}} &ndash;&gt; keep variable names
convert ${} as {} &ndash;&gt; prepare Python replacement</p>
<h2 id="examples">Examples</h2>
<p>escape("\${a}")
returns ('${{a}}', True)</p>
<p>escape("
\${abc} ${a} \${bc}")
returns ('
${{abc}} {a} ${{bc}}', True)</p>
<p>escape("${a}")
Out[94]: ('{a}', False)</p>
<p>escape("${tata}")
returns ('{tata}', False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def escape(s):
    &#34;&#34;&#34;
        escape \${} as ${{}} --&gt; keep variable names
        convert ${} as {} --&gt; prepare Python replacement

        Examples:
            escape(&#34;\${a}&#34;)
            returns (&#39;${{a}}&#39;, True)

            escape(&#34;  \${abc} ${a} \${bc}&#34;)
            returns (&#39;  ${{abc}} {a} ${{bc}}&#39;, True)

            escape(&#34;${a}&#34;)
            Out[94]: (&#39;{a}&#39;, False)

            escape(&#34;${tata}&#34;)
            returns (&#39;{tata}&#39;, False)

    &#34;&#34;&#34;
    if not isinstance(s,str):
        raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)
    se, start, found = &#34;&#34;, 0, True
    while found:
        pos0 = s.find(&#34;\${&#34;,start)
        found = pos0&gt;=0
        if found:
            pos1 = s.find(&#34;}&#34;,pos0)
            found = pos1&gt;=0
            if found:
                se += s[start:pos0].replace(&#34;${&#34;,&#34;{&#34;)+&#34;${{&#34;+s[pos0+3:pos1]+&#34;}}&#34;
                start=pos1+1
    result = se+s[start:].replace(&#34;${&#34;,&#34;{&#34;)
    if isinstance(s,pstr): result = pstr(result)
    return result,start&gt;0</code></pre>
</details>
</dd>
<dt id="script.param.replace_matrix_shorthand"><code class="name flex">
<span>def <span class="ident">replace_matrix_shorthand</span></span>(<span>valuesafe)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms custom shorthand notations for NumPy arrays within a string into valid NumPy array constructors.
Supports up to 4-dimensional arrays and handles variable references.</p>
<p><strong>Shorthand Patterns:</strong>
- <strong>1D</strong>: <code>$[1 2 3]</code> → <code>np.atleast_2d(np.array([1,2,3]))</code>
- <strong>2D</strong>: <code>$[[1 2],[3 4]]</code> → <code>np.array([[1,2],[3,4]])</code>
- <strong>3D</strong>: <code>$[[[1 2],[3 4]],[[5 6],[7 8]]]</code> → <code>np.array([[[1,2],[3,4]],[[5,6],[7,8]]])</code>
- <strong>4D</strong>: <code>$[[[[1 2]]]]</code> → <code>np.array([[[[1,2]]]])</code>
- <strong>Variable References</strong>: <code>@{var}</code> → <code>np.atleast_2d(np.array(${var}))</code></p>
<h2 id="parameters"><strong>Parameters:</strong></h2>
<p>valuesafe : str
The input string containing shorthand notations for NumPy arrays and variable references.</p>
<h2 id="returns"><strong>Returns:</strong></h2>
<p>str
The transformed string with shorthands replaced by valid NumPy array constructors.</p>
<h2 id="raises"><strong>Raises:</strong></h2>
<p>ValueError
If there are unmatched brackets in any shorthand.</p>
<h2 id="examples"><strong>Examples:</strong></h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 1D shorthand
&gt;&gt;&gt; s = &quot;$[1 2 3]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.atleast_2d(np.array([1,2,3]))'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 2D shorthand with mixed spacing
&gt;&gt;&gt; s = &quot;$[[1, 2], [3 4]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[1,2],[3,4]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 3D array with partial spacing
&gt;&gt;&gt; s = &quot;$[[[1  2], [3 4]], [[5 6], [7 8]]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[[1,2],[3,4]],[[5,6],[7,8]]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 4D array
&gt;&gt;&gt; s = &quot;$[[[[1 2]]]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[[[1,2]]]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Combined with variable references
&gt;&gt;&gt; s = &quot;@{a} + $[[${b}, 2],[ 3  4]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.atleast_2d(np.array(${a})) + np.array([[${b},2],[3,4]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Complex ND array with scaling
&gt;&gt;&gt; s = '$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*0.001'
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[[-0.5,-0.5],[-0.5,-0.5]],[[0.5,0.5],[0.5,0.5]]])*0.001'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def replace_matrix_shorthand(valuesafe):
    &#34;&#34;&#34;
    Transforms custom shorthand notations for NumPy arrays within a string into valid NumPy array constructors.
    Supports up to 4-dimensional arrays and handles variable references.

    **Shorthand Patterns:**
    - **1D**: `$[1 2 3]` → `np.atleast_2d(np.array([1,2,3]))`
    - **2D**: `$[[1 2],[3 4]]` → `np.array([[1,2],[3,4]])`
    - **3D**: `$[[[1 2],[3 4]],[[5 6],[7 8]]]` → `np.array([[[1,2],[3,4]],[[5,6],[7,8]]])`
    - **4D**: `$[[[[1 2]]]]` → `np.array([[[[1,2]]]])`
    - **Variable References**: `@{var}` → `np.atleast_2d(np.array(${var}))`

    **Parameters:**
    ----------
    valuesafe : str
        The input string containing shorthand notations for NumPy arrays and variable references.

    **Returns:**
    -------
    str
        The transformed string with shorthands replaced by valid NumPy array constructors.

    **Raises:**
    -------
    ValueError
        If there are unmatched brackets in any shorthand.

    **Examples:**
    --------
    &gt;&gt;&gt; # 1D shorthand
    &gt;&gt;&gt; s = &#34;$[1 2 3]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.atleast_2d(np.array([1,2,3]))&#39;

    &gt;&gt;&gt; # 2D shorthand with mixed spacing
    &gt;&gt;&gt; s = &#34;$[[1, 2], [3 4]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[1,2],[3,4]])&#39;

    &gt;&gt;&gt; # 3D array with partial spacing
    &gt;&gt;&gt; s = &#34;$[[[1  2], [3 4]], [[5 6], [7 8]]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[[1,2],[3,4]],[[5,6],[7,8]]])&#39;

    &gt;&gt;&gt; # 4D array
    &gt;&gt;&gt; s = &#34;$[[[[1 2]]]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[[[1,2]]]])&#39;

    &gt;&gt;&gt; # Combined with variable references
    &gt;&gt;&gt; s = &#34;@{a} + $[[${b}, 2],[ 3  4]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.atleast_2d(np.array(${a})) + np.array([[${b},2],[3,4]])&#39;

    &gt;&gt;&gt; # Complex ND array with scaling
    &gt;&gt;&gt; s = &#39;$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*0.001&#39;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[[-0.5,-0.5],[-0.5,-0.5]],[[0.5,0.5],[0.5,0.5]]])*0.001&#39;
    &#34;&#34;&#34;
    def replace_spaces_with_commas(txt):
        &#34;&#34;&#34;
        Replaces spaces with commas only when they&#39;re not preceded by a comma, opening bracket, or whitespace,
        and are followed by a digit or &#39;$&#39;. Also collapses multiple commas into one and strips leading/trailing commas.

        Parameters:
        ----------
        txt : str
            The text to process.

        Returns:
        -------
        str
            The processed text with appropriate commas.
        &#34;&#34;&#34;
        # Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas
        txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
        # Remove multiple consecutive commas
        txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
        return txt.strip(&#39;,&#39;)

    def build_pass_list(string):
        &#34;&#34;&#34;
        Determines which dimensions (1D..4D) appear in the string by searching for:
         - 4D: $[[[[
         - 3D: $[[[
         - 2D: $[[
         - 1D: $[

        Returns a sorted list in descending order, e.g., [4, 3, 2, 1].

        Parameters:
        ----------
        string : str
            The input string to scan.

        Returns:
        -------
        list
            A list of integers representing the dimensions found, sorted descending.
        &#34;&#34;&#34;
        dims_found = set()
        if re.search(r&#39;\$\[\[\[\[&#39;, string):
            dims_found.add(4)
        if re.search(r&#39;\$\[\[\[&#39;, string):
            dims_found.add(3)
        if re.search(r&#39;\$\[\[&#39;, string):
            dims_found.add(2)
        if re.search(r&#39;\$\[&#39;, string):
            dims_found.add(1)
        return sorted(dims_found, reverse=True)

    # Step 0: convert eventual Matlab syntax for row and column vectors into NumPy syntax
    valuesafe = param.expand_ranges(valuesafe)  # expands start:stop and start:step:stop syntax
    valuesafe = param.convert_matlab_like_arrays(valuesafe) # vectors and matrices conversion
    # Step 1: Handle @{var} -&gt; np.atleast_2d(np.array(${var}))
    valuesafe = re.sub(r&#39;@\{([^\{\}]+)\}&#39;, r&#39;np.atleast_2d(np.array(${\1}))&#39;, valuesafe)
    # Step 2: Build pass list from largest dimension to smallest
    pass_list = build_pass_list(valuesafe)
    # Step 3: Define patterns and replacements for each dimension
    dimension_patterns = {
        4: (r&#39;\$\[\[\[\[(.*?)\]\]\]\]&#39;, &#39;np.array([[[[{content}]]]])&#39;),   # 4D
        3: (r&#39;\$\[\[\[(.*?)\]\]\]&#39;, &#39;np.array([[[{content}]]])&#39;),         # 3D
        2: (r&#39;\$\[\[(.*?)\]\]&#39;, &#39;np.array([[{content}]])&#39;),               # 2D
        1: (r&#39;\$\[(.*?)\]&#39;, &#39;np.atleast_2d(np.array([{content}]))&#39;)       # 1D
    }
    # Step 4: Iterate over each dimension and perform replacements
    for dim in pass_list:
        pattern, replacement_fmt = dimension_patterns[dim]
        # Find all non-overlapping matches for the current dimension
        matches = list(re.finditer(pattern, valuesafe))
        for match in matches:
            full_match = match.group(0)       # Entire matched shorthand
            inner_content = match.group(1)    # Content inside the brackets
            # Replace spaces with commas as per rules
            processed_content = replace_spaces_with_commas(inner_content.strip())
            # Create the replacement string
            replacement = replacement_fmt.format(content=processed_content)
            # Replace the shorthand in the string
            valuesafe = valuesafe.replace(full_match, replacement)
    # Step 5: Verify that all shorthands have been replaced by checking for remaining &#39;$[&#39;
    if re.search(r&#39;\$\[&#39;, valuesafe):
        raise ValueError(&#34;Unmatched or improperly formatted brackets detected in the input string.&#34;)
    return valuesafe</code></pre>
</details>
</dd>
<dt id="script.param.safe_fstring"><code class="name flex">
<span>def <span class="ident">safe_fstring</span></span>(<span>template, context, varprefix='$')</span>
</code></dt>
<dd>
<div class="desc"><p>Safely evaluate expressions in ${} using SafeEvaluator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def safe_fstring(template, context,varprefix=&#34;$&#34;):
    &#34;&#34;&#34;Safely evaluate expressions in ${} using SafeEvaluator.&#34;&#34;&#34;
    evaluator = SafeEvaluator(context)
    # Process template string in combination with safe_fstring()
    # it is required to have an output compatible with eval()

    def process_template(valuesafe):
        &#34;&#34;&#34;
        Processes the input string by:
        1. Stripping leading and trailing whitespace.
        2. Removing comments (any text after &#39;#&#39; unless &#39;#&#39; is the first character).
        3. Replacing &#39;^&#39; with &#39;**&#39;.
        4. Replacing &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;. &lt;-- not applied anymore (brings confusion)

        Args:
            valuesafe (str): The input string to process.

        Returns:
            str: The processed string.
        &#34;&#34;&#34;
        # Step 1: Strip leading and trailing whitespace
        valuesafe = valuesafe.strip()
        # Step 2: Remove comments
        # This regex removes &#39;#&#39; and everything after it if &#39;#&#39; is not the first character
        # (?&lt;!^) is a negative lookbehind that ensures &#39;#&#39; is not at the start of the string
        valuesafe = re.sub(r&#39;(?&lt;!^)\#.*&#39;, &#39;&#39;, valuesafe)
        # Step 3: Replace &#39;^&#39; with &#39;**&#39;
        valuesafe = re.sub(r&#39;\^&#39;, &#39;**&#39;, valuesafe)
        # Step 4: Replace &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;
        # (?&lt;!\$)\{ matches &#39;{&#39; not preceded by &#39;$&#39;
        # valuesafe = re.sub(r&#39;(?&lt;!\$)\{&#39;, &#39;${&#39;, valuesafe)
        # Optional: Strip again to remove any trailing whitespace left after removing comments
        valuesafe = valuesafe.strip()
        return valuesafe

    # Adjusted display for NumPy arrays
    def serialize_result(result):
        &#34;&#34;&#34;
        Serialize the result into a string that can be evaluated in Python.
        Handles NumPy arrays by converting them to lists with commas.
        Handles other iterable types appropriately.
        &#34;&#34;&#34;
        if isinstance(result, np.ndarray):
            return str(result.tolist())
        elif isinstance(result, (list, tuple, dict)):
            return str(result)
        else:
            return str(result)
    # Regular expression to find ${expr} patterns
    escaped_varprefix = re.escape(varprefix)
    pattern = re.compile(escaped_varprefix+r&#39;\{([^{}]+)\}&#39;)
    def replacer(match):
        expr = match.group(1)
        try:
            result = evaluator.evaluate(expr)
            serialized = serialize_result(result)
            return serialized
        except Exception as e:
            return f&#34;&lt;Error: {e}&gt;&#34;
    return pattern.sub(replacer, process_template(template))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="script.param.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>self, s='', protection=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Eval method for structure such as MS.alias</p>
<pre><code>s = p.eval() or s = p.eval(string)

where :
    p is a param object
    s is a structure with evaluated fields
    string is only used to determine whether definitions have been forgotten
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval(self,s=&#34;&#34;,protection=False):
    &#34;&#34;&#34;
        Eval method for structure such as MS.alias

            s = p.eval() or s = p.eval(string)

            where :
                p is a param object
                s is a structure with evaluated fields
                string is only used to determine whether definitions have been forgotten

    &#34;&#34;&#34;
    # Evaluate all DEFINITIONS
    # the argument s is only used by formateval() for error management
    tmp = struct()
    for key,value in self.items():
        # strings are assumed to be expressions on one single line
        if isinstance(value,str):
            # replace ${variable} (Bash, Lammps syntax) by {variable} (Python syntax)
            # use \${variable} to prevent replacement (espace with \)
            # Protect variables if required
            ispstr = isinstance(value,pstr)
            valuesafe = pstr.eval(value,ispstr=ispstr) # value.strip()
            if valuesafe==&#34;${&#34;+key+&#34;}&#34;: # circular reference (it cannot be evaluated)
                continue
            if protection or self._protection:
                valuesafe, escape0 = self.protect(valuesafe)
            else:
                escape0 = False
            # replace ${var} by {var}
            valuesafe_priorescape = valuesafe
            valuesafe, escape = param.escape(valuesafe)
            escape = escape or escape0
            # replace &#34;^&#34; (Matlab, Lammps exponent) by &#34;**&#34; (Python syntax)
            valuesafe = pstr.eval(valuesafe.replace(&#34;^&#34;,&#34;**&#34;),ispstr=ispstr)
            # Remove all content after #
            # if the first character is &#39;#&#39;, it is not comment (e.g. MarkDown titles)
            poscomment = valuesafe.find(&#34;#&#34;)
            if poscomment&gt;0: valuesafe = valuesafe[0:poscomment].strip()
            # Matrix shorthand replacement
            # $[[1,2,${a}]]+$[[10,20,30]] --&gt; np.array([[1,2,${a}]])+np.array([[10,20,30]])
            valuesafe = param.replace_matrix_shorthand(valuesafe)
            # Literal string starts with $ (no interpretation), ! (evaluation)
            if not self._evaluation:
                tmp.setattr(key, pstr.eval(tmp.format(valuesafe,escape),ispstr=ispstr))
            elif valuesafe.startswith(&#34;!&#34;):
                try:
                    vtmp = ast.literal_eval(valuesafe[1:])
                    if isinstance(vtmp,list):
                        for i,item in enumerate(vtmp):
                            if isinstance(item,str) and not item.strip().startswith(&#34;$&#34;):
                                try:
                                    vtmp[i] = tmp.format(item, raiseerror=False)
                                except Exception as ve:
                                    vtmp[i] = f&#34;Error in &lt;{item}&gt;: {ve.__class__.__name__} - {str(ve)}&#34;
                    tmp.setattr(key,vtmp)
                except (SyntaxError, ValueError) as e:
                    tmp.setattr(key, f&#34;Error: {e.__class__.__name__} - {str(e)}&#34;)
            elif valuesafe.startswith(&#34;$&#34;) and not escape:
                tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard $
            elif valuesafe.startswith(&#34;%&#34;):
                tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard %
            else: # string empty or which can be evaluated
                if valuesafe==&#34;&#34;:
                    tmp.setattr(key,valuesafe) # empty content
                else:
                    if isinstance(value,pstr): # keep path
                        tmp.setattr(key, pstr.topath(tmp.format(valuesafe,escape=escape)))
                    elif escape:  # partial evaluation
                        tmp.setattr(key, tmp.format(valuesafe,escape=True))
                    else: # full evaluation (if it fails the last string content is returned)
                        try:
                            resstr = tmp.format(valuesafe,raiseerror=False)
                        except (KeyError,NameError) as nameerr:
                            if self._returnerror: # added on 2024-09-06
                                strnameerr = str(nameerr).replace(&#34;&#39;&#34;,&#34;&#34;)
                                tmp.setattr(key,&#39;&lt; undef %s &#34;${%s}&#34; &gt;&#39; % \
                                        (self._ftype,strnameerr))
                            else:
                                tmp.setattr(key,value) #we keep the original value
                        except (SyntaxError,TypeError,ValueError) as commonerr:
                            tmp.setattr(key,&#34;ERROR &lt; %s &gt;&#34; % commonerr)
                        except (IndexError,AttributeError):
                            try:
                                resstr = param.safe_fstring(
                                    param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                            except Exception as fstrerr:
                                tmp.setattr(key,&#34;Index Error &lt; %s &gt;&#34; % fstrerr)
                            else:
                                try:
                                    # reseval = eval(resstr)
                                    # reseval = ast.literal_eval(resstr)
                                    # Use SafeEvaluator to evaluate the final expression
                                    evaluator = SafeEvaluator(tmp)
                                    reseval = evaluator.evaluate(resstr)
                                except Exception as othererr:
                                    #tmp.setattr(key,&#34;Mathematical Error around/in ${}: &lt; %s &gt;&#34; % othererr)
                                    if self._debug:
                                        print(f&#34;DEBUG {key}: Error in Evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                    tmp.setattr(key,resstr)
                                else:
                                    tmp.setattr(key,reseval)
                        except Exception as othererr:
                            tmp.setattr(key,&#34;Error in ${}: &lt; %s &gt;&#34; % othererr)
                        else:
                            try:
                                # reseval = eval(resstr)
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluator.evaluate(resstr)
                            except Exception as othererr:
                                #tmp.setattr(key,&#34;Eval Error &lt; %s &gt;&#34; % othererr)
                                if self._debug:
                                    print(f&#34;DEBUG {key}: Error in Evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                tmp.setattr(key,resstr.replace(&#34;\n&#34;,&#34;,&#34;)) # \n replaced by ,
                            else:
                                tmp.setattr(key,reseval)
        elif isinstance(value,_numeric_types): # already a number
            tmp.setattr(key, value) # store the value with the key
        else: # unsupported types
            if s.find(&#34;{&#34;+key+&#34;}&#34;)&gt;=0:
                print(f&#39;*** WARNING ***\n\tIn the {self._ftype}:&#34;\n{s}\n&#34;&#39;)
            else:
                print(f&#39;unable to interpret the &#34;{key}&#34; of type {type(value)}&#39;)
    return tmp</code></pre>
</details>
</dd>
<dt id="script.param.expand_ranges"><code class="name flex">
<span>def <span class="ident">expand_ranges</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Expands MATLAB-style ranges in a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>The input string containing ranges.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The string with ranges expanded, or the original string if no valid ranges are found
or if expansion leads to more than 100 elements. Returns an error message if the input
format is invalid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_ranges(text):
    &#34;&#34;&#34;
    Expands MATLAB-style ranges in a string.

    Args:
        text: The input string containing ranges.

    Returns:
        The string with ranges expanded, or the original string if no valid ranges are found
        or if expansion leads to more than 100 elements. Returns an error message if the input
        format is invalid.
    &#34;&#34;&#34;
    def expand_range(match):
        try:
            parts = match.group(1).split(&#39;:&#39;)
            if len(parts) == 2:
                start, stop = map(float, parts)
                step = 1.0
            elif len(parts) == 3:
                start, step, stop = map(float, parts)
            else:
                return match.group(0)  # Return original if format is invalid
            if step == 0:
                return &#34;Error: &lt;Step cannot be zero.&gt;&#34;
            if (stop - start) / step &gt; 1e6:
                return &#34;Error: &lt;Range is too large.&gt;&#34;
            if step &gt; 0:
                num_elements = int(np.floor((stop - start)/step)+1)
            else:
                 num_elements = int(np.floor((start - stop)/-step)+1)
            if num_elements &gt; 100:
                return match.group(0)  # Return original if too many elements
            expanded_range = np.arange(start, stop + np.sign(step)*1e-9, step) #adding a small number to include the stop in case of integer steps
            return &#39;[&#39; + &#39;,&#39;.join(f&#39;{x:.4g}&#39; for x in expanded_range) + &#39;]&#39;
        except ValueError:
            return &#34;Error: &lt;Invalid range format.&gt;&#34;
    pattern = r&#39;(\b(?:-?\d+(?:\.\d*)?|-?\.\d+)(?::(?:-?\d+(?:\.\d*)?|-?\.\d+)){1,2})\b&#39;
    expanded_text = re.sub(pattern, expand_range, text)
    #check for errors generated by the function
    if &#34;Error:&#34; in expanded_text:
        return expanded_text
    return expanded_text</code></pre>
</details>
</dd>
<dt id="script.param.formateval"><code class="name flex">
<span>def <span class="ident">formateval</span></span>(<span>self, s, protection=False, fullevaluation=True)</span>
</code></dt>
<dd>
<div class="desc"><p>format method with evaluation feature</p>
<pre><code>txt = p.formateval("this my text with ${variable1}, ${variable2} ")

where:
    p is a param object

Example:
    definitions = param(a=1,b="${a}",c="\${a}")
    text = definitions.formateval("this my text ${a}, ${b}, ${c}")
    print(text)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formateval(self,s,protection=False,fullevaluation=True):
    &#34;&#34;&#34;
        format method with evaluation feature

            txt = p.formateval(&#34;this my text with ${variable1}, ${variable2} &#34;)

            where:
                p is a param object

            Example:
                definitions = param(a=1,b=&#34;${a}&#34;,c=&#34;\${a}&#34;)
                text = definitions.formateval(&#34;this my text ${a}, ${b}, ${c}&#34;)
                print(text)

    &#34;&#34;&#34;
    tmp = self.eval(s,protection=protection)
    evaluator = SafeEvaluator(tmp) # used when fullevaluation=True
    # Do all replacements in s (keep comments)
    if len(tmp)==0:
        return s
    else:
        ispstr = isinstance(s,pstr)
        ssafe, escape = param.escape(s)
        slines = ssafe.split(&#34;\n&#34;)
        for i in range(len(slines)):
            poscomment = slines[i].find(&#34;#&#34;)
            if poscomment&gt;=0:
                while (poscomment&gt;0) and (slines[i][poscomment-1]==&#34; &#34;):
                    poscomment -= 1
                comment = slines[i][poscomment:len(slines[i])]
                slines[i]  = slines[i][0:poscomment]
            else:
                comment = &#34;&#34;
            # Protect variables if required
            if protection or self._protection:
                slines[i], escape2 = self.protect(slines[i])
            # conversion
            if ispstr:
                slines[i] = pstr.eval(tmp.format(slines[i],escape=escape),ispstr=ispstr)
            else:
                if fullevaluation:
                    try:
                        resstr =tmp.format(slines[i],escape=escape)
                    except:
                        resstr = param.safe_fstring(slines[i],tmp,varprefix=&#34;&#34;)
                    try:
                        reseval = evaluator.evaluate(resstr)
                        slines[i] = str(reseval)+&#34; &#34;+comment if comment else str(reseval)
                    except:
                        slines[i] = resstr + comment
                else:
                    slines[i] = tmp.format(slines[i],escape=escape)+comment
            # convert starting % into # to authorize replacement in comments
            if len(slines[i])&gt;0:
                if slines[i][0] == &#34;%&#34;: slines[i]=&#34;#&#34;+slines[i][1:]
        return &#34;\n&#34;.join(slines)</code></pre>
</details>
</dd>
<dt id="script.param.protect"><code class="name flex">
<span>def <span class="ident">protect</span></span>(<span>self, s='')</span>
</code></dt>
<dd>
<div class="desc"><p>protect $variable as ${variable}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protect(self,s=&#34;&#34;):
    &#34;&#34;&#34; protect $variable as ${variable} &#34;&#34;&#34;
    if isinstance(s,str):
        t = s.replace(&#34;\$&#34;,&#34;££&#34;) # &amp;&amp; is a placeholder
        escape = t!=s
        for k in self.keyssorted():
            t = t.replace(&#34;$&#34;+k,&#34;${&#34;+k+&#34;}&#34;)
        if escape: t = t.replace(&#34;££&#34;,&#34;\$&#34;)
        if isinstance(s,pstr): t = pstr(t)
        return t, escape
    raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)</code></pre>
</details>
</dd>
<dt id="script.param.tostatic"><code class="name flex">
<span>def <span class="ident">tostatic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>convert dynamic a param() object to a static struct() object.
note: no interpretation
note: use tostruct() to interpret them and convert it to struct
note: tostatic().struct2param() makes it reversible</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tostatic(self):
    &#34;&#34;&#34; convert dynamic a param() object to a static struct() object.
        note: no interpretation
        note: use tostruct() to interpret them and convert it to struct
        note: tostatic().struct2param() makes it reversible
    &#34;&#34;&#34;
    return struct.fromkeysvalues(self.keys(),self.values(),makeparam=False)</code></pre>
</details>
</dd>
<dt id="script.param.tostruct"><code class="name flex">
<span>def <span class="ident">tostruct</span></span>(<span>self, protection=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generate the evaluated structure
tostruct(protection=False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tostruct(self,protection=False):
    &#34;&#34;&#34;
        generate the evaluated structure
            tostruct(protection=False)
    &#34;&#34;&#34;
    return self.eval(protection=protection)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="script.paramauto"><code class="flex name class">
<span>class <span class="ident">paramauto</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-paramauto">Class: <code><a title="script.paramauto" href="#script.paramauto">paramauto</a></code></h1>
<p>A subclass of <code><a title="script.param" href="#script.param">param</a></code> with enhanced handling for automatic sorting and evaluation
of definitions. The <code><a title="script.paramauto" href="#script.paramauto">paramauto</a></code> class ensures that all fields are sorted to resolve
dependencies, allowing seamless stacking of partially defined objects.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Inherits all functionalities of <code><a title="script.param" href="#script.param">param</a></code>.</li>
<li>Automatically sorts definitions for dependency resolution.</li>
<li>Simplifies handling of partial definitions in dynamic structures.</li>
<li>Supports safe concatenation of definitions.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="automatic-dependency-sorting">Automatic Dependency Sorting</h4>
<p>Definitions are automatically sorted to resolve dependencies:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${b}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${b} (= 3)
# --------
</code></pre>
<h4 id="handling-missing-definitions">Handling Missing Definitions</h4>
<p>Unresolved dependencies raise warnings but do not block execution:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${d}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-inheritance">Concatenation and Inheritance</h3>
<p>Concatenating <code><a title="script.paramauto" href="#script.paramauto">paramauto</a></code> objects resolves definitions:</p>
<pre><code class="language-python">p1 = paramauto(a=1, b=&quot;${a}+2&quot;)
p2 = paramauto(c=&quot;${b}*3&quot;)
p3 = p1 + p2
p3.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 2 (= 3)
#      c: ${b} * 3 (= 9)
# --------
</code></pre>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Automatically sorts fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate all fields, resolving dependencies.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display all fields with their resolved values.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="overloaded-operators">Overloaded Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenates two <code><a title="script.paramauto" href="#script.paramauto">paramauto</a></code> objects, resolving dependencies.</li>
<li><code>+=</code>: Updates the current object with another, resolving dependencies.</li>
<li><code>len()</code>: Number of fields.</li>
<li><code>in</code>: Check for field existence.</li>
</ul>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="partial-definitions">Partial Definitions</h4>
<p>The <code><a title="script.paramauto" href="#script.paramauto">paramauto</a></code> class simplifies handling of partially defined fields:</p>
<pre><code class="language-python">p = paramauto(a=&quot;${d}&quot;, b=&quot;${a}+1&quot;)
p.disp()
# Warning: Unable to resolve dependencies.
# --------
#      a: ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
#      b: ${a} + 1 (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------

p.d = 10
p.disp()
# Dependencies are resolved:
# --------
#      d: 10
#      a: ${d} (= 10)
#      b: ${a} + 1 (= 11)
# --------
</code></pre>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>The <code><a title="script.paramauto" href="#script.paramauto">paramauto</a></code> class is computationally more intensive than <code><a title="script.param" href="#script.param">param</a></code> due to automatic sorting.</li>
<li>It is ideal for managing dynamic systems with complex interdependencies.</li>
</ul>
<h3 id="examples_1">Examples</h3>
<pre><code>            p = paramauto()
            p.b = "${aa}"
            p.disp()
        yields
            WARNING: unable to interpret 1/1 expressions in "definitions"
              -----------:----------------------------------------
                        b: ${aa}
                         = &lt; undef definition "${aa}" &gt;
              -----------:----------------------------------------
              p.aa = 2
              p.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
            -----------:----------------------------------------
            q = paramauto(c="${aa}+${b}")+p
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
                      c: ${aa}+${b}
                       = 4
            -----------:----------------------------------------
            q.aa = 30
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 30
                      b: ${aa}
                       = 30
                      c: ${aa}+${b}
                       = 60
            -----------:----------------------------------------
            q.aa = "${d}"
            q.disp()
        yields multiple errors (recursion)
        WARNING: unable to interpret 3/3 expressions in "definitions"
          -----------:----------------------------------------
                   aa: ${d}
                     = &lt; undef definition "${d}" &gt;
                    b: ${aa}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                    c: ${aa}+${b}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
          -----------:----------------------------------------
            q.d = 100
            q.disp()
        yields
          -----------:----------------------------------------
                    d: 100
                   aa: ${d}
                     = 100
                    b: ${aa}
                     = 100
                    c: ${aa}+${b}
                     = 200
          -----------:----------------------------------------


    Example:

        p = paramauto(b="${a}+1",c="${a}+${d}",a=1)
        p.disp()
    generates:
        WARNING: unable to interpret 1/3 expressions in "definitions"
          -----------:----------------------------------------
                    a: 1
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = &lt; undef definition "${d}" &gt;
          -----------:----------------------------------------
    setting p.d
        p.d = 2
        p.disp()
    produces
          -----------:----------------------------------------
                    a: 1
                    d: 2
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = 3
          -----------:----------------------------------------
</code></pre>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class paramauto(param):
    &#34;&#34;&#34;
    Class: `paramauto`
    ==================

    A subclass of `param` with enhanced handling for automatic sorting and evaluation
    of definitions. The `paramauto` class ensures that all fields are sorted to resolve
    dependencies, allowing seamless stacking of partially defined objects.

    ---

    ### Features
    - Inherits all functionalities of `param`.
    - Automatically sorts definitions for dependency resolution.
    - Simplifies handling of partial definitions in dynamic structures.
    - Supports safe concatenation of definitions.

    ---

    ### Examples

    #### Automatic Dependency Sorting
    Definitions are automatically sorted to resolve dependencies:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${b}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${b} (= 3)
    # --------
    ```

    #### Handling Missing Definitions
    Unresolved dependencies raise warnings but do not block execution:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------
    ```

    ---

    ### Concatenation and Inheritance
    Concatenating `paramauto` objects resolves definitions:
    ```python
    p1 = paramauto(a=1, b=&#34;${a}+2&#34;)
    p2 = paramauto(c=&#34;${b}*3&#34;)
    p3 = p1 + p2
    p3.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 2 (= 3)
    #      c: ${b} * 3 (= 9)
    # --------
    ```

    ---

    ### Utility Methods

    | Method                | Description                                            |
    |-----------------------|--------------------------------------------------------|
    | `sortdefinitions()`   | Automatically sorts fields to resolve dependencies.    |
    | `eval()`              | Evaluate all fields, resolving dependencies.           |
    | `disp()`              | Display all fields with their resolved values.         |

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `+`: Concatenates two `paramauto` objects, resolving dependencies.
    - `+=`: Updates the current object with another, resolving dependencies.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Advanced Usage

    #### Partial Definitions
    The `paramauto` class simplifies handling of partially defined fields:
    ```python
    p = paramauto(a=&#34;${d}&#34;, b=&#34;${a}+1&#34;)
    p.disp()
    # Warning: Unable to resolve dependencies.
    # --------
    #      a: ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      b: ${a} + 1 (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------

    p.d = 10
    p.disp()
    # Dependencies are resolved:
    # --------
    #      d: 10
    #      a: ${d} (= 10)
    #      b: ${a} + 1 (= 11)
    # --------
    ```

    ---

    ### Notes
    - The `paramauto` class is computationally more intensive than `param` due to automatic sorting.
    - It is ideal for managing dynamic systems with complex interdependencies.

    ### Examples
                    p = paramauto()
                    p.b = &#34;${aa}&#34;
                    p.disp()
                yields
                    WARNING: unable to interpret 1/1 expressions in &#34;definitions&#34;
                      -----------:----------------------------------------
                                b: ${aa}
                                 = &lt; undef definition &#34;${aa}&#34; &gt;
                      -----------:----------------------------------------
                      p.aa = 2
                      p.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                    -----------:----------------------------------------
                    q = paramauto(c=&#34;${aa}+${b}&#34;)+p
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                              c: ${aa}+${b}
                               = 4
                    -----------:----------------------------------------
                    q.aa = 30
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 30
                              b: ${aa}
                               = 30
                              c: ${aa}+${b}
                               = 60
                    -----------:----------------------------------------
                    q.aa = &#34;${d}&#34;
                    q.disp()
                yields multiple errors (recursion)
                WARNING: unable to interpret 3/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                           aa: ${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                            b: ${aa}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                            c: ${aa}+${b}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                  -----------:----------------------------------------
                    q.d = 100
                    q.disp()
                yields
                  -----------:----------------------------------------
                            d: 100
                           aa: ${d}
                             = 100
                            b: ${aa}
                             = 100
                            c: ${aa}+${b}
                             = 200
                  -----------:----------------------------------------


            Example:

                p = paramauto(b=&#34;${a}+1&#34;,c=&#34;${a}+${d}&#34;,a=1)
                p.disp()
            generates:
                WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                            a: 1
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                  -----------:----------------------------------------
            setting p.d
                p.d = 2
                p.disp()
            produces
                  -----------:----------------------------------------
                            a: 1
                            d: 2
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = 3
                  -----------:----------------------------------------

    &#34;&#34;&#34;

    def __add__(self,p):
        return super(param,self).__add__(p,sortdefinitions=True,raiseerror=False)

    def __iadd__(self,p):
        return super(param,self).__iadd__(p,sortdefinitions=True,raiseerror=False)

    def __repr__(self):
        self.sortdefinitions(raiseerror=False)
        #super(param,self).__repr__()
        super().__repr__()
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.dscript.lambdaScriptdata</li>
<li>pizza.forcefield.parameterforcefield</li>
<li>pizza.region.regiondata</li>
</ul>
</dd>
<dt id="script.parameterforcefield"><code class="flex name class">
<span>class <span class="ident">parameterforcefield</span></span>
<span>(</span><span>sortdefinitions=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>class of forcefields parameters, derived from param
note that conctanating two forcefields force them
to to be sorted</p>
<p>Constructor for parameterforcefield. It forces the parent's _returnerror parameter to False.</p>
<h2 id="parameters">Parameters:</h2>
<p>_protection : bool, optional
Whether to enable protection on the parameters (default: False).
_evaluation : bool, optional
Whether evaluation is enabled for the parameters (default: True).
sortdefinitions : bool, optional
Whether to sort definitions upon initialization (default: False).
**kwargs : dict
Additional keyword arguments for the parent class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class parameterforcefield(paramauto):
    &#34;&#34;&#34; class of forcefields parameters, derived from param
        note that conctanating two forcefields force them
        to to be sorted
    &#34;&#34;&#34;
    _type = &#34;FF&#34;
    _fulltype = &#34;forcefield&#34;
    _ftype = &#34;parameter&#34;
    _maxdisplay = 80

    # same strategy as used in dscript for forcing  _returnerror = False (added 2024-09-12)
    def __init__(self, _protection=False, _evaluation=True, sortdefinitions=False, **kwargs):
        &#34;&#34;&#34;
        Constructor for parameterforcefield. It forces the parent&#39;s _returnerror parameter to False.

        Parameters:
        -----------
        _protection : bool, optional
            Whether to enable protection on the parameters (default: False).
        _evaluation : bool, optional
            Whether evaluation is enabled for the parameters (default: True).
        sortdefinitions : bool, optional
            Whether to sort definitions upon initialization (default: False).
        **kwargs : dict
            Additional keyword arguments for the parent class.
        &#34;&#34;&#34;
        # Call the parent class constructor
        super().__init__(_protection=_protection, _evaluation=_evaluation, sortdefinitions=sortdefinitions, **kwargs)
        # Override the _returnerror attribute at the instance level
        self._returnerror = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.paramauto</li>
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.generic.genericdata</li>
</ul>
</dd>
<dt id="script.pipescript"><code class="flex name class">
<span>class <span class="ident">pipescript</span></span>
<span>(</span><span>s=None, name=None, printflag=False, verbose=True, verbosity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>pipescript: A Class for Managing Script Pipelines</p>
<p>The <code><a title="script.pipescript" href="#script.pipescript">pipescript</a></code> class stores scripts in a pipeline where multiple scripts,
script objects, or script object groups can be combined and executed
sequentially. Scripts in the pipeline are executed using the pipe (<code>|</code>) operator,
allowing for dynamic control over execution order, script concatenation, and
variable management.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Pipeline Construction</strong>: Create pipelines of scripts, combining multiple
script objects, <code><a title="script.script" href="#script.script">script</a></code>, <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code>, or <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code> instances.
The pipe operator (<code>|</code>) is overloaded to concatenate scripts.</li>
<li><strong>Sequential Execution</strong>: Execute all scripts in the pipeline in the order
they were added, with support for reordering, selective execution, and
clearing of individual steps.</li>
<li><strong>User and Definition Spaces</strong>: Manage local and global user-defined variables
(<code>USER</code> space) and static definitions for each script in the pipeline.
Global definitions apply to all scripts in the pipeline, while local variables
apply to specific steps.</li>
<li><strong>Flexible Script Handling</strong>: Indexing, slicing, reordering, and renaming
scripts in the pipeline are supported. Scripts can be accessed, replaced,
and modified like array elements.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>LAMMPS Script Automation</strong>: Automate the generation of multi-step simulation
scripts for LAMMPS, combining different simulation setups into a single pipeline.</li>
<li><strong>Script Management</strong>: Combine and manage multiple scripts, tracking user
variables and ensuring that execution order can be adjusted easily.</li>
<li><strong>Advanced Script Execution</strong>: Perform partial pipeline execution, reorder
steps, or clear completed steps while maintaining the original pipeline structure.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, s=None):
Initializes a new <code><a title="script.pipescript" href="#script.pipescript">pipescript</a></code> object, optionally starting with a script
or script-like object (<code><a title="script.script" href="#script.script">script</a></code>, <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code>, <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code>).</p>
<p>setUSER(self, idx, key, value):
Set a user-defined variable (<code>USER</code>) for the script at the specified index.</p>
<p>getUSER(self, idx, key):
Get the value of a user-defined variable (<code>USER</code>) for the script at the
specified index.</p>
<p>clear(self, idx=None):
Clear the execution status of scripts in the pipeline, allowing them to
be executed again.</p>
<p>do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Execute the pipeline or a subset of the pipeline, generating a combined
LAMMPS-compatible script.</p>
<p>script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Generate the final LAMMPS script from the pipeline or a subset of the pipeline.</p>
<p>rename(self, name="", idx=None):
Rename the scripts in the pipeline, assigning new names to specific
indices or all scripts.</p>
<p>write(self, file, printflag=True, verbosity=2, verbose=None):
Write the generated script to a file.</p>
<p>dscript(self, verbose=None, **USER)
Convert the current pipescript into a dscript object</p>
<p>header(self, verbose=True,verbosity=None, style=4):
Generate a formatted header for the pipescript file.</p>
<p>list_values(self, varname, what="all"):
List all occurrences and values of a variable across the pipeline scripts.</p>
<p>list_multiple_values(self, varnames, what="all"):
List all occurrences and values of multiple variables across the pipeline scripts.</p>
<p>plot_value_distribution(self, varname, what="all"):
Plot the distribution of values for a given variable across specified scopes.</p>
<p>generate_report(self, filename, varnames=None, scopes="all"):
Generate a comprehensive report for specified variables and writes it to a file.</p>
<h2 id="static-methods">Static Methods:</h2>
<p>join(liste):
Combine a list of <code><a title="script.script" href="#script.script">script</a></code> and <code><a title="script.pipescript" href="#script.pipescript">pipescript</a></code> objects into a single pipeline.</p>
<h2 id="additional-features">Additional Features:</h2>
<ul>
<li><strong>Indexing and Slicing</strong>: Use array-like indexing (<code>p[0]</code>, <code>p[1:3]</code>) to access
and manipulate scripts in the pipeline.</li>
<li><strong>Deep Copy Support</strong>: The pipeline supports deep copying, preserving the
entire pipeline structure and its scripts.</li>
<li><strong>Verbose and Print Options</strong>: Control verbosity and printing behavior for
generated scripts, allowing for detailed output or minimal script generation.</li>
</ul>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="script.pipescript" href="#script.pipescript">pipescript</a></code> class supports a variety of pipeline operations, including:
- Sequential execution with <code>cmd = p.do()</code>.
- Reordering pipelines with <code>p[[2, 0, 1]]</code>.
- Deleting steps with <code>p[[0, 1]] = []</code>.
- Accessing local and global user space variables via <code>p.USER[idx].var</code> and
<code>p.scripts[idx].USER.var</code>.
- Managing static definitions for each script in the pipeline.
- Example usage:
<code>p = pipescript()
p | i
p = G | c | g | d | b | i | t | d | s | r
p.rename(["G", "c", "g", "d", "b", "i", "t", "d", "s", "r"])
cmd = p.do([0, 1, 4, 7])
sp = p.script([0, 1, 4, 7])</code>
- Scripts in the pipeline are executed sequentially, and definitions propagate
from left to right. The <code>USER</code> space and <code>DEFINITIONS</code> are managed separately
for each script in the pipeline.</p>
<h2 id="overview">Overview</h2>
<pre><code>Pipescript class stores scripts in pipelines
    By assuming: s0, s1, s2... scripts, scriptobject or scriptobjectgroup
    p = s0 | s1 | s2 generates a pipe script

    Example of pipeline:
  ------------:----------------------------------------
  [-]  00: G with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  01: c with (0&gt;&gt;0&gt;&gt;10) DEFINITIONS
  [-]  02: g with (0&gt;&gt;0&gt;&gt;26) DEFINITIONS
  [-]  03: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  04: b with (0&gt;&gt;0&gt;&gt;28) DEFINITIONS
  [-]  05: i with (0&gt;&gt;0&gt;&gt;49) DEFINITIONS
  [-]  06: t with (0&gt;&gt;0&gt;&gt;2) DEFINITIONS
  [-]  07: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  08: s with (0&gt;&gt;0&gt;&gt;1) DEFINITIONS
  [-]  09: r with (0&gt;&gt;0&gt;&gt;20) DEFINITIONS
  ------------:----------------------------------------
Out[35]: pipescript containing 11 scripts with 8 executed[*]

note: XX&gt;&gt;YY&gt;&gt;ZZ represents the number of stored variables
     and the direction of propagation (inheritance from left)
     XX: number of definitions in the pipeline USER space
     YY: number of definitions in the script instance (frozen in the pipeline)
     ZZ: number of definitions in the script (frozen space)

    pipelines are executed sequentially (i.e. parameters can be multivalued)
        cmd = p.do()
        fullscript = p.script()

    pipelines are indexed
        cmd = p[[0,2]].do()
        cmd = p[0:2].do()
        cmd = p.do([0,2])

    pipelines can be reordered
        q = p[[2,0,1]]

    steps can be deleted
        p[[0,1]] = []

    clear all executions with
        p.clear()
        p.clear(idx=1,2)

    local USER space can be accessed via
    (affects only the considered step)
        p.USER[0].a = 1
        p.USER[0].b = [1 2]
        p.USER[0].c = "$ hello world"

    global USER space can accessed via
    (affects all steps onward)
        p.scripts[0].USER.a = 10
        p.scripts[0].USER.b = [10 20]
        p.scripts[0].USER.c = "$ bye bye"

    static definitions
        p.scripts[0].DEFINITIONS

    steps can be renamed with the method rename()

    syntaxes are à la Matlab:
        p = pipescript()
        p | i
        p = collection | G
        p[0]
        q = p | p
        q[0] = []
        p[0:1] = q[0:1]
        p = G | c | g | d | b | i | t | d | s | r
        p.rename(["G","c","g","d","b","i","t","d","s","r"])
        cmd = p.do([0,1,4,7])
        sp = p.script([0,1,4,7])
        r = collection | p

    join joins a list (static method)
        p = pipescript.join([p1,p2,s3,s4])


    Pending: mechanism to store LAMMPS results (dump3) in the pipeline
</code></pre>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pipescript:
    &#34;&#34;&#34;
    pipescript: A Class for Managing Script Pipelines

    The `pipescript` class stores scripts in a pipeline where multiple scripts,
    script objects, or script object groups can be combined and executed
    sequentially. Scripts in the pipeline are executed using the pipe (`|`) operator,
    allowing for dynamic control over execution order, script concatenation, and
    variable management.

    Key Features:
    -------------
    - **Pipeline Construction**: Create pipelines of scripts, combining multiple
      script objects, `script`, `scriptobject`, or `scriptobjectgroup` instances.
      The pipe operator (`|`) is overloaded to concatenate scripts.
    - **Sequential Execution**: Execute all scripts in the pipeline in the order
      they were added, with support for reordering, selective execution, and
      clearing of individual steps.
    - **User and Definition Spaces**: Manage local and global user-defined variables
      (`USER` space) and static definitions for each script in the pipeline.
      Global definitions apply to all scripts in the pipeline, while local variables
      apply to specific steps.
    - **Flexible Script Handling**: Indexing, slicing, reordering, and renaming
      scripts in the pipeline are supported. Scripts can be accessed, replaced,
      and modified like array elements.

    Practical Use Cases:
    --------------------
    - **LAMMPS Script Automation**: Automate the generation of multi-step simulation
      scripts for LAMMPS, combining different simulation setups into a single pipeline.
    - **Script Management**: Combine and manage multiple scripts, tracking user
      variables and ensuring that execution order can be adjusted easily.
    - **Advanced Script Execution**: Perform partial pipeline execution, reorder
      steps, or clear completed steps while maintaining the original pipeline structure.

    Methods:
    --------
    __init__(self, s=None):
        Initializes a new `pipescript` object, optionally starting with a script
        or script-like object (`script`, `scriptobject`, `scriptobjectgroup`).

    setUSER(self, idx, key, value):
        Set a user-defined variable (`USER`) for the script at the specified index.

    getUSER(self, idx, key):
        Get the value of a user-defined variable (`USER`) for the script at the
        specified index.

    clear(self, idx=None):
        Clear the execution status of scripts in the pipeline, allowing them to
        be executed again.

    do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Execute the pipeline or a subset of the pipeline, generating a combined
        LAMMPS-compatible script.

    script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Generate the final LAMMPS script from the pipeline or a subset of the pipeline.

    rename(self, name=&#34;&#34;, idx=None):
        Rename the scripts in the pipeline, assigning new names to specific
        indices or all scripts.

    write(self, file, printflag=True, verbosity=2, verbose=None):
        Write the generated script to a file.

    dscript(self, verbose=None, **USER)
        Convert the current pipescript into a dscript object

    header(self, verbose=True,verbosity=None, style=4):
        Generate a formatted header for the pipescript file.

    list_values(self, varname, what=&#34;all&#34;):
        List all occurrences and values of a variable across the pipeline scripts.

    list_multiple_values(self, varnames, what=&#34;all&#34;):
        List all occurrences and values of multiple variables across the pipeline scripts.

    plot_value_distribution(self, varname, what=&#34;all&#34;):
        Plot the distribution of values for a given variable across specified scopes.

    generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
        Generate a comprehensive report for specified variables and writes it to a file.


    Static Methods:
    ---------------
    join(liste):
        Combine a list of `script` and `pipescript` objects into a single pipeline.

    Additional Features:
    --------------------
    - **Indexing and Slicing**: Use array-like indexing (`p[0]`, `p[1:3]`) to access
      and manipulate scripts in the pipeline.
    - **Deep Copy Support**: The pipeline supports deep copying, preserving the
      entire pipeline structure and its scripts.
    - **Verbose and Print Options**: Control verbosity and printing behavior for
      generated scripts, allowing for detailed output or minimal script generation.

    Original Content:
    -----------------
    The `pipescript` class supports a variety of pipeline operations, including:
    - Sequential execution with `cmd = p.do()`.
    - Reordering pipelines with `p[[2, 0, 1]]`.
    - Deleting steps with `p[[0, 1]] = []`.
    - Accessing local and global user space variables via `p.USER[idx].var` and
      `p.scripts[idx].USER.var`.
    - Managing static definitions for each script in the pipeline.
    - Example usage:
      ```
      p = pipescript()
      p | i
      p = G | c | g | d | b | i | t | d | s | r
      p.rename([&#34;G&#34;, &#34;c&#34;, &#34;g&#34;, &#34;d&#34;, &#34;b&#34;, &#34;i&#34;, &#34;t&#34;, &#34;d&#34;, &#34;s&#34;, &#34;r&#34;])
      cmd = p.do([0, 1, 4, 7])
      sp = p.script([0, 1, 4, 7])
      ```
    - Scripts in the pipeline are executed sequentially, and definitions propagate
      from left to right. The `USER` space and `DEFINITIONS` are managed separately
      for each script in the pipeline.

    OVERVIEW
    -----------------
        Pipescript class stores scripts in pipelines
            By assuming: s0, s1, s2... scripts, scriptobject or scriptobjectgroup
            p = s0 | s1 | s2 generates a pipe script

            Example of pipeline:
          ------------:----------------------------------------
          [-]  00: G with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  01: c with (0&gt;&gt;0&gt;&gt;10) DEFINITIONS
          [-]  02: g with (0&gt;&gt;0&gt;&gt;26) DEFINITIONS
          [-]  03: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  04: b with (0&gt;&gt;0&gt;&gt;28) DEFINITIONS
          [-]  05: i with (0&gt;&gt;0&gt;&gt;49) DEFINITIONS
          [-]  06: t with (0&gt;&gt;0&gt;&gt;2) DEFINITIONS
          [-]  07: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  08: s with (0&gt;&gt;0&gt;&gt;1) DEFINITIONS
          [-]  09: r with (0&gt;&gt;0&gt;&gt;20) DEFINITIONS
          ------------:----------------------------------------
        Out[35]: pipescript containing 11 scripts with 8 executed[*]

        note: XX&gt;&gt;YY&gt;&gt;ZZ represents the number of stored variables
             and the direction of propagation (inheritance from left)
             XX: number of definitions in the pipeline USER space
             YY: number of definitions in the script instance (frozen in the pipeline)
             ZZ: number of definitions in the script (frozen space)

            pipelines are executed sequentially (i.e. parameters can be multivalued)
                cmd = p.do()
                fullscript = p.script()

            pipelines are indexed
                cmd = p[[0,2]].do()
                cmd = p[0:2].do()
                cmd = p.do([0,2])

            pipelines can be reordered
                q = p[[2,0,1]]

            steps can be deleted
                p[[0,1]] = []

            clear all executions with
                p.clear()
                p.clear(idx=1,2)

            local USER space can be accessed via
            (affects only the considered step)
                p.USER[0].a = 1
                p.USER[0].b = [1 2]
                p.USER[0].c = &#34;$ hello world&#34;

            global USER space can accessed via
            (affects all steps onward)
                p.scripts[0].USER.a = 10
                p.scripts[0].USER.b = [10 20]
                p.scripts[0].USER.c = &#34;$ bye bye&#34;

            static definitions
                p.scripts[0].DEFINITIONS

            steps can be renamed with the method rename()

            syntaxes are à la Matlab:
                p = pipescript()
                p | i
                p = collection | G
                p[0]
                q = p | p
                q[0] = []
                p[0:1] = q[0:1]
                p = G | c | g | d | b | i | t | d | s | r
                p.rename([&#34;G&#34;,&#34;c&#34;,&#34;g&#34;,&#34;d&#34;,&#34;b&#34;,&#34;i&#34;,&#34;t&#34;,&#34;d&#34;,&#34;s&#34;,&#34;r&#34;])
                cmd = p.do([0,1,4,7])
                sp = p.script([0,1,4,7])
                r = collection | p

            join joins a list (static method)
                p = pipescript.join([p1,p2,s3,s4])


            Pending: mechanism to store LAMMPS results (dump3) in the pipeline
    &#34;&#34;&#34;

    def __init__(self,s=None, name=None, printflag=False, verbose=True, verbosity = None):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        self.globalscript = None
        self.listscript = []
        self.listUSER = []
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.cmd = &#34;&#34;
        if isinstance(s,script):
            self.listscript = [duplicate(s)]
            self.listUSER = [scriptdata()]
        elif isinstance(s,scriptobject):
            self.listscript = [scriptobjectgroup(s).script]
            self.listUSER = [scriptdata()]
        elif isinstance(s,scriptobjectgroup):
            self.listscript = [s.script]
            self.listUSER = [scriptdata()]
        else:
            ValueError(&#34;the argument should be a scriptobject or scriptobjectgroup&#34;)
        if s != None:
            self.name = [str(s)]
            self.executed = [False]
        else:
            self.name = []
            self.executed = []

    def setUSER(self,idx,key,value):
        &#34;&#34;&#34;
            setUSER sets USER variables
            setUSER(idx,varname,varvalue)
        &#34;&#34;&#34;
        if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
            self.listUSER[idx].setattr(key,value)
        else:
            raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)

    def getUSER(self,idx,key):
        &#34;&#34;&#34;
            getUSER get USER variable
            getUSER(idx,varname)
        &#34;&#34;&#34;
        if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
            self.listUSER[idx].getattr(key)
        else:
            raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)

    @property
    def USER(self):
        &#34;&#34;&#34;
            p.USER[idx].var returns the value of the USER variable var
            p.USER[idx].var = val assigns the value val to the USER variable var
        &#34;&#34;&#34;
        return self.listUSER  # override listuser

    @property
    def scripts(self):
        &#34;&#34;&#34;
            p.scripts[idx].USER.var returns the value of the USER variable var
            p.scripts[idx].USER.var = val assigns the value val to the USER variable var
        &#34;&#34;&#34;
        return self.listscript # override listuser

    def __add__(self,s):
        &#34;&#34;&#34; overload + as pipe with copy &#34;&#34;&#34;
        from pizza.dscript import dscript
        if isinstance(s,(pipescript,script)):
            dup = deepduplicate(self)
            return dup | s      # + or | are synonyms
        elif isinstance(s,scriptobject):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s,dscript):
            return self + s.pipescript(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        else:
            raise TypeError(f&#34;The operand should be a pipescript/script/dscript/scriptobjectgroup and not &#39;{type(s).__name__}&#39;&#34;)

    def __iadd__(self,s):
        &#34;&#34;&#34; overload += as pipe without copy &#34;&#34;&#34;
        if isinstance(s,pipescript):
            return self | s      # + or | are synonyms
        else:
            raise TypeError(f&#34;The operand should be a pipescript and not &#39;{type(s).__name__}&#39;&#34;)

    def __mul__(self,ntimes):
        &#34;&#34;&#34; overload * as multiple pipes with copy &#34;&#34;&#34;
        if isinstance(self,pipescript):
            res = deepduplicate(self)
            if ntimes&gt;1:
                for n in range(1,ntimes): res += self
            return res
        else:
            raise TypeError(f&#34;The operand should be a pipescript and not &#39;{type(s).__name__}&#39;&#34;)



    def __or__(self, s):
        &#34;&#34;&#34; Overload | pipe operator in pipescript &#34;&#34;&#34;
        leftarg = deepduplicate(self)  # Make a deep copy of the current object
        # Local import only when dscript type needs to be checked
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        # Convert rightarg to pipescript if needed
        if isinstance(s, dscript):
            rightarg = s.pipescript(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the dscript object to a pipescript
            native = False
        elif isinstance(s,script):
            rightarg = pipescript(s,printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s,(scriptobject,scriptobjectgroup)):
            rightarg = pipescript(s,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, group):
            stmp = s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
            rightarg = pipescript(stmp,printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, groupcollection):
            stmp = s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
            rightarg = pipescript(stmp,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, region):
            rightarg = s.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s,pipescript):
            rightarg = s
            native = True
        else:
            raise TypeError(f&#34;The operand should be a pipescript, dscript, script, scriptobject, scriptobjectgroup, group or groupcollection not {type(s)}&#34;)
        # Native piping
        if native:
            leftarg.listscript = leftarg.listscript + rightarg.listscript
            leftarg.listUSER = leftarg.listUSER + rightarg.listUSER
            leftarg.name = leftarg.name + rightarg.name
            for i in range(len(rightarg)):
                rightarg.executed[i] = False
            leftarg.executed = leftarg.executed + rightarg.executed
            return leftarg
        # Piping for non-native objects (dscript or script-like objects)
        else:
            # Loop through all items in rightarg and concatenate them
            for i in range(rightarg.n):
                leftarg.listscript.append(rightarg.listscript[i])
                leftarg.listUSER.append(rightarg.listUSER[i])
                leftarg.name.append(rightarg.name[i])
                leftarg.executed.append(False)
            return leftarg



    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;pipescript containing {self.n} scripts with {self.nrun} executed[*]&#34;


    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        line = &#34;  &#34;+&#34;-&#34;*12+&#34;:&#34;+&#34;-&#34;*40
        if self.verbose:
            print(&#34;&#34;,&#34;Pipeline with %d scripts and&#34; % self.n,
                  &#34;D(STATIC:GLOBAL:LOCAL) DEFINITIONS&#34;,line,sep=&#34;\n&#34;)
        else:
            print(line)
        for i in range(len(self)):
            if self.executed[i]:
                state = &#34;*&#34;
            else:
                state = &#34;-&#34;
            print(&#34;%10s&#34; % (&#34;[%s]  %02d:&#34; % (state,i)),
                  self.name[i],&#34;with D(%2d:%2d:%2d)&#34; % (
                       len(self.listscript[i].DEFINITIONS),
                       len(self.listscript[i].USER),
                       len(self.listUSER[i])                 )
                  )
        if self.verbose:
            print(line,&#34;::: notes :::&#34;,&#34;p[i], p[i:j], p[[i,j]] copy pipeline segments&#34;,
                  &#34;LOCAL: p.USER[i],p.USER[i].variable modify the user space of only p[i]&#34;,
                  &#34;GLOBAL: p.scripts[i].USER.var to modify the user space from p[i] and onwards&#34;,
                  &#34;STATIC: p.scripts[i].DEFINITIONS&#34;,
                  &#39;p.rename(idx=range(2),name=[&#34;A&#34;,&#34;B&#34;]), p.clear(idx=[0,3,4])&#39;,
                  &#34;p.script(), p.script(idx=range(5)), p[0:5].script()&#34;,&#34;&#34;,sep=&#34;\n&#34;)
        else:
             print(line)
        return str(self)

    def __len__(self):
        &#34;&#34;&#34; len() method &#34;&#34;&#34;
        return len(self.listscript)

    @property
    def n(self):
        &#34;&#34;&#34; number of scripts &#34;&#34;&#34;
        return len(self)

    @property
    def nrun(self):
        &#34;&#34;&#34; number of scripts executed continuously from origin &#34;&#34;&#34;
        n, nmax  = 0, len(self)
        while n&lt;nmax and self.executed[n]: n+=1
        return n

    def __getitem__(self,idx):
        &#34;&#34;&#34; return the ith or slice element(s) of the pipe  &#34;&#34;&#34;
        dup = deepduplicate(self)
        if isinstance(idx,slice):
            dup.listscript = dup.listscript[idx]
            dup.listUSER = dup.listUSER[idx]
            dup.name = dup.name[idx]
            dup.executed = dup.executed[idx]
        elif isinstance(idx,int):
            if idx&lt;len(self):
                dup.listscript = dup.listscript[idx:idx+1]
                dup.listUSER = dup.listUSER[idx:idx+1]
                dup.name = dup.name[idx:idx+1]
                dup.executed = dup.executed[idx:idx+1]
            else:
                raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,list):
            dup.listscript = picker(dup.listscript,idx)
            dup.listUSER = picker(dup.listUSER,idx)
            dup.name = picker(dup.name,idx)
            dup.executed = picker(dup.executed,idx)
        else:
            raise IndexError(&#34;the index needs to be a slice or an integer&#34;)
        return dup

    def __setitem__(self,idx,s):
        &#34;&#34;&#34;
            modify the ith element of the pipe
                p[4] = [] removes the 4th element
                p[4:7] = [] removes the elements from position 4 to 6
                p[2:4] = p[0:2] copy the elements 0 and 1 in positions 2 and 3
                p[[3,4]]=p[0]
        &#34;&#34;&#34;
        if isinstance(s,(script,scriptobject,scriptobjectgroup)):
            dup = pipescript(s)
        elif isinstance(s,pipescript):
            dup = s
        elif s==[]:
            dup = []
        else:
            raise ValueError(&#34;the value must be a pipescript, script, scriptobject, scriptobjectgroup&#34;)
        if len(s)&lt;1: # remove (delete)
            if isinstance(idx,slice) or idx&lt;len(self):
                del self.listscript[idx]
                del self.listUSER[idx]
                del self.name[idx]
                del self.executed[idx]
            else:
                raise IndexError(&#34;the index must be a slice or an integer&#34;)
        elif len(s)==1: # scalar
            if isinstance(idx,int):
                if idx&lt;len(self):
                    self.listscript[idx] = dup.listscript[0]
                    self.listUSER[idx] = dup.listUSER[0]
                    self.name[idx] = dup.name[0]
                    self.executed[idx] = False
                elif idx==len(self):
                    self.listscript.append(dup.listscript[0])
                    self.listUSER.append(dup.listUSER[0])
                    self.name.append(dup.name[0])
                    self.executed.append(False)
                else:
                    raise IndexError(f&#34;the index must be ranged between 0 and {self.n}&#34;)
            elif isinstance(idx,list):
                for i in range(len(idx)):
                    self.__setitem__(idx[i], s) # call as a scalar
            elif isinstance(idx,slice):
                for i in range(*idx.indices(len(self)+1)):
                    self.__setitem__(i, s)
            else:
                raise IndexError(&#34;unrocognized index value, the index should be an integer or a slice&#34;)
        else: # many values
            if isinstance(idx,list): # list call à la Matlab
                if len(idx)==len(s):
                    for i in range(len(s)):
                        self.__setitem__(idx[i], s[i]) # call as a scalar
                else:
                    raise IndexError(f&#34;the number of indices {len(list)} does not match the number of values {len(s)}&#34;)
            elif isinstance(idx,slice):
                ilist = list(range(*idx.indices(len(self)+len(s))))
                self.__setitem__(ilist, s) # call as a list
            else:
                raise IndexError(&#34;unrocognized index value, the index should be an integer or a slice&#34;)

    def rename(self,name=&#34;&#34;,idx=None):
        &#34;&#34;&#34;
            rename scripts in the pipe
                p.rename(idx=[0,2,3],name=[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;])
        &#34;&#34;&#34;
        if isinstance(name,list):
            if len(name)==len(self) and idx==None:
                self.name = name
            elif len(name) == len(idx):
                for i in range(len(idx)):
                    self.rename(name[i],idx[i])
            else:
                IndexError(f&#34;the number of indices {len(idx)} does not match the number of names {len(name)}&#34;)
        elif idx !=None and idx&lt;len(self) and name!=&#34;&#34;:
            self.name[idx] = name
        else:
            raise ValueError(&#34;provide a non empty name and valid index&#34;)

    def clear(self,idx=None):
        if len(self)&gt;0:
            if idx==None:
                for i in range(len(self)):
                    self.clear(i)
            else:
                if isinstance(idx,(range,list)):
                    for i in idx:
                        self.clear(idx=i)
                elif isinstance(idx,int) and idx&lt;len(self):
                    self.executed[idx] = False
                else:
                    raise IndexError(f&#34;the index should be ranged between 0 and {self.n-1}&#34;)
            if not self.executed[0]:
                self.globalscript = None
                self.cmd = &#34;&#34;



    def do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        &#34;&#34;&#34;
        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        Parameters:
            idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
            printflag (bool, optional): Whether to print the script for each step. Default is True.
            verbosity (int, optional): Level of verbosity for the output.
            verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
            forced (bool, optional): If True, forces the pipeline to regenerate all scripts.

        Returns:
            str: Combined LAMMPS script for the specified pipeline steps.

            Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

            This method processes the pipeline of script objects, executing each step to generate
            a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
            or for a specified range of indices. The generated script can include comments and
            metadata based on the verbosity level.


        Method Workflow:
            - The method first checks if there are any script objects in the pipeline.
              If the pipeline is empty, it returns a message indicating that there is nothing to execute.
            - It determines the start and stop indices for the range of steps to execute.
              If idx is not provided, it defaults to executing all steps from the last executed position.
            - If a specific index or list of indices is provided, it executes only those steps.
            - The pipeline steps are executed in order, combining the scripts using the
              &gt;&gt; operator for sequential execution.
            - The generated script includes comments indicating the current run step and pipeline range,
              based on the specified verbosity level.
            - The final combined script is returned as a string.

        Example Usage:
        --------------
            &gt;&gt;&gt; p = pipescript()
            &gt;&gt;&gt; # Execute the entire pipeline
            &gt;&gt;&gt; full_script = p.do()
            &gt;&gt;&gt; # Execute steps 0 and 2 only
            &gt;&gt;&gt; partial_script = p.do([0, 2])
            &gt;&gt;&gt; # Execute step 1 with minimal verbosity
            &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

            Notes:
            - The method uses modular arithmetic to handle index wrapping, allowing
              for cyclic execution of pipeline steps.
            - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
            - The globalscript is initialized or updated with each step&#39;s script,
              and the USER definitions are accumulated across the steps.
            - The command string self.cmd is updated with the generated script for
              each step in the specified range.

            Raises:
            - None: The method does not raise exceptions directly, but an empty pipeline will
                    result in the return of &#34;# empty pipe - nothing to do&#34;.
        &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        if len(self) == 0:
            return &#34;# empty pipe - nothing to do&#34;

        # Check if not all steps are executed or if there are gaps
        not_all_executed = not all(self.executed[:self.nrun])  # Check up to the last executed step

        # Determine pipeline range
        total_steps = len(self)
        if self.globalscript is None or forced or not_all_executed:
            start = 0
            self.cmd = &#34;&#34;
        else:
            start = self.nrun
            self.cmd = self.cmd.rstrip(&#34;\n&#34;) + &#34;\n\n&#34;

        if idx is None:
            idx = range(start, total_steps)
        if isinstance(idx, int):
            idx = [idx]
        if isinstance(idx, range):
            idx = list(idx)

        idx = [i % total_steps for i in idx]
        start, stop = min(idx), max(idx)

        # Prevent re-executing already completed steps
        if not forced:
            idx = [step for step in idx if not self.executed[step]]

        # Execute pipeline steps
        for step in idx:
            step_wrapped = step % total_steps

            # Combine scripts
            if step_wrapped == 0:
                self.globalscript = self.listscript[step_wrapped]
            else:
                self.globalscript = self.globalscript &gt;&gt; self.listscript[step_wrapped]

            # Step label
            step_name = f&#34;&lt;{self.name[step]}&gt;&#34;
            step_label = f&#34;# [{step+1} of {total_steps} from {start}:{stop}] {step_name}&#34;

            # Get script content for the step
            step_output = self.globalscript.do(printflag=printflag, verbose=verbosity &gt; 1)

            # Add comments and content
            if step_output.strip():
                self.cmd += f&#34;{step_label}\n{step_output.strip()}\n\n&#34;
            elif verbosity &gt; 0:
                self.cmd += f&#34;{step_label} :: no content\n\n&#34;

            # Update USER definitions
            self.globalscript.USER += self.listUSER[step]
            self.executed[step] = True

        # Clean up and finalize script
        self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;).strip()  # Remove literal \\n and extra spaces
        self.cmd += &#34;\n&#34;  # Ensure trailing newline
        return remove_comments(self.cmd) if verbosity == 0 else self.cmd


    def do_legacy(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        &#34;&#34;&#34;
        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        This method processes the pipeline of script objects, executing each step to generate
        a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
        or for a specified range of indices. The generated script can include comments and
        metadata based on the verbosity level.

        Parameters:
        - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                               If None, all steps from the current position to
                                               the end are executed. A list of indices can be
                                               provided to execute specific steps, or a single
                                               integer can be passed to execute a specific step.
                                               Default is None.
        - printflag (bool, optional): If True, the generated script for each step is printed
                                      to the console. Default is True.
        - verbosity (int, optional): Controls the level of detail in the generated script.
                                     - 0: Minimal output, no comments.
                                     - 1: Basic comments for run steps.
                                     - 2: Detailed comments with additional information.
                                     Default is 2.
        - forced (bool, optional): If True, all scripts are regenerated

        Returns:
        - str: The combined LAMMPS script generated from the specified steps of the pipeline.

        Method Workflow:
        - The method first checks if there are any script objects in the pipeline.
          If the pipeline is empty, it returns a message indicating that there is nothing to execute.
        - It determines the start and stop indices for the range of steps to execute.
          If idx is not provided, it defaults to executing all steps from the last executed position.
        - If a specific index or list of indices is provided, it executes only those steps.
        - The pipeline steps are executed in order, combining the scripts using the
          &gt;&gt; operator for sequential execution.
        - The generated script includes comments indicating the current run step and pipeline range,
          based on the specified verbosity level.
        - The final combined script is returned as a string.

        Example Usage:
        --------------
        &gt;&gt;&gt; p = pipescript()
        &gt;&gt;&gt; # Execute the entire pipeline
        &gt;&gt;&gt; full_script = p.do()
        &gt;&gt;&gt; # Execute steps 0 and 2 only
        &gt;&gt;&gt; partial_script = p.do([0, 2])
        &gt;&gt;&gt; # Execute step 1 with minimal verbosity
        &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

        Notes:
        - The method uses modular arithmetic to handle index wrapping, allowing
          for cyclic execution of pipeline steps.
        - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
        - The globalscript is initialized or updated with each step&#39;s script,
          and the USER definitions are accumulated across the steps.
        - The command string self.cmd is updated with the generated script for
          each step in the specified range.

        Raises:
        - None: The method does not raise exceptions directly, but an empty pipeline will
                result in the return of &#34;# empty pipe - nothing to do&#34;.
        &#34;&#34;&#34;

        verbosity = 0 if verbose is False else verbosity
        if len(self)&gt;0:
            # ranges
            ntot = len(self)
            stop = ntot-1
            if (self.globalscript == None) or (self.globalscript == []) or not self.executed[0] or forced:
                start = 0
                self.cmd = &#34;&#34;
            else:
                start = self.nrun
            if start&gt;stop: return self.cmd
            if idx is None: idx = range(start,stop+1)
            if isinstance(idx,range): idx = list(idx)
            if isinstance(idx,int): idx = [idx]
            start,stop = min(idx),max(idx)
            # do
            for i in idx:
                j = i % ntot
                if j==0:
                    self.globalscript = self.listscript[j]
                else:
                    self.globalscript = self.globalscript &gt;&gt; self.listscript[j]
                name = &#34;  &#34;+self.name[i]+&#34;  &#34;
                if verbosity&gt;0:
                    self.cmd += &#34;\n\n#\t --- run step [%d/%d] --- [%s]  %20s\n&#34; % \
                            (j,ntot-1,name.center(50,&#34;=&#34;),&#34;pipeline [%d]--&gt;[%d]&#34; %(start,stop))
                else:
                    self.cmd +=&#34;\n&#34;
                self.globalscript.USER = self.globalscript.USER + self.listUSER[j]
                self.cmd += self.globalscript.do(printflag=printflag,verbose=verbosity&gt;1)
                self.executed[i] = True
            self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;) # remove literal \\n if any (dscript.save add \\n)
            return remove_comments(self.cmd) if verbosity==0 else self.cmd
        else:
            return &#34;# empty pipe - nothing to do&#34;


    def script(self,idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4):
        &#34;&#34;&#34;
            script the pipeline or parts of the pipeline
                s = p.script()
                s = p.script([0,2])

        Parameters:
        - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                               If None, all steps from the current position to
                                               the end are executed. A list of indices can be
                                               provided to execute specific steps, or a single
                                               integer can be passed to execute a specific step.
                                               Default is None.
        - printflag (bool, optional): If True, the generated script for each step is printed
                                      to the console. Default is True.
        - verbosity (int, optional): Controls the level of detail in the generated script.
                                     - 0: Minimal output, no comments.
                                     - 1: Basic comments for run steps.
                                     - 2: Detailed comments with additional information.
                                     Default is 2.
        - forced (bool, optional): If True, all scripts are regenerated
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with `╔`, `═`, and `║`
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with `┌`, `─`, and `│`
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `4` (thick outer frame).

        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity=0 if verbose is False else verbosity
        s = script(printflag=printflag, verbose=verbosity&gt;0)
        s.name = &#34;pipescript&#34;
        s.description = &#34;pipeline with %d scripts&#34; % len(self)
        if len(self)&gt;1:
            s.userid = self.name[0]+&#34;-&gt;&#34;+self.name[-1]
        elif len(self)==1:
            s.userid = self.name[0]
        else:
            s.userid = &#34;empty pipeline&#34;
        s.TEMPLATE = self.header(verbosity=verbosity, style=style) + &#34;\n&#34; +\
            self.do(idx, printflag=printflag, verbosity=verbosity, verbose=verbose, forced=forced)
        s.DEFINITIONS = duplicate(self.globalscript.DEFINITIONS)
        s.USER = duplicate(self.globalscript.USER)
        return s

    @staticmethod
    def join(liste):
        &#34;&#34;&#34;
            join a combination scripts and pipescripts within a pipescript
                p = pipescript.join([s1,s2,p3,p4,p5...])
        &#34;&#34;&#34;
        if not isinstance(liste,list):
            raise ValueError(&#34;the argument should be a list&#34;)
        ok = True
        for i in range(len(liste)):
            ok = ok and isinstance(liste[i],(script,pipescript))
            if not ok:
                raise ValueError(f&#34;the entry [{i}] should be a script or pipescript&#34;)
        if len(liste)&lt;1:
            return liste
        out = liste[0]
        for i in range(1,len(liste)):
            out = out | liste[i]
        return out

    # Note that it was not the original intent to copy pipescripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo))
        return copie

    # write file
    def write(self, file, printflag=False, verbosity=2, verbose=None, overwrite=False):
       &#34;&#34;&#34;
       Write the combined script to a file.

       Parameters:
           file (str): The file path where the script will be saved.
           printflag (bool): Flag to enable/disable printing of details.
           verbosity (int): Level of verbosity for the script generation.
           verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance&#39;s verbosity.
           overwrite (bool): Whether to overwrite the file if it already exists. Default is False.

        Returns:
            str: The full absolute path of the file written.

       Raises:
           FileExistsError: If the file already exists and overwrite is False.

       Notes:
           - This method combines the individual scripts within the `pipescript` object
             and saves the resulting script to the specified file.
           - If `overwrite` is False and the file exists, an error is raised.
           - If `verbose` is True and the file is overwritten, a warning is displayed.
       &#34;&#34;&#34;
       # Generate the combined script
       myscript = self.script(printflag=printflag, verbosity=verbosity, verbose=verbose, forced=True)
       # Call the script&#39;s write method with the overwrite parameter
       return myscript.write(file, printflag=printflag, verbose=verbose, overwrite=overwrite)


    def dscript(self, name=None, printflag=None, verbose=None, verbosity=None, clean=&#34;fixing&#34;, **USER):
        &#34;&#34;&#34;
        Convert the current pipescript object to a dscript object.

        This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
        in the pipescript into a single dynamic script per step in the dscript.
        Each step in the pipescript is transformed into a dynamic script in the dscript,
        where variable spaces are combined using the following order:

        1. STATIC: Definitions specific to each script in the pipescript.
        2. GLOBAL: User variables shared across steps from a specific point onwards.
        3. LOCAL: User variables for each individual step.

        Parameters:
        -----------
        verbose : bool, optional
            Controls verbosity of the dynamic scripts in the resulting dscript object.
            If None, the verbosity setting of the pipescript will be used.

        clean : &#34;fixing&#34; or &#34;removing&#34;
            - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
            - &#39;fixing&#39;: Replace the content of the empty step with a comment.

        **USER : scriptobjectdata(), optional
            Additional user-defined variables that can override existing static variables
            in the dscript object or be added to it.

        Returns:
        --------
        outd : dscript
            A dscript object that contains all steps of the pipescript as dynamic scripts.
            Each step from the pipescript is added as a dynamic script with the same content
            and combined variable spaces.
        &#34;&#34;&#34;
        # Local imports
        from pizza.dscript import dscript, ScriptTemplate, lambdaScriptdata

        # verbosity
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity

        # Adjust name
        if name is None:
            if isinstance(self.name, str):
                name = self.name
            elif isinstance(self.name, list):
                name = (
                    self.name[0] if len(self.name) == 1 else self.name[0] + &#34;...&#34; + self.name[-1]
                )

        # Create the dscript container with the pipescript name as the userid
        outd = dscript(userid=name, verbose=self.verbose, **USER)

        # Initialize static merged definitions
        staticmerged_definitions = lambdaScriptdata()

        # Track used variables per step
        step_used_variables = []

        # Loop over each step in the pipescript
        for i, script in enumerate(self.listscript):
            # Merge STATIC, GLOBAL, and LOCAL variables for the current step
            static_vars = self.listUSER[i] # script.DEFINITIONS
            global_vars = script.DEFINITIONS # self.scripts[i].USER
            local_vars = script.USER # self.USER[i]
            refreshed_globalvars = static_vars + global_vars

            # Detect variables used in the current template
            used_variables = set(script.detect_variables())
            step_used_variables.append(used_variables)  # Track used variables for this step

            # Copy all current variables to local_static_updates and remove matching variables from staticmerged_definitions
            local_static_updates = lambdaScriptdata(**local_vars)

            for var, value in refreshed_globalvars.items():
                if var in staticmerged_definitions:
                    if (getattr(staticmerged_definitions, var) != value) and (var not in local_vars):
                        setattr(local_static_updates, var, value)
                else:
                    setattr(staticmerged_definitions, var, value)

           # Create the dynamic script for this step using the method in dscript
            key_name = i  # Use the index &#39;i&#39; as the key in TEMPLATE
            content = script.TEMPLATE

            # Use the helper method in dscript to add this dynamic script
            outd.add_dynamic_script(
                key=key_name,
                content=content,
                definitions = lambdaScriptdata(**local_static_updates),
                verbose=self.verbose if verbose is None else verbose,
                userid=self.name[i],
                autorefresh=False # prevent the replacement by default values ${}
            )

            # Set eval=True only if variables are detected in the template
            if outd.TEMPLATE[key_name].detect_variables():
                outd.TEMPLATE[key_name].eval = True

        # Compute the union of all used variables across all steps
        global_used_variables = set().union(*step_used_variables)

        # Filter staticmerged_definitions to keep only variables that are used
        filtered_definitions = {
            var: value for var, value in staticmerged_definitions.items() if var in global_used_variables
        }

        # Assign the filtered definitions along with USER variables to outd.DEFINITIONS
        outd.DEFINITIONS = lambdaScriptdata(**filtered_definitions)

        # Clean the entries for empty templates
        outd.clean(verbose=verbose,behavior=clean)

        return outd



    def header(self, verbose=True,verbosity=None, style=4):
        &#34;&#34;&#34;
        Generate a formatted header for the pipescript file.

        Parameters:
            verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                        Defaults to the instance&#39;s `verbose`.
            style (int from 1 to 6, optional): ASCII style to frame the header (default=4)

        Returns:
            str: A formatted string representing the pipescript object.
                 Returns an empty string if verbosity is False.

        The header includes:
            - Total number of scripts in the pipeline.
            - The verbosity setting.
            - The range of scripts from the first to the last script.
            - All enclosed within an ASCII frame that adjusts to the content.
        &#34;&#34;&#34;
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        if not verbosity:
            return &#34;&#34;

        # Prepare the header content
        lines = [
            f&#34;PIPESCRIPT with {self.n} scripts | Verbosity: {verbosity}&#34;,
            &#34;&#34;,
            f&#34;From: &lt;{str(self.scripts[0])}&gt; To: &lt;{str(self.scripts[-1])}&gt;&#34;,
        ]

        # Use the shared method to format the header
        return frame_header(lines,style=style)



    def list_values(self, varname=None, what=&#34;all&#34;):
        &#34;&#34;&#34;
        Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.

        Parameters:
        - varname (str, optional): The name of the variable to search for. If None, all variables are listed.
        - what (str or list/tuple, optional): Specifies the scopes to search in.
                                             Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                             or a list/tuple of any combination of these.

        Returns:
        - VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
        - dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.
        &#34;&#34;&#34;
        # Normalize &#39;what&#39; to a list for uniform processing
        if isinstance(what, str):
            if what.lower() == &#34;all&#34;:
                scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
            else:
                scopes = [what.lower()]
        elif isinstance(what, (list, tuple)):
            scopes_lower = [s.lower() for s in what]
            if &#39;all&#39; in scopes_lower:
                scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
            else:
                scopes = scopes_lower
        else:
            raise ValueError(&#34;Parameter &#39;what&#39; must be a string or a list/tuple of strings.&#34;)

        # Initialize data structures
        if varname:
            # Single variable case
            if len(scopes) == 1:
                data = []
            else:
                data = {}
                for scope in scopes:
                    data[scope] = []

            # Iterate over each script in the pipeline
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                # Check each requested scope
                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    if varname in vars_dict.keys():
                        value = getattr(vars_dict,varname)
                        if len(scopes) == 1:
                            data.append((i, value))
                        else:
                            data[scope].append((i, value))

            # Return a VariableOccurrences instance for the specified variable
            return VariableOccurrences(data, variables=varname)

        else:
            # All variables case
            all_vars = set()

            # First, collect all variable names across specified scopes and scripts
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    all_vars.update(vars_dict.keys())

            # Initialize a dictionary to hold VariableOccurrences for each variable
            variables_data = {}
            for var in all_vars:
                var_data = {}
                for scope in scopes:
                    var_data[scope] = []
                variables_data[var] = var_data

            # Iterate again to populate the data for each variable
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    for var, value in vars_dict.items():
                        variables_data[var][scope].append((i, value))

            # Convert each variable&#39;s data into a VariableOccurrences instance
            variables_occurrences = {}
            for var, data in variables_data.items():
                variables_occurrences[var] = VariableOccurrences(data, variables=var)

            return variables_occurrences



    def list_multiple_values(self, varnames, what=&#34;all&#34;):
        &#34;&#34;&#34;
        Lists all occurrences and values of multiple variables across the pipeline scripts.

        Parameters:
        - varnames (list): A list of variable names to search for.
        - what (str or list/tuple): Specifies the scopes to search in.
                                     Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                     or a list/tuple of any combination of these.

        Returns:
        - dict: A dictionary mapping each variable name to its VariableOccurrences object.
        &#34;&#34;&#34;
        if not isinstance(varnames, (list, tuple)):
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

        return self.list_values(varname=varnames, what=what)



    def plot_multiple_value_distributions(self, varnames, what=&#34;all&#34;, separate_plots=True):
        &#34;&#34;&#34;
        Plots the distribution of elements for multiple variables across specified scopes.

        Parameters:
        - varnames (list): A list of variable names to plot.
        - what (str or list/tuple): Specifies the scopes to include in the plot.
                                     Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                     or a list/tuple of any combination of these.
        - separate_plots (bool): If True, plots each variable in a separate subplot.
                                 If False, combines all variables in a single plot for comparison.
        &#34;&#34;&#34;
        if not isinstance(varnames, (list, tuple)):
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

        # Retrieve VariableOccurrences instances
        multiple_vars = self.list_multiple_values(varnames, what=what)

        if separate_plots:
            num_vars = len(multiple_vars)
            fig, axes = plt.subplots(num_vars, 1, figsize=(10, 5 * num_vars))
            if num_vars == 1:
                axes = [axes]  # Make it iterable

            for ax, (var, vo) in zip(axes, multiple_vars.items()):
                summary = vo.summarize()[var]
                for scope, details in summary.items():
                    elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                    counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                    ax.bar(elements, counts, label=scope)
                ax.set_xlabel(&#39;Element&#39;)
                ax.set_ylabel(&#39;Count&#39;)
                ax.set_title(f&#34;Distribution of elements in &#39;{var}&#39;&#34;)
                ax.legend()

            plt.tight_layout()
            plt.show()

        else:
            plt.figure(figsize=(12, 8))
            for var, vo in multiple_vars.items():
                summary = vo.summarize()[var]
                for scope, details in summary.items():
                    elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                    counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                    plt.bar([f&#34;{var}_{elem}&#34; for elem in elements], counts, label=f&#34;{var} - {scope}&#34;)

            plt.xlabel(&#39;Element&#39;)
            plt.ylabel(&#39;Count&#39;)
            plt.title(&#34;Distribution of elements in multiple variables&#34;)
            plt.legend()
            plt.xticks(rotation=45, ha=&#39;right&#39;)
            plt.tight_layout()
            plt.show()


    def generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
        &#34;&#34;&#34;
        Generates a comprehensive report for specified variables and writes it to a file.

        Parameters:
        - filename (str): Path to the output report file. Must end with .md, .txt, or .html.
        - varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to &#39;all&#39;.
        - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.

        Raises:
        - ValueError: If &#39;filename&#39; has an unsupported extension.
        - Exception: For other unforeseen errors.
        &#34;&#34;&#34;
        # Validate filename extension
        _, ext = os.path.splitext(filename)
        ext = ext.lower()

        if ext not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;]:
            raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

        # Determine format based on extension
        if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
            export_format = &#39;markdown&#39;
        elif ext == &#39;.html&#39;:
            export_format = &#39;html&#39;

        # Determine variables to include
        if varnames is None or (isinstance(varnames, (list, tuple)) and len(varnames) == 0):
            variables = &#39;all&#39;
        else:
            variables = varnames  # Can be a string or a list/tuple

        # Retrieve VariableOccurrences instances
        if variables == &#39;all&#39;:
            variables_occurrences = self.list_values(varname=None, what=scopes)
        else:
            # Normalize varnames to a list
            if isinstance(variables, str):
                variables = [variables]
            elif isinstance(variables, (list, tuple)):
                variables = list(variables)
            else:
                raise ValueError(&#34;Parameter &#39;varnames&#39; must be a string or a list/tuple of strings.&#34;)

            variables_occurrences = {}
            for var in variables:
                vo = self.list_values(varname=var, what=scopes)
                if vo and var in vo.variables:
                    variables_occurrences[var] = vo
                else:
                    print(f&#34;Warning: Variable &#39;{var}&#39; not found in the specified scopes.&#34;)

        # Initialize report content
        report_content = &#34;&#34;
        timestamp = datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        caller = &#34;generate_report&#34;

        # Add report header
        if export_format == &#39;markdown&#39;:
            report_content += f&#34;# Comprehensive Variable Report\n\n&#34;
            report_content += f&#34;**Generated on {timestamp} by {caller}**\n\n&#34;
        elif export_format == &#39;html&#39;:
            # Define CSS for HTML
            css = &#34;&#34;&#34;
            &lt;style&gt;
                body {
                    font-family: Arial, sans-serif;
                    margin: 20px;
                }
                h1, h2, h3, h4, h5 {
                    color: #333;
                }
                table {
                    border-collapse: collapse;
                    width: 100%;
                    margin-bottom: 40px;
                }
                th, td {
                    border: 1px solid #ddd;
                    padding: 8px;
                    text-align: left;
                }
                th {
                    background-color: #4CAF50;
                    color: white;
                }
                tr:nth-child(even){background-color: #f2f2f2;}
                tr:hover {background-color: #ddd;}
            &lt;/style&gt;
            &#34;&#34;&#34;
            report_content += f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Comprehensive Variable Report&lt;/title&gt;\n{css}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;
            report_content += f&#34;&lt;h1&gt;Comprehensive Variable Report&lt;/h1&gt;\n&#34;
            report_content += f&#34;&lt;h2&gt;Generated on {timestamp} by {caller}&lt;/h2&gt;\n&#34;

        # Assemble report content using VariableOccurrences.export()
        for var, vo in variables_occurrences.items():
            # Export content without headers and get as string
            var_content = vo.export(filename=filename, # use to identify the format based on its extension
                                    scopes=scopes,
                                    variables=var,
                                    include_headers=False,
                                    return_content=True)

            if export_format == &#39;markdown&#39;:
                # Add variable header
                report_content += f&#34;## Variable: `{var}`\n\n&#34;
                report_content += var_content + &#34;\n\n&#34;
                report_content += &#34;---\n\n&#34;  # Horizontal line between variables
            elif export_format == &#39;html&#39;:
                # Add variable header
                report_content += f&#34;&lt;h2&gt;Variable: {var}&lt;/h2&gt;\n&#34;
                report_content += var_content + &#34;\n&lt;hr/&gt;\n&#34;  # Horizontal line between variables

        # Finalize HTML content
        if export_format == &#39;html&#39;:
            report_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

        # Write report to file
        try:
            with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                file.write(report_content)
            print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
        except Exception as e:
            raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="script.pipescript.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>liste)</span>
</code></dt>
<dd>
<div class="desc"><p>join a combination scripts and pipescripts within a pipescript
p = pipescript.join([s1,s2,p3,p4,p5&hellip;])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def join(liste):
    &#34;&#34;&#34;
        join a combination scripts and pipescripts within a pipescript
            p = pipescript.join([s1,s2,p3,p4,p5...])
    &#34;&#34;&#34;
    if not isinstance(liste,list):
        raise ValueError(&#34;the argument should be a list&#34;)
    ok = True
    for i in range(len(liste)):
        ok = ok and isinstance(liste[i],(script,pipescript))
        if not ok:
            raise ValueError(f&#34;the entry [{i}] should be a script or pipescript&#34;)
    if len(liste)&lt;1:
        return liste
    out = liste[0]
    for i in range(1,len(liste)):
        out = out | liste[i]
    return out</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="script.pipescript.USER"><code class="name">var <span class="ident">USER</span></code></dt>
<dd>
<div class="desc"><p>p.USER[idx].var returns the value of the USER variable var
p.USER[idx].var = val assigns the value val to the USER variable var</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def USER(self):
    &#34;&#34;&#34;
        p.USER[idx].var returns the value of the USER variable var
        p.USER[idx].var = val assigns the value val to the USER variable var
    &#34;&#34;&#34;
    return self.listUSER  # override listuser</code></pre>
</details>
</dd>
<dt id="script.pipescript.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>number of scripts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34; number of scripts &#34;&#34;&#34;
    return len(self)</code></pre>
</details>
</dd>
<dt id="script.pipescript.nrun"><code class="name">var <span class="ident">nrun</span></code></dt>
<dd>
<div class="desc"><p>number of scripts executed continuously from origin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nrun(self):
    &#34;&#34;&#34; number of scripts executed continuously from origin &#34;&#34;&#34;
    n, nmax  = 0, len(self)
    while n&lt;nmax and self.executed[n]: n+=1
    return n</code></pre>
</details>
</dd>
<dt id="script.pipescript.scripts"><code class="name">var <span class="ident">scripts</span></code></dt>
<dd>
<div class="desc"><p>p.scripts[idx].USER.var returns the value of the USER variable var
p.scripts[idx].USER.var = val assigns the value val to the USER variable var</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scripts(self):
    &#34;&#34;&#34;
        p.scripts[idx].USER.var returns the value of the USER variable var
        p.scripts[idx].USER.var = val assigns the value val to the USER variable var
    &#34;&#34;&#34;
    return self.listscript # override listuser</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="script.pipescript.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, idx=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self,idx=None):
    if len(self)&gt;0:
        if idx==None:
            for i in range(len(self)):
                self.clear(i)
        else:
            if isinstance(idx,(range,list)):
                for i in idx:
                    self.clear(idx=i)
            elif isinstance(idx,int) and idx&lt;len(self):
                self.executed[idx] = False
            else:
                raise IndexError(f&#34;the index should be ranged between 0 and {self.n-1}&#34;)
        if not self.executed[0]:
            self.globalscript = None
            self.cmd = &#34;&#34;</code></pre>
</details>
</dd>
<dt id="script.pipescript.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<h2 id="parameters">Parameters</h2>
<p>idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
printflag (bool, optional): Whether to print the script for each step. Default is True.
verbosity (int, optional): Level of verbosity for the output.
verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
forced (bool, optional): If True, forces the pipeline to regenerate all scripts.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Combined LAMMPS script for the specified pipeline steps.</dd>
</dl>
<p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<p>This method processes the pipeline of script objects, executing each step to generate
a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
or for a specified range of indices. The generated script can include comments and
metadata based on the verbosity level.
Method Workflow:
- The method first checks if there are any script objects in the pipeline.
If the pipeline is empty, it returns a message indicating that there is nothing to execute.
- It determines the start and stop indices for the range of steps to execute.
If idx is not provided, it defaults to executing all steps from the last executed position.
- If a specific index or list of indices is provided, it executes only those steps.
- The pipeline steps are executed in order, combining the scripts using the
&gt;&gt; operator for sequential execution.
- The generated script includes comments indicating the current run step and pipeline range,
based on the specified verbosity level.
- The final combined script is returned as a string.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>&gt;&gt;&gt; p = pipescript()
&gt;&gt;&gt; # Execute the entire pipeline
&gt;&gt;&gt; full_script = p.do()
&gt;&gt;&gt; # Execute steps 0 and 2 only
&gt;&gt;&gt; partial_script = p.do([0, 2])
&gt;&gt;&gt; # Execute step 1 with minimal verbosity
&gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

Notes:
- The method uses modular arithmetic to handle index wrapping, allowing
  for cyclic execution of pipeline steps.
- If the pipeline is empty, the method returns the string "# empty pipe - nothing to do".
- The globalscript is initialized or updated with each step's script,
  and the USER definitions are accumulated across the steps.
- The command string self.cmd is updated with the generated script for
  each step in the specified range.

Raises:
- None: The method does not raise exceptions directly, but an empty pipeline will
        result in the return of "# empty pipe - nothing to do".
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
    &#34;&#34;&#34;
    Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

    Parameters:
        idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
        printflag (bool, optional): Whether to print the script for each step. Default is True.
        verbosity (int, optional): Level of verbosity for the output.
        verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
        forced (bool, optional): If True, forces the pipeline to regenerate all scripts.

    Returns:
        str: Combined LAMMPS script for the specified pipeline steps.

        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        This method processes the pipeline of script objects, executing each step to generate
        a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
        or for a specified range of indices. The generated script can include comments and
        metadata based on the verbosity level.


    Method Workflow:
        - The method first checks if there are any script objects in the pipeline.
          If the pipeline is empty, it returns a message indicating that there is nothing to execute.
        - It determines the start and stop indices for the range of steps to execute.
          If idx is not provided, it defaults to executing all steps from the last executed position.
        - If a specific index or list of indices is provided, it executes only those steps.
        - The pipeline steps are executed in order, combining the scripts using the
          &gt;&gt; operator for sequential execution.
        - The generated script includes comments indicating the current run step and pipeline range,
          based on the specified verbosity level.
        - The final combined script is returned as a string.

    Example Usage:
    --------------
        &gt;&gt;&gt; p = pipescript()
        &gt;&gt;&gt; # Execute the entire pipeline
        &gt;&gt;&gt; full_script = p.do()
        &gt;&gt;&gt; # Execute steps 0 and 2 only
        &gt;&gt;&gt; partial_script = p.do([0, 2])
        &gt;&gt;&gt; # Execute step 1 with minimal verbosity
        &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

        Notes:
        - The method uses modular arithmetic to handle index wrapping, allowing
          for cyclic execution of pipeline steps.
        - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
        - The globalscript is initialized or updated with each step&#39;s script,
          and the USER definitions are accumulated across the steps.
        - The command string self.cmd is updated with the generated script for
          each step in the specified range.

        Raises:
        - None: The method does not raise exceptions directly, but an empty pipeline will
                result in the return of &#34;# empty pipe - nothing to do&#34;.
    &#34;&#34;&#34;
    verbosity = 0 if verbose is False else verbosity
    if len(self) == 0:
        return &#34;# empty pipe - nothing to do&#34;

    # Check if not all steps are executed or if there are gaps
    not_all_executed = not all(self.executed[:self.nrun])  # Check up to the last executed step

    # Determine pipeline range
    total_steps = len(self)
    if self.globalscript is None or forced or not_all_executed:
        start = 0
        self.cmd = &#34;&#34;
    else:
        start = self.nrun
        self.cmd = self.cmd.rstrip(&#34;\n&#34;) + &#34;\n\n&#34;

    if idx is None:
        idx = range(start, total_steps)
    if isinstance(idx, int):
        idx = [idx]
    if isinstance(idx, range):
        idx = list(idx)

    idx = [i % total_steps for i in idx]
    start, stop = min(idx), max(idx)

    # Prevent re-executing already completed steps
    if not forced:
        idx = [step for step in idx if not self.executed[step]]

    # Execute pipeline steps
    for step in idx:
        step_wrapped = step % total_steps

        # Combine scripts
        if step_wrapped == 0:
            self.globalscript = self.listscript[step_wrapped]
        else:
            self.globalscript = self.globalscript &gt;&gt; self.listscript[step_wrapped]

        # Step label
        step_name = f&#34;&lt;{self.name[step]}&gt;&#34;
        step_label = f&#34;# [{step+1} of {total_steps} from {start}:{stop}] {step_name}&#34;

        # Get script content for the step
        step_output = self.globalscript.do(printflag=printflag, verbose=verbosity &gt; 1)

        # Add comments and content
        if step_output.strip():
            self.cmd += f&#34;{step_label}\n{step_output.strip()}\n\n&#34;
        elif verbosity &gt; 0:
            self.cmd += f&#34;{step_label} :: no content\n\n&#34;

        # Update USER definitions
        self.globalscript.USER += self.listUSER[step]
        self.executed[step] = True

    # Clean up and finalize script
    self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;).strip()  # Remove literal \\n and extra spaces
    self.cmd += &#34;\n&#34;  # Ensure trailing newline
    return remove_comments(self.cmd) if verbosity == 0 else self.cmd</code></pre>
</details>
</dd>
<dt id="script.pipescript.do_legacy"><code class="name flex">
<span>def <span class="ident">do_legacy</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<p>This method processes the pipeline of script objects, executing each step to generate
a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
or for a specified range of indices. The generated script can include comments and
metadata based on the verbosity level.</p>
<p>Parameters:
- idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
If None, all steps from the current position to
the end are executed. A list of indices can be
provided to execute specific steps, or a single
integer can be passed to execute a specific step.
Default is None.
- printflag (bool, optional): If True, the generated script for each step is printed
to the console. Default is True.
- verbosity (int, optional): Controls the level of detail in the generated script.
- 0: Minimal output, no comments.
- 1: Basic comments for run steps.
- 2: Detailed comments with additional information.
Default is 2.
- forced (bool, optional): If True, all scripts are regenerated</p>
<p>Returns:
- str: The combined LAMMPS script generated from the specified steps of the pipeline.</p>
<p>Method Workflow:
- The method first checks if there are any script objects in the pipeline.
If the pipeline is empty, it returns a message indicating that there is nothing to execute.
- It determines the start and stop indices for the range of steps to execute.
If idx is not provided, it defaults to executing all steps from the last executed position.
- If a specific index or list of indices is provided, it executes only those steps.
- The pipeline steps are executed in order, combining the scripts using the</p>
<blockquote>
<blockquote>
<p>operator for sequential execution.
- The generated script includes comments indicating the current run step and pipeline range,
based on the specified verbosity level.
- The final combined script is returned as a string.</p>
</blockquote>
</blockquote>
<h2 id="example-usage">Example Usage:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = pipescript()
&gt;&gt;&gt; # Execute the entire pipeline
&gt;&gt;&gt; full_script = p.do()
&gt;&gt;&gt; # Execute steps 0 and 2 only
&gt;&gt;&gt; partial_script = p.do([0, 2])
&gt;&gt;&gt; # Execute step 1 with minimal verbosity
&gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)
</code></pre>
<p>Notes:
- The method uses modular arithmetic to handle index wrapping, allowing
for cyclic execution of pipeline steps.
- If the pipeline is empty, the method returns the string "# empty pipe - nothing to do".
- The globalscript is initialized or updated with each step's script,
and the USER definitions are accumulated across the steps.
- The command string self.cmd is updated with the generated script for
each step in the specified range.</p>
<p>Raises:
- None: The method does not raise exceptions directly, but an empty pipeline will
result in the return of "# empty pipe - nothing to do".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_legacy(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
    &#34;&#34;&#34;
    Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

    This method processes the pipeline of script objects, executing each step to generate
    a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
    or for a specified range of indices. The generated script can include comments and
    metadata based on the verbosity level.

    Parameters:
    - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                           If None, all steps from the current position to
                                           the end are executed. A list of indices can be
                                           provided to execute specific steps, or a single
                                           integer can be passed to execute a specific step.
                                           Default is None.
    - printflag (bool, optional): If True, the generated script for each step is printed
                                  to the console. Default is True.
    - verbosity (int, optional): Controls the level of detail in the generated script.
                                 - 0: Minimal output, no comments.
                                 - 1: Basic comments for run steps.
                                 - 2: Detailed comments with additional information.
                                 Default is 2.
    - forced (bool, optional): If True, all scripts are regenerated

    Returns:
    - str: The combined LAMMPS script generated from the specified steps of the pipeline.

    Method Workflow:
    - The method first checks if there are any script objects in the pipeline.
      If the pipeline is empty, it returns a message indicating that there is nothing to execute.
    - It determines the start and stop indices for the range of steps to execute.
      If idx is not provided, it defaults to executing all steps from the last executed position.
    - If a specific index or list of indices is provided, it executes only those steps.
    - The pipeline steps are executed in order, combining the scripts using the
      &gt;&gt; operator for sequential execution.
    - The generated script includes comments indicating the current run step and pipeline range,
      based on the specified verbosity level.
    - The final combined script is returned as a string.

    Example Usage:
    --------------
    &gt;&gt;&gt; p = pipescript()
    &gt;&gt;&gt; # Execute the entire pipeline
    &gt;&gt;&gt; full_script = p.do()
    &gt;&gt;&gt; # Execute steps 0 and 2 only
    &gt;&gt;&gt; partial_script = p.do([0, 2])
    &gt;&gt;&gt; # Execute step 1 with minimal verbosity
    &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

    Notes:
    - The method uses modular arithmetic to handle index wrapping, allowing
      for cyclic execution of pipeline steps.
    - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
    - The globalscript is initialized or updated with each step&#39;s script,
      and the USER definitions are accumulated across the steps.
    - The command string self.cmd is updated with the generated script for
      each step in the specified range.

    Raises:
    - None: The method does not raise exceptions directly, but an empty pipeline will
            result in the return of &#34;# empty pipe - nothing to do&#34;.
    &#34;&#34;&#34;

    verbosity = 0 if verbose is False else verbosity
    if len(self)&gt;0:
        # ranges
        ntot = len(self)
        stop = ntot-1
        if (self.globalscript == None) or (self.globalscript == []) or not self.executed[0] or forced:
            start = 0
            self.cmd = &#34;&#34;
        else:
            start = self.nrun
        if start&gt;stop: return self.cmd
        if idx is None: idx = range(start,stop+1)
        if isinstance(idx,range): idx = list(idx)
        if isinstance(idx,int): idx = [idx]
        start,stop = min(idx),max(idx)
        # do
        for i in idx:
            j = i % ntot
            if j==0:
                self.globalscript = self.listscript[j]
            else:
                self.globalscript = self.globalscript &gt;&gt; self.listscript[j]
            name = &#34;  &#34;+self.name[i]+&#34;  &#34;
            if verbosity&gt;0:
                self.cmd += &#34;\n\n#\t --- run step [%d/%d] --- [%s]  %20s\n&#34; % \
                        (j,ntot-1,name.center(50,&#34;=&#34;),&#34;pipeline [%d]--&gt;[%d]&#34; %(start,stop))
            else:
                self.cmd +=&#34;\n&#34;
            self.globalscript.USER = self.globalscript.USER + self.listUSER[j]
            self.cmd += self.globalscript.do(printflag=printflag,verbose=verbosity&gt;1)
            self.executed[i] = True
        self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;) # remove literal \\n if any (dscript.save add \\n)
        return remove_comments(self.cmd) if verbosity==0 else self.cmd
    else:
        return &#34;# empty pipe - nothing to do&#34;</code></pre>
</details>
</dd>
<dt id="script.pipescript.dscript"><code class="name flex">
<span>def <span class="ident">dscript</span></span>(<span>self, name=None, printflag=None, verbose=None, verbosity=None, clean='fixing', **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the current pipescript object to a dscript object.</p>
<p>This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
in the pipescript into a single dynamic script per step in the dscript.
Each step in the pipescript is transformed into a dynamic script in the dscript,
where variable spaces are combined using the following order:</p>
<ol>
<li>STATIC: Definitions specific to each script in the pipescript.</li>
<li>GLOBAL: User variables shared across steps from a specific point onwards.</li>
<li>LOCAL: User variables for each individual step.</li>
</ol>
<h2 id="parameters">Parameters:</h2>
<p>verbose : bool, optional
Controls verbosity of the dynamic scripts in the resulting dscript object.
If None, the verbosity setting of the pipescript will be used.</p>
<p>clean : "fixing" or "removing"
- 'removing': Completely remove the empty step from TEMPLATE.
- 'fixing': Replace the content of the empty step with a comment.</p>
<p>**USER : scriptobjectdata(), optional
Additional user-defined variables that can override existing static variables
in the dscript object or be added to it.</p>
<h2 id="returns">Returns:</h2>
<p>outd : dscript
A dscript object that contains all steps of the pipescript as dynamic scripts.
Each step from the pipescript is added as a dynamic script with the same content
and combined variable spaces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dscript(self, name=None, printflag=None, verbose=None, verbosity=None, clean=&#34;fixing&#34;, **USER):
    &#34;&#34;&#34;
    Convert the current pipescript object to a dscript object.

    This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
    in the pipescript into a single dynamic script per step in the dscript.
    Each step in the pipescript is transformed into a dynamic script in the dscript,
    where variable spaces are combined using the following order:

    1. STATIC: Definitions specific to each script in the pipescript.
    2. GLOBAL: User variables shared across steps from a specific point onwards.
    3. LOCAL: User variables for each individual step.

    Parameters:
    -----------
    verbose : bool, optional
        Controls verbosity of the dynamic scripts in the resulting dscript object.
        If None, the verbosity setting of the pipescript will be used.

    clean : &#34;fixing&#34; or &#34;removing&#34;
        - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
        - &#39;fixing&#39;: Replace the content of the empty step with a comment.

    **USER : scriptobjectdata(), optional
        Additional user-defined variables that can override existing static variables
        in the dscript object or be added to it.

    Returns:
    --------
    outd : dscript
        A dscript object that contains all steps of the pipescript as dynamic scripts.
        Each step from the pipescript is added as a dynamic script with the same content
        and combined variable spaces.
    &#34;&#34;&#34;
    # Local imports
    from pizza.dscript import dscript, ScriptTemplate, lambdaScriptdata

    # verbosity
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity

    # Adjust name
    if name is None:
        if isinstance(self.name, str):
            name = self.name
        elif isinstance(self.name, list):
            name = (
                self.name[0] if len(self.name) == 1 else self.name[0] + &#34;...&#34; + self.name[-1]
            )

    # Create the dscript container with the pipescript name as the userid
    outd = dscript(userid=name, verbose=self.verbose, **USER)

    # Initialize static merged definitions
    staticmerged_definitions = lambdaScriptdata()

    # Track used variables per step
    step_used_variables = []

    # Loop over each step in the pipescript
    for i, script in enumerate(self.listscript):
        # Merge STATIC, GLOBAL, and LOCAL variables for the current step
        static_vars = self.listUSER[i] # script.DEFINITIONS
        global_vars = script.DEFINITIONS # self.scripts[i].USER
        local_vars = script.USER # self.USER[i]
        refreshed_globalvars = static_vars + global_vars

        # Detect variables used in the current template
        used_variables = set(script.detect_variables())
        step_used_variables.append(used_variables)  # Track used variables for this step

        # Copy all current variables to local_static_updates and remove matching variables from staticmerged_definitions
        local_static_updates = lambdaScriptdata(**local_vars)

        for var, value in refreshed_globalvars.items():
            if var in staticmerged_definitions:
                if (getattr(staticmerged_definitions, var) != value) and (var not in local_vars):
                    setattr(local_static_updates, var, value)
            else:
                setattr(staticmerged_definitions, var, value)

       # Create the dynamic script for this step using the method in dscript
        key_name = i  # Use the index &#39;i&#39; as the key in TEMPLATE
        content = script.TEMPLATE

        # Use the helper method in dscript to add this dynamic script
        outd.add_dynamic_script(
            key=key_name,
            content=content,
            definitions = lambdaScriptdata(**local_static_updates),
            verbose=self.verbose if verbose is None else verbose,
            userid=self.name[i],
            autorefresh=False # prevent the replacement by default values ${}
        )

        # Set eval=True only if variables are detected in the template
        if outd.TEMPLATE[key_name].detect_variables():
            outd.TEMPLATE[key_name].eval = True

    # Compute the union of all used variables across all steps
    global_used_variables = set().union(*step_used_variables)

    # Filter staticmerged_definitions to keep only variables that are used
    filtered_definitions = {
        var: value for var, value in staticmerged_definitions.items() if var in global_used_variables
    }

    # Assign the filtered definitions along with USER variables to outd.DEFINITIONS
    outd.DEFINITIONS = lambdaScriptdata(**filtered_definitions)

    # Clean the entries for empty templates
    outd.clean(verbose=verbose,behavior=clean)

    return outd</code></pre>
</details>
</dd>
<dt id="script.pipescript.generate_report"><code class="name flex">
<span>def <span class="ident">generate_report</span></span>(<span>self, filename, varnames=None, scopes='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a comprehensive report for specified variables and writes it to a file.</p>
<p>Parameters:
- filename (str): Path to the output report file. Must end with .md, .txt, or .html.
- varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to 'all'.
- scopes (str or list/tuple, optional): 'all', a single scope string, or a list of scope strings. Defaults to 'all'.</p>
<p>Raises:
- ValueError: If 'filename' has an unsupported extension.
- Exception: For other unforeseen errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
    &#34;&#34;&#34;
    Generates a comprehensive report for specified variables and writes it to a file.

    Parameters:
    - filename (str): Path to the output report file. Must end with .md, .txt, or .html.
    - varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to &#39;all&#39;.
    - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.

    Raises:
    - ValueError: If &#39;filename&#39; has an unsupported extension.
    - Exception: For other unforeseen errors.
    &#34;&#34;&#34;
    # Validate filename extension
    _, ext = os.path.splitext(filename)
    ext = ext.lower()

    if ext not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;]:
        raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

    # Determine format based on extension
    if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
        export_format = &#39;markdown&#39;
    elif ext == &#39;.html&#39;:
        export_format = &#39;html&#39;

    # Determine variables to include
    if varnames is None or (isinstance(varnames, (list, tuple)) and len(varnames) == 0):
        variables = &#39;all&#39;
    else:
        variables = varnames  # Can be a string or a list/tuple

    # Retrieve VariableOccurrences instances
    if variables == &#39;all&#39;:
        variables_occurrences = self.list_values(varname=None, what=scopes)
    else:
        # Normalize varnames to a list
        if isinstance(variables, str):
            variables = [variables]
        elif isinstance(variables, (list, tuple)):
            variables = list(variables)
        else:
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a string or a list/tuple of strings.&#34;)

        variables_occurrences = {}
        for var in variables:
            vo = self.list_values(varname=var, what=scopes)
            if vo and var in vo.variables:
                variables_occurrences[var] = vo
            else:
                print(f&#34;Warning: Variable &#39;{var}&#39; not found in the specified scopes.&#34;)

    # Initialize report content
    report_content = &#34;&#34;
    timestamp = datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
    caller = &#34;generate_report&#34;

    # Add report header
    if export_format == &#39;markdown&#39;:
        report_content += f&#34;# Comprehensive Variable Report\n\n&#34;
        report_content += f&#34;**Generated on {timestamp} by {caller}**\n\n&#34;
    elif export_format == &#39;html&#39;:
        # Define CSS for HTML
        css = &#34;&#34;&#34;
        &lt;style&gt;
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
            }
            h1, h2, h3, h4, h5 {
                color: #333;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                margin-bottom: 40px;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            th {
                background-color: #4CAF50;
                color: white;
            }
            tr:nth-child(even){background-color: #f2f2f2;}
            tr:hover {background-color: #ddd;}
        &lt;/style&gt;
        &#34;&#34;&#34;
        report_content += f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Comprehensive Variable Report&lt;/title&gt;\n{css}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;
        report_content += f&#34;&lt;h1&gt;Comprehensive Variable Report&lt;/h1&gt;\n&#34;
        report_content += f&#34;&lt;h2&gt;Generated on {timestamp} by {caller}&lt;/h2&gt;\n&#34;

    # Assemble report content using VariableOccurrences.export()
    for var, vo in variables_occurrences.items():
        # Export content without headers and get as string
        var_content = vo.export(filename=filename, # use to identify the format based on its extension
                                scopes=scopes,
                                variables=var,
                                include_headers=False,
                                return_content=True)

        if export_format == &#39;markdown&#39;:
            # Add variable header
            report_content += f&#34;## Variable: `{var}`\n\n&#34;
            report_content += var_content + &#34;\n\n&#34;
            report_content += &#34;---\n\n&#34;  # Horizontal line between variables
        elif export_format == &#39;html&#39;:
            # Add variable header
            report_content += f&#34;&lt;h2&gt;Variable: {var}&lt;/h2&gt;\n&#34;
            report_content += var_content + &#34;\n&lt;hr/&gt;\n&#34;  # Horizontal line between variables

    # Finalize HTML content
    if export_format == &#39;html&#39;:
        report_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

    # Write report to file
    try:
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            file.write(report_content)
        print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
    except Exception as e:
        raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="script.pipescript.getUSER"><code class="name flex">
<span>def <span class="ident">getUSER</span></span>(<span>self, idx, key)</span>
</code></dt>
<dd>
<div class="desc"><p>getUSER get USER variable
getUSER(idx,varname)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUSER(self,idx,key):
    &#34;&#34;&#34;
        getUSER get USER variable
        getUSER(idx,varname)
    &#34;&#34;&#34;
    if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
        self.listUSER[idx].getattr(key)
    else:
        raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)</code></pre>
</details>
</dd>
<dt id="script.pipescript.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self, verbose=True, verbosity=None, style=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a formatted header for the pipescript file.</p>
<h2 id="parameters">Parameters</h2>
<p>verbosity (bool, optional): If specified, overrides the instance's <code>verbose</code> setting.
Defaults to the instance's <code>verbose</code>.
style (int from 1 to 6, optional): ASCII style to frame the header (default=4)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representing the pipescript object.
Returns an empty string if verbosity is False.</dd>
</dl>
<p>The header includes:
- Total number of scripts in the pipeline.
- The verbosity setting.
- The range of scripts from the first to the last script.
- All enclosed within an ASCII frame that adjusts to the content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self, verbose=True,verbosity=None, style=4):
    &#34;&#34;&#34;
    Generate a formatted header for the pipescript file.

    Parameters:
        verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                    Defaults to the instance&#39;s `verbose`.
        style (int from 1 to 6, optional): ASCII style to frame the header (default=4)

    Returns:
        str: A formatted string representing the pipescript object.
             Returns an empty string if verbosity is False.

    The header includes:
        - Total number of scripts in the pipeline.
        - The verbosity setting.
        - The range of scripts from the first to the last script.
        - All enclosed within an ASCII frame that adjusts to the content.
    &#34;&#34;&#34;
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    if not verbosity:
        return &#34;&#34;

    # Prepare the header content
    lines = [
        f&#34;PIPESCRIPT with {self.n} scripts | Verbosity: {verbosity}&#34;,
        &#34;&#34;,
        f&#34;From: &lt;{str(self.scripts[0])}&gt; To: &lt;{str(self.scripts[-1])}&gt;&#34;,
    ]

    # Use the shared method to format the header
    return frame_header(lines,style=style)</code></pre>
</details>
</dd>
<dt id="script.pipescript.list_multiple_values"><code class="name flex">
<span>def <span class="ident">list_multiple_values</span></span>(<span>self, varnames, what='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all occurrences and values of multiple variables across the pipeline scripts.</p>
<p>Parameters:
- varnames (list): A list of variable names to search for.
- what (str or list/tuple): Specifies the scopes to search in.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.</p>
<p>Returns:
- dict: A dictionary mapping each variable name to its VariableOccurrences object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_multiple_values(self, varnames, what=&#34;all&#34;):
    &#34;&#34;&#34;
    Lists all occurrences and values of multiple variables across the pipeline scripts.

    Parameters:
    - varnames (list): A list of variable names to search for.
    - what (str or list/tuple): Specifies the scopes to search in.
                                 Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                 or a list/tuple of any combination of these.

    Returns:
    - dict: A dictionary mapping each variable name to its VariableOccurrences object.
    &#34;&#34;&#34;
    if not isinstance(varnames, (list, tuple)):
        raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

    return self.list_values(varname=varnames, what=what)</code></pre>
</details>
</dd>
<dt id="script.pipescript.list_values"><code class="name flex">
<span>def <span class="ident">list_values</span></span>(<span>self, varname=None, what='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.</p>
<p>Parameters:
- varname (str, optional): The name of the variable to search for. If None, all variables are listed.
- what (str or list/tuple, optional): Specifies the scopes to search in.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.</p>
<p>Returns:
- VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
- dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_values(self, varname=None, what=&#34;all&#34;):
    &#34;&#34;&#34;
    Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.

    Parameters:
    - varname (str, optional): The name of the variable to search for. If None, all variables are listed.
    - what (str or list/tuple, optional): Specifies the scopes to search in.
                                         Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                         or a list/tuple of any combination of these.

    Returns:
    - VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
    - dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.
    &#34;&#34;&#34;
    # Normalize &#39;what&#39; to a list for uniform processing
    if isinstance(what, str):
        if what.lower() == &#34;all&#34;:
            scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
        else:
            scopes = [what.lower()]
    elif isinstance(what, (list, tuple)):
        scopes_lower = [s.lower() for s in what]
        if &#39;all&#39; in scopes_lower:
            scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
        else:
            scopes = scopes_lower
    else:
        raise ValueError(&#34;Parameter &#39;what&#39; must be a string or a list/tuple of strings.&#34;)

    # Initialize data structures
    if varname:
        # Single variable case
        if len(scopes) == 1:
            data = []
        else:
            data = {}
            for scope in scopes:
                data[scope] = []

        # Iterate over each script in the pipeline
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            # Check each requested scope
            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                if varname in vars_dict.keys():
                    value = getattr(vars_dict,varname)
                    if len(scopes) == 1:
                        data.append((i, value))
                    else:
                        data[scope].append((i, value))

        # Return a VariableOccurrences instance for the specified variable
        return VariableOccurrences(data, variables=varname)

    else:
        # All variables case
        all_vars = set()

        # First, collect all variable names across specified scopes and scripts
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                all_vars.update(vars_dict.keys())

        # Initialize a dictionary to hold VariableOccurrences for each variable
        variables_data = {}
        for var in all_vars:
            var_data = {}
            for scope in scopes:
                var_data[scope] = []
            variables_data[var] = var_data

        # Iterate again to populate the data for each variable
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                for var, value in vars_dict.items():
                    variables_data[var][scope].append((i, value))

        # Convert each variable&#39;s data into a VariableOccurrences instance
        variables_occurrences = {}
        for var, data in variables_data.items():
            variables_occurrences[var] = VariableOccurrences(data, variables=var)

        return variables_occurrences</code></pre>
</details>
</dd>
<dt id="script.pipescript.plot_multiple_value_distributions"><code class="name flex">
<span>def <span class="ident">plot_multiple_value_distributions</span></span>(<span>self, varnames, what='all', separate_plots=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the distribution of elements for multiple variables across specified scopes.</p>
<p>Parameters:
- varnames (list): A list of variable names to plot.
- what (str or list/tuple): Specifies the scopes to include in the plot.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.
- separate_plots (bool): If True, plots each variable in a separate subplot.
If False, combines all variables in a single plot for comparison.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_multiple_value_distributions(self, varnames, what=&#34;all&#34;, separate_plots=True):
    &#34;&#34;&#34;
    Plots the distribution of elements for multiple variables across specified scopes.

    Parameters:
    - varnames (list): A list of variable names to plot.
    - what (str or list/tuple): Specifies the scopes to include in the plot.
                                 Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                 or a list/tuple of any combination of these.
    - separate_plots (bool): If True, plots each variable in a separate subplot.
                             If False, combines all variables in a single plot for comparison.
    &#34;&#34;&#34;
    if not isinstance(varnames, (list, tuple)):
        raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

    # Retrieve VariableOccurrences instances
    multiple_vars = self.list_multiple_values(varnames, what=what)

    if separate_plots:
        num_vars = len(multiple_vars)
        fig, axes = plt.subplots(num_vars, 1, figsize=(10, 5 * num_vars))
        if num_vars == 1:
            axes = [axes]  # Make it iterable

        for ax, (var, vo) in zip(axes, multiple_vars.items()):
            summary = vo.summarize()[var]
            for scope, details in summary.items():
                elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                ax.bar(elements, counts, label=scope)
            ax.set_xlabel(&#39;Element&#39;)
            ax.set_ylabel(&#39;Count&#39;)
            ax.set_title(f&#34;Distribution of elements in &#39;{var}&#39;&#34;)
            ax.legend()

        plt.tight_layout()
        plt.show()

    else:
        plt.figure(figsize=(12, 8))
        for var, vo in multiple_vars.items():
            summary = vo.summarize()[var]
            for scope, details in summary.items():
                elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                plt.bar([f&#34;{var}_{elem}&#34; for elem in elements], counts, label=f&#34;{var} - {scope}&#34;)

        plt.xlabel(&#39;Element&#39;)
        plt.ylabel(&#39;Count&#39;)
        plt.title(&#34;Distribution of elements in multiple variables&#34;)
        plt.legend()
        plt.xticks(rotation=45, ha=&#39;right&#39;)
        plt.tight_layout()
        plt.show()</code></pre>
</details>
</dd>
<dt id="script.pipescript.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, name='', idx=None)</span>
</code></dt>
<dd>
<div class="desc"><p>rename scripts in the pipe
p.rename(idx=[0,2,3],name=["A","B","C"])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(self,name=&#34;&#34;,idx=None):
    &#34;&#34;&#34;
        rename scripts in the pipe
            p.rename(idx=[0,2,3],name=[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;])
    &#34;&#34;&#34;
    if isinstance(name,list):
        if len(name)==len(self) and idx==None:
            self.name = name
        elif len(name) == len(idx):
            for i in range(len(idx)):
                self.rename(name[i],idx[i])
        else:
            IndexError(f&#34;the number of indices {len(idx)} does not match the number of names {len(name)}&#34;)
    elif idx !=None and idx&lt;len(self) and name!=&#34;&#34;:
        self.name[idx] = name
    else:
        raise ValueError(&#34;provide a non empty name and valid index&#34;)</code></pre>
</details>
</dd>
<dt id="script.pipescript.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4)</span>
</code></dt>
<dd>
<div class="desc"><p>script the pipeline or parts of the pipeline
s = p.script()
s = p.script([0,2])</p>
<p>Parameters:
- idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
If None, all steps from the current position to
the end are executed. A list of indices can be
provided to execute specific steps, or a single
integer can be passed to execute a specific step.
Default is None.
- printflag (bool, optional): If True, the generated script for each step is printed
to the console. Default is True.
- verbosity (int, optional): Controls the level of detail in the generated script.
- 0: Minimal output, no comments.
- 1: Basic comments for run steps.
- 2: Detailed comments with additional information.
Default is 2.
- forced (bool, optional): If True, all scripts are regenerated
- style (int, optional):
Defines the ASCII frame style for the header.
Valid values are integers from 1 to 6, corresponding to predefined styles:
1. Basic box with <code>+</code>, <code>-</code>, and <code>|</code>
2. Double-line frame with <code>╔</code>, <code>═</code>, and <code>║</code>
3. Rounded corners with <code>.</code>, <code>'</code>, <code>-</code>, and <code>|</code>
4. Thick outer frame with <code>#</code>, <code>=</code>, and <code>#</code>
5. Box drawing characters with <code>┌</code>, <code>─</code>, and <code>│</code>
6. Minimalist dotted frame with <code>.</code>, <code>:</code>, and <code>.</code>
Default is <code>4</code> (thick outer frame).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def script(self,idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4):
    &#34;&#34;&#34;
        script the pipeline or parts of the pipeline
            s = p.script()
            s = p.script([0,2])

    Parameters:
    - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                           If None, all steps from the current position to
                                           the end are executed. A list of indices can be
                                           provided to execute specific steps, or a single
                                           integer can be passed to execute a specific step.
                                           Default is None.
    - printflag (bool, optional): If True, the generated script for each step is printed
                                  to the console. Default is True.
    - verbosity (int, optional): Controls the level of detail in the generated script.
                                 - 0: Minimal output, no comments.
                                 - 1: Basic comments for run steps.
                                 - 2: Detailed comments with additional information.
                                 Default is 2.
    - forced (bool, optional): If True, all scripts are regenerated
    - style (int, optional):
        Defines the ASCII frame style for the header.
        Valid values are integers from 1 to 6, corresponding to predefined styles:
            1. Basic box with `+`, `-`, and `|`
            2. Double-line frame with `╔`, `═`, and `║`
            3. Rounded corners with `.`, `&#39;`, `-`, and `|`
            4. Thick outer frame with `#`, `=`, and `#`
            5. Box drawing characters with `┌`, `─`, and `│`
            6. Minimalist dotted frame with `.`, `:`, and `.`
        Default is `4` (thick outer frame).

    &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity=0 if verbose is False else verbosity
    s = script(printflag=printflag, verbose=verbosity&gt;0)
    s.name = &#34;pipescript&#34;
    s.description = &#34;pipeline with %d scripts&#34; % len(self)
    if len(self)&gt;1:
        s.userid = self.name[0]+&#34;-&gt;&#34;+self.name[-1]
    elif len(self)==1:
        s.userid = self.name[0]
    else:
        s.userid = &#34;empty pipeline&#34;
    s.TEMPLATE = self.header(verbosity=verbosity, style=style) + &#34;\n&#34; +\
        self.do(idx, printflag=printflag, verbosity=verbosity, verbose=verbose, forced=forced)
    s.DEFINITIONS = duplicate(self.globalscript.DEFINITIONS)
    s.USER = duplicate(self.globalscript.USER)
    return s</code></pre>
</details>
</dd>
<dt id="script.pipescript.setUSER"><code class="name flex">
<span>def <span class="ident">setUSER</span></span>(<span>self, idx, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>setUSER sets USER variables
setUSER(idx,varname,varvalue)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUSER(self,idx,key,value):
    &#34;&#34;&#34;
        setUSER sets USER variables
        setUSER(idx,varname,varvalue)
    &#34;&#34;&#34;
    if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
        self.listUSER[idx].setattr(key,value)
    else:
        raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)</code></pre>
</details>
</dd>
<dt id="script.pipescript.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, printflag=False, verbosity=2, verbose=None, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the combined script to a file.</p>
<h2 id="parameters">Parameters</h2>
<p>file (str): The file path where the script will be saved.
printflag (bool): Flag to enable/disable printing of details.
verbosity (int): Level of verbosity for the script generation.
verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance's verbosity.
overwrite (bool): Whether to overwrite the file if it already exists. Default is False.</p>
<p>Returns:
str: The full absolute path of the file written.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and overwrite is False.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>This method combines the individual scripts within the <code><a title="script.pipescript" href="#script.pipescript">pipescript</a></code> object
and saves the resulting script to the specified file.</li>
<li>If <code>overwrite</code> is False and the file exists, an error is raised.</li>
<li>If <code>verbose</code> is True and the file is overwritten, a warning is displayed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, printflag=False, verbosity=2, verbose=None, overwrite=False):
   &#34;&#34;&#34;
   Write the combined script to a file.

   Parameters:
       file (str): The file path where the script will be saved.
       printflag (bool): Flag to enable/disable printing of details.
       verbosity (int): Level of verbosity for the script generation.
       verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance&#39;s verbosity.
       overwrite (bool): Whether to overwrite the file if it already exists. Default is False.

    Returns:
        str: The full absolute path of the file written.

   Raises:
       FileExistsError: If the file already exists and overwrite is False.

   Notes:
       - This method combines the individual scripts within the `pipescript` object
         and saves the resulting script to the specified file.
       - If `overwrite` is False and the file exists, an error is raised.
       - If `verbose` is True and the file is overwritten, a warning is displayed.
   &#34;&#34;&#34;
   # Generate the combined script
   myscript = self.script(printflag=printflag, verbosity=verbosity, verbose=verbose, forced=True)
   # Call the script&#39;s write method with the overwrite parameter
   return myscript.write(file, printflag=printflag, verbose=verbose, overwrite=overwrite)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="script.rigidwall"><code class="flex name class">
<span>class <span class="ident">rigidwall</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>rigid walls (smd:none):
rigidwall()
rigidwall(beadtype=index, userid="wall", USER=&hellip;)</p>
<p>override any propery with USER.parameter (set only the parameters you want to override)
USER.rho: density in kg/m3 (default=3000)
USER.c0: speed of the sound in m/s (default=10.0)
USER.contact_scale: scaling coefficient for contact (default=1.5)
USER.contact_stiffness: contact stifness in Pa (default="2.5<em>${c0}^2</em>${rho}")</p>
<p>rigidwall forcefield:
rigidwall(beadtype=index, userid="mywall")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class rigidwall(none):
    &#34;&#34;&#34; rigid walls (smd:none):
            rigidwall()
            rigidwall(beadtype=index, userid=&#34;wall&#34;, USER=...)

            override any propery with USER.parameter (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=3000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = none.name + struct(material=&#34;walls&#34;)
    description = none.description + struct(material=&#34;rigid walls&#34;)
    userid = &#39;solidfood&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; rigidwall forcefield:
            rigidwall(beadtype=index, userid=&#34;mywall&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            rho = 3000,
            c0 = 10.0,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;,
            contact_scale = 1.5
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.none</li>
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.rigidwall.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.rigidwall.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.rigidwall.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.rigidwall.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="script.runsection"><code class="flex name class">
<span>class <span class="ident">runsection</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>LAMMPS script: run session </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class runsection(script):
    &#34;&#34;&#34; LAMMPS script: run session &#34;&#34;&#34;
    name = &#34;run&#34;
    description = name+&#34; section&#34;
    position = 9
    section = 10
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = globalsection.DEFINITIONS + scriptdata(
        balance = &#34;$ 500 0.9 rcb&#34;
        )

    TEMPLATE = &#34;&#34;&#34;
# :RUN SECTION:
#   run configuration

    ####################################################################################################
    # RUN SIMULATION
    ####################################################################################################
    fix             balance_fix all balance ${balance} # load balancing for MPI
    run             ${tsim}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="script.script" href="#script.script">script</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.runsection.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.runsection.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.runsection.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.runsection.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.runsection.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.runsection.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.runsection.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.runsection.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="script.script" href="#script.script">script</a></b></code>:
<ul class="hlist">
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="script.saltTLSPH"><code class="flex name class">
<span>class <span class="ident">saltTLSPH</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>SALTLSPH (smd:tlsph): ongoing "salting" beadtype for rheology control
saltTLSPH()
saltTLSPH(beadtype=index, userid="salt", USER=&hellip;)</p>
<p>override any property with USER.property = value</p>
<p>saltTLSPH forcefield:
saltTLSPH(beadtype=index, userid="salt")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class saltTLSPH(tlsph):
    &#34;&#34;&#34; SALTLSPH (smd:tlsph): ongoing &#34;salting&#34; beadtype for rheology control
            saltTLSPH()
            saltTLSPH(beadtype=index, userid=&#34;salt&#34;, USER=...)

            override any property with USER.property = value
    &#34;&#34;&#34;
    name = tlsph.name + struct(material=&#34;solidfood&#34;)
    description = tlsph.description + struct(material=&#34;food beads - solid behavior&#34;)
    userid = &#39;&#34;salt&#34;&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; saltTLSPH forcefield:
            saltTLSPH(beadtype=index, userid=&#34;salt&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # food-food interactions
            rho = 1000,
            c0 = 10.0,
            E = &#39;5*${c0}^2*${rho}&#39;,
            nu = 0.3,
            q1 = 1.0,
            q2 = 0.0,
            Hg = 10,
            Cp = 1.0,
            sigma_yield = &#39;0.1*${E}&#39;,
            hardening = 0,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.tlsph</li>
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.saltTLSPH.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.saltTLSPH.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.saltTLSPH.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.saltTLSPH.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="script.script"><code class="flex name class">
<span>class <span class="ident">script</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>script: A Core Class for Flexible LAMMPS Script Generation</p>
<p>The <code><a title="script.script" href="#script.script">script</a></code> class provides a flexible framework for generating dynamic LAMMPS
script sections. It supports various LAMMPS sections such as "GLOBAL", "INITIALIZE",
"GEOMETRY", "INTERACTIONS", and more, while allowing users to define custom sections
with variable definitions, templates, and dynamic evaluation of script content.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Dynamic Script Generation</strong>: Easily define and manage script sections,
using templates and definitions to dynamically generate LAMMPS-compatible scripts.</li>
<li><strong>Script Concatenation</strong>: Combine multiple script sections while managing
variable precedence and ensuring that definitions propagate as expected.</li>
<li><strong>Flexible Variable Management</strong>: Separate <code>DEFINITIONS</code> for static variables and
<code>USER</code> for user-defined variables, with clear rules for inheritance and precedence.</li>
<li><strong>Operators for Advanced Script Handling</strong>: Use <code>+</code>, <code>&amp;</code>, <code>&gt;&gt;</code>, <code>|</code>, and <code>**</code> operators
for script merging, static execution, right-shifting of definitions, and more.</li>
<li><strong>Pipeline Support</strong>: Integrate scripts into pipelines, with full support for
staged execution, variable inheritance, and reordering of script sections.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>LAMMPS Automation</strong>: Automate the generation of complex LAMMPS scripts by defining
reusable script sections with variables and templates.</li>
<li><strong>Multi-Step Simulations</strong>: Manage multi-step simulations by splitting large scripts
into smaller, manageable sections and combining them as needed.</li>
<li><strong>Advanced Script Control</strong>: Dynamically modify script behavior by overriding variables
or using advanced operators to concatenate, pipe, or merge scripts.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, persistentfile=True, persistentfolder=None, printflag=False, verbose=False, **userdefinitions):
Initializes a new <code><a title="script.script" href="#script.script">script</a></code> object, with optional user-defined variables
passed as <code>userdefinitions</code>.</p>
<p>do(self, printflag=None, verbose=None):
Generates the LAMMPS script based on the current configuration, evaluating
templates and definitions to produce the final output.</p>
<p>script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Generate the final LAMMPS script from the pipeline or a subset of the pipeline.</p>
<p>add(self, s):
Overloads the <code>+</code> operator to concatenate script objects, merging definitions
and templates while maintaining variable precedence.</p>
<p>and(self, s):
Overloads the <code>&amp;</code> operator for static execution, combining the generated scripts
of two script objects without merging their definitions.</p>
<p><strong>mul</strong>(self, ntimes):
Overloads the <code>*</code> operator to repeat the script <code>ntimes</code>, returning a new script
object with repeated sections.</p>
<p><strong>pow</strong>(self, ntimes):
Overloads the <code>**</code> operator to concatenate the script with itself <code>ntimes</code>,
similar to the <code>&amp;</code> operator, but repeated.</p>
<p><strong>or</strong>(self, pipe):
Overloads the pipe (<code>|</code>) operator to integrate the script into a pipeline,
returning a <code><a title="script.pipescript" href="#script.pipescript">pipescript</a></code> object.</p>
<p>write(self, file, printflag=True, verbose=False):
Writes the generated script to a file, including headers with metadata.</p>
<p>tmpwrite(self):
Writes the script to a temporary file, creating both a full version and a clean
version without comments.</p>
<p>printheader(txt, align="^", width=80, filler="~"):
Static method to print formatted headers, useful for organizing output.</p>
<p><strong>copy</strong>(self):
Creates a shallow copy of the script object.</p>
<p><strong>deepcopy</strong>(self, memo):
Creates a deep copy of the script object, duplicating all internal variables.</p>
<h2 id="additional-features">Additional Features:</h2>
<ul>
<li><strong>Customizable Templates</strong>: Use string templates with variable placeholders
(e.g., <code>${value}</code>) to dynamically generate script lines.</li>
<li><strong>Static and User-Defined Variables</strong>: Manage global <code>DEFINITIONS</code> for static
variables and <code>USER</code> variables for dynamic, user-defined settings.</li>
<li><strong>Advanced Operators</strong>: Leverage a range of operators (<code>+</code>, <code>&gt;&gt;</code>, <code>|</code>, <code>&amp;</code>) to
manipulate script content, inherit definitions, and control variable precedence.</li>
<li><strong>Verbose Output</strong>: Control verbosity to include detailed comments and debugging
information in generated scripts.</li>
</ul>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="script.script" href="#script.script">script</a></code> class supports LAMMPS section generation and variable management with
features such as:
- <strong>Dynamic Evaluation of Scripts</strong>: Definitions and templates are evaluated at runtime,
allowing for flexible and reusable scripts.
- <strong>Inheritance of Definitions</strong>: Variable definitions can be inherited from previous
sections, allowing for modular script construction.
- <strong>Precedence Rules for Variables</strong>: When scripts are concatenated, definitions from
the left take precedence, ensuring that the first defined values are preserved.
- <strong>Instance and Global Variables</strong>: Instance variables are set via the <code>USER</code> object,
while global variables (shared across instances) are managed in <code>DEFINITIONS</code>.
- <strong>Script Pipelines</strong>: Scripts can be integrated into pipelines for sequential execution
and dynamic variable propagation.
- <strong>Flexible Output Formats</strong>: Lists are expanded into space-separated strings, while
tuples are expanded with commas, making the output more readable.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>from pizza.script import script, scriptdata

class example_section(script):
    DEFINITIONS = scriptdata(
        X = 10,
        Y = 20,
        result = &quot;${X} + ${Y}&quot;
    )
    TEMPLATE = &quot;${result} = ${X} + ${Y}&quot;

s1 = example_section()
s1.USER.X = 5
s1.do()
</code></pre>
<p>The output for <code>s1.do()</code> will be:</p>
<pre><code>25 = 5 + 20
</code></pre>
<p>With additional sections, scripts can be concatenated and executed as a single
entity, with inheritance of variables and customizable behavior.</p>
<pre><code>--------------------------------------
   OVERVIEW ANDE DETAILED FEATURES
--------------------------------------

The class script enables to generate dynamically LAMMPS sections
"NONE","GLOBAL","INITIALIZE","GEOMETRY","DISCRETIZATION",
"BOUNDARY","INTERACTIONS","INTEGRATION","DUMP","STATUS","RUN"


# %% This the typical construction for a class
class XXXXsection(script):
    "" " LAMMPS script: XXXX session "" "
    name = "XXXXXX"
    description = name+" section"
    position = 0
    section = 0
    userid = "example"
    version = 0.1

    DEFINITIONS = scriptdata(
         value= 1,
    expression= "${value+1}",
          text= "$my text"
        )

    TEMPLATE = "" "
# :UNDEF SECTION:
#   to be defined
LAMMPS code with ${value}, ${expression}, ${text}
    "" "

DEFINTIONS can be inherited from a previous section
DEFINITIONS = previousection.DEFINTIONS + scriptdata(
         value= 1,
    expression= "${value+1}",
          text= "$my text"
    )


Recommandation: Split a large script into a small classes or actions
An example of use could be:
    move1 = translation(displacement=10)+rotation(angle=30)
    move2 = shear(rate=0.1)+rotation(angle=20)
    bigmove = move1+move2+move1
    script = bigmove.do() generates the script

NOTE1: Use the print() and the method do() to get the script interpreted

NOTE2: DEFINITIONS can be pretified using DEFINITIONS.generator()

NOTE3: Variables can extracted from a template using TEMPLATE.scan()

NOTE4: Scripts can be joined (from top down to bottom).
The first definitions keep higher precedence. Please do not use
a variable twice with different contents.

myscript = s1 + s2 + s3 will propagate the definitions
without overwritting previous values). myscript will be
defined as s1 (same name, position, userid, etc.)

myscript += s appends the script section s to myscript

NOTE5: rules of precedence when script are concatenated
The attributes from the class (name, description...) are kept from the left
The values of the right overwrite all DEFINITIONS

NOTE6: user variables (instance variables) can set with USER or at the construction
myclass_instance = myclass(myvariable = myvalue)
myclass_instance.USER.myvariable = myvalue

NOTE7: how to change variables for all instances at once?
In the example below, let x is a global variable (instance independent)
and y a local variable (instance dependent)
instance1 = myclass(y=1) --&gt; y=1 in instance1
instance2 = myclass(y=2) --&gt; y=2 in instance2
instance3.USER.y=3 --&gt; y=3 in instance3
instance1.DEFINITIONS.x = 10 --&gt; x=10 in all instances (1,2,3)

If x is also defined in the USER section, its value will be used
Setting instance3.USER.x = 30 will assign x=30 only in instance3

NOTE8: if a the script is used with different values for a same parameter
use the operator &amp; to concatenate the results instead of the script
example: load(file="myfile1") &amp; load(file="myfile2) &amp; load(file="myfile3")+...

NOTE9: lists (e.g., [1,2,'a',3] are expanded ("1 2 a 3")
       tuples (e.g. (1,2)) are expanded ("1,2")
       It is easier to read ["lost","ignore"] than "$ lost ignore"

NOTE 10: New operators &gt;&gt; and || extend properties
    + merge all scripts but overwrite definitions
    &amp; execute statically script content
    &gt;&gt; pass only DEFINITIONS but not TEMPLATE to the right
    | pipe execution such as in Bash, the result is a pipeline

NOTE 11: Scripts in pipelines are very flexible, they support
full indexing à la Matlab, including staged executions
    method do(idx) generates the script corresponding to indices idx
    method script(idx) generates the corresponding script object

--------------------------[ FULL EXAMPLE ]-----------------------------

# Import the class
from pizza.script import *

# Override the class globalsection
class scriptexample(globalsection):
    description = "demonstrate commutativity of additions"
    verbose = True

    DEFINITIONS = scriptdata(
        X = 10,
        Y = 20,
        R1 = "${X}+${Y}",
        R2 = "${Y}+${X}"
        )
    TEMPLATE = "" "
    # Property of the addition
    ${R1} = ${X} + ${Y}
    ${R2} = ${Y} + ${X}
 "" "

# derived from scriptexample, X and Y are reused
class scriptexample2(scriptexample):
    description = "demonstrate commutativity of multiplications"
    verbose = True
    DEFINITIONS = scriptexample.DEFINITIONS + scriptdata(
        R3 = "${X} * ${Y}",
        R4 = "${Y} * ${X}",
        )
    TEMPLATE = "" "
    # Property of the multiplication
    ${R3} = ${X} * ${Y}
    ${R4} = ${Y} * ${X}
 "" "

# call the first class and override the values X and Y
s1 = scriptexample()
s1.USER.X = 1  # method 1 of override
s1.USER.Y = 2
s1.do()
# call the second class and override the values X and Y
s2 = scriptexample2(X=1000,Y=2000) # method 2
s2.do()
# Merge the two scripts
s = s1+s2
print("this is my full script")
s.description
s.do()

# The result for s1 is
    3 = 1 + 2
    3 = 2 + 1
# The result for s2 is
    2000000 = 1000 * 2000
    2000000 = 2000 * 1000
# The result for s=s1+s2 is
    # Property of the addition
    3000 = 1000 + 2000
    3000 = 2000 + 1000
    # Property of the multiplication
    2000000 = 1000 * 2000
    2000000 = 2000 * 1000
</code></pre>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class script:
    &#34;&#34;&#34;
    script: A Core Class for Flexible LAMMPS Script Generation

    The `script` class provides a flexible framework for generating dynamic LAMMPS
    script sections. It supports various LAMMPS sections such as &#34;GLOBAL&#34;, &#34;INITIALIZE&#34;,
    &#34;GEOMETRY&#34;, &#34;INTERACTIONS&#34;, and more, while allowing users to define custom sections
    with variable definitions, templates, and dynamic evaluation of script content.

    Key Features:
    -------------
    - **Dynamic Script Generation**: Easily define and manage script sections,
      using templates and definitions to dynamically generate LAMMPS-compatible scripts.
    - **Script Concatenation**: Combine multiple script sections while managing
      variable precedence and ensuring that definitions propagate as expected.
    - **Flexible Variable Management**: Separate `DEFINITIONS` for static variables and
      `USER` for user-defined variables, with clear rules for inheritance and precedence.
    - **Operators for Advanced Script Handling**: Use `+`, `&amp;`, `&gt;&gt;`, `|`, and `**` operators
      for script merging, static execution, right-shifting of definitions, and more.
    - **Pipeline Support**: Integrate scripts into pipelines, with full support for
      staged execution, variable inheritance, and reordering of script sections.

    Practical Use Cases:
    --------------------
    - **LAMMPS Automation**: Automate the generation of complex LAMMPS scripts by defining
      reusable script sections with variables and templates.
    - **Multi-Step Simulations**: Manage multi-step simulations by splitting large scripts
      into smaller, manageable sections and combining them as needed.
    - **Advanced Script Control**: Dynamically modify script behavior by overriding variables
      or using advanced operators to concatenate, pipe, or merge scripts.

    Methods:
    --------
    __init__(self, persistentfile=True, persistentfolder=None, printflag=False, verbose=False, **userdefinitions):
        Initializes a new `script` object, with optional user-defined variables
        passed as `userdefinitions`.

    do(self, printflag=None, verbose=None):
        Generates the LAMMPS script based on the current configuration, evaluating
        templates and definitions to produce the final output.

    script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Generate the final LAMMPS script from the pipeline or a subset of the pipeline.

    add(self, s):
        Overloads the `+` operator to concatenate script objects, merging definitions
        and templates while maintaining variable precedence.

    and(self, s):
        Overloads the `&amp;` operator for static execution, combining the generated scripts
        of two script objects without merging their definitions.

    __mul__(self, ntimes):
        Overloads the `*` operator to repeat the script `ntimes`, returning a new script
        object with repeated sections.

    __pow__(self, ntimes):
        Overloads the `**` operator to concatenate the script with itself `ntimes`,
        similar to the `&amp;` operator, but repeated.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the script into a pipeline,
        returning a `pipescript` object.

    write(self, file, printflag=True, verbose=False):
        Writes the generated script to a file, including headers with metadata.

    tmpwrite(self):
        Writes the script to a temporary file, creating both a full version and a clean
        version without comments.

    printheader(txt, align=&#34;^&#34;, width=80, filler=&#34;~&#34;):
        Static method to print formatted headers, useful for organizing output.

    __copy__(self):
        Creates a shallow copy of the script object.

    __deepcopy__(self, memo):
        Creates a deep copy of the script object, duplicating all internal variables.

    Additional Features:
    --------------------
    - **Customizable Templates**: Use string templates with variable placeholders
      (e.g., `${value}`) to dynamically generate script lines.
    - **Static and User-Defined Variables**: Manage global `DEFINITIONS` for static
      variables and `USER` variables for dynamic, user-defined settings.
    - **Advanced Operators**: Leverage a range of operators (`+`, `&gt;&gt;`, `|`, `&amp;`) to
      manipulate script content, inherit definitions, and control variable precedence.
    - **Verbose Output**: Control verbosity to include detailed comments and debugging
      information in generated scripts.

    Original Content:
    -----------------
    The `script` class supports LAMMPS section generation and variable management with
    features such as:
    - **Dynamic Evaluation of Scripts**: Definitions and templates are evaluated at runtime,
      allowing for flexible and reusable scripts.
    - **Inheritance of Definitions**: Variable definitions can be inherited from previous
      sections, allowing for modular script construction.
    - **Precedence Rules for Variables**: When scripts are concatenated, definitions from
      the left take precedence, ensuring that the first defined values are preserved.
    - **Instance and Global Variables**: Instance variables are set via the `USER` object,
      while global variables (shared across instances) are managed in `DEFINITIONS`.
    - **Script Pipelines**: Scripts can be integrated into pipelines for sequential execution
      and dynamic variable propagation.
    - **Flexible Output Formats**: Lists are expanded into space-separated strings, while
      tuples are expanded with commas, making the output more readable.

    Example Usage:
    --------------
    ```
    from pizza.script import script, scriptdata

    class example_section(script):
        DEFINITIONS = scriptdata(
            X = 10,
            Y = 20,
            result = &#34;${X} + ${Y}&#34;
        )
        TEMPLATE = &#34;${result} = ${X} + ${Y}&#34;

    s1 = example_section()
    s1.USER.X = 5
    s1.do()
    ```

    The output for `s1.do()` will be:
    ```
    25 = 5 + 20
    ```

    With additional sections, scripts can be concatenated and executed as a single
    entity, with inheritance of variables and customizable behavior.


        --------------------------------------
           OVERVIEW ANDE DETAILED FEATURES
        --------------------------------------

        The class script enables to generate dynamically LAMMPS sections
        &#34;NONE&#34;,&#34;GLOBAL&#34;,&#34;INITIALIZE&#34;,&#34;GEOMETRY&#34;,&#34;DISCRETIZATION&#34;,
        &#34;BOUNDARY&#34;,&#34;INTERACTIONS&#34;,&#34;INTEGRATION&#34;,&#34;DUMP&#34;,&#34;STATUS&#34;,&#34;RUN&#34;


        # %% This the typical construction for a class
        class XXXXsection(script):
            &#34;&#34; &#34; LAMMPS script: XXXX session &#34;&#34; &#34;
            name = &#34;XXXXXX&#34;
            description = name+&#34; section&#34;
            position = 0
            section = 0
            userid = &#34;example&#34;
            version = 0.1

            DEFINITIONS = scriptdata(
                 value= 1,
            expression= &#34;${value+1}&#34;,
                  text= &#34;$my text&#34;
                )

            TEMPLATE = &#34;&#34; &#34;
        # :UNDEF SECTION:
        #   to be defined
        LAMMPS code with ${value}, ${expression}, ${text}
            &#34;&#34; &#34;

        DEFINTIONS can be inherited from a previous section
        DEFINITIONS = previousection.DEFINTIONS + scriptdata(
                 value= 1,
            expression= &#34;${value+1}&#34;,
                  text= &#34;$my text&#34;
            )


        Recommandation: Split a large script into a small classes or actions
        An example of use could be:
            move1 = translation(displacement=10)+rotation(angle=30)
            move2 = shear(rate=0.1)+rotation(angle=20)
            bigmove = move1+move2+move1
            script = bigmove.do() generates the script

        NOTE1: Use the print() and the method do() to get the script interpreted

        NOTE2: DEFINITIONS can be pretified using DEFINITIONS.generator()

        NOTE3: Variables can extracted from a template using TEMPLATE.scan()

        NOTE4: Scripts can be joined (from top down to bottom).
        The first definitions keep higher precedence. Please do not use
        a variable twice with different contents.

        myscript = s1 + s2 + s3 will propagate the definitions
        without overwritting previous values). myscript will be
        defined as s1 (same name, position, userid, etc.)

        myscript += s appends the script section s to myscript

        NOTE5: rules of precedence when script are concatenated
        The attributes from the class (name, description...) are kept from the left
        The values of the right overwrite all DEFINITIONS

        NOTE6: user variables (instance variables) can set with USER or at the construction
        myclass_instance = myclass(myvariable = myvalue)
        myclass_instance.USER.myvariable = myvalue

        NOTE7: how to change variables for all instances at once?
        In the example below, let x is a global variable (instance independent)
        and y a local variable (instance dependent)
        instance1 = myclass(y=1) --&gt; y=1 in instance1
        instance2 = myclass(y=2) --&gt; y=2 in instance2
        instance3.USER.y=3 --&gt; y=3 in instance3
        instance1.DEFINITIONS.x = 10 --&gt; x=10 in all instances (1,2,3)

        If x is also defined in the USER section, its value will be used
        Setting instance3.USER.x = 30 will assign x=30 only in instance3

        NOTE8: if a the script is used with different values for a same parameter
        use the operator &amp; to concatenate the results instead of the script
        example: load(file=&#34;myfile1&#34;) &amp; load(file=&#34;myfile2) &amp; load(file=&#34;myfile3&#34;)+...

        NOTE9: lists (e.g., [1,2,&#39;a&#39;,3] are expanded (&#34;1 2 a 3&#34;)
               tuples (e.g. (1,2)) are expanded (&#34;1,2&#34;)
               It is easier to read [&#34;lost&#34;,&#34;ignore&#34;] than &#34;$ lost ignore&#34;

        NOTE 10: New operators &gt;&gt; and || extend properties
            + merge all scripts but overwrite definitions
            &amp; execute statically script content
            &gt;&gt; pass only DEFINITIONS but not TEMPLATE to the right
            | pipe execution such as in Bash, the result is a pipeline

        NOTE 11: Scripts in pipelines are very flexible, they support
        full indexing à la Matlab, including staged executions
            method do(idx) generates the script corresponding to indices idx
            method script(idx) generates the corresponding script object

        --------------------------[ FULL EXAMPLE ]-----------------------------

        # Import the class
        from pizza.script import *

        # Override the class globalsection
        class scriptexample(globalsection):
            description = &#34;demonstrate commutativity of additions&#34;
            verbose = True

            DEFINITIONS = scriptdata(
                X = 10,
                Y = 20,
                R1 = &#34;${X}+${Y}&#34;,
                R2 = &#34;${Y}+${X}&#34;
                )
            TEMPLATE = &#34;&#34; &#34;
            # Property of the addition
            ${R1} = ${X} + ${Y}
            ${R2} = ${Y} + ${X}
         &#34;&#34; &#34;

        # derived from scriptexample, X and Y are reused
        class scriptexample2(scriptexample):
            description = &#34;demonstrate commutativity of multiplications&#34;
            verbose = True
            DEFINITIONS = scriptexample.DEFINITIONS + scriptdata(
                R3 = &#34;${X} * ${Y}&#34;,
                R4 = &#34;${Y} * ${X}&#34;,
                )
            TEMPLATE = &#34;&#34; &#34;
            # Property of the multiplication
            ${R3} = ${X} * ${Y}
            ${R4} = ${Y} * ${X}
         &#34;&#34; &#34;

        # call the first class and override the values X and Y
        s1 = scriptexample()
        s1.USER.X = 1  # method 1 of override
        s1.USER.Y = 2
        s1.do()
        # call the second class and override the values X and Y
        s2 = scriptexample2(X=1000,Y=2000) # method 2
        s2.do()
        # Merge the two scripts
        s = s1+s2
        print(&#34;this is my full script&#34;)
        s.description
        s.do()

        # The result for s1 is
            3 = 1 + 2
            3 = 2 + 1
        # The result for s2 is
            2000000 = 1000 * 2000
            2000000 = 2000 * 1000
        # The result for s=s1+s2 is
            # Property of the addition
            3000 = 1000 + 2000
            3000 = 2000 + 1000
            # Property of the multiplication
            2000000 = 1000 * 2000
            2000000 = 2000 * 1000

    &#34;&#34;&#34;

    # metadata
    metadata = get_metadata()               # retrieve all metadata

    type = &#34;script&#34;                         # type (class name)
    name = &#34;empty script&#34;                   # name
    description = &#34;it is an empty script&#34;   # description
    position = 0                            # 0 = root
    section = 0                             # section (0=undef)
    userid = &#34;undefined&#34;                    # user name
    version = metadata[&#34;version&#34;]           # version
    license = metadata[&#34;license&#34;]
    email = metadata[&#34;email&#34;]               # email

    verbose = False                         # set it to True to force verbosity
    _contact = (&#34;INRAE\SAYFOOD\olivier.vitrac@agroparistech.fr&#34;,
                &#34;INRAE\SAYFOOD\william.jenkinson@agroparistech.fr&#34;,
                &#34;INRAE\SAYFOOD\han.chen@inrae.fr&#34;)

    SECTIONS = [&#34;NONE&#34;,&#34;GLOBAL&#34;,&#34;INITIALIZE&#34;,&#34;GEOMETRY&#34;,&#34;DISCRETIZATION&#34;,
                &#34;BOUNDARY&#34;,&#34;INTERACTIONS&#34;,&#34;INTEGRATION&#34;,&#34;DUMP&#34;,&#34;STATUS&#34;,&#34;RUN&#34;]

    # Main class variables
    # These definitions are for instances
    DEFINITIONS = scriptdata()
    TEMPLATE = &#34;&#34;&#34;
        # empty LAMMPS script
    &#34;&#34;&#34;

    # constructor
    def __init__(self,persistentfile=True,
                 persistentfolder = None,
                 printflag = False,
                 verbose = False,
                 verbosity = None,
                 **userdefinitions):
        &#34;&#34;&#34; constructor adding instance definitions stored in USER &#34;&#34;&#34;
        if persistentfolder is None: persistentfolder = get_tmp_location()
        self.persistentfile = persistentfile
        self.persistentfolder = persistentfolder
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.USER = scriptdata(**userdefinitions)

    # print method for headers (static, no implicit argument)
    @staticmethod
    def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
        &#34;&#34;&#34; print header &#34;&#34;&#34;
        if txt==&#34;&#34;:
            print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
        else:
            print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))

    # String representation
    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self.type}:{self.name}:{self.userid}&#34;

    # Display/representation method
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        stamp = str(self)
        self.printheader(f&#34;{stamp} | version={self.version}&#34;,filler=&#34;/&#34;)
        self.printheader(&#34;POSITION &amp; DESCRIPTION&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        print(f&#34;     position: {self.position}&#34;)
        print(f&#34;         role: {self.role} (section={self.section})&#34;)
        print(f&#34;  description: {self.description}&#34;)
        self.printheader(&#34;DEFINITIONS&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        if len(self.DEFINITIONS)&lt;15:
            self.DEFINITIONS.__repr__()
        else:
            print(&#34;too many definitions: &#34;,self.DEFINITIONS)
        if self.verbose:
            self.printheader(&#34;USER&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
            self.USER.__repr__()
            self.printheader(&#34;TEMPLATE&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
            print(self.TEMPLATE)
            self.printheader(&#34;SCRIPT&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        print(self.do(printflag=False))
        self.printheader(&#34;&#34;)
        return stamp

    # Extract attributes within the class
    def getallattributes(self):
        &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
        return {k: getattr(self, k) for k in dir(self) \
                if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}

    # Generate the script
    def do(self,printflag=None,verbose=None):
        &#34;&#34;&#34;
        Generate the LAMMPS script based on the current configuration.

        This method generates a LAMMPS-compatible script from the templates and definitions
        stored in the `script` object. The generated script can be displayed, returned,
        and optionally include comments for debugging or clarity.

        Parameters:
        -----------
        - printflag (bool, optional): If True, the generated script is printed to the console.
                                      Default is True.
        - verbose (bool, optional): If True, comments and additional information are included
                                    in the generated script. If False, comments are removed.
                                    Default is True.

        Returns:
        ---------
        - str: The generated LAMMPS script.

        Method Behavior:
        - The method first collects all key-value pairs from `DEFINITIONS` and `USER` objects,
          which store the configuration data for the script.
        - Lists and tuples in the collected data are formatted into a readable string with proper
          separators (space for lists, comma for tuples) and prefixed with a &#39;%&#39; to indicate comments.
        - The generated command template is formatted and evaluated using the collected data.
        - If `verbose` is set to False, comments in the generated script are removed.
        - The script is then printed if `printflag` is True.
        - Finally, the formatted script is returned as a string.


        Example Usage:
        --------------
        &gt;&gt;&gt; s = script()
        &gt;&gt;&gt; s.do(printflag=True, verbose=True)
        units           si
        dimension       3
        boundary        f f f
        # Additional script commands...

        &gt;&gt;&gt; s.do(printflag=False, verbose=False)
        &#39;units si\ndimension 3\nboundary f f f\n# Additional script commands...&#39;

        Notes:
        - Comments are indicated in the script with &#39;%&#39; or &#39;#&#39;.
        - The [position {self.position}:{self.userid}] marker is inserted for tracking
          script sections or modifications.


        Known Issues for indexed variables
        ----------------------------------
        List and tupples used indexed in templates, such as varlist[1], are not converted into strings so that
        each element can be considered as a variable and accessed as ${varlist[1]}. If varlist is also used in
        full, such as ${varlist}. Then it is preferable to define varlist as a string:
            &#34;![v1,v2,...]&#34; where v1,v2,v3 can be int, float, static str or evaluable str (i.e., subjected to nested
             evaluation).
        The control character ! in lists, such as in var=![v1,v2,v3] preserves the Pythonic definition by do()
        at later stages during the evaluation so that its content can be indexed.

        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        inputs = self.DEFINITIONS + self.USER
        usedvariables = self.detect_variables(with_index=False,only_indexed=False)
        variables_used_with_index = self.detect_variables(with_index=False,only_indexed=True)
        usedvariables_withoutindex = [ var for var in usedvariables if var not in variables_used_with_index ]
        for k in inputs.keys():
            if k in usedvariables_withoutindex:
                if isinstance(inputs.getattr(k),list):
                    inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k)))
                elif isinstance(inputs.getattr(k),tuple):
                    inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k),sep=&#34;,&#34;))
        cmd = inputs.formateval(self.TEMPLATE)
        cmd = cmd.replace(&#34;[comment]&#34;,f&#34;[position {self.position}:{self.userid}]&#34;)
        if not verbose: cmd=remove_comments(cmd)
        if printflag: print(cmd)
        return cmd

    # Return the role of the script (based on section)
    @property
    def role(self):
        &#34;&#34;&#34; convert section index into a role (section name) &#34;&#34;&#34;
        if self.section in range(len(self.SECTIONS)):
            return self.SECTIONS[self.section]
        else:
            return &#34;&#34;

    # override +
    def __add__(self,s):
        &#34;&#34;&#34; overload addition operator &#34;&#34;&#34;
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        if isinstance(s,script):
            dup = duplicate(self)
            dup.DEFINITIONS = dup.DEFINITIONS + s.DEFINITIONS
            dup.USER = dup.USER + s.USER
            dup.TEMPLATE = &#34;\n&#34;.join([dup.TEMPLATE,s.TEMPLATE])
            return dup
        elif isinstance(s,pipescript):
            return pipescript(self, printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity) | s
        elif isinstance(s,dscript):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        elif isinstance(s, scriptobjectgroup):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s, group):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        elif isinstance(s, groupcollection):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s,region):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        raise TypeError(f&#34;the second operand in + must a script, pipescript, scriptobjectgroup,\n group, groupcollection or region object not {type(s)}&#34;)

    # override +=
    def _iadd__(self,s):
        &#34;&#34;&#34; overload addition operator &#34;&#34;&#34;
        if isinstance(s,script):
            self.DEFINITIONS = self.DEFINITIONS + s.DEFINITIONS
            self.USER = self.USER + s.USER
            self.TEMPLATE = &#34;\n&#34;.join([self.TEMPLATE,s.TEMPLATE])
        else:
            raise TypeError(&#34;the second operand must a script object&#34;)

    # override &gt;&gt;
    def __rshift__(self,s):
        &#34;&#34;&#34; overload right  shift operator (keep only the last template) &#34;&#34;&#34;
        if isinstance(s,script):
            dup = duplicate(self)
            dup.DEFINITIONS = dup.DEFINITIONS + s.DEFINITIONS
            dup.USER = dup.USER + s.USER
            dup.TEMPLATE = s.TEMPLATE
            return dup
        else:
            raise TypeError(f&#34;the second operand in &gt;&gt; must a script object not {type(s)}&#34;)

    # override &amp;
    def __and__(self,s):
        &#34;&#34;&#34; overload and operator &#34;&#34;&#34;
        if isinstance(s,script):
            dup = duplicate(self)
            dup.TEMPLATE = &#34;\n&#34;.join([self.do(printflag=False,verbose=False),s.do(printflag=False,verbose=False)])
            return dup
        raise TypeError(f&#34;the second operand in &amp; must a script object not {type(s)}&#34;)

    # override *
    def __mul__(self,ntimes):
        &#34;&#34;&#34; overload * operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
           res = duplicate(self)
           if ntimes&gt;1:
               for n in range(1,ntimes): res += self
           return res
        raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)

    # override **
    def __pow__(self,ntimes):
        &#34;&#34;&#34; overload ** operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
           res = duplicate(self)
           if ntimes&gt;1:
               for n in range(1,ntimes): res = res &amp; self
           return res
        raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)

    # pipe scripts
    def __or__(self,pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        if isinstance(pipe, dscript):
            rightarg = pipe.pipescript(printflag=pipe.printflag,verbose=pipe.verbose,verbosity=pipe.verbosity)
        elif isinstance(pipe,group):
            rightarg = pipe.script(printflag=pipe.printflag,verbose=pipe.verbose,verbosity=pipe.verbosity)
        elif isinstance(pipe,groupcollection):
            rightarg = pipe.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(pipe,region):
            rightarg = pipe.pscript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        else:
            rightarg = pipe
        if isinstance(rightarg,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | rightarg
        else:
            raise ValueError(&#34;the argument in | must a pipescript, a scriptobject or a scriptobjectgroup not {type(s)}&#34;)


    def header(self, verbose=True, verbosity=None, style=2):
        &#34;&#34;&#34;
        Generate a formatted header for the script file.

        Parameters:
            verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                        Defaults to the instance&#39;s `verbose`.
            style (int from 1 to 6, optional): ASCII style to frame the header (default=2)

        Returns:
            str: A formatted string representing the script&#39;s metadata and initialization details.
                 Returns an empty string if verbosity is False.

        The header includes:
            - Script version, license, and contact email.
            - User ID and the number of initialized definitions.
            - Current system user, hostname, and working directory.
            - Persistent filename and folder path.
            - Timestamp of the header generation.
        &#34;&#34;&#34;
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        if not verbose:
            return &#34;&#34;
        # Prepare the header content
        lines = [
            f&#34;PIZZA.SCRIPT FILE v{script.version} | License: {script.license} | Email: {script.email}&#34;,
            &#34;&#34;,
            f&#34;&lt;{str(self)}&gt;&#34;,
            f&#34;Initialized with {len(self.USER)} definitions | Verbosity: {verbosity}&#34;,
            f&#34;Persistent file: \&#34;{self.persistentfile}\&#34; | Folder: \&#34;{self.persistentfolder}\&#34;&#34;,
            &#34;&#34;,
            f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
            f&#34;{datetime.datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
        ]
        # Use the shared method to format the header
        return frame_header(lines,style=style)


    # write file
    def write(self, file, printflag=True, verbose=False, overwrite=False, style=2):
        &#34;&#34;&#34;
        Write the script to a file.

        Parameters:
            - file (str): The file path where the script will be saved.
            - printflag (bool): Flag to enable/disable printing of details.
            - verbose (bool): Flag to enable/disable verbose mode.
            - overwrite (bool): Whether to overwrite the file if it already exists.
            - style (int, optional):
                Defines the ASCII frame style for the header.
                Valid values are integers from 1 to 6, corresponding to predefined styles:
                    1. Basic box with `+`, `-`, and `|`
                    2. Double-line frame with `╔`, `═`, and `║`
                    3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                    4. Thick outer frame with `#`, `=`, and `#`
                    5. Box drawing characters with `┌`, `─`, and `│`
                    6. Minimalist dotted frame with `.`, `:`, and `.`
                Default is `2` (frame with rounded corners).

        Returns:
            str: The full absolute path of the file written.

        Raises:
            FileExistsError: If the file already exists and overwrite is False.
        &#34;&#34;&#34;
        # Resolve full path
        full_path = os.path.abspath(file)
        if os.path.exists(full_path) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{full_path}&#39; already exists. Use overwrite=True to overwrite it.&#34;)
        if os.path.exists(full_path) and overwrite and verbose:
            print(f&#34;Warning: Overwriting the existing file &#39;{full_path}&#39;.&#34;)
        # Generate the script and write to the file
        cmd = self.do(printflag=printflag, verbose=verbose)
        with open(full_path, &#34;w&#34;) as f:
            print(self.header(verbosity=verbose, style=style), &#34;\n&#34;, file=f)
            print(cmd, file=f)
        # Return the full path of the written file
        return full_path

    def tmpwrite(self, verbose=False, style=1):
        &#34;&#34;&#34;
        Write the script to a temporary file and create optional persistent copies.

        Parameters:
            verbose (bool, optional): Controls verbosity during script generation. Defaults to False.

        The method:
            - Creates a temporary file for the script, with platform-specific behavior:
                - On Windows (`os.name == &#39;nt&#39;`), the file is not automatically deleted.
                - On other systems, the file is temporary and deleted upon closure.
            - Writes a header and the script content into the temporary file.
            - Optionally creates a persistent copy in the `self.persistentfolder` directory:
                - `script.preview.&lt;suffix&gt;`: A persistent copy of the temporary file.
                - `script.preview.clean.&lt;suffix&gt;`: A clean copy with comments and empty lines removed.
            - Handles cleanup and exceptions gracefully to avoid leaving orphaned files.
            - style (int, optional):
                Defines the ASCII frame style for the header.
                Valid values are integers from 1 to 6, corresponding to predefined styles:
                    1. Basic box with `+`, `-`, and `|`
                    2. Double-line frame with `╔`, `═`, and `║`
                    3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                    4. Thick outer frame with `#`, `=`, and `#`
                    5. Box drawing characters with `┌`, `─`, and `│`
                    6. Minimalist dotted frame with `.`, `:`, and `.`
                Default is `1` (basic box).

        Returns:
            TemporaryFile: The temporary file handle (non-Windows systems only).
            None: On Windows, the file is closed and not returned.

        Raises:
            Exception: If there is an error creating or writing to the temporary file.
        &#34;&#34;&#34;
        try:
            # OS-specific temporary file behavior
            if os.name == &#39;nt&#39;:  # Windows
                ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;, delete=False)
            else:  # Other platforms
                ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;)

            # Generate header and content
            header = (
                f&#34;# TEMPORARY PIZZA.SCRIPT FILE\n&#34;
                f&#34;# {&#39;-&#39; * 40}\n&#34;
                f&#34;{self.header(verbosity=verbose, style=style)}&#34;
            )
            content = (
                header
                + &#34;\n# This is a temporary file (it will be deleted automatically)\n\n&#34;
                + self.do(printflag=False, verbose=verbose)
            )

            # Write content to the temporary file
            ftmp.write(BOM_UTF8 + content.encode(&#39;utf-8&#39;))
            ftmp.seek(0)  # Reset file pointer to the beginning

        except Exception as e:
            # Handle errors gracefully
            ftmp.close()
            os.remove(ftmp.name)  # Clean up the temporary file
            raise Exception(f&#34;Failed to write to or handle the temporary file: {e}&#34;) from None

        print(&#34;\nTemporary File Header:\n&#34;, header, &#34;\n&#34;)
        print(&#34;A temporary file has been generated here:\n&#34;, ftmp.name)

        # Persistent copy creation
        if self.persistentfile:
            ftmpname = os.path.basename(ftmp.name)
            fcopyname = os.path.join(self.persistentfolder, f&#34;script.preview.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
            copyfile(ftmp.name, fcopyname)
            print(&#34;A persistent copy has been created here:\n&#34;, fcopyname)

            # Create a clean copy without empty lines or comments
            with open(ftmp.name, &#34;r&#34;) as f:
                lines = f.readlines()
            bom_utf8_str = BOM_UTF8.decode(&#34;utf-8&#34;)
            clean_lines = [
                line for line in lines
                if line.strip() and not line.lstrip().startswith(&#34;#&#34;) and not line.startswith(bom_utf8_str)
            ]
            fcleanname = os.path.join(self.persistentfolder, f&#34;script.preview.clean.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
            with open(fcleanname, &#34;w&#34;) as f:
                f.writelines(clean_lines)
            print(&#34;A clean copy has been created here:\n&#34;, fcleanname)

            # Handle file closure for Windows
            if os.name == &#39;nt&#39;:
                ftmp.close()
                return None
            else:
                return ftmp


    # Note that it was not the original intent to copy scripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo))
        return copie


    def detect_variables(self, with_index=False, only_indexed=False):
        &#34;&#34;&#34;
        Detects variables in the content of the template using an extended pattern
        to include indexed variables (e.g., ${var[i]}) if `with_index` is True.

        Parameters:
        -----------
        with_index : bool, optional
            If True, include indexed variables with their indices (e.g., ${var[i]}). Default is False.
        only_indexed : bool, optional
            If True, target only variables that are used with an index (e.g., ${var[i]}). Default is False.

        Returns:
        --------
        list
            A list of unique variable names detected in the content based on the flags.
        &#34;&#34;&#34;
        # Regular expression to match variables with optional indexing
        variable_pattern = re.compile(r&#39;\$\{(\w+)(\[\w+\])?\}&#39;)
        # Ensure TEMPLATE is iterable (split string into lines if needed)
        if isinstance(self.TEMPLATE, str):
            lines = self.TEMPLATE.splitlines()  # Split string into lines
        elif isinstance(self.TEMPLATE, list):
            lines = self.TEMPLATE
        else:
            raise TypeError(&#34;TEMPLATE must be a string or a list of strings.&#34;)
        # Detect variables from all lines
        detected_vars = set()
        for line in lines:
            matches = variable_pattern.findall(line)
            for match in matches:
                variable_name = match[0]  # Base variable name
                index = match[1]          # Optional index (e.g., &#39;[i]&#39;)
                if only_indexed and not index:
                    continue  # Skip non-indexed variables if targeting only indexed ones
                if with_index and index:
                    detected_vars.add(f&#34;{variable_name}{index}&#34;)  # Include the full indexed variable
                elif not with_index:
                    detected_vars.add(variable_name)  # Include only the base variable

        # Return the list of unique variables
        return list(detected_vars)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="script.boundarysection" href="#script.boundarysection">boundarysection</a></li>
<li><a title="script.discretizationsection" href="#script.discretizationsection">discretizationsection</a></li>
<li><a title="script.dumpsection" href="#script.dumpsection">dumpsection</a></li>
<li><a title="script.geometrysection" href="#script.geometrysection">geometrysection</a></li>
<li><a title="script.globalsection" href="#script.globalsection">globalsection</a></li>
<li><a title="script.initializesection" href="#script.initializesection">initializesection</a></li>
<li><a title="script.integrationsection" href="#script.integrationsection">integrationsection</a></li>
<li><a title="script.interactionsection" href="#script.interactionsection">interactionsection</a></li>
<li><a title="script.runsection" href="#script.runsection">runsection</a></li>
<li><a title="script.statussection" href="#script.statussection">statussection</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.script.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.email"><code class="name">var <span class="ident">email</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.license"><code class="name">var <span class="ident">license</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.script.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="script.script.printheader"><code class="name flex">
<span>def <span class="ident">printheader</span></span>(<span>txt, align='^', width=80, filler='~')</span>
</code></dt>
<dd>
<div class="desc"><p>print header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
    &#34;&#34;&#34; print header &#34;&#34;&#34;
    if txt==&#34;&#34;:
        print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
    else:
        print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="script.script.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"><p>convert section index into a role (section name)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def role(self):
    &#34;&#34;&#34; convert section index into a role (section name) &#34;&#34;&#34;
    if self.section in range(len(self.SECTIONS)):
        return self.SECTIONS[self.section]
    else:
        return &#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="script.script.detect_variables"><code class="name flex">
<span>def <span class="ident">detect_variables</span></span>(<span>self, with_index=False, only_indexed=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects variables in the content of the template using an extended pattern
to include indexed variables (e.g., ${var[i]}) if <code>with_index</code> is True.</p>
<h2 id="parameters">Parameters:</h2>
<p>with_index : bool, optional
If True, include indexed variables with their indices (e.g., ${var[i]}). Default is False.
only_indexed : bool, optional
If True, target only variables that are used with an index (e.g., ${var[i]}). Default is False.</p>
<h2 id="returns">Returns:</h2>
<p>list
A list of unique variable names detected in the content based on the flags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_variables(self, with_index=False, only_indexed=False):
    &#34;&#34;&#34;
    Detects variables in the content of the template using an extended pattern
    to include indexed variables (e.g., ${var[i]}) if `with_index` is True.

    Parameters:
    -----------
    with_index : bool, optional
        If True, include indexed variables with their indices (e.g., ${var[i]}). Default is False.
    only_indexed : bool, optional
        If True, target only variables that are used with an index (e.g., ${var[i]}). Default is False.

    Returns:
    --------
    list
        A list of unique variable names detected in the content based on the flags.
    &#34;&#34;&#34;
    # Regular expression to match variables with optional indexing
    variable_pattern = re.compile(r&#39;\$\{(\w+)(\[\w+\])?\}&#39;)
    # Ensure TEMPLATE is iterable (split string into lines if needed)
    if isinstance(self.TEMPLATE, str):
        lines = self.TEMPLATE.splitlines()  # Split string into lines
    elif isinstance(self.TEMPLATE, list):
        lines = self.TEMPLATE
    else:
        raise TypeError(&#34;TEMPLATE must be a string or a list of strings.&#34;)
    # Detect variables from all lines
    detected_vars = set()
    for line in lines:
        matches = variable_pattern.findall(line)
        for match in matches:
            variable_name = match[0]  # Base variable name
            index = match[1]          # Optional index (e.g., &#39;[i]&#39;)
            if only_indexed and not index:
                continue  # Skip non-indexed variables if targeting only indexed ones
            if with_index and index:
                detected_vars.add(f&#34;{variable_name}{index}&#34;)  # Include the full indexed variable
            elif not with_index:
                detected_vars.add(variable_name)  # Include only the base variable

    # Return the list of unique variables
    return list(detected_vars)</code></pre>
</details>
</dd>
<dt id="script.script.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, printflag=None, verbose=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the LAMMPS script based on the current configuration.</p>
<pre><code>    This method generates a LAMMPS-compatible script from the templates and definitions
    stored in the &lt;code&gt;&lt;a title="script.script" href="#script.script"&gt;script&lt;/a&gt;&lt;/code&gt; object. The generated script can be displayed, returned,
    and optionally include comments for debugging or clarity.

    Parameters:
    -----------
    - printflag (bool, optional): If True, the generated script is printed to the console.
                                  Default is True.
    - verbose (bool, optional): If True, comments and additional information are included
                                in the generated script. If False, comments are removed.
                                Default is True.

    Returns:
    ---------
    - str: The generated LAMMPS script.

    Method Behavior:
    - The method first collects all key-value pairs from &lt;code&gt;DEFINITIONS&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; objects,
      which store the configuration data for the script.
    - Lists and tuples in the collected data are formatted into a readable string with proper
      separators (space for lists, comma for tuples) and prefixed with a '%' to indicate comments.
    - The generated command template is formatted and evaluated using the collected data.
    - If &lt;code&gt;verbose&lt;/code&gt; is set to False, comments in the generated script are removed.
    - The script is then printed if &lt;code&gt;printflag&lt;/code&gt; is True.
    - Finally, the formatted script is returned as a string.


    Example Usage:
    --------------
    &gt;&gt;&gt; s = script()
    &gt;&gt;&gt; s.do(printflag=True, verbose=True)
    units           si
    dimension       3
    boundary        f f f
    # Additional script commands...

    &gt;&gt;&gt; s.do(printflag=False, verbose=False)
    'units si
</code></pre>
<p>dimension 3
boundary f f f</p>
<h1 id="additional-script-commands">Additional script commands&hellip;'</h1>
<pre><code>    Notes:
    - Comments are indicated in the script with '%' or '#'.
    - The [position {self.position}:{self.userid}] marker is inserted for tracking
      script sections or modifications.


    Known Issues for indexed variables
    ----------------------------------
    List and tupples used indexed in templates, such as varlist[1], are not converted into strings so that
    each element can be considered as a variable and accessed as ${varlist[1]}. If varlist is also used in
    full, such as ${varlist}. Then it is preferable to define varlist as a string:
        "![v1,v2,...]" where v1,v2,v3 can be int, float, static str or evaluable str (i.e., subjected to nested
         evaluation).
    The control character ! in lists, such as in var=![v1,v2,v3] preserves the Pythonic definition by do()
    at later stages during the evaluation so that its content can be indexed.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self,printflag=None,verbose=None):
    &#34;&#34;&#34;
    Generate the LAMMPS script based on the current configuration.

    This method generates a LAMMPS-compatible script from the templates and definitions
    stored in the `script` object. The generated script can be displayed, returned,
    and optionally include comments for debugging or clarity.

    Parameters:
    -----------
    - printflag (bool, optional): If True, the generated script is printed to the console.
                                  Default is True.
    - verbose (bool, optional): If True, comments and additional information are included
                                in the generated script. If False, comments are removed.
                                Default is True.

    Returns:
    ---------
    - str: The generated LAMMPS script.

    Method Behavior:
    - The method first collects all key-value pairs from `DEFINITIONS` and `USER` objects,
      which store the configuration data for the script.
    - Lists and tuples in the collected data are formatted into a readable string with proper
      separators (space for lists, comma for tuples) and prefixed with a &#39;%&#39; to indicate comments.
    - The generated command template is formatted and evaluated using the collected data.
    - If `verbose` is set to False, comments in the generated script are removed.
    - The script is then printed if `printflag` is True.
    - Finally, the formatted script is returned as a string.


    Example Usage:
    --------------
    &gt;&gt;&gt; s = script()
    &gt;&gt;&gt; s.do(printflag=True, verbose=True)
    units           si
    dimension       3
    boundary        f f f
    # Additional script commands...

    &gt;&gt;&gt; s.do(printflag=False, verbose=False)
    &#39;units si\ndimension 3\nboundary f f f\n# Additional script commands...&#39;

    Notes:
    - Comments are indicated in the script with &#39;%&#39; or &#39;#&#39;.
    - The [position {self.position}:{self.userid}] marker is inserted for tracking
      script sections or modifications.


    Known Issues for indexed variables
    ----------------------------------
    List and tupples used indexed in templates, such as varlist[1], are not converted into strings so that
    each element can be considered as a variable and accessed as ${varlist[1]}. If varlist is also used in
    full, such as ${varlist}. Then it is preferable to define varlist as a string:
        &#34;![v1,v2,...]&#34; where v1,v2,v3 can be int, float, static str or evaluable str (i.e., subjected to nested
         evaluation).
    The control character ! in lists, such as in var=![v1,v2,v3] preserves the Pythonic definition by do()
    at later stages during the evaluation so that its content can be indexed.

    &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = self.verbose if verbose is None else verbose
    inputs = self.DEFINITIONS + self.USER
    usedvariables = self.detect_variables(with_index=False,only_indexed=False)
    variables_used_with_index = self.detect_variables(with_index=False,only_indexed=True)
    usedvariables_withoutindex = [ var for var in usedvariables if var not in variables_used_with_index ]
    for k in inputs.keys():
        if k in usedvariables_withoutindex:
            if isinstance(inputs.getattr(k),list):
                inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k)))
            elif isinstance(inputs.getattr(k),tuple):
                inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k),sep=&#34;,&#34;))
    cmd = inputs.formateval(self.TEMPLATE)
    cmd = cmd.replace(&#34;[comment]&#34;,f&#34;[position {self.position}:{self.userid}]&#34;)
    if not verbose: cmd=remove_comments(cmd)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="script.script.getallattributes"><code class="name flex">
<span>def <span class="ident">getallattributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>advanced method to get all attributes including class ones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getallattributes(self):
    &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
    return {k: getattr(self, k) for k in dir(self) \
            if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}</code></pre>
</details>
</dd>
<dt id="script.script.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self, verbose=True, verbosity=None, style=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a formatted header for the script file.</p>
<h2 id="parameters">Parameters</h2>
<p>verbosity (bool, optional): If specified, overrides the instance's <code>verbose</code> setting.
Defaults to the instance's <code>verbose</code>.
style (int from 1 to 6, optional): ASCII style to frame the header (default=2)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representing the script's metadata and initialization details.
Returns an empty string if verbosity is False.</dd>
</dl>
<p>The header includes:
- Script version, license, and contact email.
- User ID and the number of initialized definitions.
- Current system user, hostname, and working directory.
- Persistent filename and folder path.
- Timestamp of the header generation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self, verbose=True, verbosity=None, style=2):
    &#34;&#34;&#34;
    Generate a formatted header for the script file.

    Parameters:
        verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                    Defaults to the instance&#39;s `verbose`.
        style (int from 1 to 6, optional): ASCII style to frame the header (default=2)

    Returns:
        str: A formatted string representing the script&#39;s metadata and initialization details.
             Returns an empty string if verbosity is False.

    The header includes:
        - Script version, license, and contact email.
        - User ID and the number of initialized definitions.
        - Current system user, hostname, and working directory.
        - Persistent filename and folder path.
        - Timestamp of the header generation.
    &#34;&#34;&#34;
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    if not verbose:
        return &#34;&#34;
    # Prepare the header content
    lines = [
        f&#34;PIZZA.SCRIPT FILE v{script.version} | License: {script.license} | Email: {script.email}&#34;,
        &#34;&#34;,
        f&#34;&lt;{str(self)}&gt;&#34;,
        f&#34;Initialized with {len(self.USER)} definitions | Verbosity: {verbosity}&#34;,
        f&#34;Persistent file: \&#34;{self.persistentfile}\&#34; | Folder: \&#34;{self.persistentfolder}\&#34;&#34;,
        &#34;&#34;,
        f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
        f&#34;{datetime.datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
    ]
    # Use the shared method to format the header
    return frame_header(lines,style=style)</code></pre>
</details>
</dd>
<dt id="script.script.tmpwrite"><code class="name flex">
<span>def <span class="ident">tmpwrite</span></span>(<span>self, verbose=False, style=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the script to a temporary file and create optional persistent copies.</p>
<h2 id="parameters">Parameters</h2>
<p>verbose (bool, optional): Controls verbosity during script generation. Defaults to False.</p>
<p>The method:
- Creates a temporary file for the script, with platform-specific behavior:
- On Windows (<code>os.name == 'nt'</code>), the file is not automatically deleted.
- On other systems, the file is temporary and deleted upon closure.
- Writes a header and the script content into the temporary file.
- Optionally creates a persistent copy in the <code>self.persistentfolder</code> directory:
- <code>script.preview.&lt;suffix&gt;</code>: A persistent copy of the temporary file.
- <code>script.preview.clean.&lt;suffix&gt;</code>: A clean copy with comments and empty lines removed.
- Handles cleanup and exceptions gracefully to avoid leaving orphaned files.
- style (int, optional):
Defines the ASCII frame style for the header.
Valid values are integers from 1 to 6, corresponding to predefined styles:
1. Basic box with <code>+</code>, <code>-</code>, and <code>|</code>
2. Double-line frame with <code>╔</code>, <code>═</code>, and <code>║</code>
3. Rounded corners with <code>.</code>, <code>'</code>, <code>-</code>, and <code>|</code>
4. Thick outer frame with <code>#</code>, <code>=</code>, and <code>#</code>
5. Box drawing characters with <code>┌</code>, <code>─</code>, and <code>│</code>
6. Minimalist dotted frame with <code>.</code>, <code>:</code>, and <code>.</code>
Default is <code>1</code> (basic box).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TemporaryFile</code></dt>
<dd>The temporary file handle (non-Windows systems only).</dd>
<dt><code>None</code></dt>
<dd>On Windows, the file is closed and not returned.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If there is an error creating or writing to the temporary file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tmpwrite(self, verbose=False, style=1):
    &#34;&#34;&#34;
    Write the script to a temporary file and create optional persistent copies.

    Parameters:
        verbose (bool, optional): Controls verbosity during script generation. Defaults to False.

    The method:
        - Creates a temporary file for the script, with platform-specific behavior:
            - On Windows (`os.name == &#39;nt&#39;`), the file is not automatically deleted.
            - On other systems, the file is temporary and deleted upon closure.
        - Writes a header and the script content into the temporary file.
        - Optionally creates a persistent copy in the `self.persistentfolder` directory:
            - `script.preview.&lt;suffix&gt;`: A persistent copy of the temporary file.
            - `script.preview.clean.&lt;suffix&gt;`: A clean copy with comments and empty lines removed.
        - Handles cleanup and exceptions gracefully to avoid leaving orphaned files.
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with `╔`, `═`, and `║`
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with `┌`, `─`, and `│`
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `1` (basic box).

    Returns:
        TemporaryFile: The temporary file handle (non-Windows systems only).
        None: On Windows, the file is closed and not returned.

    Raises:
        Exception: If there is an error creating or writing to the temporary file.
    &#34;&#34;&#34;
    try:
        # OS-specific temporary file behavior
        if os.name == &#39;nt&#39;:  # Windows
            ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;, delete=False)
        else:  # Other platforms
            ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;)

        # Generate header and content
        header = (
            f&#34;# TEMPORARY PIZZA.SCRIPT FILE\n&#34;
            f&#34;# {&#39;-&#39; * 40}\n&#34;
            f&#34;{self.header(verbosity=verbose, style=style)}&#34;
        )
        content = (
            header
            + &#34;\n# This is a temporary file (it will be deleted automatically)\n\n&#34;
            + self.do(printflag=False, verbose=verbose)
        )

        # Write content to the temporary file
        ftmp.write(BOM_UTF8 + content.encode(&#39;utf-8&#39;))
        ftmp.seek(0)  # Reset file pointer to the beginning

    except Exception as e:
        # Handle errors gracefully
        ftmp.close()
        os.remove(ftmp.name)  # Clean up the temporary file
        raise Exception(f&#34;Failed to write to or handle the temporary file: {e}&#34;) from None

    print(&#34;\nTemporary File Header:\n&#34;, header, &#34;\n&#34;)
    print(&#34;A temporary file has been generated here:\n&#34;, ftmp.name)

    # Persistent copy creation
    if self.persistentfile:
        ftmpname = os.path.basename(ftmp.name)
        fcopyname = os.path.join(self.persistentfolder, f&#34;script.preview.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
        copyfile(ftmp.name, fcopyname)
        print(&#34;A persistent copy has been created here:\n&#34;, fcopyname)

        # Create a clean copy without empty lines or comments
        with open(ftmp.name, &#34;r&#34;) as f:
            lines = f.readlines()
        bom_utf8_str = BOM_UTF8.decode(&#34;utf-8&#34;)
        clean_lines = [
            line for line in lines
            if line.strip() and not line.lstrip().startswith(&#34;#&#34;) and not line.startswith(bom_utf8_str)
        ]
        fcleanname = os.path.join(self.persistentfolder, f&#34;script.preview.clean.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
        with open(fcleanname, &#34;w&#34;) as f:
            f.writelines(clean_lines)
        print(&#34;A clean copy has been created here:\n&#34;, fcleanname)

        # Handle file closure for Windows
        if os.name == &#39;nt&#39;:
            ftmp.close()
            return None
        else:
            return ftmp</code></pre>
</details>
</dd>
<dt id="script.script.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, printflag=True, verbose=False, overwrite=False, style=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the script to a file.</p>
<h2 id="parameters">Parameters</h2>
<ul>
<li>file (str): The file path where the script will be saved.</li>
<li>printflag (bool): Flag to enable/disable printing of details.</li>
<li>verbose (bool): Flag to enable/disable verbose mode.</li>
<li>overwrite (bool): Whether to overwrite the file if it already exists.</li>
<li>style (int, optional):
Defines the ASCII frame style for the header.
Valid values are integers from 1 to 6, corresponding to predefined styles:
1. Basic box with <code>+</code>, <code>-</code>, and <code>|</code>
2. Double-line frame with <code>╔</code>, <code>═</code>, and <code>║</code>
3. Rounded corners with <code>.</code>, <code>'</code>, <code>-</code>, and <code>|</code>
4. Thick outer frame with <code>#</code>, <code>=</code>, and <code>#</code>
5. Box drawing characters with <code>┌</code>, <code>─</code>, and <code>│</code>
6. Minimalist dotted frame with <code>.</code>, <code>:</code>, and <code>.</code>
Default is <code>2</code> (frame with rounded corners).</li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The full absolute path of the file written.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and overwrite is False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, printflag=True, verbose=False, overwrite=False, style=2):
    &#34;&#34;&#34;
    Write the script to a file.

    Parameters:
        - file (str): The file path where the script will be saved.
        - printflag (bool): Flag to enable/disable printing of details.
        - verbose (bool): Flag to enable/disable verbose mode.
        - overwrite (bool): Whether to overwrite the file if it already exists.
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with `╔`, `═`, and `║`
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with `┌`, `─`, and `│`
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `2` (frame with rounded corners).

    Returns:
        str: The full absolute path of the file written.

    Raises:
        FileExistsError: If the file already exists and overwrite is False.
    &#34;&#34;&#34;
    # Resolve full path
    full_path = os.path.abspath(file)
    if os.path.exists(full_path) and not overwrite:
        raise FileExistsError(f&#34;The file &#39;{full_path}&#39; already exists. Use overwrite=True to overwrite it.&#34;)
    if os.path.exists(full_path) and overwrite and verbose:
        print(f&#34;Warning: Overwriting the existing file &#39;{full_path}&#39;.&#34;)
    # Generate the script and write to the file
    cmd = self.do(printflag=printflag, verbose=verbose)
    with open(full_path, &#34;w&#34;) as f:
        print(self.header(verbosity=verbose, style=style), &#34;\n&#34;, file=f)
        print(cmd, file=f)
    # Return the full path of the written file
    return full_path</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="script.scriptdata"><code class="flex name class">
<span>class <span class="ident">scriptdata</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>class of script parameters
Typical constructor:
DEFINITIONS = scriptdata(
var1 = value1,
var2 = value2
)
See script, struct, param to get review all methods attached to it</p>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scriptdata(param):
    &#34;&#34;&#34;
        class of script parameters
            Typical constructor:
                DEFINITIONS = scriptdata(
                    var1 = value1,
                    var2 = value2
                    )
        See script, struct, param to get review all methods attached to it
    &#34;&#34;&#34;
    _type = &#34;SD&#34;
    _fulltype = &#34;script data&#34;
    _ftype = &#34;definition&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="script.scriptobject"><code class="flex name class">
<span>class <span class="ident">scriptobject</span></span>
<span>(</span><span>beadtype=1, name=None, fullname='', filename='', style='smd', mass=1.0, forcefield=LAMMPS:SMD:none:walls, group=[], USER=script data (SD object) with 0 definitions)</span>
</code></dt>
<dd>
<div class="desc"><p>scriptobject: A Class for Managing Script Objects in LAMMPS</p>
<p>The <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> class is designed to represent individual objects in LAMMPS scripts,
such as beads, atoms, or other components. Each object is associated with a <code><a title="script.forcefield" href="#script.forcefield">forcefield</a></code>
instance that defines the physical interactions of the object, and the class supports
a variety of properties for detailed object definition. Additionally, <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code>
instances can be grouped together and compared based on their properties, such as
<code>beadtype</code> and <code>name</code>.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Forcefield Integration</strong>: Each <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> is associated with a <code><a title="script.forcefield" href="#script.forcefield">forcefield</a></code>
instance, allowing for customized physical interactions. Forcefields can be passed
via the <code>USER</code> keyword for dynamic parameterization.</li>
<li><strong>Grouping</strong>: Multiple <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances can be combined into a
<code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code> using the <code>+</code> operator, allowing for complex collections of objects.</li>
<li><strong>Object Comparison</strong>: <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances can be compared and sorted based on
their <code>beadtype</code> and <code>name</code>, enabling efficient organization and manipulation of objects.</li>
<li><strong>Piping and Execution</strong>: Supports the pipe (<code>|</code>) operator, allowing <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code>
instances to be used in script pipelines alongside other script elements.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>Object Definition in LAMMPS</strong>: Use <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> to represent individual objects in
a simulation, including their properties and associated forcefields.</li>
<li><strong>Forcefield Parameterization</strong>: Pass customized parameters to the forcefield via the
<code>USER</code> keyword to dynamically adjust the physical interactions.</li>
<li><strong>Grouping and Sorting</strong>: Combine multiple objects into groups, or sort them based
on their properties (e.g., <code>beadtype</code>) for easier management in complex simulations.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, beadtype=1, name="undefined", fullname="", filename="", style="smd",
forcefield=rigidwall(), group=[], USER=scriptdata()):
Initializes a new <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> with the specified properties, including <code>beadtype</code>,
<code>name</code>, <code><a title="script.forcefield" href="#script.forcefield">forcefield</a></code>, and optional <code>group</code>.</p>
<p><strong>str</strong>(self):
Returns a string representation of the <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code>, showing its <code>beadtype</code> and <code>name</code>.</p>
<p><strong>add</strong>(self, SO):
Combines two <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances or a <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> with a <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code>.
Raises an error if the two objects have the same <code>name</code> or if the second operand is not
a valid <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> or <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code>.</p>
<p><strong>or</strong>(self, pipe):
Overloads the pipe (<code>|</code>) operator to integrate the <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> into a pipeline.</p>
<p><strong>eq</strong>(self, SO):
Compares two <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances, returning <code>True</code> if they have the same
<code>beadtype</code> and <code>name</code>.</p>
<p><strong>ne</strong>(self, SO):
Returns <code>True</code> if the two <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances differ in either <code>beadtype</code> or <code>name</code>.</p>
<p><strong>lt</strong>(self, SO):
Compares the <code>beadtype</code> of two <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances, returning <code>True</code> if the
left object's <code>beadtype</code> is less than the right object's.</p>
<p><strong>gt</strong>(self, SO):
Compares the <code>beadtype</code> of two <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances, returning <code>True</code> if the
left object's <code>beadtype</code> is greater than the right object's.</p>
<p><strong>le</strong>(self, SO):
Returns <code>True</code> if the <code>beadtype</code> of the left <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> is less than or equal to
the right <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code>.</p>
<p><strong>ge</strong>(self, SO):
Returns <code>True</code> if the <code>beadtype</code> of the left <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> is greater than or equal
to the right <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code>.</p>
<h2 id="attributes">Attributes:</h2>
<p>beadtype : int
The type of bead or object, used for distinguishing between different types in the simulation.
name : str
A short name for the object, useful for quick identification.
fullname : str
A comprehensive name for the object. If not provided, defaults to the <code>name</code> with "object definition".
filename : str
The path to the file containing the input data for the object.
style : str
The style of the object (e.g., "smd" for smoothed dynamics).
forcefield : forcefield
The forcefield instance associated with the object, defining its physical interactions.
group : list
A list of other <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances that are grouped with this object.
USER : scriptdata
A collection of user-defined variables for customizing the forcefield or other properties.</p>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> class enables the definition of objects within LAMMPS scripts, providing:
- <strong>Beadtype and Naming</strong>: Objects are distinguished by their <code>beadtype</code> and <code>name</code>, allowing
for comparison and sorting based on these properties.
- <strong>Forcefield Support</strong>: Objects are linked to a forcefield instance, and user-defined forcefield
parameters can be passed through the <code>USER</code> keyword.
- <strong>Group Management</strong>: Multiple objects can be grouped together using the <code>+</code> operator, forming
a <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code>.
- <strong>Comparison Operators</strong>: Objects can be compared based on their <code>beadtype</code> and <code>name</code>, using
standard comparison operators (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, etc.).
- <strong>Pipelines</strong>: <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances can be integrated into pipelines, supporting the <code>|</code>
operator for use in sequential script execution.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>from pizza.scriptobject import scriptobject, rigidwall, scriptdata

# Define a script object with custom properties
obj1 = scriptobject(beadtype=1, name=&quot;bead1&quot;, forcefield=rigidwall(USER=scriptdata(param1=10)))

# Combine two objects into a group
obj2 = scriptobject(beadtype=2, name=&quot;bead2&quot;)
group = obj1 + obj2

# Print object information
print(obj1)
print(group)
</code></pre>
<p>The output will be:</p>
<pre><code>script object | type=1 | name=bead1
scriptobjectgroup containing 2 objects
</code></pre>
<h2 id="overview">Overview</h2>
<pre><code>class of script object
    OBJ = scriptobject(...)
    Implemented properties:
        beadtype=1,2,...
        name="short name"
        fullname = "comprehensive name"
        filename = "/path/to/your/inputfile"
        style = "smd"
        forcefield = any valid forcefield instance (default = rigidwall())
        mass = 1.0

note: use a forcefield instance with the keywork USER to pass user FF parameters
examples:   rigidwall(USER=scriptdata(...))
            solidfood(USER==scriptdata(...))
            water(USER==scriptdata(...))

group objects with OBJ1+OBJ2... into scriptobjectgroups

objects can be compared and sorted based on beadtype and name
</code></pre>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scriptobject(struct):
    &#34;&#34;&#34;
    scriptobject: A Class for Managing Script Objects in LAMMPS

    The `scriptobject` class is designed to represent individual objects in LAMMPS scripts,
    such as beads, atoms, or other components. Each object is associated with a `forcefield`
    instance that defines the physical interactions of the object, and the class supports
    a variety of properties for detailed object definition. Additionally, `scriptobject`
    instances can be grouped together and compared based on their properties, such as
    `beadtype` and `name`.

    Key Features:
    -------------
    - **Forcefield Integration**: Each `scriptobject` is associated with a `forcefield`
      instance, allowing for customized physical interactions. Forcefields can be passed
      via the `USER` keyword for dynamic parameterization.
    - **Grouping**: Multiple `scriptobject` instances can be combined into a
      `scriptobjectgroup` using the `+` operator, allowing for complex collections of objects.
    - **Object Comparison**: `scriptobject` instances can be compared and sorted based on
      their `beadtype` and `name`, enabling efficient organization and manipulation of objects.
    - **Piping and Execution**: Supports the pipe (`|`) operator, allowing `scriptobject`
      instances to be used in script pipelines alongside other script elements.

    Practical Use Cases:
    --------------------
    - **Object Definition in LAMMPS**: Use `scriptobject` to represent individual objects in
      a simulation, including their properties and associated forcefields.
    - **Forcefield Parameterization**: Pass customized parameters to the forcefield via the
      `USER` keyword to dynamically adjust the physical interactions.
    - **Grouping and Sorting**: Combine multiple objects into groups, or sort them based
      on their properties (e.g., `beadtype`) for easier management in complex simulations.

    Methods:
    --------
    __init__(self, beadtype=1, name=&#34;undefined&#34;, fullname=&#34;&#34;, filename=&#34;&#34;, style=&#34;smd&#34;,
             forcefield=rigidwall(), group=[], USER=scriptdata()):
        Initializes a new `scriptobject` with the specified properties, including `beadtype`,
        `name`, `forcefield`, and optional `group`.

    __str__(self):
        Returns a string representation of the `scriptobject`, showing its `beadtype` and `name`.

    __add__(self, SO):
        Combines two `scriptobject` instances or a `scriptobject` with a `scriptobjectgroup`.
        Raises an error if the two objects have the same `name` or if the second operand is not
        a valid `scriptobject` or `scriptobjectgroup`.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the `scriptobject` into a pipeline.

    __eq__(self, SO):
        Compares two `scriptobject` instances, returning `True` if they have the same
        `beadtype` and `name`.

    __ne__(self, SO):
        Returns `True` if the two `scriptobject` instances differ in either `beadtype` or `name`.

    __lt__(self, SO):
        Compares the `beadtype` of two `scriptobject` instances, returning `True` if the
        left object&#39;s `beadtype` is less than the right object&#39;s.

    __gt__(self, SO):
        Compares the `beadtype` of two `scriptobject` instances, returning `True` if the
        left object&#39;s `beadtype` is greater than the right object&#39;s.

    __le__(self, SO):
        Returns `True` if the `beadtype` of the left `scriptobject` is less than or equal to
        the right `scriptobject`.

    __ge__(self, SO):
        Returns `True` if the `beadtype` of the left `scriptobject` is greater than or equal
        to the right `scriptobject`.

    Attributes:
    -----------
    beadtype : int
        The type of bead or object, used for distinguishing between different types in the simulation.
    name : str
        A short name for the object, useful for quick identification.
    fullname : str
        A comprehensive name for the object. If not provided, defaults to the `name` with &#34;object definition&#34;.
    filename : str
        The path to the file containing the input data for the object.
    style : str
        The style of the object (e.g., &#34;smd&#34; for smoothed dynamics).
    forcefield : forcefield
        The forcefield instance associated with the object, defining its physical interactions.
    group : list
        A list of other `scriptobject` instances that are grouped with this object.
    USER : scriptdata
        A collection of user-defined variables for customizing the forcefield or other properties.

    Original Content:
    -----------------
    The `scriptobject` class enables the definition of objects within LAMMPS scripts, providing:
    - **Beadtype and Naming**: Objects are distinguished by their `beadtype` and `name`, allowing
      for comparison and sorting based on these properties.
    - **Forcefield Support**: Objects are linked to a forcefield instance, and user-defined forcefield
      parameters can be passed through the `USER` keyword.
    - **Group Management**: Multiple objects can be grouped together using the `+` operator, forming
      a `scriptobjectgroup`.
    - **Comparison Operators**: Objects can be compared based on their `beadtype` and `name`, using
      standard comparison operators (`==`, `&lt;`, `&gt;`, etc.).
    - **Pipelines**: `scriptobject` instances can be integrated into pipelines, supporting the `|`
      operator for use in sequential script execution.

    Example Usage:
    --------------
    ```
    from pizza.scriptobject import scriptobject, rigidwall, scriptdata

    # Define a script object with custom properties
    obj1 = scriptobject(beadtype=1, name=&#34;bead1&#34;, forcefield=rigidwall(USER=scriptdata(param1=10)))

    # Combine two objects into a group
    obj2 = scriptobject(beadtype=2, name=&#34;bead2&#34;)
    group = obj1 + obj2

    # Print object information
    print(obj1)
    print(group)
    ```

    The output will be:
    ```
    script object | type=1 | name=bead1
    scriptobjectgroup containing 2 objects
    ```

    OVERVIEW
    --------------

        class of script object
            OBJ = scriptobject(...)
            Implemented properties:
                beadtype=1,2,...
                name=&#34;short name&#34;
                fullname = &#34;comprehensive name&#34;
                filename = &#34;/path/to/your/inputfile&#34;
                style = &#34;smd&#34;
                forcefield = any valid forcefield instance (default = rigidwall())
                mass = 1.0

        note: use a forcefield instance with the keywork USER to pass user FF parameters
        examples:   rigidwall(USER=scriptdata(...))
                    solidfood(USER==scriptdata(...))
                    water(USER==scriptdata(...))

        group objects with OBJ1+OBJ2... into scriptobjectgroups

        objects can be compared and sorted based on beadtype and name

    &#34;&#34;&#34;
    _type = &#34;SO&#34;
    _fulltype = &#34;script object&#34;
    _ftype = &#34;propertie&#34;

    def __init__(self,
                 beadtype = 1,
                 name = None,
                 fullname=&#34;&#34;,
                 filename=&#34;&#34;,
                 style=&#34;smd&#34;,
                 mass=1.0, # added on 2024-11-29
                 forcefield=rigidwall(),
                 group=[],
                 USER = scriptdata()
                 ):
        name = f&#34;beadtype={beadtype}&#34; if name is None else name
        if not isinstance(name,str):
            TypeError(f&#34;name must a string or None got {type(name)}&#34;)
        if fullname==&#34;&#34;: fullname = name + &#34; object definition&#34;
        if not isinstance(group,list): group = [group]
        forcefield.beadtype = beadtype
        forcefield.userid = name
        forcefield.USER = USER
        super(scriptobject,self).__init__(
              beadtype = beadtype,
                  name = name,
              fullname = fullname,
              filename = filename,
                 style = style,
            forcefield = forcefield,
                  mass = mass,
                 group = group,
                  USER = USER
                 )

    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self._fulltype} | type={self.beadtype} | name={self.name}&#34;

    def __add__(self, SO):
        if isinstance(SO,scriptobject):
            if SO.name != self.name:
                if SO.beadtype == self.beadtype:
                   SO.beadtype =  self.beadtype+1
                return scriptobjectgroup(self,SO)
            else:
                raise ValueError(&#39;the object &#34;%s&#34; already exists&#39; % SO.name)
        elif isinstance(SO,scriptobjectgroup):
            return scriptobjectgroup(self)+SO
        else:
            return ValueError(&#34;The object should a script object or its container&#34;)

    def __or__(self, pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        if isinstance(pipe,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self) | pipe
        else:
            raise ValueError(&#34;the argument must a pipescript, a scriptobject or a scriptobjectgroup&#34;)

    def __eq__(self, SO):
        return isinstance(SO,scriptobject) and (self.beadtype == SO.beadtype) and (self.mass == SO.mass) \
            and (self.name == SO.name)

    def __ne__(self, SO):
        return not isinstance(SO,scriptobject) or (self.beadtype != SO.beadtype) or (self.mass != SO.mass) or (self.name != SO.name)

    def __lt__(self, SO):
        return self.beadtype &lt; SO.beadtype

    def __gt__(self, SO):
        return self.beadtype &gt; SO.beadtype

    def __le__(self, SO):
        return self.beadtype &lt;= SO.beadtype

    def __ge__(self, SO):
        return self.beadtype &gt;= SO.beadtype</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="script.scriptobjectgroup"><code class="flex name class">
<span>class <span class="ident">scriptobjectgroup</span></span>
<span>(</span><span>*SOgroup)</span>
</code></dt>
<dd>
<div class="desc"><p>scriptobjectgroup: A Class for Managing Groups of Script Objects in LAMMPS</p>
<p>The <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code> class is designed to represent a group of <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances,
such as beads or atoms in a simulation. This class allows users to group objects together
based on their properties (e.g., beadtype, name), and provides tools to generate scripts
that define interactions, groups, and forcefields for these objects in LAMMPS.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Group Management</strong>: Objects can be combined into a group, where each <code>beadtype</code> occurs
once. The class ensures that objects are uniquely identified by their <code>beadtype</code> and <code>name</code>.</li>
<li><strong>Dynamic Properties</strong>: The group’s properties (e.g., <code>beadtype</code>, <code>name</code>, <code>groupname</code>)
are dynamically calculated, ensuring that the group reflects the current state of the objects.</li>
<li><strong>Script Generation</strong>: Provides methods to generate scripts based on the group's objects,
including interaction forcefields and group definitions.</li>
<li><strong>Interaction Accumulation</strong>: Automatically accumulates and updates all forcefield
interactions for the objects in the group.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>LAMMPS Group Definitions</strong>: Define groups of objects for use in LAMMPS simulations,
based on properties like <code>beadtype</code> and <code>groupname</code>.</li>
<li><strong>Forcefield Management</strong>: Automatically manage and update interaction forcefields for
objects in the group.</li>
<li><strong>Script Generation</strong>: Generate LAMMPS-compatible scripts that include group definitions,
input file handling, and interaction forcefields.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, *SOgroup):
Initializes a new <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code> with one or more <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances.</p>
<p><strong>str</strong>(self):
Returns a string representation of the <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code>, showing the number of objects
in the group and their <code>beadtypes</code>.</p>
<p><strong>add</strong>(self, SOgroup):
Combines two <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code> instances or a <code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> with an existing group,
ensuring that <code>beadtype</code> values are unique.</p>
<p><strong>or</strong>(self, pipe):
Overloads the pipe (<code>|</code>) operator to integrate the group into a pipeline.</p>
<p>select(self, beadtype=None):
Selects and returns a subset of the group based on the specified <code>beadtype</code>.</p>
<p>script(self, printflag=False, verbosity=2, verbose=None):
Generates a script based on the current collection of objects, including input file
handling, group definitions, and interaction forcefields.</p>
<p>interactions(self, printflag=False, verbosity=2, verbose=None):
Updates and accumulates all forcefields for the objects in the group.</p>
<p>group_generator(self, name=None):
Generates and returns a <code>group</code> object, based on the existing group structure.</p>
<h2 id="properties">Properties:</h2>
<ul>
<li>list : Converts the group into a sorted list of objects.</li>
<li>zip : Returns a sorted list of tuples containing <code>beadtype</code>, <code>name</code>, <code>group</code>, and <code>filename</code>
for each object.</li>
<li>n : Returns the number of objects in the group.</li>
<li>beadtype : Returns a list of the <code>beadtypes</code> for all objects in the group.</li>
<li>name : Returns a list of the <code>names</code> for all objects in the group.</li>
<li>groupname : Returns a list of all group names (synonyms).</li>
<li>filename : Returns a dictionary mapping filenames to the objects that use them.</li>
<li>str : Returns a string representation of the group's <code>beadtypes</code>.</li>
<li>min : Returns the minimum <code>beadtype</code> in the group.</li>
<li>max : Returns the maximum <code>beadtype</code> in the group.</li>
<li>minmax : Returns a tuple of the minimum and maximum <code>beadtypes</code> in the group.</li>
<li>forcefield : Returns the interaction forcefields for the group.</li>
</ul>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code> class enables the collection and management of multiple
<code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code> instances, providing the following functionalities:
- <strong>Group Creation</strong>: Groups are automatically formed by combining individual objects
using the <code>+</code> operator. Each <code>beadtype</code> occurs only once in the group, and errors are
raised if an object with the same <code>name</code> or <code>beadtype</code> already exists.
- <strong>Dynamic Properties</strong>: Properties such as <code>beadtype</code>, <code>name</code>, <code>groupname</code>, and <code>filename</code>
are dynamically calculated, reflecting the current state of the objects.
- <strong>Forcefield Handling</strong>: Forcefields are automatically managed for the objects in the group,
including diagonal and off-diagonal terms for pair interactions.
- <strong>Script Generation</strong>: Scripts are generated to define the interactions, groups, and
input file handling for LAMMPS.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>from pizza.scriptobject import scriptobject, scriptobjectgroup, rigidwall, solidfood, water

# Define some script objects
b1 = scriptobject(name=&quot;bead 1&quot;, group=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], filename='myfile1', forcefield=rigidwall())
b2 = scriptobject(name=&quot;bead 2&quot;, group=[&quot;B&quot;, &quot;C&quot;], filename='myfile1', forcefield=rigidwall())
b3 = scriptobject(name=&quot;bead 3&quot;, group=[&quot;B&quot;, &quot;D&quot;, &quot;E&quot;], forcefield=solidfood())
b4 = scriptobject(name=&quot;bead 4&quot;, group=&quot;D&quot;, beadtype=1, filename=&quot;myfile2&quot;, forcefield=water())

# Combine objects into a group
collection = b1 + b2 + b3 + b4

# Select a subset of objects and generate a script
grp_typ1 = collection.select(1)
grpB = collection.group.B
script12 = collection.select([1, 2]).script()
</code></pre>
<p>Output:</p>
<pre><code>script object group with 4 objects (1 2 3 4)
script
</code></pre>
<h2 id="overview">OVERVIEW:</h2>
<pre><code>class of script object group
    script object groups are built from script objects OBJ1, OBJ2,..
    GRP = scriptobjectgroup(OBJ1,OBJ2,...)
    GRP = OBJ1+OBJ2+...

note: each beadtype occurs once in the group (if not an error message is generated)

List of methods
    struct() converts data as structure
    select([1,2,4]) selects objects with matching beadtypes

List of properties (dynamically calculated)
    converted data: list, str, zip, beadtype, name, groupname, group, filename
    numeric: len, min, max, minmax
    forcefield related: interactions, forcefield
    script: generate the script (load,group,forcefield)

Full syntax (toy example)
</code></pre>
<p>b1 = scriptobject(name="bead 1",group = ["A", "B", "C"],filename='myfile1',forcefield=rigidwall())
b2 = scriptobject(name="bead 2", group = ["B", "C"],filename = 'myfile1',forcefield=rigidwall())
b3 = scriptobject(name="bead 3", group = ["B", "D", "E"],forcefield=solidfood())
b4 = scriptobject(name="bead 4", group = "D",beadtype = 1,filename="myfile2",forcefield=water())</p>
<pre><code>note: beadtype are incremented during the collection (effect of order)

    # generate a collection, select a typ 1 and a subgroup, generate the script for 1,2

    collection = b1+b2+b3+b4
    grp_typ1 = collection.select(1)
    grpB = collection.group.B
    script12 = collection.select([1,2]).script

note: collection.group.B returns a strcture with 6 fields
-----------:----------------------------------------
    groupid: 2 &lt;-- automatic group numbering
groupidname: B &lt;-- group name
  groupname: ['A', 'B', 'C', 'D', 'E'] &lt;--- snonyms
   beadtype: [1, 2, 3] &lt;-- beads belonging to B
       name: ['bead 1', 'bead 2', 'bead 3'] &lt;-- their names
        str: group B 1 2 3 &lt;-- LAMMPS syntax
-----------:----------------------------------------
</code></pre>
<p>SOG constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scriptobjectgroup(struct):
    &#34;&#34;&#34;
    scriptobjectgroup: A Class for Managing Groups of Script Objects in LAMMPS

    The `scriptobjectgroup` class is designed to represent a group of `scriptobject` instances,
    such as beads or atoms in a simulation. This class allows users to group objects together
    based on their properties (e.g., beadtype, name), and provides tools to generate scripts
    that define interactions, groups, and forcefields for these objects in LAMMPS.

    Key Features:
    -------------
    - **Group Management**: Objects can be combined into a group, where each `beadtype` occurs
      once. The class ensures that objects are uniquely identified by their `beadtype` and `name`.
    - **Dynamic Properties**: The group’s properties (e.g., `beadtype`, `name`, `groupname`)
      are dynamically calculated, ensuring that the group reflects the current state of the objects.
    - **Script Generation**: Provides methods to generate scripts based on the group&#39;s objects,
      including interaction forcefields and group definitions.
    - **Interaction Accumulation**: Automatically accumulates and updates all forcefield
      interactions for the objects in the group.

    Practical Use Cases:
    --------------------
    - **LAMMPS Group Definitions**: Define groups of objects for use in LAMMPS simulations,
      based on properties like `beadtype` and `groupname`.
    - **Forcefield Management**: Automatically manage and update interaction forcefields for
      objects in the group.
    - **Script Generation**: Generate LAMMPS-compatible scripts that include group definitions,
      input file handling, and interaction forcefields.

    Methods:
    --------
    __init__(self, *SOgroup):
        Initializes a new `scriptobjectgroup` with one or more `scriptobject` instances.

    __str__(self):
        Returns a string representation of the `scriptobjectgroup`, showing the number of objects
        in the group and their `beadtypes`.

    __add__(self, SOgroup):
        Combines two `scriptobjectgroup` instances or a `scriptobject` with an existing group,
        ensuring that `beadtype` values are unique.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the group into a pipeline.

    select(self, beadtype=None):
        Selects and returns a subset of the group based on the specified `beadtype`.

    script(self, printflag=False, verbosity=2, verbose=None):
        Generates a script based on the current collection of objects, including input file
        handling, group definitions, and interaction forcefields.

    interactions(self, printflag=False, verbosity=2, verbose=None):
        Updates and accumulates all forcefields for the objects in the group.

    group_generator(self, name=None):
        Generates and returns a `group` object, based on the existing group structure.

    Properties:
    -----------
    - list : Converts the group into a sorted list of objects.
    - zip : Returns a sorted list of tuples containing `beadtype`, `name`, `group`, and `filename`
      for each object.
    - n : Returns the number of objects in the group.
    - beadtype : Returns a list of the `beadtypes` for all objects in the group.
    - name : Returns a list of the `names` for all objects in the group.
    - groupname : Returns a list of all group names (synonyms).
    - filename : Returns a dictionary mapping filenames to the objects that use them.
    - str : Returns a string representation of the group&#39;s `beadtypes`.
    - min : Returns the minimum `beadtype` in the group.
    - max : Returns the maximum `beadtype` in the group.
    - minmax : Returns a tuple of the minimum and maximum `beadtypes` in the group.
    - forcefield : Returns the interaction forcefields for the group.

    Original Content:
    -----------------
    The `scriptobjectgroup` class enables the collection and management of multiple
    `scriptobject` instances, providing the following functionalities:
    - **Group Creation**: Groups are automatically formed by combining individual objects
      using the `+` operator. Each `beadtype` occurs only once in the group, and errors are
      raised if an object with the same `name` or `beadtype` already exists.
    - **Dynamic Properties**: Properties such as `beadtype`, `name`, `groupname`, and `filename`
      are dynamically calculated, reflecting the current state of the objects.
    - **Forcefield Handling**: Forcefields are automatically managed for the objects in the group,
      including diagonal and off-diagonal terms for pair interactions.
    - **Script Generation**: Scripts are generated to define the interactions, groups, and
      input file handling for LAMMPS.

    Example Usage:
    --------------
    ```
    from pizza.scriptobject import scriptobject, scriptobjectgroup, rigidwall, solidfood, water

    # Define some script objects
    b1 = scriptobject(name=&#34;bead 1&#34;, group=[&#34;A&#34;, &#34;B&#34;, &#34;C&#34;], filename=&#39;myfile1&#39;, forcefield=rigidwall())
    b2 = scriptobject(name=&#34;bead 2&#34;, group=[&#34;B&#34;, &#34;C&#34;], filename=&#39;myfile1&#39;, forcefield=rigidwall())
    b3 = scriptobject(name=&#34;bead 3&#34;, group=[&#34;B&#34;, &#34;D&#34;, &#34;E&#34;], forcefield=solidfood())
    b4 = scriptobject(name=&#34;bead 4&#34;, group=&#34;D&#34;, beadtype=1, filename=&#34;myfile2&#34;, forcefield=water())

    # Combine objects into a group
    collection = b1 + b2 + b3 + b4

    # Select a subset of objects and generate a script
    grp_typ1 = collection.select(1)
    grpB = collection.group.B
    script12 = collection.select([1, 2]).script()
    ```

    Output:
    ```
    script object group with 4 objects (1 2 3 4)
    script
    ```

    OVERVIEW:
    --------------


        class of script object group
            script object groups are built from script objects OBJ1, OBJ2,..
            GRP = scriptobjectgroup(OBJ1,OBJ2,...)
            GRP = OBJ1+OBJ2+...

        note: each beadtype occurs once in the group (if not an error message is generated)

        List of methods
            struct() converts data as structure
            select([1,2,4]) selects objects with matching beadtypes

        List of properties (dynamically calculated)
            converted data: list, str, zip, beadtype, name, groupname, group, filename
            numeric: len, min, max, minmax
            forcefield related: interactions, forcefield
            script: generate the script (load,group,forcefield)

        Full syntax (toy example)

    b1 = scriptobject(name=&#34;bead 1&#34;,group = [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;],filename=&#39;myfile1&#39;,forcefield=rigidwall())
    b2 = scriptobject(name=&#34;bead 2&#34;, group = [&#34;B&#34;, &#34;C&#34;],filename = &#39;myfile1&#39;,forcefield=rigidwall())
    b3 = scriptobject(name=&#34;bead 3&#34;, group = [&#34;B&#34;, &#34;D&#34;, &#34;E&#34;],forcefield=solidfood())
    b4 = scriptobject(name=&#34;bead 4&#34;, group = &#34;D&#34;,beadtype = 1,filename=&#34;myfile2&#34;,forcefield=water())

        note: beadtype are incremented during the collection (effect of order)

            # generate a collection, select a typ 1 and a subgroup, generate the script for 1,2

            collection = b1+b2+b3+b4
            grp_typ1 = collection.select(1)
            grpB = collection.group.B
            script12 = collection.select([1,2]).script

        note: collection.group.B returns a strcture with 6 fields
        -----------:----------------------------------------
            groupid: 2 &lt;-- automatic group numbering
        groupidname: B &lt;-- group name
          groupname: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] &lt;--- snonyms
           beadtype: [1, 2, 3] &lt;-- beads belonging to B
               name: [&#39;bead 1&#39;, &#39;bead 2&#39;, &#39;bead 3&#39;] &lt;-- their names
                str: group B 1 2 3 &lt;-- LAMMPS syntax
        -----------:----------------------------------------

    &#34;&#34;&#34;
    _type = &#34;SOG&#34;
    _fulltype = &#34;script object group&#34;
    _ftype = &#34;object&#34;
    _propertyasattribute = True

    def __init__(self,*SOgroup):
        &#34;&#34;&#34; SOG constructor &#34;&#34;&#34;
        super(scriptobjectgroup,self).__init__()
        beadtypemax = 0
        names = []
        for k in range(len(SOgroup)):
            if isinstance(SOgroup[k],scriptobject):
                if SOgroup[k].beadtype&lt;beadtypemax or SOgroup[k].beadtype==None:
                    beadtypemax +=1
                    SOgroup[k].beadtype = beadtypemax
                if SOgroup[k].name not in names:
                    self.setattr(SOgroup[k].name,SOgroup[k])
                    beadtypemax = SOgroup[k].beadtype
                else:
                    raise ValueError(&#39;the script object &#34;%s&#34; already exists&#39; % SOgroup[k].name)
                names.append(SOgroup[k].name)
            else:
                raise ValueError(&#34;the argument #%d is not a script object&#34;)

    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self._fulltype} with {len(self)} {self._ftype}s ({span(self.beadtype)})&#34;

    def __add__(self, SOgroup):
        &#34;&#34;&#34; overload + &#34;&#34;&#34;
        beadlist = self.beadtype
        dup = duplicate(self)
        if isinstance(SOgroup,scriptobject):
            if SOgroup.name not in self.keys():
                if SOgroup.beadtype in beadlist and \
                  (SOgroup.beadtype==None or SOgroup.beadtype==self.min):
                      SOgroup.beadtype = self.max+1
                if SOgroup.beadtype not in beadlist:
                    dup.setattr(SOgroup.name, SOgroup)
                    beadlist.append(SOgroup.beadtype)
                    return dup
                else:
                    raise ValueError(&#39;%s (beadtype=%d) is already in use, same beadtype&#39; \
                                     % (SOgroup.name,SOgroup.beadtype))
            else:
                raise ValueError(&#39;the object &#34;%s&#34; is already in the list&#39; % SOgroup.name)
        elif isinstance(SOgroup,scriptobjectgroup):
            for k in SOgroup.keys():
                if k not in dup.keys():
                    if SOgroup.getattr(k).beadtype not in beadlist:
                        dup.setattr(k,SOgroup.getattr(k))
                        beadlist.append(SOgroup.getattr(k).beadtype)
                    else:
                        raise ValueError(&#39;%s (beadtype=%d) is already in use, same beadtype&#39; \
                                         % (k,SOgroup.getattr(k).beadtype))
                else:
                    raise ValueError(&#39;the object &#34;%s&#34; is already in the list&#39; % k)
            return dup
        else:
            raise ValueError(&#34;the argument #%d is not a script object or a script object group&#34;)

    def __or__(self, pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        if isinstance(pipe,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self) | pipe
        else:
            raise ValueError(&#34;the argument must a pipescript, a scriptobject or a scriptobjectgroup&#34;)

    @property
    def list(self):
        &#34;&#34;&#34; convert into a list &#34;&#34;&#34;
        return sorted(self)

    @property
    def zip(self):
        &#34;&#34;&#34; zip beadtypes and names &#34;&#34;&#34;
        return sorted( \
            [(self.getattr(k).beadtype,self.getattr(k).name,self.getattr(k).group,self.getattr(k).filename) \
            for k in self.keys()])

    @property
    def n(self):
        &#34;&#34;&#34; returns the number of bead types &#34;&#34;&#34;
        return len(self)

    @property
    def beadtype(self):
        &#34;&#34;&#34; returns the beads in the group &#34;&#34;&#34;
        return [x for x,_,_,_ in self.zip]

    @property
    def name(self):
        &#34;&#34;&#34; &#34;return the list of names &#34;&#34;&#34;
        return [x for _,x,_,_ in self.zip]

    @property
    def groupname(self):
        &#34;&#34;&#34; &#34;return the list of groupnames &#34;&#34;&#34;
        grp = []
        for _,_,glist,_ in self.zip:
            for g in glist:
                if g not in grp: grp.append(g)
        return grp

    @property
    def filename(self):
        &#34;&#34;&#34; &#34;return the list of names as a dictionary &#34;&#34;&#34;
        files = {}
        for _,n,_,fn in self.zip:
            if fn != &#34;&#34;:
                if fn not in files:
                    files[fn] = [n]
                else:
                    files[fn].append(n)
        return files

    @property
    def str(self):
        return span(self.beadtype)

    def struct(self,groupid=1,groupidname=&#34;undef&#34;):
        &#34;&#34;&#34; create a group with name &#34;&#34;&#34;
        return struct(
                groupid = groupid,
            groupidname = groupidname,
              groupname = self.groupname, # meaning is synonyms
               beadtype = self.beadtype,
                   name = self.name,
                    str = &#34;group %s %s&#34; % (groupidname, span(self.beadtype))
               )

    @property
    def minmax(self):
        &#34;&#34;&#34; returns the min,max of beadtype &#34;&#34;&#34;
        return self.min,self.max

    @property
    def min(self):
        &#34;&#34;&#34; returns the min of beadtype &#34;&#34;&#34;
        return min(self.beadtype)

    @property
    def max(self):
        &#34;&#34;&#34; returns the max of beadtype &#34;&#34;&#34;
        return max(self.beadtype)

    def select(self,beadtype=None):
        &#34;&#34;&#34; select bead from a keep beadlist &#34;&#34;&#34;
        if beadtype==None: beadtype = list(range(self.min,self.max+1))
        if not isinstance(beadtype,(list,tuple)): beadtype = [beadtype]
        dup = scriptobjectgroup()
        for b,n,_,_ in self.zip:
            if b in beadtype:
                dup = dup + self.getattr(n)
                dup.getattr(n).USER = self.getattr(n).USER
                dup.getattr(n).forcefield = self.getattr(n).forcefield
        return dup

    @property
    def group(self):
        &#34;&#34;&#34; build groups from group (groupname contains synonyms) &#34;&#34;&#34;
        groupdef = struct()
        gid = 0
        bng = self.zip
        for g in self.groupname:
            gid +=1
            b =[x for x,_,gx,_ in bng if g in gx]
            groupdef.setattr(g,self.select(b).struct(groupid = gid, groupidname = g))
        return groupdef

    @CallableScript
    def interactions(self, printflag=False, verbosity=2, verbose=None):
        &#34;&#34;&#34; update and accumulate all forcefields &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        FF = []
        for b in self.beadtype:
            selection = deepduplicate(self.select(b)[0])
            selection.forcefield.beadtype = selection.beadtype
            selection.forcefield.userid = selection.name
            FF.append(selection.forcefield)
        # initialize interactions with pair_style
        TEMPLATE = &#34;\n# ===== [ BEGIN FORCEFIELD SECTION ] &#34;+&#34;=&#34;*80 if verbosity&gt;0 else &#34;&#34;
        TEMPLATE = FF[0].pair_style(verbose=verbosity&gt;0)
        # pair diagonal terms
        for i in range(len(FF)):
            TEMPLATE += FF[i].pair_diagcoeff(verbose=verbosity&gt;0)
        # pair off-diagonal terms
        for j in range(1,len(FF)):
            for i in range(0,j):
                TEMPLATE += FF[i].pair_offdiagcoeff(o=FF[j],verbose=verbosity&gt;0)
        # end
        TEMPLATE += &#34;\n# ===== [ END FORCEFIELD SECTION ] &#34;+&#34;=&#34;*82+&#34;\n&#34;  if verbosity&gt;0 else &#34;&#34;
        return FF,TEMPLATE

    @property
    def forcefield(self):
        &#34;&#34;&#34; interaction forcefields &#34;&#34;&#34;
        FF,_ = self.interactions
        return FF

    @CallableScript
    def script(self, printflag=False, verbosity=None, verbose=None):
        &#34;&#34;&#34;
            Generate a script based on the current collection of script objects

            Parameters:
            -----------
            printflag : bool, optional, default=False
                If True, prints the generated script.
            verbosity (int, optional): Controls the level of detail in the generated script.
                - 0: Minimal output, no comments.
                - 1: Basic comments for run steps.
                - 2: Detailed comments with additional information.
                Default is 2

            Returns:
            --------
            script
                The generated script describing the interactions between script objects.
        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if verbose is False else verbosity
        TEMPFILES = &#34;&#34;
        isfirst = True
        files_added = False
        if self.filename:
            for fn, cfn in self.filename.items():
                if fn and cfn:
                    if not files_added:
                        files_added = True
                        TEMPFILES += &#34;\n# ===== [ BEGIN INPUT FILES SECTION ] &#34; + &#34;=&#34; * 79 + &#34;\n&#34; if verbosity&gt;0 else &#34;&#34;
                    TEMPFILES += span(cfn, sep=&#34;, &#34;, left=&#34;\n# load files for objects: &#34;, right=&#34;\n&#34;) if verbosity&gt;1 else &#34;&#34;
                    if isfirst:
                        isfirst = False
                        TEMPFILES += f&#34;\tread_data {fn}\n&#34;  # First file, no append
                    else:
                        TEMPFILES += f&#34;\tread_data {fn} add append\n&#34;  # Subsequent files, append
        # define groups
        TEMPGRP = &#34;\n# ===== [ BEGIN GROUP SECTION ] &#34;+&#34;=&#34;*85 + &#34;\n&#34; if verbosity&gt;0 else &#34;&#34;
        for g in self.group:
            TEMPGRP += f&#39;\n\t#\tDefinition of group {g.groupid}:{g.groupidname}\n&#39; if verbosity&gt;1 else &#34;&#34;
            TEMPGRP += f&#39;\t#\t={span(g.name,sep=&#34;, &#34;)}\n&#39; if verbosity&gt;1 else &#34;&#34;
            TEMPGRP += f&#39;\t#\tSimilar groups: {span(g.groupname,sep=&#34;, &#34;)}\n&#39; if verbosity&gt;1 else &#34;&#34;
            TEMPGRP += f&#39;\tgroup \t {g.groupidname} \ttype \t {span(g.beadtype)}\n&#39;
        TEMPGRP += &#34;\n# ===== [ END GROUP SECTION ] &#34;+&#34;=&#34;*87+&#34;\n\n&#34; if verbosity&gt;0 else &#34;&#34;
        # define interactions
        _,TEMPFF = self.interactions(printflag=printflag, verbosity=verbosity)
        # chain strings into a script
        tscript = script(printflag=False,verbose=verbosity&gt;1)
        tscript.name = &#34;scriptobject script&#34;        # name
        tscript.description = str(self)             # description
        tscript.userid = &#34;scriptobject&#34;             # user name
        tscript.TEMPLATE = TEMPFILES+TEMPGRP+TEMPFF
        if verbosity==0:
            tscript.TEMPLATE = remove_comments(tscript.TEMPLATE)
        if printflag:
            repr(tscript)
        return tscript

    def group_generator(self, name=None):
        &#34;&#34;&#34;
        Generate and return a group object.

        This method creates a new `group` object, optionally with a specified name.
        If no name is provided, it generates a default name based on the current
        instance&#39;s `name` attribute, formatted with the `span` function. The method
        then iterates through the existing groups in `self.group`, adding each group
        to the new `group` object based on its `groupidname` and `beadtype`.

        Parameters:
        -----------
        name : str, optional
            The name for the generated group object. If not provided, a default name
            is generated based on the current instance&#39;s `name`.

        Returns:
        --------
        group
            A newly created `group` object with criteria set based on the existing groups.
        &#34;&#34;&#34;
        from pizza.group import group
        # Use the provided name or generate a default name using the span function
        G = group(name=name if name is not None else span(self.name, &#34;,&#34;, &#34;[&#34;, &#34;]&#34;))
        # Add criteria for each group in self.group
        for g in self.group:
            G.add_group_criteria(g.groupidname, type=g.beadtype)
        return G


    def mass(self, name=None, default_mass=&#34;${mass}&#34;, printflag=False, verbosity=2, verbose=True):
        &#34;&#34;&#34;
        Generates LAMMPS mass commands for each unique beadtype in the collection.

        The method iterates through all `scriptobjectgroup` instances in the collection,
        collects unique beadtypes, and ensures that each beadtype has a consistent mass.
        If a beadtype has `mass=None`, it assigns a default mass as specified by `default_mass`.

        ### Parameters:
            name (str, optional):
                The name to assign to the resulting `script` object. Defaults to a generated name.
            default_mass (str, int, or float, optional):
                The default mass value to assign when a beadtype&#39;s mass is `None`.
                Can be a string, integer, or floating-point value. Defaults to `&#34;${mass}&#34;`.
            printflag (bool, optional):
                If `True`, prints the representation of the resulting `script` object. Defaults to `False`.
            verbosity (int, optional):
                The verbosity level for logging or debugging. Higher values indicate more detailed output.
                Defaults to `2`.
            verbose (bool, optional):
                If `True`, includes a comment header in the output. Overrides `verbosity` when `False`.
                Defaults to `True`.

        ### Returns:
            script: A `script` object containing the mass commands for each beadtype, formatted as follows:
                     ```
                     mass 1 1.0
                     mass 2 ${mass}
                     mass 3 2.5
                     ```
                     The `TEMPLATE` attribute of the `script` object holds the formatted mass commands as a single string.

        ### Raises:
            ValueError: If a beadtype has inconsistent mass values across different `scriptobjectgroup` instances.

        ### Example:
            ```python
            # Create scriptobjectgroup instances
            obj1 = scriptobjectgroup(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
            obj2 = scriptobjectgroup(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
            obj3 = scriptobjectgroup(beadtype=3, group=&#34;C&#34;, mass=2.5)

            # Initialize a script group with the scriptobjectgroup instances
            G = scriptobjectgroup([obj1, obj2, obj3])

            # Generate mass commands
            M = G.mass()
            print(M.do())
            ```

            **Output:**
            ```
            # &lt;script:group:mass&gt; definitions for 3 beads
            mass 1 1.0
            mass 2 ${mass}
            mass 3 2.5
            ```
        &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        beadtype_mass = {}
        for iobj in range(0,len(self)):
            obj = self[iobj]
            bt = obj.beadtype
            mass = obj.mass if obj.mass is not None else default_mass
            if bt in beadtype_mass:
                if beadtype_mass[bt] != mass:
                    raise ValueError(
                        f&#34;Inconsistent masses for beadtype {bt}: {beadtype_mass[bt]} vs {mass}&#34;
                    )
            else:
                beadtype_mass[bt] = mass
        # Sort beadtypes for consistent ordering
        sorted_beadtypes = sorted(beadtype_mass.keys())
        # Generate mass commands
        lines = [f&#34;mass {bt} {beadtype_mass[bt]}&#34; for bt in sorted_beadtypes]
        # return a script object
        nameid = f&#34;&lt;script:group:{self.name}:mass&gt;&#34;
        description = f&#34;{nameid} definitions for {len(self)} beads&#34;
        if verbose:
            lines.insert(0, &#34;# &#34;+description)
        mscript = script(printflag=False,verbose=verbosity&gt;1)
        mscript.name = nameid if name is None else name
        mscript.description = description
        mscript.userid = &#34;scriptobject&#34;             # user name
        mscript.TEMPLATE = &#34;\n&#34;.join(lines)
        mscript.DEFINITIONS.mass = default_mass
        if printflag:
            repr(mscript)
        return mscript</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="script.scriptobjectgroup.beadtype"><code class="name">var <span class="ident">beadtype</span></code></dt>
<dd>
<div class="desc"><p>returns the beads in the group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beadtype(self):
    &#34;&#34;&#34; returns the beads in the group &#34;&#34;&#34;
    return [x for x,_,_,_ in self.zip]</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.filename"><code class="name">var <span class="ident">filename</span></code></dt>
<dd>
<div class="desc"><p>"return the list of names as a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def filename(self):
    &#34;&#34;&#34; &#34;return the list of names as a dictionary &#34;&#34;&#34;
    files = {}
    for _,n,_,fn in self.zip:
        if fn != &#34;&#34;:
            if fn not in files:
                files[fn] = [n]
            else:
                files[fn].append(n)
    return files</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.forcefield"><code class="name">var <span class="ident">forcefield</span></code></dt>
<dd>
<div class="desc"><p>interaction forcefields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def forcefield(self):
    &#34;&#34;&#34; interaction forcefields &#34;&#34;&#34;
    FF,_ = self.interactions
    return FF</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.group"><code class="name">var <span class="ident">group</span></code></dt>
<dd>
<div class="desc"><p>build groups from group (groupname contains synonyms)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def group(self):
    &#34;&#34;&#34; build groups from group (groupname contains synonyms) &#34;&#34;&#34;
    groupdef = struct()
    gid = 0
    bng = self.zip
    for g in self.groupname:
        gid +=1
        b =[x for x,_,gx,_ in bng if g in gx]
        groupdef.setattr(g,self.select(b).struct(groupid = gid, groupidname = g))
    return groupdef</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.groupname"><code class="name">var <span class="ident">groupname</span></code></dt>
<dd>
<div class="desc"><p>"return the list of groupnames</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def groupname(self):
    &#34;&#34;&#34; &#34;return the list of groupnames &#34;&#34;&#34;
    grp = []
    for _,_,glist,_ in self.zip:
        for g in glist:
            if g not in grp: grp.append(g)
    return grp</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.list"><code class="name">var <span class="ident">list</span></code></dt>
<dd>
<div class="desc"><p>convert into a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def list(self):
    &#34;&#34;&#34; convert into a list &#34;&#34;&#34;
    return sorted(self)</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.max"><code class="name">var <span class="ident">max</span></code></dt>
<dd>
<div class="desc"><p>returns the max of beadtype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max(self):
    &#34;&#34;&#34; returns the max of beadtype &#34;&#34;&#34;
    return max(self.beadtype)</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.min"><code class="name">var <span class="ident">min</span></code></dt>
<dd>
<div class="desc"><p>returns the min of beadtype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min(self):
    &#34;&#34;&#34; returns the min of beadtype &#34;&#34;&#34;
    return min(self.beadtype)</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.minmax"><code class="name">var <span class="ident">minmax</span></code></dt>
<dd>
<div class="desc"><p>returns the min,max of beadtype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def minmax(self):
    &#34;&#34;&#34; returns the min,max of beadtype &#34;&#34;&#34;
    return self.min,self.max</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>returns the number of bead types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34; returns the number of bead types &#34;&#34;&#34;
    return len(self)</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>"return the list of names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34; &#34;return the list of names &#34;&#34;&#34;
    return [x for _,x,_,_ in self.zip]</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.str"><code class="name">var <span class="ident">str</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def str(self):
    return span(self.beadtype)</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.zip"><code class="name">var <span class="ident">zip</span></code></dt>
<dd>
<div class="desc"><p>zip beadtypes and names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zip(self):
    &#34;&#34;&#34; zip beadtypes and names &#34;&#34;&#34;
    return sorted( \
        [(self.getattr(k).beadtype,self.getattr(k).name,self.getattr(k).group,self.getattr(k).filename) \
        for k in self.keys()])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="script.scriptobjectgroup.group_generator"><code class="name flex">
<span>def <span class="ident">group_generator</span></span>(<span>self, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return a group object.</p>
<p>This method creates a new <code>group</code> object, optionally with a specified name.
If no name is provided, it generates a default name based on the current
instance's <code>name</code> attribute, formatted with the <code><a title="script.span" href="#script.span">span()</a></code> function. The method
then iterates through the existing groups in <code>self.group</code>, adding each group
to the new <code>group</code> object based on its <code>groupidname</code> and <code>beadtype</code>.</p>
<h2 id="parameters">Parameters:</h2>
<p>name : str, optional
The name for the generated group object. If not provided, a default name
is generated based on the current instance's <code>name</code>.</p>
<h2 id="returns">Returns:</h2>
<p>group
A newly created <code>group</code> object with criteria set based on the existing groups.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_generator(self, name=None):
    &#34;&#34;&#34;
    Generate and return a group object.

    This method creates a new `group` object, optionally with a specified name.
    If no name is provided, it generates a default name based on the current
    instance&#39;s `name` attribute, formatted with the `span` function. The method
    then iterates through the existing groups in `self.group`, adding each group
    to the new `group` object based on its `groupidname` and `beadtype`.

    Parameters:
    -----------
    name : str, optional
        The name for the generated group object. If not provided, a default name
        is generated based on the current instance&#39;s `name`.

    Returns:
    --------
    group
        A newly created `group` object with criteria set based on the existing groups.
    &#34;&#34;&#34;
    from pizza.group import group
    # Use the provided name or generate a default name using the span function
    G = group(name=name if name is not None else span(self.name, &#34;,&#34;, &#34;[&#34;, &#34;]&#34;))
    # Add criteria for each group in self.group
    for g in self.group:
        G.add_group_criteria(g.groupidname, type=g.beadtype)
    return G</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.interactions"><code class="name flex">
<span>def <span class="ident">interactions</span></span>(<span>printflag=False, verbosity=2, verbose=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">return lambda printflag=False, verbosity=2, verbose=None: self.func(instance, printflag=printflag, verbosity=verbosity, verbose=verbose)</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.mass"><code class="name flex">
<span>def <span class="ident">mass</span></span>(<span>self, name=None, default_mass='${mass}', printflag=False, verbosity=2, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates LAMMPS mass commands for each unique beadtype in the collection.</p>
<p>The method iterates through all <code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code> instances in the collection,
collects unique beadtypes, and ensures that each beadtype has a consistent mass.
If a beadtype has <code>mass=None</code>, it assigns a default mass as specified by <code>default_mass</code>.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>name (str, optional):
    The name to assign to the resulting &lt;code&gt;&lt;a title="script.script" href="#script.script"&gt;script&lt;/a&gt;&lt;/code&gt; object. Defaults to a generated name.
default_mass (str, int, or float, optional):
    The default mass value to assign when a beadtype's mass is &lt;code&gt;None&lt;/code&gt;.
    Can be a string, integer, or floating-point value. Defaults to `"${mass}"`.
printflag (bool, optional):
    If &lt;code&gt;True&lt;/code&gt;, prints the representation of the resulting &lt;code&gt;&lt;a title="script.script" href="#script.script"&gt;script&lt;/a&gt;&lt;/code&gt; object. Defaults to &lt;code&gt;False&lt;/code&gt;.
verbosity (int, optional):
    The verbosity level for logging or debugging. Higher values indicate more detailed output.
    Defaults to &lt;code&gt;2&lt;/code&gt;.
verbose (bool, optional):
    If &lt;code&gt;True&lt;/code&gt;, includes a comment header in the output. Overrides &lt;code&gt;verbosity&lt;/code&gt; when &lt;code&gt;False&lt;/code&gt;.
    Defaults to &lt;code&gt;True&lt;/code&gt;.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>script: A &lt;code&gt;&lt;a title="script.script" href="#script.script"&gt;script&lt;/a&gt;&lt;/code&gt; object containing the mass commands for each beadtype, formatted as follows:
         ```
         mass 1 1.0
         mass 2 ${mass}
         mass 3 2.5
         ```
         The &lt;code&gt;TEMPLATE&lt;/code&gt; attribute of the &lt;code&gt;&lt;a title="script.script" href="#script.script"&gt;script&lt;/a&gt;&lt;/code&gt; object holds the formatted mass commands as a single string.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>ValueError: If a beadtype has inconsistent mass values across different &lt;code&gt;&lt;a title="script.scriptobjectgroup" href="#script.scriptobjectgroup"&gt;scriptobjectgroup&lt;/a&gt;&lt;/code&gt; instances.
</code></pre>
<h3 id="example">Example:</h3>
<pre><code>```python
# Create scriptobjectgroup instances
obj1 = scriptobjectgroup(beadtype=1, group=["all", "A"], mass=1.0)
obj2 = scriptobjectgroup(beadtype=2, group=["all", "B", "C"])
obj3 = scriptobjectgroup(beadtype=3, group="C", mass=2.5)

# Initialize a script group with the scriptobjectgroup instances
G = scriptobjectgroup([obj1, obj2, obj3])

# Generate mass commands
M = G.mass()
print(M.do())
```

**Output:**
```
# &lt;script:group:mass&gt; definitions for 3 beads
mass 1 1.0
mass 2 ${mass}
mass 3 2.5
```
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mass(self, name=None, default_mass=&#34;${mass}&#34;, printflag=False, verbosity=2, verbose=True):
    &#34;&#34;&#34;
    Generates LAMMPS mass commands for each unique beadtype in the collection.

    The method iterates through all `scriptobjectgroup` instances in the collection,
    collects unique beadtypes, and ensures that each beadtype has a consistent mass.
    If a beadtype has `mass=None`, it assigns a default mass as specified by `default_mass`.

    ### Parameters:
        name (str, optional):
            The name to assign to the resulting `script` object. Defaults to a generated name.
        default_mass (str, int, or float, optional):
            The default mass value to assign when a beadtype&#39;s mass is `None`.
            Can be a string, integer, or floating-point value. Defaults to `&#34;${mass}&#34;`.
        printflag (bool, optional):
            If `True`, prints the representation of the resulting `script` object. Defaults to `False`.
        verbosity (int, optional):
            The verbosity level for logging or debugging. Higher values indicate more detailed output.
            Defaults to `2`.
        verbose (bool, optional):
            If `True`, includes a comment header in the output. Overrides `verbosity` when `False`.
            Defaults to `True`.

    ### Returns:
        script: A `script` object containing the mass commands for each beadtype, formatted as follows:
                 ```
                 mass 1 1.0
                 mass 2 ${mass}
                 mass 3 2.5
                 ```
                 The `TEMPLATE` attribute of the `script` object holds the formatted mass commands as a single string.

    ### Raises:
        ValueError: If a beadtype has inconsistent mass values across different `scriptobjectgroup` instances.

    ### Example:
        ```python
        # Create scriptobjectgroup instances
        obj1 = scriptobjectgroup(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
        obj2 = scriptobjectgroup(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
        obj3 = scriptobjectgroup(beadtype=3, group=&#34;C&#34;, mass=2.5)

        # Initialize a script group with the scriptobjectgroup instances
        G = scriptobjectgroup([obj1, obj2, obj3])

        # Generate mass commands
        M = G.mass()
        print(M.do())
        ```

        **Output:**
        ```
        # &lt;script:group:mass&gt; definitions for 3 beads
        mass 1 1.0
        mass 2 ${mass}
        mass 3 2.5
        ```
    &#34;&#34;&#34;
    verbosity = 0 if verbose is False else verbosity
    beadtype_mass = {}
    for iobj in range(0,len(self)):
        obj = self[iobj]
        bt = obj.beadtype
        mass = obj.mass if obj.mass is not None else default_mass
        if bt in beadtype_mass:
            if beadtype_mass[bt] != mass:
                raise ValueError(
                    f&#34;Inconsistent masses for beadtype {bt}: {beadtype_mass[bt]} vs {mass}&#34;
                )
        else:
            beadtype_mass[bt] = mass
    # Sort beadtypes for consistent ordering
    sorted_beadtypes = sorted(beadtype_mass.keys())
    # Generate mass commands
    lines = [f&#34;mass {bt} {beadtype_mass[bt]}&#34; for bt in sorted_beadtypes]
    # return a script object
    nameid = f&#34;&lt;script:group:{self.name}:mass&gt;&#34;
    description = f&#34;{nameid} definitions for {len(self)} beads&#34;
    if verbose:
        lines.insert(0, &#34;# &#34;+description)
    mscript = script(printflag=False,verbose=verbosity&gt;1)
    mscript.name = nameid if name is None else name
    mscript.description = description
    mscript.userid = &#34;scriptobject&#34;             # user name
    mscript.TEMPLATE = &#34;\n&#34;.join(lines)
    mscript.DEFINITIONS.mass = default_mass
    if printflag:
        repr(mscript)
    return mscript</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>printflag=False, verbosity=2, verbose=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">return lambda printflag=False, verbosity=2, verbose=None: self.func(instance, printflag=printflag, verbosity=verbosity, verbose=verbose)</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, beadtype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>select bead from a keep beadlist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self,beadtype=None):
    &#34;&#34;&#34; select bead from a keep beadlist &#34;&#34;&#34;
    if beadtype==None: beadtype = list(range(self.min,self.max+1))
    if not isinstance(beadtype,(list,tuple)): beadtype = [beadtype]
    dup = scriptobjectgroup()
    for b,n,_,_ in self.zip:
        if b in beadtype:
            dup = dup + self.getattr(n)
            dup.getattr(n).USER = self.getattr(n).USER
            dup.getattr(n).forcefield = self.getattr(n).forcefield
    return dup</code></pre>
</details>
</dd>
<dt id="script.scriptobjectgroup.struct"><code class="name flex">
<span>def <span class="ident">struct</span></span>(<span>self, groupid=1, groupidname='undef')</span>
</code></dt>
<dd>
<div class="desc"><p>create a group with name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct(self,groupid=1,groupidname=&#34;undef&#34;):
    &#34;&#34;&#34; create a group with name &#34;&#34;&#34;
    return struct(
            groupid = groupid,
        groupidname = groupidname,
          groupname = self.groupname, # meaning is synonyms
           beadtype = self.beadtype,
               name = self.name,
                str = &#34;group %s %s&#34; % (groupidname, span(self.beadtype))
           )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="script.smd"><code class="flex name class">
<span>class <span class="ident">smd</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD forcefield</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class smd(forcefield):
    &#34;&#34;&#34; SMD forcefield &#34;&#34;&#34;
    name = forcefield.name + struct(forcefield=&#34;LAMMPS:SMD&#34;)
    description = forcefield.description + struct(forcefield=&#34;LAMMPS:SMD - solid, liquid, rigid forcefields (continuum mechanics)&#34;)

    # forcefield definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_STYLE = &#34;&#34;&#34;
    # [comment] PAIR STYLE SMD
    pair_style      hybrid/overlay smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION &amp;
                                   smd/tlsph smd/hertz ${contact_scale}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.none</li>
<li>pizza.forcefield.tlsph</li>
<li>pizza.forcefield.ulsph</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.smd.PAIR_STYLE"><code class="name">var <span class="ident">PAIR_STYLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.smd.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.smd.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="script.solidfood"><code class="flex name class">
<span>class <span class="ident">solidfood</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>solidfood material (smd:tlsph): model solid food object
solidfood()
solidfood(beadtype=index, userid="myfood", USER=&hellip;)</p>
<p>override any propery with USER.property=value (set only the parameters you want to override)
USER.rho: density in kg/m3 (default=1000)
USER.c0: speed of the sound in m/s (default=10.0)
USER.E: Young's modulus in Pa (default="5<em>${c0}^2</em>${rho}")
USER.nu: Poisson ratio (default=0.3)
USER.q1: standard artificial viscosity linear coefficient (default=1.0)
USER.q2: standard artificial viscosity quadratic coefficient (default=0)
USER.Hg: hourglass control coefficient (default=10.0)
USER.Cp: heat capacity of material &ndash; not used here (default=1.0)
USER.sigma_yield: plastic yield stress in Pa (default="0.1<em>${E}")
USER.hardening: hardening parameter (default=0)
USER.contact_scale: scaling coefficient for contact (default=1.5)
USER.contact_stiffness: contact stifness in Pa (default="2.5</em>${c0}^2*${rho}")</p>
<p>food forcefield:
solidfood(beadtype=index, userid="myfood")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class solidfood(tlsph):
    &#34;&#34;&#34; solidfood material (smd:tlsph): model solid food object
            solidfood()
            solidfood(beadtype=index, userid=&#34;myfood&#34;, USER=...)

            override any propery with USER.property=value (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=1000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.E: Young&#39;s modulus in Pa (default=&#34;5*${c0}^2*${rho}&#34;)
                USER.nu: Poisson ratio (default=0.3)
                USER.q1: standard artificial viscosity linear coefficient (default=1.0)
                USER.q2: standard artificial viscosity quadratic coefficient (default=0)
                USER.Hg: hourglass control coefficient (default=10.0)
                USER.Cp: heat capacity of material -- not used here (default=1.0)
                USER.sigma_yield: plastic yield stress in Pa (default=&#34;0.1*${E}&#34;)
                USER.hardening: hardening parameter (default=0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = tlsph.name + struct(material=&#34;solidfood&#34;)
    description = tlsph.description + struct(material=&#34;food beads - solid behavior&#34;)
    userid = &#39;solidfood&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; food forcefield:
            solidfood(beadtype=index, userid=&#34;myfood&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # food-food interactions
            rho = 1000,
            c0 = 10.0,
            E = &#34;5*${c0}^2*${rho}&#34;,
            nu = 0.3,
            q1 = 1.0,
            q2 = 0.0,
            Hg = 10.0,
            Cp = 1.0,
            sigma_yield = &#34;0.1*${E}&#34;,
            hardening = 0,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#34;2.5*${c0}^2*${rho}&#34;
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.tlsph</li>
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.solidfood.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.solidfood.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.solidfood.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.solidfood.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="script.statussection"><code class="flex name class">
<span>class <span class="ident">statussection</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>LAMMPS script: status session </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class statussection(script):
    &#34;&#34;&#34; LAMMPS script: status session &#34;&#34;&#34;
    name = &#34;status&#34;
    description = name+&#34; section&#34;
    position = 8
    section = 9
    userid = &#34;example&#34;
    version = 0.1

    DEFINITIONS = scriptdata(
        thermo = 100
        )

    TEMPLATE = &#34;&#34;&#34;
# :STATUS SECTION:
#   Status configuration

    ####################################################################################################
    # STATUS OUTPUT
    ####################################################################################################
    compute         alleint all reduce sum c_eint
    variable        etot equal pe+ke+c_alleint+f_gfix # total energy of the system
    thermo          ${thermo}
    thermo_style    custom step ke pe v_etot c_alleint f_dtfix dt
    thermo_modify   lost ignore

    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="script.script" href="#script.script">script</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.statussection.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.statussection.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.statussection.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.statussection.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.statussection.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.statussection.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.statussection.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.statussection.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="script.script" href="#script.script">script</a></b></code>:
<ul class="hlist">
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="script.struct"><code class="flex name class">
<span>class <span class="ident">struct</span></span>
<span>(</span><span>debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-struct">Class: <code><a title="script.struct" href="#script.struct">struct</a></code></h1>
<p>A lightweight class that mimics Matlab-like structures, with additional features
such as dynamic field creation, indexing, concatenation, and compatibility with
evaluated parameters (<code><a title="script.param" href="#script.param">param</a></code>).</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Dynamic creation of fields.</li>
<li>Indexing and iteration support for fields.</li>
<li>Concatenation and subtraction of structures.</li>
<li>Conversion to and from dictionaries.</li>
<li>Compatible with <code><a title="script.param" href="#script.param">param</a></code> and <code><a title="script.paramauto" href="#script.paramauto">paramauto</a></code> for evaluation and dependency handling.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic Usage</h4>
<pre><code class="language-python">s = struct(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
print(s.a)  # 1
s.d = 11    # Append a new field
delattr(s, 'd')  # Delete the field
</code></pre>
<h4 id="using-param-for-evaluation">Using <code><a title="script.param" href="#script.param">param</a></code> for Evaluation</h4>
<pre><code class="language-python">p = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
p.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-subtraction">Concatenation and Subtraction</h3>
<p>Fields from the right-most structure overwrite existing values.</p>
<pre><code class="language-python">a = struct(a=1, b=2)
b = struct(c=3, d=&quot;d&quot;, e=&quot;e&quot;)
c = a + b
e = c - a
</code></pre>
<hr>
<h3 id="practical-shorthands">Practical Shorthands</h3>
<h4 id="constructing-a-structure-from-keys">Constructing a Structure from Keys</h4>
<pre><code class="language-python">s = struct.fromkeys([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
# Output:
# --------
#      a: None
#      b: None
#      c: None
#      d: None
# --------
</code></pre>
<h4 id="building-a-structure-from-variables-in-a-string">Building a Structure from Variables in a String</h4>
<pre><code class="language-python">s = struct.scan(&quot;${a} + ${b} * ${c} / ${d} --- ${ee}&quot;)
s.a = 1
s.b = &quot;test&quot;
s.c = [1, &quot;a&quot;, 2]
s.generator()
# Output:
# X = struct(
#      a=1,
#      b=&quot;test&quot;,
#      c=[1, 'a', 2],
#      d=None,
#      ee=None
# )
</code></pre>
<h4 id="indexing-and-iteration">Indexing and Iteration</h4>
<p>Structures can be indexed or sliced like lists.</p>
<pre><code class="language-python">c = a + b
c[0]      # Access the first field
c[-1]     # Access the last field
c[:2]     # Slice the structure
for field in c:
    print(field)
</code></pre>
<hr>
<h3 id="dynamic-dependency-management">Dynamic Dependency Management</h3>
<p><code><a title="script.struct" href="#script.struct">struct</a></code> provides control over dependencies, sorting, and evaluation.</p>
<pre><code class="language-python">s = struct(d=3, e=&quot;${c} + {d}&quot;, c='${a} + ${b}', a=1, b=2)
s.sortdefinitions()
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}
#      e: ${c} + ${d}
# --------
</code></pre>
<p>For dynamic evaluation, use <code><a title="script.param" href="#script.param">param</a></code>:</p>
<pre><code class="language-python">p = param(sortdefinitions=True, d=3, e=&quot;${c} + ${d}&quot;, c='${a} + ${b}', a=1, b=2)
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}  (= 3)
#      e: ${c} + ${d}  (= 6)
# --------
</code></pre>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two structures (<code>__add__</code>).</li>
<li><code>-</code>: Subtraction of fields (<code>__sub__</code>).</li>
<li><code>len()</code>: Number of fields (<code>__len__</code>).</li>
<li><code>in</code>: Check for field existence (<code>__contains__</code>).</li>
</ul>
<h4 id="method-overview">Method Overview</h4>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>check(default)</code></td>
<td>Populate fields with defaults if missing.</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>Remove all fields.</td>
</tr>
<tr>
<td><code>dict2struct(dico)</code></td>
<td>Create a structure from a dictionary.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display the structure.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate expressions within fields.</td>
</tr>
<tr>
<td><code>fromkeys(keys)</code></td>
<td>Create a structure from a list of keys.</td>
</tr>
<tr>
<td><code>generator()</code></td>
<td>Generate Python code representing the structure.</td>
</tr>
<tr>
<td><code>items()</code></td>
<td>Return key-value pairs.</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>Return all keys in the structure.</td>
</tr>
<tr>
<td><code>read(file)</code></td>
<td>Load structure fields from a file.</td>
</tr>
<tr>
<td><code>scan(string)</code></td>
<td>Extract variables from a string and populate fields.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>struct2dict()</code></td>
<td>Convert the structure to a dictionary.</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>Return all field values.</td>
</tr>
<tr>
<td><code>write(file)</code></td>
<td>Save the structure to a file.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="dynamic-properties">Dynamic Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isempty</code></td>
<td><code>True</code> if the structure is empty.</td>
</tr>
<tr>
<td><code>isdefined</code></td>
<td><code>True</code> if all fields are defined.</td>
</tr>
</tbody>
</table>
<hr>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class struct():
    &#34;&#34;&#34;
    Class: `struct`
    ================

    A lightweight class that mimics Matlab-like structures, with additional features
    such as dynamic field creation, indexing, concatenation, and compatibility with
    evaluated parameters (`param`).

    ---

    ### Features
    - Dynamic creation of fields.
    - Indexing and iteration support for fields.
    - Concatenation and subtraction of structures.
    - Conversion to and from dictionaries.
    - Compatible with `param` and `paramauto` for evaluation and dependency handling.

    ---

    ### Examples

    #### Basic Usage
    ```python
    s = struct(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    print(s.a)  # 1
    s.d = 11    # Append a new field
    delattr(s, &#39;d&#39;)  # Delete the field
    ```

    #### Using `param` for Evaluation
    ```python
    p = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    p.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    # --------
    ```

    ---

    ### Concatenation and Subtraction
    Fields from the right-most structure overwrite existing values.
    ```python
    a = struct(a=1, b=2)
    b = struct(c=3, d=&#34;d&#34;, e=&#34;e&#34;)
    c = a + b
    e = c - a
    ```

    ---

    ### Practical Shorthands

    #### Constructing a Structure from Keys
    ```python
    s = struct.fromkeys([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;])
    # Output:
    # --------
    #      a: None
    #      b: None
    #      c: None
    #      d: None
    # --------
    ```

    #### Building a Structure from Variables in a String
    ```python
    s = struct.scan(&#34;${a} + ${b} * ${c} / ${d} --- ${ee}&#34;)
    s.a = 1
    s.b = &#34;test&#34;
    s.c = [1, &#34;a&#34;, 2]
    s.generator()
    # Output:
    # X = struct(
    #      a=1,
    #      b=&#34;test&#34;,
    #      c=[1, &#39;a&#39;, 2],
    #      d=None,
    #      ee=None
    # )
    ```

    #### Indexing and Iteration
    Structures can be indexed or sliced like lists.
    ```python
    c = a + b
    c[0]      # Access the first field
    c[-1]     # Access the last field
    c[:2]     # Slice the structure
    for field in c:
        print(field)
    ```

    ---

    ### Dynamic Dependency Management
    `struct` provides control over dependencies, sorting, and evaluation.

    ```python
    s = struct(d=3, e=&#34;${c} + {d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    s.sortdefinitions()
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}
    #      e: ${c} + ${d}
    # --------
    ```

    For dynamic evaluation, use `param`:
    ```python
    p = param(sortdefinitions=True, d=3, e=&#34;${c} + ${d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}  (= 3)
    #      e: ${c} + ${d}  (= 6)
    # --------
    ```

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two structures (`__add__`).
    - `-`: Subtraction of fields (`__sub__`).
    - `len()`: Number of fields (`__len__`).
    - `in`: Check for field existence (`__contains__`).

    #### Method Overview
    | Method                | Description                                             |
    |-----------------------|---------------------------------------------------------|
    | `check(default)`      | Populate fields with defaults if missing.               |
    | `clear()`             | Remove all fields.                                      |
    | `dict2struct(dico)`   | Create a structure from a dictionary.                   |
    | `disp()`              | Display the structure.                                  |
    | `eval()`              | Evaluate expressions within fields.                     |
    | `fromkeys(keys)`      | Create a structure from a list of keys.                 |
    | `generator()`         | Generate Python code representing the structure.        |
    | `items()`             | Return key-value pairs.                                 |
    | `keys()`              | Return all keys in the structure.                       |
    | `read(file)`          | Load structure fields from a file.                      |
    | `scan(string)`        | Extract variables from a string and populate fields.    |
    | `sortdefinitions()`   | Sort fields to resolve dependencies.                    |
    | `struct2dict()`       | Convert the structure to a dictionary.                  |
    | `values()`            | Return all field values.                                |
    | `write(file)`         | Save the structure to a file.                           |

    ---

    ### Dynamic Properties
    | Property    | Description                            |
    |-------------|----------------------------------------|
    | `isempty`   | `True` if the structure is empty.      |
    | `isdefined` | `True` if all fields are defined.      |

    ---
    &#34;&#34;&#34;

    # attributes to be overdefined
    _type = &#34;struct&#34;        # object type
    _fulltype = &#34;structure&#34; # full name
    _ftype = &#34;field&#34;        # field name
    _evalfeature = False    # true if eval() is available
    _maxdisplay = 40        # maximum number of characters to display (should be even)
    _propertyasattribute = False

    # attributes for the iterator method
    # Please keep it static, duplicate the object before changing _iter_
    _iter_ = 0

    # excluded attributes (keep the , in the Tupple if it is singleton)
    _excludedattr = {&#39;_iter_&#39;,&#39;__class__&#39;,&#39;_protection&#39;,&#39;_evaluation&#39;,&#39;_returnerror&#39;,&#39;_debug&#39;} # used by keys() and len()


    # Methods
    def __init__(self,debug=False,**kwargs):
        &#34;&#34;&#34; constructor, use debug=True to report eval errors&#34;&#34;&#34;
        # Optionally extend _excludedattr here
        self._excludedattr = self._excludedattr | {&#39;_excludedattr&#39;, &#39;_type&#39;, &#39;_fulltype&#39;,&#39;_ftype&#39;} # addition 2024-10-11
        self._debug = debug
        self.set(**kwargs)

    def zip(self):
        &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
        return zip(self.keys(),self.values())

    @staticmethod
    def dict2struct(dico,makeparam=False):
        &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
        if isinstance(dico,dict):
            s = param() if makeparam else struct()
            s.set(**dico)
            return s
        raise TypeError(&#34;the argument must be a dictionary&#34;)

    def struct2dict(self):
        &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
        return dict(self.zip())

    def struct2param(self,protection=False,evaluation=True):
        &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
        p = param(**self.struct2dict())
        for i in range(len(self)):
            if isinstance(self[i],pstr): p[i] = pstr(p[i])
        p._protection = protection
        p._evaluation = evaluation
        return p

    def set(self,**kwargs):
        &#34;&#34;&#34; initialization &#34;&#34;&#34;
        self.__dict__.update(kwargs)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value

    def getattr(self,key):
        &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
        if key in self.__dict__:
            return self.__dict__[key]
        elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
             key not in self._excludedattr and \
             key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
            # If _propertyasattribute is True and it&#39;s a property, get its value
            return self.__class__.__dict__[key].fget(self)
        else:
            raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)

    def hasattr(self, key):
        &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
        return key in self.__dict__ or (
            getattr(self, &#39;_propertyasattribute&#39;, False) and
            key not in self._excludedattr and
            key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
        )

    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return pstr.eval(self.getattr(key))

    def __setattr__(self,key,value):
        &#34;&#34;&#34; set attribute override &#34;&#34;&#34;
        self.setattr(key,value)

    def __contains__(self,item):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(item)

    def keys(self):
        &#34;&#34;&#34; return the fields &#34;&#34;&#34;
        # keys() is used by struct() and its iterator
        return [key for key in self.__dict__.keys() if key not in self._excludedattr]

    def keyssorted(self,reverse=True):
        &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
        klist = self.keys()
        l = [len(k) for k in klist]
        return [k for _,k in sorted(zip(l,klist),reverse=reverse)]

    def values(self):
        &#34;&#34;&#34; return the values &#34;&#34;&#34;
        # values() is used by struct() and its iterator
        return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]

    @staticmethod
    def fromkeysvalues(keys,values,makeparam=False):
        &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
            use makeparam = True to create a param instead of struct
        &#34;&#34;&#34;
        if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
        if not isinstance(keys,_list_types): keys = [keys]
        if not isinstance(values,_list_types): values = [values]
        nk,nv = len(keys), len(values)
        s = param() if makeparam else struct()
        if nk&gt;0 and nv&gt;0:
            iv = 0
            for ik in range(nk):
                s.setattr(keys[ik], values[iv])
                iv = min(nv-1,iv+1)
            for ik in range(nk,nv):
                s.setattr(f&#34;key{ik}&#34;, values[ik])
        return s

    def items(self):
        &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
        return self.zip()

    def __getitem__(self,idx):
        &#34;&#34;&#34;
            s[i] returns the ith element of the structure
            s[:4] returns a structure with the four first fields
            s[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.getattr(self.keys()[idx])
            raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            return struct.fromkeysvalues(self.keys()[idx], self.values()[idx])
        elif isinstance(idx,(list,tuple)):
            k,v= self.keys(), self.values()
            nk = len(k)
            s = param() if isinstance(self,param) else struct()
            for i in idx:
                if isinstance(i,int) and i&gt;=0 and i&lt;nk:
                    s.setattr(k[i],v[i])
                else:
                    raise IndexError(&#34;idx must contains only integers ranged between 0 and %d&#34; % (nk-1))
            return s
        elif isinstance(idx,str):
            return self.getattr(idx)
        else:
            raise TypeError(&#34;The index must be an integer or a slice and not a %s&#34; % type(idx).__name__)

    def __setitem__(self,idx,value):
        &#34;&#34;&#34; set the ith element of the structure  &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                self.setattr(self.keys()[idx], value)
            else:
                raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            k = self.keys()[idx]
            if len(value)&lt;=1:
                for i in range(len(k)): self.setattr(k[i], value)
            elif len(k) == len(value):
                for i in range(len(k)): self.setattr(k[i], value[i])
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of elements in the slive (%d)&#34; \
                       % (len(value),len(idx)))
        elif isinstance(idx,(list,tuple)):
            if len(value)&lt;=1:
                for i in range(len(idx)): self[idx[i]]=value
            elif len(idx) == len(value):
                for i in range(len(idx)): self[idx[i]]=value[i]
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of indices (%d)&#34; \
                                 % (len(value),len(idx)))

    def __len__(self):
        &#34;&#34;&#34; return the number of fields &#34;&#34;&#34;
        # len() is used by struct() and its iterator
        return len(self.keys())

    def __iter__(self):
        &#34;&#34;&#34; struct iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    def __next__(self):
        &#34;&#34;&#34; increment iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum {self._ftype} iteration reached {len(self)}&#34;)

    def __add__(self,s,sortdefinitions=False,raiseerror=True, silentmode=True):
        &#34;&#34;&#34; add a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        dup.__dict__.update(s.__dict__)
        if sortdefinitions: dup.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return dup

    def __iadd__(self,s,sortdefinitions=False,raiseerror=False, silentmode=True):
        &#34;&#34;&#34; iadd a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        self.__dict__.update(s.__dict__)
        if sortdefinitions: self.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return self

    def __sub__(self,s):
        &#34;&#34;&#34; sub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        listofkeys = dup.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(dup,k)
        return dup

    def __isub__(self,s):
        &#34;&#34;&#34; isub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        listofkeys = self.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(self,k)
        return self

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        if self.__dict__=={}:
            print(f&#34;empty {self._fulltype} ({self._type} object) with no {self._type}s&#34;)
            return f&#34;empty {self._fulltype}&#34;
        else:
            tmp = self.eval() if self._evalfeature else []
            keylengths = [len(key) for key in self.__dict__]
            width = max(10,max(keylengths)+2)
            fmt = &#34;%%%ss:&#34; % width
            fmteval = fmt[:-1]+&#34;=&#34;
            fmtcls =  fmt[:-1]+&#34;:&#34;
            line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
            print(line)
            for key,value in self.__dict__.items():
                if key not in self._excludedattr:
                    if isinstance(value,_numeric_types):
                        # old code (removed on 2025-01-18)
                        # if isinstance(value,pstr):
                        #     print(fmt % key,&#39;p&#34;&#39;+self.dispmax(value)+&#39;&#34;&#39;)
                        # if isinstance(value,str) and value==&#34;&#34;:
                        #     print(fmt % key,&#39;&#34;&#34;&#39;)
                        # else:
                        #     print(fmt % key,self.dispmax(value))
                        if isinstance(value,np.ndarray):
                            print(fmt % key, struct.format_array(value))
                        else:
                            print(fmt % key,self.dispmax(value))
                    elif isinstance(value,struct):
                        print(fmt % key,self.dispmax(value.__str__()))
                    elif isinstance(value,type):
                        print(fmt % key,self.dispmax(str(value)))
                    else:
                        print(fmt % key,type(value))
                        print(fmtcls % &#34;&#34;,self.dispmax(str(value)))
                    if self._evalfeature:
                        if isinstance(self,paramauto):
                            try:
                                if isinstance(value,pstr):
                                    print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                                elif isinstance(value,str):
                                    if value == &#34;&#34;:
                                        print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(tmp.getattr(key)))
                            except Exception as err:
                                print(fmteval % &#34;&#34;,err.message, err.args)
                        else:
                            if isinstance(value,pstr):
                                print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                            elif isinstance(value,str):
                                if value == &#34;&#34;:
                                    print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                else:
                                    calcvalue =tmp.getattr(key)
                                    if isinstance(calcvalue, str) and &#34;error&#34; in calcvalue.lower():
                                        print(fmteval % &#34;&#34;,calcvalue)
                                    else:
                                        if isinstance(calcvalue,np.ndarray):
                                            print(fmteval % &#34;&#34;, struct.format_array(calcvalue))
                                        else:
                                            print(fmteval % &#34;&#34;,self.dispmax(calcvalue))
            print(line)
            return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    def disp(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        self.__repr__()

    def __str__(self):
        return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    @property
    def isempty(self):
        &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
        return len(self)==0

    def clear(self):
        &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
        for k in self.keys(): delattr(self,k)

    def format(self, s, escape=False, raiseerror=True):
        &#34;&#34;&#34;
            Format a string with fields using {field} as placeholders.
            Handles expressions like ${variable1}.

            Args:
                s (str): The input string to format.
                escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
                raiseerror (bool): If True, raises errors for missing fields.

            Note:
                NumPy vectors and matrices are converted into their text representation (default behavior)
                If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

            Returns:
                str: The formatted string.
        &#34;&#34;&#34;
        tmp = self.np2str()
        if raiseerror:
            try:
                if escape:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.format_map(AttrErrorDict(self.__dict__))
                else:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
            except AttributeError as attr_err:
                # Handle AttributeError for expressions with operators
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
                return s_  # Revert to using &#39;${&#39; for unresolved expressions
            except IndexError as idx_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
                raise IndexError from idx_err
            except Exception as other_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                raise RuntimeError from other_err
        else:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except:  # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))

    def format_legacy(self,s,escape=False,raiseerror=True):
        &#34;&#34;&#34;
            format a string with field (use {field} as placeholders)
                s.replace(string), s.replace(string,escape=True)
                where:
                    s is a struct object
                    string is a string with possibly ${variable1}
                    escape is a flag to prevent ${} replaced by {}
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format(**self.__dict__)
                else:
                    return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
            except KeyError as kerr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
                return s_ # instead of s (we put back $) - OV 2023/01/27
            except Exception as othererr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                raise RuntimeError from othererr
        else:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)

    def fromkeys(self,keys):
        &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
        return self+struct(**dict.fromkeys(keys,None))

    @staticmethod
    def scan(s):
        &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
        tmp = struct()
        #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
        found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
        uniq = []
        for x in found:
            if x not in uniq: uniq.append(x)
        return tmp.fromkeys(uniq)

    @staticmethod
    def isstrexpression(s):
        &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        return re.search(r&#34;\$\{.*?\}&#34;,s) is not None

    @property
    def isexpression(self):
        &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        for k,v in self.items():
            if isinstance(v,str):
                s.setattr(k,struct.isstrexpression(v))
            else:
                s.setattr(k,False)
        return s

    @staticmethod
    def isstrdefined(s,ref):
        &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        if struct.isstrexpression(s):
            k = struct.scan(s).keys()
            allfound,i,nk = True,0,len(k)
            while (i&lt;nk) and allfound:
                allfound = k[i] in ref
                i += 1
            return allfound
        else:
            return False


    def isdefined(self,ref=None):
        &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
        nk = len(k)
        if ref is None:
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
                else:
                    s.setattr(k[i],True)
        else:
            if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],ref))
                else:
                    s.setattr(k[i],True)
        return s

    def sortdefinitions(self,raiseerror=True,silentmode=False):
        &#34;&#34;&#34; sortdefintions sorts all definitions
            so that they can be executed as param().
            If any inconsistency is found, an error message is generated.

            Flags = default values
                raiseerror=True show erros of True
                silentmode=False no warning if True
        &#34;&#34;&#34;
        find = lambda xlist: [i for i, x in enumerate(xlist) if x]
        findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
        k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
        istatic = findnot(isexpr)
        idynamic = find(isexpr)
        static = struct.fromkeysvalues(
            [ k[i] for i in istatic ],
            [ v[i] for i in istatic ],
            makeparam = False)
        dynamic = struct.fromkeysvalues(
            [ k[i] for i in idynamic ],
            [ v[i] for i in idynamic ],
            makeparam=False)
        current = static # make static the current structure
        nmissing, anychange, errorfound = len(dynamic), False, False
        while nmissing:
            itst, found = 0, False
            while itst&lt;nmissing and not found:
                teststruct = current + dynamic[[itst]] # add the test field
                found = all(list(teststruct.isdefined()))
                ifound = itst
                itst += 1
            if found:
                current = teststruct # we accept the new field
                dynamic[ifound] = []
                nmissing -= 1
                anychange = True
            else:
                if raiseerror:
                    raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                                   (nmissing,len(self),self._ftype))
                else:
                    if (not errorfound) and (not silentmode):
                        print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                              (nmissing,len(self),self._ftype))
                    current = teststruct # we accept the new field (even if it cannot be interpreted)
                    dynamic[ifound] = []
                    nmissing -= 1
                    errorfound = True
        if anychange:
            self.clear() # reset all fields and assign them in the proper order
            k,v = current.keys(), current.values()
            for i in range(len(k)):
                self.setattr(k[i],v[i])

    def generator(self):
        &#34;&#34;&#34; generate Python code of the equivalent structure &#34;&#34;&#34;
        nk = len(self)
        if nk==0:
            print(&#34;X = struct()&#34;)
        else:
            ik = 0
            fmt = &#34;%%%ss=&#34; % max(10,max([len(k) for k in self.keys()])+2)
            print(&#34;\nX = struct(&#34;)
            for k in self.keys():
                ik += 1
                end = &#34;,\n&#34; if ik&lt;nk else &#34;\n&#34;+(fmt[:-1] % &#34;)&#34;)+&#34;\n&#34;
                v = getattr(self,k)
                if isinstance(v,(int,float)) or v == None:
                    print(fmt % k,v,end=end)
                elif isinstance(v,str):
                    print(fmt % k,f&#39;&#34;{v}&#34;&#39;,end=end)
                elif isinstance(v,(list,tuple)):
                    print(fmt % k,v,end=end)
                else:
                    print(fmt % k,&#34;/* unsupported type */&#34;,end=end)

    # copy and deep copy methpds for the class
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, duplicatedeep(v, memo))
        return copie


    # write a file
    def write(self, file, overwrite=True, mkdir=False):
        &#34;&#34;&#34;
            write the equivalent structure (not recursive for nested struct)
                write(filename, overwrite=True, mkdir=False)

            Parameters:
            - file: The file path to write to.
            - overwrite: Whether to overwrite the file if it exists (default: True).
            - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()

        # Check if the directory exists or if mkdir is set to True, create it
        if mkdir:
            file_path.parent.mkdir(parents=True, exist_ok=True)
        elif not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If overwrite is False and the file already exists, raise an exception
        if not overwrite and file_path.exists():
            raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
        # Open and write to the file using the resolved path
        with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
            print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
            for k, v in self.items():
                if v is None:
                    print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
                elif isinstance(v, (int, float)):
                    print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
                elif isinstance(v, str):
                    print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
                else:
                    print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)


    # read a file
    @staticmethod
    def read(file):
        &#34;&#34;&#34;
            read the equivalent structure
                read(filename)

            Parameters:
            - file: The file path to read from.
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()
        # Check if the parent directory exists, otherwise raise an error
        if not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If the file does not exist, raise an exception
        if not file_path.exists():
            raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
        # Open and read the file
        with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            s = struct()  # Assuming struct is defined elsewhere
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                expr = line.split(sep=&#34;=&#34;)
                if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                    lhs = expr[0]
                    rhs = &#34;&#34;.join(expr[1:]).strip()
                    if len(rhs) == 0 or rhs == &#34;None&#34;:
                        v = None
                    else:
                        v = eval(rhs)
                    s.setattr(lhs, v)
        return s

    # argcheck
    def check(self,default):
        &#34;&#34;&#34;
        populate fields from a default structure
            check(defaultstruct)
            missing field, None and [] values are replaced by default ones

            Note: a.check(b) is equivalent to b+a except for [] and None values
        &#34;&#34;&#34;
        if not isinstance(default,struct):
            raise TypeError(&#34;the first argument must be a structure&#34;)
        for f in default.keys():
            ref = default.getattr(f)
            if f not in self:
                self.setattr(f, ref)
            else:
                current = self.getattr(f)
                if ((current is None)  or (current==[])) and \
                    ((ref is not None) and (ref!=[])):
                        self.setattr(f, ref)


    # update values based on key:value
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple fields at once, while protecting certain attributes.

        Parameters:
        -----------
        **kwargs : dict
            The fields to update and their new values.

        Protected attributes defined in _excludedattr are not updated.

        Usage:
        ------
        s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
        &#34;&#34;&#34;
        protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

        for key, value in kwargs.items():
            if key in protected_attributes:
                print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
            else:
                self.setattr(key, value)


    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract a sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            A new instance of the same class as the original, containing
            only the specified keys.

        Usage:
        ------
        sub_struct = s(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        # Create a new instance of the same class
        sub_struct = self.__class__()

        # Get the full type and field type for error messages
        fulltype = getattr(self, &#39;_fulltype&#39;, &#39;structure&#39;)
        ftype = getattr(self, &#39;_ftype&#39;, &#39;field&#39;)

        # Add only the specified keys to the new sub-structure
        for key in keys:
            if key in self:
                sub_struct.setattr(key, self.getattr(key))
            else:
                raise KeyError(f&#34;{fulltype} does not contain the {ftype} &#39;{key}&#39;.&#34;)

        return sub_struct


    def __delattr__(self, key):
        &#34;&#34;&#34; Delete an instance attribute if it exists and is not a class or excluded attribute. &#34;&#34;&#34;
        if key in self._excludedattr:
            raise AttributeError(f&#34;Cannot delete excluded attribute &#39;{key}&#39;&#34;)
        elif key in self.__class__.__dict__:  # Check if it&#39;s a class attribute
            raise AttributeError(f&#34;Cannot delete class attribute &#39;{key}&#39;&#34;)
        elif key in self.__dict__:  # Delete only if in instance&#39;s __dict__
            del self.__dict__[key]
        else:
            raise AttributeError(f&#34;{self._type} has no attribute &#39;{key}&#39;&#34;)


    # A la Matlab display method of vectors, matrices and ND-arrays
    @staticmethod
    def format_array(value):
        &#34;&#34;&#34;
        Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
        Recursively formats multi-dimensional arrays without introducing unwanted commas.

        Args:
            value (np.ndarray): The NumPy array to format.

        Returns:
            str: A formatted string representation of the array.
        &#34;&#34;&#34;
        dtype_str = {
            np.float64: &#34;double&#34;,
            np.float32: &#34;single&#34;,
            np.int32: &#34;int32&#34;,
            np.int64: &#34;int64&#34;,
            np.complex64: &#34;complex single&#34;,
            np.complex128: &#34;complex double&#34;,
        }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

        max_display = 10  # Maximum number of elements to display

        def format_recursive(arr):
            &#34;&#34;&#34;
            Recursively formats the array based on its dimensions.

            Args:
                arr (np.ndarray): The array or sub-array to format.

            Returns:
                str: Formatted string of the array.
            &#34;&#34;&#34;
            if arr.ndim == 0:
                return f&#34;{arr.item()}&#34;

            if arr.ndim == 1:
                if len(arr) &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in arr) + &#34;]&#34;
                else:
                    return f&#34;[{len(arr)} elements]&#34;

            if arr.ndim == 2:
                if arr.shape[1] == 1:
                    # Column vector
                    if arr.shape[0] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in arr) + &#34;]T&#34;
                    else:
                        return f&#34;[{arr.shape[0]}×1 vector]&#34;
                elif arr.shape[0] == 1:
                    # Row vector
                    if arr.shape[1] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in arr[0]) + &#34;]&#34;
                    else:
                        return f&#34;[1×{arr.shape[1]} vector]&#34;
                else:
                    # General matrix
                    return f&#34;[{arr.shape[0]}×{arr.shape[1]} matrix]&#34;

            # For higher dimensions
            shape_str = &#34;×&#34;.join(map(str, arr.shape))
            if arr.size &lt;= max_display:
                # Show full content
                if arr.ndim &gt; 2:
                    # Represent multi-dimensional arrays with nested brackets
                    return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
            return f&#34;[{shape_str} array ({dtype_str})]&#34;

        if value.size == 0:
            return &#34;[]&#34;

        if value.ndim == 0 or value.size == 1:
            return f&#34;{value.item()} ({dtype_str})&#34;

        if value.ndim == 1 or value.ndim == 2:
            # Use existing logic for vectors and matrices
            if value.ndim == 1:
                if len(value) &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{len(value)}×1 {dtype_str}]&#34;
            elif value.ndim == 2:
                rows, cols = value.shape
                if cols == 1:  # Column vector
                    if rows &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[{rows}×1 {dtype_str}]&#34;
                elif rows == 1:  # Row vector
                    if cols &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[1×{cols} {dtype_str}]&#34;
                else:  # General matrix
                    formatted = f&#34;[{rows}×{cols} {dtype_str}]&#34;
            return formatted

        # For higher-dimensional arrays
        if value.size &lt;= max_display:
            formatted = format_recursive(value)
        else:
            shape_str = &#34;×&#34;.join(map(str, value.shape))
            formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

        return formatted


    # convert all NumPy entries to &#34;nestable&#34; expressions
    def np2str(self):
        &#34;&#34;&#34; Convert all np entries of s into their string representations  &#34;&#34;&#34;
        out = struct()
        def format_numpy_result(value):
            &#34;&#34;&#34;
            Converts a NumPy array or scalar into a string representation:
            - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
            - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
            - Non-ndarray inputs are returned without modification.

            Args:
                value (np.ndarray, scalar, or other): The value to format.

            Returns:
                str or original type: A properly formatted string for NumPy arrays/scalars or the original value.
            &#34;&#34;&#34;
            if np.isscalar(value):
                # If the value is a scalar, return it directly
                return repr(value)
            elif isinstance(value, np.ndarray):
                # Check if the array has exactly one element
                if value.size == 1:
                    # Extract the scalar value
                    return repr(value.item())
                # Convert the array to a nested list
                nested_list = value.tolist()
                # Recursively format the nested list into a valid string
                def list_to_string(lst):
                    if isinstance(lst, list):
                        # Format lists with proper commas
                        return &#34;[&#34; + &#34;, &#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                    else:
                        # Format scalars in the list
                        return repr(lst)

                return list_to_string(nested_list)
            else:
                # Return the input unmodified if not a NumPy array or scalar
                return value
        # process all entries in s
        for key,value in self.items():
            out.setattr(key,format_numpy_result(value))
        return out</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.raster.collection</li>
<li>pizza.region.regioncollection</li>
<li>pizza.script.scriptobject</li>
<li>pizza.script.scriptobjectgroup</li>
<li><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></li>
<li><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="script.struct.dict2struct"><code class="name flex">
<span>def <span class="ident">dict2struct</span></span>(<span>dico, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>create a structure from a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dict2struct(dico,makeparam=False):
    &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
    if isinstance(dico,dict):
        s = param() if makeparam else struct()
        s.set(**dico)
        return s
    raise TypeError(&#34;the argument must be a dictionary&#34;)</code></pre>
</details>
</dd>
<dt id="script.struct.format_array"><code class="name flex">
<span>def <span class="ident">format_array</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
Recursively formats multi-dimensional arrays without introducing unwanted commas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The NumPy array to format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representation of the array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_array(value):
    &#34;&#34;&#34;
    Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
    Recursively formats multi-dimensional arrays without introducing unwanted commas.

    Args:
        value (np.ndarray): The NumPy array to format.

    Returns:
        str: A formatted string representation of the array.
    &#34;&#34;&#34;
    dtype_str = {
        np.float64: &#34;double&#34;,
        np.float32: &#34;single&#34;,
        np.int32: &#34;int32&#34;,
        np.int64: &#34;int64&#34;,
        np.complex64: &#34;complex single&#34;,
        np.complex128: &#34;complex double&#34;,
    }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

    max_display = 10  # Maximum number of elements to display

    def format_recursive(arr):
        &#34;&#34;&#34;
        Recursively formats the array based on its dimensions.

        Args:
            arr (np.ndarray): The array or sub-array to format.

        Returns:
            str: Formatted string of the array.
        &#34;&#34;&#34;
        if arr.ndim == 0:
            return f&#34;{arr.item()}&#34;

        if arr.ndim == 1:
            if len(arr) &lt;= max_display:
                return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in arr) + &#34;]&#34;
            else:
                return f&#34;[{len(arr)} elements]&#34;

        if arr.ndim == 2:
            if arr.shape[1] == 1:
                # Column vector
                if arr.shape[0] &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in arr) + &#34;]T&#34;
                else:
                    return f&#34;[{arr.shape[0]}×1 vector]&#34;
            elif arr.shape[0] == 1:
                # Row vector
                if arr.shape[1] &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in arr[0]) + &#34;]&#34;
                else:
                    return f&#34;[1×{arr.shape[1]} vector]&#34;
            else:
                # General matrix
                return f&#34;[{arr.shape[0]}×{arr.shape[1]} matrix]&#34;

        # For higher dimensions
        shape_str = &#34;×&#34;.join(map(str, arr.shape))
        if arr.size &lt;= max_display:
            # Show full content
            if arr.ndim &gt; 2:
                # Represent multi-dimensional arrays with nested brackets
                return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
        return f&#34;[{shape_str} array ({dtype_str})]&#34;

    if value.size == 0:
        return &#34;[]&#34;

    if value.ndim == 0 or value.size == 1:
        return f&#34;{value.item()} ({dtype_str})&#34;

    if value.ndim == 1 or value.ndim == 2:
        # Use existing logic for vectors and matrices
        if value.ndim == 1:
            if len(value) &lt;= max_display:
                formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
            else:
                formatted = f&#34;[{len(value)}×1 {dtype_str}]&#34;
        elif value.ndim == 2:
            rows, cols = value.shape
            if cols == 1:  # Column vector
                if rows &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{rows}×1 {dtype_str}]&#34;
            elif rows == 1:  # Row vector
                if cols &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[1×{cols} {dtype_str}]&#34;
            else:  # General matrix
                formatted = f&#34;[{rows}×{cols} {dtype_str}]&#34;
        return formatted

    # For higher-dimensional arrays
    if value.size &lt;= max_display:
        formatted = format_recursive(value)
    else:
        shape_str = &#34;×&#34;.join(map(str, value.shape))
        formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

    return formatted</code></pre>
</details>
</dd>
<dt id="script.struct.fromkeysvalues"><code class="name flex">
<span>def <span class="ident">fromkeysvalues</span></span>(<span>keys, values, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>struct.keysvalues(keys,values) creates a structure from keys and values
use makeparam = True to create a param instead of struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromkeysvalues(keys,values,makeparam=False):
    &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
        use makeparam = True to create a param instead of struct
    &#34;&#34;&#34;
    if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
    if not isinstance(keys,_list_types): keys = [keys]
    if not isinstance(values,_list_types): values = [values]
    nk,nv = len(keys), len(values)
    s = param() if makeparam else struct()
    if nk&gt;0 and nv&gt;0:
        iv = 0
        for ik in range(nk):
            s.setattr(keys[ik], values[iv])
            iv = min(nv-1,iv+1)
        for ik in range(nk,nv):
            s.setattr(f&#34;key{ik}&#34;, values[ik])
    return s</code></pre>
</details>
</dd>
<dt id="script.struct.isstrdefined"><code class="name flex">
<span>def <span class="ident">isstrdefined</span></span>(<span>s, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrdefined(string,ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrdefined(s,ref):
    &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
    if struct.isstrexpression(s):
        k = struct.scan(s).keys()
        allfound,i,nk = True,0,len(k)
        while (i&lt;nk) and allfound:
            allfound = k[i] in ref
            i += 1
        return allfound
    else:
        return False</code></pre>
</details>
</dd>
<dt id="script.struct.isstrexpression"><code class="name flex">
<span>def <span class="ident">isstrexpression</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrexpression(string) returns true if s contains an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrexpression(s):
    &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    return re.search(r&#34;\$\{.*?\}&#34;,s) is not None</code></pre>
</details>
</dd>
<dt id="script.struct.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>read the equivalent structure
read(filename)</p>
<p>Parameters:
- file: The file path to read from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read(file):
    &#34;&#34;&#34;
        read the equivalent structure
            read(filename)

        Parameters:
        - file: The file path to read from.
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()
    # Check if the parent directory exists, otherwise raise an error
    if not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If the file does not exist, raise an exception
    if not file_path.exists():
        raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
    # Open and read the file
    with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
        s = struct()  # Assuming struct is defined elsewhere
        while True:
            line = f.readline()
            if not line:
                break
            line = line.strip()
            expr = line.split(sep=&#34;=&#34;)
            if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                lhs = expr[0]
                rhs = &#34;&#34;.join(expr[1:]).strip()
                if len(rhs) == 0 or rhs == &#34;None&#34;:
                    v = None
                else:
                    v = eval(rhs)
                s.setattr(lhs, v)
    return s</code></pre>
</details>
</dd>
<dt id="script.struct.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>scan(string) scan a string for variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def scan(s):
    &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
    tmp = struct()
    #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
    found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
    uniq = []
    for x in found:
        if x not in uniq: uniq.append(x)
    return tmp.fromkeys(uniq)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="script.struct.isempty"><code class="name">var <span class="ident">isempty</span></code></dt>
<dd>
<div class="desc"><p>isempty is set to True for an empty structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isempty(self):
    &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
    return len(self)==0</code></pre>
</details>
</dd>
<dt id="script.struct.isexpression"><code class="name">var <span class="ident">isexpression</span></code></dt>
<dd>
<div class="desc"><p>same structure with True if it is an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isexpression(self):
    &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    for k,v in self.items():
        if isinstance(v,str):
            s.setattr(k,struct.isstrexpression(v))
        else:
            s.setattr(k,False)
    return s</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="script.struct.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, default)</span>
</code></dt>
<dd>
<div class="desc"><p>populate fields from a default structure
check(defaultstruct)
missing field, None and [] values are replaced by default ones</p>
<pre><code>Note: a.check(b) is equivalent to b+a except for [] and None values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self,default):
    &#34;&#34;&#34;
    populate fields from a default structure
        check(defaultstruct)
        missing field, None and [] values are replaced by default ones

        Note: a.check(b) is equivalent to b+a except for [] and None values
    &#34;&#34;&#34;
    if not isinstance(default,struct):
        raise TypeError(&#34;the first argument must be a structure&#34;)
    for f in default.keys():
        ref = default.getattr(f)
        if f not in self:
            self.setattr(f, ref)
        else:
            current = self.getattr(f)
            if ((current is None)  or (current==[])) and \
                ((ref is not None) and (ref!=[])):
                    self.setattr(f, ref)</code></pre>
</details>
</dd>
<dt id="script.struct.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear() delete all fields while preserving the original class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
    for k in self.keys(): delattr(self,k)</code></pre>
</details>
</dd>
<dt id="script.struct.disp"><code class="name flex">
<span>def <span class="ident">disp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>display method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disp(self):
    &#34;&#34;&#34; display method &#34;&#34;&#34;
    self.__repr__()</code></pre>
</details>
</dd>
<dt id="script.struct.dispmax"><code class="name flex">
<span>def <span class="ident">dispmax</span></span>(<span>self, content)</span>
</code></dt>
<dd>
<div class="desc"><p>optimize display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispmax(self,content):
    &#34;&#34;&#34; optimize display &#34;&#34;&#34;
    strcontent = str(content)
    if len(strcontent)&gt;self._maxdisplay:
        nchar = round(self._maxdisplay/2)
        return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
    else:
        return content</code></pre>
</details>
</dd>
<dt id="script.struct.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Format a string with fields using {field} as placeholders.
Handles expressions like ${variable1}.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>The input string to format.</dd>
<dt><strong><code>escape</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, prevents replacing '${' with '{'.</dd>
<dt><strong><code>raiseerror</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, raises errors for missing fields.</dd>
</dl>
<h2 id="note">Note</h2>
<p>NumPy vectors and matrices are converted into their text representation (default behavior)
If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, s, escape=False, raiseerror=True):
    &#34;&#34;&#34;
        Format a string with fields using {field} as placeholders.
        Handles expressions like ${variable1}.

        Args:
            s (str): The input string to format.
            escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
            raiseerror (bool): If True, raises errors for missing fields.

        Note:
            NumPy vectors and matrices are converted into their text representation (default behavior)
            If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

        Returns:
            str: The formatted string.
    &#34;&#34;&#34;
    tmp = self.np2str()
    if raiseerror:
        try:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
        except AttributeError as attr_err:
            # Handle AttributeError for expressions with operators
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
            return s_  # Revert to using &#39;${&#39; for unresolved expressions
        except IndexError as idx_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            if self._debug:
                print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
            raise IndexError from idx_err
        except Exception as other_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            raise RuntimeError from other_err
    else:
        if escape:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.format_map(AttrErrorDict(tmp.__dict__))
            except: # if an error occurs, we use the orginal content
                return s.format_map(AttrErrorDict(self.__dict__))
        else:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
            except:  # if an error occurs, we use the orginal content
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))</code></pre>
</details>
</dd>
<dt id="script.struct.format_legacy"><code class="name flex">
<span>def <span class="ident">format_legacy</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>format a string with field (use {field} as placeholders)
s.replace(string), s.replace(string,escape=True)
where:
s is a struct object
string is a string with possibly ${variable1}
escape is a flag to prevent ${} replaced by {}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_legacy(self,s,escape=False,raiseerror=True):
    &#34;&#34;&#34;
        format a string with field (use {field} as placeholders)
            s.replace(string), s.replace(string,escape=True)
            where:
                s is a struct object
                string is a string with possibly ${variable1}
                escape is a flag to prevent ${} replaced by {}
    &#34;&#34;&#34;
    if raiseerror:
        try:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
        except KeyError as kerr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
            return s_ # instead of s (we put back $) - OV 2023/01/27
        except Exception as othererr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            raise RuntimeError from othererr
    else:
        if escape:
            return s.format(**self.__dict__)
        else:
            return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)</code></pre>
</details>
</dd>
<dt id="script.struct.fromkeys"><code class="name flex">
<span>def <span class="ident">fromkeys</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a structure from keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromkeys(self,keys):
    &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
    return self+struct(**dict.fromkeys(keys,None))</code></pre>
</details>
</dd>
<dt id="script.struct.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>generate Python code of the equivalent structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self):
    &#34;&#34;&#34; generate Python code of the equivalent structure &#34;&#34;&#34;
    nk = len(self)
    if nk==0:
        print(&#34;X = struct()&#34;)
    else:
        ik = 0
        fmt = &#34;%%%ss=&#34; % max(10,max([len(k) for k in self.keys()])+2)
        print(&#34;\nX = struct(&#34;)
        for k in self.keys():
            ik += 1
            end = &#34;,\n&#34; if ik&lt;nk else &#34;\n&#34;+(fmt[:-1] % &#34;)&#34;)+&#34;\n&#34;
            v = getattr(self,k)
            if isinstance(v,(int,float)) or v == None:
                print(fmt % k,v,end=end)
            elif isinstance(v,str):
                print(fmt % k,f&#39;&#34;{v}&#34;&#39;,end=end)
            elif isinstance(v,(list,tuple)):
                print(fmt % k,v,end=end)
            else:
                print(fmt % k,&#34;/* unsupported type */&#34;,end=end)</code></pre>
</details>
</dd>
<dt id="script.struct.getattr"><code class="name flex">
<span>def <span class="ident">getattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get attribute override to access both instance attributes and properties if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getattr(self,key):
    &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
    if key in self.__dict__:
        return self.__dict__[key]
    elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
         key not in self._excludedattr and \
         key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
        # If _propertyasattribute is True and it&#39;s a property, get its value
        return self.__class__.__dict__[key].fget(self)
    else:
        raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)</code></pre>
</details>
</dd>
<dt id="script.struct.hasattr"><code class="name flex">
<span>def <span class="ident">hasattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the field exists, considering properties as regular attributes if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasattr(self, key):
    &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
    return key in self.__dict__ or (
        getattr(self, &#39;_propertyasattribute&#39;, False) and
        key not in self._excludedattr and
        key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
    )</code></pre>
</details>
</dd>
<dt id="script.struct.isdefined"><code class="name flex">
<span>def <span class="ident">isdefined</span></span>(<span>self, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>isdefined(ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdefined(self,ref=None):
    &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
    nk = len(k)
    if ref is None:
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
            else:
                s.setattr(k[i],True)
    else:
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],ref))
            else:
                s.setattr(k[i],True)
    return s</code></pre>
</details>
</dd>
<dt id="script.struct.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all elements as iterable key, value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
    return self.zip()</code></pre>
</details>
</dd>
<dt id="script.struct.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34; return the fields &#34;&#34;&#34;
    # keys() is used by struct() and its iterator
    return [key for key in self.__dict__.keys() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="script.struct.keyssorted"><code class="name flex">
<span>def <span class="ident">keyssorted</span></span>(<span>self, reverse=True)</span>
</code></dt>
<dd>
<div class="desc"><p>sort keys by length()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyssorted(self,reverse=True):
    &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
    klist = self.keys()
    l = [len(k) for k in klist]
    return [k for _,k in sorted(zip(l,klist),reverse=reverse)]</code></pre>
</details>
</dd>
<dt id="script.struct.np2str"><code class="name flex">
<span>def <span class="ident">np2str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all np entries of s into their string representations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def np2str(self):
    &#34;&#34;&#34; Convert all np entries of s into their string representations  &#34;&#34;&#34;
    out = struct()
    def format_numpy_result(value):
        &#34;&#34;&#34;
        Converts a NumPy array or scalar into a string representation:
        - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
        - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
        - Non-ndarray inputs are returned without modification.

        Args:
            value (np.ndarray, scalar, or other): The value to format.

        Returns:
            str or original type: A properly formatted string for NumPy arrays/scalars or the original value.
        &#34;&#34;&#34;
        if np.isscalar(value):
            # If the value is a scalar, return it directly
            return repr(value)
        elif isinstance(value, np.ndarray):
            # Check if the array has exactly one element
            if value.size == 1:
                # Extract the scalar value
                return repr(value.item())
            # Convert the array to a nested list
            nested_list = value.tolist()
            # Recursively format the nested list into a valid string
            def list_to_string(lst):
                if isinstance(lst, list):
                    # Format lists with proper commas
                    return &#34;[&#34; + &#34;, &#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                else:
                    # Format scalars in the list
                    return repr(lst)

            return list_to_string(nested_list)
        else:
            # Return the input unmodified if not a NumPy array or scalar
            return value
    # process all entries in s
    for key,value in self.items():
        out.setattr(key,format_numpy_result(value))
    return out</code></pre>
</details>
</dd>
<dt id="script.struct.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self,**kwargs):
    &#34;&#34;&#34; initialization &#34;&#34;&#34;
    self.__dict__.update(kwargs)</code></pre>
</details>
</dd>
<dt id="script.struct.setattr"><code class="name flex">
<span>def <span class="ident">setattr</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>set field and value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setattr(self,key,value):
    &#34;&#34;&#34; set field and value &#34;&#34;&#34;
    if isinstance(value,list) and len(value)==0 and key in self:
        delattr(self, key)
    else:
        self.__dict__[key] = value</code></pre>
</details>
</dd>
<dt id="script.struct.sortdefinitions"><code class="name flex">
<span>def <span class="ident">sortdefinitions</span></span>(<span>self, raiseerror=True, silentmode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>sortdefintions sorts all definitions
so that they can be executed as param().
If any inconsistency is found, an error message is generated.</p>
<p>Flags = default values
raiseerror=True show erros of True
silentmode=False no warning if True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortdefinitions(self,raiseerror=True,silentmode=False):
    &#34;&#34;&#34; sortdefintions sorts all definitions
        so that they can be executed as param().
        If any inconsistency is found, an error message is generated.

        Flags = default values
            raiseerror=True show erros of True
            silentmode=False no warning if True
    &#34;&#34;&#34;
    find = lambda xlist: [i for i, x in enumerate(xlist) if x]
    findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
    k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
    istatic = findnot(isexpr)
    idynamic = find(isexpr)
    static = struct.fromkeysvalues(
        [ k[i] for i in istatic ],
        [ v[i] for i in istatic ],
        makeparam = False)
    dynamic = struct.fromkeysvalues(
        [ k[i] for i in idynamic ],
        [ v[i] for i in idynamic ],
        makeparam=False)
    current = static # make static the current structure
    nmissing, anychange, errorfound = len(dynamic), False, False
    while nmissing:
        itst, found = 0, False
        while itst&lt;nmissing and not found:
            teststruct = current + dynamic[[itst]] # add the test field
            found = all(list(teststruct.isdefined()))
            ifound = itst
            itst += 1
        if found:
            current = teststruct # we accept the new field
            dynamic[ifound] = []
            nmissing -= 1
            anychange = True
        else:
            if raiseerror:
                raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                               (nmissing,len(self),self._ftype))
            else:
                if (not errorfound) and (not silentmode):
                    print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                          (nmissing,len(self),self._ftype))
                current = teststruct # we accept the new field (even if it cannot be interpreted)
                dynamic[ifound] = []
                nmissing -= 1
                errorfound = True
    if anychange:
        self.clear() # reset all fields and assign them in the proper order
        k,v = current.keys(), current.values()
        for i in range(len(k)):
            self.setattr(k[i],v[i])</code></pre>
</details>
</dd>
<dt id="script.struct.struct2dict"><code class="name flex">
<span>def <span class="ident">struct2dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create a dictionary from the current structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2dict(self):
    &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
    return dict(self.zip())</code></pre>
</details>
</dd>
<dt id="script.struct.struct2param"><code class="name flex">
<span>def <span class="ident">struct2param</span></span>(<span>self, protection=False, evaluation=True)</span>
</code></dt>
<dd>
<div class="desc"><p>convert an object struct() to param()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2param(self,protection=False,evaluation=True):
    &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
    p = param(**self.struct2dict())
    for i in range(len(self)):
        if isinstance(self[i],pstr): p[i] = pstr(p[i])
    p._protection = protection
    p._evaluation = evaluation
    return p</code></pre>
</details>
</dd>
<dt id="script.struct.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update multiple fields at once, while protecting certain attributes.</p>
<h2 id="parameters">Parameters:</h2>
<p>**kwargs : dict
The fields to update and their new values.</p>
<p>Protected attributes defined in _excludedattr are not updated.</p>
<h2 id="usage">Usage:</h2>
<p>s.update(a=10, b=[1, 2, 3], new_field="new_value")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update multiple fields at once, while protecting certain attributes.

    Parameters:
    -----------
    **kwargs : dict
        The fields to update and their new values.

    Protected attributes defined in _excludedattr are not updated.

    Usage:
    ------
    s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
    &#34;&#34;&#34;
    protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

    for key, value in kwargs.items():
        if key in protected_attributes:
            print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
        else:
            self.setattr(key, value)</code></pre>
</details>
</dd>
<dt id="script.struct.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34; return the values &#34;&#34;&#34;
    # values() is used by struct() and its iterator
    return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="script.struct.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, overwrite=True, mkdir=False)</span>
</code></dt>
<dd>
<div class="desc"><p>write the equivalent structure (not recursive for nested struct)
write(filename, overwrite=True, mkdir=False)</p>
<p>Parameters:
- file: The file path to write to.
- overwrite: Whether to overwrite the file if it exists (default: True).
- mkdir: Whether to create the directory if it doesn't exist (default: False).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, overwrite=True, mkdir=False):
    &#34;&#34;&#34;
        write the equivalent structure (not recursive for nested struct)
            write(filename, overwrite=True, mkdir=False)

        Parameters:
        - file: The file path to write to.
        - overwrite: Whether to overwrite the file if it exists (default: True).
        - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()

    # Check if the directory exists or if mkdir is set to True, create it
    if mkdir:
        file_path.parent.mkdir(parents=True, exist_ok=True)
    elif not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If overwrite is False and the file already exists, raise an exception
    if not overwrite and file_path.exists():
        raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
    # Open and write to the file using the resolved path
    with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
        print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
        for k, v in self.items():
            if v is None:
                print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
            elif isinstance(v, (int, float)):
                print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
            elif isinstance(v, str):
                print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
            else:
                print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="script.struct.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>zip keys and values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self):
    &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
    return zip(self.keys(),self.values())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="script.tlsph"><code class="flex name class">
<span>class <span class="ident">tlsph</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD:TLSPH forcefield (total Lagrangian)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tlsph(smd):
    &#34;&#34;&#34; SMD:TLSPH forcefield (total Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;tlsph&#34;)
    description = smd.description + struct(style=&#34;SMD:TLSPH - total Lagrangian for solids&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Diagonal pair coefficient tlsph
    pair_coeff      %d %d smd/tlsph *COMMON ${rho} ${E} ${nu} ${q1} ${q2} ${Hg} ${Cp} &amp;
                    *STRENGTH_LINEAR_PLASTIC ${sigma_yield} ${hardening} &amp;
                    *EOS_LINEAR &amp;
                    *END
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.saltTLSPH</li>
<li>pizza.forcefield.solidfood</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.tlsph.PAIR_DIAGCOEFF"><code class="name">var <span class="ident">PAIR_DIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.tlsph.PAIR_OFFDIAGCOEFF"><code class="name">var <span class="ident">PAIR_OFFDIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.tlsph.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.tlsph.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="script.ulsph"><code class="flex name class">
<span>class <span class="ident">ulsph</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD:ULSPH forcefield (updated Lagrangian)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ulsph(smd):
    &#34;&#34;&#34; SMD:ULSPH forcefield (updated Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;ulsph&#34;)
    description = smd.description + struct(style=&#34;SMD:ULSPH - updated Lagrangian for fluids - SPH-like&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Pair diagonal coefficient ulsph
    pair_coeff      %d %d smd/ulsph *COMMON ${rho} ${c0} ${q1} ${Cp} 0 &amp;
                    *EOS_TAIT ${taitexponent} &amp;
                    *END
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.water</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.ulsph.PAIR_DIAGCOEFF"><code class="name">var <span class="ident">PAIR_DIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.ulsph.PAIR_OFFDIAGCOEFF"><code class="name">var <span class="ident">PAIR_OFFDIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.ulsph.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.ulsph.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="script.water"><code class="flex name class">
<span>class <span class="ident">water</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>water material (smd:ulsph): generic water model
water()
water(beadtype=index, userid="myfluid", USER=&hellip;)</p>
<p>override any propery with USER.parameter (set only the parameters you want to override)
USER.rho: density in kg/m3 (default=1000)
USER.c0: speed of the sound in m/s (default=10.0)
USER.q1: standard artificial viscosity linear coefficient (default=1.0)
USER.Cp: heat capacity of material &ndash; not used here (default=1.0)
USER.contact_scale: scaling coefficient for contact (default=1.5)
USER.contact_stiffness: contact stifness in Pa (default="2.5<em>${c0}^2</em>${rho}")</p>
<p>water forcefield:
water(beadtype=index, userid="myfluid")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class water(ulsph):
    &#34;&#34;&#34; water material (smd:ulsph): generic water model
            water()
            water(beadtype=index, userid=&#34;myfluid&#34;, USER=...)

            override any propery with USER.parameter (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=1000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.q1: standard artificial viscosity linear coefficient (default=1.0)
                USER.Cp: heat capacity of material -- not used here (default=1.0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = ulsph.name + struct(material=&#34;water&#34;)
    description = ulsph.description + struct(material=&#34;water beads - SPH-like&#34;)
    userid = &#39;water&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; water forcefield:
            water(beadtype=index, userid=&#34;myfluid&#34;) &#34;&#34;&#34;
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # water-water interactions
            rho = 1000,
            c0 = 10.0,
            q1 = 1.0,
            Cp = 1.0,
            taitexponent = 7,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.ulsph</li>
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="script.water.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.water.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.water.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="script.water.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="script.frame_header" href="#script.frame_header">frame_header</a></code></li>
<li><code><a title="script.get_metadata" href="#script.get_metadata">get_metadata</a></code></li>
<li><code><a title="script.get_tmp_location" href="#script.get_tmp_location">get_tmp_location</a></code></li>
<li><code><a title="script.is_scalar" href="#script.is_scalar">is_scalar</a></code></li>
<li><code><a title="script.make_hashable" href="#script.make_hashable">make_hashable</a></code></li>
<li><code><a title="script.picker" href="#script.picker">picker</a></code></li>
<li><code><a title="script.remove_comments" href="#script.remove_comments">remove_comments</a></code></li>
<li><code><a title="script.span" href="#script.span">span</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="script.CallableScript" href="#script.CallableScript">CallableScript</a></code></h4>
</li>
<li>
<h4><code><a title="script.VariableOccurrences" href="#script.VariableOccurrences">VariableOccurrences</a></code></h4>
<ul class="">
<li><code><a title="script.VariableOccurrences.export" href="#script.VariableOccurrences.export">export</a></code></li>
<li><code><a title="script.VariableOccurrences.get_all_elements_in_lists" href="#script.VariableOccurrences.get_all_elements_in_lists">get_all_elements_in_lists</a></code></li>
<li><code><a title="script.VariableOccurrences.get_all_values" href="#script.VariableOccurrences.get_all_values">get_all_values</a></code></li>
<li><code><a title="script.VariableOccurrences.get_raw_data" href="#script.VariableOccurrences.get_raw_data">get_raw_data</a></code></li>
<li><code><a title="script.VariableOccurrences.get_steps_with_value" href="#script.VariableOccurrences.get_steps_with_value">get_steps_with_value</a></code></li>
<li><code><a title="script.VariableOccurrences.get_steps_with_value_in_scope" href="#script.VariableOccurrences.get_steps_with_value_in_scope">get_steps_with_value_in_scope</a></code></li>
<li><code><a title="script.VariableOccurrences.get_usage_count" href="#script.VariableOccurrences.get_usage_count">get_usage_count</a></code></li>
<li><code><a title="script.VariableOccurrences.summarize" href="#script.VariableOccurrences.summarize">summarize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.boundarysection" href="#script.boundarysection">boundarysection</a></code></h4>
<ul class="two-column">
<li><code><a title="script.boundarysection.DEFINITIONS" href="#script.boundarysection.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.boundarysection.TEMPLATE" href="#script.boundarysection.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.boundarysection.description" href="#script.boundarysection.description">description</a></code></li>
<li><code><a title="script.boundarysection.name" href="#script.boundarysection.name">name</a></code></li>
<li><code><a title="script.boundarysection.position" href="#script.boundarysection.position">position</a></code></li>
<li><code><a title="script.boundarysection.section" href="#script.boundarysection.section">section</a></code></li>
<li><code><a title="script.boundarysection.userid" href="#script.boundarysection.userid">userid</a></code></li>
<li><code><a title="script.boundarysection.version" href="#script.boundarysection.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.discretizationsection" href="#script.discretizationsection">discretizationsection</a></code></h4>
<ul class="two-column">
<li><code><a title="script.discretizationsection.DEFINITIONS" href="#script.discretizationsection.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.discretizationsection.TEMPLATE" href="#script.discretizationsection.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.discretizationsection.description" href="#script.discretizationsection.description">description</a></code></li>
<li><code><a title="script.discretizationsection.name" href="#script.discretizationsection.name">name</a></code></li>
<li><code><a title="script.discretizationsection.position" href="#script.discretizationsection.position">position</a></code></li>
<li><code><a title="script.discretizationsection.section" href="#script.discretizationsection.section">section</a></code></li>
<li><code><a title="script.discretizationsection.userid" href="#script.discretizationsection.userid">userid</a></code></li>
<li><code><a title="script.discretizationsection.version" href="#script.discretizationsection.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.dumpsection" href="#script.dumpsection">dumpsection</a></code></h4>
<ul class="two-column">
<li><code><a title="script.dumpsection.DEFINITIONS" href="#script.dumpsection.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.dumpsection.TEMPLATE" href="#script.dumpsection.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.dumpsection.description" href="#script.dumpsection.description">description</a></code></li>
<li><code><a title="script.dumpsection.name" href="#script.dumpsection.name">name</a></code></li>
<li><code><a title="script.dumpsection.position" href="#script.dumpsection.position">position</a></code></li>
<li><code><a title="script.dumpsection.section" href="#script.dumpsection.section">section</a></code></li>
<li><code><a title="script.dumpsection.userid" href="#script.dumpsection.userid">userid</a></code></li>
<li><code><a title="script.dumpsection.version" href="#script.dumpsection.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.forcefield" href="#script.forcefield">forcefield</a></code></h4>
<ul class="two-column">
<li><code><a title="script.forcefield.beadtype" href="#script.forcefield.beadtype">beadtype</a></code></li>
<li><code><a title="script.forcefield.description" href="#script.forcefield.description">description</a></code></li>
<li><code><a title="script.forcefield.getallattributes" href="#script.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.forcefield.name" href="#script.forcefield.name">name</a></code></li>
<li><code><a title="script.forcefield.pair_diagcoeff" href="#script.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="script.forcefield.pair_offdiagcoeff" href="#script.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="script.forcefield.pair_style" href="#script.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="script.forcefield.parameters" href="#script.forcefield.parameters">parameters</a></code></li>
<li><code><a title="script.forcefield.printheader" href="#script.forcefield.printheader">printheader</a></code></li>
<li><code><a title="script.forcefield.userid" href="#script.forcefield.userid">userid</a></code></li>
<li><code><a title="script.forcefield.version" href="#script.forcefield.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.geometrysection" href="#script.geometrysection">geometrysection</a></code></h4>
<ul class="two-column">
<li><code><a title="script.geometrysection.DEFINITIONS" href="#script.geometrysection.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.geometrysection.TEMPLATE" href="#script.geometrysection.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.geometrysection.description" href="#script.geometrysection.description">description</a></code></li>
<li><code><a title="script.geometrysection.name" href="#script.geometrysection.name">name</a></code></li>
<li><code><a title="script.geometrysection.position" href="#script.geometrysection.position">position</a></code></li>
<li><code><a title="script.geometrysection.section" href="#script.geometrysection.section">section</a></code></li>
<li><code><a title="script.geometrysection.userid" href="#script.geometrysection.userid">userid</a></code></li>
<li><code><a title="script.geometrysection.version" href="#script.geometrysection.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.globalsection" href="#script.globalsection">globalsection</a></code></h4>
<ul class="two-column">
<li><code><a title="script.globalsection.DEFINITIONS" href="#script.globalsection.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.globalsection.MATERIALS" href="#script.globalsection.MATERIALS">MATERIALS</a></code></li>
<li><code><a title="script.globalsection.TEMPLATE" href="#script.globalsection.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.globalsection.description" href="#script.globalsection.description">description</a></code></li>
<li><code><a title="script.globalsection.name" href="#script.globalsection.name">name</a></code></li>
<li><code><a title="script.globalsection.position" href="#script.globalsection.position">position</a></code></li>
<li><code><a title="script.globalsection.section" href="#script.globalsection.section">section</a></code></li>
<li><code><a title="script.globalsection.userid" href="#script.globalsection.userid">userid</a></code></li>
<li><code><a title="script.globalsection.version" href="#script.globalsection.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.initializesection" href="#script.initializesection">initializesection</a></code></h4>
<ul class="two-column">
<li><code><a title="script.initializesection.DEFINITIONS" href="#script.initializesection.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.initializesection.TEMPLATE" href="#script.initializesection.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.initializesection.description" href="#script.initializesection.description">description</a></code></li>
<li><code><a title="script.initializesection.name" href="#script.initializesection.name">name</a></code></li>
<li><code><a title="script.initializesection.position" href="#script.initializesection.position">position</a></code></li>
<li><code><a title="script.initializesection.section" href="#script.initializesection.section">section</a></code></li>
<li><code><a title="script.initializesection.userid" href="#script.initializesection.userid">userid</a></code></li>
<li><code><a title="script.initializesection.version" href="#script.initializesection.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.integrationsection" href="#script.integrationsection">integrationsection</a></code></h4>
<ul class="two-column">
<li><code><a title="script.integrationsection.DEFINITIONS" href="#script.integrationsection.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.integrationsection.TEMPLATE" href="#script.integrationsection.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.integrationsection.description" href="#script.integrationsection.description">description</a></code></li>
<li><code><a title="script.integrationsection.name" href="#script.integrationsection.name">name</a></code></li>
<li><code><a title="script.integrationsection.position" href="#script.integrationsection.position">position</a></code></li>
<li><code><a title="script.integrationsection.section" href="#script.integrationsection.section">section</a></code></li>
<li><code><a title="script.integrationsection.userid" href="#script.integrationsection.userid">userid</a></code></li>
<li><code><a title="script.integrationsection.version" href="#script.integrationsection.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.interactionsection" href="#script.interactionsection">interactionsection</a></code></h4>
<ul class="two-column">
<li><code><a title="script.interactionsection.DEFINITIONS" href="#script.interactionsection.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.interactionsection.TEMPLATE" href="#script.interactionsection.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.interactionsection.description" href="#script.interactionsection.description">description</a></code></li>
<li><code><a title="script.interactionsection.name" href="#script.interactionsection.name">name</a></code></li>
<li><code><a title="script.interactionsection.position" href="#script.interactionsection.position">position</a></code></li>
<li><code><a title="script.interactionsection.section" href="#script.interactionsection.section">section</a></code></li>
<li><code><a title="script.interactionsection.userid" href="#script.interactionsection.userid">userid</a></code></li>
<li><code><a title="script.interactionsection.version" href="#script.interactionsection.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.none" href="#script.none">none</a></code></h4>
<ul class="">
<li><code><a title="script.none.PAIR_DIAGCOEFF" href="#script.none.PAIR_DIAGCOEFF">PAIR_DIAGCOEFF</a></code></li>
<li><code><a title="script.none.PAIR_OFFDIAGCOEFF" href="#script.none.PAIR_OFFDIAGCOEFF">PAIR_OFFDIAGCOEFF</a></code></li>
<li><code><a title="script.none.description" href="#script.none.description">description</a></code></li>
<li><code><a title="script.none.name" href="#script.none.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.param" href="#script.param">param</a></code></h4>
<ul class="">
<li><code><a title="script.param.convert_matlab_like_arrays" href="#script.param.convert_matlab_like_arrays">convert_matlab_like_arrays</a></code></li>
<li><code><a title="script.param.escape" href="#script.param.escape">escape</a></code></li>
<li><code><a title="script.param.eval" href="#script.param.eval">eval</a></code></li>
<li><code><a title="script.param.expand_ranges" href="#script.param.expand_ranges">expand_ranges</a></code></li>
<li><code><a title="script.param.formateval" href="#script.param.formateval">formateval</a></code></li>
<li><code><a title="script.param.protect" href="#script.param.protect">protect</a></code></li>
<li><code><a title="script.param.replace_matrix_shorthand" href="#script.param.replace_matrix_shorthand">replace_matrix_shorthand</a></code></li>
<li><code><a title="script.param.safe_fstring" href="#script.param.safe_fstring">safe_fstring</a></code></li>
<li><code><a title="script.param.tostatic" href="#script.param.tostatic">tostatic</a></code></li>
<li><code><a title="script.param.tostruct" href="#script.param.tostruct">tostruct</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.paramauto" href="#script.paramauto">paramauto</a></code></h4>
</li>
<li>
<h4><code><a title="script.parameterforcefield" href="#script.parameterforcefield">parameterforcefield</a></code></h4>
</li>
<li>
<h4><code><a title="script.pipescript" href="#script.pipescript">pipescript</a></code></h4>
<ul class="">
<li><code><a title="script.pipescript.USER" href="#script.pipescript.USER">USER</a></code></li>
<li><code><a title="script.pipescript.clear" href="#script.pipescript.clear">clear</a></code></li>
<li><code><a title="script.pipescript.do" href="#script.pipescript.do">do</a></code></li>
<li><code><a title="script.pipescript.do_legacy" href="#script.pipescript.do_legacy">do_legacy</a></code></li>
<li><code><a title="script.pipescript.dscript" href="#script.pipescript.dscript">dscript</a></code></li>
<li><code><a title="script.pipescript.generate_report" href="#script.pipescript.generate_report">generate_report</a></code></li>
<li><code><a title="script.pipescript.getUSER" href="#script.pipescript.getUSER">getUSER</a></code></li>
<li><code><a title="script.pipescript.header" href="#script.pipescript.header">header</a></code></li>
<li><code><a title="script.pipescript.join" href="#script.pipescript.join">join</a></code></li>
<li><code><a title="script.pipescript.list_multiple_values" href="#script.pipescript.list_multiple_values">list_multiple_values</a></code></li>
<li><code><a title="script.pipescript.list_values" href="#script.pipescript.list_values">list_values</a></code></li>
<li><code><a title="script.pipescript.n" href="#script.pipescript.n">n</a></code></li>
<li><code><a title="script.pipescript.nrun" href="#script.pipescript.nrun">nrun</a></code></li>
<li><code><a title="script.pipescript.plot_multiple_value_distributions" href="#script.pipescript.plot_multiple_value_distributions">plot_multiple_value_distributions</a></code></li>
<li><code><a title="script.pipescript.rename" href="#script.pipescript.rename">rename</a></code></li>
<li><code><a title="script.pipescript.script" href="#script.pipescript.script">script</a></code></li>
<li><code><a title="script.pipescript.scripts" href="#script.pipescript.scripts">scripts</a></code></li>
<li><code><a title="script.pipescript.setUSER" href="#script.pipescript.setUSER">setUSER</a></code></li>
<li><code><a title="script.pipescript.write" href="#script.pipescript.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.rigidwall" href="#script.rigidwall">rigidwall</a></code></h4>
<ul class="">
<li><code><a title="script.rigidwall.description" href="#script.rigidwall.description">description</a></code></li>
<li><code><a title="script.rigidwall.name" href="#script.rigidwall.name">name</a></code></li>
<li><code><a title="script.rigidwall.userid" href="#script.rigidwall.userid">userid</a></code></li>
<li><code><a title="script.rigidwall.version" href="#script.rigidwall.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.runsection" href="#script.runsection">runsection</a></code></h4>
<ul class="two-column">
<li><code><a title="script.runsection.DEFINITIONS" href="#script.runsection.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.runsection.TEMPLATE" href="#script.runsection.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.runsection.description" href="#script.runsection.description">description</a></code></li>
<li><code><a title="script.runsection.name" href="#script.runsection.name">name</a></code></li>
<li><code><a title="script.runsection.position" href="#script.runsection.position">position</a></code></li>
<li><code><a title="script.runsection.section" href="#script.runsection.section">section</a></code></li>
<li><code><a title="script.runsection.userid" href="#script.runsection.userid">userid</a></code></li>
<li><code><a title="script.runsection.version" href="#script.runsection.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.saltTLSPH" href="#script.saltTLSPH">saltTLSPH</a></code></h4>
<ul class="">
<li><code><a title="script.saltTLSPH.description" href="#script.saltTLSPH.description">description</a></code></li>
<li><code><a title="script.saltTLSPH.name" href="#script.saltTLSPH.name">name</a></code></li>
<li><code><a title="script.saltTLSPH.userid" href="#script.saltTLSPH.userid">userid</a></code></li>
<li><code><a title="script.saltTLSPH.version" href="#script.saltTLSPH.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.script" href="#script.script">script</a></code></h4>
<ul class="two-column">
<li><code><a title="script.script.DEFINITIONS" href="#script.script.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.script.SECTIONS" href="#script.script.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="script.script.TEMPLATE" href="#script.script.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.script.description" href="#script.script.description">description</a></code></li>
<li><code><a title="script.script.detect_variables" href="#script.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="script.script.do" href="#script.script.do">do</a></code></li>
<li><code><a title="script.script.email" href="#script.script.email">email</a></code></li>
<li><code><a title="script.script.getallattributes" href="#script.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="script.script.header" href="#script.script.header">header</a></code></li>
<li><code><a title="script.script.license" href="#script.script.license">license</a></code></li>
<li><code><a title="script.script.metadata" href="#script.script.metadata">metadata</a></code></li>
<li><code><a title="script.script.name" href="#script.script.name">name</a></code></li>
<li><code><a title="script.script.position" href="#script.script.position">position</a></code></li>
<li><code><a title="script.script.printheader" href="#script.script.printheader">printheader</a></code></li>
<li><code><a title="script.script.role" href="#script.script.role">role</a></code></li>
<li><code><a title="script.script.section" href="#script.script.section">section</a></code></li>
<li><code><a title="script.script.tmpwrite" href="#script.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="script.script.type" href="#script.script.type">type</a></code></li>
<li><code><a title="script.script.userid" href="#script.script.userid">userid</a></code></li>
<li><code><a title="script.script.verbose" href="#script.script.verbose">verbose</a></code></li>
<li><code><a title="script.script.version" href="#script.script.version">version</a></code></li>
<li><code><a title="script.script.write" href="#script.script.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.scriptdata" href="#script.scriptdata">scriptdata</a></code></h4>
</li>
<li>
<h4><code><a title="script.scriptobject" href="#script.scriptobject">scriptobject</a></code></h4>
</li>
<li>
<h4><code><a title="script.scriptobjectgroup" href="#script.scriptobjectgroup">scriptobjectgroup</a></code></h4>
<ul class="two-column">
<li><code><a title="script.scriptobjectgroup.beadtype" href="#script.scriptobjectgroup.beadtype">beadtype</a></code></li>
<li><code><a title="script.scriptobjectgroup.filename" href="#script.scriptobjectgroup.filename">filename</a></code></li>
<li><code><a title="script.scriptobjectgroup.forcefield" href="#script.scriptobjectgroup.forcefield">forcefield</a></code></li>
<li><code><a title="script.scriptobjectgroup.group" href="#script.scriptobjectgroup.group">group</a></code></li>
<li><code><a title="script.scriptobjectgroup.group_generator" href="#script.scriptobjectgroup.group_generator">group_generator</a></code></li>
<li><code><a title="script.scriptobjectgroup.groupname" href="#script.scriptobjectgroup.groupname">groupname</a></code></li>
<li><code><a title="script.scriptobjectgroup.interactions" href="#script.scriptobjectgroup.interactions">interactions</a></code></li>
<li><code><a title="script.scriptobjectgroup.list" href="#script.scriptobjectgroup.list">list</a></code></li>
<li><code><a title="script.scriptobjectgroup.mass" href="#script.scriptobjectgroup.mass">mass</a></code></li>
<li><code><a title="script.scriptobjectgroup.max" href="#script.scriptobjectgroup.max">max</a></code></li>
<li><code><a title="script.scriptobjectgroup.min" href="#script.scriptobjectgroup.min">min</a></code></li>
<li><code><a title="script.scriptobjectgroup.minmax" href="#script.scriptobjectgroup.minmax">minmax</a></code></li>
<li><code><a title="script.scriptobjectgroup.n" href="#script.scriptobjectgroup.n">n</a></code></li>
<li><code><a title="script.scriptobjectgroup.name" href="#script.scriptobjectgroup.name">name</a></code></li>
<li><code><a title="script.scriptobjectgroup.script" href="#script.scriptobjectgroup.script">script</a></code></li>
<li><code><a title="script.scriptobjectgroup.select" href="#script.scriptobjectgroup.select">select</a></code></li>
<li><code><a title="script.scriptobjectgroup.str" href="#script.scriptobjectgroup.str">str</a></code></li>
<li><code><a title="script.scriptobjectgroup.struct" href="#script.scriptobjectgroup.struct">struct</a></code></li>
<li><code><a title="script.scriptobjectgroup.zip" href="#script.scriptobjectgroup.zip">zip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.smd" href="#script.smd">smd</a></code></h4>
<ul class="">
<li><code><a title="script.smd.PAIR_STYLE" href="#script.smd.PAIR_STYLE">PAIR_STYLE</a></code></li>
<li><code><a title="script.smd.description" href="#script.smd.description">description</a></code></li>
<li><code><a title="script.smd.name" href="#script.smd.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.solidfood" href="#script.solidfood">solidfood</a></code></h4>
<ul class="">
<li><code><a title="script.solidfood.description" href="#script.solidfood.description">description</a></code></li>
<li><code><a title="script.solidfood.name" href="#script.solidfood.name">name</a></code></li>
<li><code><a title="script.solidfood.userid" href="#script.solidfood.userid">userid</a></code></li>
<li><code><a title="script.solidfood.version" href="#script.solidfood.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.statussection" href="#script.statussection">statussection</a></code></h4>
<ul class="two-column">
<li><code><a title="script.statussection.DEFINITIONS" href="#script.statussection.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="script.statussection.TEMPLATE" href="#script.statussection.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="script.statussection.description" href="#script.statussection.description">description</a></code></li>
<li><code><a title="script.statussection.name" href="#script.statussection.name">name</a></code></li>
<li><code><a title="script.statussection.position" href="#script.statussection.position">position</a></code></li>
<li><code><a title="script.statussection.section" href="#script.statussection.section">section</a></code></li>
<li><code><a title="script.statussection.userid" href="#script.statussection.userid">userid</a></code></li>
<li><code><a title="script.statussection.version" href="#script.statussection.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.struct" href="#script.struct">struct</a></code></h4>
<ul class="two-column">
<li><code><a title="script.struct.check" href="#script.struct.check">check</a></code></li>
<li><code><a title="script.struct.clear" href="#script.struct.clear">clear</a></code></li>
<li><code><a title="script.struct.dict2struct" href="#script.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="script.struct.disp" href="#script.struct.disp">disp</a></code></li>
<li><code><a title="script.struct.dispmax" href="#script.struct.dispmax">dispmax</a></code></li>
<li><code><a title="script.struct.format" href="#script.struct.format">format</a></code></li>
<li><code><a title="script.struct.format_array" href="#script.struct.format_array">format_array</a></code></li>
<li><code><a title="script.struct.format_legacy" href="#script.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="script.struct.fromkeys" href="#script.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="script.struct.fromkeysvalues" href="#script.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="script.struct.generator" href="#script.struct.generator">generator</a></code></li>
<li><code><a title="script.struct.getattr" href="#script.struct.getattr">getattr</a></code></li>
<li><code><a title="script.struct.hasattr" href="#script.struct.hasattr">hasattr</a></code></li>
<li><code><a title="script.struct.isdefined" href="#script.struct.isdefined">isdefined</a></code></li>
<li><code><a title="script.struct.isempty" href="#script.struct.isempty">isempty</a></code></li>
<li><code><a title="script.struct.isexpression" href="#script.struct.isexpression">isexpression</a></code></li>
<li><code><a title="script.struct.isstrdefined" href="#script.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="script.struct.isstrexpression" href="#script.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="script.struct.items" href="#script.struct.items">items</a></code></li>
<li><code><a title="script.struct.keys" href="#script.struct.keys">keys</a></code></li>
<li><code><a title="script.struct.keyssorted" href="#script.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="script.struct.np2str" href="#script.struct.np2str">np2str</a></code></li>
<li><code><a title="script.struct.read" href="#script.struct.read">read</a></code></li>
<li><code><a title="script.struct.scan" href="#script.struct.scan">scan</a></code></li>
<li><code><a title="script.struct.set" href="#script.struct.set">set</a></code></li>
<li><code><a title="script.struct.setattr" href="#script.struct.setattr">setattr</a></code></li>
<li><code><a title="script.struct.sortdefinitions" href="#script.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="script.struct.struct2dict" href="#script.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="script.struct.struct2param" href="#script.struct.struct2param">struct2param</a></code></li>
<li><code><a title="script.struct.update" href="#script.struct.update">update</a></code></li>
<li><code><a title="script.struct.values" href="#script.struct.values">values</a></code></li>
<li><code><a title="script.struct.write" href="#script.struct.write">write</a></code></li>
<li><code><a title="script.struct.zip" href="#script.struct.zip">zip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.tlsph" href="#script.tlsph">tlsph</a></code></h4>
<ul class="">
<li><code><a title="script.tlsph.PAIR_DIAGCOEFF" href="#script.tlsph.PAIR_DIAGCOEFF">PAIR_DIAGCOEFF</a></code></li>
<li><code><a title="script.tlsph.PAIR_OFFDIAGCOEFF" href="#script.tlsph.PAIR_OFFDIAGCOEFF">PAIR_OFFDIAGCOEFF</a></code></li>
<li><code><a title="script.tlsph.description" href="#script.tlsph.description">description</a></code></li>
<li><code><a title="script.tlsph.name" href="#script.tlsph.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.ulsph" href="#script.ulsph">ulsph</a></code></h4>
<ul class="">
<li><code><a title="script.ulsph.PAIR_DIAGCOEFF" href="#script.ulsph.PAIR_DIAGCOEFF">PAIR_DIAGCOEFF</a></code></li>
<li><code><a title="script.ulsph.PAIR_OFFDIAGCOEFF" href="#script.ulsph.PAIR_OFFDIAGCOEFF">PAIR_OFFDIAGCOEFF</a></code></li>
<li><code><a title="script.ulsph.description" href="#script.ulsph.description">description</a></code></li>
<li><code><a title="script.ulsph.name" href="#script.ulsph.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="script.water" href="#script.water">water</a></code></h4>
<ul class="">
<li><code><a title="script.water.description" href="#script.water.description">description</a></code></li>
<li><code><a title="script.water.name" href="#script.water.name">name</a></code></li>
<li><code><a title="script.water.userid" href="#script.water.userid">userid</a></code></li>
<li><code><a title="script.water.version" href="#script.water.version">version</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>