<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>data3 API documentation</title>
<meta name="description" content="`data` Class â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>data3</code></h1>
</header>
<section id="section-intro">
<h1 id="data-class"><code><a title="data3.data" href="#data3.data">data</a></code> Class</h1>
<p>The <code><a title="data3.data" href="#data3.data">data</a></code> class provides tools to read, write, and manipulate LAMMPS data files, enabling seamless integration with the <code><a title="data3.dump" href="#data3.dump">dump</a></code> class for restart generation and simulation data management.</p>
<hr>
<h2 id="features">Features</h2>
<ul>
<li><strong>Input Handling</strong>:</li>
<li>Supports single or multiple data files, including gzipped files.</li>
<li>
<p>Create empty data objects or initialize from an existing <code><a title="data3.dump" href="#data3.dump">dump</a></code> object.</p>
</li>
<li>
<p><strong>Headers and Sections</strong>:</p>
</li>
<li>Access and modify headers, including atom counts and box dimensions.</li>
<li>
<p>Define, reorder, append, and replace columns in data file sections.</p>
</li>
<li>
<p><strong>Integration with <code><a title="data3.dump" href="#data3.dump">dump</a></code></strong>:</p>
</li>
<li>Generate restart files from <code><a title="data3.dump" href="#data3.dump">dump</a></code> snapshots.</li>
<li>
<p>Replace atomic positions and velocities in <code>Atoms</code> and <code>Velocities</code> sections.</p>
</li>
<li>
<p><strong>Visualization</strong>:</p>
</li>
<li>Extract atoms and bonds for visualization tools.</li>
<li>Iterate over single data file snapshots (compatible with <code><a title="data3.dump" href="#data3.dump">dump</a></code>).</li>
</ul>
<hr>
<h2 id="usage">Usage</h2>
<h3 id="initialization">Initialization</h3>
<ul>
<li>
<p><strong>From a File</strong>:
<code>python
d = data("data.poly")
# Read a LAMMPS data file</code></p>
</li>
<li>
<p><strong>Create an Empty Object</strong>:
<code>python
d = data()
# Create an empty data object</code></p>
</li>
<li>
<p><strong>From a <code><a title="data3.dump" href="#data3.dump">dump</a></code> Object</strong>:
<code>python
d = data(dump_obj, timestep)
# Generate data object from dump snapshot</code></p>
</li>
</ul>
<h3 id="accessing-data">Accessing Data</h3>
<ul>
<li>
<p><strong>Headers</strong>:
<code>python
d.headers["atoms"] = 1500
# Set atom count in header</code></p>
</li>
<li>
<p><strong>Sections</strong>:
<code>python
d.sections["Atoms"] = lines
# Define the &lt;code&gt;Atoms&lt;/code&gt; section</code></p>
</li>
</ul>
<h3 id="manipulation">Manipulation</h3>
<ul>
<li>
<p><strong>Column Mapping</strong>:
<code>python
d.map(1, "id", 3, "x")
# Assign names to columns</code></p>
</li>
<li>
<p><strong>Reorder Columns</strong>:
<code>python
d.reorder("Atoms", 1, 3, 2, 4)
# Reorder columns in a section</code></p>
</li>
<li>
<p><strong>Replace or Append Data</strong>:
<code>python
d.replace("Atoms", 5, vec)
# Replace a column in &lt;code&gt;Atoms&lt;/code&gt;
d.append("Atoms", vec)
# Append a new column to &lt;code&gt;Atoms&lt;/code&gt;</code></p>
</li>
<li>
<p><strong>Delete Headers or Sections</strong>:
<code>python
d.delete("Bonds")
# Remove the &lt;code&gt;Bonds&lt;/code&gt; section</code></p>
</li>
</ul>
<h3 id="output">Output</h3>
<ul>
<li><strong>Write to a File</strong>:
<code>python
d.write("data.new")
# Write the data object to a file</code></li>
</ul>
<h3 id="visualization">Visualization</h3>
<ul>
<li><strong>Extract Data for Visualization</strong>:
<code>python
time, box, atoms, bonds, tris, lines = d.viz(0)</code></li>
</ul>
<h3 id="integration-with-dump">Integration with <code><a title="data3.dump" href="#data3.dump">dump</a></code></h3>
<ul>
<li><strong>Replace Atomic Positions</strong>:
<code>python
d.newxyz(dump_obj, timestep)
# Replace atomic positions with &lt;code&gt;&lt;a title="data3.dump" href="#data3.dump"&gt;dump&lt;/a&gt;&lt;/code&gt; data</code></li>
</ul>
<hr>
<h2 id="examples">Examples</h2>
<h3 id="basic-usage">Basic Usage</h3>
<pre><code class="language-python">d = data(&quot;data.poly&quot;)             # Load a LAMMPS data file
d.headers[&quot;atoms&quot;] = 2000         # Update atom count
d.reorder(&quot;Atoms&quot;, 1, 3, 2, 4)    # Reorder columns in `Atoms`
d.write(&quot;data.new&quot;)               # Save to a new file
</code></pre>
<h3 id="restart-generation">Restart Generation</h3>
<pre><code class="language-python">dump_obj = dump(&quot;dump.poly&quot;)
d = data(dump_obj, 1000)          # Create data object from dump
d.write(&quot;data.restart&quot;)           # Write restart file
</code></pre>
<h3 id="visualization_1">Visualization</h3>
<pre><code class="language-python">time, box, atoms, bonds, tris, lines = d.viz(0)
</code></pre>
<hr>
<h2 id="properties">Properties</h2>
<ul>
<li><strong>Headers</strong>:</li>
<li><code>atoms</code>: Number of atoms in the data file.</li>
<li><code>atom types</code>: Number of atom types.</li>
<li>
<p><code>xlo xhi</code>, <code>ylo yhi</code>, <code>zlo zhi</code>: Box dimensions.</p>
</li>
<li>
<p><strong>Sections</strong>:</p>
</li>
<li><code>Atoms</code>: Atomic data (e.g., ID, type, coordinates).</li>
<li><code>Velocities</code>: Atomic velocities (optional).</li>
<li>Additional sections for bonds, angles, etc.</li>
</ul>
<hr>
<h2 id="notes">Notes</h2>
<ul>
<li><strong>Compatibility</strong>: Fully compatible with <code><a title="data3.dump" href="#data3.dump">dump</a></code> for restart and visualization tasks.</li>
<li><strong>Error Handling</strong>: Automatically validates headers and sections for consistency.</li>
<li><strong>Extensibility</strong>: Easily add or modify headers, sections, and attributes.</li>
</ul>
<hr>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
# `data` Class

The `data` class provides tools to read, write, and manipulate LAMMPS data files, enabling seamless integration with the `dump` class for restart generation and simulation data management.

---

## Features

- **Input Handling**:
  - Supports single or multiple data files, including gzipped files.
  - Create empty data objects or initialize from an existing `dump` object.

- **Headers and Sections**:
  - Access and modify headers, including atom counts and box dimensions.
  - Define, reorder, append, and replace columns in data file sections.

- **Integration with `dump`**:
  - Generate restart files from `dump` snapshots.
  - Replace atomic positions and velocities in `Atoms` and `Velocities` sections.

- **Visualization**:
  - Extract atoms and bonds for visualization tools.
  - Iterate over single data file snapshots (compatible with `dump`).

---

## Usage

### Initialization
- **From a File**:
  ```python
  d = data(&#34;data.poly&#34;)          # Read a LAMMPS data file
  ```

- **Create an Empty Object**:
  ```python
  d = data()                     # Create an empty data object
  ```

- **From a `dump` Object**:
  ```python
  d = data(dump_obj, timestep)   # Generate data object from dump snapshot
  ```

### Accessing Data
- **Headers**:
  ```python
  d.headers[&#34;atoms&#34;] = 1500       # Set atom count in header
  ```

- **Sections**:
  ```python
  d.sections[&#34;Atoms&#34;] = lines     # Define the `Atoms` section
  ```

### Manipulation
- **Column Mapping**:
  ```python
  d.map(1, &#34;id&#34;, 3, &#34;x&#34;)          # Assign names to columns
  ```

- **Reorder Columns**:
  ```python
  d.reorder(&#34;Atoms&#34;, 1, 3, 2, 4)  # Reorder columns in a section
  ```

- **Replace or Append Data**:
  ```python
  d.replace(&#34;Atoms&#34;, 5, vec)      # Replace a column in `Atoms`
  d.append(&#34;Atoms&#34;, vec)          # Append a new column to `Atoms`
  ```

- **Delete Headers or Sections**:
  ```python
  d.delete(&#34;Bonds&#34;)               # Remove the `Bonds` section
  ```

### Output
- **Write to a File**:
  ```python
  d.write(&#34;data.new&#34;)             # Write the data object to a file
  ```

### Visualization
- **Extract Data for Visualization**:
  ```python
  time, box, atoms, bonds, tris, lines = d.viz(0)
  ```

### Integration with `dump`
- **Replace Atomic Positions**:
  ```python
  d.newxyz(dump_obj, timestep)    # Replace atomic positions with `dump` data
  ```

---

## Examples

### Basic Usage
```python
d = data(&#34;data.poly&#34;)             # Load a LAMMPS data file
d.headers[&#34;atoms&#34;] = 2000         # Update atom count
d.reorder(&#34;Atoms&#34;, 1, 3, 2, 4)    # Reorder columns in `Atoms`
d.write(&#34;data.new&#34;)               # Save to a new file
```

### Restart Generation
```python
dump_obj = dump(&#34;dump.poly&#34;)
d = data(dump_obj, 1000)          # Create data object from dump
d.write(&#34;data.restart&#34;)           # Write restart file
```

### Visualization
```python
time, box, atoms, bonds, tris, lines = d.viz(0)
```

---

## Properties
- **Headers**:
  - `atoms`: Number of atoms in the data file.
  - `atom types`: Number of atom types.
  - `xlo xhi`, `ylo yhi`, `zlo zhi`: Box dimensions.

- **Sections**:
  - `Atoms`: Atomic data (e.g., ID, type, coordinates).
  - `Velocities`: Atomic velocities (optional).
  - Additional sections for bonds, angles, etc.

---

## Notes
- **Compatibility**: Fully compatible with `dump` for restart and visualization tasks.
- **Error Handling**: Automatically validates headers and sections for consistency.
- **Extensibility**: Easily add or modify headers, sections, and attributes.

---
&#34;&#34;&#34;


__project__ = &#34;Pizza3&#34;
__author__ = &#34;Olivier Vitrac&#34;
__copyright__ = &#34;Copyright 2022&#34;
__credits__ = [&#34;Steve Plimpton&#34;, &#34;Olivier Vitrac&#34;]
__license__ = &#34;GPLv3&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;0.99991&#34;


# Pizza.py toolkit, www.cs.sandia.gov/~sjplimp/pizza.html
# Steve Plimpton, sjplimp@sandia.gov, Sandia National Laboratories
#
# Copyright (2005) Sandia Corporation.  Under the terms of Contract
# DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
# certain rights in this software.  This software is distributed under
# the GNU General Public License.

# data tool

# Code converted to pyton 3.x
# INRAE\olivier.vitrac@agroparistech.fr
#
# last release
# 2022-02-03 - add flist, __repr__
# 2022-02-04 - add append and start to add comments
# 2022-02-10 - first implementation of a full restart object from a dump object
# 2022-02-12 - revised append method, more robust, more verbose
# 2024-12-08 - updated help

oneline = &#34;Read, write, manipulate LAMMPS data files&#34;

docstr = &#34;&#34;&#34;
d = data(&#34;data.poly&#34;)            read a LAMMPS data file, can be gzipped
d = data()                       create an empty data file

d.map(1,&#34;id&#34;,3,&#34;x&#34;)              assign names to atom columns (1-N)

coeffs = d.get(&#34;Pair Coeffs&#34;)    extract info from data file section
q = d.get(&#34;Atoms&#34;,4)

  1 arg = all columns returned as 2d array of floats
  2 args = Nth column returned as vector of floats

d.reorder(&#34;Atoms&#34;,1,3,2,4,5)     reorder columns (1-N) in a data file section

  1,3,2,4,5 = new order of previous columns, can delete columns this way

d.title = &#34;My LAMMPS data file&#34;  set title of the data file
d.headers[&#34;atoms&#34;] = 1500        set a header value
d.sections[&#34;Bonds&#34;] = lines      set a section to list of lines (with newlines)
d.delete(&#34;bonds&#34;)                delete a keyword or section of data file
d.delete(&#34;Bonds&#34;)
d.replace(&#34;Atoms&#34;,5,vec)         replace Nth column of section with vector
d.newxyz(dmp,1000)               replace xyz in Atoms with xyz of snapshot N

  newxyz assumes id,x,y,z are defined in both data and dump files
    also replaces ix,iy,iz if they are defined

index,time,flag = d.iterator(0/1)          loop over single data file snapshot
time,box,atoms,bonds,tris,lines = d.viz(index)   return list of viz objects

  iterator() and viz() are compatible with equivalent dump calls
  iterator() called with arg = 0 first time, with arg = 1 on subsequent calls
    index = timestep index within dump object (only 0 for data file)
    time = timestep value (only 0 for data file)
    flag = -1 when iteration is done, 1 otherwise
  viz() returns info for specified timestep index (must be 0)
    time = 0
    box = [xlo,ylo,zlo,xhi,yhi,zhi]
    atoms = id,type,x,y,z for each atom as 2d array
    bonds = id,type,x1,y1,z1,x2,y2,z2,t1,t2 for each bond as 2d array
      NULL if bonds do not exist
    tris = NULL
    lines = NULL

d.write(&#34;data.new&#34;)             write a LAMMPS data file
&#34;&#34;&#34;

# History
#   8/05, Steve Plimpton (SNL): original version
#   11/07, added triclinic box support

# ToDo list

# Variables
#   title = 1st line of data file
#   names = dictionary with atom attributes as keys, col #s as values
#   headers = dictionary with header name as key, value or tuple as values
#   sections = dictionary with section name as key, array of lines as values
#   nselect = 1 = # of snapshots

# Imports and external programs

# External dependency
from os import popen
import numpy as np

# Dependecy for the creation of DATA restart object from a DUMP object
from pizza.dump3 import dump

__all__ = [&#39;data&#39;, &#39;dump&#39;]

#try:
#    tmp = PIZZA_GUNZIP
#except:
PIZZA_GUNZIP = &#34;gunzip&#34;

# Class definition


class data:

    # --------------------------------------------------------------------

    def __init__(self, *list):
        self.nselect = 1

        if len(list) == 0:

        # ========================================
        # Default Constructor (empty object)
        # ========================================

            self.title = &#34;LAMMPS data file&#34;
            self.names = {}
            self.headers = {}
            self.sections = {}
            self.flist = []
            self.restart = False
            return

        elif isinstance(list[0],dump):

        # ========================================
        # Constructor from an existing DUMP object
        # ========================================

            X = list[0]     # supplied dump object
            t = X.time()
            nt = len(t)
            if len(list)&gt;1:
                tselect = list[1]
                if tselect not in t:
                    raise ValueError(&#34;the input time is not available in the dump object&#34;)
            else:
                tselect = t[-1]
            itselect = next(i for i in range(nt) if t[i]==tselect)
            # set object title
            self.title = &#39;LAMMPS data file (restart from &#34;%s&#34; t = %0.5g (frame %d of %d))&#39; %  \
                (X.flist[0],tselect,itselect,nt)
            # set default names                       ------------- HEADERS SECTION -------------
            self.names = {}
            X.tselect.one(tselect)
            snap = X.snaps[itselect]
            # set headers
            self.headers = {    &#39;atoms&#39;: snap.natoms,
                                &#39;atom types&#39;: X.minmax(&#34;type&#34;)[1],
                                &#39;xlo xhi&#39;: (snap.xlo, snap.xhi),
                                &#39;ylo yhi&#39;: (snap.ylo, snap.yhi),
                                &#39;zlo zhi&#39;: (snap.zlo, snap.zhi)}
            # Default sections
            self.sections = {}
            # set atoms (specific to your style/kind) ------------- ATOMS SUBSECTION -------------
            template_atoms = {&#34;smd&#34;: [&#34;id&#34;,&#34;type&#34;,&#34;mol&#34;,&#34;c_vol&#34;, &#34;mass&#34;, &#34;radius&#34;,
                                      &#34;c_contact_radius&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;f_1[1]&#34;, &#34;f_1[2]&#34;, &#34;f_1[3]&#34;] }
            if X.kind(template_atoms[&#34;smd&#34;]):
                for col in template_atoms[&#34;smd&#34;]:
                    self.append(&#34;Atoms&#34;, X.vecs(tselect, col), col in [&#34;id&#34;,&#34;type&#34;,&#34;mol&#34;],col)
            else:
                raise ValueError(&#34;Please add your ATOMS section in the constructor&#34;)
            # set velocities (if required)           ------------- VELOCITIES SUBSECTION -------------
            template_velocities = {&#34;smd&#34;: [&#34;id&#34;,&#34;vx&#34;,&#34;vy&#34;,&#34;vz&#34;]}
            if X.kind(template_atoms[&#34;smd&#34;]):
                if X.kind(template_velocities[&#34;smd&#34;]):
                    for col in template_velocities[&#34;smd&#34;]:
                        self.append(&#34;Velocities&#34;, X.vecs(tselect, col), col == &#34;id&#34;,col)
                else:
                    raise ValueError(&#34;the velocities are missing for the style SMD&#34;)
            # store filename
            self.flist = list[0].flist
            self.restart = True
            return

        # ===========================================================
        # Regular constructor from DATA file (supplied as filename)
        # ===========================================================

        flist = list
        file = list[0]
        if file[-3:] == &#34;.gz&#34;:
            f = popen(&#34;%s -c %s&#34; % (PIZZA_GUNZIP, file), &#34;r&#34;)
        else:
            f = open(file)

        self.title = f.readline()
        self.names = {}

        headers = {}
        while 1:
            line = f.readline()
            line = line.strip()
            if len(line) == 0:
                continue
            found = 0
            for keyword in hkeywords:
                if line.find(keyword) &gt;= 0:
                    found = 1
                    words = line.split()
                    if (
                        keyword == &#34;xlo xhi&#34;
                        or keyword == &#34;ylo yhi&#34;
                        or keyword == &#34;zlo zhi&#34;
                    ):
                        headers[keyword] = (float(words[0]), float(words[1]))
                    elif keyword == &#34;xy xz yz&#34;:
                        headers[keyword] = (
                            float(words[0]),
                            float(words[1]),
                            float(words[2]),
                        )
                    else:
                        headers[keyword] = int(words[0])
            if not found:
                break

        sections = {}
        while 1:
            found = 0
            for pair in skeywords:
                keyword, length = pair[0], pair[1]
                if keyword == line:
                    found = 1
                    if length not in headers: #if not headers.has_key(length):
                        raise ValueError(&#34;data section %s has no matching header value&#34; % line)
                    f.readline()
                    list = []
                    for i in range(headers[length]):
                        list.append(f.readline())
                    sections[keyword] = list
            if not found:
                raise ValueError(&#34;invalid section %s in data file&#34; % line)
            f.readline()
            line = f.readline()
            if not line:
                break
            line = line.strip()

        f.close()
        self.headers = headers
        self.sections = sections
        self.flist = flist
        self.restart = False

    # --------------------------------------------------------------------
    # Display method (added OV - 2022-02-03)
    def __repr__(self):
        if self.sections == {} or self.headers == {}:
            ret = &#34;empty %s&#34; % self.title
            print(ret)
            return ret
        if self.restart:
            kind = &#34;restart&#34;
        else:
            kind = &#34;source&#34;
        print(&#34;Data file: %s\n\tcontains %d atoms from %d atom types\n\twith box = [%0.4g %0.4g %0.4g %0.4g %0.4g %0.4g]&#34;
              % (self.flist[0],
                 self.headers[&#39;atoms&#39;],
                 self.headers[&#39;atom types&#39;],
                 self.headers[&#39;xlo xhi&#39;][0],
                 self.headers[&#39;xlo xhi&#39;][1],
                 self.headers[&#39;ylo yhi&#39;][0],
                 self.headers[&#39;ylo yhi&#39;][1],
                 self.headers[&#39;zlo zhi&#39;][0],
                 self.headers[&#39;zlo zhi&#39;][1],
                 ) )
        print(&#34;\twith the following sections:&#34;)
        for sectionname in self.sections.keys():
            print(&#34;\t\t&#34; +self.dispsection(sectionname,False))
        ret = &#39;LAMMPS data object including %d atoms (%d types, %s=&#34;%s&#34;)&#39; \
            % (self.headers[&#39;atoms&#39;],self.maxtype(),kind,self.flist[0])
        return ret


    # --------------------------------------------------------------------
    # assign names to atom columns

    def map(self, *pairs):
        if len(pairs) % 2 != 0:
            raise ValueError (&#34;data map() requires pairs of mappings&#34;)
        for i in range(0, len(pairs), 2):
            j = i + 1
            self.names[pairs[j]] = pairs[i] - 1

    # --------------------------------------------------------------------
    # extract info from data file fields

    def get(self, *list):
        if len(list) == 1:
            field = list[0]
            array = []
            lines = self.sections[field]
            for line in lines:
                words = line.split()
                values = map(float, words)
                array.append(values)
            return array
        elif len(list) == 2:
            field = list[0]
            n = list[1] - 1
            vec = []
            lines = self.sections[field]
            for line in lines:
                words = line.split()
                vec.append(float(words[n]))
            return vec
        else:
            raise ValueError(&#34;invalid arguments for data.get()&#34;)

    # --------------------------------------------------------------------
    # reorder columns in a data file field

    def reorder(self, name, *order):
        &#34;&#34;&#34; reorder columns: reorder(&#34;section&#34;,colidxfirst,colidxsecond,colidxthird,...)  &#34;&#34;&#34;
        if name not in self.sections:
            raise ValueError(&#39;&#34;%s&#34; is not a valid section name&#39; % name)
        n = len(order)
        print(&#34;&gt;&gt; reorder for %d columns&#34; % n)
        natoms = len(self.sections[name])
        oldlines = self.sections[name]
        newlines = natoms * [&#34;&#34;]
        for index in order:
            for i in range(len(newlines)):
                words = oldlines[i].split()
                newlines[i] += words[index - 1] + &#34; &#34;
        for i in range(len(newlines)):
            newlines[i] += &#34;\n&#34;
        self.sections[name] = newlines

    # --------------------------------------------------------------------
    # replace a column of named section with vector of values
    # the number of data is checked and repeated for scalars (added 2022-02-04)

    def replace(self, name, icol, vector):
        &#34;&#34;&#34; replace column values: replace(&#34;section&#34;,columnindex,vectorofvalues) with columnindex=1..ncolumns &#34;&#34;&#34;
        lines = self.sections[name]
        nlines = len(lines)
        if name not in self.sections:
            raise ValueError(&#39;&#34;%s&#34; is not a valid section name&#39; % name)
        if not isinstance(vector,list): vector = [vector]
        if len(vector)==1: vector = vector * nlines
        if len(vector) != nlines:
            raise ValueError(&#39;the length of new data (%d) in section &#34;%s&#34; does not match the number of rows %d&#39; % \
                             (len(vector),name,nlines))
        newlines = []
        j = icol - 1
        for i in range(nlines):
            line = lines[i]
            words = line.split()
            words[j] = str(vector[i])
            newline = &#34; &#34;.join(words) + &#34;\n&#34;
            newlines.append(newline)
        self.sections[name] = newlines

    # --------------------------------------------------------------------
    # append a column of named section with vector of values (added 2022-02-04)

    def append(self, name, vector, forceinteger = False, propertyname=None):
        &#34;&#34;&#34; append a new column: X.append(&#34;section&#34;,vectorofvalues,forceinteger=False,propertyname=None) &#34;&#34;&#34;
        if name not in self.sections:
            self.sections[name] = []
            print(&#39;Add section [%s] - file=&#34;%s&#34;&#39; % (name,self.title) )
        lines = self.sections[name]
        nlines = len(lines)
        if not isinstance(vector,list) and not isinstance(vector,np.ndarray):
            vector = [vector]
        if propertyname != None:
            print(&#39;\t&gt; Add &#34;%s&#34; (%d values) to [%s]&#39; % (propertyname,len(vector),name))
        else:
            print(&#39;\t&gt; Add %d values (no name) to [%s]&#39; % (len(vector),name))
        newlines = []
        if nlines == 0:           # empty atoms section, create first column
            nlines = len(vector)  # new column length = input column length
            for i in range(nlines):
                if forceinteger:
                    line = str(int(vector[i]))
                else:
                    line = str(vector[i])
                newlines.append(line)
        else:
            if len(vector)==1: vector = vector * nlines
            if len(vector) != nlines:
                raise ValueError(&#39;the length of new data (%d) in section &#34;%s&#34; does not match the number of rows %d&#39; % \
                                 (len(vector),name,nlines))
            for i in range(nlines):
                line = lines[i]
                words = line.split()
                if forceinteger:
                    words.append(str(int(vector[i])))
                else:
                    words.append(str(vector[i]))
                newline = &#34; &#34;.join(words) + &#34;\n&#34;
                newlines.append(newline)
        self.sections[name] = newlines


    # --------------------------------------------------------------------
    # disp section info (added 2022-02-04)

    def dispsection(self, name,flaghead=True):
        &#34;&#34;&#34; display section info: X.dispsection(&#34;sectionname&#34;) &#34;&#34;&#34;
        lines = self.sections[name]
        nlines = len(lines)
        line = lines[0]
        words = line.split()
        ret = &#39;&#34;%s&#34;: %d x %d values&#39; % (name,nlines,len(words))

        if flaghead: ret = &#34;LAMMPS data section &#34;+ret
        return ret

    # --------------------------------------------------------------------
    # replace x,y,z in Atoms with x,y,z values from snapshot ntime of dump object
    # assumes id,x,y,z are defined in both data and dump files
    # also replaces ix,iy,iz if they are defined

    def newxyz(self, dm, ntime):
        nsnap = dm.findtime(ntime)
        print(&#34;&gt;&gt; newxyz for %d snaps&#34; % nsnap)

        dm.sort(ntime)
        x, y, z = dm.vecs(ntime, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;)

        self.replace(&#34;Atoms&#34;, self.names[&#34;x&#34;] + 1, x)
        self.replace(&#34;Atoms&#34;, self.names[&#34;y&#34;] + 1, y)
        self.replace(&#34;Atoms&#34;, self.names[&#34;z&#34;] + 1, z)

        if &#34;ix&#34; in dm.names and &#34;ix&#34; in self.names: #if dm.names.has_key(&#34;ix&#34;) and self.names.has_key(&#34;ix&#34;):
            ix, iy, iz = dm.vecs(ntime, &#34;ix&#34;, &#34;iy&#34;, &#34;iz&#34;)
            self.replace(&#34;Atoms&#34;, self.names[&#34;ix&#34;] + 1, ix)
            self.replace(&#34;Atoms&#34;, self.names[&#34;iy&#34;] + 1, iy)
            self.replace(&#34;Atoms&#34;, self.names[&#34;iz&#34;] + 1, iz)

    # --------------------------------------------------------------------
    # delete header value or section from data file

    def delete(self, keyword):

        if keyword in self.headers: # if self.headers.has_key(keyword):
            del self.headers[keyword]
        elif keyword in self.sections: # elif self.sections.has_key(keyword):
            del self.sections[keyword]
        else:
            raise ValueError(&#34;keyword not found in data object&#34;)

    # --------------------------------------------------------------------
    # write out a LAMMPS data file

    def write(self, file):
        f = open(file, &#34;w&#34;)
        print(self.title,file=f)
        for keyword in hkeywords:
            if keyword in self.headers: # self.headers.has_key(keyword):
                if keyword == &#34;xlo xhi&#34; or keyword == &#34;ylo yhi&#34; or keyword == &#34;zlo zhi&#34;:
                    pair = self.headers[keyword]
                    print(pair[0], pair[1], keyword,file=f)
                elif keyword == &#34;xy xz yz&#34;:
                    triple = self.headers[keyword]
                    print(triple[0], triple[1], triple[2], keyword,file=f)
                else:
                    print(self.headers[keyword], keyword,file=f)
        for pair in skeywords:
            keyword = pair[0]
            if keyword in self.sections: #self.sections.has_key(keyword):
                print(&#34;\n%s\n&#34; % keyword,file=f)
                for line in self.sections[keyword]:
                    print(line,file=f,end=&#34;&#34;)
        f.close()

    # --------------------------------------------------------------------
    # iterator called from other tools

    def iterator(self, flag):
        if flag == 0:
            return 0, 0, 1
        return 0, 0, -1

    # --------------------------------------------------------------------
    # time query from other tools

    def findtime(self, n):
        if n == 0:
            return 0
        raise ValueError(&#34;no step %d exists&#34; % n)

    # --------------------------------------------------------------------
    # return list of atoms and bonds to viz for data object

    def viz(self, isnap):
        if isnap:
            raise ValueError(&#34;cannot call data.viz() with isnap != 0&#34;)

        id = self.names[&#34;id&#34;]
        type = self.names[&#34;type&#34;]
        x = self.names[&#34;x&#34;]
        y = self.names[&#34;y&#34;]
        z = self.names[&#34;z&#34;]

        xlohi = self.headers[&#34;xlo xhi&#34;]
        ylohi = self.headers[&#34;ylo yhi&#34;]
        zlohi = self.headers[&#34;zlo zhi&#34;]
        box = [xlohi[0], ylohi[0], zlohi[0], xlohi[1], ylohi[1], zlohi[1]]

        # create atom list needed by viz from id,type,x,y,z

        atoms = []
        atomlines = self.sections[&#34;Atoms&#34;]
        for line in atomlines:
            words = line.split()
            atoms.append(
                [
                    int(words[id]),
                    int(words[type]),
                    float(words[x]),
                    float(words[y]),
                    float(words[z]),
                ]
            )

        # create list of current bond coords from list of bonds
        # assumes atoms are sorted so can lookup up the 2 atoms in each bond

        bonds = []
        if self.sections.has_key(&#34;Bonds&#34;):
            bondlines = self.sections[&#34;Bonds&#34;]
            for line in bondlines:
                words = line.split()
                bid, btype = int(words[0]), int(words[1])
                atom1, atom2 = int(words[2]), int(words[3])
                atom1words = atomlines[atom1 - 1].split()
                atom2words = atomlines[atom2 - 1].split()
                bonds.append(
                    [
                        bid,
                        btype,
                        float(atom1words[x]),
                        float(atom1words[y]),
                        float(atom1words[z]),
                        float(atom2words[x]),
                        float(atom2words[y]),
                        float(atom2words[z]),
                        float(atom1words[type]),
                        float(atom2words[type]),
                    ]
                )

        tris = []
        lines = []
        return 0, box, atoms, bonds, tris, lines

    # --------------------------------------------------------------------
    # return box size

    def maxbox(self):
        xlohi = self.headers[&#34;xlo xhi&#34;]
        ylohi = self.headers[&#34;ylo yhi&#34;]
        zlohi = self.headers[&#34;zlo zhi&#34;]
        return [xlohi[0], ylohi[0], zlohi[0], xlohi[1], ylohi[1], zlohi[1]]

    # --------------------------------------------------------------------
    # return number of atom types

    def maxtype(self):
        return self.headers[&#34;atom types&#34;]


# --------------------------------------------------------------------
# data file keywords, both header and main sections

hkeywords = [
    &#34;atoms&#34;,
    &#34;ellipsoids&#34;,
    &#34;lines&#34;,
    &#34;triangles&#34;,
    &#34;bodies&#34;,
    &#34;bonds&#34;,
    &#34;angles&#34;,
    &#34;dihedrals&#34;,
    &#34;impropers&#34;,
    &#34;atom types&#34;,
    &#34;bond types&#34;,
    &#34;angle types&#34;,
    &#34;dihedral types&#34;,
    &#34;improper types&#34;,
    &#34;xlo xhi&#34;,
    &#34;ylo yhi&#34;,
    &#34;zlo zhi&#34;,
    &#34;xy xz yz&#34;,
]

skeywords = [
    [&#34;Masses&#34;, &#34;atom types&#34;],
    [&#34;Atoms&#34;, &#34;atoms&#34;],
    [&#34;Ellipsoids&#34;, &#34;ellipsoids&#34;],
    [&#34;Lines&#34;, &#34;lines&#34;],
    [&#34;Triangles&#34;, &#34;triangles&#34;],
    [&#34;Bodies&#34;, &#34;bodies&#34;],
    [&#34;Bonds&#34;, &#34;bonds&#34;],
    [&#34;Angles&#34;, &#34;angles&#34;],
    [&#34;Dihedrals&#34;, &#34;dihedrals&#34;],
    [&#34;Impropers&#34;, &#34;impropers&#34;],
    [&#34;Velocities&#34;, &#34;atoms&#34;],
    [&#34;Pair Coeffs&#34;, &#34;atom types&#34;],
    [&#34;Bond Coeffs&#34;, &#34;bond types&#34;],
    [&#34;Angle Coeffs&#34;, &#34;angle types&#34;],
    [&#34;Dihedral Coeffs&#34;, &#34;dihedral types&#34;],
    [&#34;Improper Coeffs&#34;, &#34;improper types&#34;],
    [&#34;BondBond Coeffs&#34;, &#34;angle types&#34;],
    [&#34;BondAngle Coeffs&#34;, &#34;angle types&#34;],
    [&#34;MiddleBondTorsion Coeffs&#34;, &#34;dihedral types&#34;],
    [&#34;EndBondTorsion Coeffs&#34;, &#34;dihedral types&#34;],
    [&#34;AngleTorsion Coeffs&#34;, &#34;dihedral types&#34;],
    [&#34;AngleAngleTorsion Coeffs&#34;, &#34;dihedral types&#34;],
    [&#34;BondBond13 Coeffs&#34;, &#34;dihedral types&#34;],
    [&#34;AngleAngle Coeffs&#34;, &#34;improper types&#34;],
    [&#34;Molecules&#34;, &#34;atoms&#34;],
    [&#34;Tinker Types&#34;, &#34;atoms&#34;],
]

# %%
# ===================================================
# main()
# ===================================================
# for debugging purposes (code called as a script)
# the code is called from here
# ===================================================
if __name__ == &#39;__main__&#39;:
    datafile = &#34;../data/play_data/data.play.lmp&#34;
    X = data(datafile)
    Y = dump(&#34;../data/play_data/dump.play.restartme&#34;)
    t = Y.time()
    step = 2000
    R = data(Y,step)
    R.write(&#34;../tmp/data.myfirstrestart.lmp&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="data3.data"><code class="flex name class">
<span>class <span class="ident">data</span></span>
<span>(</span><span>*list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class data:

    # --------------------------------------------------------------------

    def __init__(self, *list):
        self.nselect = 1

        if len(list) == 0:

        # ========================================
        # Default Constructor (empty object)
        # ========================================

            self.title = &#34;LAMMPS data file&#34;
            self.names = {}
            self.headers = {}
            self.sections = {}
            self.flist = []
            self.restart = False
            return

        elif isinstance(list[0],dump):

        # ========================================
        # Constructor from an existing DUMP object
        # ========================================

            X = list[0]     # supplied dump object
            t = X.time()
            nt = len(t)
            if len(list)&gt;1:
                tselect = list[1]
                if tselect not in t:
                    raise ValueError(&#34;the input time is not available in the dump object&#34;)
            else:
                tselect = t[-1]
            itselect = next(i for i in range(nt) if t[i]==tselect)
            # set object title
            self.title = &#39;LAMMPS data file (restart from &#34;%s&#34; t = %0.5g (frame %d of %d))&#39; %  \
                (X.flist[0],tselect,itselect,nt)
            # set default names                       ------------- HEADERS SECTION -------------
            self.names = {}
            X.tselect.one(tselect)
            snap = X.snaps[itselect]
            # set headers
            self.headers = {    &#39;atoms&#39;: snap.natoms,
                                &#39;atom types&#39;: X.minmax(&#34;type&#34;)[1],
                                &#39;xlo xhi&#39;: (snap.xlo, snap.xhi),
                                &#39;ylo yhi&#39;: (snap.ylo, snap.yhi),
                                &#39;zlo zhi&#39;: (snap.zlo, snap.zhi)}
            # Default sections
            self.sections = {}
            # set atoms (specific to your style/kind) ------------- ATOMS SUBSECTION -------------
            template_atoms = {&#34;smd&#34;: [&#34;id&#34;,&#34;type&#34;,&#34;mol&#34;,&#34;c_vol&#34;, &#34;mass&#34;, &#34;radius&#34;,
                                      &#34;c_contact_radius&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;f_1[1]&#34;, &#34;f_1[2]&#34;, &#34;f_1[3]&#34;] }
            if X.kind(template_atoms[&#34;smd&#34;]):
                for col in template_atoms[&#34;smd&#34;]:
                    self.append(&#34;Atoms&#34;, X.vecs(tselect, col), col in [&#34;id&#34;,&#34;type&#34;,&#34;mol&#34;],col)
            else:
                raise ValueError(&#34;Please add your ATOMS section in the constructor&#34;)
            # set velocities (if required)           ------------- VELOCITIES SUBSECTION -------------
            template_velocities = {&#34;smd&#34;: [&#34;id&#34;,&#34;vx&#34;,&#34;vy&#34;,&#34;vz&#34;]}
            if X.kind(template_atoms[&#34;smd&#34;]):
                if X.kind(template_velocities[&#34;smd&#34;]):
                    for col in template_velocities[&#34;smd&#34;]:
                        self.append(&#34;Velocities&#34;, X.vecs(tselect, col), col == &#34;id&#34;,col)
                else:
                    raise ValueError(&#34;the velocities are missing for the style SMD&#34;)
            # store filename
            self.flist = list[0].flist
            self.restart = True
            return

        # ===========================================================
        # Regular constructor from DATA file (supplied as filename)
        # ===========================================================

        flist = list
        file = list[0]
        if file[-3:] == &#34;.gz&#34;:
            f = popen(&#34;%s -c %s&#34; % (PIZZA_GUNZIP, file), &#34;r&#34;)
        else:
            f = open(file)

        self.title = f.readline()
        self.names = {}

        headers = {}
        while 1:
            line = f.readline()
            line = line.strip()
            if len(line) == 0:
                continue
            found = 0
            for keyword in hkeywords:
                if line.find(keyword) &gt;= 0:
                    found = 1
                    words = line.split()
                    if (
                        keyword == &#34;xlo xhi&#34;
                        or keyword == &#34;ylo yhi&#34;
                        or keyword == &#34;zlo zhi&#34;
                    ):
                        headers[keyword] = (float(words[0]), float(words[1]))
                    elif keyword == &#34;xy xz yz&#34;:
                        headers[keyword] = (
                            float(words[0]),
                            float(words[1]),
                            float(words[2]),
                        )
                    else:
                        headers[keyword] = int(words[0])
            if not found:
                break

        sections = {}
        while 1:
            found = 0
            for pair in skeywords:
                keyword, length = pair[0], pair[1]
                if keyword == line:
                    found = 1
                    if length not in headers: #if not headers.has_key(length):
                        raise ValueError(&#34;data section %s has no matching header value&#34; % line)
                    f.readline()
                    list = []
                    for i in range(headers[length]):
                        list.append(f.readline())
                    sections[keyword] = list
            if not found:
                raise ValueError(&#34;invalid section %s in data file&#34; % line)
            f.readline()
            line = f.readline()
            if not line:
                break
            line = line.strip()

        f.close()
        self.headers = headers
        self.sections = sections
        self.flist = flist
        self.restart = False

    # --------------------------------------------------------------------
    # Display method (added OV - 2022-02-03)
    def __repr__(self):
        if self.sections == {} or self.headers == {}:
            ret = &#34;empty %s&#34; % self.title
            print(ret)
            return ret
        if self.restart:
            kind = &#34;restart&#34;
        else:
            kind = &#34;source&#34;
        print(&#34;Data file: %s\n\tcontains %d atoms from %d atom types\n\twith box = [%0.4g %0.4g %0.4g %0.4g %0.4g %0.4g]&#34;
              % (self.flist[0],
                 self.headers[&#39;atoms&#39;],
                 self.headers[&#39;atom types&#39;],
                 self.headers[&#39;xlo xhi&#39;][0],
                 self.headers[&#39;xlo xhi&#39;][1],
                 self.headers[&#39;ylo yhi&#39;][0],
                 self.headers[&#39;ylo yhi&#39;][1],
                 self.headers[&#39;zlo zhi&#39;][0],
                 self.headers[&#39;zlo zhi&#39;][1],
                 ) )
        print(&#34;\twith the following sections:&#34;)
        for sectionname in self.sections.keys():
            print(&#34;\t\t&#34; +self.dispsection(sectionname,False))
        ret = &#39;LAMMPS data object including %d atoms (%d types, %s=&#34;%s&#34;)&#39; \
            % (self.headers[&#39;atoms&#39;],self.maxtype(),kind,self.flist[0])
        return ret


    # --------------------------------------------------------------------
    # assign names to atom columns

    def map(self, *pairs):
        if len(pairs) % 2 != 0:
            raise ValueError (&#34;data map() requires pairs of mappings&#34;)
        for i in range(0, len(pairs), 2):
            j = i + 1
            self.names[pairs[j]] = pairs[i] - 1

    # --------------------------------------------------------------------
    # extract info from data file fields

    def get(self, *list):
        if len(list) == 1:
            field = list[0]
            array = []
            lines = self.sections[field]
            for line in lines:
                words = line.split()
                values = map(float, words)
                array.append(values)
            return array
        elif len(list) == 2:
            field = list[0]
            n = list[1] - 1
            vec = []
            lines = self.sections[field]
            for line in lines:
                words = line.split()
                vec.append(float(words[n]))
            return vec
        else:
            raise ValueError(&#34;invalid arguments for data.get()&#34;)

    # --------------------------------------------------------------------
    # reorder columns in a data file field

    def reorder(self, name, *order):
        &#34;&#34;&#34; reorder columns: reorder(&#34;section&#34;,colidxfirst,colidxsecond,colidxthird,...)  &#34;&#34;&#34;
        if name not in self.sections:
            raise ValueError(&#39;&#34;%s&#34; is not a valid section name&#39; % name)
        n = len(order)
        print(&#34;&gt;&gt; reorder for %d columns&#34; % n)
        natoms = len(self.sections[name])
        oldlines = self.sections[name]
        newlines = natoms * [&#34;&#34;]
        for index in order:
            for i in range(len(newlines)):
                words = oldlines[i].split()
                newlines[i] += words[index - 1] + &#34; &#34;
        for i in range(len(newlines)):
            newlines[i] += &#34;\n&#34;
        self.sections[name] = newlines

    # --------------------------------------------------------------------
    # replace a column of named section with vector of values
    # the number of data is checked and repeated for scalars (added 2022-02-04)

    def replace(self, name, icol, vector):
        &#34;&#34;&#34; replace column values: replace(&#34;section&#34;,columnindex,vectorofvalues) with columnindex=1..ncolumns &#34;&#34;&#34;
        lines = self.sections[name]
        nlines = len(lines)
        if name not in self.sections:
            raise ValueError(&#39;&#34;%s&#34; is not a valid section name&#39; % name)
        if not isinstance(vector,list): vector = [vector]
        if len(vector)==1: vector = vector * nlines
        if len(vector) != nlines:
            raise ValueError(&#39;the length of new data (%d) in section &#34;%s&#34; does not match the number of rows %d&#39; % \
                             (len(vector),name,nlines))
        newlines = []
        j = icol - 1
        for i in range(nlines):
            line = lines[i]
            words = line.split()
            words[j] = str(vector[i])
            newline = &#34; &#34;.join(words) + &#34;\n&#34;
            newlines.append(newline)
        self.sections[name] = newlines

    # --------------------------------------------------------------------
    # append a column of named section with vector of values (added 2022-02-04)

    def append(self, name, vector, forceinteger = False, propertyname=None):
        &#34;&#34;&#34; append a new column: X.append(&#34;section&#34;,vectorofvalues,forceinteger=False,propertyname=None) &#34;&#34;&#34;
        if name not in self.sections:
            self.sections[name] = []
            print(&#39;Add section [%s] - file=&#34;%s&#34;&#39; % (name,self.title) )
        lines = self.sections[name]
        nlines = len(lines)
        if not isinstance(vector,list) and not isinstance(vector,np.ndarray):
            vector = [vector]
        if propertyname != None:
            print(&#39;\t&gt; Add &#34;%s&#34; (%d values) to [%s]&#39; % (propertyname,len(vector),name))
        else:
            print(&#39;\t&gt; Add %d values (no name) to [%s]&#39; % (len(vector),name))
        newlines = []
        if nlines == 0:           # empty atoms section, create first column
            nlines = len(vector)  # new column length = input column length
            for i in range(nlines):
                if forceinteger:
                    line = str(int(vector[i]))
                else:
                    line = str(vector[i])
                newlines.append(line)
        else:
            if len(vector)==1: vector = vector * nlines
            if len(vector) != nlines:
                raise ValueError(&#39;the length of new data (%d) in section &#34;%s&#34; does not match the number of rows %d&#39; % \
                                 (len(vector),name,nlines))
            for i in range(nlines):
                line = lines[i]
                words = line.split()
                if forceinteger:
                    words.append(str(int(vector[i])))
                else:
                    words.append(str(vector[i]))
                newline = &#34; &#34;.join(words) + &#34;\n&#34;
                newlines.append(newline)
        self.sections[name] = newlines


    # --------------------------------------------------------------------
    # disp section info (added 2022-02-04)

    def dispsection(self, name,flaghead=True):
        &#34;&#34;&#34; display section info: X.dispsection(&#34;sectionname&#34;) &#34;&#34;&#34;
        lines = self.sections[name]
        nlines = len(lines)
        line = lines[0]
        words = line.split()
        ret = &#39;&#34;%s&#34;: %d x %d values&#39; % (name,nlines,len(words))

        if flaghead: ret = &#34;LAMMPS data section &#34;+ret
        return ret

    # --------------------------------------------------------------------
    # replace x,y,z in Atoms with x,y,z values from snapshot ntime of dump object
    # assumes id,x,y,z are defined in both data and dump files
    # also replaces ix,iy,iz if they are defined

    def newxyz(self, dm, ntime):
        nsnap = dm.findtime(ntime)
        print(&#34;&gt;&gt; newxyz for %d snaps&#34; % nsnap)

        dm.sort(ntime)
        x, y, z = dm.vecs(ntime, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;)

        self.replace(&#34;Atoms&#34;, self.names[&#34;x&#34;] + 1, x)
        self.replace(&#34;Atoms&#34;, self.names[&#34;y&#34;] + 1, y)
        self.replace(&#34;Atoms&#34;, self.names[&#34;z&#34;] + 1, z)

        if &#34;ix&#34; in dm.names and &#34;ix&#34; in self.names: #if dm.names.has_key(&#34;ix&#34;) and self.names.has_key(&#34;ix&#34;):
            ix, iy, iz = dm.vecs(ntime, &#34;ix&#34;, &#34;iy&#34;, &#34;iz&#34;)
            self.replace(&#34;Atoms&#34;, self.names[&#34;ix&#34;] + 1, ix)
            self.replace(&#34;Atoms&#34;, self.names[&#34;iy&#34;] + 1, iy)
            self.replace(&#34;Atoms&#34;, self.names[&#34;iz&#34;] + 1, iz)

    # --------------------------------------------------------------------
    # delete header value or section from data file

    def delete(self, keyword):

        if keyword in self.headers: # if self.headers.has_key(keyword):
            del self.headers[keyword]
        elif keyword in self.sections: # elif self.sections.has_key(keyword):
            del self.sections[keyword]
        else:
            raise ValueError(&#34;keyword not found in data object&#34;)

    # --------------------------------------------------------------------
    # write out a LAMMPS data file

    def write(self, file):
        f = open(file, &#34;w&#34;)
        print(self.title,file=f)
        for keyword in hkeywords:
            if keyword in self.headers: # self.headers.has_key(keyword):
                if keyword == &#34;xlo xhi&#34; or keyword == &#34;ylo yhi&#34; or keyword == &#34;zlo zhi&#34;:
                    pair = self.headers[keyword]
                    print(pair[0], pair[1], keyword,file=f)
                elif keyword == &#34;xy xz yz&#34;:
                    triple = self.headers[keyword]
                    print(triple[0], triple[1], triple[2], keyword,file=f)
                else:
                    print(self.headers[keyword], keyword,file=f)
        for pair in skeywords:
            keyword = pair[0]
            if keyword in self.sections: #self.sections.has_key(keyword):
                print(&#34;\n%s\n&#34; % keyword,file=f)
                for line in self.sections[keyword]:
                    print(line,file=f,end=&#34;&#34;)
        f.close()

    # --------------------------------------------------------------------
    # iterator called from other tools

    def iterator(self, flag):
        if flag == 0:
            return 0, 0, 1
        return 0, 0, -1

    # --------------------------------------------------------------------
    # time query from other tools

    def findtime(self, n):
        if n == 0:
            return 0
        raise ValueError(&#34;no step %d exists&#34; % n)

    # --------------------------------------------------------------------
    # return list of atoms and bonds to viz for data object

    def viz(self, isnap):
        if isnap:
            raise ValueError(&#34;cannot call data.viz() with isnap != 0&#34;)

        id = self.names[&#34;id&#34;]
        type = self.names[&#34;type&#34;]
        x = self.names[&#34;x&#34;]
        y = self.names[&#34;y&#34;]
        z = self.names[&#34;z&#34;]

        xlohi = self.headers[&#34;xlo xhi&#34;]
        ylohi = self.headers[&#34;ylo yhi&#34;]
        zlohi = self.headers[&#34;zlo zhi&#34;]
        box = [xlohi[0], ylohi[0], zlohi[0], xlohi[1], ylohi[1], zlohi[1]]

        # create atom list needed by viz from id,type,x,y,z

        atoms = []
        atomlines = self.sections[&#34;Atoms&#34;]
        for line in atomlines:
            words = line.split()
            atoms.append(
                [
                    int(words[id]),
                    int(words[type]),
                    float(words[x]),
                    float(words[y]),
                    float(words[z]),
                ]
            )

        # create list of current bond coords from list of bonds
        # assumes atoms are sorted so can lookup up the 2 atoms in each bond

        bonds = []
        if self.sections.has_key(&#34;Bonds&#34;):
            bondlines = self.sections[&#34;Bonds&#34;]
            for line in bondlines:
                words = line.split()
                bid, btype = int(words[0]), int(words[1])
                atom1, atom2 = int(words[2]), int(words[3])
                atom1words = atomlines[atom1 - 1].split()
                atom2words = atomlines[atom2 - 1].split()
                bonds.append(
                    [
                        bid,
                        btype,
                        float(atom1words[x]),
                        float(atom1words[y]),
                        float(atom1words[z]),
                        float(atom2words[x]),
                        float(atom2words[y]),
                        float(atom2words[z]),
                        float(atom1words[type]),
                        float(atom2words[type]),
                    ]
                )

        tris = []
        lines = []
        return 0, box, atoms, bonds, tris, lines

    # --------------------------------------------------------------------
    # return box size

    def maxbox(self):
        xlohi = self.headers[&#34;xlo xhi&#34;]
        ylohi = self.headers[&#34;ylo yhi&#34;]
        zlohi = self.headers[&#34;zlo zhi&#34;]
        return [xlohi[0], ylohi[0], zlohi[0], xlohi[1], ylohi[1], zlohi[1]]

    # --------------------------------------------------------------------
    # return number of atom types

    def maxtype(self):
        return self.headers[&#34;atom types&#34;]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="data3.data.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, name, vector, forceinteger=False, propertyname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>append a new column: X.append("section",vectorofvalues,forceinteger=False,propertyname=None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, name, vector, forceinteger = False, propertyname=None):
    &#34;&#34;&#34; append a new column: X.append(&#34;section&#34;,vectorofvalues,forceinteger=False,propertyname=None) &#34;&#34;&#34;
    if name not in self.sections:
        self.sections[name] = []
        print(&#39;Add section [%s] - file=&#34;%s&#34;&#39; % (name,self.title) )
    lines = self.sections[name]
    nlines = len(lines)
    if not isinstance(vector,list) and not isinstance(vector,np.ndarray):
        vector = [vector]
    if propertyname != None:
        print(&#39;\t&gt; Add &#34;%s&#34; (%d values) to [%s]&#39; % (propertyname,len(vector),name))
    else:
        print(&#39;\t&gt; Add %d values (no name) to [%s]&#39; % (len(vector),name))
    newlines = []
    if nlines == 0:           # empty atoms section, create first column
        nlines = len(vector)  # new column length = input column length
        for i in range(nlines):
            if forceinteger:
                line = str(int(vector[i]))
            else:
                line = str(vector[i])
            newlines.append(line)
    else:
        if len(vector)==1: vector = vector * nlines
        if len(vector) != nlines:
            raise ValueError(&#39;the length of new data (%d) in section &#34;%s&#34; does not match the number of rows %d&#39; % \
                             (len(vector),name,nlines))
        for i in range(nlines):
            line = lines[i]
            words = line.split()
            if forceinteger:
                words.append(str(int(vector[i])))
            else:
                words.append(str(vector[i]))
            newline = &#34; &#34;.join(words) + &#34;\n&#34;
            newlines.append(newline)
    self.sections[name] = newlines</code></pre>
</details>
</dd>
<dt id="data3.data.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, keyword)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, keyword):

    if keyword in self.headers: # if self.headers.has_key(keyword):
        del self.headers[keyword]
    elif keyword in self.sections: # elif self.sections.has_key(keyword):
        del self.sections[keyword]
    else:
        raise ValueError(&#34;keyword not found in data object&#34;)</code></pre>
</details>
</dd>
<dt id="data3.data.dispsection"><code class="name flex">
<span>def <span class="ident">dispsection</span></span>(<span>self, name, flaghead=True)</span>
</code></dt>
<dd>
<div class="desc"><p>display section info: X.dispsection("sectionname")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispsection(self, name,flaghead=True):
    &#34;&#34;&#34; display section info: X.dispsection(&#34;sectionname&#34;) &#34;&#34;&#34;
    lines = self.sections[name]
    nlines = len(lines)
    line = lines[0]
    words = line.split()
    ret = &#39;&#34;%s&#34;: %d x %d values&#39; % (name,nlines,len(words))

    if flaghead: ret = &#34;LAMMPS data section &#34;+ret
    return ret</code></pre>
</details>
</dd>
<dt id="data3.data.findtime"><code class="name flex">
<span>def <span class="ident">findtime</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findtime(self, n):
    if n == 0:
        return 0
    raise ValueError(&#34;no step %d exists&#34; % n)</code></pre>
</details>
</dd>
<dt id="data3.data.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, *list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, *list):
    if len(list) == 1:
        field = list[0]
        array = []
        lines = self.sections[field]
        for line in lines:
            words = line.split()
            values = map(float, words)
            array.append(values)
        return array
    elif len(list) == 2:
        field = list[0]
        n = list[1] - 1
        vec = []
        lines = self.sections[field]
        for line in lines:
            words = line.split()
            vec.append(float(words[n]))
        return vec
    else:
        raise ValueError(&#34;invalid arguments for data.get()&#34;)</code></pre>
</details>
</dd>
<dt id="data3.data.iterator"><code class="name flex">
<span>def <span class="ident">iterator</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterator(self, flag):
    if flag == 0:
        return 0, 0, 1
    return 0, 0, -1</code></pre>
</details>
</dd>
<dt id="data3.data.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, *pairs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, *pairs):
    if len(pairs) % 2 != 0:
        raise ValueError (&#34;data map() requires pairs of mappings&#34;)
    for i in range(0, len(pairs), 2):
        j = i + 1
        self.names[pairs[j]] = pairs[i] - 1</code></pre>
</details>
</dd>
<dt id="data3.data.maxbox"><code class="name flex">
<span>def <span class="ident">maxbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxbox(self):
    xlohi = self.headers[&#34;xlo xhi&#34;]
    ylohi = self.headers[&#34;ylo yhi&#34;]
    zlohi = self.headers[&#34;zlo zhi&#34;]
    return [xlohi[0], ylohi[0], zlohi[0], xlohi[1], ylohi[1], zlohi[1]]</code></pre>
</details>
</dd>
<dt id="data3.data.maxtype"><code class="name flex">
<span>def <span class="ident">maxtype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxtype(self):
    return self.headers[&#34;atom types&#34;]</code></pre>
</details>
</dd>
<dt id="data3.data.newxyz"><code class="name flex">
<span>def <span class="ident">newxyz</span></span>(<span>self, dm, ntime)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newxyz(self, dm, ntime):
    nsnap = dm.findtime(ntime)
    print(&#34;&gt;&gt; newxyz for %d snaps&#34; % nsnap)

    dm.sort(ntime)
    x, y, z = dm.vecs(ntime, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;)

    self.replace(&#34;Atoms&#34;, self.names[&#34;x&#34;] + 1, x)
    self.replace(&#34;Atoms&#34;, self.names[&#34;y&#34;] + 1, y)
    self.replace(&#34;Atoms&#34;, self.names[&#34;z&#34;] + 1, z)

    if &#34;ix&#34; in dm.names and &#34;ix&#34; in self.names: #if dm.names.has_key(&#34;ix&#34;) and self.names.has_key(&#34;ix&#34;):
        ix, iy, iz = dm.vecs(ntime, &#34;ix&#34;, &#34;iy&#34;, &#34;iz&#34;)
        self.replace(&#34;Atoms&#34;, self.names[&#34;ix&#34;] + 1, ix)
        self.replace(&#34;Atoms&#34;, self.names[&#34;iy&#34;] + 1, iy)
        self.replace(&#34;Atoms&#34;, self.names[&#34;iz&#34;] + 1, iz)</code></pre>
</details>
</dd>
<dt id="data3.data.reorder"><code class="name flex">
<span>def <span class="ident">reorder</span></span>(<span>self, name, *order)</span>
</code></dt>
<dd>
<div class="desc"><p>reorder columns: reorder("section",colidxfirst,colidxsecond,colidxthird,&hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reorder(self, name, *order):
    &#34;&#34;&#34; reorder columns: reorder(&#34;section&#34;,colidxfirst,colidxsecond,colidxthird,...)  &#34;&#34;&#34;
    if name not in self.sections:
        raise ValueError(&#39;&#34;%s&#34; is not a valid section name&#39; % name)
    n = len(order)
    print(&#34;&gt;&gt; reorder for %d columns&#34; % n)
    natoms = len(self.sections[name])
    oldlines = self.sections[name]
    newlines = natoms * [&#34;&#34;]
    for index in order:
        for i in range(len(newlines)):
            words = oldlines[i].split()
            newlines[i] += words[index - 1] + &#34; &#34;
    for i in range(len(newlines)):
        newlines[i] += &#34;\n&#34;
    self.sections[name] = newlines</code></pre>
</details>
</dd>
<dt id="data3.data.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, name, icol, vector)</span>
</code></dt>
<dd>
<div class="desc"><p>replace column values: replace("section",columnindex,vectorofvalues) with columnindex=1..ncolumns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, name, icol, vector):
    &#34;&#34;&#34; replace column values: replace(&#34;section&#34;,columnindex,vectorofvalues) with columnindex=1..ncolumns &#34;&#34;&#34;
    lines = self.sections[name]
    nlines = len(lines)
    if name not in self.sections:
        raise ValueError(&#39;&#34;%s&#34; is not a valid section name&#39; % name)
    if not isinstance(vector,list): vector = [vector]
    if len(vector)==1: vector = vector * nlines
    if len(vector) != nlines:
        raise ValueError(&#39;the length of new data (%d) in section &#34;%s&#34; does not match the number of rows %d&#39; % \
                         (len(vector),name,nlines))
    newlines = []
    j = icol - 1
    for i in range(nlines):
        line = lines[i]
        words = line.split()
        words[j] = str(vector[i])
        newline = &#34; &#34;.join(words) + &#34;\n&#34;
        newlines.append(newline)
    self.sections[name] = newlines</code></pre>
</details>
</dd>
<dt id="data3.data.viz"><code class="name flex">
<span>def <span class="ident">viz</span></span>(<span>self, isnap)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz(self, isnap):
    if isnap:
        raise ValueError(&#34;cannot call data.viz() with isnap != 0&#34;)

    id = self.names[&#34;id&#34;]
    type = self.names[&#34;type&#34;]
    x = self.names[&#34;x&#34;]
    y = self.names[&#34;y&#34;]
    z = self.names[&#34;z&#34;]

    xlohi = self.headers[&#34;xlo xhi&#34;]
    ylohi = self.headers[&#34;ylo yhi&#34;]
    zlohi = self.headers[&#34;zlo zhi&#34;]
    box = [xlohi[0], ylohi[0], zlohi[0], xlohi[1], ylohi[1], zlohi[1]]

    # create atom list needed by viz from id,type,x,y,z

    atoms = []
    atomlines = self.sections[&#34;Atoms&#34;]
    for line in atomlines:
        words = line.split()
        atoms.append(
            [
                int(words[id]),
                int(words[type]),
                float(words[x]),
                float(words[y]),
                float(words[z]),
            ]
        )

    # create list of current bond coords from list of bonds
    # assumes atoms are sorted so can lookup up the 2 atoms in each bond

    bonds = []
    if self.sections.has_key(&#34;Bonds&#34;):
        bondlines = self.sections[&#34;Bonds&#34;]
        for line in bondlines:
            words = line.split()
            bid, btype = int(words[0]), int(words[1])
            atom1, atom2 = int(words[2]), int(words[3])
            atom1words = atomlines[atom1 - 1].split()
            atom2words = atomlines[atom2 - 1].split()
            bonds.append(
                [
                    bid,
                    btype,
                    float(atom1words[x]),
                    float(atom1words[y]),
                    float(atom1words[z]),
                    float(atom2words[x]),
                    float(atom2words[y]),
                    float(atom2words[z]),
                    float(atom1words[type]),
                    float(atom2words[type]),
                ]
            )

    tris = []
    lines = []
    return 0, box, atoms, bonds, tris, lines</code></pre>
</details>
</dd>
<dt id="data3.data.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file):
    f = open(file, &#34;w&#34;)
    print(self.title,file=f)
    for keyword in hkeywords:
        if keyword in self.headers: # self.headers.has_key(keyword):
            if keyword == &#34;xlo xhi&#34; or keyword == &#34;ylo yhi&#34; or keyword == &#34;zlo zhi&#34;:
                pair = self.headers[keyword]
                print(pair[0], pair[1], keyword,file=f)
            elif keyword == &#34;xy xz yz&#34;:
                triple = self.headers[keyword]
                print(triple[0], triple[1], triple[2], keyword,file=f)
            else:
                print(self.headers[keyword], keyword,file=f)
    for pair in skeywords:
        keyword = pair[0]
        if keyword in self.sections: #self.sections.has_key(keyword):
            print(&#34;\n%s\n&#34; % keyword,file=f)
            for line in self.sections[keyword]:
                print(line,file=f,end=&#34;&#34;)
    f.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="data3.dump"><code class="flex name class">
<span>class <span class="ident">dump</span></span>
<span>(</span><span>*list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dump:

    # --------------------------------------------------------------------

    def __init__(self, *list):
        self.snaps = []
        self.nsnaps = self.nselect = 0
        self.names = {}
        self.tselect = tselect(self)
        self.aselect = aselect(self)
        self.atype = &#34;type&#34;
        self.bondflag = 0
        self.bondlist = []
        self.triflag = 0
        self.trilist = []
        self.lineflag = 0
        self.linelist = []
        self.objextra = None

        # flist = list of all dump file names

        words = list[0].split()
        self.flist = []
        for word in words:
            self.flist += glob.glob(word)
        if len(self.flist) == 0 and len(list) == 1:
            raise ValueError(&#34;no dump file specified&#34;)

        if len(list) == 1:
            self.increment = 0
            self.read_all()
        else:
            self.increment = 1
            self.nextfile = 0
            self.eof = 0

    # --------------------------------------------------------------------

    def __repr__(self):
        times = self.time();
        ntimes = len(times)
        lastime = times[-1];
        fields = self.names;
        print(&#34;Dump file: %s\ncontains %d frames (tend=%0.4g)\nwith fields&#34; % \
              (self.flist[0],ntimes,lastime) )
        for k  in sorted(fields,key=fields.get,reverse=False):
            print(&#34;\t%02d: %s&#34; % (fields[k],k) )
        ret = &#39;LAMMPS dump object with %d properties and %d frames (tend=%0.4g, - source=&#34;%s&#34;&#39; % \
            (len(fields),ntimes,lastime,self.flist[0])
        return ret

    # --------------------------------------------------------------------

    def read_all(self):

        # read all snapshots from each file
        # test for gzipped files

        for file in self.flist:
            if file[-3:] == &#34;.gz&#34;:
                f = popen(&#34;%s -c %s&#34; % (PIZZA_GUNZIP, file), &#34;r&#34;)
            else:
                f = open(file)

            snap = self.read_snapshot(f)
            while snap:
                self.snaps.append(snap)
                print(snap.time, file=sys.stdout, flush=True, end=&#34; &#34;)
                snap = self.read_snapshot(f)

            f.close()
        print

        # sort entries by timestep, cull duplicates

        self.snaps.sort()  # self.snaps.sort(self.compare_time)  #%% to be fixed in the future (OV)
        self.cull()
        self.nsnaps = len(self.snaps)
        print(&#34;read %d snapshots&#34; % (self.nsnaps))

        # select all timesteps and atoms

        self.tselect.all()

        # print column assignments

        if len(self.names):
            print(&#34;assigned columns:&#34;, &#34;,&#34;.join(list(self.names.keys())))
        else:
            print(&#34;no column assignments made&#34;)

        # if snapshots are scaled, unscale them

        if (
            (not &#34;x&#34; in self.names)
            or (not &#34;y&#34; in self.names)
            or (not &#34;z&#34; in self.names)
        ):
            print(&#34;dump scaling status is unknown&#34;)
        elif self.nsnaps &gt; 0:
            if self.scale_original == 1:
                self.unscale()
            elif self.scale_original == 0:
                print(&#34;dump is already unscaled&#34;)
            else:
                print(&#34;dump scaling status is unknown&#34;)

    # --------------------------------------------------------------------
    # read next snapshot from list of files

    def next(self):

        if not self.increment:
            raise ValueError(&#34;cannot read incrementally&#34;)

        # read next snapshot in current file using eof as pointer
        # if fail, try next file
        # if new snapshot time stamp already exists, read next snapshot

        while 1:
            f = open(self.flist[self.nextfile], &#34;rb&#34;)
            f.seek(self.eof)
            snap = self.read_snapshot(f)
            if not snap:
                self.nextfile += 1
                if self.nextfile == len(self.flist):
                    return -1
                f.close()
                self.eof = 0
                continue
            self.eof = f.tell()
            f.close()
            try:
                self.findtime(snap.time)
                continue
            except:
                break

        # select the new snapshot with all its atoms

        self.snaps.append(snap)
        snap = self.snaps[self.nsnaps]
        snap.tselect = 1
        snap.nselect = snap.natoms
        for i in range(snap.natoms):
            snap.aselect[i] = True
        self.nsnaps += 1
        self.nselect += 1

        return snap.time

    # --------------------------------------------------------------------
    # read a single snapshot from file f
    # return snapshot or 0 if failed
    # for first snapshot only:
    #   assign column names (file must be self-describing)
    #   set scale_original to 0/1/-1 for unscaled/scaled/unknown
    #   convert xs,xu to x in names

    def read_snapshot(self, f):
        &#34;&#34;&#34; low-level method to read a snapshot from a file identifier &#34;&#34;&#34;

        # expand the list of keywords if needed (INRAE\Olivier Vitrac)
        # &#34;keyname&#34;: [&#34;name in snap&#34;,&#34;type&#34;]
        itemkeywords = {&#34;TIME&#34;: [&#34;realtime&#34;,&#34;float&#34;],
                        &#34;TIMESTEP&#34;: [&#34;time&#34;,&#34;int&#34;],
                        &#34;NUMBER OF ATOMS&#34;: [&#34;natoms&#34;,&#34;int&#34;]}
        try:
            snap = Snap()

            # read and guess the first keywords based on itemkeywords
            found = True
            while found:
                item = f.readline()
                varitem = item.split(&#34;ITEM:&#34;)[1].strip()
                found = varitem in itemkeywords
                if found:
                    tmp = f.readline().split()[0]  # just grab 1st field
                    if itemkeywords[varitem][1]==&#34;int&#34;:
                        valitem = int(tmp)
                    else:
                        valitem = float(tmp)
                    setattr(snap,itemkeywords[varitem][0],valitem)

            # prefetch
            snap.aselect = np.zeros(snap.natoms,dtype=bool)

            # we assume that the next item is BOX BOUNDS (pp ff pp)
            words = item.split(&#34;BOUNDS &#34;)
            if len(words) == 1:
                snap.boxstr = &#34;&#34;
            else:
                snap.boxstr = words[1].strip()
            if &#34;xy&#34; in snap.boxstr:
                snap.triclinic = 1
            else:
                snap.triclinic = 0

            words = f.readline().split()
            if len(words) == 2:
                snap.xlo, snap.xhi, snap.xy = float(words[0]), float(words[1]), 0.0
            else:
                snap.xlo, snap.xhi, snap.xy = (
                    float(words[0]),
                    float(words[1]),
                    float(words[2]),
                )

            words = f.readline().split()
            if len(words) == 2:
                snap.ylo, snap.yhi, snap.xz = float(words[0]), float(words[1]), 0.0
            else:
                snap.ylo, snap.yhi, snap.xz = (
                    float(words[0]),
                    float(words[1]),
                    float(words[2]),
                )

            words = f.readline().split()
            if len(words) == 2:
                snap.zlo, snap.zhi, snap.yz = float(words[0]), float(words[1]), 0.0
            else:
                snap.zlo, snap.zhi, snap.yz = (
                    float(words[0]),
                    float(words[1]),
                    float(words[2]),
                )

            item = f.readline()
            if len(self.names) == 0:
                self.scale_original = -1
                xflag = yflag = zflag = -1
                words = item.split()[2:]
                if len(words):
                    for i in range(len(words)):
                        if words[i] == &#34;x&#34; or words[i] == &#34;xu&#34;:
                            xflag = 0
                            self.names[&#34;x&#34;] = i
                        elif words[i] == &#34;xs&#34; or words[i] == &#34;xsu&#34;:
                            xflag = 1
                            self.names[&#34;x&#34;] = i
                        elif words[i] == &#34;y&#34; or words[i] == &#34;yu&#34;:
                            yflag = 0
                            self.names[&#34;y&#34;] = i
                        elif words[i] == &#34;ys&#34; or words[i] == &#34;ysu&#34;:
                            yflag = 1
                            self.names[&#34;y&#34;] = i
                        elif words[i] == &#34;z&#34; or words[i] == &#34;zu&#34;:
                            zflag = 0
                            self.names[&#34;z&#34;] = i
                        elif words[i] == &#34;zs&#34; or words[i] == &#34;zsu&#34;:
                            zflag = 1
                            self.names[&#34;z&#34;] = i
                        else:
                            self.names[words[i]] = i
                    if xflag == 0 and yflag == 0 and zflag == 0:
                        self.scale_original = 0
                    if xflag == 1 and yflag == 1 and zflag == 1:
                        self.scale_original = 1

            if snap.natoms:
                words = f.readline().split()
                ncol = len(words)
                for i in range(1, snap.natoms):
                    words += f.readline().split()
                floats = list(map(float, words))
                if oldnumeric:
                    atoms = np.zeros((snap.natoms, ncol), np.float64)
                else:
                    atoms = np.zeros((snap.natoms, ncol), np.float64)
                start = 0
                stop = ncol
                for i in range(snap.natoms):
                    atoms[i] = floats[start:stop]
                    start = stop
                    stop += ncol
            else:
                atoms = None
            snap.atoms = atoms
            return snap
        except:
            return 0

    # --------------------------------------------------------------------
    # map atom column names

    def map(self, *pairs):
        if len(pairs) % 2 != 0:
            raise ValueError(&#34;dump map() requires pairs of mappings&#34;)
        for i in range(0, len(pairs), 2):
            j = i + 1
            self.names[pairs[j]] = pairs[i] - 1

    # --------------------------------------------------------------------
    # delete unselected snapshots

    def delete(self):
        ndel = i = 0
        while i &lt; self.nsnaps:
            if not self.snaps[i].tselect:
                del self.snaps[i]
                self.nsnaps -= 1
                ndel += 1
            else:
                i += 1
        print(&#34;%d snapshots deleted&#34; % ndel)
        print(&#34;%d snapshots remaining&#34; % self.nsnaps)

    # --------------------------------------------------------------------
    # scale coords to 0-1 for all snapshots or just one
    # use 6 params as h-matrix to treat orthongonal or triclinic boxes

    def scale(self, *list):
        if len(list) == 0:
            print(&#34;Scaling dump ...&#34;)
            x = self.names[&#34;x&#34;]
            y = self.names[&#34;y&#34;]
            z = self.names[&#34;z&#34;]
            for snap in self.snaps:
                self.scale_one(snap, x, y, z)
        else:
            i = self.findtime(list[0])
            x = self.names[&#34;x&#34;]
            y = self.names[&#34;y&#34;]
            z = self.names[&#34;z&#34;]
            self.scale_one(self.snaps[i], x, y, z)

    # --------------------------------------------------------------------

    def scale_one(self, snap, x, y, z):
        if snap.xy == 0.0 and snap.xz == 0.0 and snap.yz == 0.0:
            xprdinv = 1.0 / (snap.xhi - snap.xlo)
            yprdinv = 1.0 / (snap.yhi - snap.ylo)
            zprdinv = 1.0 / (snap.zhi - snap.zlo)
            atoms = snap.atoms
            if atoms != None:
                atoms[:, x] = (atoms[:, x] - snap.xlo) * xprdinv
                atoms[:, y] = (atoms[:, y] - snap.ylo) * yprdinv
                atoms[:, z] = (atoms[:, z] - snap.zlo) * zprdinv
        else:
            xlo_bound = snap.xlo
            xhi_bound = snap.xhi
            ylo_bound = snap.ylo
            yhi_bound = snap.yhi
            zlo_bound = snap.zlo
            zhi_bound = snap.zhi
            xy = snap.xy
            xz = snap.xz
            yz = snap.yz
            xlo = xlo_bound - min((0.0, xy, xz, xy + xz))
            xhi = xhi_bound - max((0.0, xy, xz, xy + xz))
            ylo = ylo_bound - min((0.0, yz))
            yhi = yhi_bound - max((0.0, yz))
            zlo = zlo_bound
            zhi = zhi_bound
            h0 = xhi - xlo
            h1 = yhi - ylo
            h2 = zhi - zlo
            h3 = yz
            h4 = xz
            h5 = xy
            h0inv = 1.0 / h0
            h1inv = 1.0 / h1
            h2inv = 1.0 / h2
            h3inv = yz / (h1 * h2)
            h4inv = (h3 * h5 - h1 * h4) / (h0 * h1 * h2)
            h5inv = xy / (h0 * h1)
            atoms = snap.atoms
            if atoms != None:
                atoms[:, x] = (
                    (atoms[:, x] - snap.xlo) * h0inv
                    + (atoms[:, y] - snap.ylo) * h5inv
                    + (atoms[:, z] - snap.zlo) * h4inv
                )
                atoms[:, y] = (atoms[:, y] - snap.ylo) * h1inv + (
                    atoms[:, z] - snap.zlo
                ) * h3inv
                atoms[:, z] = (atoms[:, z] - snap.zlo) * h2inv

    # --------------------------------------------------------------------
    # unscale coords from 0-1 to box size for all snapshots or just one
    # use 6 params as h-matrix to treat orthongonal or triclinic boxes

    def unscale(self, *list):
        if len(list) == 0:
            print(&#34;Unscaling dump ...&#34;)
            x = self.names[&#34;x&#34;]
            y = self.names[&#34;y&#34;]
            z = self.names[&#34;z&#34;]
            for snap in self.snaps:
                self.unscale_one(snap, x, y, z)
        else:
            i = self.findtime(list[0])
            x = self.names[&#34;x&#34;]
            y = self.names[&#34;y&#34;]
            z = self.names[&#34;z&#34;]
            self.unscale_one(self.snaps[i], x, y, z)

    # --------------------------------------------------------------------

    def unscale_one(self, snap, x, y, z):
        if snap.xy == 0.0 and snap.xz == 0.0 and snap.yz == 0.0:
            xprd = snap.xhi - snap.xlo
            yprd = snap.yhi - snap.ylo
            zprd = snap.zhi - snap.zlo
            atoms = snap.atoms
            if atoms != None:
                atoms[:, x] = snap.xlo + atoms[:, x] * xprd
                atoms[:, y] = snap.ylo + atoms[:, y] * yprd
                atoms[:, z] = snap.zlo + atoms[:, z] * zprd
        else:
            xlo_bound = snap.xlo
            xhi_bound = snap.xhi
            ylo_bound = snap.ylo
            yhi_bound = snap.yhi
            zlo_bound = snap.zlo
            zhi_bound = snap.zhi
            xy = snap.xy
            xz = snap.xz
            yz = snap.yz
            xlo = xlo_bound - min((0.0, xy, xz, xy + xz))
            xhi = xhi_bound - max((0.0, xy, xz, xy + xz))
            ylo = ylo_bound - min((0.0, yz))
            yhi = yhi_bound - max((0.0, yz))
            zlo = zlo_bound
            zhi = zhi_bound
            h0 = xhi - xlo
            h1 = yhi - ylo
            h2 = zhi - zlo
            h3 = yz
            h4 = xz
            h5 = xy
            atoms = snap.atoms
            if atoms != None:
                atoms[:, x] = (
                    snap.xlo + atoms[:, x] * h0 + atoms[:, y] * h5 + atoms[:, z] * h4
                )
                atoms[:, y] = snap.ylo + atoms[:, y] * h1 + atoms[:, z] * h3
                atoms[:, z] = snap.zlo + atoms[:, z] * h2

    # --------------------------------------------------------------------
    # wrap coords from outside box to inside

    def wrap(self):
        print(&#34;Wrapping dump ...&#34;)

        x = self.names[&#34;x&#34;]
        y = self.names[&#34;y&#34;]
        z = self.names[&#34;z&#34;]
        ix = self.names[&#34;ix&#34;]
        iy = self.names[&#34;iy&#34;]
        iz = self.names[&#34;iz&#34;]

        for snap in self.snaps:
            xprd = snap.xhi - snap.xlo
            yprd = snap.yhi - snap.ylo
            zprd = snap.zhi - snap.zlo
            atoms = snap.atoms
            atoms[:, x] -= atoms[:, ix] * xprd
            atoms[:, y] -= atoms[:, iy] * yprd
            atoms[:, z] -= atoms[:, iz] * zprd

    # --------------------------------------------------------------------
    # unwrap coords from inside box to outside

    def unwrap(self):
        print(&#34;Unwrapping dump ...&#34;)

        x = self.names[&#34;x&#34;]
        y = self.names[&#34;y&#34;]
        z = self.names[&#34;z&#34;]
        ix = self.names[&#34;ix&#34;]
        iy = self.names[&#34;iy&#34;]
        iz = self.names[&#34;iz&#34;]

        for snap in self.snaps:
            xprd = snap.xhi - snap.xlo
            yprd = snap.yhi - snap.ylo
            zprd = snap.zhi - snap.zlo
            atoms = snap.atoms
            atoms[:, x] += atoms[:, ix] * xprd
            atoms[:, y] += atoms[:, iy] * yprd
            atoms[:, z] += atoms[:, iz] * zprd

    # --------------------------------------------------------------------
    # wrap coords to same image as atom ID stored in &#34;other&#34; column
    # if dynamic extra lines or triangles defined, owrap them as well

    def owrap(self, other):
        print(&#34;Wrapping to other ...&#34;)

        id = self.names[&#34;id&#34;]
        x = self.names[&#34;x&#34;]
        y = self.names[&#34;y&#34;]
        z = self.names[&#34;z&#34;]
        ix = self.names[&#34;ix&#34;]
        iy = self.names[&#34;iy&#34;]
        iz = self.names[&#34;iz&#34;]
        iother = self.names[other]

        for snap in self.snaps:
            xprd = snap.xhi - snap.xlo
            yprd = snap.yhi - snap.ylo
            zprd = snap.zhi - snap.zlo
            atoms = snap.atoms
            ids = {}
            for i in range(snap.natoms):
                ids[atoms[i][id]] = i
            for i in range(snap.natoms):
                j = ids[atoms[i][iother]]
                atoms[i][x] += (atoms[i][ix] - atoms[j][ix]) * xprd
                atoms[i][y] += (atoms[i][iy] - atoms[j][iy]) * yprd
                atoms[i][z] += (atoms[i][iz] - atoms[j][iz]) * zprd
            # should bonds also be owrapped ?
            if self.lineflag == 2 or self.triflag == 2:
                self.objextra.owrap(
                    snap.time, xprd, yprd, zprd, ids, atoms, iother, ix, iy, iz
                )

    # --------------------------------------------------------------------
    # convert column names assignment to a string, in column order

    def names2str(self):
        # &lt;--  Python 2.x  --&gt;
        # pairs = self.names.items()
        # values = self.names.values()
        # ncol = len(pairs)
        # str = &#34;&#34;
        # for i in range(ncol):
        #   if i in values: str += pairs[values.index(i)][0] + &#39; &#39;
        # &lt;--  Python 3.x  --&gt;
        str = &#34;&#34;
        for k in sorted(self.names, key=self.names.get, reverse=False):
            str += k + &#34; &#34;
        return str

    # --------------------------------------------------------------------
    # sort atoms by atom ID in all selected timesteps by default
    # if arg = string, sort all steps by that column
    # if arg = numeric, sort atoms in single step

    def sort(self, *listarg):
        if len(listarg) == 0:
            print(&#34;Sorting selected snapshots ...&#34;)
            id = self.names[&#34;id&#34;]
            for snap in self.snaps:
                if snap.tselect:
                    self.sort_one(snap, id)
        elif type(listarg[0]) is types.StringType:
            print(&#34;Sorting selected snapshots by %s ...&#34; % listarg[0])
            id = self.names[listarg[0]]
            for snap in self.snaps:
                if snap.tselect:
                    self.sort_one(snap, id)
        else:
            i = self.findtime(listarg[0])
            id = self.names[&#34;id&#34;]
            self.sort_one(self.snaps[i], id)

    # --------------------------------------------------------------------
    # sort a single snapshot by ID column

    def sort_one(self, snap, id):
        atoms = snap.atoms
        ids = atoms[:, id]
        ordering = np.argsort(ids)
        for i in range(len(atoms[0])):
            atoms[:, i] = np.take(atoms[:, i], ordering)

    # --------------------------------------------------------------------
    # write a single dump file from current selection

    def write(self, file, header=1, append=0):
        if len(self.snaps):
            namestr = self.names2str()
        if not append:
            f = open(file, &#34;w&#34;)
        else:
            f = open(file, &#34;a&#34;)

        if &#34;id&#34; in self.names:
            id = self.names[&#34;id&#34;]
        else:
            id = -1
        if &#34;type&#34; in self.names:
            type = self.names[&#34;type&#34;]
        else:
            type = -1

        for snap in self.snaps:
            if not snap.tselect:
                continue
            print(snap.time, file=sys.stdout, flush=True)

            if header:
                print(&#34;ITEM: TIMESTEP&#34;, file=f)
                print(snap.time, file=f)
                print(&#34;ITEM: NUMBER OF ATOMS&#34;, file=f)
                print(snap.nselect, file=f)
                if snap.boxstr:
                    print(&#34;ITEM: BOX BOUNDS&#34;, snap.boxstr, file=f)
                else:
                    print(&#34;ITEM: BOX BOUNDS&#34;, file=f)
                if snap.triclinic:
                    print(snap.xlo, snap.xhi, snap.xy, file=f)
                    print(snap.ylo, snap.yhi, snap.xz, file=f)
                    print(snap.zlo, snap.zhi, snap.yz, file=f)
                else:
                    print(snap.xlo, snap.xhi, file=f)
                    print(snap.ylo, snap.yhi, file=f)
                    print(snap.zlo, snap.zhi, file=f)
                print(&#34;ITEM: ATOMS&#34;, namestr, file=f)

            atoms = snap.atoms
            nvalues = len(atoms[0])
            for i in range(snap.natoms):
                if not snap.aselect[i]:
                    continue
                line = &#34;&#34;
                for j in range(nvalues):
                    if j == id or j == type:
                        line += str(int(atoms[i][j])) + &#34; &#34;
                    else:
                        line += str(atoms[i][j]) + &#34; &#34;
                print(line, file=f)
        f.close()
        print(&#34;\n%d snapshots&#34; % self.nselect)

    # --------------------------------------------------------------------
    # write one dump file per snapshot from current selection

    def scatter(self, root):
        if len(self.snaps):
            namestr = self.names2str()
        for snap in self.snaps:
            if not snap.tselect:
                continue
            print(snap.time, file=sys.stdout, flush=True)

            file = root + &#34;.&#34; + str(snap.time)
            f = open(file, &#34;w&#34;)
            print(&#34;ITEM: TIMESTEP&#34;, file=f)
            print(snap.time, file=f)
            print(&#34;ITEM: NUMBER OF ATOMS&#34;, file=f)
            print(snap.nselect, file=f)
            if snap.boxstr:
                print(&#34;ITEM: BOX BOUNDS&#34;, snap.boxstr, file=f)
            else:
                print(&#34;ITEM: BOX BOUNDS&#34;, file=f)
            if snap.triclinic:
                print(snap.xlo, snap.xhi, snap.xy, file=f)
                print(snap.ylo, snap.yhi, snap.xz, file=f)
                print(snap.zlo, snap.zhi, snap.yz, file=f)
            else:
                print(snap.xlo, snap.xhi, file=f)
                print(snap.ylo, snap.yhi, file=f)
                print(snap.zlo, snap.zhi, file=f)
            print(&#34;ITEM: ATOMS&#34;, namestr, file=f)

            atoms = snap.atoms
            nvalues = len(atoms[0])
            for i in range(snap.natoms):
                if not snap.aselect[i]:
                    continue
                line = &#34;&#34;
                for j in range(nvalues):
                    if j &lt; 2:
                        line += str(int(atoms[i][j])) + &#34; &#34;
                    else:
                        line += str(atoms[i][j]) + &#34; &#34;
                print(line, file=f)
            f.close()
        print(&#34;\n%d snapshots&#34; % self.nselect)

    # --------------------------------------------------------------------
    # find min/max across all selected snapshots/atoms for a particular column

    def minmax(self, colname):
        icol = self.names[colname]
        min = 1.0e20
        max = -min
        for snap in self.snaps:
            if not snap.tselect:
                continue
            atoms = snap.atoms
            for i in range(snap.natoms):
                if not snap.aselect[i]:
                    continue
                if atoms[i][icol] &lt; min:
                    min = atoms[i][icol]
                if atoms[i][icol] &gt; max:
                    max = atoms[i][icol]
        return (min, max)

    # --------------------------------------------------------------------
    # set a column value via an equation for all selected snapshots

    def set(self, eq):
        print(&#34;Setting ...&#34;)
        pattern = &#34;\$\w*&#34;
        list = re.findall(pattern, eq)

        lhs = list[0][1:]
        if not self.names.has_key(lhs):
            self.newcolumn(lhs)

        for item in list:
            name = item[1:]
            column = self.names[name]
            insert = &#34;snap.atoms[i][%d]&#34; % (column)
            eq = eq.replace(item, insert)
        ceq = compile(eq, &#34;&#34;, &#34;single&#34;)

        for snap in self.snaps:
            if not snap.tselect:
                continue
            for i in range(snap.natoms):
                if snap.aselect[i]:
                    exec(ceq)

    # --------------------------------------------------------------------
    # set a column value via an input vec for all selected snapshots/atoms

    def setv(self, colname, vec):
        print(&#34;Setting ...&#34;)
        if not self.names.has_key(colname):
            self.newcolumn(colname)
        icol = self.names[colname]

        for snap in self.snaps:
            if not snap.tselect:
                continue
            if snap.nselect != len(vec):
                raise ValueError(&#34;vec length does not match # of selected atoms&#34;)
            atoms = snap.atoms
            m = 0
            for i in range(snap.natoms):
                if snap.aselect[i]:
                    atoms[i][icol] = vec[m]
                    m += 1

    # --------------------------------------------------------------------
    # clone value in col across selected timesteps for atoms with same ID

    def clone(self, nstep, col):
        istep = self.findtime(nstep)
        icol = self.names[col]
        id = self.names[&#34;id&#34;]
        ids = {}
        for i in range(self.snaps[istep].natoms):
            ids[self.snaps[istep].atoms[i][id]] = i
        for snap in self.snaps:
            if not snap.tselect:
                continue
            atoms = snap.atoms
            for i in range(snap.natoms):
                if not snap.aselect[i]:
                    continue
                j = ids[atoms[i][id]]
                atoms[i][icol] = self.snaps[istep].atoms[j][icol]

    # --------------------------------------------------------------------
    # values in old column are spread as ints from 1-N and assigned to new column

    def spread(self, old, n, new):
        iold = self.names[old]
        if not self.names.has_key(new):
            self.newcolumn(new)
        inew = self.names[new]

        min, max = self.minmax(old)
        print(&#34;min/max = &#34;, min, max)

        gap = max - min
        invdelta = n / gap
        for snap in self.snaps:
            if not snap.tselect:
                continue
            atoms = snap.atoms
            for i in range(snap.natoms):
                if not snap.aselect[i]:
                    continue
                ivalue = int((atoms[i][iold] - min) * invdelta) + 1
                if ivalue &gt; n:
                    ivalue = n
                if ivalue &lt; 1:
                    ivalue = 1
                atoms[i][inew] = ivalue

    # --------------------------------------------------------------------
    # return vector of selected snapshot time stamps
    #   time is based on TIMESTEP item
    #   realtime is based on TIME item

    def time(self):
        &#34;&#34;&#34; timestep as stored: time()&#34;&#34;&#34;
        vec = self.nselect * [0]
        i = 0
        for snap in self.snaps:
            if not snap.tselect:
                continue
            vec[i] = snap.time
            i += 1
        return vec

    def realtime(self):
        &#34;&#34;&#34; time as simulated: realtime() &#34;&#34;&#34;
        vec = self.nselect * [0.0]
        i = 0
        for snap in self.snaps:
            if not snap.tselect or not hasattr(snap,&#34;realtime&#34;):
                continue
            vec[i] = snap.realtime
            i += 1
        return vec

    # --------------------------------------------------------------------
    # extract vector(s) of values for atom ID n at each selected timestep

    def atom(self, n, *list):
        if len(list) == 0:
            raise ValueError(&#34;no columns specified&#34;)
        columns = []
        values = []
        for name in list:
            columns.append(self.names[name])
            values.append(self.nselect * [0])
        ncol = len(columns)

        id = self.names[&#34;id&#34;]
        m = 0
        for snap in self.snaps:
            if not snap.tselect:
                continue
            atoms = snap.atoms
            for i in range(snap.natoms):
                if atoms[i][id] == n:
                    break
            if atoms[i][id] != n:
                raise ValueError(&#34;could not find atom ID in snapshot&#34;)
            for j in range(ncol):
                values[j][m] = atoms[i][columns[j]]
            m += 1

        if len(list) == 1:
            return values[0]
        else:
            return values

    # --------------------------------------------------------------------
    # extract vector(s) of values for selected atoms at chosen timestep

    def vecs(self, n, *colname):
        &#34;&#34;&#34;
            vecs(timeste,columname1,columname2,...)
            Examples:
                tab = vecs(timestep,&#34;id&#34;,&#34;x&#34;,&#34;y&#34;)
                tab = vecs(timestep,[&#34;id&#34;,&#34;x&#34;,&#34;y&#34;],&#34;z&#34;)
                X.vecs(X.time()[50],&#34;vx&#34;,&#34;vy&#34;)
        &#34;&#34;&#34;
        snap = self.snaps[self.findtime(n)]

        if len(colname) == 0:
            raise ValueError(&#34;no columns specified&#34;)
        if isinstance(colname[0],tuple):
            colname = list(colname[0]) + list(colname[1:])
        if isinstance(colname[0],list):
            colname = colname[0] + list(colname[1:])
        columns = []
        values = []
        for name in colname:
            columns.append(self.names[name])
            values.append(snap.nselect * [0])
        ncol = len(columns)

        m = 0
        for i in range(snap.natoms):
            if not snap.aselect[i]:
                continue
            for j in range(ncol):
                values[j][m] = snap.atoms[i][columns[j]]
            m += 1

        if len(colname) == 1:
            return values[0]
        else:
            return values

    # --------------------------------------------------------------------
    # add a new column to every snapshot and set value to 0
    # set the name of the column to str

    def newcolumn(self, str):
        ncol = len(self.snaps[0].atoms[0])
        self.map(ncol + 1, str)
        for snap in self.snaps:
            # commented because not used
            # atoms = snap.atoms
            if oldnumeric:
                newatoms = np.zeros((snap.natoms, ncol + 1), np.Float)
            else:
                newatoms = np.zeros((snap.natoms, ncol + 1), np.float)
            newatoms[:, 0:ncol] = snap.atoms
            snap.atoms = newatoms

    # --------------------------------------------------------------------
    # sort snapshots on time stamp

    def compare_time(self, a, b):
        if a.time &lt; b.time:
            return -1
        elif a.time &gt; b.time:
            return 1
        else:
            return 0

    # --------------------------------------------------------------------
    # delete successive snapshots with duplicate time stamp

    def cull(self):
        i = 1
        while i &lt; len(self.snaps):
            if self.snaps[i].time == self.snaps[i - 1].time:
                del self.snaps[i]
            else:
                i += 1

    # --------------------------------------------------------------------
    # iterate over selected snapshots

    def iterator(self, flag):
        start = 0
        if flag:
            start = self.iterate + 1
        for i in range(start, self.nsnaps):
            if self.snaps[i].tselect:
                self.iterate = i
                return i, self.snaps[i].time, 1
        return 0, 0, -1

    # --------------------------------------------------------------------
    # return list of atoms to viz for snapshot isnap
    # if called with flag, then index is timestep, so convert to snapshot index
    # augment with bonds, tris, lines if extra() was invoked

    def viz(self, index, flag=0):
        if not flag:
            isnap = index
        else:
            times = self.time()
            n = len(times)
            i = 0
            while i &lt; n:
                if times[i] &gt; index:
                    break
                i += 1
            isnap = i - 1

        snap = self.snaps[isnap]

        time = snap.time
        box = [snap.xlo, snap.ylo, snap.zlo, snap.xhi, snap.yhi, snap.zhi]
        id = self.names[&#34;id&#34;]
        type = self.names[self.atype]
        x = self.names[&#34;x&#34;]
        y = self.names[&#34;y&#34;]
        z = self.names[&#34;z&#34;]

        # create atom list needed by viz from id,type,x,y,z
        # need Numeric/Numpy mode here

        atoms = []
        for i in range(snap.natoms):
            if not snap.aselect[i]:
                continue
            atom = snap.atoms[i]
            atoms.append([atom[id], atom[type], atom[x], atom[y], atom[z]])

        # create list of bonds from static or dynamic bond list
        # then generate bond coords from bondlist
        # alist = dictionary of atom IDs for atoms list
        # lookup bond atom IDs in alist and grab their coords
        # try is used since some atoms may be unselected
        #   any bond with unselected atom is not added to bonds
        # need Numeric/Numpy mode here

        bonds = []
        if self.bondflag:
            if self.bondflag == 1:
                bondlist = self.bondlist
            elif self.bondflag == 2:
                tmp1, tmp2, tmp3, bondlist, tmp4, tmp5 = self.objextra.viz(time, 1)
            alist = {}
            for i in range(len(atoms)):
                alist[int(atoms[i][0])] = i
            for bond in bondlist:
                try:
                    i = alist[bond[2]]
                    j = alist[bond[3]]
                    atom1 = atoms[i]
                    atom2 = atoms[j]
                    bonds.append(
                        [
                            bond[0],
                            bond[1],
                            atom1[2],
                            atom1[3],
                            atom1[4],
                            atom2[2],
                            atom2[3],
                            atom2[4],
                            atom1[1],
                            atom2[1],
                        ]
                    )
                except:
                    continue

        # create list of tris from static or dynamic tri list
        # if dynamic, could eliminate tris for unselected atoms

        tris = []
        if self.triflag:
            if self.triflag == 1:
                tris = self.trilist
            elif self.triflag == 2:
                tmp1, tmp2, tmp3, tmp4, tris, tmp5 = self.objextra.viz(time, 1)

        # create list of lines from static or dynamic tri list
        # if dynamic, could eliminate lines for unselected atoms

        lines = []
        if self.lineflag:
            if self.lineflag == 1:
                lines = self.linelist
            elif self.lineflag == 2:
                tmp1, tmp2, tmp3, tmp4, tmp5, lines = self.objextra.viz(time, 1)

        return time, box, atoms, bonds, tris, lines

    # --------------------------------------------------------------------

    def findtime(self, n):
        for i in range(self.nsnaps):
            if self.snaps[i].time == n:
                return i
        raise ValueError(&#34;no step %d exists&#34; % n)

    # --------------------------------------------------------------------
    # return maximum box size across all selected snapshots

    def maxbox(self):
        xlo = ylo = zlo = None
        xhi = yhi = zhi = None
        for snap in self.snaps:
            if not snap.tselect:
                continue
            if xlo == None or snap.xlo &lt; xlo:
                xlo = snap.xlo
            if xhi == None or snap.xhi &gt; xhi:
                xhi = snap.xhi
            if ylo == None or snap.ylo &lt; ylo:
                ylo = snap.ylo
            if yhi == None or snap.yhi &gt; yhi:
                yhi = snap.yhi
            if zlo == None or snap.zlo &lt; zlo:
                zlo = snap.zlo
            if zhi == None or snap.zhi &gt; zhi:
                zhi = snap.zhi
        return [xlo, ylo, zlo, xhi, yhi, zhi]

    # --------------------------------------------------------------------
    # return maximum atom type across all selected snapshots and atoms

    def maxtype(self):
        icol = self.names[&#34;type&#34;]
        max = 0
        for snap in self.snaps:
            if not snap.tselect:
                continue
            atoms = snap.atoms
            for i in range(snap.natoms):
                if not snap.aselect[i]:
                    continue
                if atoms[i][icol] &gt; max:
                    max = atoms[i][icol]
        return int(max)

    # --------------------------------------------------------------------
    # grab bonds/tris/lines from another object
    # if static, grab once, else store obj to grab dynamically

    def extra(self, arg):

        # data object, grab bonds statically

        if type(arg) is types.InstanceType and &#34;.data&#34; in str(arg.__class__):
            self.bondflag = 0
            try:
                bondlist = []
                bondlines = arg.sections[&#34;Bonds&#34;]
                for line in bondlines:
                    words = line.split()
                    bondlist.append(
                        [int(words[0]), int(words[1]), int(words[2]), int(words[3])]
                    )
                if bondlist:
                    self.bondflag = 1
                    self.bondlist = bondlist
            except:
                raise ValueError(&#34;could not extract bonds from data object&#34;)

        # cdata object, grab tris and lines statically

        elif type(arg) is types.InstanceType and &#34;.cdata&#34; in str(arg.__class__):
            self.triflag = self.lineflag = 0
            try:
                tmp, tmp, tmp, tmp, tris, lines = arg.viz(0)
                if tris:
                    self.triflag = 1
                    self.trilist = tris
                if lines:
                    self.lineflag = 1
                    self.linelist = lines
            except:
                raise ValueError(&#34;could not extract tris/lines from cdata object&#34;)

        # mdump object, grab tris dynamically

        elif type(arg) is types.InstanceType and &#34;.mdump&#34; in str(arg.__class__):
            self.triflag = 2
            self.objextra = arg

        # bdump object, grab bonds dynamically

        elif type(arg) is types.InstanceType and &#34;.bdump&#34; in str(arg.__class__):
            self.bondflag = 2
            self.objextra = arg

        # ldump object, grab lines dynamically

        elif type(arg) is types.InstanceType and &#34;.ldump&#34; in str(arg.__class__):
            self.lineflag = 2
            self.objextra = arg

        # tdump object, grab tris dynamically

        elif type(arg) is types.InstanceType and &#34;.tdump&#34; in str(arg.__class__):
            self.triflag = 2
            self.objextra = arg

        else:
            raise ValueError(&#34;unrecognized argument to dump.extra()&#34;)

    # --------------------------------------------------------------------

    def compare_atom(self, a, b):
        if a[0] &lt; b[0]:
            return -1
        elif a[0] &gt; b[0]:
            return 1
        else:
            return 0

    # --------------------------------------------------------------------

    def frame(self,iframe):
        &#34;&#34;&#34; simplified class to access properties of a snapshot
        (INRAE\Olivier Vitrac) &#34;&#34;&#34;
        nframes= len(self.time());
        if iframe&gt;=nframes:
            raise ValueError(&#34;the frame index should be ranged between 0 and %d&#34; % nframes)
        elif iframe&lt;0:
            iframe = iframe % nframes
        times = self.time()
        fields = self.names
        snap = self.snaps[iframe]
        frame = Frame()
        frame.dumpfile = self.flist[0]
        frame.time = times[iframe]
        frame.description = {&#34;dumpfile&#34;: &#34;dumpobject.flist[0]&#34;, &#34;time&#34;: &#34;dumpobject.times()[]&#34;}
        for k in sorted(fields,key=fields.get,reverse=False):
            kvalid = k # valid key name
            for rep in [&#34;[&#34;,&#34;]&#34;,&#34;#&#34;,&#34;~&#34;,&#34;-&#34;,&#34;_&#34;,&#34;(&#34;,&#34;)&#34;,&#34;,&#34;,&#34;.&#34;,&#34;;&#34;]:
                kvalid = kvalid.replace(rep,&#34;&#34;)
            frame.description[kvalid] = k
            frame.__dict__[kvalid] = snap.atoms[:,fields[k]]
        return frame

    # --------------------------------------------------------------------

    def kind(self,listtypes=None):
        &#34;&#34;&#34; guessed kind of dump file based on column names
        (possibility to supply a personnalized list)
        (INRAE\Olivier Vitrac) &#34;&#34;&#34;
        if listtypes==None:
            listtypes = {
                &#39;vxyz&#39;: [&#34;id&#34;,&#34;type&#34;,&#34;x&#34;,&#34;y&#34;,&#34;z&#34;,&#34;vx&#34;,&#34;vy&#34;,&#34;vz&#34;],
                &#39;xyz&#39;: [&#34;id&#34;,&#34;type&#34;,&#34;x&#34;,&#34;y&#34;,&#34;z&#34;]
                     }
            internaltypes = True
        else:
            listtypes = {&#34;usertype&#34;:listtypes}
            internaltypes = False
        for t in listtypes:
            if len(listtypes[t])==0:
                ismatching = False
            else:
                ismatching = True
                for field in listtypes[t]:
                    ismatching = ismatching and field in self.names
                if ismatching: break
        if ismatching:
            if internaltypes:
                return t
            else:
                return True
        else:
            if internaltypes:
                return None
            else:
                return False

    # --------------------------------------------------------------------

    @property
    def type(self):
        &#34;&#34;&#34; type of dump file defined as a hash of column names &#34;&#34;&#34;
        return hash(self.names2str())

    # --------------------------------------------------------------------

    def __add__(self,o):
        &#34;&#34;&#34; merge dump objects of the same kind/type &#34;&#34;&#34;
        if not isinstance(o,dump):
            raise ValueError(&#34;the second operand is not a dump object&#34;)
        elif self.type != o.type:
            raise ValueError(&#34;the dumps are not of the same type&#34;)
        twofiles = self.flist[0] + &#34; &#34; + o.flist[0]
        return dump(twofiles)

    # --------------------------------------------------------------------</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="data3.dump.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>type of dump file defined as a hash of column names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self):
    &#34;&#34;&#34; type of dump file defined as a hash of column names &#34;&#34;&#34;
    return hash(self.names2str())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="data3.dump.atom"><code class="name flex">
<span>def <span class="ident">atom</span></span>(<span>self, n, *list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atom(self, n, *list):
    if len(list) == 0:
        raise ValueError(&#34;no columns specified&#34;)
    columns = []
    values = []
    for name in list:
        columns.append(self.names[name])
        values.append(self.nselect * [0])
    ncol = len(columns)

    id = self.names[&#34;id&#34;]
    m = 0
    for snap in self.snaps:
        if not snap.tselect:
            continue
        atoms = snap.atoms
        for i in range(snap.natoms):
            if atoms[i][id] == n:
                break
        if atoms[i][id] != n:
            raise ValueError(&#34;could not find atom ID in snapshot&#34;)
        for j in range(ncol):
            values[j][m] = atoms[i][columns[j]]
        m += 1

    if len(list) == 1:
        return values[0]
    else:
        return values</code></pre>
</details>
</dd>
<dt id="data3.dump.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, nstep, col)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self, nstep, col):
    istep = self.findtime(nstep)
    icol = self.names[col]
    id = self.names[&#34;id&#34;]
    ids = {}
    for i in range(self.snaps[istep].natoms):
        ids[self.snaps[istep].atoms[i][id]] = i
    for snap in self.snaps:
        if not snap.tselect:
            continue
        atoms = snap.atoms
        for i in range(snap.natoms):
            if not snap.aselect[i]:
                continue
            j = ids[atoms[i][id]]
            atoms[i][icol] = self.snaps[istep].atoms[j][icol]</code></pre>
</details>
</dd>
<dt id="data3.dump.compare_atom"><code class="name flex">
<span>def <span class="ident">compare_atom</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_atom(self, a, b):
    if a[0] &lt; b[0]:
        return -1
    elif a[0] &gt; b[0]:
        return 1
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="data3.dump.compare_time"><code class="name flex">
<span>def <span class="ident">compare_time</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_time(self, a, b):
    if a.time &lt; b.time:
        return -1
    elif a.time &gt; b.time:
        return 1
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="data3.dump.cull"><code class="name flex">
<span>def <span class="ident">cull</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cull(self):
    i = 1
    while i &lt; len(self.snaps):
        if self.snaps[i].time == self.snaps[i - 1].time:
            del self.snaps[i]
        else:
            i += 1</code></pre>
</details>
</dd>
<dt id="data3.dump.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
    ndel = i = 0
    while i &lt; self.nsnaps:
        if not self.snaps[i].tselect:
            del self.snaps[i]
            self.nsnaps -= 1
            ndel += 1
        else:
            i += 1
    print(&#34;%d snapshots deleted&#34; % ndel)
    print(&#34;%d snapshots remaining&#34; % self.nsnaps)</code></pre>
</details>
</dd>
<dt id="data3.dump.extra"><code class="name flex">
<span>def <span class="ident">extra</span></span>(<span>self, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extra(self, arg):

    # data object, grab bonds statically

    if type(arg) is types.InstanceType and &#34;.data&#34; in str(arg.__class__):
        self.bondflag = 0
        try:
            bondlist = []
            bondlines = arg.sections[&#34;Bonds&#34;]
            for line in bondlines:
                words = line.split()
                bondlist.append(
                    [int(words[0]), int(words[1]), int(words[2]), int(words[3])]
                )
            if bondlist:
                self.bondflag = 1
                self.bondlist = bondlist
        except:
            raise ValueError(&#34;could not extract bonds from data object&#34;)

    # cdata object, grab tris and lines statically

    elif type(arg) is types.InstanceType and &#34;.cdata&#34; in str(arg.__class__):
        self.triflag = self.lineflag = 0
        try:
            tmp, tmp, tmp, tmp, tris, lines = arg.viz(0)
            if tris:
                self.triflag = 1
                self.trilist = tris
            if lines:
                self.lineflag = 1
                self.linelist = lines
        except:
            raise ValueError(&#34;could not extract tris/lines from cdata object&#34;)

    # mdump object, grab tris dynamically

    elif type(arg) is types.InstanceType and &#34;.mdump&#34; in str(arg.__class__):
        self.triflag = 2
        self.objextra = arg

    # bdump object, grab bonds dynamically

    elif type(arg) is types.InstanceType and &#34;.bdump&#34; in str(arg.__class__):
        self.bondflag = 2
        self.objextra = arg

    # ldump object, grab lines dynamically

    elif type(arg) is types.InstanceType and &#34;.ldump&#34; in str(arg.__class__):
        self.lineflag = 2
        self.objextra = arg

    # tdump object, grab tris dynamically

    elif type(arg) is types.InstanceType and &#34;.tdump&#34; in str(arg.__class__):
        self.triflag = 2
        self.objextra = arg

    else:
        raise ValueError(&#34;unrecognized argument to dump.extra()&#34;)</code></pre>
</details>
</dd>
<dt id="data3.dump.findtime"><code class="name flex">
<span>def <span class="ident">findtime</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findtime(self, n):
    for i in range(self.nsnaps):
        if self.snaps[i].time == n:
            return i
    raise ValueError(&#34;no step %d exists&#34; % n)</code></pre>
</details>
</dd>
<dt id="data3.dump.frame"><code class="name flex">
<span>def <span class="ident">frame</span></span>(<span>self, iframe)</span>
</code></dt>
<dd>
<div class="desc"><p>simplified class to access properties of a snapshot
(INRAE\Olivier Vitrac)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frame(self,iframe):
    &#34;&#34;&#34; simplified class to access properties of a snapshot
    (INRAE\Olivier Vitrac) &#34;&#34;&#34;
    nframes= len(self.time());
    if iframe&gt;=nframes:
        raise ValueError(&#34;the frame index should be ranged between 0 and %d&#34; % nframes)
    elif iframe&lt;0:
        iframe = iframe % nframes
    times = self.time()
    fields = self.names
    snap = self.snaps[iframe]
    frame = Frame()
    frame.dumpfile = self.flist[0]
    frame.time = times[iframe]
    frame.description = {&#34;dumpfile&#34;: &#34;dumpobject.flist[0]&#34;, &#34;time&#34;: &#34;dumpobject.times()[]&#34;}
    for k in sorted(fields,key=fields.get,reverse=False):
        kvalid = k # valid key name
        for rep in [&#34;[&#34;,&#34;]&#34;,&#34;#&#34;,&#34;~&#34;,&#34;-&#34;,&#34;_&#34;,&#34;(&#34;,&#34;)&#34;,&#34;,&#34;,&#34;.&#34;,&#34;;&#34;]:
            kvalid = kvalid.replace(rep,&#34;&#34;)
        frame.description[kvalid] = k
        frame.__dict__[kvalid] = snap.atoms[:,fields[k]]
    return frame</code></pre>
</details>
</dd>
<dt id="data3.dump.iterator"><code class="name flex">
<span>def <span class="ident">iterator</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterator(self, flag):
    start = 0
    if flag:
        start = self.iterate + 1
    for i in range(start, self.nsnaps):
        if self.snaps[i].tselect:
            self.iterate = i
            return i, self.snaps[i].time, 1
    return 0, 0, -1</code></pre>
</details>
</dd>
<dt id="data3.dump.kind"><code class="name flex">
<span>def <span class="ident">kind</span></span>(<span>self, listtypes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>guessed kind of dump file based on column names
(possibility to supply a personnalized list)
(INRAE\Olivier Vitrac)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kind(self,listtypes=None):
    &#34;&#34;&#34; guessed kind of dump file based on column names
    (possibility to supply a personnalized list)
    (INRAE\Olivier Vitrac) &#34;&#34;&#34;
    if listtypes==None:
        listtypes = {
            &#39;vxyz&#39;: [&#34;id&#34;,&#34;type&#34;,&#34;x&#34;,&#34;y&#34;,&#34;z&#34;,&#34;vx&#34;,&#34;vy&#34;,&#34;vz&#34;],
            &#39;xyz&#39;: [&#34;id&#34;,&#34;type&#34;,&#34;x&#34;,&#34;y&#34;,&#34;z&#34;]
                 }
        internaltypes = True
    else:
        listtypes = {&#34;usertype&#34;:listtypes}
        internaltypes = False
    for t in listtypes:
        if len(listtypes[t])==0:
            ismatching = False
        else:
            ismatching = True
            for field in listtypes[t]:
                ismatching = ismatching and field in self.names
            if ismatching: break
    if ismatching:
        if internaltypes:
            return t
        else:
            return True
    else:
        if internaltypes:
            return None
        else:
            return False</code></pre>
</details>
</dd>
<dt id="data3.dump.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, *pairs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, *pairs):
    if len(pairs) % 2 != 0:
        raise ValueError(&#34;dump map() requires pairs of mappings&#34;)
    for i in range(0, len(pairs), 2):
        j = i + 1
        self.names[pairs[j]] = pairs[i] - 1</code></pre>
</details>
</dd>
<dt id="data3.dump.maxbox"><code class="name flex">
<span>def <span class="ident">maxbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxbox(self):
    xlo = ylo = zlo = None
    xhi = yhi = zhi = None
    for snap in self.snaps:
        if not snap.tselect:
            continue
        if xlo == None or snap.xlo &lt; xlo:
            xlo = snap.xlo
        if xhi == None or snap.xhi &gt; xhi:
            xhi = snap.xhi
        if ylo == None or snap.ylo &lt; ylo:
            ylo = snap.ylo
        if yhi == None or snap.yhi &gt; yhi:
            yhi = snap.yhi
        if zlo == None or snap.zlo &lt; zlo:
            zlo = snap.zlo
        if zhi == None or snap.zhi &gt; zhi:
            zhi = snap.zhi
    return [xlo, ylo, zlo, xhi, yhi, zhi]</code></pre>
</details>
</dd>
<dt id="data3.dump.maxtype"><code class="name flex">
<span>def <span class="ident">maxtype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxtype(self):
    icol = self.names[&#34;type&#34;]
    max = 0
    for snap in self.snaps:
        if not snap.tselect:
            continue
        atoms = snap.atoms
        for i in range(snap.natoms):
            if not snap.aselect[i]:
                continue
            if atoms[i][icol] &gt; max:
                max = atoms[i][icol]
    return int(max)</code></pre>
</details>
</dd>
<dt id="data3.dump.minmax"><code class="name flex">
<span>def <span class="ident">minmax</span></span>(<span>self, colname)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minmax(self, colname):
    icol = self.names[colname]
    min = 1.0e20
    max = -min
    for snap in self.snaps:
        if not snap.tselect:
            continue
        atoms = snap.atoms
        for i in range(snap.natoms):
            if not snap.aselect[i]:
                continue
            if atoms[i][icol] &lt; min:
                min = atoms[i][icol]
            if atoms[i][icol] &gt; max:
                max = atoms[i][icol]
    return (min, max)</code></pre>
</details>
</dd>
<dt id="data3.dump.names2str"><code class="name flex">
<span>def <span class="ident">names2str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def names2str(self):
    # &lt;--  Python 2.x  --&gt;
    # pairs = self.names.items()
    # values = self.names.values()
    # ncol = len(pairs)
    # str = &#34;&#34;
    # for i in range(ncol):
    #   if i in values: str += pairs[values.index(i)][0] + &#39; &#39;
    # &lt;--  Python 3.x  --&gt;
    str = &#34;&#34;
    for k in sorted(self.names, key=self.names.get, reverse=False):
        str += k + &#34; &#34;
    return str</code></pre>
</details>
</dd>
<dt id="data3.dump.newcolumn"><code class="name flex">
<span>def <span class="ident">newcolumn</span></span>(<span>self, str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newcolumn(self, str):
    ncol = len(self.snaps[0].atoms[0])
    self.map(ncol + 1, str)
    for snap in self.snaps:
        # commented because not used
        # atoms = snap.atoms
        if oldnumeric:
            newatoms = np.zeros((snap.natoms, ncol + 1), np.Float)
        else:
            newatoms = np.zeros((snap.natoms, ncol + 1), np.float)
        newatoms[:, 0:ncol] = snap.atoms
        snap.atoms = newatoms</code></pre>
</details>
</dd>
<dt id="data3.dump.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self):

    if not self.increment:
        raise ValueError(&#34;cannot read incrementally&#34;)

    # read next snapshot in current file using eof as pointer
    # if fail, try next file
    # if new snapshot time stamp already exists, read next snapshot

    while 1:
        f = open(self.flist[self.nextfile], &#34;rb&#34;)
        f.seek(self.eof)
        snap = self.read_snapshot(f)
        if not snap:
            self.nextfile += 1
            if self.nextfile == len(self.flist):
                return -1
            f.close()
            self.eof = 0
            continue
        self.eof = f.tell()
        f.close()
        try:
            self.findtime(snap.time)
            continue
        except:
            break

    # select the new snapshot with all its atoms

    self.snaps.append(snap)
    snap = self.snaps[self.nsnaps]
    snap.tselect = 1
    snap.nselect = snap.natoms
    for i in range(snap.natoms):
        snap.aselect[i] = True
    self.nsnaps += 1
    self.nselect += 1

    return snap.time</code></pre>
</details>
</dd>
<dt id="data3.dump.owrap"><code class="name flex">
<span>def <span class="ident">owrap</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def owrap(self, other):
    print(&#34;Wrapping to other ...&#34;)

    id = self.names[&#34;id&#34;]
    x = self.names[&#34;x&#34;]
    y = self.names[&#34;y&#34;]
    z = self.names[&#34;z&#34;]
    ix = self.names[&#34;ix&#34;]
    iy = self.names[&#34;iy&#34;]
    iz = self.names[&#34;iz&#34;]
    iother = self.names[other]

    for snap in self.snaps:
        xprd = snap.xhi - snap.xlo
        yprd = snap.yhi - snap.ylo
        zprd = snap.zhi - snap.zlo
        atoms = snap.atoms
        ids = {}
        for i in range(snap.natoms):
            ids[atoms[i][id]] = i
        for i in range(snap.natoms):
            j = ids[atoms[i][iother]]
            atoms[i][x] += (atoms[i][ix] - atoms[j][ix]) * xprd
            atoms[i][y] += (atoms[i][iy] - atoms[j][iy]) * yprd
            atoms[i][z] += (atoms[i][iz] - atoms[j][iz]) * zprd
        # should bonds also be owrapped ?
        if self.lineflag == 2 or self.triflag == 2:
            self.objextra.owrap(
                snap.time, xprd, yprd, zprd, ids, atoms, iother, ix, iy, iz
            )</code></pre>
</details>
</dd>
<dt id="data3.dump.read_all"><code class="name flex">
<span>def <span class="ident">read_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_all(self):

    # read all snapshots from each file
    # test for gzipped files

    for file in self.flist:
        if file[-3:] == &#34;.gz&#34;:
            f = popen(&#34;%s -c %s&#34; % (PIZZA_GUNZIP, file), &#34;r&#34;)
        else:
            f = open(file)

        snap = self.read_snapshot(f)
        while snap:
            self.snaps.append(snap)
            print(snap.time, file=sys.stdout, flush=True, end=&#34; &#34;)
            snap = self.read_snapshot(f)

        f.close()
    print

    # sort entries by timestep, cull duplicates

    self.snaps.sort()  # self.snaps.sort(self.compare_time)  #%% to be fixed in the future (OV)
    self.cull()
    self.nsnaps = len(self.snaps)
    print(&#34;read %d snapshots&#34; % (self.nsnaps))

    # select all timesteps and atoms

    self.tselect.all()

    # print column assignments

    if len(self.names):
        print(&#34;assigned columns:&#34;, &#34;,&#34;.join(list(self.names.keys())))
    else:
        print(&#34;no column assignments made&#34;)

    # if snapshots are scaled, unscale them

    if (
        (not &#34;x&#34; in self.names)
        or (not &#34;y&#34; in self.names)
        or (not &#34;z&#34; in self.names)
    ):
        print(&#34;dump scaling status is unknown&#34;)
    elif self.nsnaps &gt; 0:
        if self.scale_original == 1:
            self.unscale()
        elif self.scale_original == 0:
            print(&#34;dump is already unscaled&#34;)
        else:
            print(&#34;dump scaling status is unknown&#34;)</code></pre>
</details>
</dd>
<dt id="data3.dump.read_snapshot"><code class="name flex">
<span>def <span class="ident">read_snapshot</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>low-level method to read a snapshot from a file identifier</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_snapshot(self, f):
    &#34;&#34;&#34; low-level method to read a snapshot from a file identifier &#34;&#34;&#34;

    # expand the list of keywords if needed (INRAE\Olivier Vitrac)
    # &#34;keyname&#34;: [&#34;name in snap&#34;,&#34;type&#34;]
    itemkeywords = {&#34;TIME&#34;: [&#34;realtime&#34;,&#34;float&#34;],
                    &#34;TIMESTEP&#34;: [&#34;time&#34;,&#34;int&#34;],
                    &#34;NUMBER OF ATOMS&#34;: [&#34;natoms&#34;,&#34;int&#34;]}
    try:
        snap = Snap()

        # read and guess the first keywords based on itemkeywords
        found = True
        while found:
            item = f.readline()
            varitem = item.split(&#34;ITEM:&#34;)[1].strip()
            found = varitem in itemkeywords
            if found:
                tmp = f.readline().split()[0]  # just grab 1st field
                if itemkeywords[varitem][1]==&#34;int&#34;:
                    valitem = int(tmp)
                else:
                    valitem = float(tmp)
                setattr(snap,itemkeywords[varitem][0],valitem)

        # prefetch
        snap.aselect = np.zeros(snap.natoms,dtype=bool)

        # we assume that the next item is BOX BOUNDS (pp ff pp)
        words = item.split(&#34;BOUNDS &#34;)
        if len(words) == 1:
            snap.boxstr = &#34;&#34;
        else:
            snap.boxstr = words[1].strip()
        if &#34;xy&#34; in snap.boxstr:
            snap.triclinic = 1
        else:
            snap.triclinic = 0

        words = f.readline().split()
        if len(words) == 2:
            snap.xlo, snap.xhi, snap.xy = float(words[0]), float(words[1]), 0.0
        else:
            snap.xlo, snap.xhi, snap.xy = (
                float(words[0]),
                float(words[1]),
                float(words[2]),
            )

        words = f.readline().split()
        if len(words) == 2:
            snap.ylo, snap.yhi, snap.xz = float(words[0]), float(words[1]), 0.0
        else:
            snap.ylo, snap.yhi, snap.xz = (
                float(words[0]),
                float(words[1]),
                float(words[2]),
            )

        words = f.readline().split()
        if len(words) == 2:
            snap.zlo, snap.zhi, snap.yz = float(words[0]), float(words[1]), 0.0
        else:
            snap.zlo, snap.zhi, snap.yz = (
                float(words[0]),
                float(words[1]),
                float(words[2]),
            )

        item = f.readline()
        if len(self.names) == 0:
            self.scale_original = -1
            xflag = yflag = zflag = -1
            words = item.split()[2:]
            if len(words):
                for i in range(len(words)):
                    if words[i] == &#34;x&#34; or words[i] == &#34;xu&#34;:
                        xflag = 0
                        self.names[&#34;x&#34;] = i
                    elif words[i] == &#34;xs&#34; or words[i] == &#34;xsu&#34;:
                        xflag = 1
                        self.names[&#34;x&#34;] = i
                    elif words[i] == &#34;y&#34; or words[i] == &#34;yu&#34;:
                        yflag = 0
                        self.names[&#34;y&#34;] = i
                    elif words[i] == &#34;ys&#34; or words[i] == &#34;ysu&#34;:
                        yflag = 1
                        self.names[&#34;y&#34;] = i
                    elif words[i] == &#34;z&#34; or words[i] == &#34;zu&#34;:
                        zflag = 0
                        self.names[&#34;z&#34;] = i
                    elif words[i] == &#34;zs&#34; or words[i] == &#34;zsu&#34;:
                        zflag = 1
                        self.names[&#34;z&#34;] = i
                    else:
                        self.names[words[i]] = i
                if xflag == 0 and yflag == 0 and zflag == 0:
                    self.scale_original = 0
                if xflag == 1 and yflag == 1 and zflag == 1:
                    self.scale_original = 1

        if snap.natoms:
            words = f.readline().split()
            ncol = len(words)
            for i in range(1, snap.natoms):
                words += f.readline().split()
            floats = list(map(float, words))
            if oldnumeric:
                atoms = np.zeros((snap.natoms, ncol), np.float64)
            else:
                atoms = np.zeros((snap.natoms, ncol), np.float64)
            start = 0
            stop = ncol
            for i in range(snap.natoms):
                atoms[i] = floats[start:stop]
                start = stop
                stop += ncol
        else:
            atoms = None
        snap.atoms = atoms
        return snap
    except:
        return 0</code></pre>
</details>
</dd>
<dt id="data3.dump.realtime"><code class="name flex">
<span>def <span class="ident">realtime</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>time as simulated: realtime()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def realtime(self):
    &#34;&#34;&#34; time as simulated: realtime() &#34;&#34;&#34;
    vec = self.nselect * [0.0]
    i = 0
    for snap in self.snaps:
        if not snap.tselect or not hasattr(snap,&#34;realtime&#34;):
            continue
        vec[i] = snap.realtime
        i += 1
    return vec</code></pre>
</details>
</dd>
<dt id="data3.dump.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, *list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, *list):
    if len(list) == 0:
        print(&#34;Scaling dump ...&#34;)
        x = self.names[&#34;x&#34;]
        y = self.names[&#34;y&#34;]
        z = self.names[&#34;z&#34;]
        for snap in self.snaps:
            self.scale_one(snap, x, y, z)
    else:
        i = self.findtime(list[0])
        x = self.names[&#34;x&#34;]
        y = self.names[&#34;y&#34;]
        z = self.names[&#34;z&#34;]
        self.scale_one(self.snaps[i], x, y, z)</code></pre>
</details>
</dd>
<dt id="data3.dump.scale_one"><code class="name flex">
<span>def <span class="ident">scale_one</span></span>(<span>self, snap, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_one(self, snap, x, y, z):
    if snap.xy == 0.0 and snap.xz == 0.0 and snap.yz == 0.0:
        xprdinv = 1.0 / (snap.xhi - snap.xlo)
        yprdinv = 1.0 / (snap.yhi - snap.ylo)
        zprdinv = 1.0 / (snap.zhi - snap.zlo)
        atoms = snap.atoms
        if atoms != None:
            atoms[:, x] = (atoms[:, x] - snap.xlo) * xprdinv
            atoms[:, y] = (atoms[:, y] - snap.ylo) * yprdinv
            atoms[:, z] = (atoms[:, z] - snap.zlo) * zprdinv
    else:
        xlo_bound = snap.xlo
        xhi_bound = snap.xhi
        ylo_bound = snap.ylo
        yhi_bound = snap.yhi
        zlo_bound = snap.zlo
        zhi_bound = snap.zhi
        xy = snap.xy
        xz = snap.xz
        yz = snap.yz
        xlo = xlo_bound - min((0.0, xy, xz, xy + xz))
        xhi = xhi_bound - max((0.0, xy, xz, xy + xz))
        ylo = ylo_bound - min((0.0, yz))
        yhi = yhi_bound - max((0.0, yz))
        zlo = zlo_bound
        zhi = zhi_bound
        h0 = xhi - xlo
        h1 = yhi - ylo
        h2 = zhi - zlo
        h3 = yz
        h4 = xz
        h5 = xy
        h0inv = 1.0 / h0
        h1inv = 1.0 / h1
        h2inv = 1.0 / h2
        h3inv = yz / (h1 * h2)
        h4inv = (h3 * h5 - h1 * h4) / (h0 * h1 * h2)
        h5inv = xy / (h0 * h1)
        atoms = snap.atoms
        if atoms != None:
            atoms[:, x] = (
                (atoms[:, x] - snap.xlo) * h0inv
                + (atoms[:, y] - snap.ylo) * h5inv
                + (atoms[:, z] - snap.zlo) * h4inv
            )
            atoms[:, y] = (atoms[:, y] - snap.ylo) * h1inv + (
                atoms[:, z] - snap.zlo
            ) * h3inv
            atoms[:, z] = (atoms[:, z] - snap.zlo) * h2inv</code></pre>
</details>
</dd>
<dt id="data3.dump.scatter"><code class="name flex">
<span>def <span class="ident">scatter</span></span>(<span>self, root)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatter(self, root):
    if len(self.snaps):
        namestr = self.names2str()
    for snap in self.snaps:
        if not snap.tselect:
            continue
        print(snap.time, file=sys.stdout, flush=True)

        file = root + &#34;.&#34; + str(snap.time)
        f = open(file, &#34;w&#34;)
        print(&#34;ITEM: TIMESTEP&#34;, file=f)
        print(snap.time, file=f)
        print(&#34;ITEM: NUMBER OF ATOMS&#34;, file=f)
        print(snap.nselect, file=f)
        if snap.boxstr:
            print(&#34;ITEM: BOX BOUNDS&#34;, snap.boxstr, file=f)
        else:
            print(&#34;ITEM: BOX BOUNDS&#34;, file=f)
        if snap.triclinic:
            print(snap.xlo, snap.xhi, snap.xy, file=f)
            print(snap.ylo, snap.yhi, snap.xz, file=f)
            print(snap.zlo, snap.zhi, snap.yz, file=f)
        else:
            print(snap.xlo, snap.xhi, file=f)
            print(snap.ylo, snap.yhi, file=f)
            print(snap.zlo, snap.zhi, file=f)
        print(&#34;ITEM: ATOMS&#34;, namestr, file=f)

        atoms = snap.atoms
        nvalues = len(atoms[0])
        for i in range(snap.natoms):
            if not snap.aselect[i]:
                continue
            line = &#34;&#34;
            for j in range(nvalues):
                if j &lt; 2:
                    line += str(int(atoms[i][j])) + &#34; &#34;
                else:
                    line += str(atoms[i][j]) + &#34; &#34;
            print(line, file=f)
        f.close()
    print(&#34;\n%d snapshots&#34; % self.nselect)</code></pre>
</details>
</dd>
<dt id="data3.dump.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, eq)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, eq):
    print(&#34;Setting ...&#34;)
    pattern = &#34;\$\w*&#34;
    list = re.findall(pattern, eq)

    lhs = list[0][1:]
    if not self.names.has_key(lhs):
        self.newcolumn(lhs)

    for item in list:
        name = item[1:]
        column = self.names[name]
        insert = &#34;snap.atoms[i][%d]&#34; % (column)
        eq = eq.replace(item, insert)
    ceq = compile(eq, &#34;&#34;, &#34;single&#34;)

    for snap in self.snaps:
        if not snap.tselect:
            continue
        for i in range(snap.natoms):
            if snap.aselect[i]:
                exec(ceq)</code></pre>
</details>
</dd>
<dt id="data3.dump.setv"><code class="name flex">
<span>def <span class="ident">setv</span></span>(<span>self, colname, vec)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setv(self, colname, vec):
    print(&#34;Setting ...&#34;)
    if not self.names.has_key(colname):
        self.newcolumn(colname)
    icol = self.names[colname]

    for snap in self.snaps:
        if not snap.tselect:
            continue
        if snap.nselect != len(vec):
            raise ValueError(&#34;vec length does not match # of selected atoms&#34;)
        atoms = snap.atoms
        m = 0
        for i in range(snap.natoms):
            if snap.aselect[i]:
                atoms[i][icol] = vec[m]
                m += 1</code></pre>
</details>
</dd>
<dt id="data3.dump.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, *listarg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, *listarg):
    if len(listarg) == 0:
        print(&#34;Sorting selected snapshots ...&#34;)
        id = self.names[&#34;id&#34;]
        for snap in self.snaps:
            if snap.tselect:
                self.sort_one(snap, id)
    elif type(listarg[0]) is types.StringType:
        print(&#34;Sorting selected snapshots by %s ...&#34; % listarg[0])
        id = self.names[listarg[0]]
        for snap in self.snaps:
            if snap.tselect:
                self.sort_one(snap, id)
    else:
        i = self.findtime(listarg[0])
        id = self.names[&#34;id&#34;]
        self.sort_one(self.snaps[i], id)</code></pre>
</details>
</dd>
<dt id="data3.dump.sort_one"><code class="name flex">
<span>def <span class="ident">sort_one</span></span>(<span>self, snap, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_one(self, snap, id):
    atoms = snap.atoms
    ids = atoms[:, id]
    ordering = np.argsort(ids)
    for i in range(len(atoms[0])):
        atoms[:, i] = np.take(atoms[:, i], ordering)</code></pre>
</details>
</dd>
<dt id="data3.dump.spread"><code class="name flex">
<span>def <span class="ident">spread</span></span>(<span>self, old, n, new)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spread(self, old, n, new):
    iold = self.names[old]
    if not self.names.has_key(new):
        self.newcolumn(new)
    inew = self.names[new]

    min, max = self.minmax(old)
    print(&#34;min/max = &#34;, min, max)

    gap = max - min
    invdelta = n / gap
    for snap in self.snaps:
        if not snap.tselect:
            continue
        atoms = snap.atoms
        for i in range(snap.natoms):
            if not snap.aselect[i]:
                continue
            ivalue = int((atoms[i][iold] - min) * invdelta) + 1
            if ivalue &gt; n:
                ivalue = n
            if ivalue &lt; 1:
                ivalue = 1
            atoms[i][inew] = ivalue</code></pre>
</details>
</dd>
<dt id="data3.dump.time"><code class="name flex">
<span>def <span class="ident">time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>timestep as stored: time()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time(self):
    &#34;&#34;&#34; timestep as stored: time()&#34;&#34;&#34;
    vec = self.nselect * [0]
    i = 0
    for snap in self.snaps:
        if not snap.tselect:
            continue
        vec[i] = snap.time
        i += 1
    return vec</code></pre>
</details>
</dd>
<dt id="data3.dump.unscale"><code class="name flex">
<span>def <span class="ident">unscale</span></span>(<span>self, *list)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unscale(self, *list):
    if len(list) == 0:
        print(&#34;Unscaling dump ...&#34;)
        x = self.names[&#34;x&#34;]
        y = self.names[&#34;y&#34;]
        z = self.names[&#34;z&#34;]
        for snap in self.snaps:
            self.unscale_one(snap, x, y, z)
    else:
        i = self.findtime(list[0])
        x = self.names[&#34;x&#34;]
        y = self.names[&#34;y&#34;]
        z = self.names[&#34;z&#34;]
        self.unscale_one(self.snaps[i], x, y, z)</code></pre>
</details>
</dd>
<dt id="data3.dump.unscale_one"><code class="name flex">
<span>def <span class="ident">unscale_one</span></span>(<span>self, snap, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unscale_one(self, snap, x, y, z):
    if snap.xy == 0.0 and snap.xz == 0.0 and snap.yz == 0.0:
        xprd = snap.xhi - snap.xlo
        yprd = snap.yhi - snap.ylo
        zprd = snap.zhi - snap.zlo
        atoms = snap.atoms
        if atoms != None:
            atoms[:, x] = snap.xlo + atoms[:, x] * xprd
            atoms[:, y] = snap.ylo + atoms[:, y] * yprd
            atoms[:, z] = snap.zlo + atoms[:, z] * zprd
    else:
        xlo_bound = snap.xlo
        xhi_bound = snap.xhi
        ylo_bound = snap.ylo
        yhi_bound = snap.yhi
        zlo_bound = snap.zlo
        zhi_bound = snap.zhi
        xy = snap.xy
        xz = snap.xz
        yz = snap.yz
        xlo = xlo_bound - min((0.0, xy, xz, xy + xz))
        xhi = xhi_bound - max((0.0, xy, xz, xy + xz))
        ylo = ylo_bound - min((0.0, yz))
        yhi = yhi_bound - max((0.0, yz))
        zlo = zlo_bound
        zhi = zhi_bound
        h0 = xhi - xlo
        h1 = yhi - ylo
        h2 = zhi - zlo
        h3 = yz
        h4 = xz
        h5 = xy
        atoms = snap.atoms
        if atoms != None:
            atoms[:, x] = (
                snap.xlo + atoms[:, x] * h0 + atoms[:, y] * h5 + atoms[:, z] * h4
            )
            atoms[:, y] = snap.ylo + atoms[:, y] * h1 + atoms[:, z] * h3
            atoms[:, z] = snap.zlo + atoms[:, z] * h2</code></pre>
</details>
</dd>
<dt id="data3.dump.unwrap"><code class="name flex">
<span>def <span class="ident">unwrap</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap(self):
    print(&#34;Unwrapping dump ...&#34;)

    x = self.names[&#34;x&#34;]
    y = self.names[&#34;y&#34;]
    z = self.names[&#34;z&#34;]
    ix = self.names[&#34;ix&#34;]
    iy = self.names[&#34;iy&#34;]
    iz = self.names[&#34;iz&#34;]

    for snap in self.snaps:
        xprd = snap.xhi - snap.xlo
        yprd = snap.yhi - snap.ylo
        zprd = snap.zhi - snap.zlo
        atoms = snap.atoms
        atoms[:, x] += atoms[:, ix] * xprd
        atoms[:, y] += atoms[:, iy] * yprd
        atoms[:, z] += atoms[:, iz] * zprd</code></pre>
</details>
</dd>
<dt id="data3.dump.vecs"><code class="name flex">
<span>def <span class="ident">vecs</span></span>(<span>self, n, *colname)</span>
</code></dt>
<dd>
<div class="desc"><p>vecs(timeste,columname1,columname2,&hellip;)</p>
<h2 id="examples">Examples</h2>
<p>tab = vecs(timestep,"id","x","y")
tab = vecs(timestep,["id","x","y"],"z")
X.vecs(X.time()[50],"vx","vy")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vecs(self, n, *colname):
    &#34;&#34;&#34;
        vecs(timeste,columname1,columname2,...)
        Examples:
            tab = vecs(timestep,&#34;id&#34;,&#34;x&#34;,&#34;y&#34;)
            tab = vecs(timestep,[&#34;id&#34;,&#34;x&#34;,&#34;y&#34;],&#34;z&#34;)
            X.vecs(X.time()[50],&#34;vx&#34;,&#34;vy&#34;)
    &#34;&#34;&#34;
    snap = self.snaps[self.findtime(n)]

    if len(colname) == 0:
        raise ValueError(&#34;no columns specified&#34;)
    if isinstance(colname[0],tuple):
        colname = list(colname[0]) + list(colname[1:])
    if isinstance(colname[0],list):
        colname = colname[0] + list(colname[1:])
    columns = []
    values = []
    for name in colname:
        columns.append(self.names[name])
        values.append(snap.nselect * [0])
    ncol = len(columns)

    m = 0
    for i in range(snap.natoms):
        if not snap.aselect[i]:
            continue
        for j in range(ncol):
            values[j][m] = snap.atoms[i][columns[j]]
        m += 1

    if len(colname) == 1:
        return values[0]
    else:
        return values</code></pre>
</details>
</dd>
<dt id="data3.dump.viz"><code class="name flex">
<span>def <span class="ident">viz</span></span>(<span>self, index, flag=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def viz(self, index, flag=0):
    if not flag:
        isnap = index
    else:
        times = self.time()
        n = len(times)
        i = 0
        while i &lt; n:
            if times[i] &gt; index:
                break
            i += 1
        isnap = i - 1

    snap = self.snaps[isnap]

    time = snap.time
    box = [snap.xlo, snap.ylo, snap.zlo, snap.xhi, snap.yhi, snap.zhi]
    id = self.names[&#34;id&#34;]
    type = self.names[self.atype]
    x = self.names[&#34;x&#34;]
    y = self.names[&#34;y&#34;]
    z = self.names[&#34;z&#34;]

    # create atom list needed by viz from id,type,x,y,z
    # need Numeric/Numpy mode here

    atoms = []
    for i in range(snap.natoms):
        if not snap.aselect[i]:
            continue
        atom = snap.atoms[i]
        atoms.append([atom[id], atom[type], atom[x], atom[y], atom[z]])

    # create list of bonds from static or dynamic bond list
    # then generate bond coords from bondlist
    # alist = dictionary of atom IDs for atoms list
    # lookup bond atom IDs in alist and grab their coords
    # try is used since some atoms may be unselected
    #   any bond with unselected atom is not added to bonds
    # need Numeric/Numpy mode here

    bonds = []
    if self.bondflag:
        if self.bondflag == 1:
            bondlist = self.bondlist
        elif self.bondflag == 2:
            tmp1, tmp2, tmp3, bondlist, tmp4, tmp5 = self.objextra.viz(time, 1)
        alist = {}
        for i in range(len(atoms)):
            alist[int(atoms[i][0])] = i
        for bond in bondlist:
            try:
                i = alist[bond[2]]
                j = alist[bond[3]]
                atom1 = atoms[i]
                atom2 = atoms[j]
                bonds.append(
                    [
                        bond[0],
                        bond[1],
                        atom1[2],
                        atom1[3],
                        atom1[4],
                        atom2[2],
                        atom2[3],
                        atom2[4],
                        atom1[1],
                        atom2[1],
                    ]
                )
            except:
                continue

    # create list of tris from static or dynamic tri list
    # if dynamic, could eliminate tris for unselected atoms

    tris = []
    if self.triflag:
        if self.triflag == 1:
            tris = self.trilist
        elif self.triflag == 2:
            tmp1, tmp2, tmp3, tmp4, tris, tmp5 = self.objextra.viz(time, 1)

    # create list of lines from static or dynamic tri list
    # if dynamic, could eliminate lines for unselected atoms

    lines = []
    if self.lineflag:
        if self.lineflag == 1:
            lines = self.linelist
        elif self.lineflag == 2:
            tmp1, tmp2, tmp3, tmp4, tmp5, lines = self.objextra.viz(time, 1)

    return time, box, atoms, bonds, tris, lines</code></pre>
</details>
</dd>
<dt id="data3.dump.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap(self):
    print(&#34;Wrapping dump ...&#34;)

    x = self.names[&#34;x&#34;]
    y = self.names[&#34;y&#34;]
    z = self.names[&#34;z&#34;]
    ix = self.names[&#34;ix&#34;]
    iy = self.names[&#34;iy&#34;]
    iz = self.names[&#34;iz&#34;]

    for snap in self.snaps:
        xprd = snap.xhi - snap.xlo
        yprd = snap.yhi - snap.ylo
        zprd = snap.zhi - snap.zlo
        atoms = snap.atoms
        atoms[:, x] -= atoms[:, ix] * xprd
        atoms[:, y] -= atoms[:, iy] * yprd
        atoms[:, z] -= atoms[:, iz] * zprd</code></pre>
</details>
</dd>
<dt id="data3.dump.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, header=1, append=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, header=1, append=0):
    if len(self.snaps):
        namestr = self.names2str()
    if not append:
        f = open(file, &#34;w&#34;)
    else:
        f = open(file, &#34;a&#34;)

    if &#34;id&#34; in self.names:
        id = self.names[&#34;id&#34;]
    else:
        id = -1
    if &#34;type&#34; in self.names:
        type = self.names[&#34;type&#34;]
    else:
        type = -1

    for snap in self.snaps:
        if not snap.tselect:
            continue
        print(snap.time, file=sys.stdout, flush=True)

        if header:
            print(&#34;ITEM: TIMESTEP&#34;, file=f)
            print(snap.time, file=f)
            print(&#34;ITEM: NUMBER OF ATOMS&#34;, file=f)
            print(snap.nselect, file=f)
            if snap.boxstr:
                print(&#34;ITEM: BOX BOUNDS&#34;, snap.boxstr, file=f)
            else:
                print(&#34;ITEM: BOX BOUNDS&#34;, file=f)
            if snap.triclinic:
                print(snap.xlo, snap.xhi, snap.xy, file=f)
                print(snap.ylo, snap.yhi, snap.xz, file=f)
                print(snap.zlo, snap.zhi, snap.yz, file=f)
            else:
                print(snap.xlo, snap.xhi, file=f)
                print(snap.ylo, snap.yhi, file=f)
                print(snap.zlo, snap.zhi, file=f)
            print(&#34;ITEM: ATOMS&#34;, namestr, file=f)

        atoms = snap.atoms
        nvalues = len(atoms[0])
        for i in range(snap.natoms):
            if not snap.aselect[i]:
                continue
            line = &#34;&#34;
            for j in range(nvalues):
                if j == id or j == type:
                    line += str(int(atoms[i][j])) + &#34; &#34;
                else:
                    line += str(atoms[i][j]) + &#34; &#34;
            print(line, file=f)
    f.close()
    print(&#34;\n%d snapshots&#34; % self.nselect)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#data-class">data Class</a><ul>
<li><a href="#features">Features</a></li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#initialization">Initialization</a></li>
<li><a href="#accessing-data">Accessing Data</a></li>
<li><a href="#manipulation">Manipulation</a></li>
<li><a href="#output">Output</a></li>
<li><a href="#visualization">Visualization</a></li>
<li><a href="#integration-with-dump">Integration with dump</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#basic-usage">Basic Usage</a></li>
<li><a href="#restart-generation">Restart Generation</a></li>
<li><a href="#visualization_1">Visualization</a></li>
</ul>
</li>
<li><a href="#properties">Properties</a></li>
<li><a href="#notes">Notes</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="data3.data" href="#data3.data">data</a></code></h4>
<ul class="two-column">
<li><code><a title="data3.data.append" href="#data3.data.append">append</a></code></li>
<li><code><a title="data3.data.delete" href="#data3.data.delete">delete</a></code></li>
<li><code><a title="data3.data.dispsection" href="#data3.data.dispsection">dispsection</a></code></li>
<li><code><a title="data3.data.findtime" href="#data3.data.findtime">findtime</a></code></li>
<li><code><a title="data3.data.get" href="#data3.data.get">get</a></code></li>
<li><code><a title="data3.data.iterator" href="#data3.data.iterator">iterator</a></code></li>
<li><code><a title="data3.data.map" href="#data3.data.map">map</a></code></li>
<li><code><a title="data3.data.maxbox" href="#data3.data.maxbox">maxbox</a></code></li>
<li><code><a title="data3.data.maxtype" href="#data3.data.maxtype">maxtype</a></code></li>
<li><code><a title="data3.data.newxyz" href="#data3.data.newxyz">newxyz</a></code></li>
<li><code><a title="data3.data.reorder" href="#data3.data.reorder">reorder</a></code></li>
<li><code><a title="data3.data.replace" href="#data3.data.replace">replace</a></code></li>
<li><code><a title="data3.data.viz" href="#data3.data.viz">viz</a></code></li>
<li><code><a title="data3.data.write" href="#data3.data.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="data3.dump" href="#data3.dump">dump</a></code></h4>
<ul class="two-column">
<li><code><a title="data3.dump.atom" href="#data3.dump.atom">atom</a></code></li>
<li><code><a title="data3.dump.clone" href="#data3.dump.clone">clone</a></code></li>
<li><code><a title="data3.dump.compare_atom" href="#data3.dump.compare_atom">compare_atom</a></code></li>
<li><code><a title="data3.dump.compare_time" href="#data3.dump.compare_time">compare_time</a></code></li>
<li><code><a title="data3.dump.cull" href="#data3.dump.cull">cull</a></code></li>
<li><code><a title="data3.dump.delete" href="#data3.dump.delete">delete</a></code></li>
<li><code><a title="data3.dump.extra" href="#data3.dump.extra">extra</a></code></li>
<li><code><a title="data3.dump.findtime" href="#data3.dump.findtime">findtime</a></code></li>
<li><code><a title="data3.dump.frame" href="#data3.dump.frame">frame</a></code></li>
<li><code><a title="data3.dump.iterator" href="#data3.dump.iterator">iterator</a></code></li>
<li><code><a title="data3.dump.kind" href="#data3.dump.kind">kind</a></code></li>
<li><code><a title="data3.dump.map" href="#data3.dump.map">map</a></code></li>
<li><code><a title="data3.dump.maxbox" href="#data3.dump.maxbox">maxbox</a></code></li>
<li><code><a title="data3.dump.maxtype" href="#data3.dump.maxtype">maxtype</a></code></li>
<li><code><a title="data3.dump.minmax" href="#data3.dump.minmax">minmax</a></code></li>
<li><code><a title="data3.dump.names2str" href="#data3.dump.names2str">names2str</a></code></li>
<li><code><a title="data3.dump.newcolumn" href="#data3.dump.newcolumn">newcolumn</a></code></li>
<li><code><a title="data3.dump.next" href="#data3.dump.next">next</a></code></li>
<li><code><a title="data3.dump.owrap" href="#data3.dump.owrap">owrap</a></code></li>
<li><code><a title="data3.dump.read_all" href="#data3.dump.read_all">read_all</a></code></li>
<li><code><a title="data3.dump.read_snapshot" href="#data3.dump.read_snapshot">read_snapshot</a></code></li>
<li><code><a title="data3.dump.realtime" href="#data3.dump.realtime">realtime</a></code></li>
<li><code><a title="data3.dump.scale" href="#data3.dump.scale">scale</a></code></li>
<li><code><a title="data3.dump.scale_one" href="#data3.dump.scale_one">scale_one</a></code></li>
<li><code><a title="data3.dump.scatter" href="#data3.dump.scatter">scatter</a></code></li>
<li><code><a title="data3.dump.set" href="#data3.dump.set">set</a></code></li>
<li><code><a title="data3.dump.setv" href="#data3.dump.setv">setv</a></code></li>
<li><code><a title="data3.dump.sort" href="#data3.dump.sort">sort</a></code></li>
<li><code><a title="data3.dump.sort_one" href="#data3.dump.sort_one">sort_one</a></code></li>
<li><code><a title="data3.dump.spread" href="#data3.dump.spread">spread</a></code></li>
<li><code><a title="data3.dump.time" href="#data3.dump.time">time</a></code></li>
<li><code><a title="data3.dump.type" href="#data3.dump.type">type</a></code></li>
<li><code><a title="data3.dump.unscale" href="#data3.dump.unscale">unscale</a></code></li>
<li><code><a title="data3.dump.unscale_one" href="#data3.dump.unscale_one">unscale_one</a></code></li>
<li><code><a title="data3.dump.unwrap" href="#data3.dump.unwrap">unwrap</a></code></li>
<li><code><a title="data3.dump.vecs" href="#data3.dump.vecs">vecs</a></code></li>
<li><code><a title="data3.dump.viz" href="#data3.dump.viz">viz</a></code></li>
<li><code><a title="data3.dump.wrap" href="#data3.dump.wrap">wrap</a></code></li>
<li><code><a title="data3.dump.write" href="#data3.dump.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>