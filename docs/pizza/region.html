<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>region API documentation</title>
<meta name="description" content="REGION Module Documentation
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>region</code></h1>
</header>
<section id="section-intro">
<p>================================================================================
REGION Module Documentation
================================================================================</p>
<p>Project: Pizza3
Authors: Olivier Vitrac, Han Chen
Copyright: 2024
Credits: Olivier Vitrac, Han Chen
License: GPLv3
Maintainer: Olivier Vitrac
Email: olivier.vitrac@agroparistech.fr
Version: 1.0</p>
<h2 id="overview">Overview</h2>
<p>The REGION module provides a suite of tools to define and manipulate native geometries in Python
for LAMMPS (Large-scale Atomic/Molecular Massively Parallel Simulator). It is designed to facilitate
the creation, concatenation, and manipulation of geometric regions used in molecular dynamics simulations.</p>
<h2 id="public-features">Public Features</h2>
<ul>
<li>Concatenation of Regions:</li>
<li><code>R1 + R2</code> concatenates two regions (objects of R2 are inherited in R1, higher precedence for R2).</li>
<li>Generation of Objects:</li>
<li><code>R.do()</code> generates the objects (similar functionality to <code>do()</code> in pizza.script).</li>
<li>Script Generation:</li>
<li><code>R.script</code> returns the script (similar functionality to <code><a title="region.script" href="#region.script">script</a></code> in pizza.script).</li>
<li>Object Deletion:</li>
<li><code>R.o1 = []</code> deletes object <code>o1</code>.</li>
<li>Union of Objects:</li>
<li><code>R.union(o1, o2, name=...)</code> creates a union of <code>o1</code> and <code>o2</code> (in the LAMMPS sense, see region manual).</li>
</ul>
<h2 id="classes-and-methods">Classes And Methods</h2>
<h3 id="class-region">Class: <code><a title="region.region" href="#region.region">region</a></code></h3>
<h4 id="description">Description:</h4>
<p>The <code><a title="region.region" href="#region.region">region</a></code> class is used to define and manipulate geometries for LAMMPS simulations. It includes
methods for creating different geometric shapes, combining regions, and generating corresponding LAMMPS scripts.</p>
<h4 id="methods">Methods:</h4>
<ul>
<li><strong><code>__init__(self, name='', width=0, height=0, depth=0, regionunits='lattice', separationdistance=0.0, lattice_scale=1.0)</code></strong></li>
<li><strong>Description</strong>: Initializes a new region with specified dimensions and parameters.</li>
<li>
<p><strong>Parameters</strong>:</p>
<ul>
<li><code>name</code> (str): The name of the region.</li>
<li><code>width</code> (float): Width of the region.</li>
<li><code>height</code> (float): Height of the region.</li>
<li><code>depth</code> (float): Depth of the region.</li>
<li><code>regionunits</code> (str): Units of the region dimensions ('lattice' or 'si').</li>
<li><code>separationdistance</code> (float): Separation distance between regions.</li>
<li><code>lattice_scale</code> (float): Scale of the lattice.</li>
</ul>
</li>
<li>
<p><strong><code>do(self)</code></strong></p>
</li>
<li><strong>Description</strong>: Generates the objects within the region.</li>
<li>
<p><strong>Returns</strong>: None</p>
</li>
<li>
<p><strong><code><a title="region.script" href="#region.script">script</a>(self)</code></strong></p>
</li>
<li><strong>Description</strong>: Returns the LAMMPS script for the region.</li>
<li>
<p><strong>Returns</strong>: str</p>
</li>
<li>
<p><strong><code>union(self, o1, o2, name='')</code></strong></p>
</li>
<li><strong>Description</strong>: Creates a union of two objects within the region.</li>
<li><strong>Parameters</strong>:<ul>
<li><code>o1</code> (object): The first object.</li>
<li><code>o2</code> (object): The second object.</li>
<li><code>name</code> (str): The name of the union.</li>
</ul>
</li>
<li>
<p><strong>Returns</strong>: None</p>
</li>
<li>
<p><strong><code>cylinder(self, name, dim, c1, c2, radius, lo, hi, beadtype)</code></strong></p>
</li>
<li><strong>Description</strong>: Adds a cylinder to the region.</li>
<li><strong>Parameters</strong>:<ul>
<li><code>name</code> (str): The name of the cylinder.</li>
<li><code>dim</code> (str): Dimension along which the cylinder is oriented ('x', 'y', or 'z').</li>
<li><code>c1</code> (float): First coordinate of the center of the cylinder's base.</li>
<li><code>c2</code> (float): Second coordinate of the center of the cylinder's base.</li>
<li><code>radius</code> (float): Radius of the cylinder.</li>
<li><code>lo</code> (float): Lower bound of the cylinder along the specified dimension.</li>
<li><code>hi</code> (float): Upper bound of the cylinder along the specified dimension.</li>
<li><code>beadtype</code> (int): Type of beads to use for the cylinder.</li>
</ul>
</li>
<li>
<p><strong>Returns</strong>: None</p>
</li>
<li>
<p><strong><code>delete(self, name)</code></strong></p>
</li>
<li><strong>Description</strong>: Deletes an object from the region.</li>
<li><strong>Parameters</strong>:<ul>
<li><code>name</code> (str): The name of the object to delete.</li>
</ul>
</li>
<li><strong>Returns</strong>: None</li>
</ul>
<h2 id="examples">Examples</h2>
<p>Below are some examples demonstrating how to use the REGION module:</p>
<ol>
<li>
<p><strong>Concatenating Two Regions</strong>:
<code>python
R1 = pizza.regions()
R2 = pizza.regions()
R = R1 + R2</code></p>
</li>
<li>
<p><strong>Generating Objects</strong>:
<code>python
R.do()</code></p>
</li>
<li>
<p><strong>Retrieving the Script</strong>:
<code>python
script_content = R.script()</code></p>
</li>
<li>
<p><strong>Deleting an Object</strong>:
<code>python
R.o1 = []</code></p>
</li>
<li>
<p><strong>Creating a Union of Objects</strong>:
<code>python
R.union(o1, o2, name='union_name')</code></p>
</li>
<li>
<p><strong>Adding a Cylinder</strong>:
```python
R.cylinder(name='cyl1', dim='z', c1=0, c2=0, radius=1.0, lo=0.0, hi=5.0, beadtype=1)</p>
</li>
</ol>
<h2 id="advanced-features">Advanced Features</h2>
<p>Public features (i.e. to be used by the end-user)
Let R1, R2 being pizza.regions()
R = R1 + R2 concatenates two regions (objects of R2 are inherited in R1, higher precedence for R2)
R.do()
generate the objects (do() should work as in pizza.script)
R.script returns the script (script() should work as in pizza.script)</p>
<pre><code>    Let o1, o2 are objects of R
    R.o1 = [] delete o1
    R.union(o1,o2,name=...) creates an union of o1 and o2 (in the LAMMPS sense, see region manual)
    R.intersect(o1,o2,name=...) creates an intersection of o1 and o2 (in the LAMMPS sense, see region manual)
    R.eval(expr,name=)
            expr any algebraic expression including +
            o1+o2+...
</code></pre>
<p>Private features (i.e. to be used inside the code)
Overloading operators +, +=, | for any coregeometry object
Note that coregeometry have four main SECTIONS (scripts)
SECTIONS["variables"]
SECTIONS["region"]
SECTIONS["create"]
SECTIONS["group"]
SECTIONS["move"]
USER, VARIABLES are overdefined as attributes</p>
<pre><code>    +, += merge regions (no piping)
    | pipe them
</code></pre>
<p>Add other geometries: block, sphere, cylinder....</p>
<pre><code>```
</code></pre>
<h2 id="dependencies">Dependencies</h2>
<ul>
<li>Python 3.x</li>
<li>LAMMPS</li>
<li>pizza3.pizza</li>
</ul>
<h2 id="installation">Installation</h2>
<p>To use the REGION module, ensure that you have Python 3.x and LAMMPS installed. You can integrate the module into your project by placing the <code>region.py</code> file in your working directory or your Python path.</p>
<h2 id="license">License</h2>
<p>This project is licensed under the terms of the GPLv3 license.</p>
<h2 id="contact">Contact</h2>
<p>For any queries or contributions, please contact the maintainer:
- Olivier Vitrac, Han Chen
- Email: olivier.vitrac@agroparistech.fr</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;

================================================================================
REGION Module Documentation
================================================================================

Project: Pizza3
Authors: Olivier Vitrac, Han Chen
Copyright: 2024
Credits: Olivier Vitrac, Han Chen
License: GPLv3
Maintainer: Olivier Vitrac
Email: olivier.vitrac@agroparistech.fr
Version: 1.0

Overview
--------
The REGION module provides a suite of tools to define and manipulate native geometries in Python
 for LAMMPS (Large-scale Atomic/Molecular Massively Parallel Simulator). It is designed to facilitate
 the creation, concatenation, and manipulation of geometric regions used in molecular dynamics simulations.

Public Features
---------------
- Concatenation of Regions:
  - `R1 + R2` concatenates two regions (objects of R2 are inherited in R1, higher precedence for R2).
- Generation of Objects:
  - `R.do()` generates the objects (similar functionality to `do()` in pizza.script).
- Script Generation:
  - `R.script` returns the script (similar functionality to `script()` in pizza.script).
- Object Deletion:
  - `R.o1 = []` deletes object `o1`.
- Union of Objects:
  - `R.union(o1, o2, name=...)` creates a union of `o1` and `o2` (in the LAMMPS sense, see region manual).

Classes and Methods
-------------------
### Class: `region`
#### Description:
The `region` class is used to define and manipulate geometries for LAMMPS simulations. It includes
 methods for creating different geometric shapes, combining regions, and generating corresponding LAMMPS scripts.

#### Methods:
- **`__init__(self, name=&#39;&#39;, width=0, height=0, depth=0, regionunits=&#39;lattice&#39;, separationdistance=0.0, lattice_scale=1.0)`**
  - **Description**: Initializes a new region with specified dimensions and parameters.
  - **Parameters**:
    - `name` (str): The name of the region.
    - `width` (float): Width of the region.
    - `height` (float): Height of the region.
    - `depth` (float): Depth of the region.
    - `regionunits` (str): Units of the region dimensions (&#39;lattice&#39; or &#39;si&#39;).
    - `separationdistance` (float): Separation distance between regions.
    - `lattice_scale` (float): Scale of the lattice.

- **`do(self)`**
  - **Description**: Generates the objects within the region.
  - **Returns**: None

- **`script(self)`**
  - **Description**: Returns the LAMMPS script for the region.
  - **Returns**: str

- **`union(self, o1, o2, name=&#39;&#39;)`**
  - **Description**: Creates a union of two objects within the region.
  - **Parameters**:
    - `o1` (object): The first object.
    - `o2` (object): The second object.
    - `name` (str): The name of the union.
  - **Returns**: None

- **`cylinder(self, name, dim, c1, c2, radius, lo, hi, beadtype)`**
  - **Description**: Adds a cylinder to the region.
  - **Parameters**:
    - `name` (str): The name of the cylinder.
    - `dim` (str): Dimension along which the cylinder is oriented (&#39;x&#39;, &#39;y&#39;, or &#39;z&#39;).
    - `c1` (float): First coordinate of the center of the cylinder&#39;s base.
    - `c2` (float): Second coordinate of the center of the cylinder&#39;s base.
    - `radius` (float): Radius of the cylinder.
    - `lo` (float): Lower bound of the cylinder along the specified dimension.
    - `hi` (float): Upper bound of the cylinder along the specified dimension.
    - `beadtype` (int): Type of beads to use for the cylinder.
  - **Returns**: None

- **`delete(self, name)`**
  - **Description**: Deletes an object from the region.
  - **Parameters**:
    - `name` (str): The name of the object to delete.
  - **Returns**: None

Examples
--------
Below are some examples demonstrating how to use the REGION module:

1. **Concatenating Two Regions**:
    ```python
    R1 = pizza.regions()
    R2 = pizza.regions()
    R = R1 + R2
    ```

2. **Generating Objects**:
    ```python
    R.do()
    ```

3. **Retrieving the Script**:
    ```python
    script_content = R.script()
    ```

4. **Deleting an Object**:
    ```python
    R.o1 = []
    ```

5. **Creating a Union of Objects**:
    ```python
    R.union(o1, o2, name=&#39;union_name&#39;)
    ```

6. **Adding a Cylinder**:
    ```python
    R.cylinder(name=&#39;cyl1&#39;, dim=&#39;z&#39;, c1=0, c2=0, radius=1.0, lo=0.0, hi=5.0, beadtype=1)


Advanced features
-----------------
Public features (i.e. to be used by the end-user)
        Let R1, R2 being pizza.regions()
        R = R1 + R2 concatenates two regions (objects of R2 are inherited in R1, higher precedence for R2)
        R.do()   generate the objects (do() should work as in pizza.script)
        R.script returns the script (script() should work as in pizza.script)

        Let o1, o2 are objects of R
        R.o1 = [] delete o1
        R.union(o1,o2,name=...) creates an union of o1 and o2 (in the LAMMPS sense, see region manual)
        R.intersect(o1,o2,name=...) creates an intersection of o1 and o2 (in the LAMMPS sense, see region manual)
        R.eval(expr,name=)
                expr any algebraic expression including +
                o1+o2+...

Private features (i.e. to be used inside the code)
        Overloading operators +, +=, | for any coregeometry object
        Note that coregeometry have four main SECTIONS (scripts)
       SECTIONS[&#34;variables&#34;]
       SECTIONS[&#34;region&#34;]
       SECTIONS[&#34;create&#34;]
       SECTIONS[&#34;group&#34;]
       SECTIONS[&#34;move&#34;]
                USER, VARIABLES are overdefined as attributes

        +, += merge regions (no piping)
        | pipe them

   Add other geometries: block, sphere, cylinder....

    ```

Dependencies
------------
- Python 3.x
- LAMMPS
- pizza3.pizza

Installation
------------
To use the REGION module, ensure that you have Python 3.x and LAMMPS installed. You can integrate the module into your project by placing the `region.py` file in your working directory or your Python path.

License
-------
This project is licensed under the terms of the GPLv3 license.

Contact
-------
For any queries or contributions, please contact the maintainer:
- Olivier Vitrac, Han Chen
- Email: olivier.vitrac@agroparistech.fr
&#34;&#34;&#34;

__project__ = &#34;Pizza3&#34;
__author__ = &#34;Olivier Vitrac, Han Chen&#34;
__copyright__ = &#34;Copyright 2024&#34;
__credits__ = [&#34;Olivier Vitrac&#34;, &#34;Han Chen&#34;]
__license__ = &#34;GPLv3&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;1.0&#34;




# INRAE\Olivier Vitrac - rev. 2025-01-17 (community)
# contact: olivier.vitrac@agroparistech.fr, han.chen@inrae.fr

# Revision history
# 2023-01-04 code initialization
# 2023-01-10 early alpha version
# 2023-01-11 alpha version (many fixes), wrap and align all displays with textwrap.fill, textwrap.shorten
# 2023-01-12 implement methods of keyword(units/rotate/open)
# 2023-01-18 split a script into subscripts to be executed in pipescripts
# 2023-01-19 use of LammpsGeneric.do() and hasvariables flag to manage VARIABLES
# 2023-01-20 app PythonPath management for VScode, add comments region.ellipsoid()
# 2023-01-22 todo list added
# 2023-01-24 implementation (o1 = R.E1, o2 = R.E2): o1+o2+... and o1 | o2 | ...
# 2023-01-25 full implementation of eval(), set(), get(), __setattr__(), __getattr__(), iterators
# 2023-01-26 add an example with for and join
# 2023-01-27 add coregometry.__iadd__, region.pipescript, region.script, region.do()
# 2023-01-27 true alpha version, workable with https://andeplane.github.io/atomify/
# 2023-01-31 fix browser and temporary files on Linux
# 2023-02-06 major update, internal documentation for all objects, livelammps attribute
# 2023-02-16 fix object counters, add width, height, depth to region(), data are stored in live
# 2023-02-16 add a specific &gt;&gt; (__rshift__) method for LammpsVariables, to be used by pipescript.do()
# 2023-02-21 add gel compression exemple, modification of the footer section to account for several beadtypes
# 2023-03-16 add emulsion, collection
# 2023-07-07 fix region.union()
# 2023-07-15 add the preffix &#34;$&#34; to units, fix prism and other minor issues
# 2023-07-15 (code works with the current state of Workshop4)
# 2023-07-17 avoid duplicates if union or intersect is used, early implemeantion of &#34;move&#34;
# 2023-07-19 add region.hasfixmove, region.livelammps.options[&#34;static&#34; | &#34;dynamic&#34;]
# 2023-07-19 early design for LammpsGroup class, Group class, region.group()
# 2023-07-20 reimplement, validate and extend the original emulsion example
# 2023-07-25 add group section (not active by default)
# 2023-07-29 symmetric design for coregeometry and collection objects with flag control, implementation in pipescript
# 2023-07-29 fix for the class LammpsCollectionGroup() - previous bug resolved
# 2023-08-11 full implementation of the space-filled model such as in pizza.raster
# 2024-04-18 workshop compatible (i.e., implementation of region.scriptobject(), to be used along with region.do())
# 2024-06-14 add mass, density attributes to all region objects and region (overdefinitions are possible), natoms return the number of atoms
# 2024-06-20 debug the calculation of volume of cylinder
# 2024-07-03 full implementation of scaling in pizza.region()
# 2024-07-04 implementation of scaling with formula (when variables are used), add live attributes to region along with an updated LammpsHeader
# 2024-07-05 full implementation of natoms, geometry
# 2024-07-29 consolidation of the method scriptobject (note that a do() is required before calling scriptobject)
# 2024-08-02 community implementation
# 2024-08-31 add method R.beadtypes(), class headerbox(), method R.headerbox()
# 2024-08-01 more robust implementation via method: scriptHeaders() and headersData object
# 2024-10-08 add lattice_scale
# 2024-12-01 standarize scripting features, automatically call script/pscript methods
# 2024-12-09 fix getattr for region objects to be compatible with inspect, pdoc
# 2025-01-17 fix numpy import (it was removed)


# %% Imports and private library
import os, sys, math
import numpy as np
from datetime import datetime
from copy import copy as duplicate
from copy import deepcopy as deepduplicate
from textwrap import fill, shorten
from webbrowser import open as livelammps

# update python path if needed (for development only)
# try: pwd = os.path.abspath(os.path.join(os.path.dirname(__file__),&#34;..&#34;))
# except NameError: pwd = os.getcwd()
# try: sys.path.index(pwd) # sys.path.insert(0, os.getcwd())
# except ValueError: sys.path.append(pwd)
# print(&#39;\n&gt;&gt;&gt;&#39;,pwd,&#39;\n&#39;)
# os.chdir(pwd)

# import struct, param, paramauto, span
from pizza.private.mstruct import *
from pizza.script import pipescript, script, scriptdata, scriptobject, span
from pizza.forcefield import *


__all__ = [&#39;AttrErrorDict&#39;, &#39;Block&#39;, &#39;Collection&#39;, &#39;Cone&#39;, &#39;Cylinder&#39;, &#39;Ellipsoid&#39;, &#39;Evalgeometry&#39;, &#39;Intersect&#39;, &#39;LammpsCollectionGroup&#39;, &#39;LammpsCreate&#39;, &#39;LammpsFooter&#39;, &#39;LammpsFooterPreview&#39;, &#39;LammpsGeneric&#39;, &#39;LammpsGroup&#39;, &#39;LammpsHeader&#39;, &#39;LammpsHeaderBox&#39;, &#39;LammpsHeaderInit&#39;, &#39;LammpsHeaderLattice&#39;, &#39;LammpsHeaderMass&#39;, &#39;LammpsMove&#39;, &#39;LammpsRegion&#39;, &#39;LammpsSetGroup&#39;, &#39;LammpsSpacefilling&#39;, &#39;LammpsVariables&#39;, &#39;Plane&#39;, &#39;Prism&#39;, &#39;SafeEvaluator&#39;, &#39;Sphere&#39;, &#39;Union&#39;, &#39;cleanname&#39;, &#39;coregeometry&#39;, &#39;emulsion&#39;, &#39;forcefield&#39;, &#39;headersRegiondata&#39;, &#39;none&#39;, &#39;param&#39;, &#39;paramauto&#39;, &#39;parameterforcefield&#39;, &#39;pipescript&#39;, &#39;pstr&#39;, &#39;region&#39;, &#39;regioncollection&#39;, &#39;regiondata&#39;, &#39;rigidwall&#39;, &#39;saltTLSPH&#39;, &#39;scatter&#39;, &#39;script&#39;, &#39;scriptdata&#39;, &#39;scriptobject&#39;, &#39;smd&#39;, &#39;solidfood&#39;, &#39;span&#39;, &#39;struct&#39;, &#39;tlsph&#39;, &#39;ulsph&#39;, &#39;water&#39;, &#39;wrap&#39;]


# protected properties in region
protectedregionkeys = (&#39;name&#39;, &#39;live&#39;, &#39;nbeads&#39; &#39;volume&#39;, &#39;mass&#39;, &#39;radius&#39;, &#39;contactradius&#39;, &#39;velocities&#39;,
                        &#39;forces&#39;, &#39;filename&#39;, &#39;index&#39;, &#39;objects&#39;, &#39;nobjects&#39;, &#39;counter&#39;,&#39;_iter_&#39;,
                        &#39;livelammps&#39;,&#39;copy&#39;, &#39;hasfixmove&#39;, &#39;spacefilling&#39;, &#39;isspacefilled&#39;, &#39;spacefillingbeadtype&#39;,&#39;mass&#39;,&#39;density&#39;,
                        &#39;units&#39;,&#39;center&#39;,&#39;separationdistance&#39;,&#39;regionunits&#39;,
                        &#39;lattice_scale&#39;,&#39;lattice_style&#39;,&#39;lattice_scale_siunits&#39;, &#39;lattice_spacing&#39;,
                        &#39;geometry&#39;, &#39;natoms&#39;, &#39;headersData&#39;
                            )

# livelammps
#livelammpsURL = &#39;https://editor.lammps.org/&#39;
livelammpsURL = &#34;https://andeplane.github.io/atomify/&#34;
livetemplate = {
    &#39;mass&#39;:&#39;mass                    %d 1.0&#39;,
    &#39;pair_coeff&#39;:&#39;pair_coeff        %d %d 1.0 1.0 2.5&#39;,
    }
groupprefix = &#34;GRP&#34;  # prefix for all group IDs created from a named region
fixmoveprefix = &#34;FM&#34; # prefix for all fix move IDs created from a named region
# %% Low level functions
# wrap and indent text for variables
wrap = lambda k,op,v,indent,width,maxwidth: fill(
        shorten(v,width=maxwidth+indent,
        fix_sentence_endings=True),
        width=width+indent,
        initial_indent=&#34; &#34;*(indent-len(k)-len(op)-2)+f&#39;{k} {op} &#39;,
        subsequent_indent=&#39; &#39;*(indent+(1 if v[0]==&#39;&#34;&#39; else 0) )
        )

# remove $ from variable names
cleanname = lambda name: &#34;&#34;.join([x for x in name if x!=&#34;$&#34;])

# %% Top generic classes for storing region data and objects
# they are not intended to be used outside script data and objects

class regiondata(paramauto):
    &#34;&#34;&#34;
        class of script parameters
            Typical constructor:
                DEFINITIONS = regiondata(
                    var1 = value1,
                    var2 = value2
                    )
        See script, struct, param to get review all methods attached to it
    &#34;&#34;&#34;
    _type = &#34;RD&#34;
    _fulltype = &#34;region data&#34;
    _ftype = &#34;definition&#34;

    def generatorforlammps(self,verbose=False,hasvariables=False):
        &#34;&#34;&#34;
            generate LAMMPS code from regiondata (struct)
            generatorforlammps(verbose,hasvariables)
            hasvariables = False is used to prevent a call of generatorforLammps()
            for scripts others than LammpsGeneric ones
        &#34;&#34;&#34;
        nk = len(self)
        if nk&gt;0:
            self.sortdefinitions(raiseerror=False)
            s = self.tostruct()
            ik = 0
            fmt = &#34;variable %s equal %s&#34;
            cmd = &#34;\n#&#34;+&#34;_&#34;*40+&#34;\n&#34;+f&#34;#[{str(datetime.now())}]\n&#34; if verbose else &#34;&#34;
            cmd += f&#34;\n# Definition of {nk} variables (URL: https://docs.lammps.org/variable.html)\n&#34;
            if hasvariables:
                for k in s.keys():
                    ik += 1
                    end = &#34;\n&#34; if ik&lt;nk else &#34;\n&#34;*2
                    v = getattr(s,k)
                    if v is None: v = &#34;NULL&#34;
                    if isinstance(v,(int,float)) or v == None:
                        cmd += fmt % (k,v)+end
                    elif isinstance(v,str):
                        cmd += fmt % (k,f&#39;{v}&#39;)+end
                    elif isinstance(v,(list,tuple)):
                        cmd += fmt % (k,span(v))+end
                    else:
                        raise TypeError(f&#34;unsupported type for the variable {k} set to {v}&#34;)
                if verbose: cmd += &#34;#&#34;+&#34;_&#34;*40+&#34;\n&#34;
        return cmd

class regioncollection(struct):
    &#34;&#34;&#34; regioncollection class container (not to be called directly) &#34;&#34;&#34;
    _type = &#34;collect&#34;               # object type
    _fulltype = &#34;Collections&#34;    # full name
    _ftype = &#34;collection&#34;        # field name
    def __init__(self,*obj,**kwobj):
        # store the objects with their alias
        super().__init__(**kwobj)
        # store objects with their real names
        for o in obj:
            if isinstance(o,region):
                s = struct.dict2struct(o.objects)
                list_s = s.keys()
                for i in range(len(list_s)): self.setattr(list_s[i], s[i].copy())
            elif o!=None:
                self.setattr(o.name, o.copy())

# Class for headersData (added on 2024-09-01)
class headersRegiondata(regiondata):
    &#34;&#34;&#34;
        class of script parameters
            Typical constructor:
                DEFINITIONS = headersRegiondata(
                    var1 = value1,
                    var2 = value2
                    )
        See script, struct, param to get review all methods attached to it
    &#34;&#34;&#34;
    _type = &#34;HRD&#34;
    _fulltype = &#34;Header parameters - helper for scripts&#34;
    _ftype = &#34;header definition&#34;


# %% PRIVATE SUB-CLASSES
# Use the equivalent methods of raster() to call these constructors

class LammpsGeneric(script):
    &#34;&#34;&#34;
        common class to override standard do() method from script
        LammpsVariables, LammpsRegion, LammpsCreate are LammpsGeneric
        note:: the only difference with the common script class is that
        LammpsGeneric accepts VARIABLES AND To SHOW THEM
    &#34;&#34;&#34;
    def do(self,printflag=True,verbose=False):
        &#34;&#34;&#34; generate the LAMMPS code with VARIABLE definitions &#34;&#34;&#34;
        if self.DEFINITIONS.hasvariables and hasattr(self,&#39;VARIABLES&#39;): # attribute VARIABLES checked 2023-08-11
            cmd = f&#34;#[{str(datetime.now())}] {self.name} &gt; {self.SECTIONS[0]}&#34; \
                if verbose else &#34;&#34;
            if len(self.VARIABLES)&gt;0: cmd += \
            self.VARIABLES.generatorforlammps(verbose=verbose,hasvariables=True)
        else:
            cmd = &#34;&#34;
        cmd += super().do(printflag=False,verbose=verbose)
        if printflag: print(cmd)
        return cmd

class LammpsVariables(LammpsGeneric):
    &#34;&#34;&#34;
        script for LAMMPS variables section
        myvars = LammpsVariables(regiondata(var1=...),ID=&#39;....&#39;,style=&#39;....&#39;)
    &#34;&#34;&#34;
    name = &#34;LammpsVariables&#34;
    SECTIONS = [&#34;VARIABLES&#34;]
    position = 2
    role = &#34;variable command definition&#34;
    description = &#34;variable name style args&#34;
    userid = &#34;variable&#34;
    version = 0.1
    verbose = True

    # Definitions used in TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
                 style = &#34;${style}&#34;,
          hasvariables = True
                    )

    # Template  (using % instead of # enables replacements)
    TEMPLATE = &#34;% variables to be used for ${ID} ${style}&#34;

    def __init__(self,VARIABLES=regiondata(),**userdefinitions):
        &#34;&#34;&#34; constructor of LammpsVariables &#34;&#34;&#34;
        super().__init__(**userdefinitions)
        self.VARIABLES = VARIABLES

    # override &gt;&gt;
    def __rshift__(self,s):
        &#34;&#34;&#34; overload right  shift operator (keep only the last template) &#34;&#34;&#34;
        if isinstance(s,script):
            dup = deepduplicate(self) # instead of duplicate (added 2023-08-11)
            dup.DEFINITIONS = dup.DEFINITIONS + s.DEFINITIONS
            dup.USER = dup.USER + s.USER
            if self.DEFINITIONS.hasvariables and s.DEFINITIONS.hasvariables:
                dup.VARIABLES = s.VARIABLES
            dup.TEMPLATE = s.TEMPLATE
            return dup
        else:
            raise TypeError(&#34;the second operand must a script object&#34;)


class LammpsCreate(LammpsGeneric):
    &#34;&#34;&#34; script for LAMMPS variables section &#34;&#34;&#34;
    name = &#34;LammpsCreate&#34;
    SECTIONS = [&#34;create_atoms&#34;]
    position = 4
    role = &#34;create_atoms command&#34;
    description = &#34;create_atoms type style args keyword values ...&#34;
    userid = &#34;create&#34;
    version = 0.1
    verbose = True

    # Definitions used in TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
                 style = &#34;${style}&#34;,
                 hasvariables = False
                    )

    # Template (using % instead of # enables replacements)
    TEMPLATE = &#34;&#34;&#34;
% Create atoms of type ${beadtype} for ${ID} ${style} (https://docs.lammps.org/create_atoms.html)
create_atoms ${beadtype} region ${ID}
&#34;&#34;&#34;

class LammpsSetGroup(LammpsGeneric):
    &#34;&#34;&#34; script for LAMMPS set group section &#34;&#34;&#34;
    name = &#34;LammpsSetGroup&#34;
    SECTIONS = [&#34;set group&#34;]
    position = 4
    role = &#34;create_atoms command&#34;
    description = &#34;set group groupID type beadtype&#34;
    userid = &#34;setgroup&#34;
    version = 0.1
    verbose = True

    # Definitions used in TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
               groupID = &#34;$&#34;+groupprefix+&#34;${ID}&#34;, # freeze the interpretation,
          hasvariables = False
                    )

    # Template (using % instead of # enables replacements)
    TEMPLATE = &#34;&#34;&#34;
% Reassign atom type to ${beadtype} for the group ${groupID} associated with region ${ID} (https://docs.lammps.org/set.html)
set group ${groupID} type ${beadtype}
&#34;&#34;&#34;

class LammpsMove(LammpsGeneric):
    &#34;&#34;&#34; script for LAMMPS variables section &#34;&#34;&#34;
    name = &#34;LammpsMove&#34;
    SECTIONS = [&#34;move_fix&#34;]
    position = 6
    role = &#34;move along a trajectory&#34;
    description = &#34;fix ID group-ID move style args keyword values ...&#34;
    userid = &#34;move&#34;
    version = 0.2
    verbose = True

    # Definitions used in TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
                moveID = &#34;$&#34;+fixmoveprefix+&#34;${ID}&#34;, # freeze the interpretation
               groupID = &#34;$&#34;+groupprefix+&#34;${ID}&#34;, # freeze the interpretation
                 style = &#34;${style}&#34;,
                  args = &#34;${args}&#34;,
          hasvariables = False
                    )

    # Template (using % instead of # enables replacements)
    TEMPLATE = &#34;&#34;&#34;
# Move atoms fix ID group-ID move style args keyword values (https://docs.lammps.org/fix_move.html)
% move_fix for group ${groupID} using ${style}
% prefix &#34;g&#34; added to ${ID} to indicate a group of atoms
% prefix &#34;fm&#34; added to ${ID} to indicate the ID of the fix move
fix ${moveID} ${groupID} move ${style} ${args}
&#34;&#34;&#34;


class LammpsRegion(LammpsGeneric):
    &#34;&#34;&#34; generic region based on script &#34;&#34;&#34;
    name = &#34;LammpsRegion&#34;
    SECTIONS = [&#34;REGION&#34;]
    position = 3
    role = &#34;region command definition&#34;
    description = &#34;region ID style args keyword arg&#34;
    userid = &#34;region&#34;              # user name
    version = 0.1                  # version
    verbose = True

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
                 style = &#34;${style}&#34;,
                  args = &#34;${args}&#34;,
                  side = &#34;${side}&#34;,
                 units = &#34;${units}&#34;,
                  move = &#34;${move}&#34;,
                rotate = &#34;${rotate}&#34;,
                  open = &#34;${open}&#34;,
          hasvariables = False
                    )

    # Template  (using % instead of # enables replacements)
    TEMPLATE = &#34;&#34;&#34;
% Create region ${ID} ${style} args ...  (URL: https://docs.lammps.org/region.html)
# keywords: side, units, move, rotate, open
# values: in|out, lattice|box, v_x v_y v_z, v_theta Px Py Pz Rx Ry Rz, integer
region ${ID} ${style} ${args} ${side}${units}${move}${rotate}${open}
&#34;&#34;&#34;


class LammpsGroup(LammpsGeneric):
    &#34;&#34;&#34; generic group class based on script &#34;&#34;&#34;
    name = &#34;LammpsGroup&#34;
    SECTIONS = [&#34;GROUP&#34;]
    position = 5
    role = &#34;group command definition&#34;
    description = &#34;group ID region regionID&#34;
    userid = &#34;region&#34;              # user name
    version = 0.2                  # version
    verbose = True

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
               groupID = &#34;$&#34;+groupprefix+&#34;${ID}&#34;, # freeze the interpretation
          countgroupID = &#34;$count&#34;+&#34;${groupID}&#34;, # either using $
           grouptoshow = [&#34;${groupID}&#34;], # or []
                 hasvariables = False
                    )

    # Template  (using % instead of # enables replacements)
    TEMPLATE = &#34;&#34;&#34;
% Create group ${groupID} region ${ID} (URL: https://docs.lammps.org/group.html)
group ${groupID} region ${ID}
variable ${countgroupID} equal count(${grouptoshow})
print &#34;Number of atoms in ${groupID}: \${{countgroupID}}&#34;
&#34;&#34;&#34;


class LammpsCollectionGroup(LammpsGeneric):
    &#34;&#34;&#34; Collection group class based on script &#34;&#34;&#34;
    name = &#34;LammpsCollection Group&#34;
    SECTIONS = [&#34;COLLECTIONGROUP&#34;]
    position = 6
    role = &#34;group command definition for a collection&#34;
    description = &#34;group ID union regionID1 regionID2...&#34;
    userid = &#34;collectionregion&#34;              # user name
    version = 0.3                            # version
    verbose = True

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
               groupID = &#34;$&#34;+groupprefix+&#34;${ID}&#34;, # freeze the interpretation
          hasvariables = False
                    )

    # Template  (ID is spanned over all regionIDs)
    TEMPLATE = &#34;&#34;&#34;
% Create group ${groupID} region ${ID} (URL: https://docs.lammps.org/group.html)
group ${groupID} union ${ID}
&#34;&#34;&#34;

class LammpsHeader(LammpsGeneric):
    &#34;&#34;&#34; generic header for pizza.region &#34;&#34;&#34;
    name = &#34;LammpsHeader&#34;
    SECTIONS = [&#34;HEADER&#34;]
    position = 0
    role = &#34;header for live view&#34;
    description = &#34;To be used with https://editor.lammps.org/&#34;
    userid = &#34;header&#34;              # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
                    width = 10,
                   height = 10,
                    depth = 10,
                    nbeads = 1,
            hasvariables = False
                    )

    # Template
    TEMPLATE = &#34;&#34;&#34;
# --------------[    INIT   ]--------------
# assuming generic LJ units and style
units           ${live_units}
atom_style          ${live_atom_style}
lattice             ${live_lattice_style} ${live_lattice_scale}
# ------------------------------------------

# --------------[    B O X   ]--------------
variable        halfwidth equal ${width}/2
variable        halfheight equal ${height}/2
variable        halfdepth equal ${depth}/2
region box block -${halfwidth} ${halfwidth} -${halfheight} ${halfheight} -${halfdepth} ${halfdepth}
create_box      ${nbeads} box
# ------------------------------------------
&#34;&#34;&#34;

class LammpsHeaderInit(LammpsGeneric): # --- helper script ---
    &#34;&#34;&#34;
    Generates an initialization header script for a pizza.region object in LAMMPS.

    This class constructs a LAMMPS header based on user-defined properties stored
    in `R.headersData` of the pizza.region object. Properties set to `None` or an
    empty string will be omitted from the script.

    Attributes:
        DEFINITIONS: Defines the parameters like dimension, units, boundary, etc.,
        that can be set in `R.headersData`.

    Methods:
        __init__(persistentfile=True, persistentfolder=None, **userdefinitions):
            Initializes the header script and sets up the `USER` attribute.

        generate_template():
            Creates the header template based on the provided `USER` definitions.

    Note: This class is primarily intended for internal use within the simulation setup.
    &#34;&#34;&#34;
    name = &#34;LammpsHeaderBox&#34;
    SECTIONS = [&#34;HEADER&#34;]
    position = -2
    role = &#34;initialization header for pizza.region&#34;
    description = &#34;helper method&#34;
    userid = &#34;headerinit&#34;          # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    # circular references (the variable is defined by its field in USER of class regiondata)
    # are not needed but this explicits the requirements.
    # All fields are stored in R.headersData with R a region object.
    # Use R.headersData.property = value to assign a value
    # Use R.headersData.property = None or &#34;&#34; to prevent the initialization of property
    DEFINITIONS = scriptdata(
                regionname = &#34;${name}&#34;,
                 dimension = &#34;${dimension}&#34;,
                     units = &#34;${units}&#34;,
                  boundary = &#34;${boundary}&#34;,
                atom_style = &#34;${atom_style}&#34;,
               atom_modify = &#34;${atom_modify}&#34;,
               comm_modify = &#34;${comm_modify}&#34;,
              neigh_modify = &#34;${neigh_modify}&#34;,
                    newton = &#34;${newton}&#34;,
            hasvariables = False
                    )

    def __init__(self, persistentfile=True, persistentfolder=None, **userdefinitions):
        &#34;&#34;&#34;Constructor adding instance definitions stored in USER.&#34;&#34;&#34;
        super().__init__(persistentfile, persistentfolder, **userdefinitions)
        self.generate_template()

    def generate_template(self):
        &#34;&#34;&#34;Generate the TEMPLATE based on USER definitions.&#34;&#34;&#34;
        self.TEMPLATE = &#34;&#34;&#34;
% --------------[ Initialization for &lt;${name}:${boxid}&gt;   ]--------------
    &#34;&#34;&#34;
        self.TEMPLATE += &#39;# set a parameter to None or &#34;&#34; to remove the definition\n&#39;
        if self.USER.dimension:   self.TEMPLATE += &#34;dimension    ${dimension}\n&#34;
        if self.USER.units:       self.TEMPLATE += &#34;units        ${units}\n&#34;
        if self.USER.boundary:    self.TEMPLATE += &#34;boundary     ${boundary}\n&#34;
        if self.USER.atom_style:  self.TEMPLATE += &#34;atom_style   ${atom_style}\n&#34;
        if self.USER.atom_modify: self.TEMPLATE += &#34;atom_modify  ${atom_modify}\n&#34;
        if self.USER.comm_modify: self.TEMPLATE += &#34;comm_modify  ${comm_modify}\n&#34;
        if self.USER.neigh_modify:self.TEMPLATE += &#34;neigh_modify ${neigh_modify}\n&#34;
        if self.USER.newton:      self.TEMPLATE += &#34;newton       ${newton}\n&#34;
        self.TEMPLATE += &#34;# ------------------------------------------\n&#34;


class LammpsHeaderLattice(LammpsGeneric): # --- helper script ---
    &#34;&#34;&#34;
        Lattice header for pizza.region

        Use R.headersData.property = value to assign a value
        with R a pizza.region object
    &#34;&#34;&#34;
    name = &#34;LammpsHeaderLattice&#34;
    SECTIONS = [&#34;HEADER&#34;]
    position = 0
    role = &#34;lattice header for pizza.region&#34;
    description = &#34;helper method&#34;
    userid = &#34;headerlattice&#34;       # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    # circular references (the variable is defined by its field in USER of class regiondata)
    # are not needed but this explicits the requirements.
    # All fields are stored in R.headersData with R a region object.
    # Use R.headersData.property = value to assign a value
    DEFINITIONS = scriptdata(
             lattice_style = &#34;${lattice_style}&#34;,
             lattice_scale = &#34;${lattice_scale}&#34;,
            hasvariables = False
                    )
    def __init__(self, persistentfile=True, persistentfolder=None, **userdefinitions):
        &#34;&#34;&#34;Constructor adding instance definitions stored in USER.&#34;&#34;&#34;
        super().__init__(persistentfile, persistentfolder, **userdefinitions)
        self.generate_template()

    def generate_template(self):
        &#34;&#34;&#34;Generate the TEMPLATE based on USER definitions.&#34;&#34;&#34;
        self.TEMPLATE = &#34;\n% --------------[ Lattice for &lt;${name}:${boxid}&gt;, style=${lattice_style}, scale=${lattice_scale} ]--------------\n&#34;
        if self.USER.lattice_spacing is None:
            self.TEMPLATE += &#34;lattice ${lattice_style} ${lattice_scale}\n&#34;
        else:
            self.TEMPLATE += &#34;lattice ${lattice_style} ${lattice_scale} spacing ${lattice_spacing}\n&#34;
        self.TEMPLATE += &#34;# ------------------------------------------\n&#34;


class LammpsHeaderBox(LammpsGeneric): # --- helper script ---
    &#34;&#34;&#34;
        Box header for pizza.region

        Use R.headersData.property = value to assign a value
        with R a pizza.region object
    &#34;&#34;&#34;
    name = &#34;LammpsHeaderBox&#34;
    SECTIONS = [&#34;HEADER&#34;]
    position = 0
    role = &#34;box header for pizza.region&#34;
    description = &#34;helper method&#34;
    userid = &#34;headerbox&#34;           # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    # circular references (the variable is defined by its field in USER of class regiondata)
    # are not needed but this explicits the requirements.
    # All fields are stored in R.headersData with R a region object.
    # Use R.headersData.property = value to assign a value
    # Extra arguments
    #   ${boxid_arg} is by default &#34;box&#34;
    #   ${boxunits_arg} can be &#34;&#34;, &#34;units lattice&#34;, &#34;units box&#34;
    DEFINITIONS = scriptdata(
                      name = &#34;${name}&#34;,
                      xmin = &#34;${xmin}&#34;,
                      xmax = &#34;${xmax}&#34;,
                      ymin = &#34;${ymin}&#34;,
                      ymax = &#34;${ymax}&#34;,
                      zmin = &#34;${zmin}&#34;,
                      zmax = &#34;${zmax}&#34;,
                    nbeads = &#34;${nbeads}&#34;,
                     boxid = &#34;${boxid}&#34;,
              boxunits_arg = &#34;&#34;,     # default units
            hasvariables = False
                    )

    # Template
    TEMPLATE = &#34;&#34;&#34;
% --------------[ Box for &lt;${name}:${boxid}&gt; incl. ${nbeads} bead types ]--------------
region ${boxid} block ${xmin} ${xmax} ${ymin} ${ymax} ${zmin} ${zmax} ${boxunits_arg}
create_box      ${nbeads} ${boxid}
# ------------------------------------------
&#34;&#34;&#34;

class LammpsHeaderMass(LammpsGeneric):
    &#34;&#34;&#34;
    Mass assignment header for pizza.region.

    Use R.headersData.property = value to assign a value
    with R a pizza.region object.
    &#34;&#34;&#34;
    name = &#34;LammpsHeaderMass&#34;
    SECTIONS = [&#34;HEADER&#34;]
    position = 2  # Positioned after other headers like Box and Lattice
    role = &#34;mass assignment header for pizza.region&#34;
    description = &#34;Assigns masses to bead types based on nbeads and default mass.&#34;
    userid = &#34;headermass&#34;  # User identifier
    version = 0.1
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    # All fields are stored in R.headersData with R a region object.
    # Use R.headersData.property = value to assign a value.
    # Mass overrides are provided via the &#39;mass&#39; keyword argument as a list or tuple.
    DEFINITIONS = scriptdata(
        nbeads=&#34;${nbeads}&#34;,  # these default values are not used
        mass=&#34;${mass}&#34;,      # but reported for records
        hasvariables=False
    )

    def __init__(self, persistentfile=True, persistentfolder=None, **userdefinitions):
        &#34;&#34;&#34;
            Constructor adding instance definitions stored in USER.

            Parameters:
                persistentfile (bool, optional): Whether to use a persistent file. Defaults to True.
                persistentfolder (str, optional): Folder path for persistent files. Defaults to None.
                **userdefinitions: Arbitrary keyword arguments for user definitions.
                    - mass (list or tuple, optional): List or tuple to override masses for specific bead types.
                      Example: mass=[1.2, 1.0, 0.8] assigns mass 1.2 to bead type 1, 1.0 to bead type 2,
                      and 0.8 to bead type 3.
        &#34;&#34;&#34;
        super().__init__(persistentfile, persistentfolder, **userdefinitions)
        self.generate_template()

    def generate_template(self):
        &#34;&#34;&#34;
            Generate the TEMPLATE for mass assignments based on USER definitions.

            The method constructs mass assignments for each bead type. If `mass` overrides
            are provided as a list or tuple, it assigns the specified mass to the corresponding
            bead types. Otherwise, it uses the default `mass` value from `USER.headersData.mass`.
        &#34;&#34;&#34;
        # Retrieve user-defined parameters
        nbeads = self.USER.nbeads
        mass = self.USER.mass
        # Validate mass
        if not isinstance(mass, (list, tuple)): mass = [mass]  # Convert single value to a list
        if len(mass) &gt; nbeads:
            mass = mass[:nbeads]  # Truncate excess entries
        elif len(mass) &lt; nbeads:
            last_mass = mass[-1]  # Repeat the last value for missing entries
            mass += [last_mass] * (nbeads - len(mass))
        # Initialize TEMPLATE with header comment
        self.TEMPLATE = &#34;\n% --------------[ Mass Assignments for &lt;${name}:${boxid}&gt;&#34; + f&#34; (nbeads={nbeads}) &#34; +&#34; ]--------------\n&#34;
        # Iterate over bead types and assign masses
        for bead_type in range(1, nbeads + 1):
            bead_mass = mass[bead_type - 1]
            if isinstance(bead_mass, str):
                # If mass is a string (e.g., formula), ensure proper formatting
                mass_str = f&#34;({bead_mass})&#34;
            else:
                # If mass is a numeric value, convert to string
                mass_str = f&#34;{bead_mass}&#34;
            self.TEMPLATE += f&#34;mass {bead_type} {mass_str}\n&#34;
        # Close the TEMPLATE with a comment
        self.TEMPLATE += &#34;# ------------------------------------------\n&#34;


class LammpsFooterPreview(LammpsGeneric): # --- helper script ---
    &#34;&#34;&#34;
        Box header for pizza.region

        Use R.headersData.property = value to assign a value
        with R a pizza.region object
    &#34;&#34;&#34;
    name = &#34;LammpsFooterPreview&#34;
    SECTIONS = [&#34;Footer&#34;]
    position = 0
    role = &#34;box footer for pizza.region&#34;
    description = &#34;helper method&#34;
    userid = &#34;footerpreview&#34;       # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    # circular references (the variable is defined by its field in USER of class regiondata)
    # are not needed but this explicits the requirements.
    # All fields are stored in R.headersData with R a region object.
    # Use R.headersData.property = value to assign a value
    # Extra arguments
    #   ${boxid_arg} is by default &#34;box&#34;
    #   ${boxunits_arg} can be &#34;&#34;, &#34;units lattice&#34;, &#34;units box&#34;
    DEFINITIONS = scriptdata(
                filename = &#34;${previewfilename}&#34;,
            hasvariables = False
                    )

    # Template
    TEMPLATE = &#34;&#34;&#34;
% --------------[ Preview for &lt;${name}:${boxid}&gt; incl. ${nbeads} bead types ]--------------
% Output the initial geometry to a dump file &#34;${previewfilename}&#34; for visualization
dump initial_dump all custom 1 ${previewfilename} id type x y z
run 0
# ------------------------------------------
&#34;&#34;&#34;

class LammpsSpacefilling(LammpsGeneric):
    &#34;&#34;&#34; Spacefilling script: fill space with a block &#34;&#34;&#34;
    name = &#34;LammpsSpacefilling&#34;
    SECTIONS = [&#34;SPACEFILLING&#34;]
    position = 1
    role = &#34;fill space with fillingbeadtype atoms&#34;
    description = &#39;fill the whole space (region &#34;filledspace&#34;) with default atoms (beadtype)&#39;
    userid = &#34;spacefilling&#34;              # user name
    version = 0.1                        # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
             fillingunits = &#34;${fillingunits}&#34;,
             fillingwidth = &#34;${fillingwidth}&#34;,
            fillingheight = &#34;${fillingheight}&#34;,
             fillingdepth = &#34;${fillingdepth}&#34;,
               fillingxlo = &#34;-${fillingwidth}/2&#34;,
               fillingxhi = &#34;${fillingwidth}/2&#34;,
               fillingylo = &#34;-${fillingheight}/2&#34;,
               fillingyhi = &#34;${fillingheight}/2&#34;,
               fillingzlo = &#34;-${fillingdepth}/2&#34;,
               fillingzhi = &#34;${fillingdepth}/2&#34;,
          fillingbeadtype = &#34;${fillingbeadtype}&#34;,
             fillingstyle = &#34;${block}&#34;,
             hasvariables = False
                    )

    # Template
    TEMPLATE = &#34;&#34;&#34;
region filledspace ${fillingstyle} ${fillingxlo} ${fillingxhi} ${fillingylo} ${fillingyhi} ${fillingzlo} ${fillingzhi}
create_atoms ${fillingbeadtype} region filledspace
# ------------------------------------------
&#34;&#34;&#34;

class LammpsFooter(LammpsGeneric):
    &#34;&#34;&#34; generic header for pizza.region &#34;&#34;&#34;
    name = &#34;LammpsFooter&#34;
    SECTIONS = [&#34;FOOTER&#34;]
    position = 1000
    role = &#34;footer for live view&#34;
    description = &#34;To be used with https://editor.lammps.org/&#34;
    userid = &#34;footer&#34;              # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
                      run = 1,
             hasvariables = False
                    )

    # Template
    TEMPLATE = &#34;&#34;&#34;
# --------------[  DYNAMICS  ]--------------
${mass}
velocity            all create 1.44 87287 loop geom
pair_style          lj/cut 2.5
${pair_coeff}
neighbor            0.3 bin
neigh_modify    delay 0 every 20 check no
fix                     1 all nve
run                     ${run}
# ------------------------------------------
&#34;&#34;&#34;

class coregeometry:
    &#34;&#34;&#34;
        core geometry object
        (helper class for attributes, side,units, move, rotate, open)

        SECTIONS store scripts (variables, region and create for the geometry)
        USER = common USER definitions for the three scripts
        VARIABLES = variables definitions (used by variables only)
        update() propagate USER to the three scripts
        script returns SECTIONS as a pipescript
        do() generate the script

        Parameters to be used along scriptobject()
                 style
            forcefield
                 group
        They are stored SCRIPTOBJECT_USER

    &#34;&#34;&#34;

    _version = &#34;0.35&#34;
    __custom_documentations__ = &#34;pizza.region.coregeometry class&#34;


    def __init__(self,USER=regiondata(),VARIABLES=regiondata(),
                 hasgroup=False, hasmove=False, spacefilling=False,
                 style=&#34;smd&#34;,
                 forcefield=rigidwall(),
                 group=[],
                 mass=1, density=1,
                 lattice_style=&#34;sc&#34;, lattice_scale=1, lattice_scale_siunits=1 # added on 2024-07-05
                 ):
        &#34;&#34;&#34;
            constructor of the generic core geometry
                USER: any definitions requires by the geometry
           VARIABLES: variables used to define the geometry (to be used in LAMMPS)
           hasgroup, hasmove: flag to force the sections group and move
           SECTIONS: they must be PIZZA.script

           The flag spacefilling is true of the container of objects (class region) is filled with beads
        &#34;&#34;&#34;
        self.USER = USER
        self.SECTIONS = {
            &#39;variables&#39;: LammpsVariables(VARIABLES,**USER),
               &#39;region&#39;: LammpsRegion(**USER),
               &#39;create&#39;: LammpsCreate(**USER),
                &#39;group&#39;: LammpsGroup(**USER),
             &#39;setgroup&#39;: LammpsSetGroup(**USER),
                 &#39;move&#39;: LammpsMove(**USER)
            }
        self.FLAGSECTIONS = {
            &#39;variables&#39;: True,
               &#39;region&#39;: True,
               &#39;create&#39;: not spacefilling,
                &#39;group&#39;: hasgroup,
             &#39;setgroup&#39;: spacefilling,
                 &#39;move&#39;: hasmove
            }
        self.spacefilling = spacefilling

        # add comptaibility with scriptobjects
        self.SCRIPTOBJECT_USER = {
                 &#39;style&#39;: style,
            &#39;forcefield&#39;: forcefield,
                 &#39;group&#39;: group
            }
        # collect information from parent region
        self.mass = mass
        self.density = density
        self.lattice_style = lattice_style
        self.lattice_scale = lattice_scale
        self.lattice_scale_siunits = lattice_scale_siunits

    def update(self):
        &#34;&#34;&#34; update the USER content for all three scripts &#34;&#34;&#34;
        if isinstance(self.SECTIONS[&#34;variables&#34;],script):
            self.SECTIONS[&#34;variables&#34;].USER += self.USER
        if isinstance(self.SECTIONS[&#34;region&#34;],script):
            self.SECTIONS[&#34;region&#34;].USER += self.USER
        if isinstance(self.SECTIONS[&#34;create&#34;],script):
            self.SECTIONS[&#34;create&#34;].USER += self.USER
        if isinstance(self.SECTIONS[&#34;group&#34;],script):
            self.SECTIONS[&#34;group&#34;].USER += self.USER
        if isinstance(self.SECTIONS[&#34;setgroup&#34;],script):
            self.SECTIONS[&#34;setgroup&#34;].USER += self.USER
        if isinstance(self.SECTIONS[&#34;move&#34;],script):
            self.SECTIONS[&#34;move&#34;].USER += self.USER


    def copy(self,beadtype=None,name=&#34;&#34;):
        &#34;&#34;&#34; returns a copy of the graphical object &#34;&#34;&#34;
        if self.alike != &#34;mixed&#34;:
            dup = deepduplicate(self)
            if beadtype != None: # update beadtype
                dup.beadtype = beadtype
            if name != &#34;&#34;: # update name
                dup.name = name
            return dup
        else:
            raise ValueError(&#34;collections cannot be copied, regenerate the collection instead&#34;)


    def creategroup(self):
        &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
        self.FLAGSECTIONS[&#34;group&#34;] = True

    def setgroup(self):
        &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
        self.FLAGSECTIONS[&#34;setgroup&#34;] = True

    def createmove(self):
        &#34;&#34;&#34;  force the fix move creation in script &#34;&#34;&#34;
        self.FLAGSECTIONS[&#34;move&#34;] = True

    def removegroup(self):
        &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
        self.FLAGSECTIONS[&#34;group&#34;] = False

    def removemove(self):
        &#34;&#34;&#34;  force the fix move creation in script &#34;&#34;&#34;
        self.FLAGSECTIONS[&#34;move&#34;] = False

    def scriptobject(self, beadtype=None, name=None, fullname=None, group=None, style=None, forcefield=None, USER = scriptdata()):
        &#34;&#34;&#34;
        Method to return a scriptobject based on region instead of an input file
        Syntax similar to script.scriptobject
        OBJ = scriptobject(...)
        Implemented properties:
            beadtype=1,2,...
            name=&#34;short name&#34;
            fullname = &#34;comprehensive name&#34;
            style = &#34;smd&#34;
            forcefield = any valid forcefield instance (default = rigidwall())
        &#34;&#34;&#34;
        # Set defaults using instance attributes if parameters are None
        if beadtype is None:
            beadtype = self.beadtype
        if name is None:
            name = f&#34;{self.name} bead&#34;
        if fullname is None:
            fullname = f&#34;beads of type {self.beadtype} | object {self.name} of kind region.{self.kind}&#34;
        if group is None:
            group = self.SCRIPTOBJECT_USER[&#34;group&#34;]
        if style is None:
            style = self.SCRIPTOBJECT_USER[&#34;style&#34;]
        if forcefield is None:
            style = self.SCRIPTOBJECT_USER[&#34;forcefield&#34;]
        return scriptobject(
            beadtype=beadtype,
            name=name,
            fullname=fullname,
            style=style,
            group=group,
            filename=None,  # No need for a file
            USER = USER
        )

    @property
    def hasvariables(self):
        &#34;&#34;&#34; return the flag VARIABLES &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;variables&#34;],script) \
               and self.FLAGSECTIONS[&#34;variables&#34;]

    @property
    def hasregion(self):
        &#34;&#34;&#34; return the flag REGION &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;region&#34;],script) \
               and self.FLAGSECTIONS[&#34;region&#34;]

    @property
    def hascreate(self):
        &#34;&#34;&#34; return the flag CREATE &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;create&#34;],script) \
               and self.FLAGSECTIONS[&#34;create&#34;] \
               and (not self.spacefilling)

    @property
    def hasgroup(self):
        &#34;&#34;&#34; return the flag GROUP &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;group&#34;],script) \
               and self.FLAGSECTIONS[&#34;group&#34;]

    @property
    def hassetgroup(self):
        &#34;&#34;&#34; return the flag GROUP &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;setgroup&#34;],script) \
               and self.FLAGSECTIONS[&#34;setgroup&#34;] \
               and self.hasgroup \
               and (not self.hascreate)

    @property
    def hasmove(self):
        &#34;&#34;&#34; return the flag MOVE &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;move&#34;],script) \
               and self.FLAGSECTIONS[&#34;move&#34;]

    @property
    def isspacefilled(self):
        &#34;&#34;&#34; return the flag spacefilling &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;spacefilling&#34;],script) \
               and self.FLAGSECTIONS[&#34;spacefilling&#34;]

    @property
    def flags(self):
        &#34;&#34;&#34; return a list of all flags that are currently set &#34;&#34;&#34;
        flag_names = list(self.SECTIONS.keys())
        return [flag for flag in flag_names if getattr(self, f&#34;has{flag}&#34;)]

    @property
    def shortflags(self):
        &#34;&#34;&#34; return a string made from the first letter of each set flag &#34;&#34;&#34;
        return &#34;&#34;.join([flag[0] for flag in self.flags])


    @property
    def VARIABLES(self):
        &#34;&#34;&#34; return variables &#34;&#34;&#34;
        if isinstance(self.SECTIONS[&#34;variables&#34;],script):
            return self.SECTIONS[&#34;variables&#34;].VARIABLES
        else:
            v = regiondata()
            for i in range(len(self.SECTIONS[&#34;variables&#34;].scripts)):
                v = v + self.SECTIONS[&#34;variables&#34;].scripts[i].VARIABLES
            return v

    @property
    def script(self):
        &#34;&#34;&#34; generates a pipe script from sections &#34;&#34;&#34;
        self.update()
        ptmp = self.SECTIONS[&#34;variables&#34;] if self.hasvariables else None
        if self.hasregion:
            ptmp = self.SECTIONS[&#34;region&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;region&#34;]
        if self.hascreate:
            ptmp = self.SECTIONS[&#34;create&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;create&#34;]
        if self.hasgroup:
            ptmp = self.SECTIONS[&#34;group&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;group&#34;]
        if self.hassetgroup:
            ptmp = self.SECTIONS[&#34;setgroup&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;setgroup&#34;]
        if self.hasmove:
            ptmp = self.SECTIONS[&#34;move&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;move&#34;]
        return ptmp
        # before 2023-07-17
        #return self.SECTIONS[&#34;variables&#34;] | self.SECTIONS[&#34;region&#34;] | self.SECTIONS[&#34;create&#34;]

    def do(self,printflag=False,verbosity=1):
        &#34;&#34;&#34; generates a script &#34;&#34;&#34;
        p = self.script # intentional, force script before do(), comment added on 2023-07-17
        cmd = p.do(printflag=printflag,verbosity=verbosity)
        # if printflag: print(cmd)
        return cmd

    def __repr__(self):
        &#34;&#34;&#34; display method&#34;&#34;&#34;
        nVAR = len(self.VARIABLES)
        print(&#34;%s - %s object - beadtype=%d &#34; % (self.name, self.kind,self.beadtype))
        if hasattr(self,&#34;filename&#34;): print(f&#39;\tfilename: &#34;{self.filename}&#34;&#39;)
        if nVAR&gt;0:
            print(f&#34;\t&lt;-- {nVAR} variables are defined --&gt;&#34;)
            print(f&#34;\tUse {self.name}.VARIABLES to see details and their evaluation&#34;)
            for k,v in self.VARIABLES.items():
                v0 = &#39;&#34;&#39;+v+&#39;&#34;&#39; if isinstance(v,str) else repr(v)
                print(wrap(k,&#34;=&#34;,v0,20,40,80))
        print(&#34;\t&lt;-- keyword arg --&gt;&#34;)
        haskeys = False
        for k in (&#34;side&#34;,&#34;move&#34;,&#34;units&#34;,&#34;rotate&#34;,&#34;open&#34;):
            if k in self.USER:
                v = self.USER.getattr(k)
                if v != &#34;&#34;:
                    print(wrap(k,&#34;:&#34;,v[1:],20,60,80))
                    haskeys = True
        if not haskeys: print(wrap(&#34;no keywords&#34;,&#34;&lt;&#34;,&#34;from side|move|units|rotate|open&#34;,20,60,80))
        flags = self.flags
        if flags: print(f&#39;defined scripts: {span(flags,sep=&#34;,&#34;)}&#39;,&#34;\n&#34;)
        print(&#34;\n&#34;+self.geometry) # added 2024-07-05
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind,self.name,self.beadtype)


    # ~~~~ validator for region arguments (the implementation is specific and not generic as fix move ones)
    def sidearg(self,side):
        &#34;&#34;&#34;
            Validation of side arguments for region command (https://docs.lammps.org/region.html)
            side value = in or out
              in = the region is inside the specified geometry
              out = the region is outside the specified geometry
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if side is None:
            return &#34;&#34;
        elif isinstance(side, str):
            side = side.lower()
            if side in (&#34;in&#34;,&#34;out&#34;):
                return f&#34;{prefix} side {side}&#34;
            elif side in (&#34;&#34;,&#34;none&#34;):
                return &#34;&#34;
            else:
                raise ValueError(f&#39;the value of side: &#34;{side}&#34; is not recognized&#39;)
        else:
            raise ValueError(&#39;the parameter side can be &#34;in|out|None&#34;&#39;)

    def movearg(self,move):
        &#34;&#34;&#34;
            Validation of move arguments for region command (https://docs.lammps.org/region.html)
            move args = v_x v_y v_z
              v_x,v_y,v_z = equal-style variables for x,y,z displacement of region over time (distance units)
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if move is None:
            return &#34;&#34;
        elif isinstance(move, str):
            move = move.lower()
            if move in(&#34;&#34;,&#34;none&#34;):
                return &#34;&#34;
            else:
                return f&#34;{prefix} move {move}&#34;
        elif isinstance(move,(list,tuple)):
            if len(move)&lt;3:
                print(&#34;NULL will be added to move&#34;)
            elif len(move)&gt;3:
                print(&#34;move will be truncated to 3 elements&#34;)
            movevalid = [&#34;NULL&#34;,&#34;NULL&#34;,&#34;NULL&#34;]
            for i in range(min(3,len(move))):
                if isinstance(move[i],str):
                    if move[i].upper()!=&#34;NULL&#34;:
                        if prefix in move[i]:
                            # we assume a numeric result after evaluation
                            # Pizza variables will be evaluated
                            # formateval for the evaluation of ${}
                            # eval for residual expressions
                            movevalid[i] = round(eval(self.VARIABLES.formateval(move[i])),6)
                        else:
                            # we assume a variable (LAMMPS variable, not Pizza ones)
                            movevalid[i] = &#34;v_&#34; + move[i]
                elif not isinstance(move[i],(int,float)):
                    if (move[i] is not None):
                        raise TypeError(&#34;move values should be str, int or float&#34;)
            return f&#34;{prefix} move {span(movevalid)}&#34;
        else:
            raise TypeError(&#34;the parameter move should be a list or tuple&#34;)

    def unitsarg(self,units):
        &#34;&#34;&#34;
            Validation for units arguments for region command (https://docs.lammps.org/region.html)
            units value = lattice or box
              lattice = the geometry is defined in lattice units
              box = the geometry is defined in simulation box units
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if units is None:
            return &#34;&#34;
        elif isinstance(units,str):
            units = units.lower()
            if units in (&#34;lattice&#34;,&#34;box&#34;):
                return f&#34;{prefix} units {units}&#34;
            elif (units==&#34;&#34;) or (units==&#34;none&#34;):
                return &#34;&#34;
            else:
                raise ValueError(f&#39;the value of side: &#34;{units}&#34; is not recognized&#39;)
        else:
            raise TypeError(&#39;the parameter units can be &#34;lattice|box|None&#34;&#39;)

    def rotatearg(self,rotate):
        &#34;&#34;&#34;
            Validation of rotate arguments for region command (https://docs.lammps.org/region.html)
            rotate args = v_theta Px Py Pz Rx Ry Rz
              v_theta = equal-style variable for rotaton of region over time (in radians)
              Px,Py,Pz = origin for axis of rotation (distance units)
              Rx,Ry,Rz = axis of rotation vector
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if rotate is None:
            return &#34;&#34;
        elif isinstance(rotate, str):
            rotate = rotate.lower()
            if rotate in (&#34;&#34;,&#34;none&#34;,None):
                return &#34;&#34;
            else:
                return f&#34;{prefix} rotate {rotate}&#34;
        elif isinstance(rotate,(list,tuple)):
            if len(rotate)&lt;7:
                print(&#34;NULL will be added to rotate&#34;)
            elif len(rotate)&gt;7:
                print(&#34;rotate will be truncated to 7 elements&#34;)
            rotatevalid = [&#34;NULL&#34;]*7
            for i in range(min(7,len(rotate))):
                if isinstance(rotate[i],str):
                    if rotate[i].upper()!=&#34;NULL&#34;:
                        if prefix in rotate[i]:
                            rotatevalid[i] = round(eval(self.VARIABLES.formateval(rotate[i])),6)
                        else:
                            rotatevalid[i] = rotate[i]
                elif not isinstance(rotate[i],(int,float)):
                    if (rotate[i] is not None):
                        raise TypeError(&#34;rotate values should be str, int or float&#34;)
            return f&#34;{prefix} move {span(rotatevalid)}&#34;
        else:
            raise TypeError(&#34;the parameter rotate should be a list or tuple&#34;)

    def openarg(self,open):
        &#34;&#34;&#34;
            Validation of open arguments for region command (https://docs.lammps.org/region.html)
            open value = integer from 1-6 corresponding to face index (see below)
            The indices specified as part of the open keyword have the following meanings:

            For style block, indices 1-6 correspond to the xlo, xhi, ylo, yhi, zlo, zhi surfaces of the block.
            I.e. 1 is the yz plane at x = xlo, 2 is the yz-plane at x = xhi, 3 is the xz plane at y = ylo,
            4 is the xz plane at y = yhi, 5 is the xy plane at z = zlo, 6 is the xy plane at z = zhi).
            In the second-to-last example above, the region is a box open at both xy planes.

            For style prism, values 1-6 have the same mapping as for style block.
            I.e. in an untilted prism, open indices correspond to the xlo, xhi, ylo, yhi, zlo, zhi surfaces.

            For style cylinder, index 1 corresponds to the flat end cap at the low coordinate along the cylinder axis,
            index 2 corresponds to the high-coordinate flat end cap along the cylinder axis, and index 3 is the curved
            cylinder surface. For example, a cylinder region with open 1 open 2 keywords will be open at both ends
            (e.g. a section of pipe), regardless of the cylinder orientation.
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if open in (&#34;&#34;,&#34;none&#34;,None):
            return &#34;&#34;
        elif isinstance(open, str):
            raise TypeError(&#34; the parameter open should be an integer or a list/tuple of integers from 1-6&#34;)
        elif isinstance(open, int):
            if open in range(1,7):
                return f&#34;{prefix} open {open}&#34;
            else:
                raise TypeError(&#34; open value should be integer from 1-6&#34;)
        elif isinstance(open, (list,tuple)):
            openvalid = [f&#34;{prefix} open {i}&#34; for i in range(1,7) if i in open]
            return f&#34;$ {span(openvalid)}&#34;
    # ~~~~ end validator for region arguments

    # ~~~~ validator for fix move arguments (implemented generically on 2023-07-17)
    def fixmoveargvalidator(self, argtype, arg, arglen):
        &#34;&#34;&#34;
            Validation of arguments for fix move command in LAMMPS (https://docs.lammps.org/fix_move.html)

            LAMMPS syntax:
                fix ID group-ID move style args
                - linear args = Vx Vy Vz
                - wiggle args = Ax Ay Az period
                - rotate args = Px Py Pz Rx Ry Rz period
                - transrot args = Vx Vy Vz Px Py Pz Rx Ry Rz period
                - variable args = v_dx v_dy v_dz v_vx v_vy v_vz

            Args:
                argtype: Type of the argument (linear, wiggle, rotate, transrot, variable)
                arg: The argument to validate
                arglen: Expected length of the argument
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if arg in (&#34;&#34;,&#34;none&#34;,None):
            return &#34;&#34;
        elif isinstance(arg,(list,tuple)):
            if len(arg) &lt; arglen:
                print(f&#34;NULL will be added to {argtype}&#34;)
            elif len(arg) &gt; arglen:
                print(f&#34;{argtype} will be truncated to {arglen} elements&#34;)
            argvalid = [&#34;NULL&#34;]*arglen
            for i in range(min(arglen,len(arg))):
                if isinstance(arg[i],str):
                    if arg[i].upper()!=&#34;NULL&#34;:
                        if prefix in arg[i]:
                            argvalid[i] = round(eval(self.VARIABLES.formateval(arg[i])),6)
                        else:
                            argvalid[i] = arg[i]
                elif not isinstance(arg[i],(int,float)):
                    if (arg[i] is not None):
                        raise TypeError(f&#34;{argtype} values should be str, int or float&#34;)
            return f&#34;{prefix} move {span(argvalid)}&#34;
        else:
            raise TypeError(f&#34;the parameter {argtype} should be a list or tuple&#34;)


    def fixmoveargs(self, linear=None, wiggle=None, rotate=None, transrot=None, variable=None):
        &#34;&#34;&#34;
            Validates all arguments for fix move command in LAMMPS (https://docs.lammps.org/fix_move.html)
            the result is adictionary, all fixmove can be combined
        &#34;&#34;&#34;
        argsdict = {
            &#34;linear&#34;: [linear, 3],
            &#34;wiggle&#34;: [wiggle, 4],
            &#34;rotate&#34;: [rotate, 7],
            &#34;transrot&#34;: [transrot, 10],
            &#34;variable&#34;: [variable, 6]
        }

        for argtype, arginfo in argsdict.items():
            arg, arglen = arginfo
            if arg is not None:
                argsdict[argtype] = self.fixmoveargvalidator(argtype, arg, arglen)
        return argsdict


    def get_fixmovesyntax(self, argtype=None):
        &#34;&#34;&#34;
        Returns the syntax for LAMMPS command, or detailed explanation for a specific argument type

        Args:
        argtype: Optional; Type of the argument (linear, wiggle, rotate, transrot, variable)
        &#34;&#34;&#34;
        syntax = {
            &#34;linear&#34;: &#34;linear args = Vx Vy Vz\n&#34;
                      &#34;Vx,Vy,Vz = components of velocity vector (velocity units), any component can be specified as NULL&#34;,
            &#34;wiggle&#34;: &#34;wiggle args = Ax Ay Az period\n&#34;
                       &#34;Ax,Ay,Az = components of amplitude vector (distance units), any component can be specified as NULL\n&#34;
                       &#34;period = period of oscillation (time units)&#34;,
            &#34;rotate&#34;: &#34;rotate args = Px Py Pz Rx Ry Rz period\n&#34;
                       &#34;Px,Py,Pz = origin point of axis of rotation (distance units)\n&#34;
                       &#34;Rx,Ry,Rz = axis of rotation vector\n&#34;
                       &#34;period = period of rotation (time units)&#34;,
            &#34;transrot&#34;: &#34;transrot args = Vx Vy Vz Px Py Pz Rx Ry Rz period\n&#34;
                        &#34;Vx,Vy,Vz = components of velocity vector (velocity units)\n&#34;
                        &#34;Px,Py,Pz = origin point of axis of rotation (distance units)\n&#34;
                        &#34;Rx,Ry,Rz = axis of rotation vector\n&#34;
                        &#34;period = period of rotation (time units)&#34;,
            &#34;variable&#34;: &#34;variable args = v_dx v_dy v_dz v_vx v_vy v_vz\n&#34;
                        &#34;v_dx,v_dy,v_dz = 3 variable names that calculate x,y,z displacement as function of time, any component can be specified as NULL\n&#34;
                        &#34;v_vx,v_vy,v_vz = 3 variable names that calculate x,y,z velocity as function of time, any component can be specified as NULL&#34;,
        }

        base_syntax = (
            &#34;fix ID group-ID move style args\n&#34;
            &#34; - linear args = Vx Vy Vz\n&#34;
            &#34; - wiggle args = Ax Ay Az period\n&#34;
            &#34; - rotate args = Px Py Pz Rx Ry Rz period\n&#34;
            &#34; - transrot args = Vx Vy Vz Px Py Pz Rx Ry Rz period\n&#34;
            &#34; - variable args = v_dx v_dy v_dz v_vx v_vy v_vz\n\n&#34;
            &#39;use get_movesyntax(&#34;movemethod&#34;) for details&#39;
            &#34;manual: https://docs.lammps.org/fix_move.html&#34;
        )

        return syntax.get(argtype, base_syntax)

    # ~~~~ end validator for fix move arguments

    def __add__(self,C):
        &#34;&#34;&#34; overload addition (&#34;+&#34;) operator &#34;&#34;&#34;
        if isinstance(C,coregeometry):
            dup = deepduplicate(self)
            dup.name = cleanname(self.name) +&#34;+&#34;+ cleanname(C.name)
            dup.USER = dup.USER + C.USER
            dup.USER.ID = &#34;$&#34; + cleanname(self.USER.ID) +&#34;+&#34;+ cleanname(C.USER.ID)
            dup.SECTIONS[&#34;variables&#34;] = dup.SECTIONS[&#34;variables&#34;] + C.SECTIONS[&#34;variables&#34;]
            dup.SECTIONS[&#34;region&#34;] = dup.SECTIONS[&#34;region&#34;] + C.SECTIONS[&#34;region&#34;]
            dup.SECTIONS[&#34;create&#34;] = dup.SECTIONS[&#34;create&#34;] + C.SECTIONS[&#34;create&#34;]
            dup.SECTIONS[&#34;group&#34;] = dup.SECTIONS[&#34;group&#34;] + C.SECTIONS[&#34;group&#34;]
            dup.SECTIONS[&#34;move&#34;] = dup.SECTIONS[&#34;move&#34;] + C.SECTIONS[&#34;move&#34;]
            dup.FLAGSECTIONS[&#34;variables&#34;] = dup.FLAGSECTIONS[&#34;variables&#34;] or C.FLAGSECTIONS[&#34;variables&#34;]
            dup.FLAGSECTIONS[&#34;region&#34;] = dup.FLAGSECTIONS[&#34;region&#34;] or C.FLAGSECTIONS[&#34;region&#34;]
            dup.FLAGSECTIONS[&#34;create&#34;] = dup.FLAGSECTIONS[&#34;create&#34;] or C.FLAGSECTIONS[&#34;create&#34;]
            dup.FLAGSECTIONS[&#34;group&#34;] = dup.FLAGSECTIONS[&#34;group&#34;] or C.FLAGSECTIONS[&#34;group&#34;]
            dup.FLAGSECTIONS[&#34;move&#34;] = dup.FLAGSECTIONS[&#34;move&#34;] or C.FLAGSECTIONS[&#34;move&#34;]
            return dup
        raise TypeError(&#34;the second operand must a region.coregeometry object&#34;)

    def __iadd__(self,C):
        &#34;&#34;&#34; overload iaddition (&#34;+=&#34;) operator &#34;&#34;&#34;
        if isinstance(C,coregeometry):
            self.USER += C.USER
            self.SECTIONS[&#34;variables&#34;] += C.SECTIONS[&#34;variables&#34;]
            self.SECTIONS[&#34;region&#34;] += C.SECTIONS[&#34;region&#34;]
            self.SECTIONS[&#34;create&#34;] += C.SECTIONS[&#34;create&#34;]
            self.SECTIONS[&#34;group&#34;] += C.SECTIONS[&#34;group&#34;]
            self.SECTIONS[&#34;move&#34;] += C.SECTIONS[&#34;move&#34;]
            self.FLAGSECTIONS[&#34;variables&#34;] = self.FLAGSECTIONS[&#34;variables&#34;] or C.FLAGSECTIONS[&#34;variables&#34;]
            self.FLAGSECTIONS[&#34;region&#34;] = self.FLAGSECTIONS[&#34;region&#34;] or C.FLAGSECTIONS[&#34;region&#34;]
            self.FLAGSECTIONS[&#34;create&#34;] = self.FLAGSECTIONS[&#34;create&#34;] or C.FLAGSECTIONS[&#34;create&#34;]
            self.FLAGSECTIONS[&#34;group&#34;] = self.FLAGSECTIONS[&#34;group&#34;] or C.FLAGSECTIONS[&#34;group&#34;]
            self.FLAGSECTIONS[&#34;move&#34;] = self.FLAGSECTIONS[&#34;move&#34;] or C.FLAGSECTIONS[&#34;move&#34;]
            return self
        raise TypeError(&#34;the operand must a region.coregeometry object&#34;)

    def __or__(self,C):
        &#34;&#34;&#34; overload | pipe &#34;&#34;&#34;
        if isinstance(C,coregeometry):
            dup = deepduplicate(self)
            dup.name = cleanname(self.name) +&#34;|&#34;+ cleanname(C.name)
            dup.USER = dup.USER + C.USER
            dup.USER.ID = &#34;$&#34; + cleanname(self.USER.ID) +&#34;|&#34;+ cleanname(C.USER.ID)
            dup.SECTIONS[&#34;variables&#34;] = dup.SECTIONS[&#34;variables&#34;] | C.SECTIONS[&#34;variables&#34;]
            dup.SECTIONS[&#34;region&#34;] = dup.SECTIONS[&#34;region&#34;] | C.SECTIONS[&#34;region&#34;]
            dup.SECTIONS[&#34;create&#34;] = dup.SECTIONS[&#34;create&#34;] | C.SECTIONS[&#34;create&#34;]
            dup.SECTIONS[&#34;group&#34;] = dup.SECTIONS[&#34;group&#34;] | C.SECTIONS[&#34;group&#34;]
            dup.SECTIONS[&#34;move&#34;] = dup.SECTIONS[&#34;move&#34;] | C.SECTIONS[&#34;move&#34;]
            self.FLAGSECTIONS[&#34;variables&#34;] = self.FLAGSECTIONS[&#34;variables&#34;] or C.FLAGSECTIONS[&#34;variables&#34;]
            self.FLAGSECTIONS[&#34;region&#34;] = self.FLAGSECTIONS[&#34;region&#34;] or C.FLAGSECTIONS[&#34;region&#34;]
            self.FLAGSECTIONS[&#34;create&#34;] = self.FLAGSECTIONS[&#34;create&#34;] or C.FLAGSECTIONS[&#34;create&#34;]
            self.FLAGSECTIONS[&#34;group&#34;] = self.FLAGSECTIONS[&#34;group&#34;] or C.FLAGSECTIONS[&#34;group&#34;]
            self.FLAGSECTIONS[&#34;move&#34;] = self.FLAGSECTIONS[&#34;move&#34;] or C.FLAGSECTIONS[&#34;move&#34;]
            return dup
        raise TypeError(&#34;the second operand must a region.coregeometry object&#34;)

    # copy and deep copy methods for the class (required)
    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo)) # replace duplicatedeep by deepduplicate (OV: 2023-07-28)
        return copie

    # Return the number of atoms
    @property
    def natoms(self):
        &#34;&#34;&#34;Calculate the number of beads based on density, mass, and volume&#34;&#34;&#34;
        if hasattr(self, &#39;volume&#39;):
            try:
                volume_siunits = self.volume(&#34;si&#34;)
                voxel_volume_siunits = self.lattice_scale**3
                number_of_beads = volume_siunits / voxel_volume_siunits
                packing_factors = {
                    &#39;sc&#39;: 1.0,
                    &#39;fcc&#39;: 4.0,
                    &#39;bcc&#39;: 2.0,
                    &#39;hcp&#39;: 6.0,  # Approximate value, requires specific volume calculation for accuracy
                    &#39;dia&#39;: 8.0,
                    &#39;bco&#39;: 2.0,  # Assuming orthorhombic lattice similar to bcc
                    &#39;fco&#39;: 4.0,  # Assuming orthorhombic lattice similar to fcc
                }
                packing_factor = packing_factors.get(self.lattice_style, 1.0)  # Default to simple cubic if unknown
                number_of_beads *= packing_factor
                return round(number_of_beads)
            except Exception as e:
                print(f&#34;Error calculating number of beads: {e}&#34;)
                return None
        else:
            print(&#34;Volume attribute is missing.&#34;)
            return None

    # return parent region details
    @property
    def regiondetails(self):
        return &#34;\n&#34;.join((
        f&#34;\n--- | Region Details | ---&#34;,
        f&#34;Name: {self.name}&#34;,
        f&#34;Lattice Style: {self.lattice_style}&#34;,
        f&#34;Lattice Scale: {self.lattice_scale}&#34;,
        f&#34;Lattice Scale (SI units): {self.lattice_scale_siunits}&#34;,
        f&#34;Volume: {self.volume()}&#34;,
        f&#34;Volume (SI units): {self.volume(&#39;si&#39;)}&#34;,
        f&#34;Number of Atoms: {self.natoms}&#34;,&#34;\n&#34;
        ))


    # return geometry details (2024-07-04)
    @property
    def geometry(self):
        &#34;&#34;&#34;Return the geometry details of the object.&#34;&#34;&#34;
        details = self.regiondetails
        details += &#34;\n--- | Geometry Details | ---\n&#34;
        if hasattr(self.USER, &#39;geometry&#39;):
            details += self.USER.geometry
        else:
            details = &#34;No geometry available.\n&#34;
        return details


class Block(coregeometry):
    &#34;&#34;&#34; Block class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;block%03d&#34; % counter[1]
        self.kind = &#34;block&#34;     # kind of object
        self.alike = &#34;block&#34;    # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density

        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$block&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        &#34;&#34;&#34;Calculate the volume of the block based on USER.args&#34;&#34;&#34;
        #args = [xlo, xhi, ylo, yhi, zlo, zhi]
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            xlo = float(args[0])
            xhi = float(args[1])
            ylo = float(args[2])
            yhi = float(args[3])
            zlo = float(args[4])
            zhi = float(args[5])

            # Calculate the dimensions of the block
            length = xhi - xlo
            width = yhi - ylo
            height = zhi - zlo

            # Calculate the volume of the block
            volume = length * width * height
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None


class Cone(coregeometry):
    &#34;&#34;&#34; Cone class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;cone%03d&#34; % counter[1]
        self.kind = &#34;cone&#34;     # kind of object
        self.alike = &#34;cone&#34;    # similar object for plotting
        self.beadtype = 1      # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$cone&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        &#34;&#34;&#34;Calculate the volume of the cone based on USER.args&#34;&#34;&#34;
        #args = [dim, c1, c2, radlo, radhi, lo, hi]
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            radius_low = float(args[3])
            radius_high = float(args[4])
            lo = float(args[5])
            hi = float(args[6])
            # Calculate the height of the cone
            height = hi - lo
            # Calculate the volume of the cone (assuming a conical frustum if radii are different)
            if radius_low == radius_high:
                volume = (1/3) * 3.141592653589793 * (radius_low ** 2) * height
            else:
                volume = (1/3) * 3.141592653589793 * height * (radius_low ** 2 + radius_low * radius_high + radius_high ** 2)
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None


class Cylinder(coregeometry):
    &#34;&#34;&#34; Cylinder class &#34;&#34;&#34;
    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;cylinder%03d&#34; % counter[1]
        self.kind = &#34;cylinder&#34;     # kind of object
        self.alike = &#34;cylinder&#34;    # similar object for plotting
        self.beadtype = 1          # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$cylinder&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        &#34;&#34;&#34;Calculate the volume of the cylinder based on USER.args&#34;&#34;&#34;
        # args = [dim,c1,c2,radius,lo,hi]
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            radius = float(args[3])
            lo = float(args[4])
            hi = float(args[5])
            # Calculate the height of the cylinder
            height = hi - lo
            # Calculate the volume of the cylinder
            volume = 3.141592653589793 * (radius ** 2) * height
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None

class Ellipsoid(coregeometry):
    &#34;&#34;&#34; Ellipsoid class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;ellipsoid%03d&#34; % counter[1]
        self.kind = &#34;ellipsoid&#34;     # kind of object
        self.alike = &#34;ellipsoid&#34;    # similar object for plotting
        self.beadtype = 1           # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$ellipsoid&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        #args = [x, y, z, a, b, c]
        &#34;&#34;&#34;Calculate the volume of the ellipsoid based on USER.args&#34;&#34;&#34;
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            a = float(args[3])
            b = float(args[4])
            c = float(args[5])
            # Calculate the volume of the ellipsoid
            volume = (4/3) * 3.141592653589793 * a * b * c
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None

class Plane(coregeometry):
    &#34;&#34;&#34; Plane class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;plane%03d&#34; % counter[1]
        self.kind = &#34;plane&#34;      # kind of object
        self.alike = &#34;plane&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$plane&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    @property
    def volume(self,units=None):
        &#34;&#34;&#34;Dummy method returning None for volume&#34;&#34;&#34;
        #args = [px, py, pz, nx, ny, nz]
        return None

class Prism(coregeometry):
    &#34;&#34;&#34; Prism class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;prism%03d&#34; % counter[1]
        self.kind = &#34;prism&#34;      # kind of object
        self.alike = &#34;prism&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$prism&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        &#34;&#34;&#34;Calculate the volume of the prism based on USER.args&#34;&#34;&#34;
        #args = [xlo, xhi, ylo, yhi, zlo, zhi, xy, xz, yz]
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            xlo = float(args[0])
            xhi = float(args[1])
            ylo = float(args[2])
            yhi = float(args[3])
            zlo = float(args[4])
            zhi = float(args[5])
            # Calculate the dimensions of the prism
            length = xhi - xlo
            width = yhi - ylo
            height = zhi - zlo
            # Calculate the volume of the prism
            volume = length * width * height
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None

class Sphere(coregeometry):
    &#34;&#34;&#34; Sphere class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;sphere%03d&#34; % counter[1]
        self.kind = &#34;sphere&#34;      # kind of object
        self.alike = &#34;ellipsoid&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$sphere&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        &#34;&#34;&#34;Calculate the volume of the sphere based on USER.args&#34;&#34;&#34;
        #args = [x, y, z, radius]
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            radius = float(args[3])
            # Calculate the volume of the sphere
            volume = (4/3) * 3.141592653589793 * (radius ** 3)
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None

class Union(coregeometry):
    &#34;&#34;&#34; Union class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None,
                 hasgroup=False,hasmove=False,spacefilling=False,**variables):
        self.name = &#34;union%03d&#34; % counter[1]
        self.kind = &#34;union&#34;      # kind of object
        self.alike = &#34;operator&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$union&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling
                )

class Intersect(coregeometry):
    &#34;&#34;&#34; Intersect class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None,
                 hasgroup=False,hasmove=False,spacefilling=False,**variables):
        self.name = &#34;intersect%03d&#34; % counter[1]
        self.kind = &#34;intersect&#34;      # kind of object
        self.alike = &#34;operator&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$intersect&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling
                )

class Evalgeometry(coregeometry):
    &#34;&#34;&#34; generic class to store evaluated objects with region.eval() &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None,
                 hasgroup=False,hasmove=False,spacefilling=False):
        self.name = &#34;eval%03d&#34; % counter[1]
        self.kind = &#34;eval&#34;      # kind of object
        self.alike = &#34;eval&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        super().__init__(hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling)


class Collection:
    &#34;&#34;&#34;
        Collection class (including many objects)
    &#34;&#34;&#34;
    _version = &#34;0.31&#34;
    __custom_documentations__ = &#34;pizza.region.Collection class&#34;

    # CONSTRUCTOR
    def __init__(self,counter,
                 name=None,
                 index = None,
                 subindex = None,
                 hasgroup = False,
                 USER = regiondata()):
        if (name is None) or (name==&#34;&#34;):
            self.name = &#34;collect%03d&#34; % counter[1]
        elif name in self:
            raise KeyError(f&#39;the name &#34;{name}&#34; already exist&#39;)
        else:
            self.name = name
        if not isinstance(USER,regiondata):
            raise TypeError(&#34;USER should be a regiondata object&#34;)
        USER.groupID = &#34;$&#34;+self.name # the content is frozen
        USER.ID = &#34;&#34;
        self.USER = USER
        self.kind = &#34;collection&#34;    # kind of object
        self.alike = &#34;mixed&#34;        # similar object for plotting
        self.index = counter[0] if index is None else index
        self.subindex = counter[1]
        self.collection = regioncollection()
        self.SECTIONS = {
                &#39;group&#39;: LammpsCollectionGroup(**USER)
        }
        self.FLAGSECTIONS = {&#34;group&#34;: hasgroup}

    def update(self):
        &#34;&#34;&#34; update the USER content for the script &#34;&#34;&#34;
        if isinstance(self.SECTIONS[&#34;group&#34;],script):
            self.USER.ID = &#34;$&#34;\
                +span([groupprefix+x for x in self.list()]) # the content is frozen
            self.SECTIONS[&#34;group&#34;].USER += self.USER

    def creategroup(self):
        &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
        for o in self.collection: o.creategroup()
        self.update()
        self.FLAGSECTIONS[&#34;group&#34;] = True

    def removegroup(self,recursive=True):
        &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
        if recursive:
            for o in self.collection: o.removegroup()
        self.FLAGSECTIONS[&#34;group&#34;] = False

    @property
    def hasgroup(self):
        &#34;&#34;&#34; return the flag hasgroup &#34;&#34;&#34;
        return self.FLAGSECTIONS[&#34;group&#34;]

    @property
    def flags(self):
        &#34;&#34;&#34; return a list of all flags that are currently set &#34;&#34;&#34;
        flag_names = list(self.SECTIONS.keys())
        return [flag for flag in flag_names if getattr(self, f&#34;has{flag}&#34;)]

    @property
    def shortflags(self):
        &#34;&#34;&#34; return a string made from the first letter of each set flag &#34;&#34;&#34;
        return &#34;&#34;.join([flag[0] for flag in self.flags])

    @property
    def script(self):
        &#34;&#34;&#34; generates a pipe script from SECTIONS &#34;&#34;&#34;
        self.update()
        return self.SECTIONS[&#34;group&#34;]

    def __repr__(self):
        keylengths = [len(key) for key in self.collection.keys()]
        width = max(10,max(keylengths)+2)
        fmt = &#34;%%%ss:&#34; % width
        line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
        print(line,&#34;  %s - %s object&#34; % (self.name, self.kind), line,sep=&#34;\n&#34;)
        for key,value in self.collection.items():
            flags = &#34;(&#34;+self.collection[key].shortflags+&#34;)&#34; if self.collection[key].flags else &#34;(no script)&#34;
            print(fmt % key,value.kind,
                  &#39;&#34;%s&#34;&#39; % value.name,&#34; &gt; &#34;,flags)
        flags = self.flags
        if flags: print(line,f&#39;defined scripts: {span(flags,sep=&#34;,&#34;)}&#39;,sep=&#34;\n&#34;)
        print(line)
        return &#34;%s object: %s (beadtype=[%s])&#34; % (self.kind,self.name,&#34;, &#34;.join(map(str,self.beadtype)))

    # GET -----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.collection:
            return self.collection.getattr(name)
        elif name in [&#34;collection&#34;,&#34;hasgroup&#34;,&#34;flags&#34;,&#34;shortflags&#34;,&#34;script&#34;]:
            return getattr(self,name)
        else:
            raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # GETATTR --------------------------
    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return self.get(key)

    @property
    def beadtype(self):
        &#34;&#34;&#34; returns the beadtypes used in the collection &#34;&#34;&#34;
        b = []
        for o in self.collection:
            if o.beadtype not in b:
                b.append(o.beadtype)
        if len(b)==0:
            return 1
        else:
            return b

    # GROUP -------------------------------
    def group(self):
        &#34;&#34;&#34; return the grouped coregeometry object &#34;&#34;&#34;
        if len(self) == 0:return pipescript()
        # execute all objects
        for i in range(len(self)): self.collection[i].do()
        # concatenate all objects into a pipe script
        liste = [x.SECTIONS[&#34;variables&#34;] for x in self.collection if x.hasvariables] + \
                [x.SECTIONS[&#34;region&#34;]    for x in self.collection if x.hasregion] + \
                [x.SECTIONS[&#34;create&#34;]    for x in self.collection if x.hascreate] + \
                [x.SECTIONS[&#34;group&#34;]     for x in self.collection if x.hasgroup] + \
                [x.SECTIONS[&#34;setgroup&#34;]  for x in self.collection if x.hassetgroup] + \
                [x.SECTIONS[&#34;move&#34;]      for x in self.collection if x.hasmove]
        return pipescript.join(liste)

    # LEN ---------------------------------
    def __len__(self):
        &#34;&#34;&#34; return length of collection &#34;&#34;&#34;
        return len(self.collection)

    # LIST ---------------------------------
    def list(self):
        &#34;&#34;&#34; return the list of objects &#34;&#34;&#34;
        return self.collection.keys()



# %% region class (main class)
class region:
    &#34;&#34;&#34;
    The `region` class represents a simulation region, centered at the origin (0, 0, 0) by default,
    and is characterized by its physical dimensions, properties, and boundary conditions. It supports
    setting up lattice structures, particle properties, and options for live previews.

    Attributes:
    ----------
    name : str, optional
        Name of the region (default is &#39;region container&#39;).

    dimension : int, optional
        Number of spatial dimensions for the simulation (either 2 or 3, default is 3).

    boundary : list of str or None, optional
        Boundary conditions for each dimension. If None, defaults to [&#34;sm&#34;] * dimension.
        Must be a list of length `dimension`, where &#34;s&#34; indicates shrink-wrapped, and &#34;m&#34; indicates a non-periodic boundary.

    nbeads : int, optional
        Number of beads in the region (default is 1).

    units : str, optional
        Units for the simulation box (default is &#34;&#34;).

    Particle Properties:
    -------------------
    mass : float, optional
        Mass of particles in the region (default is 1).

    volume : float, optional
        Volume of the region (default is 1).

    density : float, optional
        Density of the region (default is 1).

    radius : float, optional
        Radius of the particles (default is 1.5).

    contactradius : float, optional
        Contact radius of the particles (default is 0.5).

    velocities : list of floats, optional
        Initial velocities of particles (default is [0, 0, 0]).

    forces : list of floats, optional
        External forces acting on the particles (default is [0, 0, 0]).

    Other Properties:
    ----------------
    filename : str, optional
        Name of the output file (default is an empty string, which will auto-generate a name based on the region name).

    index : int, optional
        Index or identifier for the region.

    run : int, optional
        Run configuration parameter (default is 1).

    Box Properties:
    ---------------
    center : list of floats, optional
        Center of the simulation box for coordinate scaling (default is [0, 0, 0]).

    width : float, optional
        Width of the region (default is 10).

    height : float, optional
        Height of the region (default is 10).

    depth : float, optional
        Depth of the region (default is 10).

    hasfixmove : bool, optional
        Indicates whether the region has a fixed movement (default is False).

    Spacefilling Design:
    -------------------
    spacefilling : bool, optional
        Indicates whether the design is space-filling (default is False).

    fillingbeadtype : int, optional
        Type of bead used for space filling (default is 1).

    Lattice Properties:
    ------------------
    regionunits : str, optional
        Defines the units of the region. Can be either &#34;lattice&#34; (default) or &#34;si&#34;.

    separationdistance : float, optional
        Separation distance between atoms in SI units (default is 5e-6).

    lattice_scale : float, optional
        Scaling factor for the lattice, used mainly in visualization (default is 0.8442).

    lattice_spacing : list or None, optional
        Specifies the spacing between lattice points. If None, the default spacing is used. Can be a list of [dx, dy, dz].

    lattice_style : str, optional
        Specifies the lattice structure style (default is &#34;fcc&#34;). Accepts any LAMMPS valid style, e.g., &#34;sc&#34; for simple cubic.

    Atom Properties:
    ----------------
    atom_style : str, optional
        Defines the atom style for the region (default is &#34;smd&#34;).

    atom_modify : list of str, optional
        LAMMPS command for atom modification (default is [&#34;map&#34;, &#34;array&#34;]).

    comm_modify : list of str, optional
        LAMMPS command for communication modification (default is [&#34;vel&#34;, &#34;yes&#34;]).

    neigh_modify : list, optional
        LAMMPS command for neighbor list modification (default is [&#34;every&#34;, 10, &#34;delay&#34;, 0, &#34;check&#34;, &#34;yes&#34;]).

    newton : str, optional
        Specifies the Newton flag (default is &#34;off&#34;).

    Live Preview:
    ------------
    live_units : str, optional
        Units for live preview (default is &#34;lj&#34;, for Lennard-Jones units).

    live_atom_style : str, optional
        Atom style used specifically for live LAMMPS sessions (default is &#34;atomic&#34;).

    livepreview_options : dict, optional
        Contains options for live preview. The dictionary includes &#39;static&#39; (default: run = 1) and &#39;dynamic&#39; (default: run = 100) options.

    Methods:
    -------
    __init__ :
        Constructor method to initialize all the attributes of the `region` class.
    &#34;&#34;&#34;

    _version = &#34;0.9997&#34;
    __custom_documentations__ = &#34;pizza.region.region class&#34;

    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    #
    # CONSTRUCTOR METHOD
    #
    #
    # The constructor include
    #   the main container: objects (a dictionnary)
    #   several attributes covering current and future use of PIZZA.REGION()
    #
    # The original constructor is derived from PIZZA.RASTER() with
    # an intent to allow at some point some forward and backward port between
    # objects of the class PIZZA.RASTER() and PIZZA.REGION().
    #
    # The code will evolve according to the needs, please come back regularly.
    #
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

    # CONSTRUCTOR ----------------------------
    def __init__(self,
                 # container properties
                 name=&#34;region container&#34;,
                 dimension = 3,
                 boundary = None,
                 nbeads=1,
                 units = &#34;&#34;,

                 # particle properties
                 mass=1.0,
                 volume=1.0,
                 density=1.0,
                 radius=1.5,
                 contactradius=0.5,
                 velocities=[0.0,0.0,0.0],
                 forces=[0.0,0.0,0.0],

                 # other properties
                 filename=&#34;&#34;,
                 previewfilename=&#34;&#34;,
                 index = None,
                 run=1,

                 # Box lengths
                 center = [0.0,0.0,0.0],    # center of the box for coordinates scaling
                 width = 10.0,  # along x
                 height = 10.0, # along y
                 depth = 10.0,  # along z
                 hasfixmove = False, # by default no fix move

                 # Spacefilling design (added on 2023-08-10)
                 spacefilling = False,
                 fillingbeadtype = 1,

                 # Lattice properties
                 boxid = &#34;box&#34;,             # default value for ${boxid_arg}
                 regionunits = &#34;lattice&#34;,   # units (&#34;lattice&#34; or &#34;si&#34;)
                 separationdistance = 5e-6, # SI units
                 lattice_scale = 0.8442,    # LJ units (for visualization)
                 lattice_spacing = None,    # lattice spacing is not used by default (set [dx dy dz] if needed)
                 lattice_style = &#34;fcc&#34; ,    # any valid lattice style accepted by LAMMPS (sc=simple cubic)

                 # Atom properties
                 atom_style = &#34;smd&#34;,
                 atom_modify = [&#34;map&#34;,&#34;array&#34;],
                 comm_modify = [&#34;vel&#34;,&#34;yes&#34;],
                 neigh_modify = [&#34;every&#34;,10,&#34;delay&#34;,0,&#34;check&#34;,&#34;yes&#34;],
                 newton =&#34;off&#34;,

                 # Live preview
                 live_units = &#34;lj&#34;,         # units to be used ONLY with livelammps (https://andeplane.github.io/atomify/)
                 live_atom_style = &#34;atomic&#34;,# atom style to be used ONLY with livelammps (https://andeplane.github.io/atomify/)

                 # livepreview options
                 livepreview_options = {
                     &#39;static&#39;:{&#39;run&#39;:1},
                     &#39;dynamic&#39;:{&#39;run&#39;:100}
                     },

                 # common flags (for scripting)
                 printflag = False,
                 verbose = True,
                 verbosity = None

                 ):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        self.name = name

        # Ensure dimension is an integer (must be 2 or 3 for LAMMPS)
        if not isinstance(dimension, int) or dimension not in (2, 3):
            raise ValueError(&#34;dimension must be either 2 or 3.&#34;)

        # Handle boundary input
        if boundary is None:
            boundary = [&#34;sm&#34;] * dimension
        elif isinstance(boundary, list):
            if len(boundary) != dimension:
                raise ValueError(f&#34;The length of boundary ({len(boundary)}) must match the dimension ({dimension}).&#34;)
        else:
            raise ValueError(&#34;boundary must be a list of strings or None.&#34;)

        # Validate regionunits
        if regionunits not in (&#34;lattice&#34;, &#34;si&#34;):
            raise ValueError(&#34;regionunits can only be &#39;lattice&#39; or &#39;si&#39;.&#34;)

        # Lattice scaling logic
        lattice_scale_siunits = lattice_scale if regionunits == &#34;si&#34; else separationdistance
        if lattice_scale_siunits is None or lattice_scale_siunits==&#34;&#34;:
            lattice_scale_siunits = separationdistance
        if lattice_spacing == &#34;&#34;:
            lattice_spacing = None
        elif isinstance(lattice_spacing, (int, float)):
            lattice_spacing = [lattice_spacing] * dimension
        elif isinstance(lattice_spacing, list):
            lattice_spacing = lattice_spacing + [lattice_spacing[-1]] * (dimension - len(lattice_spacing)) if len(lattice_spacing) &lt; dimension else lattice_spacing[:dimension]

        # live data (updated 2024-07-04)
        live_lattice_scale = lattice_scale/separationdistance if regionunits == &#34;si&#34; else lattice_scale
        live_box_scale = 1/lattice_scale_siunits if regionunits == &#34;si&#34; else 1
        self.live = regiondata(nbeads=nbeads,
                               run=run,
                               width=math.ceil(width*live_box_scale),    # live_box_scale force lattice units for live visualization
                               height=math.ceil(height*live_box_scale),  # live_box_scale force lattice units for live visualization
                               depth=math.ceil(depth*live_box_scale),    # live_box_scale force lattice units for live visualization
                               live_units = &#34;$&#34;+live_units,
                               live_atom_style = &#34;$&#34;+live_atom_style,
                               live_lattice_style=&#34;$&#34;+lattice_style,
                               live_lattice_scale=live_lattice_scale)
        # generic SMD properties (to be rescaled)
        self.volume = volume
        self.mass = mass
        self.density = density
        self.radius = radius
        self.contactradius = contactradius
        self.velocities = velocities
        self.forces = forces
        if filename == &#34;&#34;:
            self.filename = f&#34;region_{self.name}&#34;
        else:
            self.filename = filename
        self.index = index
        self.objects = {}    # object container
        self.nobjects = 0    # total number of objects (alive)
        # count objects per type
        self.counter = {
                  &#34;ellipsoid&#34;:0,
                  &#34;block&#34;:0,
                  &#34;sphere&#34;:0,
                  &#34;cone&#34;:0,
                  &#34;cylinder&#34;:0,
                  &#34;prism&#34;:0,
                  &#34;plane&#34;:0,
                  &#34;union&#34;:0,
                  &#34;intersect&#34;:0,
                  &#34;eval&#34;:0,
                  &#34;collection&#34;:0,
                  &#34;all&#34;:0
            }
        # fix move flag
        self.hasfixmove = hasfixmove
        # livelammps (for live sessions) - added 2023-02-06
        self.livelammps = {
            &#34;URL&#34;: livelammpsURL,
         &#34;active&#34;: False,
           &#34;file&#34;: None,
        &#34;options&#34;: livepreview_options
            }
        # space filling  (added 2023-08-10)
        self.spacefilling = {
                   &#34;flag&#34;: spacefilling,
           &#34;fillingstyle&#34;: &#34;$block&#34;,
        &#34;fillingbeadtype&#34;: fillingbeadtype,
           &#34;fillingwidth&#34;: width,
          &#34;fillingheight&#34;: height,
           &#34;fillingdepth&#34;: depth,
           &#34;fillingunits&#34;: units
               }
        # region object units
        self.regionunits = regionunits
        # lattice
        self.units = units
        self.center = center
        self.separationdistance = separationdistance
        self.lattice_scale = lattice_scale
        self.lattice_spacing = lattice_spacing
        self.lattice_scale_siunits = lattice_scale_siunits
        self.lattice_style = lattice_style
        # headers for header scripts (added 2024-09-01)
        # geometry is assumed to be units set by ${boxunits_arg} (new standard 2024-11-26)
        self.headersData = headersRegiondata(
            # use $ and [] to prevent execution
            name = &#34;$&#34;+name,
            previewfilename = &#34;$dump.initial.&#34;+self.filename if previewfilename==&#34;&#34; else &#34;$&#34;+previewfilename,
            # Initialize Lammps
            dimension = dimension,
            units = &#34;$&#34;+units,
            boundary = boundary,
            atom_style = &#34;$&#34; + atom_style,
            atom_modify = atom_modify,
            comm_modify = comm_modify,
            neigh_modify = neigh_modify,
            newton =&#34;$&#34; + newton,
            # Box (added 2024-11-26)
            boxid = &#34;$&#34;+boxid,
            boxunits_arg = &#34;$units box&#34; if regionunits==&#34;si&#34; else &#34;&#34;, # standard on 2025-11-26
            # Lattice
            lattice_style = &#34;$&#34;+lattice_style,
            lattice_scale = lattice_scale,
            lattice_spacing = lattice_spacing,
            # Box
            xmin = -(width/2)  +center[0],
            xmax = +(width/2)   +center[0],
            ymin = -(height/2) +center[1],
            ymax = +(height/2) +center[1],
            zmin = -(depth/2)  +center[2],
            zmax = +(depth/2)  +center[2],
            nbeads = nbeads,
            mass = mass
            )
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity

    # Method for coordinate/length scaling and translation including with formula embedded strings (updated 2024-07-03, fixed 2024-07-04)
    # Note that the translation is not fully required since the scaling applies also to full coordinates.
    # However, an implementation is provided for arbitrary offset.
    def scale_and_translate(self, value, offset=0):
        &#34;&#34;&#34;
        Scale and translate a value or encapsulate the formula within a string.

        If self.regionunits is &#34;si&#34;, only the offset is applied without scaling.
        Otherwise, scaling and translation are performed based on self.units (&#34;si&#34; or &#34;lattice&#34;).

        Parameters:
            value (str or float): The value or formula to be scaled and translated.
            offset (float, optional): The offset to apply. Defaults to 0.

        Returns:
            str or float: The scaled and translated value or formula.
        &#34;&#34;&#34;
        if self.regionunits == &#34;si&#34;:
            # Only apply offset without scaling
            if isinstance(value, str):
                if offset:
                    translated = f&#34;({value}) - {offset}&#34;
                else:
                    translated = f&#34;{value}&#34;
                return translated
            else:
                if offset:
                    return value - offset
                else:
                    return value
        else:
            # Existing behavior based on self.units
            if isinstance(value, str):
                if offset:
                    translated = f&#34;({value}) - {offset}&#34;
                else:
                    translated = f&#34;{value}&#34;
                if self.units == &#34;si&#34;:
                    return f&#34;({translated}) / {self.lattice_scale} + {offset / self.lattice_scale}&#34;
                else:  # &#34;lattice&#34;
                    return f&#34;({translated}) * {self.lattice_scale} + {offset * self.lattice_scale}&#34;
            else:
                if offset:
                    translated = value - offset
                else:
                    translated = value
                if self.units == &#34;si&#34;:
                    return translated / self.lattice_scale + (offset / self.lattice_scale)
                else:  # &#34;lattice&#34;
                    return translated * self.lattice_scale + (offset * self.lattice_scale)



    # space filling attributes (cannot be changed)
    @property
    def isspacefilled(self):
        return self.spacefilling[&#34;flag&#34;]

    @property
    def spacefillingbeadtype(self):
        return self.spacefilling[&#34;fillingbeadtype&#34;]

    # total number of atoms in the region
    @property
    def natoms(self):
        &#34;&#34;&#34;Count the total number of atoms in all objects within the region.&#34;&#34;&#34;
        total_atoms = 0
        for eachobj in self:
            total_atoms += eachobj.natoms
        return total_atoms

    # details if the geometry of the region
    @property
    def geometry(self):
        &#34;&#34;&#34;Display the dimensions and characteristics of the region and its objects.&#34;&#34;&#34;
        details = f&#34;Region: {self.name}\n&#34;
        details += f&#34;Total atoms: {self.natoms}\n&#34;
        details += f&#34;Span: width={self.spacefilling[&#39;fillingwidth&#39;]}, height={self.spacefilling[&#39;fillingheight&#39;]}, depth={self.spacefilling[&#39;fillingdepth&#39;]}\n&#34;
        details += f&#34;Box center: {self.center}\n&#34;
        details += &#34;Objects in the region:\n\n&#34;
        for obj in self:
            details += &#34;\n\n&#34;+&#34;-&#34;*32+&#34;\n&#34;
            details += f&#34;\nObject: {obj.name}\n&#34;
            details += f&#34;Type: {type(obj).__name__}\n&#34;
            if hasattr(obj, &#39;geometry&#39;):
                details += &#34;\n&#34;+&#34;-&#34;*32+&#34;\n&#34;
                details += obj.geometry
            else:
                details += &#34;No geometry information available.\n&#34;
        print(details)

    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    #
    # REGION.GEOMETRY constructors
    #
    #
    #   These methods create the 3D geometry objects (at least their code)
    #   A geometry is a collection of PIZZA.SCRIPT() objects (LAMMPS codelet)
    #   not a real geometry. The distinction between the creation (definition)
    #   and the execution (generation) of the gometry object existed already
    #   in PIZZA.RASTER(), but here they remain codelets as ONLY LAMMPS can
    #   generate the real object.
    #
    #   This level of abstraction makes it possible to mix PIZZA variables
    #   (USER, PIZZA.SCRIPT.USER, PIZZA.PIPESCRIPT.USER) with LAMMPS variables.
    #   The same object template can be used in different LAMMPS scripts with
    #   different values and without writting additional Python code.
    #   In shorts: USER fields store PIZZA.SCRIPT() like variables
    #              (they are compiled [statically] before LAMMPS execution)
    #              VARIABLES are defined in the generated LAMMPS script but
    #              created [dynamically] in LAMMPS. Note that these variables
    #              are defined explicitly with the LAMMPS variable command:
    #                   variable name style args ...
    #   Note: static variables can have only one single value for LAMMPS, which
    #         is known before LAMMPS is launched. The others can be assigned
    #         at runtime when LAMMPS is running.
    #   Example with complex definitions
    #       R.ellipsoid(0,0,0,1,1,1,name=&#34;E2&#34;,side=&#34;out&#34;,
    #                   move=[&#34;left&#34;,&#34;${up}*3&#34;,None],
    #                   up=0.1)
    #       R.E2.VARIABLES.left = &#39;&#34;swiggle(%s,%s,%s)&#34;%(${a},${b},${c})&#39;
    #       R.E2.VARIABLES.a=&#34;${b}-5&#34;
    #       R.E2.VARIABLES.b=5
    #       R.E2.VARIABLES.c=100
    #
    #   The methods PIZZA.REGION.DO(), PIZZA.REGION.DOLIVE() compiles
    #   (statically) and generate the corresponding LAMMPS code. The static
    #   compiler accepts hybrid constructions where USER and VARIABLES are
    #   mixed. Any undefined variables will be assumed to be defined elsewhere
    #   in the LAMMPS code.
    #
    #  Current attributes of PIZZA.REGION.OBJECT cover current and future use
    #  of these objects and will allow some point some forward and backward
    #  compatibility with the same PIZZA.RASTER.OBJECT.
    #
    #
    #   References:
    #       https://docs.lammps.org/region.html
    #       https://docs.lammps.org/variable.html
    #       https://docs.lammps.org/create_atoms.html
    #       https://docs.lammps.org/create_box.html
    #
    #
    #   List of implemented geometries (shown here with the LAMMPS syntax)
    #       block args = xlo xhi ylo yhi zlo zhi
    #       cone args = dim c1 c2 radlo radhi lo hi
    #       cylinder args = dim c1 c2 radius lo hi
    #       ellipsoid args = x y z a b c &lt;-- first method to be implemented
    #       plane args = px py pz nx ny n
    #       prism args = xlo xhi ylo yhi zlo zhi xy xz yz
    #       sphere args = x y z radius
    #       union args = N reg-ID1 reg-ID2 ..
    #       intersect args = N reg-ID1 reg-ID2 ...
    #
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

    # BLOCK method ---------------------------
    # block args = xlo xhi ylo yhi zlo zhi
    # xlo,xhi,ylo,yhi,zlo,zhi = bounds of block in all dimensions (distance units)
    def block(self,xlo=-5,xhi=5,ylo=-5,yhi=5,zlo=-5,zhi=5,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a block region
            xlo,xhi,ylo,yhi,zlo,zhi = bounds of block in all dimensions (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;block001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;block&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object B with B for block
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        B = Block((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density, # added on 2024-06-14
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): B.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: B.beadtype = beadtype # bead type (if not defined, default index will apply)
        B.USER.ID = &#34;$&#34;+B.name        # add $ to prevent its execution
        # geometry args (2024-07-04)  -------------------------------------
        args = [xlo, xhi, ylo, yhi, zlo, zhi]  # args = [....] as defined in the class Block
        args_scaled = [
            self.scale_and_translate(xlo, self.center[0]),
            self.scale_and_translate(xhi, self.center[0]),
            self.scale_and_translate(ylo, self.center[1]),
            self.scale_and_translate(yhi, self.center[1]),
            self.scale_and_translate(zlo, self.center[2]),
            self.scale_and_translate(zhi, self.center[2])
        ]
        if self.units == &#34;si&#34;:
            B.USER.args = args_scaled
            B.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            B.USER.args = args
            B.USER.args_siunits = args_scaled
        # geometry
        B.USER.geometry = (
            f&#34;Block Region: {B.name}\n&#34;
            &#34;Coordinates: [xlo,xhi,ylo,yhi,zlo,zhi] = bounds of block in all dimensions&#34;
            f&#34;Coordinates (scaled): {B.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {B.USER.args_siunits}\n&#34;
            f&#34;\talong x: [{B.USER.args[0]}, {B.USER.args[1]}]\n&#34;
            f&#34;\talong y: [{B.USER.args[2]}, {B.USER.args[3]}]\n&#34;
            f&#34;\talong z: [{B.USER.args[4]}, {B.USER.args[5]}]&#34;
        )
        # other attributes  -------------------------------------
        B.USER.beadtype = B.beadtype  # beadtype to be used for create_atoms
        B.USER.side = B.sidearg(side) # extra parameter side
        B.USER.move = B.movearg(move) # move arg
        B.USER.units = B.unitsarg(units) # units
        B.USER.rotate = B.rotatearg(rotate) # rotate
        B.USER.open = B.openarg(open) # open
        # Create the object if not fake
        if fake:
            return B
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = B
            self.nobjects += 1
            return None

    # CONE method ---------------------------
    # cone args = dim c1 c2 radlo radhi lo hi
    # dim = x or y or z = axis of cone
    # c1,c2 = coords of cone axis in other 2 dimensions (distance units)
    # radlo,radhi = cone radii at lo and hi end (distance units)
    # lo,hi = bounds of cone in dim (distance units)
    def cone(self,dim=&#34;z&#34;,c1=0,c2=0,radlo=2,radhi=5,lo=-10,hi=10,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a cone region
            dim = &#34;x&#34; or &#34;y&#34; or &#34;z&#34; = axis of the cone
                 note: USER, LAMMPS variables are not authorized here
            c1,c2 = coords of cone axis in other 2 dimensions (distance units)
            radlo,radhi = cone radii at lo and hi end (distance units)
            lo,hi = bounds of cone in dim (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;cone001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;cone&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object C with C for cone
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        C = Cone((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density, # added on 2024-06-14
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): C.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: C.beadtype = beadtype # bead type (if not defined, default index will apply)
        C.USER.ID = &#34;$&#34;+C.name        # add $ to prevent its execution
        # geometry args (2024-07-04)  -------------------------------------
        args = [dim, c1, c2, radlo, radhi, lo, hi]  # args = [....] as defined in the class Cone
        if dim == &#34;x&#34;:  # x-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[1]),
                self.scale_and_translate(c2, self.center[2]),
                self.scale_and_translate(radlo, 0),
                self.scale_and_translate(radhi, 0),
                self.scale_and_translate(lo, self.center[0]),
                self.scale_and_translate(hi, self.center[0])
            ]
        elif dim == &#34;y&#34;:  # y-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[0]),
                self.scale_and_translate(c2, self.center[2]),
                self.scale_and_translate(radlo, 0),
                self.scale_and_translate(radhi, 0),
                self.scale_and_translate(lo, self.center[1]),
                self.scale_and_translate(hi, self.center[1])
            ]
        else:  # z-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[0]),
                self.scale_and_translate(c2, self.center[1]),
                self.scale_and_translate(radlo, 0),
                self.scale_and_translate(radhi, 0),
                self.scale_and_translate(lo, self.center[2]),
                self.scale_and_translate(hi, self.center[2])
            ]

        if self.units == &#34;si&#34;:
            C.USER.args = args_scaled
            C.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            C.USER.args = args
            C.USER.args_siunits = args_scaled
        # geometry
        C.USER.geometry = (
            f&#34;Cone Region: {C.name}\n&#34;
            &#34;Coordinates: [dim,c1,c2,radlo,radhi,lo,hi] = dimensions of cone\n&#34;
            f&#34;Coordinates (scaled): {C.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {C.USER.args_siunits}\n&#34;
            f&#34;\tdim: {C.USER.args[0]}\n&#34;
            f&#34;\tc1: {C.USER.args[1]}\n&#34;
            f&#34;\tc2: {C.USER.args[2]}\n&#34;
            f&#34;\tradlo: {C.USER.args[3]}\n&#34;
            f&#34;\tradhi: {C.USER.args[4]}\n&#34;
            f&#34;\tlo: {C.USER.args[5]}\n&#34;
            f&#34;\thi: {C.USER.args[6]}&#34;
        )
        # other attributes  -------------------------------------
        C.USER.beadtype = C.beadtype  # beadtype to be used for create_atoms
        C.USER.side = C.sidearg(side) # extra parameter side
        C.USER.move = C.movearg(move) # move arg
        C.USER.units = C.unitsarg(units) # units
        C.USER.rotate = C.rotatearg(rotate) # rotate
        C.USER.open = C.openarg(open) # open
        # Create the object if not fake
        if fake:
            return C
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = C
            self.nobjects += 1
            return None

    # CYLINDER method ---------------------------
    # cylinder args = dim c1 c2 radius lo hi
    # dim = x or y or z = axis of cylinder
    # c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)
    # radius = cylinder radius (distance units)
    # c1,c2, and radius can be a variable (see below)
    # lo,hi = bounds of cylinder in dim (distance units)
    def cylinder(self,dim=&#34;z&#34;,c1=0,c2=0,radius=4,lo=-10,hi=10,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a cylinder region
              dim = x or y or z = axis of cylinder
              c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)
              radius = cylinder radius (distance units)
              c1,c2, and radius can be a LAMMPS variable
              lo,hi = bounds of cylinder in dim (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;cylinder001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;cylinder&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object C with C for cylinder
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        C = Cylinder((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density,
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): C.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: C.beadtype = beadtype # bead type (if not defined, default index will apply)
        C.USER.ID = &#34;$&#34;+C.name        # add $ to prevent its execution
        # geometry args (2024-07-04)  -------------------------------------
        args = [dim, c1, c2, radius, lo, hi]  # args = [....] as defined in the class Cylinder
        if dim == &#34;x&#34;:  # x-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[1]),
                self.scale_and_translate(c2, self.center[2]),
                self.scale_and_translate(radius, 0),
                self.scale_and_translate(lo, self.center[0]),
                self.scale_and_translate(hi, self.center[0])
            ]
        elif dim == &#34;y&#34;:  # y-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[0]),
                self.scale_and_translate(c2, self.center[2]),
                self.scale_and_translate(radius, 0),
                self.scale_and_translate(lo, self.center[1]),
                self.scale_and_translate(hi, self.center[1])
            ]
        else:  # z-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[0]),
                self.scale_and_translate(c2, self.center[1]),
                self.scale_and_translate(radius, 0),
                self.scale_and_translate(lo, self.center[2]),
                self.scale_and_translate(hi, self.center[2])
            ]
        if self.units == &#34;si&#34;:
            C.USER.args = args_scaled
            C.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            C.USER.args = args
            C.USER.args_siunits = args_scaled
        # geometry
        C.USER.geometry = (
            f&#34;Cylinder Region: {C.name}\n&#34;
            &#34;Coordinates: [dim,c1,c2,radius,lo,hi] = dimensions of cylinder\n&#34;
            f&#34;Coordinates (scaled): {C.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {C.USER.args_siunits}\n&#34;
            f&#34;\tdim: {C.USER.args[0]}\n&#34;
            f&#34;\tc1: {C.USER.args[1]}\n&#34;
            f&#34;\tc2: {C.USER.args[2]}\n&#34;
            f&#34;\tradius: {C.USER.args[3]}\n&#34;
            f&#34;\tlo: {C.USER.args[4]}\n&#34;
            f&#34;\thi: {C.USER.args[5]}&#34;
        )
        # other attributes  -------------------------------------
        C.USER.beadtype = C.beadtype  # beadtype to be used for create_atoms
        C.USER.side = C.sidearg(side) # extra parameter side
        C.USER.move = C.movearg(move) # move arg
        C.USER.units = C.unitsarg(units) # units
        C.USER.rotate = C.rotatearg(rotate) # rotate
        C.USER.open = C.openarg(open) # open
        # Create the object if not fake
        if fake:
            return C
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = C
            self.nobjects += 1
            return None

    # ELLIPSOID method ---------------------------
    # ellipsoid args = x y z a b c
    # x,y,z = center of ellipsoid (distance units)
    # a,b,c = half the length of the principal axes of the ellipsoid (distance units)
    # x,y,z,a,b,c can be variables
    def ellipsoid(self,x=0,y=0,z=0,a=5,b=3,c=2,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates an ellipsoid region
            ellipsoid(x,y,z,a,b,c [,name=None,beadtype=None,property=value,...])
            x,y,z = center of ellipsoid (distance units)
            a,b,c = half the length of the principal axes of the ellipsoid (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;ellipsoid001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
                index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index


            Examples:
                # example with variables created either at creation or later
                    R = region(name=&#34;my region&#34;)
                    R.ellipsoid(0, 0, 0, 1, 1, 1,name=&#34;E1&#34;,toto=3)
                    repr(R.E1)
                    R.E1.VARIABLES.a=1
                    R.E1.VARIABLES.b=2
                    R.E1.VARIABLES.c=&#34;(${a},${b},100)&#34;
                    R.E1.VARIABLES.d = &#39;&#34;%s%s&#34; %(&#34;test&#34;,${c}) # note that test could be replaced by any function&#39;
                # example with extra parameters
                    R.ellipsoid(0,0,0,1,1,1,name=&#34;E2&#34;,side=&#34;out&#34;,move=[&#34;left&#34;,&#34;${up}*3&#34;,None],up=0.1)
                    R.E2.VARIABLES.left = &#39;&#34;swiggle(%s,%s,%s)&#34;%(${a},${b},${c})&#39;
                    R.E2.VARIABLES.a=&#34;${b}-5&#34;
                    R.E2.VARIABLES.b=5
                    R.E2.VARIABLES.c=100
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;ellipsoid&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object E with E for Ellipsoid
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        E = Ellipsoid((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density,
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): E.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: E.beadtype = beadtype # bead type (if not defined, default index will apply)
        E.USER.ID = &#34;$&#34;+E.name        # add $ to prevent its execution
        # geometry args (2024-07-04)  -------------------------------------
        args = [x, y, z, a, b, c]  # args = [....] as defined in the class Ellipsoid
        args_scaled = [
            self.scale_and_translate(x, self.center[0]),
            self.scale_and_translate(y, self.center[1]),
            self.scale_and_translate(z, self.center[2]),
            self.scale_and_translate(a, 0),
            self.scale_and_translate(b, 0),
            self.scale_and_translate(c, 0)
        ]
        if self.units == &#34;si&#34;:
            E.USER.args = args_scaled
            E.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            E.USER.args = args
            E.USER.args_siunits = args_scaled
        # geometry
        E.USER.geometry = (
            f&#34;Ellipsoid Region: {E.name}\n&#34;
            &#34;Coordinates: [x,y,z,a,b,c] = center and radii of ellipsoid\n&#34;
            f&#34;Coordinates (scaled): {E.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {E.USER.args_siunits}\n&#34;
            f&#34;\tcenter: [{E.USER.args[0]}, {E.USER.args[1]}, {E.USER.args[2]}]\n&#34;
            f&#34;\ta: {E.USER.args[3]}\n&#34;
            f&#34;\tb: {E.USER.args[4]}\n&#34;
            f&#34;\tc: {E.USER.args[5]}&#34;
        )
        # other attributes  -------------------------------------
        E.USER.beadtype = E.beadtype  # beadtype to be used for create_atoms
        E.USER.side = E.sidearg(side) # extra parameter side
        E.USER.move = E.movearg(move) # move arg
        E.USER.units = E.unitsarg(units) # units
        E.USER.rotate = E.rotatearg(rotate) # rotate
        E.USER.open = E.openarg(open) # open
        # Create the object if not fake
        if fake:
            return E
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = E
            self.nobjects += 1
            return None

    # PLANE method ---------------------------
    # plane args = px py pz nx ny nz
    # px,py,pz = point on the plane (distance units)
    # nx,ny,nz = direction normal to plane (distance units)
    def plane(self,px=0,py=0,pz=0,nx=0,ny=0,nz=1,
                  name=None,beadtype=None,fake=False,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a plane region
              px,py,pz = point on the plane (distance units)
              nx,ny,nz = direction normal to plane (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;plane001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;plane&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object P with P for plane
        P = Plane((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=self.mass, density=self.density, # added on 2024-06-14
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): P.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: P.beadtype = beadtype # bead type (if not defined, default index will apply)
        P.USER.ID = &#34;$&#34;+P.name        # add $ to prevent its execution
        # geometry args (2024-07-04) ---------------------------
        args = [px, py, pz, nx, ny, nz]  # args = [....] as defined in the class Plane
        args_scaled = [
            self.scale_and_translate(px, self.center[0]),
            self.scale_and_translate(py, self.center[1]),
            self.scale_and_translate(pz, self.center[2]),
            self.scale_and_translate(nx, 0),
            self.scale_and_translate(ny, 0),
            self.scale_and_translate(nz, 0)
        ]
        if self.units == &#34;si&#34;:
            P.USER.args = args_scaled
            P.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            P.USER.args = args
            P.USER.args_siunits = args_scaled
        # geometry
        P.USER.geometry = (
            f&#34;Plane Region: {P.name}\n&#34;
            &#34;Coordinates: [px,py,pz,nx,ny,nz] = point and normal vector of plane\n&#34;
            f&#34;Coordinates (scaled): {P.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {P.USER.args_siunits}\n&#34;
            f&#34;\tpoint: [{P.USER.args[0]}, {P.USER.args[1]}, {P.USER.args[2]}]\n&#34;
            f&#34;\tnormal: [{P.USER.args[3]}, {P.USER.args[4]}, {P.USER.args[5]}]&#34;
            )
        # other attributes ---------------------------
        P.USER.beadtype = P.beadtype  # beadtype to be used for create_atoms
        P.USER.side = P.sidearg(side) # extra parameter side
        P.USER.move = P.movearg(move) # move arg
        P.USER.units = P.unitsarg(units) # units
        P.USER.rotate = P.rotatearg(rotate) # rotate
        P.USER.open = P.openarg(open) # open
        # Create the object if not fake
        if fake:
            return P
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = P
            self.nobjects += 1
            return None

    # PRISM method ---------------------------
    # prism args = xlo xhi ylo yhi zlo zhi xy xz yz
    # xlo,xhi,ylo,yhi,zlo,zhi = bounds of untilted prism (distance units)
    # xy = distance to tilt y in x direction (distance units)
    # xz = distance to tilt z in x direction (distance units)
    # yz = distance to tilt z in y direction (distance units)
    def prism(self,xlo=-5,xhi=5,ylo=-5,yhi=5,zlo=-5,zhi=5,xy=1,xz=1,yz=1,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a prism region
            xlo,xhi,ylo,yhi,zlo,zhi = bounds of untilted prism (distance units)
            xy = distance to tilt y in x direction (distance units)
            xz = distance to tilt z in x direction (distance units)
            yz = distance to tilt z in y direction (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;prism001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;prism&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object P with P for prism
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        P = Prism((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density, # added on 2024-06-14
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): P.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: P.beadtype = beadtype # bead type (if not defined, default index will apply)
        P.USER.ID = &#34;$&#34;+P.name        # add $ to prevent its execution
        # geometry args (2024-07-04) ---------------------------
        args = [xlo, xhi, ylo, yhi, zlo, zhi, xy, xz, yz]  # args = [....] as defined in the class Prism
        args_scaled = [
            self.scale_and_translate(xlo, self.center[0]),
            self.scale_and_translate(xhi, self.center[0]),
            self.scale_and_translate(ylo, self.center[1]),
            self.scale_and_translate(yhi, self.center[1]),
            self.scale_and_translate(zlo, self.center[2]),
            self.scale_and_translate(zhi, self.center[2]),
            self.scale_and_translate(xy, 0),
            self.scale_and_translate(xz, 0),
            self.scale_and_translate(yz, 0)
        ]
        if self.units == &#34;si&#34;:
            P.USER.args = args_scaled
            P.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            P.USER.args = args
            P.USER.args_siunits = args_scaled
        # geometry
        P.USER.geometry = (
            f&#34;Prism Region: {P.name}\n&#34;
            &#34;Coordinates: [xlo,xhi,ylo,yhi,zlo,zhi,xy,xz,yz] = bounds and tilts of prism\n&#34;
            f&#34;Coordinates (scaled): {P.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {P.USER.args_siunits}\n&#34;
            f&#34;\tbounds: [{P.USER.args[0]}, {P.USER.args[1]}, {P.USER.args[2]}, {P.USER.args[3]}, {P.USER.args[4]}, {P.USER.args[5]}]\n&#34;
            f&#34;\ttilts: [{P.USER.args[6]}, {P.USER.args[7]}, {P.USER.args[8]}]&#34;
        )
        # other attributes ---------------------------
        P.USER.beadtype = P.beadtype  # beadtype to be used for create_atoms
        P.USER.side = P.sidearg(side) # extra parameter side
        P.USER.move = P.movearg(move) # move arg
        P.USER.units = P.unitsarg(units) # units
        P.USER.rotate = P.rotatearg(rotate) # rotate
        P.USER.open = P.openarg(open) # open
        # Create the object if not fake
        if fake:
            return P
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = P
            self.nobjects += 1
            return None

    # SPHERE method ---------------------------
    # sphere args = x y z radius
    # x,y,z = center of sphere (distance units)
    # radius = radius of sphere (distance units)
    # x,y,z, and radius can be a variable (see below)
    def sphere(self,x=0,y=0,z=0,radius=3,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a sphere region
              x,y,z = center of sphere (distance units)
              radius = radius of sphere (distance units)
              x,y,z, and radius can be a variable

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;sphere001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;sphere&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object S with S for sphere
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        S = Sphere((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density, # added on 2024-06-14
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): S.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: S.beadtype = beadtype # bead type (if not defined, default index will apply)
        S.USER.ID = &#34;$&#34;+S.name        # add $ to prevent its execution
        # geometry args (2024-07-04) ---------------------------
        args = [x, y, z, radius]  # args = [....] as defined in the class Sphere
        args_scaled = [
            self.scale_and_translate(x, self.center[0]),
            self.scale_and_translate(y, self.center[1]),
            self.scale_and_translate(z, self.center[2]),
            self.scale_and_translate(radius, 0)
        ]
        if self.units == &#34;si&#34;:
            S.USER.args = args_scaled
            S.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            S.USER.args = args
            S.USER.args_siunits = args_scaled
        # geometry
        S.USER.geometry = (
            f&#34;Sphere Region: {S.name}\n&#34;
            &#34;Coordinates: [x,y,z,radius] = center and radius of sphere\n&#34;
            f&#34;Coordinates (scaled): {S.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {S.USER.args_siunits}\n&#34;
            f&#34;\tcenter: [{S.USER.args[0]}, {S.USER.args[1]}, {S.USER.args[2]}]\n&#34;
            f&#34;\tradius: {S.USER.args[3]}&#34;
        )
        # other attributes ---------------------------
        S.USER.beadtype = S.beadtype  # beadtype to be used for create_atoms
        S.USER.side = S.sidearg(side) # extra parameter side
        S.USER.move = S.movearg(move) # move arg
        S.USER.units = S.unitsarg(units) # units
        S.USER.rotate = S.rotatearg(rotate) # rotate
        S.USER.open = S.openarg(open) # open
        # Create the object if not fake
        if fake:
            return S
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = S
            self.nobjects += 1
            return None

    # UNION method ---------------------------
    # union args = N reg-ID1 reg-ID2
    def union(self,*regID,
              name=None,beadtype=1,fake=False,
              index = None,subindex = None,
              **variables):
        &#34;&#34;&#34;
        creates a union region
              union(&#34;reg-ID1&#34;,&#34;reg-ID2&#34;,name=&#34;myname&#34;,beadtype=1,...)
              reg-ID1,reg-ID2, ... = IDs of regions to join together

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;union001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex
        &#34;&#34;&#34;
        kind = &#34;union&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        # create the object U with U for union
        U = Union((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      index=index,subindex=subindex,**variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): U.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: U.beadtype = beadtype # bead type (if not defined, default index will apply)
        U.USER.ID = &#34;$&#34;+U.name        # add $ to prevent its execution
        U.USER.side, U.USER.move, U.USER.units, U.USER.rotate, U.USER.open = &#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;
        # build arguments based on regID
        nregID = len(regID)
        if nregID&lt;2: raise ValueError(&#39;two objects must be given at least for an union&#39;)
        args = [None] # the number of arguments is not known yet
        validID = range(nregID)
        for ireg in validID:
            if isinstance(regID[ireg],int):
                if regID[ireg] in validID:
                    args.append(self.names[regID[ireg]])
                else:
                    raise IndexError(f&#34;the index {regID[ireg]} exceeds the number of objects {len(self)}&#34;)
            elif isinstance(regID[ireg],str):
                if regID[ireg] in self:
                    args.append(regID[ireg])
                else:
                    raise KeyError(f&#39;the object &#34;{regID[ireg]}&#34; does not exist&#39;)
            else:
                raise KeyError(f&#34;the {ireg+1}th object should be given as a string or an index&#34;)
            # prevent the creation of atoms merged (avoid duplicates)
            self.objects[regID[ireg]].FLAGSECTIONS[&#34;create&#34;] = False
        args[0] = len(regID)
        U.USER.args = args   # args = [....] as defined in the class Union
        # Create the object if not fake
        if fake:
            return U
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = U
            self.nobjects += 1
            return None

    # UNION method ---------------------------
    # union args = N reg-ID1 reg-ID2
    def intersect(self,*regID,
              name=None,beadtype=1,fake=False,
              index = None,subindex = None,
              **variables):
        &#34;&#34;&#34;
        creates an intersection region
              intersect(&#34;reg-ID1&#34;,&#34;reg-ID2&#34;,name=&#34;myname&#34;,beadtype=1,...)
              reg-ID1,reg-ID2, ... = IDs of regions to join together

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;intersect001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex
        &#34;&#34;&#34;
        kind = &#34;intersect&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        # create the object I with I for intersect
        I = Intersect((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      index=index,subindex=subindex,**variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): I.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: I.beadtype = beadtype # bead type (if not defined, default index will apply)
        I.USER.ID = &#34;$&#34;+I.name        # add $ to prevent its execution
        I.USER.side, I.USER.move, I.USER.units, I.USER.rotate, I.USER.open = &#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;
        # build arguments based on regID
        nregID = len(regID)
        if nregID&lt;2: raise ValueError(&#39;two objects must be given at least for an intersection&#39;)
        args = [None] # the number of arguments is not known yet
        validID = range(nregID)
        for ireg in validID:
            if isinstance(regID[ireg],int):
                if regID[ireg] in validID:
                    args.append(self.names[regID[ireg]])
                else:
                    raise IndexError(f&#34;the index {regID[ireg]} exceeds the number of objects {len(self)}&#34;)
            elif isinstance(regID[ireg],str):
                if regID[ireg] in self:
                    args.append(regID[ireg])
                else:
                    raise KeyError(f&#39;the object &#34;{regID[ireg]}&#34; does not exist&#39;)
            else:
                raise KeyError(f&#34;the {ireg+1}th object should be given as a string or an index&#34;)
            # prevent the creation of atoms (avoid duplicates)
            self.objects[regID[ireg]].FLAGSECTIONS[&#34;create&#34;] = False
        args[0] = len(regID)
        I.USER.args = args   # args = [....] as defined in the class Union
        # Create the object if not fake
        if fake:
            return I
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = I
            self.nobjects += 1
            return None


    # Group method ---------------------------
    def group(self,obj,name=None,fake=False):
        pass


    # COLLECTION method ---------------------------
    def collection(self,*obj,name=None,beadtype=None,fake=False,
              index = None,subindex = None,
              **kwobj):
        kind = &#34;collection&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        # create the object C with C for collection
        C = Collection((index,subindex))
        if name not in (None,&#34;&#34;): C.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: C.beadtype = beadtype # bead type (if not defined, default index will apply)
        # add objects
        C.collection = regioncollection(*obj,**kwobj)
        # apply modifications (beadtype, ismask)
        for o in C.collection.keys():
            tmp = C.collection.getattr(o)
            if beadtype != None: tmp.beadtype = beadtype
            C.collection.setattr(o,tmp)
        # Create the object if not fake
        if fake:
            return C
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = C
            self.nobjects += 1
            return None

    def scatter(self,
                 E,
                 name=&#34;emulsion&#34;,
                 beadtype=None,
                 ):
        &#34;&#34;&#34;


        Parameters
        ----------
        E : scatter or emulsion object
            codes for x,y,z and r.
        name : string, optional
            name of the collection. The default is &#34;emulsion&#34;.
        beadtype : integer, optional
            for all objects. The default is 1.

        Raises
        ------
        TypeError
            Return an error of the object is not a scatter type.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if isinstance(E,scatter):
            collect = {}
            for i in range(E.n):
                b = E.beadtype[i] if beadtype==None else beadtype
                nameobj = &#34;glob%02d&#34; % i
                collect[nameobj] = self.sphere(E.x[i],E.y[i],E.z[i],E.r[i],
                            name=nameobj,beadtype=b,fake=True)
            self.collection(**collect,name=name)
        else:
            raise TypeError(&#34;the first argument must be an emulsion object&#34;)



    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    #
    # LOW-LEVEL METHODS
    #
    #
    # Low-level methods to manipulate and operate region objects (e.g., R).
    # They implement essentially some Python standards with the following
    # shortcut: R[i] or R[objecti] and R.objecti and R.objects[objecti] are
    # the same ith object where R.objects is the original container
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

    # repr() method ----------------------------
    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        spacefillingstr = f&#34;\n(space filled with beads of type {self.spacefillingbeadtype})&#34; \
            if self.isspacefilled else &#34;&#34;
        print(&#34;-&#34;*40)
        print(&#39;REGION container &#34;%s&#34; with %d objects %s\n(units=&#34;%s&#34;, lattice=&#34;%s&#34;, scale=%0.4g [m])&#39; \
              % (self.name,self.nobjects,spacefillingstr,self.units,self.lattice_style,self.lattice_scale_siunits))
        if self.nobjects&gt;0:
            names = self.names
            l = [len(n) for n in names]
            width = max(10,max(l)+2)
            fmt = &#34;%%%ss:&#34; % width
            for i in range(self.nobjects):
                flags = &#34;(&#34;+self.objects[names[i]].shortflags+&#34;)&#34; if self.objects[names[i]].flags else &#34;(no script)&#34;
                if isinstance(self.objects[names[i]],Collection):
                        print(fmt % names[i],&#34; %s region (%d beadtypes)&#34; % \
                              (self.objects[names[i]].kind,len(self.objects[names[i]].beadtype)),&#34; &gt; &#34;,flags)
                else:
                    print(fmt % names[i],&#34; %s region (beadtype=%d)&#34; % \
                          (self.objects[names[i]].kind,self.objects[names[i]].beadtype),&#34; &gt; &#34;,flags)
            print(wrap(&#34;they are&#34;,&#34;:&#34;,&#34;, &#34;.join(self.names),10,60,80))
        print(&#34;-&#34;*40)
        return &#34;REGION container %s with %d objects (%s)&#34; % \
            (self.name,self.nobjects,&#34;,&#34;.join(self.names))

    # str() method ----------------------------
    def __str__(self):
        &#34;&#34;&#34; string representation of a region &#34;&#34;&#34;
        return &#34;REGION container %s with %d objects (%s)&#34; % \
            (self.name,self.nobjects,&#34;,&#34;.join(self.names))

    # generic GET method ----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.objects:
            return self.objects[name]
        else:
            raise NameError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # getattr() method ----------------------------
    def __getattr__(self,name):
        &#34;&#34;&#34; getattr attribute override &#34;&#34;&#34;
        if (name in self.__dict__) or (name in protectedregionkeys):
            return self.__dict__[name] # higher precedence for root attributes
        if name in protectedregionkeys:
            return getattr(type(self), name).__get__(self) # for methods decorated as properties (@property)
        # Handle special cases like __wrapped__ explicitly
        if name == &#34;__wrapped__&#34;:
            return None  # Default value or appropriate behavior
        # Leave legitimate __dunder__ attributes to the default mechanism
        if name.startswith(&#34;__&#34;) and name.endswith(&#34;__&#34;):
            raise AttributeError(f&#34;{type(self).__name__!r} object has no attribute {name!r}&#34;)
        # Default
        return self.get(name)

    # generic SET method ----------------------------
    def set(self,name,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0:
            if name not in self.objects:
                raise NameError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)
            self.delete(name)
        elif isinstance(value,coregeometry):
            if name in self.objects: self.delete(name)
            if isinstance(value.SECTIONS,pipescript) or isinstance(value,Evalgeometry):
                self.eval(deepduplicate(value),name) # not a scalar
            else: # scalar
                self.objects[name] = deepduplicate(value)
                self.objects[name].name = name
                self.nobjects += 1
                self.counter[&#34;all&#34;] += 1
                self.objects[name].index = self.counter[&#34;all&#34;]
                self.counter[value.kind] += 1

    # setattr() method ----------------------------
    def __setattr__(self,name,value):
        &#34;&#34;&#34; setattr override &#34;&#34;&#34;
        if name in protectedregionkeys: # do not forget to increment protectedregionkeys
            self.__dict__[name] = value # if not, you may enter in infinite loops
        else:
            self.set(name,value)

    # generic HASATTR method ----------------------------
    def hasattr(self,name):
        &#34;&#34;&#34; return true if the object exist &#34;&#34;&#34;
        if not isinstance(name,str): raise TypeError(&#34;please provide a string&#34;)
        return name in self.objects

    # IN operator ----------------------------
    def __contains__(self,obj):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(obj)

    # len() method ----------------------------
    def __len__(self):
        &#34;&#34;&#34; len method &#34;&#34;&#34;
        return len(self.objects)

    # indexing [int] and [&#34;str&#34;] method ----------------------------
    def __getitem__(self,idx):
        &#34;&#34;&#34;
            R[i] returns the ith element of the structure
            R[:4] returns a structure with the four first fields
            R[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.get(self.names[idx])
            raise IndexError(f&#34;the index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,str):
            if idx in self:
                return self.get(idx)
            raise NameError(f&#39;{idx} does not exist, use list() to list objects&#39;)
        elif isinstance(idx,list):
            pass
        elif isinstance(idx,slice):
            return self.__getitem__(self,list(range(*idx.indices(len(self)))))
        else:
            raise IndexError(&#34;not implemented yet&#34;)

    # duplication GET method based on DICT ----------------------------
    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    # duplication SET method based on DICT ----------------------------
    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    # iterator method ----------------------------
    def __iter__(self):
        &#34;&#34;&#34; region iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    # next iterator method ----------------------------
    def __next__(self):
        &#34;&#34;&#34; region iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum region.objects iteration reached {len(self)}&#34;)


    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    #
    # MIDDLE-LEVEL METHODS
    #
    #
    # These methods are specific to PIZZA.REGION() objects.
    # They bring useful methods for the user and developer.
    # Similar methods exist in PIZZA.RASTER()
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

    # LIST method ----------------------------
    def list(self):
        &#34;&#34;&#34; list objects &#34;&#34;&#34;
        fmt = &#34;%%%ss:&#34; % max(10,max([len(n) for n in self.names])+2)
        print(&#39;REGION container &#34;%s&#34; with %d objects&#39; % (self.name,self.nobjects))
        for o in self.objects.keys():
            print(fmt % self.objects[o].name,&#34;%-10s&#34; % self.objects[o].kind,
                  &#34;(beadtype=%d,object index=[%d,%d])&#34; % \
                      (self.objects[o].beadtype,
                       self.objects[o].index,
                       self.objects[o].subindex))

    # NAMES method set as an attribute ----------------------------
    @property
    def names(self):
        &#34;&#34;&#34; return the names of objects sorted as index &#34;&#34;&#34;
        namesunsorted=namessorted=list(self.objects.keys())
        nobj = len(namesunsorted)
        if nobj&lt;1:
            return []
        elif nobj&lt;2:
            return namessorted
        else:
            for iobj in range(nobj):
                namessorted[self.objects[namesunsorted[iobj]].index-1] = namesunsorted[iobj]
            return namessorted

    # NBEADS method set as an attribute
    @property
    def nbeads(self):
        &#34;return the number of beadtypes used&#34;
        if len(self)&gt;0:
            guess = max(len(self.count()),self.live.nbeads)
            return guess+1 if self.isspacefilled else guess
        else:
            return self.live.nbeads

    # COUNT method
    def count(self):
        &#34;&#34;&#34; count objects by type &#34;&#34;&#34;
        typlist = []
        for  o in self.names:
            if isinstance(self.objects[o].beadtype,list):
                typlist += self.objects[o].beadtype
            else:
                typlist.append(self.objects[o].beadtype)
        utypes = list(set(typlist))
        c = []
        for t in utypes:
            c.append((t,typlist.count(t)))
        return c

    # BEADTYPES property
    @property
    def beadtypes(self):
        &#34;&#34;&#34; list the beadtypes &#34;&#34;&#34;
        return [ x[0] for x in self.count() ]

    # DELETE method
    def delete(self,name):
        &#34;&#34;&#34; delete object &#34;&#34;&#34;
        if name in self.objects:
            kind = self.objects[name].kind
            del self.objects[name]
            self.nobjects -= 1
            self.counter[kind] -= 1
            self.counter[&#34;all&#34;] -= 1
        else:
            raise NameError(&#34;%s does not exist (use list()) to list valid objects&#34; % name)

    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    #
    # HIGH-LEVEL METHODS
    #
    #
    # These methods are connect PIZZA.REGION() objects with their equivalent
    # as PIZZA.SCRIPT() and PIZZA.PIPESCRIPT() objects and methods.
    #
    # They are essential to PIZZA.REGION(). They do not have equivalent in
    # PIZZA.RASTER(). They use extensively the methods attached to :
    #        PIZZA.REGION.LAMMPSGENERIC()
    #        PIZZA.REGION.COREGEOMETRY()
    #
    # Current real-time rendering relies on
    #   https://andeplane.github.io/atomify/
    # which gives better results than
    #   https://editor.lammps.org/
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

    # EVALUATE algebraic operation on PIZZA.REGION() objects (operation on codes)
    def eval(self,expression,name=None,beadtype = None,
             fake=False,index = None,subindex = None):
        &#34;&#34;&#34;
            evaluates (i.e, combine scripts) an expression combining objects
                R= region(name=&#34;my region&#34;)
                R.eval(o1+o2+...,name=&#39;obj&#39;)
                R.eval(o1|o2|...,name=&#39;obj&#39;)
            R.name will be the resulting object of class region.eval (region.coregeometry)
        &#34;&#34;&#34;
        if not isinstance(expression, coregeometry): raise TypeError(&#34;the argument should be a region.coregeometry&#34;)
        # prepare object creation
        kind = &#34;eval&#34;
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        if index is None: index = self.counter[&#34;all&#34;]
        if subindex is None: subindex = self.counter[kind]
        # create the object E with E for Ellipsoid
        E = Evalgeometry((self.counter[&#34;all&#34;],self.counter[kind]),
                      index=index,subindex=subindex)
        # link expression to E
        if beadtype is not None: E.beadtype = beadtype # bead type (if not defined, default index will apply)
        if name is None: name = expression.name
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        E.name = name
        E.SECTIONS = expression.SECTIONS
        E.USER = expression.USER
        if isinstance(E.SECTIONS,pipescript):
            # set beadtypes for all sections and scripts in the pipeline
            for i in E.SECTIONS.keys():
                for j in range(len(E.SECTIONS[i])):
                    E.SECTIONS[i].USER[j].beadtype = E.beadtype
        E.USER.beadtype = beadtype
        # Create the object if not fake
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[kind] -= 1
            return E
        else:
            self.objects[name] = E
            self.nobjects += 1
            return None

    # PIPESCRIPT method generates a pipe for all objects and sections
    def pipescript(self,printflag=False,verbose=False,verbosity=0):
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        &#34;&#34;&#34; pipescript all objects in the region &#34;&#34;&#34;
        if len(self)&lt;1: return pipescript()
        # execute all objects
        for myobj in self:
            if not isinstance(myobj,Collection): myobj.do(printflag=printflag,verbosity=verbosity)
        # concatenate all objects into a pipe script
        # for collections, only group is accepted
        liste = [x.SECTIONS[&#34;variables&#34;] for x in self if not isinstance(x,Collection) and x.hasvariables] + \
                [x.SECTIONS[&#34;region&#34;]    for x in self if not isinstance(x,Collection) and x.hasregion] + \
                [x.SECTIONS[&#34;create&#34;]    for x in self if not isinstance(x,Collection) and x.hascreate] + \
                [x.SECTIONS[&#34;group&#34;]     for x in self if not isinstance(x,Collection) and x.hasgroup] + \
                [x.SECTIONS[&#34;setgroup&#34;]  for x in self if not isinstance(x,Collection) and x.hassetgroup] + \
                [x.SECTIONS[&#34;move&#34;]      for x in self if not isinstance(x,Collection) and x.hasmove]
        # add the objects within the collection
        for x in self:
            if isinstance(x,Collection): liste += x.group()
        # add the eventual group for the collection
        liste += [x.SECTIONS[&#34;group&#34;] for x in self if isinstance(x,Collection) and x.hasgroup]
        # chain all scripts
        return pipescript.join(liste)

    # SCRIPT add header and footer to PIPECRIPT
    def script(self,live=False, printflag=None, verbose=None, verbosity=None):
        &#34;&#34;&#34; script all objects in the region &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        s = self.pipescript(printflag=printflag,verbose=verbose,verbosity=verbosity).script(printflag=printflag,verbose=verbose,verbosity=verbosity)
        if self.isspacefilled:
            USERspacefilling =regiondata(**self.spacefilling)
            s = LammpsSpacefilling(**USERspacefilling)+s
        if live:
            beadtypes = self.beadtypes
            USER = regiondata(**self.live)
            USER.nbeads = self.nbeads
            USER.mass = &#34;$&#34;
            USER.pair_coeff = &#34;$&#34;
            # list beadtype and prepare  mass, pair_coeff
            beadtypes = [ x[0] for x in self.count() ]
            if self.isspacefilled and self.spacefillingbeadtype not in beadtypes:
                beadtypes = [self.spacefillingbeadtype]+beadtypes
            for b in beadtypes:
                USER.mass += livetemplate[&#34;mass&#34;] % b +&#34;\n&#34;
                USER.pair_coeff += livetemplate[&#34;pair_coeff&#34;] %(b,b) +&#34;\n&#34;
            for b1 in beadtypes:
                for b2 in beadtypes:
                    if b2&gt;b1:
                        USER.pair_coeff += livetemplate[&#34;pair_coeff&#34;] %(b1,b2) +&#34;\n&#34;
            livemode = &#34;dynamic&#34; if self.hasfixmove else &#34;static&#34;
            USER.run =self.livelammps[&#34;options&#34;][livemode][&#34;run&#34;]
            s = LammpsHeader(**USER)+s+LammpsFooter(**USER)
        return s

    # SCRIPTHEADERS add header scripts for initializing script, lattice, box for region
    def scriptHeaders(self, what=[&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;], pipescript=False, **userdefinitions):
        &#34;&#34;&#34;
            Generate and return LAMMPS header scripts for initializing the simulation, defining the lattice,
            and specifying the simulation box for all region objects.

            Parameters:
            - what (list of str): Specifies which scripts to generate. Options are &#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;, &#34;mass&#34; and &#34;preview&#34;.
                                  Multiple scripts can be generated by passing a list of these options.
                                  Default is [&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;].
            - pipescript (bool): If True, the generated scripts are combined with `|` instead of `+`. Default is False.

            Property/pair value
            - nbeads (int): Specifies the number of beads, overriding the default if larger than `self.nbeads`.
                            Default is 1.
            - mass (real value or list): Sets the mass for each bead, overrriding `self.mass`
                            Default is 1.0.


            Returns:
            - object: The combined header scripts as a single object.
                      Header values can be overridden by updating `self.headersData`.

            Raises:
            - Exception: If no valid script options are provided in `what`.

            Example usage:
                sRheader = R.scriptHeaders(&#34;box&#34;).do()  # Generate the box header script.
                sRallheaders = R.scriptHeaders([&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;])  # Generate all headers.

                Example usage without naming parameters:
                sRheader = R.scriptHeaders(&#34;box&#34;)  # &#34;what&#34; specified as &#34;box&#34;, nbeads defaults to 1.

                Example of overriding values
                sRheader = R.scriptHeaders(&#34;lattice&#34;,lattice_style = &#34;$sq&#34;)  # Generate the lattice header script with the overridden value.
        &#34;&#34;&#34;
        # handle overrides
        USERregion = self.headersData + regiondata(**userdefinitions)
        # Fix singletons
        if not isinstance(what, list):
            what = [what]
        # Generate the initialization script
        scripts = []  # Store all generated script objects here
        if &#34;init&#34; in what:
            scripts.append(LammpsHeaderInit(**USERregion))
        # Generate the lattice script
        if &#34;lattice&#34; in what:
            scripts.append(LammpsHeaderLattice(**USERregion))
        # Generate the box script
        if &#34;box&#34; in what:
            scripts.append(LammpsHeaderBox(**USERregion))
            if self.isspacefilled:
                scripts.append(LammpsSpacefilling(**self.spacefilling))
        # Generate the mass script
        if &#34;mass&#34; in what:
            scripts.append(LammpsHeaderMass(**USERregion))
        # Generate the preview script
        if &#34;preview&#34; in what:
            scripts.append(LammpsFooterPreview(**USERregion))
        if not scripts:
            raise Exception(&#39;nothing to do (use: &#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;, &#34;mass&#34; or &#34;preview&#34; within [ ])&#39;)

        # Combine the scripts based on the pipescript flag
        combined_script = scripts[0]  # Initialize the combined script with the first element
        for script in scripts[1:]:
            if pipescript:
                # Combine scripts using the | operator, maintaining pipescript format
                combined_script = combined_script | script  # p_ab = s_a | s_b or p_ab = s_a | p_b
            else:
                # Combine scripts using the + operator, maintaining regular script format
                combined_script = combined_script + script  # s_ab = s_a + s_b
        return combined_script


    def pscriptHeaders(self, what=[&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;], **userdefinitions):
        &#34;&#34;&#34;
        Surrogate method for generating LAMMPS pipescript headers.
        Calls the `scriptHeaders` method with `pipescript=True`.

        Parameters:
        - what (list of str): Specifies which scripts to generate. Options are &#34;init&#34;, &#34;lattice&#34;, and &#34;box&#34;.
                              Multiple scripts can be generated by passing a list of these options.
                              Default is [&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;].
        Property/pair value
        - nbeads (int): Specifies the number of beads, overriding the default if larger than `self.nbeads`.
                        Default is 1.
        - mass (real value or list): Sets the mass for each bead, overrriding `self.mass`
                        Default is 1.0.
        Returns:
        - object: The combined pipescript header scripts as a single object.
        &#34;&#34;&#34;
        # Call scriptHeaders with pipescript=True
        return self.scriptHeaders(what=what, pipescript=True, **userdefinitions)


    # DO METHOD = main static compiler
    def do(self, printflag=False, verbosity=1):
        &#34;&#34;&#34; execute the entire script &#34;&#34;&#34;
        return self.pipescript().do(printflag=printflag, verbosity=verbosity)

    # DOLIVE = fast code generation for online rendering
    def dolive(self):
        &#34;&#34;&#34;
            execute the entire script for online testing
            see: https://editor.lammps.org/
        &#34;&#34;&#34;
        self.livelammps[&#34;file&#34;] = self.script(live=True).tmpwrite()
        if not self.livelammps[&#34;active&#34;]:
            livelammps(self.livelammps[&#34;URL&#34;],new=0)
            self.livelammps[&#34;active&#34;] = True
        return self.livelammps[&#34;file&#34;]

# %% scatter class and emulsion class
#    Simplified scatter and emulsion generator
#    generalized from its 2D version in raster.scatter and raster.emulsion
#    added on 2023-03-10

class scatter():
    &#34;&#34;&#34; generic top scatter class &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        The scatter class provides an easy constructor
        to distribute in space objects according to their
        positions x,y,z size r (radius) and beadtype.

        The class is used to derive emulsions.

        Returns
        -------
        None.
        &#34;&#34;&#34;
        self.x = np.array([],dtype=int)
        self.y = np.array([],dtype=int)
        self.z = np.array([],dtype=int)
        self.r = np.array([],dtype=int)
        self.beadtype = []

    @property
    def n(self):
        return len(self.x)

    def pairdist(self,x,y,z):
        &#34;&#34;&#34; pair distance to the surface of all disks/spheres &#34;&#34;&#34;
        if self.n==0:
            return np.Inf
        else:
            return np.sqrt((x-self.x)**2+(y-self.y)**2+(z-self.z)**2)-self.r


class emulsion(scatter):
    &#34;&#34;&#34; emulsion generator &#34;&#34;&#34;

    def __init__(self, xmin=10, ymin=10, zmin=10, xmax=90, ymax=90, zmax=90,
                 maxtrials=1000, beadtype=1, forcedinsertion=True):
        &#34;&#34;&#34;


        Parameters
        ----------
        The insertions are performed between xmin,ymin and xmax,ymax
        xmin : int64 or real, optional
            x left corner. The default is 10.
        ymin : int64 or real, optional
            y bottom corner. The default is 10.
        zmin : int64 or real, optional
            z bottom corner. The default is 10.
        xmax : int64 or real, optional
            x right corner. The default is 90.
        ymax : int64 or real, optional
            y top corner. The default is 90.
        zmax : int64 or real, optional
            z top corner. The default is 90.
        beadtype : default beadtype to apply if not precised at insertion
        maxtrials : integer, optional
            Maximum of attempts for an object. The default is 1000.
        forcedinsertion : logical, optional
            Set it to true to force the next insertion. The default is True.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        super().__init__()
        self.xmin, self.xmax, self.ymin, self.ymax, self.zmin, self.zmax = xmin, xmax, ymin, ymax, zmin, zmax
        self.lastinsertion = (None,None,None,None,None) # x,y,z,r, beadtype
        self.length = xmax-xmin
        self.width = ymax-ymin
        self.height = zmax-zmin
        self.defautbeadtype = beadtype
        self.maxtrials = maxtrials
        self.forcedinsertion = forcedinsertion

    def __repr__(self):
        print(f&#34; Emulsion object\n\t{self.length}x{self.width}x{self.height} starting at x={self.xmin}, y={self.ymin}, z={self.zmin}&#34;)
        print(f&#34;\tcontains {self.n} insertions&#34;)
        print(&#34;\tmaximum insertion trials:&#34;, self.maxtrials)
        print(&#34;\tforce next insertion if previous fails:&#34;, self.forcedinsertion)
        return f&#34;emulsion with {self.n} insertions&#34;


    def walldist(self,x,y,z):
        &#34;&#34;&#34; shortest distance to the wall &#34;&#34;&#34;
        return min(abs(x-self.xmin),abs(y-self.ymin),abs(z-self.zmin),abs(x-self.xmax),abs(y-self.ymax),abs(z-self.zmax))

    def dist(self,x,y,z):
        &#34;&#34;&#34; shortest distance of the center (x,y) to the wall or any object&#34;&#34;&#34;
        return np.minimum(np.min(self.pairdist(x,y,z)),self.walldist(x,y,z))

    def accepted(self,x,y,z,r):
        &#34;&#34;&#34; acceptation criterion &#34;&#34;&#34;
        return self.dist(x,y,z)&gt;r

    def rand(self):
        &#34;&#34;&#34; random position x,y  &#34;&#34;&#34;
        return  np.random.uniform(low=self.xmin,high=self.xmax), \
                np.random.uniform(low=self.ymin,high=self.ymax),\
                np.random.uniform(low=self.zmin,high=self.zmax)

    def setbeadtype(self,beadtype):
        &#34;&#34;&#34; set the default or the supplied beadtype  &#34;&#34;&#34;
        if beadtype == None:
            self.beadtype.append(self.defautbeadtype)
            return self.defautbeadtype
        else:
            self.beadtype.append(beadtype)
            return beadtype

    def insertone(self,x=None,y=None,z=None,r=None,beadtype=None,overlap=False):
        &#34;&#34;&#34;
            insert one object of radius r
            properties:
                x,y,z coordinates (if missing, picked randomly from uniform distribution)
                r radius (default = 2% of diagonal)
                beadtype (default = defautbeadtype)
                overlap = False (accept only if no overlap)
        &#34;&#34;&#34;
        attempt, success = 0, False
        random = (x==None) or (y==None) or (z==None)
        if r==None:
            r = 0.02*np.sqrt(self.length**2+self.width**2+self.height**2)
        while not success and attempt&lt;self.maxtrials:
            attempt += 1
            if random: x,y,z = self.rand()
            if overlap:
                success = True
            else:
                success = self.accepted(x,y,z,r)
        if success:
            self.x = np.append(self.x,x)
            self.y = np.append(self.y,y)
            self.z = np.append(self.z,z)
            self.r = np.append(self.r,r)
            b=self.setbeadtype(beadtype)
            self.lastinsertion = (x,y,z,r,b)
        return success

    def insertion(self,rlist,beadtype=None):
        &#34;&#34;&#34;
            insert a list of objects
                nsuccess=insertion(rlist,beadtype=None)
                beadtype=b forces the value b
                if None, defaultbeadtype is used instead
        &#34;&#34;&#34;
        rlist.sort(reverse=True)
        ntodo = len(rlist)
        n = nsuccess = 0
        stop = False
        while not stop:
            n += 1
            success = self.insertone(r=rlist[n-1],beadtype=beadtype)
            if success: nsuccess += 1
            stop = (n==ntodo) or (not success and not self.forcedinsertion)
        if nsuccess==ntodo:
            print(f&#34;{nsuccess} objects inserted successfully&#34;)
        else:
            print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
        return nsuccess



# %% debug section - generic code to test methods (press F5)
# ===================================================
# main()
# ===================================================
# for debugging purposes (code called as a script)
# the code is called from here
# ===================================================
if __name__ == &#39;__main__&#39;:

    R = region(name=&#34;my region&#34;, mass=2, density=5)
    # Create a Block object using the block method of the region container with specific dimensions
    R.block(xlo=0, xhi=10, ylo=0, yhi=10, zlo=0, zhi=10, name=&#34;B1&#34;,mass=3)
    # Access the natoms property of the Block object
    print(&#34;Number of atoms in the block:&#34;, R.B1.natoms)

    # early example
    a=region(name=&#34;region A&#34;)
    b=region(name=&#34;region B&#34;)
    c = [a,b]
    # step 1
    R = region(name=&#34;my region&#34;)
    R.ellipsoid(0, 0, 0, 1, 1, 1,name=&#34;E1&#34;,toto=3)
    R
    repr(R.E1)
    R.E1.VARIABLES.a=1
    R.E1.VARIABLES.b=2
    R.E1.VARIABLES.c=&#34;(${a},${b},100)&#34;
    R.E1.VARIABLES.d = &#39;&#34;%s%s&#34; %(&#34;test&#34;,${c}) # note that test could be replaced by any function&#39;
    R.E1
    code1 = R.E1.do()
    print(code1)
    # step 2
    R.ellipsoid(0,0,0,1,1,1,name=&#34;E2&#34;,side=&#34;out&#34;,move=[&#34;left&#34;,&#34;${up}*3&#34;,None],up=0.1)
    R.E2.VARIABLES.left = &#39;&#34;swiggle(%s,%s,%s)&#34;%(${a},${b},${c})&#39;
    R.E2.VARIABLES.a=&#34;${b}-5&#34;
    R.E2.VARIABLES.b=5
    R.E2.VARIABLES.c=100
    code2 = R.E2.do()
    print(R)
    repr(R.E2)
    print(code2)
    print(R.names)
    R.list()

    # eval objects
    R.set(&#39;E3&#39;,R.E2)
    R.E3.beadtype = 2
    R.set(&#39;add&#39;,R.E1 + R.E2)
    R.addd2 = R.E1 + R.E2
    R.eval(R.E1 | R.E2,&#39;E12&#39;)


    # How to manage pipelines
    print(&#34;\n&#34;,&#34;-&#34;*20,&#34;pipeline&#34;,&#34;-&#34;*20)
    p = R.E2.script
    s = p.script() # first execution
    s = p.script() # do nothing
    s # check

    # reorganize scripts
    print(&#34;\n&#34;,&#34;-&#34;*20,&#34;change order&#34;,&#34;-&#34;*20)
    p.clear() # undo executions first
    q = p[[0,2,1]]
    sq = q.script()
    print(q.do())

    # join sections
    liste = [x.SECTIONS[&#34;variables&#34;] for x in R]
    pliste = pipescript.join(liste)


    # Example closer to production
    P = region(name=&#34;live test&#34;,width = 20)
    P.ellipsoid(0, 0, 0, &#34;${Ra}&#34;, &#34;${Rb}&#34;, &#34;${Rc}&#34;,
              name=&#34;E1&#34;, Ra=5,Rb=2,Rc=3)
    P.sphere(7,0,0,radius=&#34;${R}&#34;,name = &#34;S1&#34;, R=2)
    cmd = P.do()
    print(cmd)
    #outputfile = P.dolive()

    # EXAMPLE: gel compression
    scale = 1
    name = [&#39;top&#39;,&#39;food&#39;,&#39;tongue&#39;,&#39;bottom&#39;]
    radius = [10,5,8,10]
    height = [1,4,3,1]
    spacer = 2 * scale
    radius = [r*scale for r in radius]
    height = [h*scale for h in height]
    position_original = [spacer+height[1]+height[2]+height[3],
                          height[2]+height[3],
                          height[3],
                          0]
    beadtype = [1,2,3,1]
    total_height = sum(height) +spacer
    position = [x-total_height/2 for x in position_original]
    B = region(name = &#39;region container&#39;,
                width=2*max(radius),
                height=total_height,
                depth=2*max(radius))
    for i in range(len(name)):
        B.cylinder(name = name[i],
                    c1=0,
                    c2=0,
                    radius=radius[i],
                    lo=position[i],
                    hi=position[i]+height[i],
                    beadtype=beadtype[i])
    B.dolive()

    # Draft for workshop
    sB = B.do()
    b1 = B[0].scriptobject()
    b2 = B[1].scriptobject()
    b3 = B[2].scriptobject()
    b4 = B[3].scriptobject()
    collection = b1 + b2 + b3 + b4;

    # # emulsion example
    scale = 1 # tested up to scale = 10 to reach million of beads
    mag = 3
    e = emulsion(xmin=-5*mag, ymin=-5*mag, zmin=-5*mag,xmax=5*mag, ymax=5*mag, zmax=5*mag)
    e.insertion([2,2,2,1,1.6,1.2,1.4,1.3],beadtype=3)
    e.insertion([0.6,0.3,2,1.5,1.5,1,2,1.2,1.1,1.3],beadtype=1)
    e.insertion([3,1,2,2,4,1,1.2,2,2.5,1.2,1.4,1.6,1.7],beadtype=2)
    e.insertion([3,1,2,2,4,1,5.2,2,4.5,1.2,1.4,1.6,1.7],beadtype=4)

    # b = region()
    # a = region()
    # a.sphere(1,1,1,1,name=&#39;sphere1&#39;)
    # a.sphere(1,2,2,1,name=&#39;sphere2&#39;)
    # b.collection(a, name=&#39;acollection&#39;)

    C = region(name=&#39;cregion&#39;,width=11*mag,height=11*mag,depth=11*mag)
    C.scatter(e)
    C.script()
    g = C.emulsion.group()
    C.dolive()


    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    #             F O R   P R O D U C T I O N
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    # History: 2024-07-04 (first version), 2024-07-29 (update), 2024-09-01 (community, per request)

    &#34;&#34;&#34;
=== [  S Y N O P S I S  ] ===
This script provides a detailed example of simulating gel compression using cylindrical objects
within a defined region, employing SI units. The example is designed for production and includes
steps to create, script, and visualize the simulation setup using LAMMPS-compatible scripts.

Key Features:
1. **Geometry Setup**:
    - Four cylindrical objects (&#39;top&#39;, &#39;food&#39;, &#39;tongue&#39;, &#39;bottom&#39;) are defined with specific radii
      and heights.
    - The cylinders are positioned within a central container, with spacing determined by a spacer
      element.
    - The total height of the system is calculated, and the objects are centered within the region.

2. **Forcefield Assignment**:
    - Each object is assigned a bead type and grouped with attributes such as rigidity or softness.
    - Custom forcefields are applied to each object, simulating different physical properties like
      rigid walls or soft materials.

3. **Region Definition**:
    - A simulation region is created with specific dimensions, accounting for the maximum radius of
      the cylinders and the total height of the system.
    - The region is defined in SI units, with additional parameters like separation distance and
      lattice scale.

4. **Script Generation**:
    - The script converts the defined region and objects into LAMMPS-compatible code.
    - Header scripts for initialization, lattice, and the bounding box are generated.
    - The example emphasizes the flexibility in scripting, allowing dynamic reordering and
      combination of scripts.

5. **Execution and Visualization**:
    - The region setup is executed for visualization purposes, enabling control and inspection of
      the geometry.
    - The geometry details, including an estimation of the number of atoms, are provided for
      further analysis.

This example showcases how to effectively set up a gel compression simulation, highlighting key
aspects of geometry definition, forcefield application, and scripting for simulation execution.
&#34;&#34;&#34;

    # EXAMPLE: gel compression with SI units
    name = [&#39;top&#39;, &#39;food&#39;, &#39;tongue&#39;, &#39;bottom&#39;]
    radius = [10e-3, 5e-3, 8e-3, 10e-3]  # in m
    height = [1e-3, 4e-3, 3e-3, 1e-3]  # in m
    spacer = 2e-3  # in m

    # Calculate positions in SI units (meters)
    position_original = [
        spacer + height[1] + height[2] + height[3],
        height[2] + height[3],
        height[3],
        0
    ]
    total_height = sum(height) + spacer * 1e-3  # converting spacer to meters

    # Center positions around the middle of the container
    position = [x - total_height / 2 for x in position_original]

    # information for beads
    # add attributes to forcefields to match your needs or derive new forcefields
    beadtypes = [1, 2, 3, 1]
    groups = [[&#34;rigid&#34;,&#34;wall1&#34;],[&#34;food1&#34;,&#34;soft&#34;],[&#34;food2&#34;,&#34;soft&#34;],[&#34;rigid&#34;,&#34;wall2&#34;]]
    forcefields = [rigidwall(),solidfood(),solidfood(),rigidwall()]

    # Create the region container with SI units
    R = region(
        name=&#39;region container&#39;,
        width=2 * max(radius),
        height=total_height,
        depth=2 * max(radius),
        regionunits=&#34;si&#34;,
        separationdistance=100e-6,  # 50 µm
        lattice_scale=100e-6  # 50 µm
    )

    # Add cylinders to the region R
    # the objects are added &#34;statically&#34;
    # since they contain variables a do() is required to make them a script
    nobjects = len(name)
    for i in range(nobjects):
        R.cylinder(
            name=name[i],
            dim=&#34;z&#34;,  # Assuming z-axis as the dimension
            c1=0,
            c2=0,
            radius=radius[i],
            lo=position[i],
            hi=position[i] + height[i],
            beadtype=beadtypes[i],
            style=&#34;smd&#34;,      # the script oject properties
            group=groups[i],  # can be defined in the geometry or
            forcefield=forcefields[i] # when scriptoject() is called
        )

    # Compile statically all objects
    # sR contains the LAMMPS code to generate all region objects and their atoms
    # sR is a string, all variables have been executed
    sR = R.do() # this line force the execution of R

    # Header Scripts facilitate the deployment and initialization of region objects.
    # ------------- Summary ---------------
    # Available scripts include &#34;init&#34;, &#34;lattice&#34;, and &#34;box&#34;.
    # Multiple scripts can be generated simultaneously by specifying them in a list.
    #   For example: [&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;] will generate all three scripts.
    # Script parameters and variables can be customized via R.headersData.
    #   For instance: R.headersData.lattice_style = &#34;$sq&#34;
    #   This overrides the lattice style, which was originally set in the region object.
    #   The &#34;$&#34; prefix indicates that lattice_style is a static value.
    #   Alternatively, R.headersData.lattice_style = [&#34;sq&#34;] can also be used.
    # --------------------------------------
    # use help(R.scriptHeaders) to get a full help
    # Note: sRheader is a string since a do()
    sRheader = R.scriptHeaders(&#34;box&#34;).do() # generate the box that contains R
    print(sRheader)
    # To generate all header scripts in the specified order, use R.scriptHeaders.
    # Note: sRallheaders is a script object. Use sRallheaders.do() to convert it into a string.
    # Scripts can be dynamically combined using the + operator or statically with the &amp; operator.
    # Scripts can also be combined with pipescripts using the + or | (piped) operator.
    # Region and collection objects are considered pipescripts.
    #
    # Comment on the differences between scripts and pipescripts:
    #   - Scripts operate within a single variable space and cannot be reordered once combined.
    #   - Pipescripts, however, include both global and local variable spaces and can be reordered,
    #     and indexed, offering greater flexibility in complex simulations.
    #
    # A property can be removed from the initialization process by setting it to None or &#34;&#34;
    # In this example, atom_style is removed as it also set with forcefields
    R.headersData.atom_style = None
    sRallheaders = R.scriptHeaders([&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;] )

    # Generate information on beads from the scripted objects
    # note that scriptobject is a method of script extended to region
    # the region must have been preallably scripted, which has been done with &#34;sR = R.do()&#34;
    # Note that the current implementation include also style definitions in init
    b = []
    for i in range(nobjects):
        # style, group and forcefield can be overdefined if needed
        b.append(R[i].scriptobject(style=&#34;smd&#34;))
    collection = b[0] + b[1] + b[2] + b[3]

    # The script corresponding to the collection is given by:
    # scollection is an object of the class script
    # its final execution can be still affected by variables
    scollection = collection.script.do()

    # Execute the region setup only for visualization (control only)
    R.dolive()

    # The detail of the geometry with an estimation of the number of atoms (control only)
    R.geometry

    # to be continued as in the previous workshops
    # sRheader, sR and scollection can be concatenated (they are strings)
    # Note that scripts can be concatenated before do()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="region.cleanname"><code class="name flex">
<span>def <span class="ident">cleanname</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">cleanname = lambda name: &#34;&#34;.join([x for x in name if x!=&#34;$&#34;])</code></pre>
</details>
</dd>
<dt id="region.span"><code class="name flex">
<span>def <span class="ident">span</span></span>(<span>vector, sep=' ', left='', right='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def span(vector,sep=&#34; &#34;,left=&#34;&#34;,right=&#34;&#34;):
    return left + (vector if isinstance(vector, str) else sep.join(map(str, vector))) + right if vector is not None else &#34;&#34;</code></pre>
</details>
</dd>
<dt id="region.wrap"><code class="name flex">
<span>def <span class="ident">wrap</span></span>(<span>k, op, v, indent, width, maxwidth)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">wrap = lambda k,op,v,indent,width,maxwidth: fill(
        shorten(v,width=maxwidth+indent,
        fix_sentence_endings=True),
        width=width+indent,
        initial_indent=&#34; &#34;*(indent-len(k)-len(op)-2)+f&#39;{k} {op} &#39;,
        subsequent_indent=&#39; &#39;*(indent+(1 if v[0]==&#39;&#34;&#39; else 0) )
        )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="region.AttrErrorDict"><code class="flex name class">
<span>class <span class="ident">AttrErrorDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom dictionary that raises AttributeError (as required for the logic of struct)
instead of KeyError for missing keys and strips quotes from strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttrErrorDict(dict):
    &#34;&#34;&#34;Custom dictionary that raises AttributeError (as required for the logic of struct)
       instead of KeyError for missing keys and strips quotes from strings.&#34;&#34;&#34;
    def __getitem__(self, key):
        try:
            value = super().__getitem__(key)
            if isinstance(value, str):
                # Strip surrounding single or double quotes if present
                if (value.startswith(&#34;&#39;&#34;) and value.endswith(&#34;&#39;&#34;)) or (value.startswith(&#39;&#34;&#39;) and value.endswith(&#39;&#34;&#39;)):
                    return value[1:-1]
                return value
            return value
        except KeyError:
            raise AttributeError(f&#34;Attribute &#39;{key}&#39; not found&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
<dt id="region.Block"><code class="flex name class">
<span>class <span class="ident">Block</span></span>
<span>(</span><span>counter, index=None, subindex=None, mass=1, density=1, lattice_style='sc', lattice_scale=1, lattice_scale_siunits=1, hasgroup=False, hasmove=False, spacefilling=False, style=None, group=None, forcefield=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>Block class </p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Block(coregeometry):
    &#34;&#34;&#34; Block class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;block%03d&#34; % counter[1]
        self.kind = &#34;block&#34;     # kind of object
        self.alike = &#34;block&#34;    # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density

        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$block&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        &#34;&#34;&#34;Calculate the volume of the block based on USER.args&#34;&#34;&#34;
        #args = [xlo, xhi, ylo, yhi, zlo, zhi]
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            xlo = float(args[0])
            xhi = float(args[1])
            ylo = float(args[2])
            yhi = float(args[3])
            zlo = float(args[4])
            zhi = float(args[5])

            # Calculate the dimensions of the block
            length = xhi - xlo
            width = yhi - ylo
            height = zhi - zlo

            # Calculate the volume of the block
            volume = length * width * height
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="region.Block.volume"><code class="name flex">
<span>def <span class="ident">volume</span></span>(<span>self, units=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the volume of the block based on USER.args</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volume(self,units=None):
    &#34;&#34;&#34;Calculate the volume of the block based on USER.args&#34;&#34;&#34;
    #args = [xlo, xhi, ylo, yhi, zlo, zhi]
    try:
        # Extract the arguments from USER.args
        args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
        xlo = float(args[0])
        xhi = float(args[1])
        ylo = float(args[2])
        yhi = float(args[3])
        zlo = float(args[4])
        zhi = float(args[5])

        # Calculate the dimensions of the block
        length = xhi - xlo
        width = yhi - ylo
        height = zhi - zlo

        # Calculate the volume of the block
        volume = length * width * height
        return volume
    except Exception as e:
        print(f&#34;Error calculating volume: {e}&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.Collection"><code class="flex name class">
<span>class <span class="ident">Collection</span></span>
<span>(</span><span>counter, name=None, index=None, subindex=None, hasgroup=False, USER=region data (RD object) with 0 definitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Collection class (including many objects)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Collection:
    &#34;&#34;&#34;
        Collection class (including many objects)
    &#34;&#34;&#34;
    _version = &#34;0.31&#34;
    __custom_documentations__ = &#34;pizza.region.Collection class&#34;

    # CONSTRUCTOR
    def __init__(self,counter,
                 name=None,
                 index = None,
                 subindex = None,
                 hasgroup = False,
                 USER = regiondata()):
        if (name is None) or (name==&#34;&#34;):
            self.name = &#34;collect%03d&#34; % counter[1]
        elif name in self:
            raise KeyError(f&#39;the name &#34;{name}&#34; already exist&#39;)
        else:
            self.name = name
        if not isinstance(USER,regiondata):
            raise TypeError(&#34;USER should be a regiondata object&#34;)
        USER.groupID = &#34;$&#34;+self.name # the content is frozen
        USER.ID = &#34;&#34;
        self.USER = USER
        self.kind = &#34;collection&#34;    # kind of object
        self.alike = &#34;mixed&#34;        # similar object for plotting
        self.index = counter[0] if index is None else index
        self.subindex = counter[1]
        self.collection = regioncollection()
        self.SECTIONS = {
                &#39;group&#39;: LammpsCollectionGroup(**USER)
        }
        self.FLAGSECTIONS = {&#34;group&#34;: hasgroup}

    def update(self):
        &#34;&#34;&#34; update the USER content for the script &#34;&#34;&#34;
        if isinstance(self.SECTIONS[&#34;group&#34;],script):
            self.USER.ID = &#34;$&#34;\
                +span([groupprefix+x for x in self.list()]) # the content is frozen
            self.SECTIONS[&#34;group&#34;].USER += self.USER

    def creategroup(self):
        &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
        for o in self.collection: o.creategroup()
        self.update()
        self.FLAGSECTIONS[&#34;group&#34;] = True

    def removegroup(self,recursive=True):
        &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
        if recursive:
            for o in self.collection: o.removegroup()
        self.FLAGSECTIONS[&#34;group&#34;] = False

    @property
    def hasgroup(self):
        &#34;&#34;&#34; return the flag hasgroup &#34;&#34;&#34;
        return self.FLAGSECTIONS[&#34;group&#34;]

    @property
    def flags(self):
        &#34;&#34;&#34; return a list of all flags that are currently set &#34;&#34;&#34;
        flag_names = list(self.SECTIONS.keys())
        return [flag for flag in flag_names if getattr(self, f&#34;has{flag}&#34;)]

    @property
    def shortflags(self):
        &#34;&#34;&#34; return a string made from the first letter of each set flag &#34;&#34;&#34;
        return &#34;&#34;.join([flag[0] for flag in self.flags])

    @property
    def script(self):
        &#34;&#34;&#34; generates a pipe script from SECTIONS &#34;&#34;&#34;
        self.update()
        return self.SECTIONS[&#34;group&#34;]

    def __repr__(self):
        keylengths = [len(key) for key in self.collection.keys()]
        width = max(10,max(keylengths)+2)
        fmt = &#34;%%%ss:&#34; % width
        line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
        print(line,&#34;  %s - %s object&#34; % (self.name, self.kind), line,sep=&#34;\n&#34;)
        for key,value in self.collection.items():
            flags = &#34;(&#34;+self.collection[key].shortflags+&#34;)&#34; if self.collection[key].flags else &#34;(no script)&#34;
            print(fmt % key,value.kind,
                  &#39;&#34;%s&#34;&#39; % value.name,&#34; &gt; &#34;,flags)
        flags = self.flags
        if flags: print(line,f&#39;defined scripts: {span(flags,sep=&#34;,&#34;)}&#39;,sep=&#34;\n&#34;)
        print(line)
        return &#34;%s object: %s (beadtype=[%s])&#34; % (self.kind,self.name,&#34;, &#34;.join(map(str,self.beadtype)))

    # GET -----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.collection:
            return self.collection.getattr(name)
        elif name in [&#34;collection&#34;,&#34;hasgroup&#34;,&#34;flags&#34;,&#34;shortflags&#34;,&#34;script&#34;]:
            return getattr(self,name)
        else:
            raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # GETATTR --------------------------
    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return self.get(key)

    @property
    def beadtype(self):
        &#34;&#34;&#34; returns the beadtypes used in the collection &#34;&#34;&#34;
        b = []
        for o in self.collection:
            if o.beadtype not in b:
                b.append(o.beadtype)
        if len(b)==0:
            return 1
        else:
            return b

    # GROUP -------------------------------
    def group(self):
        &#34;&#34;&#34; return the grouped coregeometry object &#34;&#34;&#34;
        if len(self) == 0:return pipescript()
        # execute all objects
        for i in range(len(self)): self.collection[i].do()
        # concatenate all objects into a pipe script
        liste = [x.SECTIONS[&#34;variables&#34;] for x in self.collection if x.hasvariables] + \
                [x.SECTIONS[&#34;region&#34;]    for x in self.collection if x.hasregion] + \
                [x.SECTIONS[&#34;create&#34;]    for x in self.collection if x.hascreate] + \
                [x.SECTIONS[&#34;group&#34;]     for x in self.collection if x.hasgroup] + \
                [x.SECTIONS[&#34;setgroup&#34;]  for x in self.collection if x.hassetgroup] + \
                [x.SECTIONS[&#34;move&#34;]      for x in self.collection if x.hasmove]
        return pipescript.join(liste)

    # LEN ---------------------------------
    def __len__(self):
        &#34;&#34;&#34; return length of collection &#34;&#34;&#34;
        return len(self.collection)

    # LIST ---------------------------------
    def list(self):
        &#34;&#34;&#34; return the list of objects &#34;&#34;&#34;
        return self.collection.keys()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="region.Collection.beadtype"><code class="name">var <span class="ident">beadtype</span></code></dt>
<dd>
<div class="desc"><p>returns the beadtypes used in the collection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beadtype(self):
    &#34;&#34;&#34; returns the beadtypes used in the collection &#34;&#34;&#34;
    b = []
    for o in self.collection:
        if o.beadtype not in b:
            b.append(o.beadtype)
    if len(b)==0:
        return 1
    else:
        return b</code></pre>
</details>
</dd>
<dt id="region.Collection.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><p>return a list of all flags that are currently set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flags(self):
    &#34;&#34;&#34; return a list of all flags that are currently set &#34;&#34;&#34;
    flag_names = list(self.SECTIONS.keys())
    return [flag for flag in flag_names if getattr(self, f&#34;has{flag}&#34;)]</code></pre>
</details>
</dd>
<dt id="region.Collection.hasgroup"><code class="name">var <span class="ident">hasgroup</span></code></dt>
<dd>
<div class="desc"><p>return the flag hasgroup</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hasgroup(self):
    &#34;&#34;&#34; return the flag hasgroup &#34;&#34;&#34;
    return self.FLAGSECTIONS[&#34;group&#34;]</code></pre>
</details>
</dd>
<dt id="region.Collection.script"><code class="name">var <span class="ident">script</span></code></dt>
<dd>
<div class="desc"><p>generates a pipe script from SECTIONS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def script(self):
    &#34;&#34;&#34; generates a pipe script from SECTIONS &#34;&#34;&#34;
    self.update()
    return self.SECTIONS[&#34;group&#34;]</code></pre>
</details>
</dd>
<dt id="region.Collection.shortflags"><code class="name">var <span class="ident">shortflags</span></code></dt>
<dd>
<div class="desc"><p>return a string made from the first letter of each set flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shortflags(self):
    &#34;&#34;&#34; return a string made from the first letter of each set flag &#34;&#34;&#34;
    return &#34;&#34;.join([flag[0] for flag in self.flags])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.Collection.creategroup"><code class="name flex">
<span>def <span class="ident">creategroup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>force the group creation in script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def creategroup(self):
    &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
    for o in self.collection: o.creategroup()
    self.update()
    self.FLAGSECTIONS[&#34;group&#34;] = True</code></pre>
</details>
</dd>
<dt id="region.Collection.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self,name):
    &#34;&#34;&#34; returns the object &#34;&#34;&#34;
    if name in self.collection:
        return self.collection.getattr(name)
    elif name in [&#34;collection&#34;,&#34;hasgroup&#34;,&#34;flags&#34;,&#34;shortflags&#34;,&#34;script&#34;]:
        return getattr(self,name)
    else:
        raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)</code></pre>
</details>
</dd>
<dt id="region.Collection.group"><code class="name flex">
<span>def <span class="ident">group</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the grouped coregeometry object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group(self):
    &#34;&#34;&#34; return the grouped coregeometry object &#34;&#34;&#34;
    if len(self) == 0:return pipescript()
    # execute all objects
    for i in range(len(self)): self.collection[i].do()
    # concatenate all objects into a pipe script
    liste = [x.SECTIONS[&#34;variables&#34;] for x in self.collection if x.hasvariables] + \
            [x.SECTIONS[&#34;region&#34;]    for x in self.collection if x.hasregion] + \
            [x.SECTIONS[&#34;create&#34;]    for x in self.collection if x.hascreate] + \
            [x.SECTIONS[&#34;group&#34;]     for x in self.collection if x.hasgroup] + \
            [x.SECTIONS[&#34;setgroup&#34;]  for x in self.collection if x.hassetgroup] + \
            [x.SECTIONS[&#34;move&#34;]      for x in self.collection if x.hasmove]
    return pipescript.join(liste)</code></pre>
</details>
</dd>
<dt id="region.Collection.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the list of objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self):
    &#34;&#34;&#34; return the list of objects &#34;&#34;&#34;
    return self.collection.keys()</code></pre>
</details>
</dd>
<dt id="region.Collection.removegroup"><code class="name flex">
<span>def <span class="ident">removegroup</span></span>(<span>self, recursive=True)</span>
</code></dt>
<dd>
<div class="desc"><p>force the group creation in script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removegroup(self,recursive=True):
    &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
    if recursive:
        for o in self.collection: o.removegroup()
    self.FLAGSECTIONS[&#34;group&#34;] = False</code></pre>
</details>
</dd>
<dt id="region.Collection.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>update the USER content for the script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34; update the USER content for the script &#34;&#34;&#34;
    if isinstance(self.SECTIONS[&#34;group&#34;],script):
        self.USER.ID = &#34;$&#34;\
            +span([groupprefix+x for x in self.list()]) # the content is frozen
        self.SECTIONS[&#34;group&#34;].USER += self.USER</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.Cone"><code class="flex name class">
<span>class <span class="ident">Cone</span></span>
<span>(</span><span>counter, index=None, subindex=None, mass=1, density=1, lattice_style='sc', lattice_scale=1, lattice_scale_siunits=1, hasgroup=False, hasmove=False, spacefilling=False, style=None, group=None, forcefield=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>Cone class </p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cone(coregeometry):
    &#34;&#34;&#34; Cone class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;cone%03d&#34; % counter[1]
        self.kind = &#34;cone&#34;     # kind of object
        self.alike = &#34;cone&#34;    # similar object for plotting
        self.beadtype = 1      # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$cone&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        &#34;&#34;&#34;Calculate the volume of the cone based on USER.args&#34;&#34;&#34;
        #args = [dim, c1, c2, radlo, radhi, lo, hi]
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            radius_low = float(args[3])
            radius_high = float(args[4])
            lo = float(args[5])
            hi = float(args[6])
            # Calculate the height of the cone
            height = hi - lo
            # Calculate the volume of the cone (assuming a conical frustum if radii are different)
            if radius_low == radius_high:
                volume = (1/3) * 3.141592653589793 * (radius_low ** 2) * height
            else:
                volume = (1/3) * 3.141592653589793 * height * (radius_low ** 2 + radius_low * radius_high + radius_high ** 2)
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="region.Cone.volume"><code class="name flex">
<span>def <span class="ident">volume</span></span>(<span>self, units=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the volume of the cone based on USER.args</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volume(self,units=None):
    &#34;&#34;&#34;Calculate the volume of the cone based on USER.args&#34;&#34;&#34;
    #args = [dim, c1, c2, radlo, radhi, lo, hi]
    try:
        # Extract the arguments from USER.args
        args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
        radius_low = float(args[3])
        radius_high = float(args[4])
        lo = float(args[5])
        hi = float(args[6])
        # Calculate the height of the cone
        height = hi - lo
        # Calculate the volume of the cone (assuming a conical frustum if radii are different)
        if radius_low == radius_high:
            volume = (1/3) * 3.141592653589793 * (radius_low ** 2) * height
        else:
            volume = (1/3) * 3.141592653589793 * height * (radius_low ** 2 + radius_low * radius_high + radius_high ** 2)
        return volume
    except Exception as e:
        print(f&#34;Error calculating volume: {e}&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.Cylinder"><code class="flex name class">
<span>class <span class="ident">Cylinder</span></span>
<span>(</span><span>counter, index=None, subindex=None, mass=1, density=1, lattice_style='sc', lattice_scale=1, lattice_scale_siunits=1, hasgroup=False, hasmove=False, spacefilling=False, style=None, group=None, forcefield=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>Cylinder class </p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cylinder(coregeometry):
    &#34;&#34;&#34; Cylinder class &#34;&#34;&#34;
    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;cylinder%03d&#34; % counter[1]
        self.kind = &#34;cylinder&#34;     # kind of object
        self.alike = &#34;cylinder&#34;    # similar object for plotting
        self.beadtype = 1          # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$cylinder&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        &#34;&#34;&#34;Calculate the volume of the cylinder based on USER.args&#34;&#34;&#34;
        # args = [dim,c1,c2,radius,lo,hi]
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            radius = float(args[3])
            lo = float(args[4])
            hi = float(args[5])
            # Calculate the height of the cylinder
            height = hi - lo
            # Calculate the volume of the cylinder
            volume = 3.141592653589793 * (radius ** 2) * height
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="region.Cylinder.volume"><code class="name flex">
<span>def <span class="ident">volume</span></span>(<span>self, units=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the volume of the cylinder based on USER.args</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volume(self,units=None):
    &#34;&#34;&#34;Calculate the volume of the cylinder based on USER.args&#34;&#34;&#34;
    # args = [dim,c1,c2,radius,lo,hi]
    try:
        # Extract the arguments from USER.args
        args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
        radius = float(args[3])
        lo = float(args[4])
        hi = float(args[5])
        # Calculate the height of the cylinder
        height = hi - lo
        # Calculate the volume of the cylinder
        volume = 3.141592653589793 * (radius ** 2) * height
        return volume
    except Exception as e:
        print(f&#34;Error calculating volume: {e}&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.Ellipsoid"><code class="flex name class">
<span>class <span class="ident">Ellipsoid</span></span>
<span>(</span><span>counter, index=None, subindex=None, mass=1, density=1, lattice_style='sc', lattice_scale=1, lattice_scale_siunits=1, hasgroup=False, hasmove=False, spacefilling=False, style=None, group=None, forcefield=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>Ellipsoid class </p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ellipsoid(coregeometry):
    &#34;&#34;&#34; Ellipsoid class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;ellipsoid%03d&#34; % counter[1]
        self.kind = &#34;ellipsoid&#34;     # kind of object
        self.alike = &#34;ellipsoid&#34;    # similar object for plotting
        self.beadtype = 1           # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$ellipsoid&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        #args = [x, y, z, a, b, c]
        &#34;&#34;&#34;Calculate the volume of the ellipsoid based on USER.args&#34;&#34;&#34;
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            a = float(args[3])
            b = float(args[4])
            c = float(args[5])
            # Calculate the volume of the ellipsoid
            volume = (4/3) * 3.141592653589793 * a * b * c
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="region.Ellipsoid.volume"><code class="name flex">
<span>def <span class="ident">volume</span></span>(<span>self, units=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the volume of the ellipsoid based on USER.args</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volume(self,units=None):
    #args = [x, y, z, a, b, c]
    &#34;&#34;&#34;Calculate the volume of the ellipsoid based on USER.args&#34;&#34;&#34;
    try:
        # Extract the arguments from USER.args
        args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
        a = float(args[3])
        b = float(args[4])
        c = float(args[5])
        # Calculate the volume of the ellipsoid
        volume = (4/3) * 3.141592653589793 * a * b * c
        return volume
    except Exception as e:
        print(f&#34;Error calculating volume: {e}&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.Evalgeometry"><code class="flex name class">
<span>class <span class="ident">Evalgeometry</span></span>
<span>(</span><span>counter, index=None, subindex=None, hasgroup=False, hasmove=False, spacefilling=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generic class to store evaluated objects with region.eval() </p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Evalgeometry(coregeometry):
    &#34;&#34;&#34; generic class to store evaluated objects with region.eval() &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None,
                 hasgroup=False,hasmove=False,spacefilling=False):
        self.name = &#34;eval%03d&#34; % counter[1]
        self.kind = &#34;eval&#34;      # kind of object
        self.alike = &#34;eval&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        super().__init__(hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.Intersect"><code class="flex name class">
<span>class <span class="ident">Intersect</span></span>
<span>(</span><span>counter, index=None, subindex=None, hasgroup=False, hasmove=False, spacefilling=False, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>Intersect class </p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Intersect(coregeometry):
    &#34;&#34;&#34; Intersect class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None,
                 hasgroup=False,hasmove=False,spacefilling=False,**variables):
        self.name = &#34;intersect%03d&#34; % counter[1]
        self.kind = &#34;intersect&#34;      # kind of object
        self.alike = &#34;operator&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$intersect&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling
                )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsCollectionGroup"><code class="flex name class">
<span>class <span class="ident">LammpsCollectionGroup</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Collection group class based on script </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsCollectionGroup(LammpsGeneric):
    &#34;&#34;&#34; Collection group class based on script &#34;&#34;&#34;
    name = &#34;LammpsCollection Group&#34;
    SECTIONS = [&#34;COLLECTIONGROUP&#34;]
    position = 6
    role = &#34;group command definition for a collection&#34;
    description = &#34;group ID union regionID1 regionID2...&#34;
    userid = &#34;collectionregion&#34;              # user name
    version = 0.3                            # version
    verbose = True

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
               groupID = &#34;$&#34;+groupprefix+&#34;${ID}&#34;, # freeze the interpretation
          hasvariables = False
                    )

    # Template  (ID is spanned over all regionIDs)
    TEMPLATE = &#34;&#34;&#34;
% Create group ${groupID} region ${ID} (URL: https://docs.lammps.org/group.html)
group ${groupID} union ${ID}
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsCollectionGroup.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCollectionGroup.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCollectionGroup.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCollectionGroup.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCollectionGroup.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCollectionGroup.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCollectionGroup.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCollectionGroup.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCollectionGroup.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCollectionGroup.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsCreate"><code class="flex name class">
<span>class <span class="ident">LammpsCreate</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>script for LAMMPS variables section </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsCreate(LammpsGeneric):
    &#34;&#34;&#34; script for LAMMPS variables section &#34;&#34;&#34;
    name = &#34;LammpsCreate&#34;
    SECTIONS = [&#34;create_atoms&#34;]
    position = 4
    role = &#34;create_atoms command&#34;
    description = &#34;create_atoms type style args keyword values ...&#34;
    userid = &#34;create&#34;
    version = 0.1
    verbose = True

    # Definitions used in TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
                 style = &#34;${style}&#34;,
                 hasvariables = False
                    )

    # Template (using % instead of # enables replacements)
    TEMPLATE = &#34;&#34;&#34;
% Create atoms of type ${beadtype} for ${ID} ${style} (https://docs.lammps.org/create_atoms.html)
create_atoms ${beadtype} region ${ID}
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsCreate.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCreate.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCreate.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCreate.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCreate.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCreate.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCreate.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCreate.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCreate.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsCreate.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsFooter"><code class="flex name class">
<span>class <span class="ident">LammpsFooter</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>generic header for pizza.region </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsFooter(LammpsGeneric):
    &#34;&#34;&#34; generic header for pizza.region &#34;&#34;&#34;
    name = &#34;LammpsFooter&#34;
    SECTIONS = [&#34;FOOTER&#34;]
    position = 1000
    role = &#34;footer for live view&#34;
    description = &#34;To be used with https://editor.lammps.org/&#34;
    userid = &#34;footer&#34;              # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
                      run = 1,
             hasvariables = False
                    )

    # Template
    TEMPLATE = &#34;&#34;&#34;
# --------------[  DYNAMICS  ]--------------
${mass}
velocity            all create 1.44 87287 loop geom
pair_style          lj/cut 2.5
${pair_coeff}
neighbor            0.3 bin
neigh_modify    delay 0 every 20 check no
fix                     1 all nve
run                     ${run}
# ------------------------------------------
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsFooter.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooter.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooter.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooter.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooter.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooter.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooter.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooter.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooter.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooter.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsFooterPreview"><code class="flex name class">
<span>class <span class="ident">LammpsFooterPreview</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Box header for pizza.region</p>
<p>Use R.headersData.property = value to assign a value
with R a pizza.region object</p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsFooterPreview(LammpsGeneric): # --- helper script ---
    &#34;&#34;&#34;
        Box header for pizza.region

        Use R.headersData.property = value to assign a value
        with R a pizza.region object
    &#34;&#34;&#34;
    name = &#34;LammpsFooterPreview&#34;
    SECTIONS = [&#34;Footer&#34;]
    position = 0
    role = &#34;box footer for pizza.region&#34;
    description = &#34;helper method&#34;
    userid = &#34;footerpreview&#34;       # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    # circular references (the variable is defined by its field in USER of class regiondata)
    # are not needed but this explicits the requirements.
    # All fields are stored in R.headersData with R a region object.
    # Use R.headersData.property = value to assign a value
    # Extra arguments
    #   ${boxid_arg} is by default &#34;box&#34;
    #   ${boxunits_arg} can be &#34;&#34;, &#34;units lattice&#34;, &#34;units box&#34;
    DEFINITIONS = scriptdata(
                filename = &#34;${previewfilename}&#34;,
            hasvariables = False
                    )

    # Template
    TEMPLATE = &#34;&#34;&#34;
% --------------[ Preview for &lt;${name}:${boxid}&gt; incl. ${nbeads} bead types ]--------------
% Output the initial geometry to a dump file &#34;${previewfilename}&#34; for visualization
dump initial_dump all custom 1 ${previewfilename} id type x y z
run 0
# ------------------------------------------
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsFooterPreview.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooterPreview.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooterPreview.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooterPreview.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooterPreview.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooterPreview.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooterPreview.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooterPreview.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooterPreview.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsFooterPreview.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsGeneric"><code class="flex name class">
<span>class <span class="ident">LammpsGeneric</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>common class to override standard do() method from script
LammpsVariables, LammpsRegion, LammpsCreate are LammpsGeneric
note:: the only difference with the common script class is that
LammpsGeneric accepts VARIABLES AND To SHOW THEM</p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsGeneric(script):
    &#34;&#34;&#34;
        common class to override standard do() method from script
        LammpsVariables, LammpsRegion, LammpsCreate are LammpsGeneric
        note:: the only difference with the common script class is that
        LammpsGeneric accepts VARIABLES AND To SHOW THEM
    &#34;&#34;&#34;
    def do(self,printflag=True,verbose=False):
        &#34;&#34;&#34; generate the LAMMPS code with VARIABLE definitions &#34;&#34;&#34;
        if self.DEFINITIONS.hasvariables and hasattr(self,&#39;VARIABLES&#39;): # attribute VARIABLES checked 2023-08-11
            cmd = f&#34;#[{str(datetime.now())}] {self.name} &gt; {self.SECTIONS[0]}&#34; \
                if verbose else &#34;&#34;
            if len(self.VARIABLES)&gt;0: cmd += \
            self.VARIABLES.generatorforlammps(verbose=verbose,hasvariables=True)
        else:
            cmd = &#34;&#34;
        cmd += super().do(printflag=False,verbose=verbose)
        if printflag: print(cmd)
        return cmd</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.script.script</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="region.LammpsCollectionGroup" href="#region.LammpsCollectionGroup">LammpsCollectionGroup</a></li>
<li><a title="region.LammpsCreate" href="#region.LammpsCreate">LammpsCreate</a></li>
<li><a title="region.LammpsFooter" href="#region.LammpsFooter">LammpsFooter</a></li>
<li><a title="region.LammpsFooterPreview" href="#region.LammpsFooterPreview">LammpsFooterPreview</a></li>
<li><a title="region.LammpsGroup" href="#region.LammpsGroup">LammpsGroup</a></li>
<li><a title="region.LammpsHeader" href="#region.LammpsHeader">LammpsHeader</a></li>
<li><a title="region.LammpsHeaderBox" href="#region.LammpsHeaderBox">LammpsHeaderBox</a></li>
<li><a title="region.LammpsHeaderInit" href="#region.LammpsHeaderInit">LammpsHeaderInit</a></li>
<li><a title="region.LammpsHeaderLattice" href="#region.LammpsHeaderLattice">LammpsHeaderLattice</a></li>
<li><a title="region.LammpsHeaderMass" href="#region.LammpsHeaderMass">LammpsHeaderMass</a></li>
<li><a title="region.LammpsMove" href="#region.LammpsMove">LammpsMove</a></li>
<li><a title="region.LammpsRegion" href="#region.LammpsRegion">LammpsRegion</a></li>
<li><a title="region.LammpsSetGroup" href="#region.LammpsSetGroup">LammpsSetGroup</a></li>
<li><a title="region.LammpsSpacefilling" href="#region.LammpsSpacefilling">LammpsSpacefilling</a></li>
<li><a title="region.LammpsVariables" href="#region.LammpsVariables">LammpsVariables</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="region.LammpsGeneric.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, printflag=True, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generate the LAMMPS code with VARIABLE definitions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self,printflag=True,verbose=False):
    &#34;&#34;&#34; generate the LAMMPS code with VARIABLE definitions &#34;&#34;&#34;
    if self.DEFINITIONS.hasvariables and hasattr(self,&#39;VARIABLES&#39;): # attribute VARIABLES checked 2023-08-11
        cmd = f&#34;#[{str(datetime.now())}] {self.name} &gt; {self.SECTIONS[0]}&#34; \
            if verbose else &#34;&#34;
        if len(self.VARIABLES)&gt;0: cmd += \
        self.VARIABLES.generatorforlammps(verbose=verbose,hasvariables=True)
    else:
        cmd = &#34;&#34;
    cmd += super().do(printflag=False,verbose=verbose)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.LammpsGroup"><code class="flex name class">
<span>class <span class="ident">LammpsGroup</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>generic group class based on script </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsGroup(LammpsGeneric):
    &#34;&#34;&#34; generic group class based on script &#34;&#34;&#34;
    name = &#34;LammpsGroup&#34;
    SECTIONS = [&#34;GROUP&#34;]
    position = 5
    role = &#34;group command definition&#34;
    description = &#34;group ID region regionID&#34;
    userid = &#34;region&#34;              # user name
    version = 0.2                  # version
    verbose = True

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
               groupID = &#34;$&#34;+groupprefix+&#34;${ID}&#34;, # freeze the interpretation
          countgroupID = &#34;$count&#34;+&#34;${groupID}&#34;, # either using $
           grouptoshow = [&#34;${groupID}&#34;], # or []
                 hasvariables = False
                    )

    # Template  (using % instead of # enables replacements)
    TEMPLATE = &#34;&#34;&#34;
% Create group ${groupID} region ${ID} (URL: https://docs.lammps.org/group.html)
group ${groupID} region ${ID}
variable ${countgroupID} equal count(${grouptoshow})
print &#34;Number of atoms in ${groupID}: \${{countgroupID}}&#34;
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsGroup.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsGroup.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsGroup.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsGroup.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsGroup.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsGroup.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsGroup.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsGroup.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsGroup.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsGroup.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsHeader"><code class="flex name class">
<span>class <span class="ident">LammpsHeader</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>generic header for pizza.region </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsHeader(LammpsGeneric):
    &#34;&#34;&#34; generic header for pizza.region &#34;&#34;&#34;
    name = &#34;LammpsHeader&#34;
    SECTIONS = [&#34;HEADER&#34;]
    position = 0
    role = &#34;header for live view&#34;
    description = &#34;To be used with https://editor.lammps.org/&#34;
    userid = &#34;header&#34;              # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
                    width = 10,
                   height = 10,
                    depth = 10,
                    nbeads = 1,
            hasvariables = False
                    )

    # Template
    TEMPLATE = &#34;&#34;&#34;
# --------------[    INIT   ]--------------
# assuming generic LJ units and style
units           ${live_units}
atom_style          ${live_atom_style}
lattice             ${live_lattice_style} ${live_lattice_scale}
# ------------------------------------------

# --------------[    B O X   ]--------------
variable        halfwidth equal ${width}/2
variable        halfheight equal ${height}/2
variable        halfdepth equal ${depth}/2
region box block -${halfwidth} ${halfwidth} -${halfheight} ${halfheight} -${halfdepth} ${halfdepth}
create_box      ${nbeads} box
# ------------------------------------------
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsHeader.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeader.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeader.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeader.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeader.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeader.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeader.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeader.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeader.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeader.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsHeaderBox"><code class="flex name class">
<span>class <span class="ident">LammpsHeaderBox</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Box header for pizza.region</p>
<p>Use R.headersData.property = value to assign a value
with R a pizza.region object</p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsHeaderBox(LammpsGeneric): # --- helper script ---
    &#34;&#34;&#34;
        Box header for pizza.region

        Use R.headersData.property = value to assign a value
        with R a pizza.region object
    &#34;&#34;&#34;
    name = &#34;LammpsHeaderBox&#34;
    SECTIONS = [&#34;HEADER&#34;]
    position = 0
    role = &#34;box header for pizza.region&#34;
    description = &#34;helper method&#34;
    userid = &#34;headerbox&#34;           # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    # circular references (the variable is defined by its field in USER of class regiondata)
    # are not needed but this explicits the requirements.
    # All fields are stored in R.headersData with R a region object.
    # Use R.headersData.property = value to assign a value
    # Extra arguments
    #   ${boxid_arg} is by default &#34;box&#34;
    #   ${boxunits_arg} can be &#34;&#34;, &#34;units lattice&#34;, &#34;units box&#34;
    DEFINITIONS = scriptdata(
                      name = &#34;${name}&#34;,
                      xmin = &#34;${xmin}&#34;,
                      xmax = &#34;${xmax}&#34;,
                      ymin = &#34;${ymin}&#34;,
                      ymax = &#34;${ymax}&#34;,
                      zmin = &#34;${zmin}&#34;,
                      zmax = &#34;${zmax}&#34;,
                    nbeads = &#34;${nbeads}&#34;,
                     boxid = &#34;${boxid}&#34;,
              boxunits_arg = &#34;&#34;,     # default units
            hasvariables = False
                    )

    # Template
    TEMPLATE = &#34;&#34;&#34;
% --------------[ Box for &lt;${name}:${boxid}&gt; incl. ${nbeads} bead types ]--------------
region ${boxid} block ${xmin} ${xmax} ${ymin} ${ymax} ${zmin} ${zmax} ${boxunits_arg}
create_box      ${nbeads} ${boxid}
# ------------------------------------------
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsHeaderBox.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderBox.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderBox.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderBox.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderBox.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderBox.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderBox.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderBox.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderBox.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderBox.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsHeaderInit"><code class="flex name class">
<span>class <span class="ident">LammpsHeaderInit</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an initialization header script for a pizza.region object in LAMMPS.</p>
<p>This class constructs a LAMMPS header based on user-defined properties stored
in <code>R.headersData</code> of the pizza.region object. Properties set to <code>None</code> or an
empty string will be omitted from the script.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>DEFINITIONS</code></strong></dt>
<dd>Defines the parameters like dimension, units, boundary, etc.,</dd>
</dl>
<p>that can be set in <code>R.headersData</code>.</p>
<h2 id="methods">Methods</h2>
<p><strong>init</strong>(persistentfile=True, persistentfolder=None, **userdefinitions):
Initializes the header script and sets up the <code>USER</code> attribute.</p>
<p>generate_template():
Creates the header template based on the provided <code>USER</code> definitions.</p>
<p>Note: This class is primarily intended for internal use within the simulation setup.</p>
<p>Constructor adding instance definitions stored in USER.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsHeaderInit(LammpsGeneric): # --- helper script ---
    &#34;&#34;&#34;
    Generates an initialization header script for a pizza.region object in LAMMPS.

    This class constructs a LAMMPS header based on user-defined properties stored
    in `R.headersData` of the pizza.region object. Properties set to `None` or an
    empty string will be omitted from the script.

    Attributes:
        DEFINITIONS: Defines the parameters like dimension, units, boundary, etc.,
        that can be set in `R.headersData`.

    Methods:
        __init__(persistentfile=True, persistentfolder=None, **userdefinitions):
            Initializes the header script and sets up the `USER` attribute.

        generate_template():
            Creates the header template based on the provided `USER` definitions.

    Note: This class is primarily intended for internal use within the simulation setup.
    &#34;&#34;&#34;
    name = &#34;LammpsHeaderBox&#34;
    SECTIONS = [&#34;HEADER&#34;]
    position = -2
    role = &#34;initialization header for pizza.region&#34;
    description = &#34;helper method&#34;
    userid = &#34;headerinit&#34;          # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    # circular references (the variable is defined by its field in USER of class regiondata)
    # are not needed but this explicits the requirements.
    # All fields are stored in R.headersData with R a region object.
    # Use R.headersData.property = value to assign a value
    # Use R.headersData.property = None or &#34;&#34; to prevent the initialization of property
    DEFINITIONS = scriptdata(
                regionname = &#34;${name}&#34;,
                 dimension = &#34;${dimension}&#34;,
                     units = &#34;${units}&#34;,
                  boundary = &#34;${boundary}&#34;,
                atom_style = &#34;${atom_style}&#34;,
               atom_modify = &#34;${atom_modify}&#34;,
               comm_modify = &#34;${comm_modify}&#34;,
              neigh_modify = &#34;${neigh_modify}&#34;,
                    newton = &#34;${newton}&#34;,
            hasvariables = False
                    )

    def __init__(self, persistentfile=True, persistentfolder=None, **userdefinitions):
        &#34;&#34;&#34;Constructor adding instance definitions stored in USER.&#34;&#34;&#34;
        super().__init__(persistentfile, persistentfolder, **userdefinitions)
        self.generate_template()

    def generate_template(self):
        &#34;&#34;&#34;Generate the TEMPLATE based on USER definitions.&#34;&#34;&#34;
        self.TEMPLATE = &#34;&#34;&#34;
% --------------[ Initialization for &lt;${name}:${boxid}&gt;   ]--------------
    &#34;&#34;&#34;
        self.TEMPLATE += &#39;# set a parameter to None or &#34;&#34; to remove the definition\n&#39;
        if self.USER.dimension:   self.TEMPLATE += &#34;dimension    ${dimension}\n&#34;
        if self.USER.units:       self.TEMPLATE += &#34;units        ${units}\n&#34;
        if self.USER.boundary:    self.TEMPLATE += &#34;boundary     ${boundary}\n&#34;
        if self.USER.atom_style:  self.TEMPLATE += &#34;atom_style   ${atom_style}\n&#34;
        if self.USER.atom_modify: self.TEMPLATE += &#34;atom_modify  ${atom_modify}\n&#34;
        if self.USER.comm_modify: self.TEMPLATE += &#34;comm_modify  ${comm_modify}\n&#34;
        if self.USER.neigh_modify:self.TEMPLATE += &#34;neigh_modify ${neigh_modify}\n&#34;
        if self.USER.newton:      self.TEMPLATE += &#34;newton       ${newton}\n&#34;
        self.TEMPLATE += &#34;# ------------------------------------------\n&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsHeaderInit.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderInit.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderInit.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderInit.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderInit.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderInit.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderInit.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderInit.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderInit.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.LammpsHeaderInit.generate_template"><code class="name flex">
<span>def <span class="ident">generate_template</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the TEMPLATE based on USER definitions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def generate_template(self):
        &#34;&#34;&#34;Generate the TEMPLATE based on USER definitions.&#34;&#34;&#34;
        self.TEMPLATE = &#34;&#34;&#34;
% --------------[ Initialization for &lt;${name}:${boxid}&gt;   ]--------------
    &#34;&#34;&#34;
        self.TEMPLATE += &#39;# set a parameter to None or &#34;&#34; to remove the definition\n&#39;
        if self.USER.dimension:   self.TEMPLATE += &#34;dimension    ${dimension}\n&#34;
        if self.USER.units:       self.TEMPLATE += &#34;units        ${units}\n&#34;
        if self.USER.boundary:    self.TEMPLATE += &#34;boundary     ${boundary}\n&#34;
        if self.USER.atom_style:  self.TEMPLATE += &#34;atom_style   ${atom_style}\n&#34;
        if self.USER.atom_modify: self.TEMPLATE += &#34;atom_modify  ${atom_modify}\n&#34;
        if self.USER.comm_modify: self.TEMPLATE += &#34;comm_modify  ${comm_modify}\n&#34;
        if self.USER.neigh_modify:self.TEMPLATE += &#34;neigh_modify ${neigh_modify}\n&#34;
        if self.USER.newton:      self.TEMPLATE += &#34;newton       ${newton}\n&#34;
        self.TEMPLATE += &#34;# ------------------------------------------\n&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsHeaderLattice"><code class="flex name class">
<span>class <span class="ident">LammpsHeaderLattice</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Lattice header for pizza.region</p>
<p>Use R.headersData.property = value to assign a value
with R a pizza.region object</p>
<p>Constructor adding instance definitions stored in USER.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsHeaderLattice(LammpsGeneric): # --- helper script ---
    &#34;&#34;&#34;
        Lattice header for pizza.region

        Use R.headersData.property = value to assign a value
        with R a pizza.region object
    &#34;&#34;&#34;
    name = &#34;LammpsHeaderLattice&#34;
    SECTIONS = [&#34;HEADER&#34;]
    position = 0
    role = &#34;lattice header for pizza.region&#34;
    description = &#34;helper method&#34;
    userid = &#34;headerlattice&#34;       # user name
    version = 0.1                  # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    # circular references (the variable is defined by its field in USER of class regiondata)
    # are not needed but this explicits the requirements.
    # All fields are stored in R.headersData with R a region object.
    # Use R.headersData.property = value to assign a value
    DEFINITIONS = scriptdata(
             lattice_style = &#34;${lattice_style}&#34;,
             lattice_scale = &#34;${lattice_scale}&#34;,
            hasvariables = False
                    )
    def __init__(self, persistentfile=True, persistentfolder=None, **userdefinitions):
        &#34;&#34;&#34;Constructor adding instance definitions stored in USER.&#34;&#34;&#34;
        super().__init__(persistentfile, persistentfolder, **userdefinitions)
        self.generate_template()

    def generate_template(self):
        &#34;&#34;&#34;Generate the TEMPLATE based on USER definitions.&#34;&#34;&#34;
        self.TEMPLATE = &#34;\n% --------------[ Lattice for &lt;${name}:${boxid}&gt;, style=${lattice_style}, scale=${lattice_scale} ]--------------\n&#34;
        if self.USER.lattice_spacing is None:
            self.TEMPLATE += &#34;lattice ${lattice_style} ${lattice_scale}\n&#34;
        else:
            self.TEMPLATE += &#34;lattice ${lattice_style} ${lattice_scale} spacing ${lattice_spacing}\n&#34;
        self.TEMPLATE += &#34;# ------------------------------------------\n&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsHeaderLattice.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderLattice.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderLattice.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderLattice.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderLattice.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderLattice.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderLattice.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderLattice.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderLattice.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.LammpsHeaderLattice.generate_template"><code class="name flex">
<span>def <span class="ident">generate_template</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the TEMPLATE based on USER definitions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_template(self):
    &#34;&#34;&#34;Generate the TEMPLATE based on USER definitions.&#34;&#34;&#34;
    self.TEMPLATE = &#34;\n% --------------[ Lattice for &lt;${name}:${boxid}&gt;, style=${lattice_style}, scale=${lattice_scale} ]--------------\n&#34;
    if self.USER.lattice_spacing is None:
        self.TEMPLATE += &#34;lattice ${lattice_style} ${lattice_scale}\n&#34;
    else:
        self.TEMPLATE += &#34;lattice ${lattice_style} ${lattice_scale} spacing ${lattice_spacing}\n&#34;
    self.TEMPLATE += &#34;# ------------------------------------------\n&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsHeaderMass"><code class="flex name class">
<span>class <span class="ident">LammpsHeaderMass</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Mass assignment header for pizza.region.</p>
<p>Use R.headersData.property = value to assign a value
with R a pizza.region object.</p>
<p>Constructor adding instance definitions stored in USER.</p>
<h2 id="parameters">Parameters</h2>
<p>persistentfile (bool, optional): Whether to use a persistent file. Defaults to True.
persistentfolder (str, optional): Folder path for persistent files. Defaults to None.
**userdefinitions: Arbitrary keyword arguments for user definitions.
- mass (list or tuple, optional): List or tuple to override masses for specific bead types.
Example: mass=[1.2, 1.0, 0.8] assigns mass 1.2 to bead type 1, 1.0 to bead type 2,
and 0.8 to bead type 3.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsHeaderMass(LammpsGeneric):
    &#34;&#34;&#34;
    Mass assignment header for pizza.region.

    Use R.headersData.property = value to assign a value
    with R a pizza.region object.
    &#34;&#34;&#34;
    name = &#34;LammpsHeaderMass&#34;
    SECTIONS = [&#34;HEADER&#34;]
    position = 2  # Positioned after other headers like Box and Lattice
    role = &#34;mass assignment header for pizza.region&#34;
    description = &#34;Assigns masses to bead types based on nbeads and default mass.&#34;
    userid = &#34;headermass&#34;  # User identifier
    version = 0.1
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    # All fields are stored in R.headersData with R a region object.
    # Use R.headersData.property = value to assign a value.
    # Mass overrides are provided via the &#39;mass&#39; keyword argument as a list or tuple.
    DEFINITIONS = scriptdata(
        nbeads=&#34;${nbeads}&#34;,  # these default values are not used
        mass=&#34;${mass}&#34;,      # but reported for records
        hasvariables=False
    )

    def __init__(self, persistentfile=True, persistentfolder=None, **userdefinitions):
        &#34;&#34;&#34;
            Constructor adding instance definitions stored in USER.

            Parameters:
                persistentfile (bool, optional): Whether to use a persistent file. Defaults to True.
                persistentfolder (str, optional): Folder path for persistent files. Defaults to None.
                **userdefinitions: Arbitrary keyword arguments for user definitions.
                    - mass (list or tuple, optional): List or tuple to override masses for specific bead types.
                      Example: mass=[1.2, 1.0, 0.8] assigns mass 1.2 to bead type 1, 1.0 to bead type 2,
                      and 0.8 to bead type 3.
        &#34;&#34;&#34;
        super().__init__(persistentfile, persistentfolder, **userdefinitions)
        self.generate_template()

    def generate_template(self):
        &#34;&#34;&#34;
            Generate the TEMPLATE for mass assignments based on USER definitions.

            The method constructs mass assignments for each bead type. If `mass` overrides
            are provided as a list or tuple, it assigns the specified mass to the corresponding
            bead types. Otherwise, it uses the default `mass` value from `USER.headersData.mass`.
        &#34;&#34;&#34;
        # Retrieve user-defined parameters
        nbeads = self.USER.nbeads
        mass = self.USER.mass
        # Validate mass
        if not isinstance(mass, (list, tuple)): mass = [mass]  # Convert single value to a list
        if len(mass) &gt; nbeads:
            mass = mass[:nbeads]  # Truncate excess entries
        elif len(mass) &lt; nbeads:
            last_mass = mass[-1]  # Repeat the last value for missing entries
            mass += [last_mass] * (nbeads - len(mass))
        # Initialize TEMPLATE with header comment
        self.TEMPLATE = &#34;\n% --------------[ Mass Assignments for &lt;${name}:${boxid}&gt;&#34; + f&#34; (nbeads={nbeads}) &#34; +&#34; ]--------------\n&#34;
        # Iterate over bead types and assign masses
        for bead_type in range(1, nbeads + 1):
            bead_mass = mass[bead_type - 1]
            if isinstance(bead_mass, str):
                # If mass is a string (e.g., formula), ensure proper formatting
                mass_str = f&#34;({bead_mass})&#34;
            else:
                # If mass is a numeric value, convert to string
                mass_str = f&#34;{bead_mass}&#34;
            self.TEMPLATE += f&#34;mass {bead_type} {mass_str}\n&#34;
        # Close the TEMPLATE with a comment
        self.TEMPLATE += &#34;# ------------------------------------------\n&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsHeaderMass.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderMass.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderMass.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderMass.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderMass.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderMass.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderMass.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderMass.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsHeaderMass.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.LammpsHeaderMass.generate_template"><code class="name flex">
<span>def <span class="ident">generate_template</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the TEMPLATE for mass assignments based on USER definitions.</p>
<p>The method constructs mass assignments for each bead type. If <code>mass</code> overrides
are provided as a list or tuple, it assigns the specified mass to the corresponding
bead types. Otherwise, it uses the default <code>mass</code> value from <code>USER.headersData.mass</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_template(self):
    &#34;&#34;&#34;
        Generate the TEMPLATE for mass assignments based on USER definitions.

        The method constructs mass assignments for each bead type. If `mass` overrides
        are provided as a list or tuple, it assigns the specified mass to the corresponding
        bead types. Otherwise, it uses the default `mass` value from `USER.headersData.mass`.
    &#34;&#34;&#34;
    # Retrieve user-defined parameters
    nbeads = self.USER.nbeads
    mass = self.USER.mass
    # Validate mass
    if not isinstance(mass, (list, tuple)): mass = [mass]  # Convert single value to a list
    if len(mass) &gt; nbeads:
        mass = mass[:nbeads]  # Truncate excess entries
    elif len(mass) &lt; nbeads:
        last_mass = mass[-1]  # Repeat the last value for missing entries
        mass += [last_mass] * (nbeads - len(mass))
    # Initialize TEMPLATE with header comment
    self.TEMPLATE = &#34;\n% --------------[ Mass Assignments for &lt;${name}:${boxid}&gt;&#34; + f&#34; (nbeads={nbeads}) &#34; +&#34; ]--------------\n&#34;
    # Iterate over bead types and assign masses
    for bead_type in range(1, nbeads + 1):
        bead_mass = mass[bead_type - 1]
        if isinstance(bead_mass, str):
            # If mass is a string (e.g., formula), ensure proper formatting
            mass_str = f&#34;({bead_mass})&#34;
        else:
            # If mass is a numeric value, convert to string
            mass_str = f&#34;{bead_mass}&#34;
        self.TEMPLATE += f&#34;mass {bead_type} {mass_str}\n&#34;
    # Close the TEMPLATE with a comment
    self.TEMPLATE += &#34;# ------------------------------------------\n&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsMove"><code class="flex name class">
<span>class <span class="ident">LammpsMove</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>script for LAMMPS variables section </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsMove(LammpsGeneric):
    &#34;&#34;&#34; script for LAMMPS variables section &#34;&#34;&#34;
    name = &#34;LammpsMove&#34;
    SECTIONS = [&#34;move_fix&#34;]
    position = 6
    role = &#34;move along a trajectory&#34;
    description = &#34;fix ID group-ID move style args keyword values ...&#34;
    userid = &#34;move&#34;
    version = 0.2
    verbose = True

    # Definitions used in TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
                moveID = &#34;$&#34;+fixmoveprefix+&#34;${ID}&#34;, # freeze the interpretation
               groupID = &#34;$&#34;+groupprefix+&#34;${ID}&#34;, # freeze the interpretation
                 style = &#34;${style}&#34;,
                  args = &#34;${args}&#34;,
          hasvariables = False
                    )

    # Template (using % instead of # enables replacements)
    TEMPLATE = &#34;&#34;&#34;
# Move atoms fix ID group-ID move style args keyword values (https://docs.lammps.org/fix_move.html)
% move_fix for group ${groupID} using ${style}
% prefix &#34;g&#34; added to ${ID} to indicate a group of atoms
% prefix &#34;fm&#34; added to ${ID} to indicate the ID of the fix move
fix ${moveID} ${groupID} move ${style} ${args}
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsMove.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsMove.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsMove.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsMove.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsMove.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsMove.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsMove.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsMove.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsMove.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsMove.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsRegion"><code class="flex name class">
<span>class <span class="ident">LammpsRegion</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>generic region based on script </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsRegion(LammpsGeneric):
    &#34;&#34;&#34; generic region based on script &#34;&#34;&#34;
    name = &#34;LammpsRegion&#34;
    SECTIONS = [&#34;REGION&#34;]
    position = 3
    role = &#34;region command definition&#34;
    description = &#34;region ID style args keyword arg&#34;
    userid = &#34;region&#34;              # user name
    version = 0.1                  # version
    verbose = True

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
                 style = &#34;${style}&#34;,
                  args = &#34;${args}&#34;,
                  side = &#34;${side}&#34;,
                 units = &#34;${units}&#34;,
                  move = &#34;${move}&#34;,
                rotate = &#34;${rotate}&#34;,
                  open = &#34;${open}&#34;,
          hasvariables = False
                    )

    # Template  (using % instead of # enables replacements)
    TEMPLATE = &#34;&#34;&#34;
% Create region ${ID} ${style} args ...  (URL: https://docs.lammps.org/region.html)
# keywords: side, units, move, rotate, open
# values: in|out, lattice|box, v_x v_y v_z, v_theta Px Py Pz Rx Ry Rz, integer
region ${ID} ${style} ${args} ${side}${units}${move}${rotate}${open}
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsRegion.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsRegion.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsRegion.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsRegion.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsRegion.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsRegion.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsRegion.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsRegion.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsRegion.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsRegion.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsSetGroup"><code class="flex name class">
<span>class <span class="ident">LammpsSetGroup</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>script for LAMMPS set group section </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsSetGroup(LammpsGeneric):
    &#34;&#34;&#34; script for LAMMPS set group section &#34;&#34;&#34;
    name = &#34;LammpsSetGroup&#34;
    SECTIONS = [&#34;set group&#34;]
    position = 4
    role = &#34;create_atoms command&#34;
    description = &#34;set group groupID type beadtype&#34;
    userid = &#34;setgroup&#34;
    version = 0.1
    verbose = True

    # Definitions used in TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
               groupID = &#34;$&#34;+groupprefix+&#34;${ID}&#34;, # freeze the interpretation,
          hasvariables = False
                    )

    # Template (using % instead of # enables replacements)
    TEMPLATE = &#34;&#34;&#34;
% Reassign atom type to ${beadtype} for the group ${groupID} associated with region ${ID} (https://docs.lammps.org/set.html)
set group ${groupID} type ${beadtype}
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsSetGroup.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSetGroup.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSetGroup.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSetGroup.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSetGroup.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSetGroup.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSetGroup.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSetGroup.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSetGroup.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSetGroup.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsSpacefilling"><code class="flex name class">
<span>class <span class="ident">LammpsSpacefilling</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Spacefilling script: fill space with a block </p>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsSpacefilling(LammpsGeneric):
    &#34;&#34;&#34; Spacefilling script: fill space with a block &#34;&#34;&#34;
    name = &#34;LammpsSpacefilling&#34;
    SECTIONS = [&#34;SPACEFILLING&#34;]
    position = 1
    role = &#34;fill space with fillingbeadtype atoms&#34;
    description = &#39;fill the whole space (region &#34;filledspace&#34;) with default atoms (beadtype)&#39;
    userid = &#34;spacefilling&#34;              # user name
    version = 0.1                        # version
    verbose = False

    # DEFINITIONS USED IN TEMPLATE
    DEFINITIONS = scriptdata(
             fillingunits = &#34;${fillingunits}&#34;,
             fillingwidth = &#34;${fillingwidth}&#34;,
            fillingheight = &#34;${fillingheight}&#34;,
             fillingdepth = &#34;${fillingdepth}&#34;,
               fillingxlo = &#34;-${fillingwidth}/2&#34;,
               fillingxhi = &#34;${fillingwidth}/2&#34;,
               fillingylo = &#34;-${fillingheight}/2&#34;,
               fillingyhi = &#34;${fillingheight}/2&#34;,
               fillingzlo = &#34;-${fillingdepth}/2&#34;,
               fillingzhi = &#34;${fillingdepth}/2&#34;,
          fillingbeadtype = &#34;${fillingbeadtype}&#34;,
             fillingstyle = &#34;${block}&#34;,
             hasvariables = False
                    )

    # Template
    TEMPLATE = &#34;&#34;&#34;
region filledspace ${fillingstyle} ${fillingxlo} ${fillingxhi} ${fillingylo} ${fillingyhi} ${fillingzlo} ${fillingzhi}
create_atoms ${fillingbeadtype} region filledspace
# ------------------------------------------
&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsSpacefilling.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSpacefilling.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSpacefilling.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSpacefilling.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSpacefilling.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSpacefilling.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSpacefilling.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSpacefilling.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSpacefilling.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsSpacefilling.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.LammpsVariables"><code class="flex name class">
<span>class <span class="ident">LammpsVariables</span></span>
<span>(</span><span>VARIABLES=region data (RD object) with 0 definitions, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>script for LAMMPS variables section
myvars = LammpsVariables(regiondata(var1=&hellip;),ID='....',style='....')</p>
<p>constructor of LammpsVariables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LammpsVariables(LammpsGeneric):
    &#34;&#34;&#34;
        script for LAMMPS variables section
        myvars = LammpsVariables(regiondata(var1=...),ID=&#39;....&#39;,style=&#39;....&#39;)
    &#34;&#34;&#34;
    name = &#34;LammpsVariables&#34;
    SECTIONS = [&#34;VARIABLES&#34;]
    position = 2
    role = &#34;variable command definition&#34;
    description = &#34;variable name style args&#34;
    userid = &#34;variable&#34;
    version = 0.1
    verbose = True

    # Definitions used in TEMPLATE
    DEFINITIONS = scriptdata(
                    ID = &#34;${ID}&#34;,
                 style = &#34;${style}&#34;,
          hasvariables = True
                    )

    # Template  (using % instead of # enables replacements)
    TEMPLATE = &#34;% variables to be used for ${ID} ${style}&#34;

    def __init__(self,VARIABLES=regiondata(),**userdefinitions):
        &#34;&#34;&#34; constructor of LammpsVariables &#34;&#34;&#34;
        super().__init__(**userdefinitions)
        self.VARIABLES = VARIABLES

    # override &gt;&gt;
    def __rshift__(self,s):
        &#34;&#34;&#34; overload right  shift operator (keep only the last template) &#34;&#34;&#34;
        if isinstance(s,script):
            dup = deepduplicate(self) # instead of duplicate (added 2023-08-11)
            dup.DEFINITIONS = dup.DEFINITIONS + s.DEFINITIONS
            dup.USER = dup.USER + s.USER
            if self.DEFINITIONS.hasvariables and s.DEFINITIONS.hasvariables:
                dup.VARIABLES = s.VARIABLES
            dup.TEMPLATE = s.TEMPLATE
            return dup
        else:
            raise TypeError(&#34;the second operand must a script object&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
<li>pizza.script.script</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.LammpsVariables.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsVariables.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsVariables.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsVariables.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsVariables.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsVariables.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsVariables.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsVariables.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsVariables.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.LammpsVariables.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></b></code>:
<ul class="hlist">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.Plane"><code class="flex name class">
<span>class <span class="ident">Plane</span></span>
<span>(</span><span>counter, index=None, subindex=None, mass=1, density=1, lattice_style='sc', lattice_scale=1, lattice_scale_siunits=1, hasgroup=False, hasmove=False, spacefilling=False, style=None, group=None, forcefield=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>Plane class </p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plane(coregeometry):
    &#34;&#34;&#34; Plane class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;plane%03d&#34; % counter[1]
        self.kind = &#34;plane&#34;      # kind of object
        self.alike = &#34;plane&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$plane&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    @property
    def volume(self,units=None):
        &#34;&#34;&#34;Dummy method returning None for volume&#34;&#34;&#34;
        #args = [px, py, pz, nx, ny, nz]
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="region.Plane.volume"><code class="name">var <span class="ident">volume</span></code></dt>
<dd>
<div class="desc"><p>Dummy method returning None for volume</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self,units=None):
    &#34;&#34;&#34;Dummy method returning None for volume&#34;&#34;&#34;
    #args = [px, py, pz, nx, ny, nz]
    return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.Prism"><code class="flex name class">
<span>class <span class="ident">Prism</span></span>
<span>(</span><span>counter, index=None, subindex=None, mass=1, density=1, lattice_style='sc', lattice_scale=1, lattice_scale_siunits=1, hasgroup=False, hasmove=False, spacefilling=False, style=None, group=None, forcefield=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>Prism class </p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Prism(coregeometry):
    &#34;&#34;&#34; Prism class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;prism%03d&#34; % counter[1]
        self.kind = &#34;prism&#34;      # kind of object
        self.alike = &#34;prism&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$prism&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        &#34;&#34;&#34;Calculate the volume of the prism based on USER.args&#34;&#34;&#34;
        #args = [xlo, xhi, ylo, yhi, zlo, zhi, xy, xz, yz]
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            xlo = float(args[0])
            xhi = float(args[1])
            ylo = float(args[2])
            yhi = float(args[3])
            zlo = float(args[4])
            zhi = float(args[5])
            # Calculate the dimensions of the prism
            length = xhi - xlo
            width = yhi - ylo
            height = zhi - zlo
            # Calculate the volume of the prism
            volume = length * width * height
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="region.Prism.volume"><code class="name flex">
<span>def <span class="ident">volume</span></span>(<span>self, units=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the volume of the prism based on USER.args</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volume(self,units=None):
    &#34;&#34;&#34;Calculate the volume of the prism based on USER.args&#34;&#34;&#34;
    #args = [xlo, xhi, ylo, yhi, zlo, zhi, xy, xz, yz]
    try:
        # Extract the arguments from USER.args
        args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
        xlo = float(args[0])
        xhi = float(args[1])
        ylo = float(args[2])
        yhi = float(args[3])
        zlo = float(args[4])
        zhi = float(args[5])
        # Calculate the dimensions of the prism
        length = xhi - xlo
        width = yhi - ylo
        height = zhi - zlo
        # Calculate the volume of the prism
        volume = length * width * height
        return volume
    except Exception as e:
        print(f&#34;Error calculating volume: {e}&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.SafeEvaluator"><code class="flex name class">
<span>class <span class="ident">SafeEvaluator</span></span>
<span>(</span><span>context)</span>
</code></dt>
<dd>
<div class="desc"><p>A safe evaluator class for expressions involving math, NumPy, random, and basic operators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SafeEvaluator(ast.NodeVisitor):
    &#34;&#34;&#34;A safe evaluator class for expressions involving math, NumPy, random, and basic operators.&#34;&#34;&#34;

    def __init__(self, context):
        self.context = {**context}
        self.context.update({
            name: getattr(math, name)
            for name in [
                &#34;sin&#34;, &#34;cos&#34;, &#34;tan&#34;, &#34;asin&#34;, &#34;acos&#34;, &#34;atan&#34;, &#34;atan2&#34;, &#34;radians&#34;, &#34;degrees&#34;,
                &#34;exp&#34;, &#34;log&#34;, &#34;log10&#34;, &#34;pow&#34;, &#34;sqrt&#34;,
                &#34;ceil&#34;, &#34;floor&#34;, &#34;fmod&#34;, &#34;modf&#34;,
                &#34;fabs&#34;, &#34;hypot&#34;, &#34;pi&#34;, &#34;e&#34;
            ]
        })
        self.context.update({
            &#34;gauss&#34;: random.gauss,
            &#34;uniform&#34;: random.uniform,
            &#34;randint&#34;: random.randint,
            &#34;choice&#34;: random.choice
        })
        self.context[&#34;np&#34;] = np  # Allow &#39;np.sin&#39;, &#39;np.cos&#39;, etc.

        # Define allowed operators
        self.operators = {
            ast.Add: operator.add,
            ast.Sub: operator.sub,
            ast.Mult: operator.mul,
            ast.Div: operator.truediv,
            ast.FloorDiv: operator.floordiv,
            ast.Mod: operator.mod,
            ast.Pow: operator.pow,
            ast.USub: operator.neg,  # Unary subtraction
        }

    def visit_Name(self, node):
        if node.id in self.context:
            return self.context[node.id]
        raise ValueError(f&#34;Variable or function &#39;{node.id}&#39; is not defined&#34;)

    def visit_Constant(self, node):
        return node.value

    def visit_BinOp(self, node):
        left = self.visit(node.left)
        right = self.visit(node.right)
        op_type = type(node.op)
        if isinstance(left, np.ndarray) and isinstance(right, np.ndarray) and isinstance(node.op, ast.MatMult):
            return np.matmul(left, right)
        if op_type in self.operators:
            return self.operators[op_type](left, right)
        raise ValueError(f&#34;Unsupported operator: {op_type}&#34;)

    def visit_UnaryOp(self, node):
        operand = self.visit(node.operand)
        op_type = type(node.op)
        if op_type in self.operators:
            return self.operators[op_type](operand)
        raise ValueError(f&#34;Unsupported unary operator: {op_type}&#34;)

    def visit_Call(self, node):
        func = self.visit(node.func)
        if callable(func):
            args = [self.visit(arg) for arg in node.args]
            kwargs = {kw.arg: self.visit(kw.value) for kw in node.keywords}
            return func(*args, **kwargs)
        raise ValueError(f&#34;Function &#39;{ast.dump(node.func)}&#39; is not callable&#34;)

    def visit_Attribute(self, node):
        value = self.visit(node.value)
        attr = node.attr
        if hasattr(value, attr):
            # If the attribute is &#34;T&#34;, return the transpose of the array
            if attr == &#34;T&#34; and isinstance(value, np.ndarray):
                return value.T
            # Check if the attribute is the &#39;@&#39; matrix multiplication operator
            if attr == &#34;@&#34; and isinstance(value, np.ndarray):
                return value @ value  # or handle accordingly with another operand
            return getattr(value, attr)
        raise ValueError(f&#34;Object &#39;{value}&#39; has no attribute &#39;{attr}&#39;&#34;)

    def visit_Subscript(self, node):
        value = self.visit(node.value)
        slice_obj = self.visit(node.slice)
        try:
            return value[slice_obj]
        except Exception as e:
            raise ValueError(f&#34;Invalid index {slice_obj} for object of type {type(value).__name__}: {e}&#34;)

    def visit_Index(self, node):
        return self.visit(node.value)

    def visit_Slice(self, node):
        lower = self.visit(node.lower) if node.lower else None
        upper = self.visit(node.upper) if node.upper else None
        step = self.visit(node.step) if node.step else None
        return slice(lower, upper, step)

    def visit_ExtSlice(self, node):
        dims = tuple(self.visit(dim) for dim in node.dims)
        return dims

    def visit_Tuple(self, node):
        return tuple(self.visit(elt) for elt in node.elts)

    def visit_List(self, node):
        return [self.visit(elt) for elt in node.elts]

    def generic_visit(self, node):
        raise ValueError(f&#34;Unsupported expression: {ast.dump(node)}&#34;)

    def evaluate(self, expression):
        tree = ast.parse(expression, mode=&#39;eval&#39;)
        return self.visit(tree.body)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ast.NodeVisitor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="region.SafeEvaluator.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, expression):
    tree = ast.parse(expression, mode=&#39;eval&#39;)
    return self.visit(tree.body)</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.generic_visit"><code class="name flex">
<span>def <span class="ident">generic_visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Called if no explicit visitor function exists for a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_visit(self, node):
    raise ValueError(f&#34;Unsupported expression: {ast.dump(node)}&#34;)</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_Attribute"><code class="name flex">
<span>def <span class="ident">visit_Attribute</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Attribute(self, node):
    value = self.visit(node.value)
    attr = node.attr
    if hasattr(value, attr):
        # If the attribute is &#34;T&#34;, return the transpose of the array
        if attr == &#34;T&#34; and isinstance(value, np.ndarray):
            return value.T
        # Check if the attribute is the &#39;@&#39; matrix multiplication operator
        if attr == &#34;@&#34; and isinstance(value, np.ndarray):
            return value @ value  # or handle accordingly with another operand
        return getattr(value, attr)
    raise ValueError(f&#34;Object &#39;{value}&#39; has no attribute &#39;{attr}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_BinOp"><code class="name flex">
<span>def <span class="ident">visit_BinOp</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_BinOp(self, node):
    left = self.visit(node.left)
    right = self.visit(node.right)
    op_type = type(node.op)
    if isinstance(left, np.ndarray) and isinstance(right, np.ndarray) and isinstance(node.op, ast.MatMult):
        return np.matmul(left, right)
    if op_type in self.operators:
        return self.operators[op_type](left, right)
    raise ValueError(f&#34;Unsupported operator: {op_type}&#34;)</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_Call"><code class="name flex">
<span>def <span class="ident">visit_Call</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Call(self, node):
    func = self.visit(node.func)
    if callable(func):
        args = [self.visit(arg) for arg in node.args]
        kwargs = {kw.arg: self.visit(kw.value) for kw in node.keywords}
        return func(*args, **kwargs)
    raise ValueError(f&#34;Function &#39;{ast.dump(node.func)}&#39; is not callable&#34;)</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_Constant"><code class="name flex">
<span>def <span class="ident">visit_Constant</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Constant(self, node):
    return node.value</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_ExtSlice"><code class="name flex">
<span>def <span class="ident">visit_ExtSlice</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ExtSlice(self, node):
    dims = tuple(self.visit(dim) for dim in node.dims)
    return dims</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_Index"><code class="name flex">
<span>def <span class="ident">visit_Index</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Index(self, node):
    return self.visit(node.value)</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_List"><code class="name flex">
<span>def <span class="ident">visit_List</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_List(self, node):
    return [self.visit(elt) for elt in node.elts]</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Name(self, node):
    if node.id in self.context:
        return self.context[node.id]
    raise ValueError(f&#34;Variable or function &#39;{node.id}&#39; is not defined&#34;)</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_Slice"><code class="name flex">
<span>def <span class="ident">visit_Slice</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Slice(self, node):
    lower = self.visit(node.lower) if node.lower else None
    upper = self.visit(node.upper) if node.upper else None
    step = self.visit(node.step) if node.step else None
    return slice(lower, upper, step)</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_Subscript"><code class="name flex">
<span>def <span class="ident">visit_Subscript</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Subscript(self, node):
    value = self.visit(node.value)
    slice_obj = self.visit(node.slice)
    try:
        return value[slice_obj]
    except Exception as e:
        raise ValueError(f&#34;Invalid index {slice_obj} for object of type {type(value).__name__}: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_Tuple"><code class="name flex">
<span>def <span class="ident">visit_Tuple</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Tuple(self, node):
    return tuple(self.visit(elt) for elt in node.elts)</code></pre>
</details>
</dd>
<dt id="region.SafeEvaluator.visit_UnaryOp"><code class="name flex">
<span>def <span class="ident">visit_UnaryOp</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_UnaryOp(self, node):
    operand = self.visit(node.operand)
    op_type = type(node.op)
    if op_type in self.operators:
        return self.operators[op_type](operand)
    raise ValueError(f&#34;Unsupported unary operator: {op_type}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.Sphere"><code class="flex name class">
<span>class <span class="ident">Sphere</span></span>
<span>(</span><span>counter, index=None, subindex=None, mass=1, density=1, lattice_style='sc', lattice_scale=1, lattice_scale_siunits=1, hasgroup=False, hasmove=False, spacefilling=False, style=None, group=None, forcefield=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>Sphere class </p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sphere(coregeometry):
    &#34;&#34;&#34; Sphere class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None, mass=1, density=1,
                 lattice_style=&#34;sc&#34;,lattice_scale=1,lattice_scale_siunits=1,
                 hasgroup=False,hasmove=False,spacefilling=False,
                 style=None, group=None, forcefield=None, **variables):
        self.name = &#34;sphere%03d&#34; % counter[1]
        self.kind = &#34;sphere&#34;      # kind of object
        self.alike = &#34;ellipsoid&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        self.mass = mass
        self.density = density
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$sphere&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling,
                mass=mass, density=density,
                lattice_style=lattice_style,
                lattice_scale=lattice_scale,
                lattice_scale_siunits=lattice_scale_siunits,
                style=style, group=group, forcefield=forcefield # script object properties
                )

    def volume(self,units=None):
        &#34;&#34;&#34;Calculate the volume of the sphere based on USER.args&#34;&#34;&#34;
        #args = [x, y, z, radius]
        try:
            # Extract the arguments from USER.args
            args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
            radius = float(args[3])
            # Calculate the volume of the sphere
            volume = (4/3) * 3.141592653589793 * (radius ** 3)
            return volume
        except Exception as e:
            print(f&#34;Error calculating volume: {e}&#34;)
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="region.Sphere.volume"><code class="name flex">
<span>def <span class="ident">volume</span></span>(<span>self, units=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the volume of the sphere based on USER.args</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volume(self,units=None):
    &#34;&#34;&#34;Calculate the volume of the sphere based on USER.args&#34;&#34;&#34;
    #args = [x, y, z, radius]
    try:
        # Extract the arguments from USER.args
        args = self.USER.args_siunits if units==&#34;si&#34; else self.USER.args
        radius = float(args[3])
        # Calculate the volume of the sphere
        volume = (4/3) * 3.141592653589793 * (radius ** 3)
        return volume
    except Exception as e:
        print(f&#34;Error calculating volume: {e}&#34;)
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.Union"><code class="flex name class">
<span>class <span class="ident">Union</span></span>
<span>(</span><span>counter, index=None, subindex=None, hasgroup=False, hasmove=False, spacefilling=False, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>Union class </p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Union(coregeometry):
    &#34;&#34;&#34; Union class &#34;&#34;&#34;

    def __init__(self,counter,index=None,subindex=None,
                 hasgroup=False,hasmove=False,spacefilling=False,**variables):
        self.name = &#34;union%03d&#34; % counter[1]
        self.kind = &#34;union&#34;      # kind of object
        self.alike = &#34;operator&#34;     # similar object for plotting
        self.beadtype = 1       # bead type
        self.index = counter[0] if index is None else index
        self.subindex = subindex
        # call the generic constructor
        super().__init__(
                USER = regiondata(style=&#34;$union&#34;),
                VARIABLES = regiondata(**variables),
                hasgroup=hasgroup,hasmove=hasmove,spacefilling=spacefilling
                )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.coregeometry"><code class="flex name class">
<span>class <span class="ident">coregeometry</span></span>
<span>(</span><span>USER=region data (RD object) with 0 definitions, VARIABLES=region data (RD object) with 0 definitions, hasgroup=False, hasmove=False, spacefilling=False, style='smd', forcefield=LAMMPS:SMD:none:walls, group=[], mass=1, density=1, lattice_style='sc', lattice_scale=1, lattice_scale_siunits=1)</span>
</code></dt>
<dd>
<div class="desc"><p>core geometry object
(helper class for attributes, side,units, move, rotate, open)</p>
<p>SECTIONS store scripts (variables, region and create for the geometry)
USER = common USER definitions for the three scripts
VARIABLES = variables definitions (used by variables only)
update() propagate USER to the three scripts
script returns SECTIONS as a pipescript
do() generate the script</p>
<p>Parameters to be used along scriptobject()
style
forcefield
group
They are stored SCRIPTOBJECT_USER</p>
<p>constructor of the generic core geometry
USER: any definitions requires by the geometry
VARIABLES: variables used to define the geometry (to be used in LAMMPS)
hasgroup, hasmove: flag to force the sections group and move
SECTIONS: they must be PIZZA.script</p>
<p>The flag spacefilling is true of the container of objects (class region) is filled with beads</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class coregeometry:
    &#34;&#34;&#34;
        core geometry object
        (helper class for attributes, side,units, move, rotate, open)

        SECTIONS store scripts (variables, region and create for the geometry)
        USER = common USER definitions for the three scripts
        VARIABLES = variables definitions (used by variables only)
        update() propagate USER to the three scripts
        script returns SECTIONS as a pipescript
        do() generate the script

        Parameters to be used along scriptobject()
                 style
            forcefield
                 group
        They are stored SCRIPTOBJECT_USER

    &#34;&#34;&#34;

    _version = &#34;0.35&#34;
    __custom_documentations__ = &#34;pizza.region.coregeometry class&#34;


    def __init__(self,USER=regiondata(),VARIABLES=regiondata(),
                 hasgroup=False, hasmove=False, spacefilling=False,
                 style=&#34;smd&#34;,
                 forcefield=rigidwall(),
                 group=[],
                 mass=1, density=1,
                 lattice_style=&#34;sc&#34;, lattice_scale=1, lattice_scale_siunits=1 # added on 2024-07-05
                 ):
        &#34;&#34;&#34;
            constructor of the generic core geometry
                USER: any definitions requires by the geometry
           VARIABLES: variables used to define the geometry (to be used in LAMMPS)
           hasgroup, hasmove: flag to force the sections group and move
           SECTIONS: they must be PIZZA.script

           The flag spacefilling is true of the container of objects (class region) is filled with beads
        &#34;&#34;&#34;
        self.USER = USER
        self.SECTIONS = {
            &#39;variables&#39;: LammpsVariables(VARIABLES,**USER),
               &#39;region&#39;: LammpsRegion(**USER),
               &#39;create&#39;: LammpsCreate(**USER),
                &#39;group&#39;: LammpsGroup(**USER),
             &#39;setgroup&#39;: LammpsSetGroup(**USER),
                 &#39;move&#39;: LammpsMove(**USER)
            }
        self.FLAGSECTIONS = {
            &#39;variables&#39;: True,
               &#39;region&#39;: True,
               &#39;create&#39;: not spacefilling,
                &#39;group&#39;: hasgroup,
             &#39;setgroup&#39;: spacefilling,
                 &#39;move&#39;: hasmove
            }
        self.spacefilling = spacefilling

        # add comptaibility with scriptobjects
        self.SCRIPTOBJECT_USER = {
                 &#39;style&#39;: style,
            &#39;forcefield&#39;: forcefield,
                 &#39;group&#39;: group
            }
        # collect information from parent region
        self.mass = mass
        self.density = density
        self.lattice_style = lattice_style
        self.lattice_scale = lattice_scale
        self.lattice_scale_siunits = lattice_scale_siunits

    def update(self):
        &#34;&#34;&#34; update the USER content for all three scripts &#34;&#34;&#34;
        if isinstance(self.SECTIONS[&#34;variables&#34;],script):
            self.SECTIONS[&#34;variables&#34;].USER += self.USER
        if isinstance(self.SECTIONS[&#34;region&#34;],script):
            self.SECTIONS[&#34;region&#34;].USER += self.USER
        if isinstance(self.SECTIONS[&#34;create&#34;],script):
            self.SECTIONS[&#34;create&#34;].USER += self.USER
        if isinstance(self.SECTIONS[&#34;group&#34;],script):
            self.SECTIONS[&#34;group&#34;].USER += self.USER
        if isinstance(self.SECTIONS[&#34;setgroup&#34;],script):
            self.SECTIONS[&#34;setgroup&#34;].USER += self.USER
        if isinstance(self.SECTIONS[&#34;move&#34;],script):
            self.SECTIONS[&#34;move&#34;].USER += self.USER


    def copy(self,beadtype=None,name=&#34;&#34;):
        &#34;&#34;&#34; returns a copy of the graphical object &#34;&#34;&#34;
        if self.alike != &#34;mixed&#34;:
            dup = deepduplicate(self)
            if beadtype != None: # update beadtype
                dup.beadtype = beadtype
            if name != &#34;&#34;: # update name
                dup.name = name
            return dup
        else:
            raise ValueError(&#34;collections cannot be copied, regenerate the collection instead&#34;)


    def creategroup(self):
        &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
        self.FLAGSECTIONS[&#34;group&#34;] = True

    def setgroup(self):
        &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
        self.FLAGSECTIONS[&#34;setgroup&#34;] = True

    def createmove(self):
        &#34;&#34;&#34;  force the fix move creation in script &#34;&#34;&#34;
        self.FLAGSECTIONS[&#34;move&#34;] = True

    def removegroup(self):
        &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
        self.FLAGSECTIONS[&#34;group&#34;] = False

    def removemove(self):
        &#34;&#34;&#34;  force the fix move creation in script &#34;&#34;&#34;
        self.FLAGSECTIONS[&#34;move&#34;] = False

    def scriptobject(self, beadtype=None, name=None, fullname=None, group=None, style=None, forcefield=None, USER = scriptdata()):
        &#34;&#34;&#34;
        Method to return a scriptobject based on region instead of an input file
        Syntax similar to script.scriptobject
        OBJ = scriptobject(...)
        Implemented properties:
            beadtype=1,2,...
            name=&#34;short name&#34;
            fullname = &#34;comprehensive name&#34;
            style = &#34;smd&#34;
            forcefield = any valid forcefield instance (default = rigidwall())
        &#34;&#34;&#34;
        # Set defaults using instance attributes if parameters are None
        if beadtype is None:
            beadtype = self.beadtype
        if name is None:
            name = f&#34;{self.name} bead&#34;
        if fullname is None:
            fullname = f&#34;beads of type {self.beadtype} | object {self.name} of kind region.{self.kind}&#34;
        if group is None:
            group = self.SCRIPTOBJECT_USER[&#34;group&#34;]
        if style is None:
            style = self.SCRIPTOBJECT_USER[&#34;style&#34;]
        if forcefield is None:
            style = self.SCRIPTOBJECT_USER[&#34;forcefield&#34;]
        return scriptobject(
            beadtype=beadtype,
            name=name,
            fullname=fullname,
            style=style,
            group=group,
            filename=None,  # No need for a file
            USER = USER
        )

    @property
    def hasvariables(self):
        &#34;&#34;&#34; return the flag VARIABLES &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;variables&#34;],script) \
               and self.FLAGSECTIONS[&#34;variables&#34;]

    @property
    def hasregion(self):
        &#34;&#34;&#34; return the flag REGION &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;region&#34;],script) \
               and self.FLAGSECTIONS[&#34;region&#34;]

    @property
    def hascreate(self):
        &#34;&#34;&#34; return the flag CREATE &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;create&#34;],script) \
               and self.FLAGSECTIONS[&#34;create&#34;] \
               and (not self.spacefilling)

    @property
    def hasgroup(self):
        &#34;&#34;&#34; return the flag GROUP &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;group&#34;],script) \
               and self.FLAGSECTIONS[&#34;group&#34;]

    @property
    def hassetgroup(self):
        &#34;&#34;&#34; return the flag GROUP &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;setgroup&#34;],script) \
               and self.FLAGSECTIONS[&#34;setgroup&#34;] \
               and self.hasgroup \
               and (not self.hascreate)

    @property
    def hasmove(self):
        &#34;&#34;&#34; return the flag MOVE &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;move&#34;],script) \
               and self.FLAGSECTIONS[&#34;move&#34;]

    @property
    def isspacefilled(self):
        &#34;&#34;&#34; return the flag spacefilling &#34;&#34;&#34;
        return isinstance(self.SECTIONS[&#34;spacefilling&#34;],script) \
               and self.FLAGSECTIONS[&#34;spacefilling&#34;]

    @property
    def flags(self):
        &#34;&#34;&#34; return a list of all flags that are currently set &#34;&#34;&#34;
        flag_names = list(self.SECTIONS.keys())
        return [flag for flag in flag_names if getattr(self, f&#34;has{flag}&#34;)]

    @property
    def shortflags(self):
        &#34;&#34;&#34; return a string made from the first letter of each set flag &#34;&#34;&#34;
        return &#34;&#34;.join([flag[0] for flag in self.flags])


    @property
    def VARIABLES(self):
        &#34;&#34;&#34; return variables &#34;&#34;&#34;
        if isinstance(self.SECTIONS[&#34;variables&#34;],script):
            return self.SECTIONS[&#34;variables&#34;].VARIABLES
        else:
            v = regiondata()
            for i in range(len(self.SECTIONS[&#34;variables&#34;].scripts)):
                v = v + self.SECTIONS[&#34;variables&#34;].scripts[i].VARIABLES
            return v

    @property
    def script(self):
        &#34;&#34;&#34; generates a pipe script from sections &#34;&#34;&#34;
        self.update()
        ptmp = self.SECTIONS[&#34;variables&#34;] if self.hasvariables else None
        if self.hasregion:
            ptmp = self.SECTIONS[&#34;region&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;region&#34;]
        if self.hascreate:
            ptmp = self.SECTIONS[&#34;create&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;create&#34;]
        if self.hasgroup:
            ptmp = self.SECTIONS[&#34;group&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;group&#34;]
        if self.hassetgroup:
            ptmp = self.SECTIONS[&#34;setgroup&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;setgroup&#34;]
        if self.hasmove:
            ptmp = self.SECTIONS[&#34;move&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;move&#34;]
        return ptmp
        # before 2023-07-17
        #return self.SECTIONS[&#34;variables&#34;] | self.SECTIONS[&#34;region&#34;] | self.SECTIONS[&#34;create&#34;]

    def do(self,printflag=False,verbosity=1):
        &#34;&#34;&#34; generates a script &#34;&#34;&#34;
        p = self.script # intentional, force script before do(), comment added on 2023-07-17
        cmd = p.do(printflag=printflag,verbosity=verbosity)
        # if printflag: print(cmd)
        return cmd

    def __repr__(self):
        &#34;&#34;&#34; display method&#34;&#34;&#34;
        nVAR = len(self.VARIABLES)
        print(&#34;%s - %s object - beadtype=%d &#34; % (self.name, self.kind,self.beadtype))
        if hasattr(self,&#34;filename&#34;): print(f&#39;\tfilename: &#34;{self.filename}&#34;&#39;)
        if nVAR&gt;0:
            print(f&#34;\t&lt;-- {nVAR} variables are defined --&gt;&#34;)
            print(f&#34;\tUse {self.name}.VARIABLES to see details and their evaluation&#34;)
            for k,v in self.VARIABLES.items():
                v0 = &#39;&#34;&#39;+v+&#39;&#34;&#39; if isinstance(v,str) else repr(v)
                print(wrap(k,&#34;=&#34;,v0,20,40,80))
        print(&#34;\t&lt;-- keyword arg --&gt;&#34;)
        haskeys = False
        for k in (&#34;side&#34;,&#34;move&#34;,&#34;units&#34;,&#34;rotate&#34;,&#34;open&#34;):
            if k in self.USER:
                v = self.USER.getattr(k)
                if v != &#34;&#34;:
                    print(wrap(k,&#34;:&#34;,v[1:],20,60,80))
                    haskeys = True
        if not haskeys: print(wrap(&#34;no keywords&#34;,&#34;&lt;&#34;,&#34;from side|move|units|rotate|open&#34;,20,60,80))
        flags = self.flags
        if flags: print(f&#39;defined scripts: {span(flags,sep=&#34;,&#34;)}&#39;,&#34;\n&#34;)
        print(&#34;\n&#34;+self.geometry) # added 2024-07-05
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind,self.name,self.beadtype)


    # ~~~~ validator for region arguments (the implementation is specific and not generic as fix move ones)
    def sidearg(self,side):
        &#34;&#34;&#34;
            Validation of side arguments for region command (https://docs.lammps.org/region.html)
            side value = in or out
              in = the region is inside the specified geometry
              out = the region is outside the specified geometry
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if side is None:
            return &#34;&#34;
        elif isinstance(side, str):
            side = side.lower()
            if side in (&#34;in&#34;,&#34;out&#34;):
                return f&#34;{prefix} side {side}&#34;
            elif side in (&#34;&#34;,&#34;none&#34;):
                return &#34;&#34;
            else:
                raise ValueError(f&#39;the value of side: &#34;{side}&#34; is not recognized&#39;)
        else:
            raise ValueError(&#39;the parameter side can be &#34;in|out|None&#34;&#39;)

    def movearg(self,move):
        &#34;&#34;&#34;
            Validation of move arguments for region command (https://docs.lammps.org/region.html)
            move args = v_x v_y v_z
              v_x,v_y,v_z = equal-style variables for x,y,z displacement of region over time (distance units)
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if move is None:
            return &#34;&#34;
        elif isinstance(move, str):
            move = move.lower()
            if move in(&#34;&#34;,&#34;none&#34;):
                return &#34;&#34;
            else:
                return f&#34;{prefix} move {move}&#34;
        elif isinstance(move,(list,tuple)):
            if len(move)&lt;3:
                print(&#34;NULL will be added to move&#34;)
            elif len(move)&gt;3:
                print(&#34;move will be truncated to 3 elements&#34;)
            movevalid = [&#34;NULL&#34;,&#34;NULL&#34;,&#34;NULL&#34;]
            for i in range(min(3,len(move))):
                if isinstance(move[i],str):
                    if move[i].upper()!=&#34;NULL&#34;:
                        if prefix in move[i]:
                            # we assume a numeric result after evaluation
                            # Pizza variables will be evaluated
                            # formateval for the evaluation of ${}
                            # eval for residual expressions
                            movevalid[i] = round(eval(self.VARIABLES.formateval(move[i])),6)
                        else:
                            # we assume a variable (LAMMPS variable, not Pizza ones)
                            movevalid[i] = &#34;v_&#34; + move[i]
                elif not isinstance(move[i],(int,float)):
                    if (move[i] is not None):
                        raise TypeError(&#34;move values should be str, int or float&#34;)
            return f&#34;{prefix} move {span(movevalid)}&#34;
        else:
            raise TypeError(&#34;the parameter move should be a list or tuple&#34;)

    def unitsarg(self,units):
        &#34;&#34;&#34;
            Validation for units arguments for region command (https://docs.lammps.org/region.html)
            units value = lattice or box
              lattice = the geometry is defined in lattice units
              box = the geometry is defined in simulation box units
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if units is None:
            return &#34;&#34;
        elif isinstance(units,str):
            units = units.lower()
            if units in (&#34;lattice&#34;,&#34;box&#34;):
                return f&#34;{prefix} units {units}&#34;
            elif (units==&#34;&#34;) or (units==&#34;none&#34;):
                return &#34;&#34;
            else:
                raise ValueError(f&#39;the value of side: &#34;{units}&#34; is not recognized&#39;)
        else:
            raise TypeError(&#39;the parameter units can be &#34;lattice|box|None&#34;&#39;)

    def rotatearg(self,rotate):
        &#34;&#34;&#34;
            Validation of rotate arguments for region command (https://docs.lammps.org/region.html)
            rotate args = v_theta Px Py Pz Rx Ry Rz
              v_theta = equal-style variable for rotaton of region over time (in radians)
              Px,Py,Pz = origin for axis of rotation (distance units)
              Rx,Ry,Rz = axis of rotation vector
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if rotate is None:
            return &#34;&#34;
        elif isinstance(rotate, str):
            rotate = rotate.lower()
            if rotate in (&#34;&#34;,&#34;none&#34;,None):
                return &#34;&#34;
            else:
                return f&#34;{prefix} rotate {rotate}&#34;
        elif isinstance(rotate,(list,tuple)):
            if len(rotate)&lt;7:
                print(&#34;NULL will be added to rotate&#34;)
            elif len(rotate)&gt;7:
                print(&#34;rotate will be truncated to 7 elements&#34;)
            rotatevalid = [&#34;NULL&#34;]*7
            for i in range(min(7,len(rotate))):
                if isinstance(rotate[i],str):
                    if rotate[i].upper()!=&#34;NULL&#34;:
                        if prefix in rotate[i]:
                            rotatevalid[i] = round(eval(self.VARIABLES.formateval(rotate[i])),6)
                        else:
                            rotatevalid[i] = rotate[i]
                elif not isinstance(rotate[i],(int,float)):
                    if (rotate[i] is not None):
                        raise TypeError(&#34;rotate values should be str, int or float&#34;)
            return f&#34;{prefix} move {span(rotatevalid)}&#34;
        else:
            raise TypeError(&#34;the parameter rotate should be a list or tuple&#34;)

    def openarg(self,open):
        &#34;&#34;&#34;
            Validation of open arguments for region command (https://docs.lammps.org/region.html)
            open value = integer from 1-6 corresponding to face index (see below)
            The indices specified as part of the open keyword have the following meanings:

            For style block, indices 1-6 correspond to the xlo, xhi, ylo, yhi, zlo, zhi surfaces of the block.
            I.e. 1 is the yz plane at x = xlo, 2 is the yz-plane at x = xhi, 3 is the xz plane at y = ylo,
            4 is the xz plane at y = yhi, 5 is the xy plane at z = zlo, 6 is the xy plane at z = zhi).
            In the second-to-last example above, the region is a box open at both xy planes.

            For style prism, values 1-6 have the same mapping as for style block.
            I.e. in an untilted prism, open indices correspond to the xlo, xhi, ylo, yhi, zlo, zhi surfaces.

            For style cylinder, index 1 corresponds to the flat end cap at the low coordinate along the cylinder axis,
            index 2 corresponds to the high-coordinate flat end cap along the cylinder axis, and index 3 is the curved
            cylinder surface. For example, a cylinder region with open 1 open 2 keywords will be open at both ends
            (e.g. a section of pipe), regardless of the cylinder orientation.
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if open in (&#34;&#34;,&#34;none&#34;,None):
            return &#34;&#34;
        elif isinstance(open, str):
            raise TypeError(&#34; the parameter open should be an integer or a list/tuple of integers from 1-6&#34;)
        elif isinstance(open, int):
            if open in range(1,7):
                return f&#34;{prefix} open {open}&#34;
            else:
                raise TypeError(&#34; open value should be integer from 1-6&#34;)
        elif isinstance(open, (list,tuple)):
            openvalid = [f&#34;{prefix} open {i}&#34; for i in range(1,7) if i in open]
            return f&#34;$ {span(openvalid)}&#34;
    # ~~~~ end validator for region arguments

    # ~~~~ validator for fix move arguments (implemented generically on 2023-07-17)
    def fixmoveargvalidator(self, argtype, arg, arglen):
        &#34;&#34;&#34;
            Validation of arguments for fix move command in LAMMPS (https://docs.lammps.org/fix_move.html)

            LAMMPS syntax:
                fix ID group-ID move style args
                - linear args = Vx Vy Vz
                - wiggle args = Ax Ay Az period
                - rotate args = Px Py Pz Rx Ry Rz period
                - transrot args = Vx Vy Vz Px Py Pz Rx Ry Rz period
                - variable args = v_dx v_dy v_dz v_vx v_vy v_vz

            Args:
                argtype: Type of the argument (linear, wiggle, rotate, transrot, variable)
                arg: The argument to validate
                arglen: Expected length of the argument
        &#34;&#34;&#34;
        prefix = &#34;$&#34;
        if arg in (&#34;&#34;,&#34;none&#34;,None):
            return &#34;&#34;
        elif isinstance(arg,(list,tuple)):
            if len(arg) &lt; arglen:
                print(f&#34;NULL will be added to {argtype}&#34;)
            elif len(arg) &gt; arglen:
                print(f&#34;{argtype} will be truncated to {arglen} elements&#34;)
            argvalid = [&#34;NULL&#34;]*arglen
            for i in range(min(arglen,len(arg))):
                if isinstance(arg[i],str):
                    if arg[i].upper()!=&#34;NULL&#34;:
                        if prefix in arg[i]:
                            argvalid[i] = round(eval(self.VARIABLES.formateval(arg[i])),6)
                        else:
                            argvalid[i] = arg[i]
                elif not isinstance(arg[i],(int,float)):
                    if (arg[i] is not None):
                        raise TypeError(f&#34;{argtype} values should be str, int or float&#34;)
            return f&#34;{prefix} move {span(argvalid)}&#34;
        else:
            raise TypeError(f&#34;the parameter {argtype} should be a list or tuple&#34;)


    def fixmoveargs(self, linear=None, wiggle=None, rotate=None, transrot=None, variable=None):
        &#34;&#34;&#34;
            Validates all arguments for fix move command in LAMMPS (https://docs.lammps.org/fix_move.html)
            the result is adictionary, all fixmove can be combined
        &#34;&#34;&#34;
        argsdict = {
            &#34;linear&#34;: [linear, 3],
            &#34;wiggle&#34;: [wiggle, 4],
            &#34;rotate&#34;: [rotate, 7],
            &#34;transrot&#34;: [transrot, 10],
            &#34;variable&#34;: [variable, 6]
        }

        for argtype, arginfo in argsdict.items():
            arg, arglen = arginfo
            if arg is not None:
                argsdict[argtype] = self.fixmoveargvalidator(argtype, arg, arglen)
        return argsdict


    def get_fixmovesyntax(self, argtype=None):
        &#34;&#34;&#34;
        Returns the syntax for LAMMPS command, or detailed explanation for a specific argument type

        Args:
        argtype: Optional; Type of the argument (linear, wiggle, rotate, transrot, variable)
        &#34;&#34;&#34;
        syntax = {
            &#34;linear&#34;: &#34;linear args = Vx Vy Vz\n&#34;
                      &#34;Vx,Vy,Vz = components of velocity vector (velocity units), any component can be specified as NULL&#34;,
            &#34;wiggle&#34;: &#34;wiggle args = Ax Ay Az period\n&#34;
                       &#34;Ax,Ay,Az = components of amplitude vector (distance units), any component can be specified as NULL\n&#34;
                       &#34;period = period of oscillation (time units)&#34;,
            &#34;rotate&#34;: &#34;rotate args = Px Py Pz Rx Ry Rz period\n&#34;
                       &#34;Px,Py,Pz = origin point of axis of rotation (distance units)\n&#34;
                       &#34;Rx,Ry,Rz = axis of rotation vector\n&#34;
                       &#34;period = period of rotation (time units)&#34;,
            &#34;transrot&#34;: &#34;transrot args = Vx Vy Vz Px Py Pz Rx Ry Rz period\n&#34;
                        &#34;Vx,Vy,Vz = components of velocity vector (velocity units)\n&#34;
                        &#34;Px,Py,Pz = origin point of axis of rotation (distance units)\n&#34;
                        &#34;Rx,Ry,Rz = axis of rotation vector\n&#34;
                        &#34;period = period of rotation (time units)&#34;,
            &#34;variable&#34;: &#34;variable args = v_dx v_dy v_dz v_vx v_vy v_vz\n&#34;
                        &#34;v_dx,v_dy,v_dz = 3 variable names that calculate x,y,z displacement as function of time, any component can be specified as NULL\n&#34;
                        &#34;v_vx,v_vy,v_vz = 3 variable names that calculate x,y,z velocity as function of time, any component can be specified as NULL&#34;,
        }

        base_syntax = (
            &#34;fix ID group-ID move style args\n&#34;
            &#34; - linear args = Vx Vy Vz\n&#34;
            &#34; - wiggle args = Ax Ay Az period\n&#34;
            &#34; - rotate args = Px Py Pz Rx Ry Rz period\n&#34;
            &#34; - transrot args = Vx Vy Vz Px Py Pz Rx Ry Rz period\n&#34;
            &#34; - variable args = v_dx v_dy v_dz v_vx v_vy v_vz\n\n&#34;
            &#39;use get_movesyntax(&#34;movemethod&#34;) for details&#39;
            &#34;manual: https://docs.lammps.org/fix_move.html&#34;
        )

        return syntax.get(argtype, base_syntax)

    # ~~~~ end validator for fix move arguments

    def __add__(self,C):
        &#34;&#34;&#34; overload addition (&#34;+&#34;) operator &#34;&#34;&#34;
        if isinstance(C,coregeometry):
            dup = deepduplicate(self)
            dup.name = cleanname(self.name) +&#34;+&#34;+ cleanname(C.name)
            dup.USER = dup.USER + C.USER
            dup.USER.ID = &#34;$&#34; + cleanname(self.USER.ID) +&#34;+&#34;+ cleanname(C.USER.ID)
            dup.SECTIONS[&#34;variables&#34;] = dup.SECTIONS[&#34;variables&#34;] + C.SECTIONS[&#34;variables&#34;]
            dup.SECTIONS[&#34;region&#34;] = dup.SECTIONS[&#34;region&#34;] + C.SECTIONS[&#34;region&#34;]
            dup.SECTIONS[&#34;create&#34;] = dup.SECTIONS[&#34;create&#34;] + C.SECTIONS[&#34;create&#34;]
            dup.SECTIONS[&#34;group&#34;] = dup.SECTIONS[&#34;group&#34;] + C.SECTIONS[&#34;group&#34;]
            dup.SECTIONS[&#34;move&#34;] = dup.SECTIONS[&#34;move&#34;] + C.SECTIONS[&#34;move&#34;]
            dup.FLAGSECTIONS[&#34;variables&#34;] = dup.FLAGSECTIONS[&#34;variables&#34;] or C.FLAGSECTIONS[&#34;variables&#34;]
            dup.FLAGSECTIONS[&#34;region&#34;] = dup.FLAGSECTIONS[&#34;region&#34;] or C.FLAGSECTIONS[&#34;region&#34;]
            dup.FLAGSECTIONS[&#34;create&#34;] = dup.FLAGSECTIONS[&#34;create&#34;] or C.FLAGSECTIONS[&#34;create&#34;]
            dup.FLAGSECTIONS[&#34;group&#34;] = dup.FLAGSECTIONS[&#34;group&#34;] or C.FLAGSECTIONS[&#34;group&#34;]
            dup.FLAGSECTIONS[&#34;move&#34;] = dup.FLAGSECTIONS[&#34;move&#34;] or C.FLAGSECTIONS[&#34;move&#34;]
            return dup
        raise TypeError(&#34;the second operand must a region.coregeometry object&#34;)

    def __iadd__(self,C):
        &#34;&#34;&#34; overload iaddition (&#34;+=&#34;) operator &#34;&#34;&#34;
        if isinstance(C,coregeometry):
            self.USER += C.USER
            self.SECTIONS[&#34;variables&#34;] += C.SECTIONS[&#34;variables&#34;]
            self.SECTIONS[&#34;region&#34;] += C.SECTIONS[&#34;region&#34;]
            self.SECTIONS[&#34;create&#34;] += C.SECTIONS[&#34;create&#34;]
            self.SECTIONS[&#34;group&#34;] += C.SECTIONS[&#34;group&#34;]
            self.SECTIONS[&#34;move&#34;] += C.SECTIONS[&#34;move&#34;]
            self.FLAGSECTIONS[&#34;variables&#34;] = self.FLAGSECTIONS[&#34;variables&#34;] or C.FLAGSECTIONS[&#34;variables&#34;]
            self.FLAGSECTIONS[&#34;region&#34;] = self.FLAGSECTIONS[&#34;region&#34;] or C.FLAGSECTIONS[&#34;region&#34;]
            self.FLAGSECTIONS[&#34;create&#34;] = self.FLAGSECTIONS[&#34;create&#34;] or C.FLAGSECTIONS[&#34;create&#34;]
            self.FLAGSECTIONS[&#34;group&#34;] = self.FLAGSECTIONS[&#34;group&#34;] or C.FLAGSECTIONS[&#34;group&#34;]
            self.FLAGSECTIONS[&#34;move&#34;] = self.FLAGSECTIONS[&#34;move&#34;] or C.FLAGSECTIONS[&#34;move&#34;]
            return self
        raise TypeError(&#34;the operand must a region.coregeometry object&#34;)

    def __or__(self,C):
        &#34;&#34;&#34; overload | pipe &#34;&#34;&#34;
        if isinstance(C,coregeometry):
            dup = deepduplicate(self)
            dup.name = cleanname(self.name) +&#34;|&#34;+ cleanname(C.name)
            dup.USER = dup.USER + C.USER
            dup.USER.ID = &#34;$&#34; + cleanname(self.USER.ID) +&#34;|&#34;+ cleanname(C.USER.ID)
            dup.SECTIONS[&#34;variables&#34;] = dup.SECTIONS[&#34;variables&#34;] | C.SECTIONS[&#34;variables&#34;]
            dup.SECTIONS[&#34;region&#34;] = dup.SECTIONS[&#34;region&#34;] | C.SECTIONS[&#34;region&#34;]
            dup.SECTIONS[&#34;create&#34;] = dup.SECTIONS[&#34;create&#34;] | C.SECTIONS[&#34;create&#34;]
            dup.SECTIONS[&#34;group&#34;] = dup.SECTIONS[&#34;group&#34;] | C.SECTIONS[&#34;group&#34;]
            dup.SECTIONS[&#34;move&#34;] = dup.SECTIONS[&#34;move&#34;] | C.SECTIONS[&#34;move&#34;]
            self.FLAGSECTIONS[&#34;variables&#34;] = self.FLAGSECTIONS[&#34;variables&#34;] or C.FLAGSECTIONS[&#34;variables&#34;]
            self.FLAGSECTIONS[&#34;region&#34;] = self.FLAGSECTIONS[&#34;region&#34;] or C.FLAGSECTIONS[&#34;region&#34;]
            self.FLAGSECTIONS[&#34;create&#34;] = self.FLAGSECTIONS[&#34;create&#34;] or C.FLAGSECTIONS[&#34;create&#34;]
            self.FLAGSECTIONS[&#34;group&#34;] = self.FLAGSECTIONS[&#34;group&#34;] or C.FLAGSECTIONS[&#34;group&#34;]
            self.FLAGSECTIONS[&#34;move&#34;] = self.FLAGSECTIONS[&#34;move&#34;] or C.FLAGSECTIONS[&#34;move&#34;]
            return dup
        raise TypeError(&#34;the second operand must a region.coregeometry object&#34;)

    # copy and deep copy methods for the class (required)
    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo)) # replace duplicatedeep by deepduplicate (OV: 2023-07-28)
        return copie

    # Return the number of atoms
    @property
    def natoms(self):
        &#34;&#34;&#34;Calculate the number of beads based on density, mass, and volume&#34;&#34;&#34;
        if hasattr(self, &#39;volume&#39;):
            try:
                volume_siunits = self.volume(&#34;si&#34;)
                voxel_volume_siunits = self.lattice_scale**3
                number_of_beads = volume_siunits / voxel_volume_siunits
                packing_factors = {
                    &#39;sc&#39;: 1.0,
                    &#39;fcc&#39;: 4.0,
                    &#39;bcc&#39;: 2.0,
                    &#39;hcp&#39;: 6.0,  # Approximate value, requires specific volume calculation for accuracy
                    &#39;dia&#39;: 8.0,
                    &#39;bco&#39;: 2.0,  # Assuming orthorhombic lattice similar to bcc
                    &#39;fco&#39;: 4.0,  # Assuming orthorhombic lattice similar to fcc
                }
                packing_factor = packing_factors.get(self.lattice_style, 1.0)  # Default to simple cubic if unknown
                number_of_beads *= packing_factor
                return round(number_of_beads)
            except Exception as e:
                print(f&#34;Error calculating number of beads: {e}&#34;)
                return None
        else:
            print(&#34;Volume attribute is missing.&#34;)
            return None

    # return parent region details
    @property
    def regiondetails(self):
        return &#34;\n&#34;.join((
        f&#34;\n--- | Region Details | ---&#34;,
        f&#34;Name: {self.name}&#34;,
        f&#34;Lattice Style: {self.lattice_style}&#34;,
        f&#34;Lattice Scale: {self.lattice_scale}&#34;,
        f&#34;Lattice Scale (SI units): {self.lattice_scale_siunits}&#34;,
        f&#34;Volume: {self.volume()}&#34;,
        f&#34;Volume (SI units): {self.volume(&#39;si&#39;)}&#34;,
        f&#34;Number of Atoms: {self.natoms}&#34;,&#34;\n&#34;
        ))


    # return geometry details (2024-07-04)
    @property
    def geometry(self):
        &#34;&#34;&#34;Return the geometry details of the object.&#34;&#34;&#34;
        details = self.regiondetails
        details += &#34;\n--- | Geometry Details | ---\n&#34;
        if hasattr(self.USER, &#39;geometry&#39;):
            details += self.USER.geometry
        else:
            details = &#34;No geometry available.\n&#34;
        return details</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="region.Block" href="#region.Block">Block</a></li>
<li><a title="region.Cone" href="#region.Cone">Cone</a></li>
<li><a title="region.Cylinder" href="#region.Cylinder">Cylinder</a></li>
<li><a title="region.Ellipsoid" href="#region.Ellipsoid">Ellipsoid</a></li>
<li><a title="region.Evalgeometry" href="#region.Evalgeometry">Evalgeometry</a></li>
<li><a title="region.Intersect" href="#region.Intersect">Intersect</a></li>
<li><a title="region.Plane" href="#region.Plane">Plane</a></li>
<li><a title="region.Prism" href="#region.Prism">Prism</a></li>
<li><a title="region.Sphere" href="#region.Sphere">Sphere</a></li>
<li><a title="region.Union" href="#region.Union">Union</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="region.coregeometry.VARIABLES"><code class="name">var <span class="ident">VARIABLES</span></code></dt>
<dd>
<div class="desc"><p>return variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def VARIABLES(self):
    &#34;&#34;&#34; return variables &#34;&#34;&#34;
    if isinstance(self.SECTIONS[&#34;variables&#34;],script):
        return self.SECTIONS[&#34;variables&#34;].VARIABLES
    else:
        v = regiondata()
        for i in range(len(self.SECTIONS[&#34;variables&#34;].scripts)):
            v = v + self.SECTIONS[&#34;variables&#34;].scripts[i].VARIABLES
        return v</code></pre>
</details>
</dd>
<dt id="region.coregeometry.flags"><code class="name">var <span class="ident">flags</span></code></dt>
<dd>
<div class="desc"><p>return a list of all flags that are currently set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flags(self):
    &#34;&#34;&#34; return a list of all flags that are currently set &#34;&#34;&#34;
    flag_names = list(self.SECTIONS.keys())
    return [flag for flag in flag_names if getattr(self, f&#34;has{flag}&#34;)]</code></pre>
</details>
</dd>
<dt id="region.coregeometry.geometry"><code class="name">var <span class="ident">geometry</span></code></dt>
<dd>
<div class="desc"><p>Return the geometry details of the object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def geometry(self):
    &#34;&#34;&#34;Return the geometry details of the object.&#34;&#34;&#34;
    details = self.regiondetails
    details += &#34;\n--- | Geometry Details | ---\n&#34;
    if hasattr(self.USER, &#39;geometry&#39;):
        details += self.USER.geometry
    else:
        details = &#34;No geometry available.\n&#34;
    return details</code></pre>
</details>
</dd>
<dt id="region.coregeometry.hascreate"><code class="name">var <span class="ident">hascreate</span></code></dt>
<dd>
<div class="desc"><p>return the flag CREATE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hascreate(self):
    &#34;&#34;&#34; return the flag CREATE &#34;&#34;&#34;
    return isinstance(self.SECTIONS[&#34;create&#34;],script) \
           and self.FLAGSECTIONS[&#34;create&#34;] \
           and (not self.spacefilling)</code></pre>
</details>
</dd>
<dt id="region.coregeometry.hasgroup"><code class="name">var <span class="ident">hasgroup</span></code></dt>
<dd>
<div class="desc"><p>return the flag GROUP</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hasgroup(self):
    &#34;&#34;&#34; return the flag GROUP &#34;&#34;&#34;
    return isinstance(self.SECTIONS[&#34;group&#34;],script) \
           and self.FLAGSECTIONS[&#34;group&#34;]</code></pre>
</details>
</dd>
<dt id="region.coregeometry.hasmove"><code class="name">var <span class="ident">hasmove</span></code></dt>
<dd>
<div class="desc"><p>return the flag MOVE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hasmove(self):
    &#34;&#34;&#34; return the flag MOVE &#34;&#34;&#34;
    return isinstance(self.SECTIONS[&#34;move&#34;],script) \
           and self.FLAGSECTIONS[&#34;move&#34;]</code></pre>
</details>
</dd>
<dt id="region.coregeometry.hasregion"><code class="name">var <span class="ident">hasregion</span></code></dt>
<dd>
<div class="desc"><p>return the flag REGION</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hasregion(self):
    &#34;&#34;&#34; return the flag REGION &#34;&#34;&#34;
    return isinstance(self.SECTIONS[&#34;region&#34;],script) \
           and self.FLAGSECTIONS[&#34;region&#34;]</code></pre>
</details>
</dd>
<dt id="region.coregeometry.hassetgroup"><code class="name">var <span class="ident">hassetgroup</span></code></dt>
<dd>
<div class="desc"><p>return the flag GROUP</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hassetgroup(self):
    &#34;&#34;&#34; return the flag GROUP &#34;&#34;&#34;
    return isinstance(self.SECTIONS[&#34;setgroup&#34;],script) \
           and self.FLAGSECTIONS[&#34;setgroup&#34;] \
           and self.hasgroup \
           and (not self.hascreate)</code></pre>
</details>
</dd>
<dt id="region.coregeometry.hasvariables"><code class="name">var <span class="ident">hasvariables</span></code></dt>
<dd>
<div class="desc"><p>return the flag VARIABLES</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hasvariables(self):
    &#34;&#34;&#34; return the flag VARIABLES &#34;&#34;&#34;
    return isinstance(self.SECTIONS[&#34;variables&#34;],script) \
           and self.FLAGSECTIONS[&#34;variables&#34;]</code></pre>
</details>
</dd>
<dt id="region.coregeometry.isspacefilled"><code class="name">var <span class="ident">isspacefilled</span></code></dt>
<dd>
<div class="desc"><p>return the flag spacefilling</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isspacefilled(self):
    &#34;&#34;&#34; return the flag spacefilling &#34;&#34;&#34;
    return isinstance(self.SECTIONS[&#34;spacefilling&#34;],script) \
           and self.FLAGSECTIONS[&#34;spacefilling&#34;]</code></pre>
</details>
</dd>
<dt id="region.coregeometry.natoms"><code class="name">var <span class="ident">natoms</span></code></dt>
<dd>
<div class="desc"><p>Calculate the number of beads based on density, mass, and volume</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def natoms(self):
    &#34;&#34;&#34;Calculate the number of beads based on density, mass, and volume&#34;&#34;&#34;
    if hasattr(self, &#39;volume&#39;):
        try:
            volume_siunits = self.volume(&#34;si&#34;)
            voxel_volume_siunits = self.lattice_scale**3
            number_of_beads = volume_siunits / voxel_volume_siunits
            packing_factors = {
                &#39;sc&#39;: 1.0,
                &#39;fcc&#39;: 4.0,
                &#39;bcc&#39;: 2.0,
                &#39;hcp&#39;: 6.0,  # Approximate value, requires specific volume calculation for accuracy
                &#39;dia&#39;: 8.0,
                &#39;bco&#39;: 2.0,  # Assuming orthorhombic lattice similar to bcc
                &#39;fco&#39;: 4.0,  # Assuming orthorhombic lattice similar to fcc
            }
            packing_factor = packing_factors.get(self.lattice_style, 1.0)  # Default to simple cubic if unknown
            number_of_beads *= packing_factor
            return round(number_of_beads)
        except Exception as e:
            print(f&#34;Error calculating number of beads: {e}&#34;)
            return None
    else:
        print(&#34;Volume attribute is missing.&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="region.coregeometry.regiondetails"><code class="name">var <span class="ident">regiondetails</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def regiondetails(self):
    return &#34;\n&#34;.join((
    f&#34;\n--- | Region Details | ---&#34;,
    f&#34;Name: {self.name}&#34;,
    f&#34;Lattice Style: {self.lattice_style}&#34;,
    f&#34;Lattice Scale: {self.lattice_scale}&#34;,
    f&#34;Lattice Scale (SI units): {self.lattice_scale_siunits}&#34;,
    f&#34;Volume: {self.volume()}&#34;,
    f&#34;Volume (SI units): {self.volume(&#39;si&#39;)}&#34;,
    f&#34;Number of Atoms: {self.natoms}&#34;,&#34;\n&#34;
    ))</code></pre>
</details>
</dd>
<dt id="region.coregeometry.script"><code class="name">var <span class="ident">script</span></code></dt>
<dd>
<div class="desc"><p>generates a pipe script from sections</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def script(self):
    &#34;&#34;&#34; generates a pipe script from sections &#34;&#34;&#34;
    self.update()
    ptmp = self.SECTIONS[&#34;variables&#34;] if self.hasvariables else None
    if self.hasregion:
        ptmp = self.SECTIONS[&#34;region&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;region&#34;]
    if self.hascreate:
        ptmp = self.SECTIONS[&#34;create&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;create&#34;]
    if self.hasgroup:
        ptmp = self.SECTIONS[&#34;group&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;group&#34;]
    if self.hassetgroup:
        ptmp = self.SECTIONS[&#34;setgroup&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;setgroup&#34;]
    if self.hasmove:
        ptmp = self.SECTIONS[&#34;move&#34;] if ptmp is None else ptmp | self.SECTIONS[&#34;move&#34;]
    return ptmp
    # before 2023-07-17
    #return self.SECTIONS[&#34;variables&#34;] | self.SECTIONS[&#34;region&#34;] | self.SECTIONS[&#34;create&#34;]</code></pre>
</details>
</dd>
<dt id="region.coregeometry.shortflags"><code class="name">var <span class="ident">shortflags</span></code></dt>
<dd>
<div class="desc"><p>return a string made from the first letter of each set flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shortflags(self):
    &#34;&#34;&#34; return a string made from the first letter of each set flag &#34;&#34;&#34;
    return &#34;&#34;.join([flag[0] for flag in self.flags])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.coregeometry.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, beadtype=None, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>returns a copy of the graphical object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self,beadtype=None,name=&#34;&#34;):
    &#34;&#34;&#34; returns a copy of the graphical object &#34;&#34;&#34;
    if self.alike != &#34;mixed&#34;:
        dup = deepduplicate(self)
        if beadtype != None: # update beadtype
            dup.beadtype = beadtype
        if name != &#34;&#34;: # update name
            dup.name = name
        return dup
    else:
        raise ValueError(&#34;collections cannot be copied, regenerate the collection instead&#34;)</code></pre>
</details>
</dd>
<dt id="region.coregeometry.creategroup"><code class="name flex">
<span>def <span class="ident">creategroup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>force the group creation in script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def creategroup(self):
    &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
    self.FLAGSECTIONS[&#34;group&#34;] = True</code></pre>
</details>
</dd>
<dt id="region.coregeometry.createmove"><code class="name flex">
<span>def <span class="ident">createmove</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>force the fix move creation in script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createmove(self):
    &#34;&#34;&#34;  force the fix move creation in script &#34;&#34;&#34;
    self.FLAGSECTIONS[&#34;move&#34;] = True</code></pre>
</details>
</dd>
<dt id="region.coregeometry.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, printflag=False, verbosity=1)</span>
</code></dt>
<dd>
<div class="desc"><p>generates a script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self,printflag=False,verbosity=1):
    &#34;&#34;&#34; generates a script &#34;&#34;&#34;
    p = self.script # intentional, force script before do(), comment added on 2023-07-17
    cmd = p.do(printflag=printflag,verbosity=verbosity)
    # if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="region.coregeometry.fixmoveargs"><code class="name flex">
<span>def <span class="ident">fixmoveargs</span></span>(<span>self, linear=None, wiggle=None, rotate=None, transrot=None, variable=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Validates all arguments for fix move command in LAMMPS (<a href="https://docs.lammps.org/fix_move.html">https://docs.lammps.org/fix_move.html</a>)
the result is adictionary, all fixmove can be combined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixmoveargs(self, linear=None, wiggle=None, rotate=None, transrot=None, variable=None):
    &#34;&#34;&#34;
        Validates all arguments for fix move command in LAMMPS (https://docs.lammps.org/fix_move.html)
        the result is adictionary, all fixmove can be combined
    &#34;&#34;&#34;
    argsdict = {
        &#34;linear&#34;: [linear, 3],
        &#34;wiggle&#34;: [wiggle, 4],
        &#34;rotate&#34;: [rotate, 7],
        &#34;transrot&#34;: [transrot, 10],
        &#34;variable&#34;: [variable, 6]
    }

    for argtype, arginfo in argsdict.items():
        arg, arglen = arginfo
        if arg is not None:
            argsdict[argtype] = self.fixmoveargvalidator(argtype, arg, arglen)
    return argsdict</code></pre>
</details>
</dd>
<dt id="region.coregeometry.fixmoveargvalidator"><code class="name flex">
<span>def <span class="ident">fixmoveargvalidator</span></span>(<span>self, argtype, arg, arglen)</span>
</code></dt>
<dd>
<div class="desc"><p>Validation of arguments for fix move command in LAMMPS (<a href="https://docs.lammps.org/fix_move.html">https://docs.lammps.org/fix_move.html</a>)</p>
<p>LAMMPS syntax:
fix ID group-ID move style args
- linear args = Vx Vy Vz
- wiggle args = Ax Ay Az period
- rotate args = Px Py Pz Rx Ry Rz period
- transrot args = Vx Vy Vz Px Py Pz Rx Ry Rz period
- variable args = v_dx v_dy v_dz v_vx v_vy v_vz</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>argtype</code></strong></dt>
<dd>Type of the argument (linear, wiggle, rotate, transrot, variable)</dd>
<dt><strong><code>arg</code></strong></dt>
<dd>The argument to validate</dd>
<dt><strong><code>arglen</code></strong></dt>
<dd>Expected length of the argument</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixmoveargvalidator(self, argtype, arg, arglen):
    &#34;&#34;&#34;
        Validation of arguments for fix move command in LAMMPS (https://docs.lammps.org/fix_move.html)

        LAMMPS syntax:
            fix ID group-ID move style args
            - linear args = Vx Vy Vz
            - wiggle args = Ax Ay Az period
            - rotate args = Px Py Pz Rx Ry Rz period
            - transrot args = Vx Vy Vz Px Py Pz Rx Ry Rz period
            - variable args = v_dx v_dy v_dz v_vx v_vy v_vz

        Args:
            argtype: Type of the argument (linear, wiggle, rotate, transrot, variable)
            arg: The argument to validate
            arglen: Expected length of the argument
    &#34;&#34;&#34;
    prefix = &#34;$&#34;
    if arg in (&#34;&#34;,&#34;none&#34;,None):
        return &#34;&#34;
    elif isinstance(arg,(list,tuple)):
        if len(arg) &lt; arglen:
            print(f&#34;NULL will be added to {argtype}&#34;)
        elif len(arg) &gt; arglen:
            print(f&#34;{argtype} will be truncated to {arglen} elements&#34;)
        argvalid = [&#34;NULL&#34;]*arglen
        for i in range(min(arglen,len(arg))):
            if isinstance(arg[i],str):
                if arg[i].upper()!=&#34;NULL&#34;:
                    if prefix in arg[i]:
                        argvalid[i] = round(eval(self.VARIABLES.formateval(arg[i])),6)
                    else:
                        argvalid[i] = arg[i]
            elif not isinstance(arg[i],(int,float)):
                if (arg[i] is not None):
                    raise TypeError(f&#34;{argtype} values should be str, int or float&#34;)
        return f&#34;{prefix} move {span(argvalid)}&#34;
    else:
        raise TypeError(f&#34;the parameter {argtype} should be a list or tuple&#34;)</code></pre>
</details>
</dd>
<dt id="region.coregeometry.get_fixmovesyntax"><code class="name flex">
<span>def <span class="ident">get_fixmovesyntax</span></span>(<span>self, argtype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the syntax for LAMMPS command, or detailed explanation for a specific argument type</p>
<p>Args:
argtype: Optional; Type of the argument (linear, wiggle, rotate, transrot, variable)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fixmovesyntax(self, argtype=None):
    &#34;&#34;&#34;
    Returns the syntax for LAMMPS command, or detailed explanation for a specific argument type

    Args:
    argtype: Optional; Type of the argument (linear, wiggle, rotate, transrot, variable)
    &#34;&#34;&#34;
    syntax = {
        &#34;linear&#34;: &#34;linear args = Vx Vy Vz\n&#34;
                  &#34;Vx,Vy,Vz = components of velocity vector (velocity units), any component can be specified as NULL&#34;,
        &#34;wiggle&#34;: &#34;wiggle args = Ax Ay Az period\n&#34;
                   &#34;Ax,Ay,Az = components of amplitude vector (distance units), any component can be specified as NULL\n&#34;
                   &#34;period = period of oscillation (time units)&#34;,
        &#34;rotate&#34;: &#34;rotate args = Px Py Pz Rx Ry Rz period\n&#34;
                   &#34;Px,Py,Pz = origin point of axis of rotation (distance units)\n&#34;
                   &#34;Rx,Ry,Rz = axis of rotation vector\n&#34;
                   &#34;period = period of rotation (time units)&#34;,
        &#34;transrot&#34;: &#34;transrot args = Vx Vy Vz Px Py Pz Rx Ry Rz period\n&#34;
                    &#34;Vx,Vy,Vz = components of velocity vector (velocity units)\n&#34;
                    &#34;Px,Py,Pz = origin point of axis of rotation (distance units)\n&#34;
                    &#34;Rx,Ry,Rz = axis of rotation vector\n&#34;
                    &#34;period = period of rotation (time units)&#34;,
        &#34;variable&#34;: &#34;variable args = v_dx v_dy v_dz v_vx v_vy v_vz\n&#34;
                    &#34;v_dx,v_dy,v_dz = 3 variable names that calculate x,y,z displacement as function of time, any component can be specified as NULL\n&#34;
                    &#34;v_vx,v_vy,v_vz = 3 variable names that calculate x,y,z velocity as function of time, any component can be specified as NULL&#34;,
    }

    base_syntax = (
        &#34;fix ID group-ID move style args\n&#34;
        &#34; - linear args = Vx Vy Vz\n&#34;
        &#34; - wiggle args = Ax Ay Az period\n&#34;
        &#34; - rotate args = Px Py Pz Rx Ry Rz period\n&#34;
        &#34; - transrot args = Vx Vy Vz Px Py Pz Rx Ry Rz period\n&#34;
        &#34; - variable args = v_dx v_dy v_dz v_vx v_vy v_vz\n\n&#34;
        &#39;use get_movesyntax(&#34;movemethod&#34;) for details&#39;
        &#34;manual: https://docs.lammps.org/fix_move.html&#34;
    )

    return syntax.get(argtype, base_syntax)</code></pre>
</details>
</dd>
<dt id="region.coregeometry.movearg"><code class="name flex">
<span>def <span class="ident">movearg</span></span>(<span>self, move)</span>
</code></dt>
<dd>
<div class="desc"><p>Validation of move arguments for region command (<a href="https://docs.lammps.org/region.html">https://docs.lammps.org/region.html</a>)
move args = v_x v_y v_z
v_x,v_y,v_z = equal-style variables for x,y,z displacement of region over time (distance units)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def movearg(self,move):
    &#34;&#34;&#34;
        Validation of move arguments for region command (https://docs.lammps.org/region.html)
        move args = v_x v_y v_z
          v_x,v_y,v_z = equal-style variables for x,y,z displacement of region over time (distance units)
    &#34;&#34;&#34;
    prefix = &#34;$&#34;
    if move is None:
        return &#34;&#34;
    elif isinstance(move, str):
        move = move.lower()
        if move in(&#34;&#34;,&#34;none&#34;):
            return &#34;&#34;
        else:
            return f&#34;{prefix} move {move}&#34;
    elif isinstance(move,(list,tuple)):
        if len(move)&lt;3:
            print(&#34;NULL will be added to move&#34;)
        elif len(move)&gt;3:
            print(&#34;move will be truncated to 3 elements&#34;)
        movevalid = [&#34;NULL&#34;,&#34;NULL&#34;,&#34;NULL&#34;]
        for i in range(min(3,len(move))):
            if isinstance(move[i],str):
                if move[i].upper()!=&#34;NULL&#34;:
                    if prefix in move[i]:
                        # we assume a numeric result after evaluation
                        # Pizza variables will be evaluated
                        # formateval for the evaluation of ${}
                        # eval for residual expressions
                        movevalid[i] = round(eval(self.VARIABLES.formateval(move[i])),6)
                    else:
                        # we assume a variable (LAMMPS variable, not Pizza ones)
                        movevalid[i] = &#34;v_&#34; + move[i]
            elif not isinstance(move[i],(int,float)):
                if (move[i] is not None):
                    raise TypeError(&#34;move values should be str, int or float&#34;)
        return f&#34;{prefix} move {span(movevalid)}&#34;
    else:
        raise TypeError(&#34;the parameter move should be a list or tuple&#34;)</code></pre>
</details>
</dd>
<dt id="region.coregeometry.openarg"><code class="name flex">
<span>def <span class="ident">openarg</span></span>(<span>self, open)</span>
</code></dt>
<dd>
<div class="desc"><p>Validation of open arguments for region command (<a href="https://docs.lammps.org/region.html">https://docs.lammps.org/region.html</a>)
open value = integer from 1-6 corresponding to face index (see below)
The indices specified as part of the open keyword have the following meanings:</p>
<p>For style block, indices 1-6 correspond to the xlo, xhi, ylo, yhi, zlo, zhi surfaces of the block.
I.e. 1 is the yz plane at x = xlo, 2 is the yz-plane at x = xhi, 3 is the xz plane at y = ylo,
4 is the xz plane at y = yhi, 5 is the xy plane at z = zlo, 6 is the xy plane at z = zhi).
In the second-to-last example above, the region is a box open at both xy planes.</p>
<p>For style prism, values 1-6 have the same mapping as for style block.
I.e. in an untilted prism, open indices correspond to the xlo, xhi, ylo, yhi, zlo, zhi surfaces.</p>
<p>For style cylinder, index 1 corresponds to the flat end cap at the low coordinate along the cylinder axis,
index 2 corresponds to the high-coordinate flat end cap along the cylinder axis, and index 3 is the curved
cylinder surface. For example, a cylinder region with open 1 open 2 keywords will be open at both ends
(e.g. a section of pipe), regardless of the cylinder orientation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openarg(self,open):
    &#34;&#34;&#34;
        Validation of open arguments for region command (https://docs.lammps.org/region.html)
        open value = integer from 1-6 corresponding to face index (see below)
        The indices specified as part of the open keyword have the following meanings:

        For style block, indices 1-6 correspond to the xlo, xhi, ylo, yhi, zlo, zhi surfaces of the block.
        I.e. 1 is the yz plane at x = xlo, 2 is the yz-plane at x = xhi, 3 is the xz plane at y = ylo,
        4 is the xz plane at y = yhi, 5 is the xy plane at z = zlo, 6 is the xy plane at z = zhi).
        In the second-to-last example above, the region is a box open at both xy planes.

        For style prism, values 1-6 have the same mapping as for style block.
        I.e. in an untilted prism, open indices correspond to the xlo, xhi, ylo, yhi, zlo, zhi surfaces.

        For style cylinder, index 1 corresponds to the flat end cap at the low coordinate along the cylinder axis,
        index 2 corresponds to the high-coordinate flat end cap along the cylinder axis, and index 3 is the curved
        cylinder surface. For example, a cylinder region with open 1 open 2 keywords will be open at both ends
        (e.g. a section of pipe), regardless of the cylinder orientation.
    &#34;&#34;&#34;
    prefix = &#34;$&#34;
    if open in (&#34;&#34;,&#34;none&#34;,None):
        return &#34;&#34;
    elif isinstance(open, str):
        raise TypeError(&#34; the parameter open should be an integer or a list/tuple of integers from 1-6&#34;)
    elif isinstance(open, int):
        if open in range(1,7):
            return f&#34;{prefix} open {open}&#34;
        else:
            raise TypeError(&#34; open value should be integer from 1-6&#34;)
    elif isinstance(open, (list,tuple)):
        openvalid = [f&#34;{prefix} open {i}&#34; for i in range(1,7) if i in open]
        return f&#34;$ {span(openvalid)}&#34;</code></pre>
</details>
</dd>
<dt id="region.coregeometry.removegroup"><code class="name flex">
<span>def <span class="ident">removegroup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>force the group creation in script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removegroup(self):
    &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
    self.FLAGSECTIONS[&#34;group&#34;] = False</code></pre>
</details>
</dd>
<dt id="region.coregeometry.removemove"><code class="name flex">
<span>def <span class="ident">removemove</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>force the fix move creation in script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removemove(self):
    &#34;&#34;&#34;  force the fix move creation in script &#34;&#34;&#34;
    self.FLAGSECTIONS[&#34;move&#34;] = False</code></pre>
</details>
</dd>
<dt id="region.coregeometry.rotatearg"><code class="name flex">
<span>def <span class="ident">rotatearg</span></span>(<span>self, rotate)</span>
</code></dt>
<dd>
<div class="desc"><p>Validation of rotate arguments for region command (<a href="https://docs.lammps.org/region.html">https://docs.lammps.org/region.html</a>)
rotate args = v_theta Px Py Pz Rx Ry Rz
v_theta = equal-style variable for rotaton of region over time (in radians)
Px,Py,Pz = origin for axis of rotation (distance units)
Rx,Ry,Rz = axis of rotation vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotatearg(self,rotate):
    &#34;&#34;&#34;
        Validation of rotate arguments for region command (https://docs.lammps.org/region.html)
        rotate args = v_theta Px Py Pz Rx Ry Rz
          v_theta = equal-style variable for rotaton of region over time (in radians)
          Px,Py,Pz = origin for axis of rotation (distance units)
          Rx,Ry,Rz = axis of rotation vector
    &#34;&#34;&#34;
    prefix = &#34;$&#34;
    if rotate is None:
        return &#34;&#34;
    elif isinstance(rotate, str):
        rotate = rotate.lower()
        if rotate in (&#34;&#34;,&#34;none&#34;,None):
            return &#34;&#34;
        else:
            return f&#34;{prefix} rotate {rotate}&#34;
    elif isinstance(rotate,(list,tuple)):
        if len(rotate)&lt;7:
            print(&#34;NULL will be added to rotate&#34;)
        elif len(rotate)&gt;7:
            print(&#34;rotate will be truncated to 7 elements&#34;)
        rotatevalid = [&#34;NULL&#34;]*7
        for i in range(min(7,len(rotate))):
            if isinstance(rotate[i],str):
                if rotate[i].upper()!=&#34;NULL&#34;:
                    if prefix in rotate[i]:
                        rotatevalid[i] = round(eval(self.VARIABLES.formateval(rotate[i])),6)
                    else:
                        rotatevalid[i] = rotate[i]
            elif not isinstance(rotate[i],(int,float)):
                if (rotate[i] is not None):
                    raise TypeError(&#34;rotate values should be str, int or float&#34;)
        return f&#34;{prefix} move {span(rotatevalid)}&#34;
    else:
        raise TypeError(&#34;the parameter rotate should be a list or tuple&#34;)</code></pre>
</details>
</dd>
<dt id="region.coregeometry.scriptobject"><code class="name flex">
<span>def <span class="ident">scriptobject</span></span>(<span>self, beadtype=None, name=None, fullname=None, group=None, style=None, forcefield=None, USER=script data (SD object) with 0 definitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to return a scriptobject based on region instead of an input file
Syntax similar to script.scriptobject
OBJ = scriptobject(&hellip;)
Implemented properties:
beadtype=1,2,&hellip;
name="short name"
fullname = "comprehensive name"
style = "smd"
forcefield = any valid forcefield instance (default = rigidwall())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scriptobject(self, beadtype=None, name=None, fullname=None, group=None, style=None, forcefield=None, USER = scriptdata()):
    &#34;&#34;&#34;
    Method to return a scriptobject based on region instead of an input file
    Syntax similar to script.scriptobject
    OBJ = scriptobject(...)
    Implemented properties:
        beadtype=1,2,...
        name=&#34;short name&#34;
        fullname = &#34;comprehensive name&#34;
        style = &#34;smd&#34;
        forcefield = any valid forcefield instance (default = rigidwall())
    &#34;&#34;&#34;
    # Set defaults using instance attributes if parameters are None
    if beadtype is None:
        beadtype = self.beadtype
    if name is None:
        name = f&#34;{self.name} bead&#34;
    if fullname is None:
        fullname = f&#34;beads of type {self.beadtype} | object {self.name} of kind region.{self.kind}&#34;
    if group is None:
        group = self.SCRIPTOBJECT_USER[&#34;group&#34;]
    if style is None:
        style = self.SCRIPTOBJECT_USER[&#34;style&#34;]
    if forcefield is None:
        style = self.SCRIPTOBJECT_USER[&#34;forcefield&#34;]
    return scriptobject(
        beadtype=beadtype,
        name=name,
        fullname=fullname,
        style=style,
        group=group,
        filename=None,  # No need for a file
        USER = USER
    )</code></pre>
</details>
</dd>
<dt id="region.coregeometry.setgroup"><code class="name flex">
<span>def <span class="ident">setgroup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>force the group creation in script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setgroup(self):
    &#34;&#34;&#34;  force the group creation in script &#34;&#34;&#34;
    self.FLAGSECTIONS[&#34;setgroup&#34;] = True</code></pre>
</details>
</dd>
<dt id="region.coregeometry.sidearg"><code class="name flex">
<span>def <span class="ident">sidearg</span></span>(<span>self, side)</span>
</code></dt>
<dd>
<div class="desc"><p>Validation of side arguments for region command (<a href="https://docs.lammps.org/region.html">https://docs.lammps.org/region.html</a>)
side value = in or out
in = the region is inside the specified geometry
out = the region is outside the specified geometry</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sidearg(self,side):
    &#34;&#34;&#34;
        Validation of side arguments for region command (https://docs.lammps.org/region.html)
        side value = in or out
          in = the region is inside the specified geometry
          out = the region is outside the specified geometry
    &#34;&#34;&#34;
    prefix = &#34;$&#34;
    if side is None:
        return &#34;&#34;
    elif isinstance(side, str):
        side = side.lower()
        if side in (&#34;in&#34;,&#34;out&#34;):
            return f&#34;{prefix} side {side}&#34;
        elif side in (&#34;&#34;,&#34;none&#34;):
            return &#34;&#34;
        else:
            raise ValueError(f&#39;the value of side: &#34;{side}&#34; is not recognized&#39;)
    else:
        raise ValueError(&#39;the parameter side can be &#34;in|out|None&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="region.coregeometry.unitsarg"><code class="name flex">
<span>def <span class="ident">unitsarg</span></span>(<span>self, units)</span>
</code></dt>
<dd>
<div class="desc"><p>Validation for units arguments for region command (<a href="https://docs.lammps.org/region.html">https://docs.lammps.org/region.html</a>)
units value = lattice or box
lattice = the geometry is defined in lattice units
box = the geometry is defined in simulation box units</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unitsarg(self,units):
    &#34;&#34;&#34;
        Validation for units arguments for region command (https://docs.lammps.org/region.html)
        units value = lattice or box
          lattice = the geometry is defined in lattice units
          box = the geometry is defined in simulation box units
    &#34;&#34;&#34;
    prefix = &#34;$&#34;
    if units is None:
        return &#34;&#34;
    elif isinstance(units,str):
        units = units.lower()
        if units in (&#34;lattice&#34;,&#34;box&#34;):
            return f&#34;{prefix} units {units}&#34;
        elif (units==&#34;&#34;) or (units==&#34;none&#34;):
            return &#34;&#34;
        else:
            raise ValueError(f&#39;the value of side: &#34;{units}&#34; is not recognized&#39;)
    else:
        raise TypeError(&#39;the parameter units can be &#34;lattice|box|None&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="region.coregeometry.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>update the USER content for all three scripts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34; update the USER content for all three scripts &#34;&#34;&#34;
    if isinstance(self.SECTIONS[&#34;variables&#34;],script):
        self.SECTIONS[&#34;variables&#34;].USER += self.USER
    if isinstance(self.SECTIONS[&#34;region&#34;],script):
        self.SECTIONS[&#34;region&#34;].USER += self.USER
    if isinstance(self.SECTIONS[&#34;create&#34;],script):
        self.SECTIONS[&#34;create&#34;].USER += self.USER
    if isinstance(self.SECTIONS[&#34;group&#34;],script):
        self.SECTIONS[&#34;group&#34;].USER += self.USER
    if isinstance(self.SECTIONS[&#34;setgroup&#34;],script):
        self.SECTIONS[&#34;setgroup&#34;].USER += self.USER
    if isinstance(self.SECTIONS[&#34;move&#34;],script):
        self.SECTIONS[&#34;move&#34;].USER += self.USER</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.emulsion"><code class="flex name class">
<span>class <span class="ident">emulsion</span></span>
<span>(</span><span>xmin=10, ymin=10, zmin=10, xmax=90, ymax=90, zmax=90, maxtrials=1000, beadtype=1, forcedinsertion=True)</span>
</code></dt>
<dd>
<div class="desc"><p>emulsion generator </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>The insertions are performed between xmin,ymin and xmax,ymax</dt>
<dt><strong><code>xmin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>x left corner. The default is 10.</dd>
<dt><strong><code>ymin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>y bottom corner. The default is 10.</dd>
<dt><strong><code>zmin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>z bottom corner. The default is 10.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>x right corner. The default is 90.</dd>
<dt><strong><code>ymax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>y top corner. The default is 90.</dd>
<dt><strong><code>zmax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>z top corner. The default is 90.</dd>
<dt><strong><code>beadtype</code></strong> :&ensp;<code>default beadtype to apply if not precised at insertion</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>maxtrials</code></strong> :&ensp;<code>integer</code>, optional</dt>
<dd>Maximum of attempts for an object. The default is 1000.</dd>
<dt><strong><code>forcedinsertion</code></strong> :&ensp;<code>logical</code>, optional</dt>
<dd>Set it to true to force the next insertion. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class emulsion(scatter):
    &#34;&#34;&#34; emulsion generator &#34;&#34;&#34;

    def __init__(self, xmin=10, ymin=10, zmin=10, xmax=90, ymax=90, zmax=90,
                 maxtrials=1000, beadtype=1, forcedinsertion=True):
        &#34;&#34;&#34;


        Parameters
        ----------
        The insertions are performed between xmin,ymin and xmax,ymax
        xmin : int64 or real, optional
            x left corner. The default is 10.
        ymin : int64 or real, optional
            y bottom corner. The default is 10.
        zmin : int64 or real, optional
            z bottom corner. The default is 10.
        xmax : int64 or real, optional
            x right corner. The default is 90.
        ymax : int64 or real, optional
            y top corner. The default is 90.
        zmax : int64 or real, optional
            z top corner. The default is 90.
        beadtype : default beadtype to apply if not precised at insertion
        maxtrials : integer, optional
            Maximum of attempts for an object. The default is 1000.
        forcedinsertion : logical, optional
            Set it to true to force the next insertion. The default is True.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        super().__init__()
        self.xmin, self.xmax, self.ymin, self.ymax, self.zmin, self.zmax = xmin, xmax, ymin, ymax, zmin, zmax
        self.lastinsertion = (None,None,None,None,None) # x,y,z,r, beadtype
        self.length = xmax-xmin
        self.width = ymax-ymin
        self.height = zmax-zmin
        self.defautbeadtype = beadtype
        self.maxtrials = maxtrials
        self.forcedinsertion = forcedinsertion

    def __repr__(self):
        print(f&#34; Emulsion object\n\t{self.length}x{self.width}x{self.height} starting at x={self.xmin}, y={self.ymin}, z={self.zmin}&#34;)
        print(f&#34;\tcontains {self.n} insertions&#34;)
        print(&#34;\tmaximum insertion trials:&#34;, self.maxtrials)
        print(&#34;\tforce next insertion if previous fails:&#34;, self.forcedinsertion)
        return f&#34;emulsion with {self.n} insertions&#34;


    def walldist(self,x,y,z):
        &#34;&#34;&#34; shortest distance to the wall &#34;&#34;&#34;
        return min(abs(x-self.xmin),abs(y-self.ymin),abs(z-self.zmin),abs(x-self.xmax),abs(y-self.ymax),abs(z-self.zmax))

    def dist(self,x,y,z):
        &#34;&#34;&#34; shortest distance of the center (x,y) to the wall or any object&#34;&#34;&#34;
        return np.minimum(np.min(self.pairdist(x,y,z)),self.walldist(x,y,z))

    def accepted(self,x,y,z,r):
        &#34;&#34;&#34; acceptation criterion &#34;&#34;&#34;
        return self.dist(x,y,z)&gt;r

    def rand(self):
        &#34;&#34;&#34; random position x,y  &#34;&#34;&#34;
        return  np.random.uniform(low=self.xmin,high=self.xmax), \
                np.random.uniform(low=self.ymin,high=self.ymax),\
                np.random.uniform(low=self.zmin,high=self.zmax)

    def setbeadtype(self,beadtype):
        &#34;&#34;&#34; set the default or the supplied beadtype  &#34;&#34;&#34;
        if beadtype == None:
            self.beadtype.append(self.defautbeadtype)
            return self.defautbeadtype
        else:
            self.beadtype.append(beadtype)
            return beadtype

    def insertone(self,x=None,y=None,z=None,r=None,beadtype=None,overlap=False):
        &#34;&#34;&#34;
            insert one object of radius r
            properties:
                x,y,z coordinates (if missing, picked randomly from uniform distribution)
                r radius (default = 2% of diagonal)
                beadtype (default = defautbeadtype)
                overlap = False (accept only if no overlap)
        &#34;&#34;&#34;
        attempt, success = 0, False
        random = (x==None) or (y==None) or (z==None)
        if r==None:
            r = 0.02*np.sqrt(self.length**2+self.width**2+self.height**2)
        while not success and attempt&lt;self.maxtrials:
            attempt += 1
            if random: x,y,z = self.rand()
            if overlap:
                success = True
            else:
                success = self.accepted(x,y,z,r)
        if success:
            self.x = np.append(self.x,x)
            self.y = np.append(self.y,y)
            self.z = np.append(self.z,z)
            self.r = np.append(self.r,r)
            b=self.setbeadtype(beadtype)
            self.lastinsertion = (x,y,z,r,b)
        return success

    def insertion(self,rlist,beadtype=None):
        &#34;&#34;&#34;
            insert a list of objects
                nsuccess=insertion(rlist,beadtype=None)
                beadtype=b forces the value b
                if None, defaultbeadtype is used instead
        &#34;&#34;&#34;
        rlist.sort(reverse=True)
        ntodo = len(rlist)
        n = nsuccess = 0
        stop = False
        while not stop:
            n += 1
            success = self.insertone(r=rlist[n-1],beadtype=beadtype)
            if success: nsuccess += 1
            stop = (n==ntodo) or (not success and not self.forcedinsertion)
        if nsuccess==ntodo:
            print(f&#34;{nsuccess} objects inserted successfully&#34;)
        else:
            print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
        return nsuccess</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.scatter" href="#region.scatter">scatter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="region.emulsion.accepted"><code class="name flex">
<span>def <span class="ident">accepted</span></span>(<span>self, x, y, z, r)</span>
</code></dt>
<dd>
<div class="desc"><p>acceptation criterion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accepted(self,x,y,z,r):
    &#34;&#34;&#34; acceptation criterion &#34;&#34;&#34;
    return self.dist(x,y,z)&gt;r</code></pre>
</details>
</dd>
<dt id="region.emulsion.dist"><code class="name flex">
<span>def <span class="ident">dist</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>shortest distance of the center (x,y) to the wall or any object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist(self,x,y,z):
    &#34;&#34;&#34; shortest distance of the center (x,y) to the wall or any object&#34;&#34;&#34;
    return np.minimum(np.min(self.pairdist(x,y,z)),self.walldist(x,y,z))</code></pre>
</details>
</dd>
<dt id="region.emulsion.insertion"><code class="name flex">
<span>def <span class="ident">insertion</span></span>(<span>self, rlist, beadtype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>insert a list of objects
nsuccess=insertion(rlist,beadtype=None)
beadtype=b forces the value b
if None, defaultbeadtype is used instead</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertion(self,rlist,beadtype=None):
    &#34;&#34;&#34;
        insert a list of objects
            nsuccess=insertion(rlist,beadtype=None)
            beadtype=b forces the value b
            if None, defaultbeadtype is used instead
    &#34;&#34;&#34;
    rlist.sort(reverse=True)
    ntodo = len(rlist)
    n = nsuccess = 0
    stop = False
    while not stop:
        n += 1
        success = self.insertone(r=rlist[n-1],beadtype=beadtype)
        if success: nsuccess += 1
        stop = (n==ntodo) or (not success and not self.forcedinsertion)
    if nsuccess==ntodo:
        print(f&#34;{nsuccess} objects inserted successfully&#34;)
    else:
        print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
    return nsuccess</code></pre>
</details>
</dd>
<dt id="region.emulsion.insertone"><code class="name flex">
<span>def <span class="ident">insertone</span></span>(<span>self, x=None, y=None, z=None, r=None, beadtype=None, overlap=False)</span>
</code></dt>
<dd>
<div class="desc"><p>insert one object of radius r
properties:
x,y,z coordinates (if missing, picked randomly from uniform distribution)
r radius (default = 2% of diagonal)
beadtype (default = defautbeadtype)
overlap = False (accept only if no overlap)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertone(self,x=None,y=None,z=None,r=None,beadtype=None,overlap=False):
    &#34;&#34;&#34;
        insert one object of radius r
        properties:
            x,y,z coordinates (if missing, picked randomly from uniform distribution)
            r radius (default = 2% of diagonal)
            beadtype (default = defautbeadtype)
            overlap = False (accept only if no overlap)
    &#34;&#34;&#34;
    attempt, success = 0, False
    random = (x==None) or (y==None) or (z==None)
    if r==None:
        r = 0.02*np.sqrt(self.length**2+self.width**2+self.height**2)
    while not success and attempt&lt;self.maxtrials:
        attempt += 1
        if random: x,y,z = self.rand()
        if overlap:
            success = True
        else:
            success = self.accepted(x,y,z,r)
    if success:
        self.x = np.append(self.x,x)
        self.y = np.append(self.y,y)
        self.z = np.append(self.z,z)
        self.r = np.append(self.r,r)
        b=self.setbeadtype(beadtype)
        self.lastinsertion = (x,y,z,r,b)
    return success</code></pre>
</details>
</dd>
<dt id="region.emulsion.rand"><code class="name flex">
<span>def <span class="ident">rand</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>random position x,y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand(self):
    &#34;&#34;&#34; random position x,y  &#34;&#34;&#34;
    return  np.random.uniform(low=self.xmin,high=self.xmax), \
            np.random.uniform(low=self.ymin,high=self.ymax),\
            np.random.uniform(low=self.zmin,high=self.zmax)</code></pre>
</details>
</dd>
<dt id="region.emulsion.setbeadtype"><code class="name flex">
<span>def <span class="ident">setbeadtype</span></span>(<span>self, beadtype)</span>
</code></dt>
<dd>
<div class="desc"><p>set the default or the supplied beadtype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setbeadtype(self,beadtype):
    &#34;&#34;&#34; set the default or the supplied beadtype  &#34;&#34;&#34;
    if beadtype == None:
        self.beadtype.append(self.defautbeadtype)
        return self.defautbeadtype
    else:
        self.beadtype.append(beadtype)
        return beadtype</code></pre>
</details>
</dd>
<dt id="region.emulsion.walldist"><code class="name flex">
<span>def <span class="ident">walldist</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>shortest distance to the wall</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walldist(self,x,y,z):
    &#34;&#34;&#34; shortest distance to the wall &#34;&#34;&#34;
    return min(abs(x-self.xmin),abs(y-self.ymin),abs(z-self.zmin),abs(x-self.xmax),abs(y-self.ymax),abs(z-self.zmax))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.scatter" href="#region.scatter">scatter</a></b></code>:
<ul class="hlist">
<li><code><a title="region.scatter.pairdist" href="#region.scatter.pairdist">pairdist</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.forcefield"><code class="flex name class">
<span>class <span class="ident">forcefield</span></span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="region.forcefield" href="#region.forcefield">forcefield</a></code> class represents the core implementation of a forcefield model,
defining interaction parameters and coefficients for simulations. This class provides
methods to handle pair styles, diagonal pair coefficients, and off-diagonal pair coefficients,
which are essential for simulating inter-particle interactions in molecular dynamics or
other physics-based simulations.</p>
<h2 id="attributes">Attributes:</h2>
<p>PAIR_STYLE : str
The default pair style command for the forcefield interactions.</p>
<p>PAIR_DIAGCOEFF : str
The default command for calculating diagonal pair coefficients.</p>
<p>PAIR_OFFDIAGCOEFF : str
The default command for calculating off-diagonal pair coefficients.</p>
<p>parameters : parameterforcefield
An instance of <code><a title="region.parameterforcefield" href="#region.parameterforcefield">parameterforcefield</a></code> that stores the parameters for
evaluating interaction commands.</p>
<p>beadtype : int
The bead type associated with the current forcefield instance.</p>
<p>userid : str
A unique identifier for the forcefield instance, used in interaction commands.</p>
<h2 id="methods">Methods:</h2>
<p>pair_style(printflag=True):
Generate and return the pair style command based on the current parameters,
beadtype, and userid.</p>
<p>pair_diagcoeff(printflag=True, i=None):
Generate and return the diagonal pair coefficients based on the current parameters,
beadtype, and userid. The bead type <code>i</code> can be overridden with an optional argument.</p>
<p>pair_offdiagcoeff(o=None, printflag=True, i=None):
Generate and return the off-diagonal pair coefficients between two different
bead types or forcefield objects. The bead type <code>i</code> can be overridden, and the
interaction with another forcefield object <code>o</code> can also be specified.</p>
<h2 id="notes">Notes:</h2>
<ul>
<li>This class is intended to be extended by specific forcefield types such as <code><a title="region.ulsph" href="#region.ulsph">ulsph</a></code>.</li>
<li>The parameters used in the interaction commands are dynamically evaluated using
the <code><a title="region.parameterforcefield" href="#region.parameterforcefield">parameterforcefield</a></code> class, which provides the required values during runtime.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class forcefield():
    &#34;&#34;&#34;
    The `forcefield` class represents the core implementation of a forcefield model,
    defining interaction parameters and coefficients for simulations. This class provides
    methods to handle pair styles, diagonal pair coefficients, and off-diagonal pair coefficients,
    which are essential for simulating inter-particle interactions in molecular dynamics or
    other physics-based simulations.

    Attributes:
    -----------
    PAIR_STYLE : str
        The default pair style command for the forcefield interactions.

    PAIR_DIAGCOEFF : str
        The default command for calculating diagonal pair coefficients.

    PAIR_OFFDIAGCOEFF : str
        The default command for calculating off-diagonal pair coefficients.

    parameters : parameterforcefield
        An instance of `parameterforcefield` that stores the parameters for
        evaluating interaction commands.

    beadtype : int
        The bead type associated with the current forcefield instance.

    userid : str
        A unique identifier for the forcefield instance, used in interaction commands.

    Methods:
    --------
    pair_style(printflag=True):
        Generate and return the pair style command based on the current parameters,
        beadtype, and userid.

    pair_diagcoeff(printflag=True, i=None):
        Generate and return the diagonal pair coefficients based on the current parameters,
        beadtype, and userid. The bead type `i` can be overridden with an optional argument.

    pair_offdiagcoeff(o=None, printflag=True, i=None):
        Generate and return the off-diagonal pair coefficients between two different
        bead types or forcefield objects. The bead type `i` can be overridden, and the
        interaction with another forcefield object `o` can also be specified.

    Notes:
    ------
    - This class is intended to be extended by specific forcefield types such as `ulsph`.
    - The parameters used in the interaction commands are dynamically evaluated using
      the `parameterforcefield` class, which provides the required values during runtime.
    &#34;&#34;&#34;

    # Main attributes (instance independent)
    name = struct(forcefield=&#34;undefined&#34;, style=&#34;undefined&#34;, material=&#34;undefined&#34;)
    description = struct(forcefield=&#34;missing&#34;, style=&#34;missing&#34;, material=&#34;missing&#34;)
    beadtype = 1  # default bead type
    parameters = parameterforcefield() # empty parameters object
    userid = &#34;undefined&#34;
    version = 0

    # print method for headers (static, no implicit argument)
    @staticmethod
    def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
        &#34;&#34;&#34; print header &#34;&#34;&#34;
        if txt==&#34;&#34;:
            print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
        else:
            print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))

    # Display/representation method
    # The method provides full help for the end-user
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        stamp = self.name.forcefield+&#34;:&#34;+self.name.style+&#34;:&#34;+self.name.material
        self.printheader(&#34;%s | version=%0.3g&#34; % (self.userid,self.version),filler=&#34;=&#34;)
        print(&#34;  Bead of type %d = [%s]&#34; % (self.beadtype,stamp))
        print(self.parameters)
        self.printheader(&#34;description&#34;,filler=&#34;.&#34;)
        print(&#34;\t# \t%s&#34; % self.description.forcefield)
        print(&#34;\t# \t%s&#34; % self.description.style)
        print(&#34;\t# \t%s&#34; % self.description.material)
        self.printheader(&#34;methods&#34;)
        print(&#34;\t   &gt;&gt;&gt; replace FFi,FFj by your variable names &lt;&lt;&lt;&#34;)
        print(&#34;\tTo assign a type, use: FFi.beadtype = integer value&#34;)
        print(&#34;\tUse the methods FFi.pair_style() and FFi.pair_coeff(FFj)&#34;)
        print(&#34;\tNote for pairs: the caller object is i (FFi), the argument is j (FFj or j)&#34;)
        self.printheader(&#34;template&#34;)
        self.pair_style()
        self.pair_diagcoeff()
        self.pair_offdiagcoeff()
        self.printheader(&#34;&#34;)
        return stamp

    # Extract attributes within the class
    def getallattributes(self):
        &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
        return {k: getattr(self, k) for k in dir(self) \
                if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}


    # Forcefield Methods: pair_style(), pair_coeff()
    # the substitution of LAMMPS variables is carried out with the method
    # parameters.format() method implemented in struct and inherited by parameterforcefield()
    def pair_style(self,printflag=False,verbose=True, raw=False,USER=None,beadtype=None,userid=None):
        &#34;&#34;&#34;
        Generate and return the pair style command for the current forcefield instance.

        This method creates a formatted pair style command based on the interaction parameters
        stored in the `parameters` attribute. It allows customization of the command using the
        `beadtype` and `userid` arguments. The behavior can be altered by passing a `USER` object
        or opting for the raw command template.

        Parameters:
        -----------
        printflag : bool, optional, default=False
            If True, the generated pair style command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        raw : bool, optional, default=False
            If True, returns the raw template of the pair style without any interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier used in the generated command. If not provided, the
            instance&#39;s beadtype is used.
        userid : str, optional, default=None
            The user identifier to include in the formatted command. Defaults to the instance&#39;s
            userid if not specified.

        Returns:
        --------
        str
            The formatted pair style command string.

        Raises:
        -------
        TypeError
            If `USER` is provided but is not of type `struct` or derived from `struct`.
        &#34;&#34;&#34;
        # raw format
        if raw:
            return self.PAIR_STYLE
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # cmd
        cmd = parameters.formateval(self.PAIR_STYLE)
        # Replace [comment] with the formatted comment (e.g., &#34;[2:my_user_id]&#34;)
        cmd = cmd.replace(&#34;[comment]&#34;,&#34;[%d:%s]&#34; % (beadtype, userid) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


    def pair_diagcoeff(self,printflag=False,verbose=True, i=None,raw=False,USER=None,beadtype=None,userid=None):
        &#34;&#34;&#34;
        Generate and return the diagonal pair coefficients for the current forcefield instance.

        This method evaluates the diagonal pair coefficients based on the interaction parameters,
        the bead type (`beadtype`), and the user identifier (`userid`). The bead type `i` can
        be overridden by passing it as an argument. The method supports returning the raw template
        without evaluation and modifying parameters using a `USER` object.

        Parameters:
        -----------
        printflag : bool, optional, default=False
            If True, the generated diagonal pair coefficient command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        i : int, optional, default=None
            The bead type used for evaluating the diagonal pair coefficients. If not provided,
            defaults to the instance&#39;s bead type (`self.beadtype`).
        raw : bool, optional, default=False
            If True, returns the raw template for the diagonal pair coefficients without interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier to use in the command. Defaults to the instance&#39;s beadtype
            if not provided.
        userid : str, optional, default=None
            The user identifier to include in the formatted command. Defaults to the instance&#39;s
            userid if not specified.

        Returns:
        --------
        str
            The formatted diagonal pair coefficient command string.

        Raises:
        -------
        TypeError
            If `USER` is provided but is not of type `struct` or derived from `struct`.
        &#34;&#34;&#34;
        # raw format
        if raw:
            return self.PAIR_DIAGCOEFF
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # diagonal index
        i = i if i is not None else beadtype
        # cmd
        cmd = parameters.formateval(self.PAIR_DIAGCOEFF) % (i,i)
        # Replace [comment] with the formatted string, without using .format()
        cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, userid, i, userid) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd


    def pair_offdiagcoeff(self,o=None,printflag=False,verbose=True,i=None,raw=False,USER=None,beadtype=None,userid=None,oname=None):
        &#34;&#34;&#34;
        Generate and return the off-diagonal pair coefficients for the current forcefield instance.

        This method evaluates the off-diagonal pair coefficients between two different bead types
        or forcefield objects, using the interaction parameters, bead type, and user identifier.
        The bead type `i` can be overridden, and the interaction with another forcefield object `o`
        can also be specified.

        Parameters:
        -----------
        o : forcefield or int, optional, default=None
            The second forcefield object or bead type used for calculating the off-diagonal
            pair coefficients. If not provided, the method assumes interactions between
            beads of the same type.
        printflag : bool, optional, default=False
            If True, the generated off-diagonal pair coefficient command is printed to the console.
        verbose : bool, optional, default=True
            If True, enables verbose output during the script generation.
        i : int, optional, default=None
            The bead type used for the current forcefield instance. If not provided,
            defaults to the instance&#39;s bead type (`self.beadtype`).
        raw : bool, optional, default=False
            If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
        USER : struct, optional, default=None
            A user-defined struct object used for overriding the default parameters.
            When provided, the method updates parameters using `USER` in conjunction with
            the instance&#39;s base parameters.
        beadtype : int, optional, default=None
            The bead type identifier used in the command. Defaults to the instance&#39;s beadtype
            if not provided.
        userid : str, optional, default=None
            The user identifier included in the formatted command. Defaults to the instance&#39;s
            userid if not specified.
        oname : str, optional, default=None
            The user identifier for the second forcefield or bead type. If not provided, it
            defaults to `&#34;none&#34;`.

        Returns:
        --------
        str
            The formatted off-diagonal pair coefficient command string.

        Raises:
        -------
        TypeError
            If `USER` is not of type `struct` or derived from `struct`.
        IndexError
            If the first argument `o` is not a forcefield object or an integer.
        &#34;&#34;&#34;

        # raw format
        if raw:
            return self.PAIR_OFFDIAGCOEFF
        # USER overrride if the forcefield class is inherited
        if USER is None: # ---- default behavior for forcefield
            parameters = self.parameters
            beadtype = self.beadtype
            userid = self.userid
            i = i if i is not None else beadtype
        elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
            parameters = self.parameters+USER
            beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
            userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
        else:
            raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
        # Determine the first bead type (i)
        i = i if i is not None else beadtype
        # Determine the second bead type (j) based on o
        if o is None:
            j = i
        elif hasattr(o, &#39;beadtype&#39;):
            j = o.beadtype
        elif isinstance(o, (float, int)):
            j = int(o)
        else:
            raise IndexError(&#34;The first argument should be a forcefield object or an integer representing bead type.&#34;)
        # Adjust j if it matches i (to ensure off-diagonal interaction)
        if j == i:
            j = i - 1 if i &gt; 1 else i + 1
        oname = oname if oname is not None else o.userid if hasattr(o, &#34;userid&#34;) else &#34;none&#34;
        # cmd
        cmd = parameters.formateval(self.PAIR_OFFDIAGCOEFF) % (min(i,j),max(j,i))
        # Replace [comment] with the formatted string, without using .format()
        cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, self.userid, j, oname) if verbose else &#34;&#34;)
        if printflag: print(cmd)
        return cmd</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.smd</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.forcefield.beadtype"><code class="name">var <span class="ident">beadtype</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.forcefield.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.forcefield.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.forcefield.parameters"><code class="name">var <span class="ident">parameters</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.forcefield.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.forcefield.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="region.forcefield.printheader"><code class="name flex">
<span>def <span class="ident">printheader</span></span>(<span>txt, align='^', width=80, filler='~')</span>
</code></dt>
<dd>
<div class="desc"><p>print header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
    &#34;&#34;&#34; print header &#34;&#34;&#34;
    if txt==&#34;&#34;:
        print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
    else:
        print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.forcefield.getallattributes"><code class="name flex">
<span>def <span class="ident">getallattributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>advanced method to get all attributes including class ones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getallattributes(self):
    &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
    return {k: getattr(self, k) for k in dir(self) \
            if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}</code></pre>
</details>
</dd>
<dt id="region.forcefield.pair_diagcoeff"><code class="name flex">
<span>def <span class="ident">pair_diagcoeff</span></span>(<span>self, printflag=False, verbose=True, i=None, raw=False, USER=None, beadtype=None, userid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the diagonal pair coefficients for the current forcefield instance.</p>
<p>This method evaluates the diagonal pair coefficients based on the interaction parameters,
the bead type (<code>beadtype</code>), and the user identifier (<code>userid</code>). The bead type <code>i</code> can
be overridden by passing it as an argument. The method supports returning the raw template
without evaluation and modifying parameters using a <code>USER</code> object.</p>
<h2 id="parameters">Parameters:</h2>
<p>printflag : bool, optional, default=False
If True, the generated diagonal pair coefficient command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
i : int, optional, default=None
The bead type used for evaluating the diagonal pair coefficients. If not provided,
defaults to the instance's bead type (<code>self.beadtype</code>).
raw : bool, optional, default=False
If True, returns the raw template for the diagonal pair coefficients without interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier to use in the command. Defaults to the instance's beadtype
if not provided.
userid : str, optional, default=None
The user identifier to include in the formatted command. Defaults to the instance's
userid if not specified.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted diagonal pair coefficient command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is provided but is not of type <code><a title="region.struct" href="#region.struct">struct</a></code> or derived from <code><a title="region.struct" href="#region.struct">struct</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_diagcoeff(self,printflag=False,verbose=True, i=None,raw=False,USER=None,beadtype=None,userid=None):
    &#34;&#34;&#34;
    Generate and return the diagonal pair coefficients for the current forcefield instance.

    This method evaluates the diagonal pair coefficients based on the interaction parameters,
    the bead type (`beadtype`), and the user identifier (`userid`). The bead type `i` can
    be overridden by passing it as an argument. The method supports returning the raw template
    without evaluation and modifying parameters using a `USER` object.

    Parameters:
    -----------
    printflag : bool, optional, default=False
        If True, the generated diagonal pair coefficient command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    i : int, optional, default=None
        The bead type used for evaluating the diagonal pair coefficients. If not provided,
        defaults to the instance&#39;s bead type (`self.beadtype`).
    raw : bool, optional, default=False
        If True, returns the raw template for the diagonal pair coefficients without interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier to use in the command. Defaults to the instance&#39;s beadtype
        if not provided.
    userid : str, optional, default=None
        The user identifier to include in the formatted command. Defaults to the instance&#39;s
        userid if not specified.

    Returns:
    --------
    str
        The formatted diagonal pair coefficient command string.

    Raises:
    -------
    TypeError
        If `USER` is provided but is not of type `struct` or derived from `struct`.
    &#34;&#34;&#34;
    # raw format
    if raw:
        return self.PAIR_DIAGCOEFF
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # diagonal index
    i = i if i is not None else beadtype
    # cmd
    cmd = parameters.formateval(self.PAIR_DIAGCOEFF) % (i,i)
    # Replace [comment] with the formatted string, without using .format()
    cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, userid, i, userid) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="region.forcefield.pair_offdiagcoeff"><code class="name flex">
<span>def <span class="ident">pair_offdiagcoeff</span></span>(<span>self, o=None, printflag=False, verbose=True, i=None, raw=False, USER=None, beadtype=None, userid=None, oname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the off-diagonal pair coefficients for the current forcefield instance.</p>
<p>This method evaluates the off-diagonal pair coefficients between two different bead types
or forcefield objects, using the interaction parameters, bead type, and user identifier.
The bead type <code>i</code> can be overridden, and the interaction with another forcefield object <code>o</code>
can also be specified.</p>
<h2 id="parameters">Parameters:</h2>
<p>o : forcefield or int, optional, default=None
The second forcefield object or bead type used for calculating the off-diagonal
pair coefficients. If not provided, the method assumes interactions between
beads of the same type.
printflag : bool, optional, default=False
If True, the generated off-diagonal pair coefficient command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
i : int, optional, default=None
The bead type used for the current forcefield instance. If not provided,
defaults to the instance's bead type (<code>self.beadtype</code>).
raw : bool, optional, default=False
If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier used in the command. Defaults to the instance's beadtype
if not provided.
userid : str, optional, default=None
The user identifier included in the formatted command. Defaults to the instance's
userid if not specified.
oname : str, optional, default=None
The user identifier for the second forcefield or bead type. If not provided, it
defaults to <code>"none"</code>.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted off-diagonal pair coefficient command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is not of type <code><a title="region.struct" href="#region.struct">struct</a></code> or derived from <code><a title="region.struct" href="#region.struct">struct</a></code>.
IndexError
If the first argument <code>o</code> is not a forcefield object or an integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_offdiagcoeff(self,o=None,printflag=False,verbose=True,i=None,raw=False,USER=None,beadtype=None,userid=None,oname=None):
    &#34;&#34;&#34;
    Generate and return the off-diagonal pair coefficients for the current forcefield instance.

    This method evaluates the off-diagonal pair coefficients between two different bead types
    or forcefield objects, using the interaction parameters, bead type, and user identifier.
    The bead type `i` can be overridden, and the interaction with another forcefield object `o`
    can also be specified.

    Parameters:
    -----------
    o : forcefield or int, optional, default=None
        The second forcefield object or bead type used for calculating the off-diagonal
        pair coefficients. If not provided, the method assumes interactions between
        beads of the same type.
    printflag : bool, optional, default=False
        If True, the generated off-diagonal pair coefficient command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    i : int, optional, default=None
        The bead type used for the current forcefield instance. If not provided,
        defaults to the instance&#39;s bead type (`self.beadtype`).
    raw : bool, optional, default=False
        If True, returns the raw template for the off-diagonal pair coefficients without interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier used in the command. Defaults to the instance&#39;s beadtype
        if not provided.
    userid : str, optional, default=None
        The user identifier included in the formatted command. Defaults to the instance&#39;s
        userid if not specified.
    oname : str, optional, default=None
        The user identifier for the second forcefield or bead type. If not provided, it
        defaults to `&#34;none&#34;`.

    Returns:
    --------
    str
        The formatted off-diagonal pair coefficient command string.

    Raises:
    -------
    TypeError
        If `USER` is not of type `struct` or derived from `struct`.
    IndexError
        If the first argument `o` is not a forcefield object or an integer.
    &#34;&#34;&#34;

    # raw format
    if raw:
        return self.PAIR_OFFDIAGCOEFF
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
        i = i if i is not None else beadtype
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # Determine the first bead type (i)
    i = i if i is not None else beadtype
    # Determine the second bead type (j) based on o
    if o is None:
        j = i
    elif hasattr(o, &#39;beadtype&#39;):
        j = o.beadtype
    elif isinstance(o, (float, int)):
        j = int(o)
    else:
        raise IndexError(&#34;The first argument should be a forcefield object or an integer representing bead type.&#34;)
    # Adjust j if it matches i (to ensure off-diagonal interaction)
    if j == i:
        j = i - 1 if i &gt; 1 else i + 1
    oname = oname if oname is not None else o.userid if hasattr(o, &#34;userid&#34;) else &#34;none&#34;
    # cmd
    cmd = parameters.formateval(self.PAIR_OFFDIAGCOEFF) % (min(i,j),max(j,i))
    # Replace [comment] with the formatted string, without using .format()
    cmd = cmd.replace(&#34;[comment]&#34;, &#34;[%d:%s x %d:%s]&#34; % (i, self.userid, j, oname) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="region.forcefield.pair_style"><code class="name flex">
<span>def <span class="ident">pair_style</span></span>(<span>self, printflag=False, verbose=True, raw=False, USER=None, beadtype=None, userid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return the pair style command for the current forcefield instance.</p>
<p>This method creates a formatted pair style command based on the interaction parameters
stored in the <code>parameters</code> attribute. It allows customization of the command using the
<code>beadtype</code> and <code>userid</code> arguments. The behavior can be altered by passing a <code>USER</code> object
or opting for the raw command template.</p>
<h2 id="parameters">Parameters:</h2>
<p>printflag : bool, optional, default=False
If True, the generated pair style command is printed to the console.
verbose : bool, optional, default=True
If True, enables verbose output during the script generation.
raw : bool, optional, default=False
If True, returns the raw template of the pair style without any interpretation.
USER : struct, optional, default=None
A user-defined struct object used for overriding the default parameters.
When provided, the method updates parameters using <code>USER</code> in conjunction with
the instance's base parameters.
beadtype : int, optional, default=None
The bead type identifier used in the generated command. If not provided, the
instance's beadtype is used.
userid : str, optional, default=None
The user identifier to include in the formatted command. Defaults to the instance's
userid if not specified.</p>
<h2 id="returns">Returns:</h2>
<p>str
The formatted pair style command string.</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If <code>USER</code> is provided but is not of type <code><a title="region.struct" href="#region.struct">struct</a></code> or derived from <code><a title="region.struct" href="#region.struct">struct</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pair_style(self,printflag=False,verbose=True, raw=False,USER=None,beadtype=None,userid=None):
    &#34;&#34;&#34;
    Generate and return the pair style command for the current forcefield instance.

    This method creates a formatted pair style command based on the interaction parameters
    stored in the `parameters` attribute. It allows customization of the command using the
    `beadtype` and `userid` arguments. The behavior can be altered by passing a `USER` object
    or opting for the raw command template.

    Parameters:
    -----------
    printflag : bool, optional, default=False
        If True, the generated pair style command is printed to the console.
    verbose : bool, optional, default=True
        If True, enables verbose output during the script generation.
    raw : bool, optional, default=False
        If True, returns the raw template of the pair style without any interpretation.
    USER : struct, optional, default=None
        A user-defined struct object used for overriding the default parameters.
        When provided, the method updates parameters using `USER` in conjunction with
        the instance&#39;s base parameters.
    beadtype : int, optional, default=None
        The bead type identifier used in the generated command. If not provided, the
        instance&#39;s beadtype is used.
    userid : str, optional, default=None
        The user identifier to include in the formatted command. Defaults to the instance&#39;s
        userid if not specified.

    Returns:
    --------
    str
        The formatted pair style command string.

    Raises:
    -------
    TypeError
        If `USER` is provided but is not of type `struct` or derived from `struct`.
    &#34;&#34;&#34;
    # raw format
    if raw:
        return self.PAIR_STYLE
    # USER overrride if the forcefield class is inherited
    if USER is None: # ---- default behavior for forcefield
        parameters = self.parameters
        beadtype = self.beadtype
        userid = self.userid
    elif isinstance(USER,struct): # ---- behavior for dforcefield (using baseclass)
        parameters = self.parameters+USER
        beadtype = beadtype if beadtype is not None else USER.beadtype if hasattr(USER, &#39;beadtype&#39;) else self.beadtype
        userid = userid if userid is not None else USER.userid if hasattr(USER, &#39;userid&#39;) else self.userid
    else:
        raise TypeError(f&#39;USER must be of type struct or derived from struct, not {type(USER)}&#39;)
    # cmd
    cmd = parameters.formateval(self.PAIR_STYLE)
    # Replace [comment] with the formatted comment (e.g., &#34;[2:my_user_id]&#34;)
    cmd = cmd.replace(&#34;[comment]&#34;,&#34;[%d:%s]&#34; % (beadtype, userid) if verbose else &#34;&#34;)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.headersRegiondata"><code class="flex name class">
<span>class <span class="ident">headersRegiondata</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>class of script parameters
Typical constructor:
DEFINITIONS = headersRegiondata(
var1 = value1,
var2 = value2
)
See script, struct, param to get review all methods attached to it</p>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class headersRegiondata(regiondata):
    &#34;&#34;&#34;
        class of script parameters
            Typical constructor:
                DEFINITIONS = headersRegiondata(
                    var1 = value1,
                    var2 = value2
                    )
        See script, struct, param to get review all methods attached to it
    &#34;&#34;&#34;
    _type = &#34;HRD&#34;
    _fulltype = &#34;Header parameters - helper for scripts&#34;
    _ftype = &#34;header definition&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="region.regiondata" href="#region.regiondata">regiondata</a></li>
<li>pizza.private.mstruct.paramauto</li>
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="region.regiondata" href="#region.regiondata">regiondata</a></b></code>:
<ul class="hlist">
<li><code><a title="region.regiondata.generatorforlammps" href="#region.regiondata.generatorforlammps">generatorforlammps</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="region.none"><code class="flex name class">
<span>class <span class="ident">none</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD:TLSPH forcefield (updated Lagrangian)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class none(smd):
    &#34;&#34;&#34; SMD:TLSPH forcefield (updated Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;none&#34;)
    description = smd.description + struct(style=&#34;no interactions&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Diagonal pair coefficient tlsph
    pair_coeff      %d %d none
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.rigidwall</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.none.PAIR_DIAGCOEFF"><code class="name">var <span class="ident">PAIR_DIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.none.PAIR_OFFDIAGCOEFF"><code class="name">var <span class="ident">PAIR_OFFDIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.none.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.none.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="region.param"><code class="flex name class">
<span>class <span class="ident">param</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-param">Class: <code><a title="region.param" href="#region.param">param</a></code></h1>
<p>A class derived from <code><a title="region.struct" href="#region.struct">struct</a></code> that introduces dynamic evaluation of field values.
The <code><a title="region.param" href="#region.param">param</a></code> class acts as a container for evaluated parameters, allowing expressions
to depend on other fields. It supports advanced evaluation, sorting of dependencies,
and text formatting.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Inherits all functionalities of <code><a title="region.struct" href="#region.struct">struct</a></code>.</li>
<li>Supports dynamic evaluation of field expressions.</li>
<li>Automatically resolves dependencies between fields.</li>
<li>Includes utility methods for text formatting and evaluation.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage-with-evaluation">Basic Usage with Evaluation</h4>
<pre><code class="language-python">s = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can', d=&quot;$this is a string&quot;, e=&quot;1000 # this is my number&quot;)
s.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
#      d: $this is a string (= this is a string)
#      e: 1000 # this is my number (= 1000)
# --------

s.a = 10
s.eval()
# Output:
# --------
#      a: 10
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 12)
#      d: $this is a string (= this is a string)
#      e: 1000 # this is my number (= 1000)
# --------
</code></pre>
<h4 id="handling-text-parameters">Handling Text Parameters</h4>
<pre><code class="language-python">s = param()
s.mypath = &quot;$/this/folder&quot;
s.myfile = &quot;$file&quot;
s.myext = &quot;$ext&quot;
s.fullfile = &quot;$${mypath}/${myfile}.${myext}&quot;
s.eval()
# Output:
# --------
#    mypath: $/this/folder (= /this/folder)
#    myfile: $file (= file)
#     myext: $ext (= ext)
#  fullfile: $${mypath}/${myfile}.${myext} (= /this/folder/file.ext)
# --------
</code></pre>
<hr>
<h3 id="text-evaluation-and-formatting">Text Evaluation and Formatting</h3>
<h4 id="evaluate-strings">Evaluate Strings</h4>
<pre><code class="language-python">s = param(a=1, b=2)
result = s.eval(&quot;this is a string with ${a} and ${b}&quot;)
print(result)  # &quot;this is a string with 1 and 2&quot;
</code></pre>
<h4 id="prevent-evaluation">Prevent Evaluation</h4>
<pre><code class="language-python">definitions = param(a=1, b=&quot;${a}*10+${a}&quot;, c=&quot;\${a}+10&quot;, d='\${myparam}')
text = definitions.formateval(&quot;this is my text ${a}, ${b}, \${myvar}=${c}+${d}&quot;)
print(text)  # &quot;this is my text 1, 11, \${myvar}=\${a}+10+${myparam}&quot;
</code></pre>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="rearranging-and-sorting-definitions">Rearranging and Sorting Definitions</h4>
<pre><code class="language-python">s = param(
    a=1,
    f=&quot;${e}/3&quot;,
    e=&quot;${a}*${c}&quot;,
    c=&quot;${a}+${b}&quot;,
    b=2,
    d=&quot;${c}*2&quot;
)
s.sortdefinitions()
s.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} (= 3)
#      d: ${c} * 2 (= 6)
#      e: ${a} * ${c} (= 3)
#      f: ${e} / 3 (= 1.0)
# --------
</code></pre>
<h4 id="internal-evaluation-and-recursion-with">Internal Evaluation and Recursion with !</h4>
<pre><code class="language-python">p=param()
p.a = [0,1,2]
p.b = '![1,2,&quot;test&quot;,&quot;${a[1]}&quot;]'
p
# Output:
#  -------------:----------------------------------------
#          a: [0, 1, 2]
#          b: ![1,2,&quot;test&quot;,&quot;${a[1]}&quot;]
#           = [1, 2, 'test', '1']
#  -------------:----------------------------------------
# Out: parameter list (param object) with 2 definitions
</code></pre>
<h4 id="error-handling">Error Handling</h4>
<pre><code class="language-python">p = param(b=&quot;${a}+1&quot;, c=&quot;${a}+${d}&quot;, a=1)
p.disp()
# Output:
# --------
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
#      a: 1
# --------
</code></pre>
<p>Sorting unresolved definitions raises errors unless explicitly suppressed:</p>
<pre><code class="language-python">p.sortdefinitions(raiseerror=False)
# WARNING: unable to interpret 1/3 expressions in &quot;definitions&quot;
</code></pre>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eval()</code></td>
<td>Evaluate all field expressions.</td>
</tr>
<tr>
<td><code>formateval(string)</code></td>
<td>Format and evaluate a string with field placeholders.</td>
</tr>
<tr>
<td><code>protect(string)</code></td>
<td>Escape variable placeholders in a string.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort definitions to resolve dependencies.</td>
</tr>
<tr>
<td><code>escape(string)</code></td>
<td>Protect escaped variables in a string.</td>
</tr>
<tr>
<td><code>safe_fstring(string)</code></td>
<td>evaluate safely complex mathemical expressions.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two parameter lists, sorting definitions.</li>
<li><code>-</code>: Subtraction of fields.</li>
<li><code>len()</code>: Number of fields.</li>
<li><code>in</code>: Check for field existence.</li>
</ul>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>The <code><a title="region.paramauto" href="#region.paramauto">paramauto</a></code> class simplifies handling of partial definitions and inherits from <code><a title="region.param" href="#region.param">param</a></code>.</li>
<li>Use <code><a title="region.paramauto" href="#region.paramauto">paramauto</a></code> when definitions need to be stacked irrespective of execution order.</li>
</ul>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class param(struct):
    &#34;&#34;&#34;
    Class: `param`
    ==============

    A class derived from `struct` that introduces dynamic evaluation of field values.
    The `param` class acts as a container for evaluated parameters, allowing expressions
    to depend on other fields. It supports advanced evaluation, sorting of dependencies,
    and text formatting.

    ---

    ### Features
    - Inherits all functionalities of `struct`.
    - Supports dynamic evaluation of field expressions.
    - Automatically resolves dependencies between fields.
    - Includes utility methods for text formatting and evaluation.

    ---

    ### Examples

    #### Basic Usage with Evaluation
    ```python
    s = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;, d=&#34;$this is a string&#34;, e=&#34;1000 # this is my number&#34;)
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------

    s.a = 10
    s.eval()
    # Output:
    # --------
    #      a: 10
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 12)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------
    ```

    #### Handling Text Parameters
    ```python
    s = param()
    s.mypath = &#34;$/this/folder&#34;
    s.myfile = &#34;$file&#34;
    s.myext = &#34;$ext&#34;
    s.fullfile = &#34;$${mypath}/${myfile}.${myext}&#34;
    s.eval()
    # Output:
    # --------
    #    mypath: $/this/folder (= /this/folder)
    #    myfile: $file (= file)
    #     myext: $ext (= ext)
    #  fullfile: $${mypath}/${myfile}.${myext} (= /this/folder/file.ext)
    # --------
    ```

    ---

    ### Text Evaluation and Formatting

    #### Evaluate Strings
    ```python
    s = param(a=1, b=2)
    result = s.eval(&#34;this is a string with ${a} and ${b}&#34;)
    print(result)  # &#34;this is a string with 1 and 2&#34;
    ```

    #### Prevent Evaluation
    ```python
    definitions = param(a=1, b=&#34;${a}*10+${a}&#34;, c=&#34;\${a}+10&#34;, d=&#39;\${myparam}&#39;)
    text = definitions.formateval(&#34;this is my text ${a}, ${b}, \${myvar}=${c}+${d}&#34;)
    print(text)  # &#34;this is my text 1, 11, \${myvar}=\${a}+10+${myparam}&#34;
    ```

    ---

    ### Advanced Usage

    #### Rearranging and Sorting Definitions
    ```python
    s = param(
        a=1,
        f=&#34;${e}/3&#34;,
        e=&#34;${a}*${c}&#34;,
        c=&#34;${a}+${b}&#34;,
        b=2,
        d=&#34;${c}*2&#34;
    )
    s.sortdefinitions()
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} (= 3)
    #      d: ${c} * 2 (= 6)
    #      e: ${a} * ${c} (= 3)
    #      f: ${e} / 3 (= 1.0)
    # --------
    ```

    #### Internal Evaluation and Recursion with !
    ```python
    p=param()
    p.a = [0,1,2]
    p.b = &#39;![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]&#39;
    p
    # Output:
    #  -------------:----------------------------------------
    #          a: [0, 1, 2]
    #          b: ![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]
    #           = [1, 2, &#39;test&#39;, &#39;1&#39;]
    #  -------------:----------------------------------------
    # Out: parameter list (param object) with 2 definitions
    ```

    #### Error Handling
    ```python
    p = param(b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;, a=1)
    p.disp()
    # Output:
    # --------
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      a: 1
    # --------
    ```

    Sorting unresolved definitions raises errors unless explicitly suppressed:
    ```python
    p.sortdefinitions(raiseerror=False)
    # WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
    ```

    ---

    ### Utility Methods
    | Method                 | Description                                             |
    |------------------------|---------------------------------------------------------|
    | `eval()`               | Evaluate all field expressions.                         |
    | `formateval(string)`   | Format and evaluate a string with field placeholders.   |
    | `protect(string)`      | Escape variable placeholders in a string.               |
    | `sortdefinitions()`    | Sort definitions to resolve dependencies.               |
    | `escape(string)`       | Protect escaped variables in a string.                  |
    | `safe_fstring(string)` | evaluate safely complex mathemical expressions.         |

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two parameter lists, sorting definitions.
    - `-`: Subtraction of fields.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Notes
    - The `paramauto` class simplifies handling of partial definitions and inherits from `param`.
    - Use `paramauto` when definitions need to be stacked irrespective of execution order.
    &#34;&#34;&#34;

    # override
    _type = &#34;param&#34;
    _fulltype = &#34;parameter list&#34;
    _ftype = &#34;definition&#34;
    _evalfeature = True    # This class can be evaluated with .eval()
    _returnerror = True    # This class returns an error in the evaluation string (added on 2024-09-06)

    # magic constructor
    def __init__(self,_protection=False,_evaluation=True,
                 sortdefinitions=False,debug=False,**kwargs):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        super().__init__(debug=debug,**kwargs)
        self._protection = _protection
        self._evaluation = _evaluation
        if sortdefinitions: self.sortdefinitions()

    # escape definitions if needed
    @staticmethod
    def escape(s):
        &#34;&#34;&#34;
            escape \${} as ${{}} --&gt; keep variable names
            convert ${} as {} --&gt; prepare Python replacement

            Examples:
                escape(&#34;\${a}&#34;)
                returns (&#39;${{a}}&#39;, True)

                escape(&#34;  \${abc} ${a} \${bc}&#34;)
                returns (&#39;  ${{abc}} {a} ${{bc}}&#39;, True)

                escape(&#34;${a}&#34;)
                Out[94]: (&#39;{a}&#39;, False)

                escape(&#34;${tata}&#34;)
                returns (&#39;{tata}&#39;, False)

        &#34;&#34;&#34;
        if not isinstance(s,str):
            raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)
        se, start, found = &#34;&#34;, 0, True
        while found:
            pos0 = s.find(&#34;\${&#34;,start)
            found = pos0&gt;=0
            if found:
                pos1 = s.find(&#34;}&#34;,pos0)
                found = pos1&gt;=0
                if found:
                    se += s[start:pos0].replace(&#34;${&#34;,&#34;{&#34;)+&#34;${{&#34;+s[pos0+3:pos1]+&#34;}}&#34;
                    start=pos1+1
        result = se+s[start:].replace(&#34;${&#34;,&#34;{&#34;)
        if isinstance(s,pstr): result = pstr(result)
        return result,start&gt;0

    # protect variables in a string
    def protect(self,s=&#34;&#34;):
        &#34;&#34;&#34; protect $variable as ${variable} &#34;&#34;&#34;
        if isinstance(s,str):
            t = s.replace(&#34;\$&#34;,&#34;££&#34;) # &amp;&amp; is a placeholder
            escape = t!=s
            for k in self.keyssorted():
                t = t.replace(&#34;$&#34;+k,&#34;${&#34;+k+&#34;}&#34;)
            if escape: t = t.replace(&#34;££&#34;,&#34;\$&#34;)
            if isinstance(s,pstr): t = pstr(t)
            return t, escape
        raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)


    # lines starting with # (hash) are interpreted as comments
    # ${variable} or {variable} are substituted by variable.value
    # any line starting with $ is assumed to be a string (no interpretation)
    # ^ is accepted in formula(replaced by **))
    def eval(self,s=&#34;&#34;,protection=False):
        &#34;&#34;&#34;
            Eval method for structure such as MS.alias

                s = p.eval() or s = p.eval(string)

                where :
                    p is a param object
                    s is a structure with evaluated fields
                    string is only used to determine whether definitions have been forgotten

        &#34;&#34;&#34;
        # Evaluate all DEFINITIONS
        # the argument s is only used by formateval() for error management
        tmp = struct()
        for key,value in self.items():
            # strings are assumed to be expressions on one single line
            if isinstance(value,str):
                # replace ${variable} (Bash, Lammps syntax) by {variable} (Python syntax)
                # use \${variable} to prevent replacement (espace with \)
                # Protect variables if required
                ispstr = isinstance(value,pstr)
                valuesafe = pstr.eval(value,ispstr=ispstr) # value.strip()
                if valuesafe==&#34;${&#34;+key+&#34;}&#34;: # circular reference (it cannot be evaluated)
                    continue
                if protection or self._protection:
                    valuesafe, escape0 = self.protect(valuesafe)
                else:
                    escape0 = False
                # replace ${var} by {var}
                valuesafe_priorescape = param.replace_matrix_shorthand(valuesafe)
                valuesafe, escape = param.escape(valuesafe)
                escape = escape or escape0
                # replace &#34;^&#34; (Matlab, Lammps exponent) by &#34;**&#34; (Python syntax)
                valuesafe = pstr.eval(valuesafe.replace(&#34;^&#34;,&#34;**&#34;),ispstr=ispstr)
                # Remove all content after #
                # if the first character is &#39;#&#39;, it is not comment (e.g. MarkDown titles)
                poscomment = valuesafe.find(&#34;#&#34;)
                if poscomment&gt;0: valuesafe = valuesafe[0:poscomment].strip()
                # Matrix shorthand replacement
                # $[[1,2,${a}]]+$[[10,20,30]] --&gt; np.array([[1,2,${a}]])+np.array([[10,20,30]])
                valuesafe = param.replace_matrix_shorthand(valuesafe)
                # Literal string starts with $ (no interpretation), ! (evaluation)
                if not self._evaluation:
                    tmp.setattr(key, pstr.eval(tmp.format(valuesafe,escape),ispstr=ispstr))
                elif valuesafe.startswith(&#34;!&#34;):
                    try:
                        vtmp = ast.literal_eval(valuesafe[1:])
                        if isinstance(vtmp,list):
                            for i,item in enumerate(vtmp):
                                if isinstance(item,str) and not item.strip().startswith(&#34;$&#34;):
                                    try:
                                        vtmp[i] = tmp.format(item, raiseerror=False)
                                    except Exception as ve:
                                        vtmp[i] = f&#34;Error in &lt;{item}&gt;: {ve.__class__.__name__} - {str(ve)}&#34;
                        tmp.setattr(key,vtmp)
                    except (SyntaxError, ValueError) as e:
                        tmp.setattr(key, f&#34;Error: {e.__class__.__name__} - {str(e)}&#34;)
                elif valuesafe.startswith(&#34;$&#34;) and not escape:
                    tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard $
                elif valuesafe.startswith(&#34;%&#34;):
                    tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard %
                else: # string empty or which can be evaluated
                    if valuesafe==&#34;&#34;:
                        tmp.setattr(key,valuesafe) # empty content
                    else:
                        if isinstance(value,pstr): # keep path
                            tmp.setattr(key, pstr.topath(tmp.format(valuesafe,escape=escape)))
                        elif escape:  # partial evaluation
                            tmp.setattr(key, tmp.format(valuesafe,escape=True))
                        else: # full evaluation (if it fails the last string content is returned)
                            try:
                                resstr = tmp.format(valuesafe,raiseerror=False)
                            except (KeyError,NameError) as nameerr:
                                if self._returnerror: # added on 2024-09-06
                                    strnameerr = str(nameerr).replace(&#34;&#39;&#34;,&#34;&#34;)
                                    tmp.setattr(key,&#39;&lt; undef %s &#34;${%s}&#34; &gt;&#39; % \
                                            (self._ftype,strnameerr))
                                else:
                                    tmp.setattr(key,value) #we keep the original value
                            except (SyntaxError,TypeError,ValueError) as commonerr:
                                tmp.setattr(key,&#34;ERROR &lt; %s &gt;&#34; % commonerr)
                            except (IndexError,AttributeError):
                                try:
                                    resstr = param.safe_fstring(valuesafe_priorescape,tmp)
                                except Exception as fstrerr:
                                    tmp.setattr(key,&#34;Index Error &lt; %s &gt;&#34; % fstrerr)
                                else:
                                    try:
                                        # reseval = eval(resstr)
                                        # reseval = ast.literal_eval(resstr)
                                        # Use SafeEvaluator to evaluate the final expression
                                        evaluator = SafeEvaluator(tmp)
                                        reseval = evaluator.evaluate(resstr)
                                    except Exception as othererr:
                                        #tmp.setattr(key,&#34;Mathematical Error around/in ${}: &lt; %s &gt;&#34; % othererr)
                                        if self._debug:
                                            print(f&#34;DEBUG {key}: Error in Evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                        tmp.setattr(key,resstr)
                                    else:
                                        tmp.setattr(key,reseval)
                            except Exception as othererr:
                                tmp.setattr(key,&#34;Error in ${}: &lt; %s &gt;&#34; % othererr)
                            else:
                                try:
                                    # reseval = eval(resstr)
                                    evaluator = SafeEvaluator(tmp)
                                    reseval = evaluator.evaluate(resstr)
                                except Exception as othererr:
                                    #tmp.setattr(key,&#34;Eval Error &lt; %s &gt;&#34; % othererr)
                                    if self._debug:
                                        print(f&#34;DEBUG {key}: Error in Evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                    tmp.setattr(key,resstr.replace(&#34;\n&#34;,&#34;,&#34;)) # \n replaced by ,
                                else:
                                    tmp.setattr(key,reseval)
            elif isinstance(value,_numeric_types): # already a number
                tmp.setattr(key, value) # store the value with the key
            else: # unsupported types
                if s.find(&#34;{&#34;+key+&#34;}&#34;)&gt;=0:
                    print(f&#39;*** WARNING ***\n\tIn the {self._ftype}:&#34;\n{s}\n&#34;&#39;)
                else:
                    print(f&#39;unable to interpret the &#34;{key}&#34; of type {type(value)}&#39;)
        return tmp

    # formateval obeys to following rules
    # lines starting with # (hash) are interpreted as comments
    def formateval(self,s,protection=False,fullevaluation=True):
        &#34;&#34;&#34;
            format method with evaluation feature

                txt = p.formateval(&#34;this my text with ${variable1}, ${variable2} &#34;)

                where:
                    p is a param object

                Example:
                    definitions = param(a=1,b=&#34;${a}&#34;,c=&#34;\${a}&#34;)
                    text = definitions.formateval(&#34;this my text ${a}, ${b}, ${c}&#34;)
                    print(text)

        &#34;&#34;&#34;
        tmp = self.eval(s,protection=protection)
        evaluator = SafeEvaluator(tmp) # used when fullevaluation=True
        # Do all replacements in s (keep comments)
        if len(tmp)==0:
            return s
        else:
            ispstr = isinstance(s,pstr)
            ssafe, escape = param.escape(s)
            slines = ssafe.split(&#34;\n&#34;)
            for i in range(len(slines)):
                poscomment = slines[i].find(&#34;#&#34;)
                if poscomment&gt;=0:
                    while (poscomment&gt;0) and (slines[i][poscomment-1]==&#34; &#34;):
                        poscomment -= 1
                    comment = slines[i][poscomment:len(slines[i])]
                    slines[i]  = slines[i][0:poscomment]
                else:
                    comment = &#34;&#34;
                # Protect variables if required
                if protection or self._protection:
                    slines[i], escape2 = self.protect(slines[i])
                # conversion
                if ispstr:
                    slines[i] = pstr.eval(tmp.format(slines[i],escape=escape),ispstr=ispstr)
                else:
                    if fullevaluation:
                        try:
                            resstr =tmp.format(slines[i],escape=escape)
                        except:
                            resstr = param.safe_fstring(slines[i],tmp,varprefix=&#34;&#34;)
                        try:
                            reseval = evaluator.evaluate(resstr)
                            slines[i] = str(reseval)+&#34; &#34;+comment if comment else str(reseval)
                        except:
                            slines[i] = resstr + comment
                    else:
                        slines[i] = tmp.format(slines[i],escape=escape)+comment
                # convert starting % into # to authorize replacement in comments
                if len(slines[i])&gt;0:
                    if slines[i][0] == &#34;%&#34;: slines[i]=&#34;#&#34;+slines[i][1:]
            return &#34;\n&#34;.join(slines)

    # returns the equivalent structure evaluated
    def tostruct(self,protection=False):
        &#34;&#34;&#34;
            generate the evaluated structure
                tostruct(protection=False)
        &#34;&#34;&#34;
        return self.eval(protection=protection)

    # returns the equivalent structure evaluated
    def tostatic(self):
        &#34;&#34;&#34; convert dynamic a param() object to a static struct() object.
            note: no interpretation
            note: use tostruct() to interpret them and convert it to struct
            note: tostatic().struct2param() makes it reversible
        &#34;&#34;&#34;
        return struct.fromkeysvalues(self.keys(),self.values(),makeparam=False)


    @staticmethod
    def replace_matrix_shorthand(valuesafe):
        &#34;&#34;&#34;
        Transforms custom shorthand notations for NumPy arrays within a string into valid NumPy array constructors.
        Supports up to 4-dimensional arrays and handles variable references.

        **Shorthand Patterns:**
        - **1D**: `$[1 2 3]` → `np.atleast_2d(np.array([1,2,3]))`
        - **2D**: `$[[1 2],[3 4]]` → `np.array([[1,2],[3,4]])`
        - **3D**: `$[[[1 2],[3 4]],[[5 6],[7 8]]]` → `np.array([[[1,2],[3,4]],[[5,6],[7,8]]])`
        - **4D**: `$[[[[1 2]]]]` → `np.array([[[[1,2]]]])`
        - **Variable References**: `@{var}` → `np.atleast_2d(np.array(${var}))`

        **Parameters:**
        ----------
        valuesafe : str
            The input string containing shorthand notations for NumPy arrays and variable references.

        **Returns:**
        -------
        str
            The transformed string with shorthands replaced by valid NumPy array constructors.

        **Raises:**
        -------
        ValueError
            If there are unmatched brackets in any shorthand.

        **Examples:**
        --------
        &gt;&gt;&gt; # 1D shorthand
        &gt;&gt;&gt; s = &#34;$[1 2 3]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.atleast_2d(np.array([1,2,3]))&#39;

        &gt;&gt;&gt; # 2D shorthand with mixed spacing
        &gt;&gt;&gt; s = &#34;$[[1, 2], [3 4]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[1,2],[3,4]])&#39;

        &gt;&gt;&gt; # 3D array with partial spacing
        &gt;&gt;&gt; s = &#34;$[[[1  2], [3 4]], [[5 6], [7 8]]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[1,2],[3,4]],[[5,6],[7,8]]])&#39;

        &gt;&gt;&gt; # 4D array
        &gt;&gt;&gt; s = &#34;$[[[[1 2]]]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[[1,2]]]])&#39;

        &gt;&gt;&gt; # Combined with variable references
        &gt;&gt;&gt; s = &#34;@{a} + $[[${b}, 2],[ 3  4]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.atleast_2d(np.array(${a})) + np.array([[${b},2],[3,4]])&#39;

        &gt;&gt;&gt; # Complex ND array with scaling
        &gt;&gt;&gt; s = &#39;$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*0.001&#39;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[-0.5,-0.5],[-0.5,-0.5]],[[0.5,0.5],[0.5,0.5]]])*0.001&#39;
        &#34;&#34;&#34;
        def replace_spaces_with_commas(txt):
            &#34;&#34;&#34;
            Replaces spaces with commas only when they&#39;re not preceded by a comma, opening bracket, or whitespace,
            and are followed by a digit or &#39;$&#39;. Also collapses multiple commas into one and strips leading/trailing commas.

            Parameters:
            ----------
            txt : str
                The text to process.

            Returns:
            -------
            str
                The processed text with appropriate commas.
            &#34;&#34;&#34;
            # Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas
            txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
            # Remove multiple consecutive commas
            txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
            return txt.strip(&#39;,&#39;)

        def build_pass_list(string):
            &#34;&#34;&#34;
            Determines which dimensions (1D..4D) appear in the string by searching for:
             - 4D: $[[[[
             - 3D: $[[[
             - 2D: $[[
             - 1D: $[

            Returns a sorted list in descending order, e.g., [4, 3, 2, 1].

            Parameters:
            ----------
            string : str
                The input string to scan.

            Returns:
            -------
            list
                A list of integers representing the dimensions found, sorted descending.
            &#34;&#34;&#34;
            dims_found = set()
            if re.search(r&#39;\$\[\[\[\[&#39;, string):
                dims_found.add(4)
            if re.search(r&#39;\$\[\[\[&#39;, string):
                dims_found.add(3)
            if re.search(r&#39;\$\[\[&#39;, string):
                dims_found.add(2)
            if re.search(r&#39;\$\[&#39;, string):
                dims_found.add(1)
            return sorted(dims_found, reverse=True)

        # Step 1: Handle @{var} -&gt; np.atleast_2d(np.array(${var}))
        valuesafe = re.sub(r&#39;@\{([^\{\}]+)\}&#39;, r&#39;np.atleast_2d(np.array(${\1}))&#39;, valuesafe)

        # Step 2: Build pass list from largest dimension to smallest
        pass_list = build_pass_list(valuesafe)

        # Step 3: Define patterns and replacements for each dimension
        dimension_patterns = {
            4: (r&#39;\$\[\[\[\[(.*?)\]\]\]\]&#39;, &#39;np.array([[[[{content}]]]])&#39;),   # 4D
            3: (r&#39;\$\[\[\[(.*?)\]\]\]&#39;, &#39;np.array([[[{content}]]])&#39;),         # 3D
            2: (r&#39;\$\[\[(.*?)\]\]&#39;, &#39;np.array([[{content}]])&#39;),               # 2D
            1: (r&#39;\$\[(.*?)\]&#39;, &#39;np.atleast_2d(np.array([{content}]))&#39;)       # 1D
        }

        # Step 4: Iterate over each dimension and perform replacements
        for dim in pass_list:
            pattern, replacement_fmt = dimension_patterns[dim]
            # Find all non-overlapping matches for the current dimension
            matches = list(re.finditer(pattern, valuesafe))
            for match in matches:
                full_match = match.group(0)       # Entire matched shorthand
                inner_content = match.group(1)    # Content inside the brackets
                # Replace spaces with commas as per rules
                processed_content = replace_spaces_with_commas(inner_content.strip())
                # Create the replacement string
                replacement = replacement_fmt.format(content=processed_content)
                # Replace the shorthand in the string
                valuesafe = valuesafe.replace(full_match, replacement)

        # Step 5: Verify that all shorthands have been replaced by checking for remaining &#39;$[&#39;
        if re.search(r&#39;\$\[&#39;, valuesafe):
            raise ValueError(&#34;Unmatched or improperly formatted brackets detected in the input string.&#34;)

        return valuesafe



    # Safe fstring
    @staticmethod
    def safe_fstring(template, context,varprefix=&#34;$&#34;):
        &#34;&#34;&#34;Safely evaluate expressions in ${} using SafeEvaluator.&#34;&#34;&#34;
        evaluator = SafeEvaluator(context)
        # Process template string in combination with safe_fstring()
        # it is required to have an output compatible with eval()

        def process_template(valuesafe):
            &#34;&#34;&#34;
            Processes the input string by:
            1. Stripping leading and trailing whitespace.
            2. Removing comments (any text after &#39;#&#39; unless &#39;#&#39; is the first character).
            3. Replacing &#39;^&#39; with &#39;**&#39;.
            4. Replacing &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;. &lt;-- not applied anymore (brings confusion)

            Args:
                valuesafe (str): The input string to process.

            Returns:
                str: The processed string.
            &#34;&#34;&#34;
            # Step 1: Strip leading and trailing whitespace
            valuesafe = valuesafe.strip()
            # Step 2: Remove comments
            # This regex removes &#39;#&#39; and everything after it if &#39;#&#39; is not the first character
            # (?&lt;!^) is a negative lookbehind that ensures &#39;#&#39; is not at the start of the string
            valuesafe = re.sub(r&#39;(?&lt;!^)\#.*&#39;, &#39;&#39;, valuesafe)
            # Step 3: Replace &#39;^&#39; with &#39;**&#39;
            valuesafe = re.sub(r&#39;\^&#39;, &#39;**&#39;, valuesafe)
            # Step 4: Replace &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;
            # (?&lt;!\$)\{ matches &#39;{&#39; not preceded by &#39;$&#39;
            # valuesafe = re.sub(r&#39;(?&lt;!\$)\{&#39;, &#39;${&#39;, valuesafe)
            # Optional: Strip again to remove any trailing whitespace left after removing comments
            valuesafe = valuesafe.strip()
            return valuesafe

        # Adjusted display for NumPy arrays
        def serialize_result(result):
            &#34;&#34;&#34;
            Serialize the result into a string that can be evaluated in Python.
            Handles NumPy arrays by converting them to lists with commas.
            Handles other iterable types appropriately.
            &#34;&#34;&#34;
            if isinstance(result, np.ndarray):
                return str(result.tolist())
            elif isinstance(result, (list, tuple, dict)):
                return str(result)
            else:
                return str(result)
        # Regular expression to find ${expr} patterns
        escaped_varprefix = re.escape(varprefix)
        pattern = re.compile(escaped_varprefix+r&#39;\{([^{}]+)\}&#39;)
        def replacer(match):
            expr = match.group(1)
            try:
                result = evaluator.evaluate(expr)
                serialized = serialize_result(result)
                return serialized
            except Exception as e:
                return f&#34;&lt;Error: {e}&gt;&#34;
        return pattern.sub(replacer, process_template(template))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.private.mstruct.paramauto</li>
<li>pizza.script.scriptdata</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="region.param.escape"><code class="name flex">
<span>def <span class="ident">escape</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>escape \${} as ${{}} &ndash;&gt; keep variable names
convert ${} as {} &ndash;&gt; prepare Python replacement</p>
<h2 id="examples">Examples</h2>
<p>escape("\${a}")
returns ('${{a}}', True)</p>
<p>escape("
\${abc} ${a} \${bc}")
returns ('
${{abc}} {a} ${{bc}}', True)</p>
<p>escape("${a}")
Out[94]: ('{a}', False)</p>
<p>escape("${tata}")
returns ('{tata}', False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def escape(s):
    &#34;&#34;&#34;
        escape \${} as ${{}} --&gt; keep variable names
        convert ${} as {} --&gt; prepare Python replacement

        Examples:
            escape(&#34;\${a}&#34;)
            returns (&#39;${{a}}&#39;, True)

            escape(&#34;  \${abc} ${a} \${bc}&#34;)
            returns (&#39;  ${{abc}} {a} ${{bc}}&#39;, True)

            escape(&#34;${a}&#34;)
            Out[94]: (&#39;{a}&#39;, False)

            escape(&#34;${tata}&#34;)
            returns (&#39;{tata}&#39;, False)

    &#34;&#34;&#34;
    if not isinstance(s,str):
        raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)
    se, start, found = &#34;&#34;, 0, True
    while found:
        pos0 = s.find(&#34;\${&#34;,start)
        found = pos0&gt;=0
        if found:
            pos1 = s.find(&#34;}&#34;,pos0)
            found = pos1&gt;=0
            if found:
                se += s[start:pos0].replace(&#34;${&#34;,&#34;{&#34;)+&#34;${{&#34;+s[pos0+3:pos1]+&#34;}}&#34;
                start=pos1+1
    result = se+s[start:].replace(&#34;${&#34;,&#34;{&#34;)
    if isinstance(s,pstr): result = pstr(result)
    return result,start&gt;0</code></pre>
</details>
</dd>
<dt id="region.param.replace_matrix_shorthand"><code class="name flex">
<span>def <span class="ident">replace_matrix_shorthand</span></span>(<span>valuesafe)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms custom shorthand notations for NumPy arrays within a string into valid NumPy array constructors.
Supports up to 4-dimensional arrays and handles variable references.</p>
<p><strong>Shorthand Patterns:</strong>
- <strong>1D</strong>: <code>$[1 2 3]</code> → <code>np.atleast_2d(np.array([1,2,3]))</code>
- <strong>2D</strong>: <code>$[[1 2],[3 4]]</code> → <code>np.array([[1,2],[3,4]])</code>
- <strong>3D</strong>: <code>$[[[1 2],[3 4]],[[5 6],[7 8]]]</code> → <code>np.array([[[1,2],[3,4]],[[5,6],[7,8]]])</code>
- <strong>4D</strong>: <code>$[[[[1 2]]]]</code> → <code>np.array([[[[1,2]]]])</code>
- <strong>Variable References</strong>: <code>@{var}</code> → <code>np.atleast_2d(np.array(${var}))</code></p>
<h2 id="parameters"><strong>Parameters:</strong></h2>
<p>valuesafe : str
The input string containing shorthand notations for NumPy arrays and variable references.</p>
<h2 id="returns"><strong>Returns:</strong></h2>
<p>str
The transformed string with shorthands replaced by valid NumPy array constructors.</p>
<h2 id="raises"><strong>Raises:</strong></h2>
<p>ValueError
If there are unmatched brackets in any shorthand.</p>
<h2 id="examples"><strong>Examples:</strong></h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 1D shorthand
&gt;&gt;&gt; s = &quot;$[1 2 3]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.atleast_2d(np.array([1,2,3]))'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 2D shorthand with mixed spacing
&gt;&gt;&gt; s = &quot;$[[1, 2], [3 4]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[1,2],[3,4]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 3D array with partial spacing
&gt;&gt;&gt; s = &quot;$[[[1  2], [3 4]], [[5 6], [7 8]]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[[1,2],[3,4]],[[5,6],[7,8]]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 4D array
&gt;&gt;&gt; s = &quot;$[[[[1 2]]]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[[[1,2]]]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Combined with variable references
&gt;&gt;&gt; s = &quot;@{a} + $[[${b}, 2],[ 3  4]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.atleast_2d(np.array(${a})) + np.array([[${b},2],[3,4]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Complex ND array with scaling
&gt;&gt;&gt; s = '$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*0.001'
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[[-0.5,-0.5],[-0.5,-0.5]],[[0.5,0.5],[0.5,0.5]]])*0.001'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def replace_matrix_shorthand(valuesafe):
    &#34;&#34;&#34;
    Transforms custom shorthand notations for NumPy arrays within a string into valid NumPy array constructors.
    Supports up to 4-dimensional arrays and handles variable references.

    **Shorthand Patterns:**
    - **1D**: `$[1 2 3]` → `np.atleast_2d(np.array([1,2,3]))`
    - **2D**: `$[[1 2],[3 4]]` → `np.array([[1,2],[3,4]])`
    - **3D**: `$[[[1 2],[3 4]],[[5 6],[7 8]]]` → `np.array([[[1,2],[3,4]],[[5,6],[7,8]]])`
    - **4D**: `$[[[[1 2]]]]` → `np.array([[[[1,2]]]])`
    - **Variable References**: `@{var}` → `np.atleast_2d(np.array(${var}))`

    **Parameters:**
    ----------
    valuesafe : str
        The input string containing shorthand notations for NumPy arrays and variable references.

    **Returns:**
    -------
    str
        The transformed string with shorthands replaced by valid NumPy array constructors.

    **Raises:**
    -------
    ValueError
        If there are unmatched brackets in any shorthand.

    **Examples:**
    --------
    &gt;&gt;&gt; # 1D shorthand
    &gt;&gt;&gt; s = &#34;$[1 2 3]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.atleast_2d(np.array([1,2,3]))&#39;

    &gt;&gt;&gt; # 2D shorthand with mixed spacing
    &gt;&gt;&gt; s = &#34;$[[1, 2], [3 4]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[1,2],[3,4]])&#39;

    &gt;&gt;&gt; # 3D array with partial spacing
    &gt;&gt;&gt; s = &#34;$[[[1  2], [3 4]], [[5 6], [7 8]]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[[1,2],[3,4]],[[5,6],[7,8]]])&#39;

    &gt;&gt;&gt; # 4D array
    &gt;&gt;&gt; s = &#34;$[[[[1 2]]]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[[[1,2]]]])&#39;

    &gt;&gt;&gt; # Combined with variable references
    &gt;&gt;&gt; s = &#34;@{a} + $[[${b}, 2],[ 3  4]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.atleast_2d(np.array(${a})) + np.array([[${b},2],[3,4]])&#39;

    &gt;&gt;&gt; # Complex ND array with scaling
    &gt;&gt;&gt; s = &#39;$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*0.001&#39;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[[-0.5,-0.5],[-0.5,-0.5]],[[0.5,0.5],[0.5,0.5]]])*0.001&#39;
    &#34;&#34;&#34;
    def replace_spaces_with_commas(txt):
        &#34;&#34;&#34;
        Replaces spaces with commas only when they&#39;re not preceded by a comma, opening bracket, or whitespace,
        and are followed by a digit or &#39;$&#39;. Also collapses multiple commas into one and strips leading/trailing commas.

        Parameters:
        ----------
        txt : str
            The text to process.

        Returns:
        -------
        str
            The processed text with appropriate commas.
        &#34;&#34;&#34;
        # Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas
        txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
        # Remove multiple consecutive commas
        txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
        return txt.strip(&#39;,&#39;)

    def build_pass_list(string):
        &#34;&#34;&#34;
        Determines which dimensions (1D..4D) appear in the string by searching for:
         - 4D: $[[[[
         - 3D: $[[[
         - 2D: $[[
         - 1D: $[

        Returns a sorted list in descending order, e.g., [4, 3, 2, 1].

        Parameters:
        ----------
        string : str
            The input string to scan.

        Returns:
        -------
        list
            A list of integers representing the dimensions found, sorted descending.
        &#34;&#34;&#34;
        dims_found = set()
        if re.search(r&#39;\$\[\[\[\[&#39;, string):
            dims_found.add(4)
        if re.search(r&#39;\$\[\[\[&#39;, string):
            dims_found.add(3)
        if re.search(r&#39;\$\[\[&#39;, string):
            dims_found.add(2)
        if re.search(r&#39;\$\[&#39;, string):
            dims_found.add(1)
        return sorted(dims_found, reverse=True)

    # Step 1: Handle @{var} -&gt; np.atleast_2d(np.array(${var}))
    valuesafe = re.sub(r&#39;@\{([^\{\}]+)\}&#39;, r&#39;np.atleast_2d(np.array(${\1}))&#39;, valuesafe)

    # Step 2: Build pass list from largest dimension to smallest
    pass_list = build_pass_list(valuesafe)

    # Step 3: Define patterns and replacements for each dimension
    dimension_patterns = {
        4: (r&#39;\$\[\[\[\[(.*?)\]\]\]\]&#39;, &#39;np.array([[[[{content}]]]])&#39;),   # 4D
        3: (r&#39;\$\[\[\[(.*?)\]\]\]&#39;, &#39;np.array([[[{content}]]])&#39;),         # 3D
        2: (r&#39;\$\[\[(.*?)\]\]&#39;, &#39;np.array([[{content}]])&#39;),               # 2D
        1: (r&#39;\$\[(.*?)\]&#39;, &#39;np.atleast_2d(np.array([{content}]))&#39;)       # 1D
    }

    # Step 4: Iterate over each dimension and perform replacements
    for dim in pass_list:
        pattern, replacement_fmt = dimension_patterns[dim]
        # Find all non-overlapping matches for the current dimension
        matches = list(re.finditer(pattern, valuesafe))
        for match in matches:
            full_match = match.group(0)       # Entire matched shorthand
            inner_content = match.group(1)    # Content inside the brackets
            # Replace spaces with commas as per rules
            processed_content = replace_spaces_with_commas(inner_content.strip())
            # Create the replacement string
            replacement = replacement_fmt.format(content=processed_content)
            # Replace the shorthand in the string
            valuesafe = valuesafe.replace(full_match, replacement)

    # Step 5: Verify that all shorthands have been replaced by checking for remaining &#39;$[&#39;
    if re.search(r&#39;\$\[&#39;, valuesafe):
        raise ValueError(&#34;Unmatched or improperly formatted brackets detected in the input string.&#34;)

    return valuesafe</code></pre>
</details>
</dd>
<dt id="region.param.safe_fstring"><code class="name flex">
<span>def <span class="ident">safe_fstring</span></span>(<span>template, context, varprefix='$')</span>
</code></dt>
<dd>
<div class="desc"><p>Safely evaluate expressions in ${} using SafeEvaluator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def safe_fstring(template, context,varprefix=&#34;$&#34;):
    &#34;&#34;&#34;Safely evaluate expressions in ${} using SafeEvaluator.&#34;&#34;&#34;
    evaluator = SafeEvaluator(context)
    # Process template string in combination with safe_fstring()
    # it is required to have an output compatible with eval()

    def process_template(valuesafe):
        &#34;&#34;&#34;
        Processes the input string by:
        1. Stripping leading and trailing whitespace.
        2. Removing comments (any text after &#39;#&#39; unless &#39;#&#39; is the first character).
        3. Replacing &#39;^&#39; with &#39;**&#39;.
        4. Replacing &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;. &lt;-- not applied anymore (brings confusion)

        Args:
            valuesafe (str): The input string to process.

        Returns:
            str: The processed string.
        &#34;&#34;&#34;
        # Step 1: Strip leading and trailing whitespace
        valuesafe = valuesafe.strip()
        # Step 2: Remove comments
        # This regex removes &#39;#&#39; and everything after it if &#39;#&#39; is not the first character
        # (?&lt;!^) is a negative lookbehind that ensures &#39;#&#39; is not at the start of the string
        valuesafe = re.sub(r&#39;(?&lt;!^)\#.*&#39;, &#39;&#39;, valuesafe)
        # Step 3: Replace &#39;^&#39; with &#39;**&#39;
        valuesafe = re.sub(r&#39;\^&#39;, &#39;**&#39;, valuesafe)
        # Step 4: Replace &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;
        # (?&lt;!\$)\{ matches &#39;{&#39; not preceded by &#39;$&#39;
        # valuesafe = re.sub(r&#39;(?&lt;!\$)\{&#39;, &#39;${&#39;, valuesafe)
        # Optional: Strip again to remove any trailing whitespace left after removing comments
        valuesafe = valuesafe.strip()
        return valuesafe

    # Adjusted display for NumPy arrays
    def serialize_result(result):
        &#34;&#34;&#34;
        Serialize the result into a string that can be evaluated in Python.
        Handles NumPy arrays by converting them to lists with commas.
        Handles other iterable types appropriately.
        &#34;&#34;&#34;
        if isinstance(result, np.ndarray):
            return str(result.tolist())
        elif isinstance(result, (list, tuple, dict)):
            return str(result)
        else:
            return str(result)
    # Regular expression to find ${expr} patterns
    escaped_varprefix = re.escape(varprefix)
    pattern = re.compile(escaped_varprefix+r&#39;\{([^{}]+)\}&#39;)
    def replacer(match):
        expr = match.group(1)
        try:
            result = evaluator.evaluate(expr)
            serialized = serialize_result(result)
            return serialized
        except Exception as e:
            return f&#34;&lt;Error: {e}&gt;&#34;
    return pattern.sub(replacer, process_template(template))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.param.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>self, s='', protection=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Eval method for structure such as MS.alias</p>
<pre><code>s = p.eval() or s = p.eval(string)

where :
    p is a param object
    s is a structure with evaluated fields
    string is only used to determine whether definitions have been forgotten
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval(self,s=&#34;&#34;,protection=False):
    &#34;&#34;&#34;
        Eval method for structure such as MS.alias

            s = p.eval() or s = p.eval(string)

            where :
                p is a param object
                s is a structure with evaluated fields
                string is only used to determine whether definitions have been forgotten

    &#34;&#34;&#34;
    # Evaluate all DEFINITIONS
    # the argument s is only used by formateval() for error management
    tmp = struct()
    for key,value in self.items():
        # strings are assumed to be expressions on one single line
        if isinstance(value,str):
            # replace ${variable} (Bash, Lammps syntax) by {variable} (Python syntax)
            # use \${variable} to prevent replacement (espace with \)
            # Protect variables if required
            ispstr = isinstance(value,pstr)
            valuesafe = pstr.eval(value,ispstr=ispstr) # value.strip()
            if valuesafe==&#34;${&#34;+key+&#34;}&#34;: # circular reference (it cannot be evaluated)
                continue
            if protection or self._protection:
                valuesafe, escape0 = self.protect(valuesafe)
            else:
                escape0 = False
            # replace ${var} by {var}
            valuesafe_priorescape = param.replace_matrix_shorthand(valuesafe)
            valuesafe, escape = param.escape(valuesafe)
            escape = escape or escape0
            # replace &#34;^&#34; (Matlab, Lammps exponent) by &#34;**&#34; (Python syntax)
            valuesafe = pstr.eval(valuesafe.replace(&#34;^&#34;,&#34;**&#34;),ispstr=ispstr)
            # Remove all content after #
            # if the first character is &#39;#&#39;, it is not comment (e.g. MarkDown titles)
            poscomment = valuesafe.find(&#34;#&#34;)
            if poscomment&gt;0: valuesafe = valuesafe[0:poscomment].strip()
            # Matrix shorthand replacement
            # $[[1,2,${a}]]+$[[10,20,30]] --&gt; np.array([[1,2,${a}]])+np.array([[10,20,30]])
            valuesafe = param.replace_matrix_shorthand(valuesafe)
            # Literal string starts with $ (no interpretation), ! (evaluation)
            if not self._evaluation:
                tmp.setattr(key, pstr.eval(tmp.format(valuesafe,escape),ispstr=ispstr))
            elif valuesafe.startswith(&#34;!&#34;):
                try:
                    vtmp = ast.literal_eval(valuesafe[1:])
                    if isinstance(vtmp,list):
                        for i,item in enumerate(vtmp):
                            if isinstance(item,str) and not item.strip().startswith(&#34;$&#34;):
                                try:
                                    vtmp[i] = tmp.format(item, raiseerror=False)
                                except Exception as ve:
                                    vtmp[i] = f&#34;Error in &lt;{item}&gt;: {ve.__class__.__name__} - {str(ve)}&#34;
                    tmp.setattr(key,vtmp)
                except (SyntaxError, ValueError) as e:
                    tmp.setattr(key, f&#34;Error: {e.__class__.__name__} - {str(e)}&#34;)
            elif valuesafe.startswith(&#34;$&#34;) and not escape:
                tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard $
            elif valuesafe.startswith(&#34;%&#34;):
                tmp.setattr(key,tmp.format(valuesafe[1:].lstrip())) # discard %
            else: # string empty or which can be evaluated
                if valuesafe==&#34;&#34;:
                    tmp.setattr(key,valuesafe) # empty content
                else:
                    if isinstance(value,pstr): # keep path
                        tmp.setattr(key, pstr.topath(tmp.format(valuesafe,escape=escape)))
                    elif escape:  # partial evaluation
                        tmp.setattr(key, tmp.format(valuesafe,escape=True))
                    else: # full evaluation (if it fails the last string content is returned)
                        try:
                            resstr = tmp.format(valuesafe,raiseerror=False)
                        except (KeyError,NameError) as nameerr:
                            if self._returnerror: # added on 2024-09-06
                                strnameerr = str(nameerr).replace(&#34;&#39;&#34;,&#34;&#34;)
                                tmp.setattr(key,&#39;&lt; undef %s &#34;${%s}&#34; &gt;&#39; % \
                                        (self._ftype,strnameerr))
                            else:
                                tmp.setattr(key,value) #we keep the original value
                        except (SyntaxError,TypeError,ValueError) as commonerr:
                            tmp.setattr(key,&#34;ERROR &lt; %s &gt;&#34; % commonerr)
                        except (IndexError,AttributeError):
                            try:
                                resstr = param.safe_fstring(valuesafe_priorescape,tmp)
                            except Exception as fstrerr:
                                tmp.setattr(key,&#34;Index Error &lt; %s &gt;&#34; % fstrerr)
                            else:
                                try:
                                    # reseval = eval(resstr)
                                    # reseval = ast.literal_eval(resstr)
                                    # Use SafeEvaluator to evaluate the final expression
                                    evaluator = SafeEvaluator(tmp)
                                    reseval = evaluator.evaluate(resstr)
                                except Exception as othererr:
                                    #tmp.setattr(key,&#34;Mathematical Error around/in ${}: &lt; %s &gt;&#34; % othererr)
                                    if self._debug:
                                        print(f&#34;DEBUG {key}: Error in Evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                    tmp.setattr(key,resstr)
                                else:
                                    tmp.setattr(key,reseval)
                        except Exception as othererr:
                            tmp.setattr(key,&#34;Error in ${}: &lt; %s &gt;&#34; % othererr)
                        else:
                            try:
                                # reseval = eval(resstr)
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluator.evaluate(resstr)
                            except Exception as othererr:
                                #tmp.setattr(key,&#34;Eval Error &lt; %s &gt;&#34; % othererr)
                                if self._debug:
                                    print(f&#34;DEBUG {key}: Error in Evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                tmp.setattr(key,resstr.replace(&#34;\n&#34;,&#34;,&#34;)) # \n replaced by ,
                            else:
                                tmp.setattr(key,reseval)
        elif isinstance(value,_numeric_types): # already a number
            tmp.setattr(key, value) # store the value with the key
        else: # unsupported types
            if s.find(&#34;{&#34;+key+&#34;}&#34;)&gt;=0:
                print(f&#39;*** WARNING ***\n\tIn the {self._ftype}:&#34;\n{s}\n&#34;&#39;)
            else:
                print(f&#39;unable to interpret the &#34;{key}&#34; of type {type(value)}&#39;)
    return tmp</code></pre>
</details>
</dd>
<dt id="region.param.formateval"><code class="name flex">
<span>def <span class="ident">formateval</span></span>(<span>self, s, protection=False, fullevaluation=True)</span>
</code></dt>
<dd>
<div class="desc"><p>format method with evaluation feature</p>
<pre><code>txt = p.formateval("this my text with ${variable1}, ${variable2} ")

where:
    p is a param object

Example:
    definitions = param(a=1,b="${a}",c="\${a}")
    text = definitions.formateval("this my text ${a}, ${b}, ${c}")
    print(text)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formateval(self,s,protection=False,fullevaluation=True):
    &#34;&#34;&#34;
        format method with evaluation feature

            txt = p.formateval(&#34;this my text with ${variable1}, ${variable2} &#34;)

            where:
                p is a param object

            Example:
                definitions = param(a=1,b=&#34;${a}&#34;,c=&#34;\${a}&#34;)
                text = definitions.formateval(&#34;this my text ${a}, ${b}, ${c}&#34;)
                print(text)

    &#34;&#34;&#34;
    tmp = self.eval(s,protection=protection)
    evaluator = SafeEvaluator(tmp) # used when fullevaluation=True
    # Do all replacements in s (keep comments)
    if len(tmp)==0:
        return s
    else:
        ispstr = isinstance(s,pstr)
        ssafe, escape = param.escape(s)
        slines = ssafe.split(&#34;\n&#34;)
        for i in range(len(slines)):
            poscomment = slines[i].find(&#34;#&#34;)
            if poscomment&gt;=0:
                while (poscomment&gt;0) and (slines[i][poscomment-1]==&#34; &#34;):
                    poscomment -= 1
                comment = slines[i][poscomment:len(slines[i])]
                slines[i]  = slines[i][0:poscomment]
            else:
                comment = &#34;&#34;
            # Protect variables if required
            if protection or self._protection:
                slines[i], escape2 = self.protect(slines[i])
            # conversion
            if ispstr:
                slines[i] = pstr.eval(tmp.format(slines[i],escape=escape),ispstr=ispstr)
            else:
                if fullevaluation:
                    try:
                        resstr =tmp.format(slines[i],escape=escape)
                    except:
                        resstr = param.safe_fstring(slines[i],tmp,varprefix=&#34;&#34;)
                    try:
                        reseval = evaluator.evaluate(resstr)
                        slines[i] = str(reseval)+&#34; &#34;+comment if comment else str(reseval)
                    except:
                        slines[i] = resstr + comment
                else:
                    slines[i] = tmp.format(slines[i],escape=escape)+comment
            # convert starting % into # to authorize replacement in comments
            if len(slines[i])&gt;0:
                if slines[i][0] == &#34;%&#34;: slines[i]=&#34;#&#34;+slines[i][1:]
        return &#34;\n&#34;.join(slines)</code></pre>
</details>
</dd>
<dt id="region.param.protect"><code class="name flex">
<span>def <span class="ident">protect</span></span>(<span>self, s='')</span>
</code></dt>
<dd>
<div class="desc"><p>protect $variable as ${variable}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protect(self,s=&#34;&#34;):
    &#34;&#34;&#34; protect $variable as ${variable} &#34;&#34;&#34;
    if isinstance(s,str):
        t = s.replace(&#34;\$&#34;,&#34;££&#34;) # &amp;&amp; is a placeholder
        escape = t!=s
        for k in self.keyssorted():
            t = t.replace(&#34;$&#34;+k,&#34;${&#34;+k+&#34;}&#34;)
        if escape: t = t.replace(&#34;££&#34;,&#34;\$&#34;)
        if isinstance(s,pstr): t = pstr(t)
        return t, escape
    raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)</code></pre>
</details>
</dd>
<dt id="region.param.tostatic"><code class="name flex">
<span>def <span class="ident">tostatic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>convert dynamic a param() object to a static struct() object.
note: no interpretation
note: use tostruct() to interpret them and convert it to struct
note: tostatic().struct2param() makes it reversible</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tostatic(self):
    &#34;&#34;&#34; convert dynamic a param() object to a static struct() object.
        note: no interpretation
        note: use tostruct() to interpret them and convert it to struct
        note: tostatic().struct2param() makes it reversible
    &#34;&#34;&#34;
    return struct.fromkeysvalues(self.keys(),self.values(),makeparam=False)</code></pre>
</details>
</dd>
<dt id="region.param.tostruct"><code class="name flex">
<span>def <span class="ident">tostruct</span></span>(<span>self, protection=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generate the evaluated structure
tostruct(protection=False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tostruct(self,protection=False):
    &#34;&#34;&#34;
        generate the evaluated structure
            tostruct(protection=False)
    &#34;&#34;&#34;
    return self.eval(protection=protection)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.paramauto"><code class="flex name class">
<span>class <span class="ident">paramauto</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-paramauto">Class: <code><a title="region.paramauto" href="#region.paramauto">paramauto</a></code></h1>
<p>A subclass of <code><a title="region.param" href="#region.param">param</a></code> with enhanced handling for automatic sorting and evaluation
of definitions. The <code><a title="region.paramauto" href="#region.paramauto">paramauto</a></code> class ensures that all fields are sorted to resolve
dependencies, allowing seamless stacking of partially defined objects.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Inherits all functionalities of <code><a title="region.param" href="#region.param">param</a></code>.</li>
<li>Automatically sorts definitions for dependency resolution.</li>
<li>Simplifies handling of partial definitions in dynamic structures.</li>
<li>Supports safe concatenation of definitions.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="automatic-dependency-sorting">Automatic Dependency Sorting</h4>
<p>Definitions are automatically sorted to resolve dependencies:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${b}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${b} (= 3)
# --------
</code></pre>
<h4 id="handling-missing-definitions">Handling Missing Definitions</h4>
<p>Unresolved dependencies raise warnings but do not block execution:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${d}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-inheritance">Concatenation and Inheritance</h3>
<p>Concatenating <code><a title="region.paramauto" href="#region.paramauto">paramauto</a></code> objects resolves definitions:</p>
<pre><code class="language-python">p1 = paramauto(a=1, b=&quot;${a}+2&quot;)
p2 = paramauto(c=&quot;${b}*3&quot;)
p3 = p1 + p2
p3.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 2 (= 3)
#      c: ${b} * 3 (= 9)
# --------
</code></pre>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Automatically sorts fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate all fields, resolving dependencies.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display all fields with their resolved values.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="overloaded-operators">Overloaded Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenates two <code><a title="region.paramauto" href="#region.paramauto">paramauto</a></code> objects, resolving dependencies.</li>
<li><code>+=</code>: Updates the current object with another, resolving dependencies.</li>
<li><code>len()</code>: Number of fields.</li>
<li><code>in</code>: Check for field existence.</li>
</ul>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="partial-definitions">Partial Definitions</h4>
<p>The <code><a title="region.paramauto" href="#region.paramauto">paramauto</a></code> class simplifies handling of partially defined fields:</p>
<pre><code class="language-python">p = paramauto(a=&quot;${d}&quot;, b=&quot;${a}+1&quot;)
p.disp()
# Warning: Unable to resolve dependencies.
# --------
#      a: ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
#      b: ${a} + 1 (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------

p.d = 10
p.disp()
# Dependencies are resolved:
# --------
#      d: 10
#      a: ${d} (= 10)
#      b: ${a} + 1 (= 11)
# --------
</code></pre>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>The <code><a title="region.paramauto" href="#region.paramauto">paramauto</a></code> class is computationally more intensive than <code><a title="region.param" href="#region.param">param</a></code> due to automatic sorting.</li>
<li>It is ideal for managing dynamic systems with complex interdependencies.</li>
</ul>
<h3 id="examples_1">Examples</h3>
<pre><code>            p = paramauto()
            p.b = "${aa}"
            p.disp()
        yields
            WARNING: unable to interpret 1/1 expressions in "definitions"
              -----------:----------------------------------------
                        b: ${aa}
                         = &lt; undef definition "${aa}" &gt;
              -----------:----------------------------------------
              p.aa = 2
              p.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
            -----------:----------------------------------------
            q = paramauto(c="${aa}+${b}")+p
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
                      c: ${aa}+${b}
                       = 4
            -----------:----------------------------------------
            q.aa = 30
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 30
                      b: ${aa}
                       = 30
                      c: ${aa}+${b}
                       = 60
            -----------:----------------------------------------
            q.aa = "${d}"
            q.disp()
        yields multiple errors (recursion)
        WARNING: unable to interpret 3/3 expressions in "definitions"
          -----------:----------------------------------------
                   aa: ${d}
                     = &lt; undef definition "${d}" &gt;
                    b: ${aa}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                    c: ${aa}+${b}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
          -----------:----------------------------------------
            q.d = 100
            q.disp()
        yields
          -----------:----------------------------------------
                    d: 100
                   aa: ${d}
                     = 100
                    b: ${aa}
                     = 100
                    c: ${aa}+${b}
                     = 200
          -----------:----------------------------------------


    Example:

        p = paramauto(b="${a}+1",c="${a}+${d}",a=1)
        p.disp()
    generates:
        WARNING: unable to interpret 1/3 expressions in "definitions"
          -----------:----------------------------------------
                    a: 1
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = &lt; undef definition "${d}" &gt;
          -----------:----------------------------------------
    setting p.d
        p.d = 2
        p.disp()
    produces
          -----------:----------------------------------------
                    a: 1
                    d: 2
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = 3
          -----------:----------------------------------------
</code></pre>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class paramauto(param):
    &#34;&#34;&#34;
    Class: `paramauto`
    ==================

    A subclass of `param` with enhanced handling for automatic sorting and evaluation
    of definitions. The `paramauto` class ensures that all fields are sorted to resolve
    dependencies, allowing seamless stacking of partially defined objects.

    ---

    ### Features
    - Inherits all functionalities of `param`.
    - Automatically sorts definitions for dependency resolution.
    - Simplifies handling of partial definitions in dynamic structures.
    - Supports safe concatenation of definitions.

    ---

    ### Examples

    #### Automatic Dependency Sorting
    Definitions are automatically sorted to resolve dependencies:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${b}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${b} (= 3)
    # --------
    ```

    #### Handling Missing Definitions
    Unresolved dependencies raise warnings but do not block execution:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------
    ```

    ---

    ### Concatenation and Inheritance
    Concatenating `paramauto` objects resolves definitions:
    ```python
    p1 = paramauto(a=1, b=&#34;${a}+2&#34;)
    p2 = paramauto(c=&#34;${b}*3&#34;)
    p3 = p1 + p2
    p3.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 2 (= 3)
    #      c: ${b} * 3 (= 9)
    # --------
    ```

    ---

    ### Utility Methods

    | Method                | Description                                            |
    |-----------------------|--------------------------------------------------------|
    | `sortdefinitions()`   | Automatically sorts fields to resolve dependencies.    |
    | `eval()`              | Evaluate all fields, resolving dependencies.           |
    | `disp()`              | Display all fields with their resolved values.         |

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `+`: Concatenates two `paramauto` objects, resolving dependencies.
    - `+=`: Updates the current object with another, resolving dependencies.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Advanced Usage

    #### Partial Definitions
    The `paramauto` class simplifies handling of partially defined fields:
    ```python
    p = paramauto(a=&#34;${d}&#34;, b=&#34;${a}+1&#34;)
    p.disp()
    # Warning: Unable to resolve dependencies.
    # --------
    #      a: ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      b: ${a} + 1 (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------

    p.d = 10
    p.disp()
    # Dependencies are resolved:
    # --------
    #      d: 10
    #      a: ${d} (= 10)
    #      b: ${a} + 1 (= 11)
    # --------
    ```

    ---

    ### Notes
    - The `paramauto` class is computationally more intensive than `param` due to automatic sorting.
    - It is ideal for managing dynamic systems with complex interdependencies.

    ### Examples
                    p = paramauto()
                    p.b = &#34;${aa}&#34;
                    p.disp()
                yields
                    WARNING: unable to interpret 1/1 expressions in &#34;definitions&#34;
                      -----------:----------------------------------------
                                b: ${aa}
                                 = &lt; undef definition &#34;${aa}&#34; &gt;
                      -----------:----------------------------------------
                      p.aa = 2
                      p.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                    -----------:----------------------------------------
                    q = paramauto(c=&#34;${aa}+${b}&#34;)+p
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                              c: ${aa}+${b}
                               = 4
                    -----------:----------------------------------------
                    q.aa = 30
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 30
                              b: ${aa}
                               = 30
                              c: ${aa}+${b}
                               = 60
                    -----------:----------------------------------------
                    q.aa = &#34;${d}&#34;
                    q.disp()
                yields multiple errors (recursion)
                WARNING: unable to interpret 3/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                           aa: ${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                            b: ${aa}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                            c: ${aa}+${b}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                  -----------:----------------------------------------
                    q.d = 100
                    q.disp()
                yields
                  -----------:----------------------------------------
                            d: 100
                           aa: ${d}
                             = 100
                            b: ${aa}
                             = 100
                            c: ${aa}+${b}
                             = 200
                  -----------:----------------------------------------


            Example:

                p = paramauto(b=&#34;${a}+1&#34;,c=&#34;${a}+${d}&#34;,a=1)
                p.disp()
            generates:
                WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                            a: 1
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                  -----------:----------------------------------------
            setting p.d
                p.d = 2
                p.disp()
            produces
                  -----------:----------------------------------------
                            a: 1
                            d: 2
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = 3
                  -----------:----------------------------------------

    &#34;&#34;&#34;

    def __add__(self,p):
        return super(param,self).__add__(p,sortdefinitions=True,raiseerror=False)

    def __iadd__(self,p):
        return super(param,self).__iadd__(p,sortdefinitions=True,raiseerror=False)

    def __repr__(self):
        self.sortdefinitions(raiseerror=False)
        #super(param,self).__repr__()
        super().__repr__()
        return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.dscript.lambdaScriptdata</li>
<li>pizza.forcefield.parameterforcefield</li>
<li>pizza.region.regiondata</li>
<li><a title="region.regiondata" href="#region.regiondata">regiondata</a></li>
</ul>
</dd>
<dt id="region.parameterforcefield"><code class="flex name class">
<span>class <span class="ident">parameterforcefield</span></span>
<span>(</span><span>sortdefinitions=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>class of forcefields parameters, derived from param
note that conctanating two forcefields force them
to to be sorted</p>
<p>Constructor for parameterforcefield. It forces the parent's _returnerror parameter to False.</p>
<h2 id="parameters">Parameters:</h2>
<p>_protection : bool, optional
Whether to enable protection on the parameters (default: False).
_evaluation : bool, optional
Whether evaluation is enabled for the parameters (default: True).
sortdefinitions : bool, optional
Whether to sort definitions upon initialization (default: False).
**kwargs : dict
Additional keyword arguments for the parent class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class parameterforcefield(paramauto):
    &#34;&#34;&#34; class of forcefields parameters, derived from param
        note that conctanating two forcefields force them
        to to be sorted
    &#34;&#34;&#34;
    _type = &#34;FF&#34;
    _fulltype = &#34;forcefield&#34;
    _ftype = &#34;parameter&#34;
    _maxdisplay = 80

    # same strategy as used in dscript for forcing  _returnerror = False (added 2024-09-12)
    def __init__(self, _protection=False, _evaluation=True, sortdefinitions=False, **kwargs):
        &#34;&#34;&#34;
        Constructor for parameterforcefield. It forces the parent&#39;s _returnerror parameter to False.

        Parameters:
        -----------
        _protection : bool, optional
            Whether to enable protection on the parameters (default: False).
        _evaluation : bool, optional
            Whether evaluation is enabled for the parameters (default: True).
        sortdefinitions : bool, optional
            Whether to sort definitions upon initialization (default: False).
        **kwargs : dict
            Additional keyword arguments for the parent class.
        &#34;&#34;&#34;
        # Call the parent class constructor
        super().__init__(_protection=_protection, _evaluation=_evaluation, sortdefinitions=sortdefinitions, **kwargs)
        # Override the _returnerror attribute at the instance level
        self._returnerror = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.paramauto</li>
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.generic.genericdata</li>
</ul>
</dd>
<dt id="region.pipescript"><code class="flex name class">
<span>class <span class="ident">pipescript</span></span>
<span>(</span><span>s=None, name=None, printflag=False, verbose=True, verbosity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>pipescript: A Class for Managing Script Pipelines</p>
<p>The <code><a title="region.pipescript" href="#region.pipescript">pipescript</a></code> class stores scripts in a pipeline where multiple scripts,
script objects, or script object groups can be combined and executed
sequentially. Scripts in the pipeline are executed using the pipe (<code>|</code>) operator,
allowing for dynamic control over execution order, script concatenation, and
variable management.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Pipeline Construction</strong>: Create pipelines of scripts, combining multiple
script objects, <code><a title="region.script" href="#region.script">script</a></code>, <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code>, or <code>scriptobjectgroup</code> instances.
The pipe operator (<code>|</code>) is overloaded to concatenate scripts.</li>
<li><strong>Sequential Execution</strong>: Execute all scripts in the pipeline in the order
they were added, with support for reordering, selective execution, and
clearing of individual steps.</li>
<li><strong>User and Definition Spaces</strong>: Manage local and global user-defined variables
(<code>USER</code> space) and static definitions for each script in the pipeline.
Global definitions apply to all scripts in the pipeline, while local variables
apply to specific steps.</li>
<li><strong>Flexible Script Handling</strong>: Indexing, slicing, reordering, and renaming
scripts in the pipeline are supported. Scripts can be accessed, replaced,
and modified like array elements.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>LAMMPS Script Automation</strong>: Automate the generation of multi-step simulation
scripts for LAMMPS, combining different simulation setups into a single pipeline.</li>
<li><strong>Script Management</strong>: Combine and manage multiple scripts, tracking user
variables and ensuring that execution order can be adjusted easily.</li>
<li><strong>Advanced Script Execution</strong>: Perform partial pipeline execution, reorder
steps, or clear completed steps while maintaining the original pipeline structure.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, s=None):
Initializes a new <code><a title="region.pipescript" href="#region.pipescript">pipescript</a></code> object, optionally starting with a script
or script-like object (<code><a title="region.script" href="#region.script">script</a></code>, <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code>, <code>scriptobjectgroup</code>).</p>
<p>setUSER(self, idx, key, value):
Set a user-defined variable (<code>USER</code>) for the script at the specified index.</p>
<p>getUSER(self, idx, key):
Get the value of a user-defined variable (<code>USER</code>) for the script at the
specified index.</p>
<p>clear(self, idx=None):
Clear the execution status of scripts in the pipeline, allowing them to
be executed again.</p>
<p>do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Execute the pipeline or a subset of the pipeline, generating a combined
LAMMPS-compatible script.</p>
<p>script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Generate the final LAMMPS script from the pipeline or a subset of the pipeline.</p>
<p>rename(self, name="", idx=None):
Rename the scripts in the pipeline, assigning new names to specific
indices or all scripts.</p>
<p>write(self, file, printflag=True, verbosity=2, verbose=None):
Write the generated script to a file.</p>
<p>dscript(self, verbose=None, **USER)
Convert the current pipescript into a dscript object</p>
<p>header(self, verbose=True,verbosity=None, style=4):
Generate a formatted header for the pipescript file.</p>
<p>list_values(self, varname, what="all"):
List all occurrences and values of a variable across the pipeline scripts.</p>
<p>list_multiple_values(self, varnames, what="all"):
List all occurrences and values of multiple variables across the pipeline scripts.</p>
<p>plot_value_distribution(self, varname, what="all"):
Plot the distribution of values for a given variable across specified scopes.</p>
<p>generate_report(self, filename, varnames=None, scopes="all"):
Generate a comprehensive report for specified variables and writes it to a file.</p>
<h2 id="static-methods">Static Methods:</h2>
<p>join(liste):
Combine a list of <code><a title="region.script" href="#region.script">script</a></code> and <code><a title="region.pipescript" href="#region.pipescript">pipescript</a></code> objects into a single pipeline.</p>
<h2 id="additional-features">Additional Features:</h2>
<ul>
<li><strong>Indexing and Slicing</strong>: Use array-like indexing (<code>p[0]</code>, <code>p[1:3]</code>) to access
and manipulate scripts in the pipeline.</li>
<li><strong>Deep Copy Support</strong>: The pipeline supports deep copying, preserving the
entire pipeline structure and its scripts.</li>
<li><strong>Verbose and Print Options</strong>: Control verbosity and printing behavior for
generated scripts, allowing for detailed output or minimal script generation.</li>
</ul>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="region.pipescript" href="#region.pipescript">pipescript</a></code> class supports a variety of pipeline operations, including:
- Sequential execution with <code>cmd = p.do()</code>.
- Reordering pipelines with <code>p[[2, 0, 1]]</code>.
- Deleting steps with <code>p[[0, 1]] = []</code>.
- Accessing local and global user space variables via <code>p.USER[idx].var</code> and
<code>p.scripts[idx].USER.var</code>.
- Managing static definitions for each script in the pipeline.
- Example usage:
<code>p = pipescript()
p | i
p = G | c | g | d | b | i | t | d | s | r
p.rename(["G", "c", "g", "d", "b", "i", "t", "d", "s", "r"])
cmd = p.do([0, 1, 4, 7])
sp = p.script([0, 1, 4, 7])</code>
- Scripts in the pipeline are executed sequentially, and definitions propagate
from left to right. The <code>USER</code> space and <code>DEFINITIONS</code> are managed separately
for each script in the pipeline.</p>
<h2 id="overview">Overview</h2>
<pre><code>Pipescript class stores scripts in pipelines
    By assuming: s0, s1, s2... scripts, scriptobject or scriptobjectgroup
    p = s0 | s1 | s2 generates a pipe script

    Example of pipeline:
  ------------:----------------------------------------
  [-]  00: G with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  01: c with (0&gt;&gt;0&gt;&gt;10) DEFINITIONS
  [-]  02: g with (0&gt;&gt;0&gt;&gt;26) DEFINITIONS
  [-]  03: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  04: b with (0&gt;&gt;0&gt;&gt;28) DEFINITIONS
  [-]  05: i with (0&gt;&gt;0&gt;&gt;49) DEFINITIONS
  [-]  06: t with (0&gt;&gt;0&gt;&gt;2) DEFINITIONS
  [-]  07: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  08: s with (0&gt;&gt;0&gt;&gt;1) DEFINITIONS
  [-]  09: r with (0&gt;&gt;0&gt;&gt;20) DEFINITIONS
  ------------:----------------------------------------
Out[35]: pipescript containing 11 scripts with 8 executed[*]

note: XX&gt;&gt;YY&gt;&gt;ZZ represents the number of stored variables
     and the direction of propagation (inheritance from left)
     XX: number of definitions in the pipeline USER space
     YY: number of definitions in the script instance (frozen in the pipeline)
     ZZ: number of definitions in the script (frozen space)

    pipelines are executed sequentially (i.e. parameters can be multivalued)
        cmd = p.do()
        fullscript = p.script()

    pipelines are indexed
        cmd = p[[0,2]].do()
        cmd = p[0:2].do()
        cmd = p.do([0,2])

    pipelines can be reordered
        q = p[[2,0,1]]

    steps can be deleted
        p[[0,1]] = []

    clear all executions with
        p.clear()
        p.clear(idx=1,2)

    local USER space can be accessed via
    (affects only the considered step)
        p.USER[0].a = 1
        p.USER[0].b = [1 2]
        p.USER[0].c = "$ hello world"

    global USER space can accessed via
    (affects all steps onward)
        p.scripts[0].USER.a = 10
        p.scripts[0].USER.b = [10 20]
        p.scripts[0].USER.c = "$ bye bye"

    static definitions
        p.scripts[0].DEFINITIONS

    steps can be renamed with the method rename()

    syntaxes are à la Matlab:
        p = pipescript()
        p | i
        p = collection | G
        p[0]
        q = p | p
        q[0] = []
        p[0:1] = q[0:1]
        p = G | c | g | d | b | i | t | d | s | r
        p.rename(["G","c","g","d","b","i","t","d","s","r"])
        cmd = p.do([0,1,4,7])
        sp = p.script([0,1,4,7])
        r = collection | p

    join joins a list (static method)
        p = pipescript.join([p1,p2,s3,s4])


    Pending: mechanism to store LAMMPS results (dump3) in the pipeline
</code></pre>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pipescript:
    &#34;&#34;&#34;
    pipescript: A Class for Managing Script Pipelines

    The `pipescript` class stores scripts in a pipeline where multiple scripts,
    script objects, or script object groups can be combined and executed
    sequentially. Scripts in the pipeline are executed using the pipe (`|`) operator,
    allowing for dynamic control over execution order, script concatenation, and
    variable management.

    Key Features:
    -------------
    - **Pipeline Construction**: Create pipelines of scripts, combining multiple
      script objects, `script`, `scriptobject`, or `scriptobjectgroup` instances.
      The pipe operator (`|`) is overloaded to concatenate scripts.
    - **Sequential Execution**: Execute all scripts in the pipeline in the order
      they were added, with support for reordering, selective execution, and
      clearing of individual steps.
    - **User and Definition Spaces**: Manage local and global user-defined variables
      (`USER` space) and static definitions for each script in the pipeline.
      Global definitions apply to all scripts in the pipeline, while local variables
      apply to specific steps.
    - **Flexible Script Handling**: Indexing, slicing, reordering, and renaming
      scripts in the pipeline are supported. Scripts can be accessed, replaced,
      and modified like array elements.

    Practical Use Cases:
    --------------------
    - **LAMMPS Script Automation**: Automate the generation of multi-step simulation
      scripts for LAMMPS, combining different simulation setups into a single pipeline.
    - **Script Management**: Combine and manage multiple scripts, tracking user
      variables and ensuring that execution order can be adjusted easily.
    - **Advanced Script Execution**: Perform partial pipeline execution, reorder
      steps, or clear completed steps while maintaining the original pipeline structure.

    Methods:
    --------
    __init__(self, s=None):
        Initializes a new `pipescript` object, optionally starting with a script
        or script-like object (`script`, `scriptobject`, `scriptobjectgroup`).

    setUSER(self, idx, key, value):
        Set a user-defined variable (`USER`) for the script at the specified index.

    getUSER(self, idx, key):
        Get the value of a user-defined variable (`USER`) for the script at the
        specified index.

    clear(self, idx=None):
        Clear the execution status of scripts in the pipeline, allowing them to
        be executed again.

    do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Execute the pipeline or a subset of the pipeline, generating a combined
        LAMMPS-compatible script.

    script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Generate the final LAMMPS script from the pipeline or a subset of the pipeline.

    rename(self, name=&#34;&#34;, idx=None):
        Rename the scripts in the pipeline, assigning new names to specific
        indices or all scripts.

    write(self, file, printflag=True, verbosity=2, verbose=None):
        Write the generated script to a file.

    dscript(self, verbose=None, **USER)
        Convert the current pipescript into a dscript object

    header(self, verbose=True,verbosity=None, style=4):
        Generate a formatted header for the pipescript file.

    list_values(self, varname, what=&#34;all&#34;):
        List all occurrences and values of a variable across the pipeline scripts.

    list_multiple_values(self, varnames, what=&#34;all&#34;):
        List all occurrences and values of multiple variables across the pipeline scripts.

    plot_value_distribution(self, varname, what=&#34;all&#34;):
        Plot the distribution of values for a given variable across specified scopes.

    generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
        Generate a comprehensive report for specified variables and writes it to a file.


    Static Methods:
    ---------------
    join(liste):
        Combine a list of `script` and `pipescript` objects into a single pipeline.

    Additional Features:
    --------------------
    - **Indexing and Slicing**: Use array-like indexing (`p[0]`, `p[1:3]`) to access
      and manipulate scripts in the pipeline.
    - **Deep Copy Support**: The pipeline supports deep copying, preserving the
      entire pipeline structure and its scripts.
    - **Verbose and Print Options**: Control verbosity and printing behavior for
      generated scripts, allowing for detailed output or minimal script generation.

    Original Content:
    -----------------
    The `pipescript` class supports a variety of pipeline operations, including:
    - Sequential execution with `cmd = p.do()`.
    - Reordering pipelines with `p[[2, 0, 1]]`.
    - Deleting steps with `p[[0, 1]] = []`.
    - Accessing local and global user space variables via `p.USER[idx].var` and
      `p.scripts[idx].USER.var`.
    - Managing static definitions for each script in the pipeline.
    - Example usage:
      ```
      p = pipescript()
      p | i
      p = G | c | g | d | b | i | t | d | s | r
      p.rename([&#34;G&#34;, &#34;c&#34;, &#34;g&#34;, &#34;d&#34;, &#34;b&#34;, &#34;i&#34;, &#34;t&#34;, &#34;d&#34;, &#34;s&#34;, &#34;r&#34;])
      cmd = p.do([0, 1, 4, 7])
      sp = p.script([0, 1, 4, 7])
      ```
    - Scripts in the pipeline are executed sequentially, and definitions propagate
      from left to right. The `USER` space and `DEFINITIONS` are managed separately
      for each script in the pipeline.

    OVERVIEW
    -----------------
        Pipescript class stores scripts in pipelines
            By assuming: s0, s1, s2... scripts, scriptobject or scriptobjectgroup
            p = s0 | s1 | s2 generates a pipe script

            Example of pipeline:
          ------------:----------------------------------------
          [-]  00: G with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  01: c with (0&gt;&gt;0&gt;&gt;10) DEFINITIONS
          [-]  02: g with (0&gt;&gt;0&gt;&gt;26) DEFINITIONS
          [-]  03: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  04: b with (0&gt;&gt;0&gt;&gt;28) DEFINITIONS
          [-]  05: i with (0&gt;&gt;0&gt;&gt;49) DEFINITIONS
          [-]  06: t with (0&gt;&gt;0&gt;&gt;2) DEFINITIONS
          [-]  07: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  08: s with (0&gt;&gt;0&gt;&gt;1) DEFINITIONS
          [-]  09: r with (0&gt;&gt;0&gt;&gt;20) DEFINITIONS
          ------------:----------------------------------------
        Out[35]: pipescript containing 11 scripts with 8 executed[*]

        note: XX&gt;&gt;YY&gt;&gt;ZZ represents the number of stored variables
             and the direction of propagation (inheritance from left)
             XX: number of definitions in the pipeline USER space
             YY: number of definitions in the script instance (frozen in the pipeline)
             ZZ: number of definitions in the script (frozen space)

            pipelines are executed sequentially (i.e. parameters can be multivalued)
                cmd = p.do()
                fullscript = p.script()

            pipelines are indexed
                cmd = p[[0,2]].do()
                cmd = p[0:2].do()
                cmd = p.do([0,2])

            pipelines can be reordered
                q = p[[2,0,1]]

            steps can be deleted
                p[[0,1]] = []

            clear all executions with
                p.clear()
                p.clear(idx=1,2)

            local USER space can be accessed via
            (affects only the considered step)
                p.USER[0].a = 1
                p.USER[0].b = [1 2]
                p.USER[0].c = &#34;$ hello world&#34;

            global USER space can accessed via
            (affects all steps onward)
                p.scripts[0].USER.a = 10
                p.scripts[0].USER.b = [10 20]
                p.scripts[0].USER.c = &#34;$ bye bye&#34;

            static definitions
                p.scripts[0].DEFINITIONS

            steps can be renamed with the method rename()

            syntaxes are à la Matlab:
                p = pipescript()
                p | i
                p = collection | G
                p[0]
                q = p | p
                q[0] = []
                p[0:1] = q[0:1]
                p = G | c | g | d | b | i | t | d | s | r
                p.rename([&#34;G&#34;,&#34;c&#34;,&#34;g&#34;,&#34;d&#34;,&#34;b&#34;,&#34;i&#34;,&#34;t&#34;,&#34;d&#34;,&#34;s&#34;,&#34;r&#34;])
                cmd = p.do([0,1,4,7])
                sp = p.script([0,1,4,7])
                r = collection | p

            join joins a list (static method)
                p = pipescript.join([p1,p2,s3,s4])


            Pending: mechanism to store LAMMPS results (dump3) in the pipeline
    &#34;&#34;&#34;

    def __init__(self,s=None, name=None, printflag=False, verbose=True, verbosity = None):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        self.globalscript = None
        self.listscript = []
        self.listUSER = []
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.cmd = &#34;&#34;
        if isinstance(s,script):
            self.listscript = [duplicate(s)]
            self.listUSER = [scriptdata()]
        elif isinstance(s,scriptobject):
            self.listscript = [scriptobjectgroup(s).script]
            self.listUSER = [scriptdata()]
        elif isinstance(s,scriptobjectgroup):
            self.listscript = [s.script]
            self.listUSER = [scriptdata()]
        else:
            ValueError(&#34;the argument should be a scriptobject or scriptobjectgroup&#34;)
        if s != None:
            self.name = [str(s)]
            self.executed = [False]
        else:
            self.name = []
            self.executed = []

    def setUSER(self,idx,key,value):
        &#34;&#34;&#34;
            setUSER sets USER variables
            setUSER(idx,varname,varvalue)
        &#34;&#34;&#34;
        if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
            self.listUSER[idx].setattr(key,value)
        else:
            raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)

    def getUSER(self,idx,key):
        &#34;&#34;&#34;
            getUSER get USER variable
            getUSER(idx,varname)
        &#34;&#34;&#34;
        if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
            self.listUSER[idx].getattr(key)
        else:
            raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)

    @property
    def USER(self):
        &#34;&#34;&#34;
            p.USER[idx].var returns the value of the USER variable var
            p.USER[idx].var = val assigns the value val to the USER variable var
        &#34;&#34;&#34;
        return self.listUSER  # override listuser

    @property
    def scripts(self):
        &#34;&#34;&#34;
            p.scripts[idx].USER.var returns the value of the USER variable var
            p.scripts[idx].USER.var = val assigns the value val to the USER variable var
        &#34;&#34;&#34;
        return self.listscript # override listuser

    def __add__(self,s):
        &#34;&#34;&#34; overload + as pipe with copy &#34;&#34;&#34;
        from pizza.dscript import dscript
        if isinstance(s,(pipescript,script)):
            dup = deepduplicate(self)
            return dup | s      # + or | are synonyms
        elif isinstance(s,scriptobject):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s,dscript):
            return self + s.pipescript(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        else:
            raise TypeError(f&#34;The operand should be a pipescript/script/dscript/scriptobjectgroup and not &#39;{type(s).__name__}&#39;&#34;)

    def __iadd__(self,s):
        &#34;&#34;&#34; overload += as pipe without copy &#34;&#34;&#34;
        if isinstance(s,pipescript):
            return self | s      # + or | are synonyms
        else:
            raise TypeError(f&#34;The operand should be a pipescript and not &#39;{type(s).__name__}&#39;&#34;)

    def __mul__(self,ntimes):
        &#34;&#34;&#34; overload * as multiple pipes with copy &#34;&#34;&#34;
        if isinstance(self,pipescript):
            res = deepduplicate(self)
            if ntimes&gt;1:
                for n in range(1,ntimes): res += self
            return res
        else:
            raise TypeError(f&#34;The operand should be a pipescript and not &#39;{type(s).__name__}&#39;&#34;)



    def __or__(self, s):
        &#34;&#34;&#34; Overload | pipe operator in pipescript &#34;&#34;&#34;
        leftarg = deepduplicate(self)  # Make a deep copy of the current object
        # Local import only when dscript type needs to be checked
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        # Convert rightarg to pipescript if needed
        if isinstance(s, dscript):
            rightarg = s.pipescript(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the dscript object to a pipescript
            native = False
        elif isinstance(s,script):
            rightarg = pipescript(s,printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s,(scriptobject,scriptobjectgroup)):
            rightarg = pipescript(s,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, group):
            stmp = s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
            rightarg = pipescript(stmp,printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, groupcollection):
            stmp = s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
            rightarg = pipescript(stmp,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, region):
            rightarg = s.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s,pipescript):
            rightarg = s
            native = True
        else:
            raise TypeError(f&#34;The operand should be a pipescript, dscript, script, scriptobject, scriptobjectgroup, group or groupcollection not {type(s)}&#34;)
        # Native piping
        if native:
            leftarg.listscript = leftarg.listscript + rightarg.listscript
            leftarg.listUSER = leftarg.listUSER + rightarg.listUSER
            leftarg.name = leftarg.name + rightarg.name
            for i in range(len(rightarg)):
                rightarg.executed[i] = False
            leftarg.executed = leftarg.executed + rightarg.executed
            return leftarg
        # Piping for non-native objects (dscript or script-like objects)
        else:
            # Loop through all items in rightarg and concatenate them
            for i in range(rightarg.n):
                leftarg.listscript.append(rightarg.listscript[i])
                leftarg.listUSER.append(rightarg.listUSER[i])
                leftarg.name.append(rightarg.name[i])
                leftarg.executed.append(False)
            return leftarg



    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;pipescript containing {self.n} scripts with {self.nrun} executed[*]&#34;


    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        line = &#34;  &#34;+&#34;-&#34;*12+&#34;:&#34;+&#34;-&#34;*40
        if self.verbose:
            print(&#34;&#34;,&#34;Pipeline with %d scripts and&#34; % self.n,
                  &#34;D(STATIC:GLOBAL:LOCAL) DEFINITIONS&#34;,line,sep=&#34;\n&#34;)
        else:
            print(line)
        for i in range(len(self)):
            if self.executed[i]:
                state = &#34;*&#34;
            else:
                state = &#34;-&#34;
            print(&#34;%10s&#34; % (&#34;[%s]  %02d:&#34; % (state,i)),
                  self.name[i],&#34;with D(%2d:%2d:%2d)&#34; % (
                       len(self.listscript[i].DEFINITIONS),
                       len(self.listscript[i].USER),
                       len(self.listUSER[i])                 )
                  )
        if self.verbose:
            print(line,&#34;::: notes :::&#34;,&#34;p[i], p[i:j], p[[i,j]] copy pipeline segments&#34;,
                  &#34;LOCAL: p.USER[i],p.USER[i].variable modify the user space of only p[i]&#34;,
                  &#34;GLOBAL: p.scripts[i].USER.var to modify the user space from p[i] and onwards&#34;,
                  &#34;STATIC: p.scripts[i].DEFINITIONS&#34;,
                  &#39;p.rename(idx=range(2),name=[&#34;A&#34;,&#34;B&#34;]), p.clear(idx=[0,3,4])&#39;,
                  &#34;p.script(), p.script(idx=range(5)), p[0:5].script()&#34;,&#34;&#34;,sep=&#34;\n&#34;)
        else:
             print(line)
        return str(self)

    def __len__(self):
        &#34;&#34;&#34; len() method &#34;&#34;&#34;
        return len(self.listscript)

    @property
    def n(self):
        &#34;&#34;&#34; number of scripts &#34;&#34;&#34;
        return len(self)

    @property
    def nrun(self):
        &#34;&#34;&#34; number of scripts executed continuously from origin &#34;&#34;&#34;
        n, nmax  = 0, len(self)
        while n&lt;nmax and self.executed[n]: n+=1
        return n

    def __getitem__(self,idx):
        &#34;&#34;&#34; return the ith or slice element(s) of the pipe  &#34;&#34;&#34;
        dup = deepduplicate(self)
        if isinstance(idx,slice):
            dup.listscript = dup.listscript[idx]
            dup.listUSER = dup.listUSER[idx]
            dup.name = dup.name[idx]
            dup.executed = dup.executed[idx]
        elif isinstance(idx,int):
            if idx&lt;len(self):
                dup.listscript = dup.listscript[idx:idx+1]
                dup.listUSER = dup.listUSER[idx:idx+1]
                dup.name = dup.name[idx:idx+1]
                dup.executed = dup.executed[idx:idx+1]
            else:
                raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,list):
            dup.listscript = picker(dup.listscript,idx)
            dup.listUSER = picker(dup.listUSER,idx)
            dup.name = picker(dup.name,idx)
            dup.executed = picker(dup.executed,idx)
        else:
            raise IndexError(&#34;the index needs to be a slice or an integer&#34;)
        return dup

    def __setitem__(self,idx,s):
        &#34;&#34;&#34;
            modify the ith element of the pipe
                p[4] = [] removes the 4th element
                p[4:7] = [] removes the elements from position 4 to 6
                p[2:4] = p[0:2] copy the elements 0 and 1 in positions 2 and 3
                p[[3,4]]=p[0]
        &#34;&#34;&#34;
        if isinstance(s,(script,scriptobject,scriptobjectgroup)):
            dup = pipescript(s)
        elif isinstance(s,pipescript):
            dup = s
        elif s==[]:
            dup = []
        else:
            raise ValueError(&#34;the value must be a pipescript, script, scriptobject, scriptobjectgroup&#34;)
        if len(s)&lt;1: # remove (delete)
            if isinstance(idx,slice) or idx&lt;len(self):
                del self.listscript[idx]
                del self.listUSER[idx]
                del self.name[idx]
                del self.executed[idx]
            else:
                raise IndexError(&#34;the index must be a slice or an integer&#34;)
        elif len(s)==1: # scalar
            if isinstance(idx,int):
                if idx&lt;len(self):
                    self.listscript[idx] = dup.listscript[0]
                    self.listUSER[idx] = dup.listUSER[0]
                    self.name[idx] = dup.name[0]
                    self.executed[idx] = False
                elif idx==len(self):
                    self.listscript.append(dup.listscript[0])
                    self.listUSER.append(dup.listUSER[0])
                    self.name.append(dup.name[0])
                    self.executed.append(False)
                else:
                    raise IndexError(f&#34;the index must be ranged between 0 and {self.n}&#34;)
            elif isinstance(idx,list):
                for i in range(len(idx)):
                    self.__setitem__(idx[i], s) # call as a scalar
            elif isinstance(idx,slice):
                for i in range(*idx.indices(len(self)+1)):
                    self.__setitem__(i, s)
            else:
                raise IndexError(&#34;unrocognized index value, the index should be an integer or a slice&#34;)
        else: # many values
            if isinstance(idx,list): # list call à la Matlab
                if len(idx)==len(s):
                    for i in range(len(s)):
                        self.__setitem__(idx[i], s[i]) # call as a scalar
                else:
                    raise IndexError(f&#34;the number of indices {len(list)} does not match the number of values {len(s)}&#34;)
            elif isinstance(idx,slice):
                ilist = list(range(*idx.indices(len(self)+len(s))))
                self.__setitem__(ilist, s) # call as a list
            else:
                raise IndexError(&#34;unrocognized index value, the index should be an integer or a slice&#34;)

    def rename(self,name=&#34;&#34;,idx=None):
        &#34;&#34;&#34;
            rename scripts in the pipe
                p.rename(idx=[0,2,3],name=[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;])
        &#34;&#34;&#34;
        if isinstance(name,list):
            if len(name)==len(self) and idx==None:
                self.name = name
            elif len(name) == len(idx):
                for i in range(len(idx)):
                    self.rename(name[i],idx[i])
            else:
                IndexError(f&#34;the number of indices {len(idx)} does not match the number of names {len(name)}&#34;)
        elif idx !=None and idx&lt;len(self) and name!=&#34;&#34;:
            self.name[idx] = name
        else:
            raise ValueError(&#34;provide a non empty name and valid index&#34;)

    def clear(self,idx=None):
        if len(self)&gt;0:
            if idx==None:
                for i in range(len(self)):
                    self.clear(i)
            else:
                if isinstance(idx,(range,list)):
                    for i in idx:
                        self.clear(idx=i)
                elif isinstance(idx,int) and idx&lt;len(self):
                    self.executed[idx] = False
                else:
                    raise IndexError(f&#34;the index should be ranged between 0 and {self.n-1}&#34;)
            if not self.executed[0]:
                self.globalscript = None
                self.cmd = &#34;&#34;



    def do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        &#34;&#34;&#34;
        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        Parameters:
            idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
            printflag (bool, optional): Whether to print the script for each step. Default is True.
            verbosity (int, optional): Level of verbosity for the output.
            verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
            forced (bool, optional): If True, forces the pipeline to regenerate all scripts.

        Returns:
            str: Combined LAMMPS script for the specified pipeline steps.

            Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

            This method processes the pipeline of script objects, executing each step to generate
            a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
            or for a specified range of indices. The generated script can include comments and
            metadata based on the verbosity level.


        Method Workflow:
            - The method first checks if there are any script objects in the pipeline.
              If the pipeline is empty, it returns a message indicating that there is nothing to execute.
            - It determines the start and stop indices for the range of steps to execute.
              If idx is not provided, it defaults to executing all steps from the last executed position.
            - If a specific index or list of indices is provided, it executes only those steps.
            - The pipeline steps are executed in order, combining the scripts using the
              &gt;&gt; operator for sequential execution.
            - The generated script includes comments indicating the current run step and pipeline range,
              based on the specified verbosity level.
            - The final combined script is returned as a string.

        Example Usage:
        --------------
            &gt;&gt;&gt; p = pipescript()
            &gt;&gt;&gt; # Execute the entire pipeline
            &gt;&gt;&gt; full_script = p.do()
            &gt;&gt;&gt; # Execute steps 0 and 2 only
            &gt;&gt;&gt; partial_script = p.do([0, 2])
            &gt;&gt;&gt; # Execute step 1 with minimal verbosity
            &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

            Notes:
            - The method uses modular arithmetic to handle index wrapping, allowing
              for cyclic execution of pipeline steps.
            - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
            - The globalscript is initialized or updated with each step&#39;s script,
              and the USER definitions are accumulated across the steps.
            - The command string self.cmd is updated with the generated script for
              each step in the specified range.

            Raises:
            - None: The method does not raise exceptions directly, but an empty pipeline will
                    result in the return of &#34;# empty pipe - nothing to do&#34;.
        &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        if len(self) == 0:
            return &#34;# empty pipe - nothing to do&#34;

        # Check if not all steps are executed or if there are gaps
        not_all_executed = not all(self.executed[:self.nrun])  # Check up to the last executed step

        # Determine pipeline range
        total_steps = len(self)
        if self.globalscript is None or forced or not_all_executed:
            start = 0
            self.cmd = &#34;&#34;
        else:
            start = self.nrun
            self.cmd = self.cmd.rstrip(&#34;\n&#34;) + &#34;\n\n&#34;

        if idx is None:
            idx = range(start, total_steps)
        if isinstance(idx, int):
            idx = [idx]
        if isinstance(idx, range):
            idx = list(idx)

        idx = [i % total_steps for i in idx]
        start, stop = min(idx), max(idx)

        # Prevent re-executing already completed steps
        if not forced:
            idx = [step for step in idx if not self.executed[step]]

        # Execute pipeline steps
        for step in idx:
            step_wrapped = step % total_steps

            # Combine scripts
            if step_wrapped == 0:
                self.globalscript = self.listscript[step_wrapped]
            else:
                self.globalscript = self.globalscript &gt;&gt; self.listscript[step_wrapped]

            # Step label
            step_name = f&#34;&lt;{self.name[step]}&gt;&#34;
            step_label = f&#34;# [{step+1} of {total_steps} from {start}:{stop}] {step_name}&#34;

            # Get script content for the step
            step_output = self.globalscript.do(printflag=printflag, verbose=verbosity &gt; 1)

            # Add comments and content
            if step_output.strip():
                self.cmd += f&#34;{step_label}\n{step_output.strip()}\n\n&#34;
            elif verbosity &gt; 0:
                self.cmd += f&#34;{step_label} :: no content\n\n&#34;

            # Update USER definitions
            self.globalscript.USER += self.listUSER[step]
            self.executed[step] = True

        # Clean up and finalize script
        self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;).strip()  # Remove literal \\n and extra spaces
        self.cmd += &#34;\n&#34;  # Ensure trailing newline
        return remove_comments(self.cmd) if verbosity == 0 else self.cmd


    def do_legacy(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        &#34;&#34;&#34;
        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        This method processes the pipeline of script objects, executing each step to generate
        a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
        or for a specified range of indices. The generated script can include comments and
        metadata based on the verbosity level.

        Parameters:
        - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                               If None, all steps from the current position to
                                               the end are executed. A list of indices can be
                                               provided to execute specific steps, or a single
                                               integer can be passed to execute a specific step.
                                               Default is None.
        - printflag (bool, optional): If True, the generated script for each step is printed
                                      to the console. Default is True.
        - verbosity (int, optional): Controls the level of detail in the generated script.
                                     - 0: Minimal output, no comments.
                                     - 1: Basic comments for run steps.
                                     - 2: Detailed comments with additional information.
                                     Default is 2.
        - forced (bool, optional): If True, all scripts are regenerated

        Returns:
        - str: The combined LAMMPS script generated from the specified steps of the pipeline.

        Method Workflow:
        - The method first checks if there are any script objects in the pipeline.
          If the pipeline is empty, it returns a message indicating that there is nothing to execute.
        - It determines the start and stop indices for the range of steps to execute.
          If idx is not provided, it defaults to executing all steps from the last executed position.
        - If a specific index or list of indices is provided, it executes only those steps.
        - The pipeline steps are executed in order, combining the scripts using the
          &gt;&gt; operator for sequential execution.
        - The generated script includes comments indicating the current run step and pipeline range,
          based on the specified verbosity level.
        - The final combined script is returned as a string.

        Example Usage:
        --------------
        &gt;&gt;&gt; p = pipescript()
        &gt;&gt;&gt; # Execute the entire pipeline
        &gt;&gt;&gt; full_script = p.do()
        &gt;&gt;&gt; # Execute steps 0 and 2 only
        &gt;&gt;&gt; partial_script = p.do([0, 2])
        &gt;&gt;&gt; # Execute step 1 with minimal verbosity
        &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

        Notes:
        - The method uses modular arithmetic to handle index wrapping, allowing
          for cyclic execution of pipeline steps.
        - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
        - The globalscript is initialized or updated with each step&#39;s script,
          and the USER definitions are accumulated across the steps.
        - The command string self.cmd is updated with the generated script for
          each step in the specified range.

        Raises:
        - None: The method does not raise exceptions directly, but an empty pipeline will
                result in the return of &#34;# empty pipe - nothing to do&#34;.
        &#34;&#34;&#34;

        verbosity = 0 if verbose is False else verbosity
        if len(self)&gt;0:
            # ranges
            ntot = len(self)
            stop = ntot-1
            if (self.globalscript == None) or (self.globalscript == []) or not self.executed[0] or forced:
                start = 0
                self.cmd = &#34;&#34;
            else:
                start = self.nrun
            if start&gt;stop: return self.cmd
            if idx is None: idx = range(start,stop+1)
            if isinstance(idx,range): idx = list(idx)
            if isinstance(idx,int): idx = [idx]
            start,stop = min(idx),max(idx)
            # do
            for i in idx:
                j = i % ntot
                if j==0:
                    self.globalscript = self.listscript[j]
                else:
                    self.globalscript = self.globalscript &gt;&gt; self.listscript[j]
                name = &#34;  &#34;+self.name[i]+&#34;  &#34;
                if verbosity&gt;0:
                    self.cmd += &#34;\n\n#\t --- run step [%d/%d] --- [%s]  %20s\n&#34; % \
                            (j,ntot-1,name.center(50,&#34;=&#34;),&#34;pipeline [%d]--&gt;[%d]&#34; %(start,stop))
                else:
                    self.cmd +=&#34;\n&#34;
                self.globalscript.USER = self.globalscript.USER + self.listUSER[j]
                self.cmd += self.globalscript.do(printflag=printflag,verbose=verbosity&gt;1)
                self.executed[i] = True
            self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;) # remove literal \\n if any (dscript.save add \\n)
            return remove_comments(self.cmd) if verbosity==0 else self.cmd
        else:
            return &#34;# empty pipe - nothing to do&#34;


    def script(self,idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4):
        &#34;&#34;&#34;
            script the pipeline or parts of the pipeline
                s = p.script()
                s = p.script([0,2])

        Parameters:
        - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                               If None, all steps from the current position to
                                               the end are executed. A list of indices can be
                                               provided to execute specific steps, or a single
                                               integer can be passed to execute a specific step.
                                               Default is None.
        - printflag (bool, optional): If True, the generated script for each step is printed
                                      to the console. Default is True.
        - verbosity (int, optional): Controls the level of detail in the generated script.
                                     - 0: Minimal output, no comments.
                                     - 1: Basic comments for run steps.
                                     - 2: Detailed comments with additional information.
                                     Default is 2.
        - forced (bool, optional): If True, all scripts are regenerated
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with `╔`, `═`, and `║`
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with `┌`, `─`, and `│`
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `4` (thick outer frame).

        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity=0 if verbose is False else verbosity
        s = script(printflag=printflag, verbose=verbosity&gt;0)
        s.name = &#34;pipescript&#34;
        s.description = &#34;pipeline with %d scripts&#34; % len(self)
        if len(self)&gt;1:
            s.userid = self.name[0]+&#34;-&gt;&#34;+self.name[-1]
        elif len(self)==1:
            s.userid = self.name[0]
        else:
            s.userid = &#34;empty pipeline&#34;
        s.TEMPLATE = self.header(verbosity=verbosity, style=style) + &#34;\n&#34; +\
            self.do(idx, printflag=printflag, verbosity=verbosity, verbose=verbose, forced=forced)
        s.DEFINITIONS = duplicate(self.globalscript.DEFINITIONS)
        s.USER = duplicate(self.globalscript.USER)
        return s

    @staticmethod
    def join(liste):
        &#34;&#34;&#34;
            join a combination scripts and pipescripts within a pipescript
                p = pipescript.join([s1,s2,p3,p4,p5...])
        &#34;&#34;&#34;
        if not isinstance(liste,list):
            raise ValueError(&#34;the argument should be a list&#34;)
        ok = True
        for i in range(len(liste)):
            ok = ok and isinstance(liste[i],(script,pipescript))
            if not ok:
                raise ValueError(f&#34;the entry [{i}] should be a script or pipescript&#34;)
        if len(liste)&lt;1:
            return liste
        out = liste[0]
        for i in range(1,len(liste)):
            out = out | liste[i]
        return out

    # Note that it was not the original intent to copy pipescripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo))
        return copie

    # write file
    def write(self, file, printflag=False, verbosity=2, verbose=None, overwrite=False):
       &#34;&#34;&#34;
       Write the combined script to a file.

       Parameters:
           file (str): The file path where the script will be saved.
           printflag (bool): Flag to enable/disable printing of details.
           verbosity (int): Level of verbosity for the script generation.
           verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance&#39;s verbosity.
           overwrite (bool): Whether to overwrite the file if it already exists. Default is False.

        Returns:
            str: The full absolute path of the file written.

       Raises:
           FileExistsError: If the file already exists and overwrite is False.

       Notes:
           - This method combines the individual scripts within the `pipescript` object
             and saves the resulting script to the specified file.
           - If `overwrite` is False and the file exists, an error is raised.
           - If `verbose` is True and the file is overwritten, a warning is displayed.
       &#34;&#34;&#34;
       # Generate the combined script
       myscript = self.script(printflag=printflag, verbosity=verbosity, verbose=verbose, forced=True)
       # Call the script&#39;s write method with the overwrite parameter
       return myscript.write(file, printflag=printflag, verbose=verbose, overwrite=overwrite)


    def dscript(self, name=None, printflag=None, verbose=None, verbosity=None, clean=&#34;fixing&#34;, **USER):
        &#34;&#34;&#34;
        Convert the current pipescript object to a dscript object.

        This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
        in the pipescript into a single dynamic script per step in the dscript.
        Each step in the pipescript is transformed into a dynamic script in the dscript,
        where variable spaces are combined using the following order:

        1. STATIC: Definitions specific to each script in the pipescript.
        2. GLOBAL: User variables shared across steps from a specific point onwards.
        3. LOCAL: User variables for each individual step.

        Parameters:
        -----------
        verbose : bool, optional
            Controls verbosity of the dynamic scripts in the resulting dscript object.
            If None, the verbosity setting of the pipescript will be used.

        clean : &#34;fixing&#34; or &#34;removing&#34;
            - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
            - &#39;fixing&#39;: Replace the content of the empty step with a comment.

        **USER : scriptobjectdata(), optional
            Additional user-defined variables that can override existing static variables
            in the dscript object or be added to it.

        Returns:
        --------
        outd : dscript
            A dscript object that contains all steps of the pipescript as dynamic scripts.
            Each step from the pipescript is added as a dynamic script with the same content
            and combined variable spaces.
        &#34;&#34;&#34;
        # Local imports
        from pizza.dscript import dscript, ScriptTemplate, lambdaScriptdata

        # verbosity
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity

        # Adjust name
        if name is None:
            if isinstance(self.name, str):
                name = self.name
            elif isinstance(self.name, list):
                name = (
                    self.name[0] if len(self.name) == 1 else self.name[0] + &#34;...&#34; + self.name[-1]
                )

        # Create the dscript container with the pipescript name as the userid
        outd = dscript(userid=name, verbose=self.verbose, **USER)

        # Initialize static merged definitions
        staticmerged_definitions = lambdaScriptdata()

        # Track used variables per step
        step_used_variables = []

        # Loop over each step in the pipescript
        for i, script in enumerate(self.listscript):
            # Merge STATIC, GLOBAL, and LOCAL variables for the current step
            static_vars = self.listUSER[i] # script.DEFINITIONS
            global_vars = script.DEFINITIONS # self.scripts[i].USER
            local_vars = script.USER # self.USER[i]
            refreshed_globalvars = static_vars + global_vars

            # Detect variables used in the current template
            used_variables = set(script.detect_variables())
            step_used_variables.append(used_variables)  # Track used variables for this step

            # Copy all current variables to local_static_updates and remove matching variables from staticmerged_definitions
            local_static_updates = lambdaScriptdata(**local_vars)

            for var, value in refreshed_globalvars.items():
                if var in staticmerged_definitions:
                    if (getattr(staticmerged_definitions, var) != value) and (var not in local_vars):
                        setattr(local_static_updates, var, value)
                else:
                    setattr(staticmerged_definitions, var, value)

           # Create the dynamic script for this step using the method in dscript
            key_name = i  # Use the index &#39;i&#39; as the key in TEMPLATE
            content = script.TEMPLATE

            # Use the helper method in dscript to add this dynamic script
            outd.add_dynamic_script(
                key=key_name,
                content=content,
                definitions = lambdaScriptdata(**local_static_updates),
                verbose=self.verbose if verbose is None else verbose,
                userid=self.name[i],
                autorefresh=False # prevent the replacement by default values ${}
            )

            # Set eval=True only if variables are detected in the template
            if outd.TEMPLATE[key_name].detect_variables():
                outd.TEMPLATE[key_name].eval = True

        # Compute the union of all used variables across all steps
        global_used_variables = set().union(*step_used_variables)

        # Filter staticmerged_definitions to keep only variables that are used
        filtered_definitions = {
            var: value for var, value in staticmerged_definitions.items() if var in global_used_variables
        }

        # Assign the filtered definitions along with USER variables to outd.DEFINITIONS
        outd.DEFINITIONS = lambdaScriptdata(**filtered_definitions)

        # Clean the entries for empty templates
        outd.clean(verbose=verbose,behavior=clean)

        return outd



    def header(self, verbose=True,verbosity=None, style=4):
        &#34;&#34;&#34;
        Generate a formatted header for the pipescript file.

        Parameters:
            verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                        Defaults to the instance&#39;s `verbose`.
            style (int from 1 to 6, optional): ASCII style to frame the header (default=4)

        Returns:
            str: A formatted string representing the pipescript object.
                 Returns an empty string if verbosity is False.

        The header includes:
            - Total number of scripts in the pipeline.
            - The verbosity setting.
            - The range of scripts from the first to the last script.
            - All enclosed within an ASCII frame that adjusts to the content.
        &#34;&#34;&#34;
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        if not verbosity:
            return &#34;&#34;

        # Prepare the header content
        lines = [
            f&#34;PIPESCRIPT with {self.n} scripts | Verbosity: {verbosity}&#34;,
            &#34;&#34;,
            f&#34;From: &lt;{str(self.scripts[0])}&gt; To: &lt;{str(self.scripts[-1])}&gt;&#34;,
        ]

        # Use the shared method to format the header
        return frame_header(lines,style=style)



    def list_values(self, varname=None, what=&#34;all&#34;):
        &#34;&#34;&#34;
        Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.

        Parameters:
        - varname (str, optional): The name of the variable to search for. If None, all variables are listed.
        - what (str or list/tuple, optional): Specifies the scopes to search in.
                                             Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                             or a list/tuple of any combination of these.

        Returns:
        - VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
        - dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.
        &#34;&#34;&#34;
        # Normalize &#39;what&#39; to a list for uniform processing
        if isinstance(what, str):
            if what.lower() == &#34;all&#34;:
                scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
            else:
                scopes = [what.lower()]
        elif isinstance(what, (list, tuple)):
            scopes_lower = [s.lower() for s in what]
            if &#39;all&#39; in scopes_lower:
                scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
            else:
                scopes = scopes_lower
        else:
            raise ValueError(&#34;Parameter &#39;what&#39; must be a string or a list/tuple of strings.&#34;)

        # Initialize data structures
        if varname:
            # Single variable case
            if len(scopes) == 1:
                data = []
            else:
                data = {}
                for scope in scopes:
                    data[scope] = []

            # Iterate over each script in the pipeline
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                # Check each requested scope
                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    if varname in vars_dict.keys():
                        value = getattr(vars_dict,varname)
                        if len(scopes) == 1:
                            data.append((i, value))
                        else:
                            data[scope].append((i, value))

            # Return a VariableOccurrences instance for the specified variable
            return VariableOccurrences(data, variables=varname)

        else:
            # All variables case
            all_vars = set()

            # First, collect all variable names across specified scopes and scripts
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    all_vars.update(vars_dict.keys())

            # Initialize a dictionary to hold VariableOccurrences for each variable
            variables_data = {}
            for var in all_vars:
                var_data = {}
                for scope in scopes:
                    var_data[scope] = []
                variables_data[var] = var_data

            # Iterate again to populate the data for each variable
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    for var, value in vars_dict.items():
                        variables_data[var][scope].append((i, value))

            # Convert each variable&#39;s data into a VariableOccurrences instance
            variables_occurrences = {}
            for var, data in variables_data.items():
                variables_occurrences[var] = VariableOccurrences(data, variables=var)

            return variables_occurrences



    def list_multiple_values(self, varnames, what=&#34;all&#34;):
        &#34;&#34;&#34;
        Lists all occurrences and values of multiple variables across the pipeline scripts.

        Parameters:
        - varnames (list): A list of variable names to search for.
        - what (str or list/tuple): Specifies the scopes to search in.
                                     Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                     or a list/tuple of any combination of these.

        Returns:
        - dict: A dictionary mapping each variable name to its VariableOccurrences object.
        &#34;&#34;&#34;
        if not isinstance(varnames, (list, tuple)):
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

        return self.list_values(varname=varnames, what=what)



    def plot_multiple_value_distributions(self, varnames, what=&#34;all&#34;, separate_plots=True):
        &#34;&#34;&#34;
        Plots the distribution of elements for multiple variables across specified scopes.

        Parameters:
        - varnames (list): A list of variable names to plot.
        - what (str or list/tuple): Specifies the scopes to include in the plot.
                                     Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                     or a list/tuple of any combination of these.
        - separate_plots (bool): If True, plots each variable in a separate subplot.
                                 If False, combines all variables in a single plot for comparison.
        &#34;&#34;&#34;
        if not isinstance(varnames, (list, tuple)):
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

        # Retrieve VariableOccurrences instances
        multiple_vars = self.list_multiple_values(varnames, what=what)

        if separate_plots:
            num_vars = len(multiple_vars)
            fig, axes = plt.subplots(num_vars, 1, figsize=(10, 5 * num_vars))
            if num_vars == 1:
                axes = [axes]  # Make it iterable

            for ax, (var, vo) in zip(axes, multiple_vars.items()):
                summary = vo.summarize()[var]
                for scope, details in summary.items():
                    elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                    counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                    ax.bar(elements, counts, label=scope)
                ax.set_xlabel(&#39;Element&#39;)
                ax.set_ylabel(&#39;Count&#39;)
                ax.set_title(f&#34;Distribution of elements in &#39;{var}&#39;&#34;)
                ax.legend()

            plt.tight_layout()
            plt.show()

        else:
            plt.figure(figsize=(12, 8))
            for var, vo in multiple_vars.items():
                summary = vo.summarize()[var]
                for scope, details in summary.items():
                    elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                    counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                    plt.bar([f&#34;{var}_{elem}&#34; for elem in elements], counts, label=f&#34;{var} - {scope}&#34;)

            plt.xlabel(&#39;Element&#39;)
            plt.ylabel(&#39;Count&#39;)
            plt.title(&#34;Distribution of elements in multiple variables&#34;)
            plt.legend()
            plt.xticks(rotation=45, ha=&#39;right&#39;)
            plt.tight_layout()
            plt.show()


    def generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
        &#34;&#34;&#34;
        Generates a comprehensive report for specified variables and writes it to a file.

        Parameters:
        - filename (str): Path to the output report file. Must end with .md, .txt, or .html.
        - varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to &#39;all&#39;.
        - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.

        Raises:
        - ValueError: If &#39;filename&#39; has an unsupported extension.
        - Exception: For other unforeseen errors.
        &#34;&#34;&#34;
        # Validate filename extension
        _, ext = os.path.splitext(filename)
        ext = ext.lower()

        if ext not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;]:
            raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

        # Determine format based on extension
        if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
            export_format = &#39;markdown&#39;
        elif ext == &#39;.html&#39;:
            export_format = &#39;html&#39;

        # Determine variables to include
        if varnames is None or (isinstance(varnames, (list, tuple)) and len(varnames) == 0):
            variables = &#39;all&#39;
        else:
            variables = varnames  # Can be a string or a list/tuple

        # Retrieve VariableOccurrences instances
        if variables == &#39;all&#39;:
            variables_occurrences = self.list_values(varname=None, what=scopes)
        else:
            # Normalize varnames to a list
            if isinstance(variables, str):
                variables = [variables]
            elif isinstance(variables, (list, tuple)):
                variables = list(variables)
            else:
                raise ValueError(&#34;Parameter &#39;varnames&#39; must be a string or a list/tuple of strings.&#34;)

            variables_occurrences = {}
            for var in variables:
                vo = self.list_values(varname=var, what=scopes)
                if vo and var in vo.variables:
                    variables_occurrences[var] = vo
                else:
                    print(f&#34;Warning: Variable &#39;{var}&#39; not found in the specified scopes.&#34;)

        # Initialize report content
        report_content = &#34;&#34;
        timestamp = datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        caller = &#34;generate_report&#34;

        # Add report header
        if export_format == &#39;markdown&#39;:
            report_content += f&#34;# Comprehensive Variable Report\n\n&#34;
            report_content += f&#34;**Generated on {timestamp} by {caller}**\n\n&#34;
        elif export_format == &#39;html&#39;:
            # Define CSS for HTML
            css = &#34;&#34;&#34;
            &lt;style&gt;
                body {
                    font-family: Arial, sans-serif;
                    margin: 20px;
                }
                h1, h2, h3, h4, h5 {
                    color: #333;
                }
                table {
                    border-collapse: collapse;
                    width: 100%;
                    margin-bottom: 40px;
                }
                th, td {
                    border: 1px solid #ddd;
                    padding: 8px;
                    text-align: left;
                }
                th {
                    background-color: #4CAF50;
                    color: white;
                }
                tr:nth-child(even){background-color: #f2f2f2;}
                tr:hover {background-color: #ddd;}
            &lt;/style&gt;
            &#34;&#34;&#34;
            report_content += f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Comprehensive Variable Report&lt;/title&gt;\n{css}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;
            report_content += f&#34;&lt;h1&gt;Comprehensive Variable Report&lt;/h1&gt;\n&#34;
            report_content += f&#34;&lt;h2&gt;Generated on {timestamp} by {caller}&lt;/h2&gt;\n&#34;

        # Assemble report content using VariableOccurrences.export()
        for var, vo in variables_occurrences.items():
            # Export content without headers and get as string
            var_content = vo.export(filename=filename, # use to identify the format based on its extension
                                    scopes=scopes,
                                    variables=var,
                                    include_headers=False,
                                    return_content=True)

            if export_format == &#39;markdown&#39;:
                # Add variable header
                report_content += f&#34;## Variable: `{var}`\n\n&#34;
                report_content += var_content + &#34;\n\n&#34;
                report_content += &#34;---\n\n&#34;  # Horizontal line between variables
            elif export_format == &#39;html&#39;:
                # Add variable header
                report_content += f&#34;&lt;h2&gt;Variable: {var}&lt;/h2&gt;\n&#34;
                report_content += var_content + &#34;\n&lt;hr/&gt;\n&#34;  # Horizontal line between variables

        # Finalize HTML content
        if export_format == &#39;html&#39;:
            report_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

        # Write report to file
        try:
            with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                file.write(report_content)
            print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
        except Exception as e:
            raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="region.pipescript.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>liste)</span>
</code></dt>
<dd>
<div class="desc"><p>join a combination scripts and pipescripts within a pipescript
p = pipescript.join([s1,s2,p3,p4,p5&hellip;])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def join(liste):
    &#34;&#34;&#34;
        join a combination scripts and pipescripts within a pipescript
            p = pipescript.join([s1,s2,p3,p4,p5...])
    &#34;&#34;&#34;
    if not isinstance(liste,list):
        raise ValueError(&#34;the argument should be a list&#34;)
    ok = True
    for i in range(len(liste)):
        ok = ok and isinstance(liste[i],(script,pipescript))
        if not ok:
            raise ValueError(f&#34;the entry [{i}] should be a script or pipescript&#34;)
    if len(liste)&lt;1:
        return liste
    out = liste[0]
    for i in range(1,len(liste)):
        out = out | liste[i]
    return out</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="region.pipescript.USER"><code class="name">var <span class="ident">USER</span></code></dt>
<dd>
<div class="desc"><p>p.USER[idx].var returns the value of the USER variable var
p.USER[idx].var = val assigns the value val to the USER variable var</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def USER(self):
    &#34;&#34;&#34;
        p.USER[idx].var returns the value of the USER variable var
        p.USER[idx].var = val assigns the value val to the USER variable var
    &#34;&#34;&#34;
    return self.listUSER  # override listuser</code></pre>
</details>
</dd>
<dt id="region.pipescript.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>number of scripts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34; number of scripts &#34;&#34;&#34;
    return len(self)</code></pre>
</details>
</dd>
<dt id="region.pipescript.nrun"><code class="name">var <span class="ident">nrun</span></code></dt>
<dd>
<div class="desc"><p>number of scripts executed continuously from origin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nrun(self):
    &#34;&#34;&#34; number of scripts executed continuously from origin &#34;&#34;&#34;
    n, nmax  = 0, len(self)
    while n&lt;nmax and self.executed[n]: n+=1
    return n</code></pre>
</details>
</dd>
<dt id="region.pipescript.scripts"><code class="name">var <span class="ident">scripts</span></code></dt>
<dd>
<div class="desc"><p>p.scripts[idx].USER.var returns the value of the USER variable var
p.scripts[idx].USER.var = val assigns the value val to the USER variable var</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scripts(self):
    &#34;&#34;&#34;
        p.scripts[idx].USER.var returns the value of the USER variable var
        p.scripts[idx].USER.var = val assigns the value val to the USER variable var
    &#34;&#34;&#34;
    return self.listscript # override listuser</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.pipescript.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, idx=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self,idx=None):
    if len(self)&gt;0:
        if idx==None:
            for i in range(len(self)):
                self.clear(i)
        else:
            if isinstance(idx,(range,list)):
                for i in idx:
                    self.clear(idx=i)
            elif isinstance(idx,int) and idx&lt;len(self):
                self.executed[idx] = False
            else:
                raise IndexError(f&#34;the index should be ranged between 0 and {self.n-1}&#34;)
        if not self.executed[0]:
            self.globalscript = None
            self.cmd = &#34;&#34;</code></pre>
</details>
</dd>
<dt id="region.pipescript.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<h2 id="parameters">Parameters</h2>
<p>idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
printflag (bool, optional): Whether to print the script for each step. Default is True.
verbosity (int, optional): Level of verbosity for the output.
verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
forced (bool, optional): If True, forces the pipeline to regenerate all scripts.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Combined LAMMPS script for the specified pipeline steps.</dd>
</dl>
<p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<p>This method processes the pipeline of script objects, executing each step to generate
a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
or for a specified range of indices. The generated script can include comments and
metadata based on the verbosity level.
Method Workflow:
- The method first checks if there are any script objects in the pipeline.
If the pipeline is empty, it returns a message indicating that there is nothing to execute.
- It determines the start and stop indices for the range of steps to execute.
If idx is not provided, it defaults to executing all steps from the last executed position.
- If a specific index or list of indices is provided, it executes only those steps.
- The pipeline steps are executed in order, combining the scripts using the
&gt;&gt; operator for sequential execution.
- The generated script includes comments indicating the current run step and pipeline range,
based on the specified verbosity level.
- The final combined script is returned as a string.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>&gt;&gt;&gt; p = pipescript()
&gt;&gt;&gt; # Execute the entire pipeline
&gt;&gt;&gt; full_script = p.do()
&gt;&gt;&gt; # Execute steps 0 and 2 only
&gt;&gt;&gt; partial_script = p.do([0, 2])
&gt;&gt;&gt; # Execute step 1 with minimal verbosity
&gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

Notes:
- The method uses modular arithmetic to handle index wrapping, allowing
  for cyclic execution of pipeline steps.
- If the pipeline is empty, the method returns the string "# empty pipe - nothing to do".
- The globalscript is initialized or updated with each step's script,
  and the USER definitions are accumulated across the steps.
- The command string self.cmd is updated with the generated script for
  each step in the specified range.

Raises:
- None: The method does not raise exceptions directly, but an empty pipeline will
        result in the return of "# empty pipe - nothing to do".
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
    &#34;&#34;&#34;
    Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

    Parameters:
        idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
        printflag (bool, optional): Whether to print the script for each step. Default is True.
        verbosity (int, optional): Level of verbosity for the output.
        verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
        forced (bool, optional): If True, forces the pipeline to regenerate all scripts.

    Returns:
        str: Combined LAMMPS script for the specified pipeline steps.

        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        This method processes the pipeline of script objects, executing each step to generate
        a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
        or for a specified range of indices. The generated script can include comments and
        metadata based on the verbosity level.


    Method Workflow:
        - The method first checks if there are any script objects in the pipeline.
          If the pipeline is empty, it returns a message indicating that there is nothing to execute.
        - It determines the start and stop indices for the range of steps to execute.
          If idx is not provided, it defaults to executing all steps from the last executed position.
        - If a specific index or list of indices is provided, it executes only those steps.
        - The pipeline steps are executed in order, combining the scripts using the
          &gt;&gt; operator for sequential execution.
        - The generated script includes comments indicating the current run step and pipeline range,
          based on the specified verbosity level.
        - The final combined script is returned as a string.

    Example Usage:
    --------------
        &gt;&gt;&gt; p = pipescript()
        &gt;&gt;&gt; # Execute the entire pipeline
        &gt;&gt;&gt; full_script = p.do()
        &gt;&gt;&gt; # Execute steps 0 and 2 only
        &gt;&gt;&gt; partial_script = p.do([0, 2])
        &gt;&gt;&gt; # Execute step 1 with minimal verbosity
        &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

        Notes:
        - The method uses modular arithmetic to handle index wrapping, allowing
          for cyclic execution of pipeline steps.
        - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
        - The globalscript is initialized or updated with each step&#39;s script,
          and the USER definitions are accumulated across the steps.
        - The command string self.cmd is updated with the generated script for
          each step in the specified range.

        Raises:
        - None: The method does not raise exceptions directly, but an empty pipeline will
                result in the return of &#34;# empty pipe - nothing to do&#34;.
    &#34;&#34;&#34;
    verbosity = 0 if verbose is False else verbosity
    if len(self) == 0:
        return &#34;# empty pipe - nothing to do&#34;

    # Check if not all steps are executed or if there are gaps
    not_all_executed = not all(self.executed[:self.nrun])  # Check up to the last executed step

    # Determine pipeline range
    total_steps = len(self)
    if self.globalscript is None or forced or not_all_executed:
        start = 0
        self.cmd = &#34;&#34;
    else:
        start = self.nrun
        self.cmd = self.cmd.rstrip(&#34;\n&#34;) + &#34;\n\n&#34;

    if idx is None:
        idx = range(start, total_steps)
    if isinstance(idx, int):
        idx = [idx]
    if isinstance(idx, range):
        idx = list(idx)

    idx = [i % total_steps for i in idx]
    start, stop = min(idx), max(idx)

    # Prevent re-executing already completed steps
    if not forced:
        idx = [step for step in idx if not self.executed[step]]

    # Execute pipeline steps
    for step in idx:
        step_wrapped = step % total_steps

        # Combine scripts
        if step_wrapped == 0:
            self.globalscript = self.listscript[step_wrapped]
        else:
            self.globalscript = self.globalscript &gt;&gt; self.listscript[step_wrapped]

        # Step label
        step_name = f&#34;&lt;{self.name[step]}&gt;&#34;
        step_label = f&#34;# [{step+1} of {total_steps} from {start}:{stop}] {step_name}&#34;

        # Get script content for the step
        step_output = self.globalscript.do(printflag=printflag, verbose=verbosity &gt; 1)

        # Add comments and content
        if step_output.strip():
            self.cmd += f&#34;{step_label}\n{step_output.strip()}\n\n&#34;
        elif verbosity &gt; 0:
            self.cmd += f&#34;{step_label} :: no content\n\n&#34;

        # Update USER definitions
        self.globalscript.USER += self.listUSER[step]
        self.executed[step] = True

    # Clean up and finalize script
    self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;).strip()  # Remove literal \\n and extra spaces
    self.cmd += &#34;\n&#34;  # Ensure trailing newline
    return remove_comments(self.cmd) if verbosity == 0 else self.cmd</code></pre>
</details>
</dd>
<dt id="region.pipescript.do_legacy"><code class="name flex">
<span>def <span class="ident">do_legacy</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<p>This method processes the pipeline of script objects, executing each step to generate
a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
or for a specified range of indices. The generated script can include comments and
metadata based on the verbosity level.</p>
<p>Parameters:
- idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
If None, all steps from the current position to
the end are executed. A list of indices can be
provided to execute specific steps, or a single
integer can be passed to execute a specific step.
Default is None.
- printflag (bool, optional): If True, the generated script for each step is printed
to the console. Default is True.
- verbosity (int, optional): Controls the level of detail in the generated script.
- 0: Minimal output, no comments.
- 1: Basic comments for run steps.
- 2: Detailed comments with additional information.
Default is 2.
- forced (bool, optional): If True, all scripts are regenerated</p>
<p>Returns:
- str: The combined LAMMPS script generated from the specified steps of the pipeline.</p>
<p>Method Workflow:
- The method first checks if there are any script objects in the pipeline.
If the pipeline is empty, it returns a message indicating that there is nothing to execute.
- It determines the start and stop indices for the range of steps to execute.
If idx is not provided, it defaults to executing all steps from the last executed position.
- If a specific index or list of indices is provided, it executes only those steps.
- The pipeline steps are executed in order, combining the scripts using the</p>
<blockquote>
<blockquote>
<p>operator for sequential execution.
- The generated script includes comments indicating the current run step and pipeline range,
based on the specified verbosity level.
- The final combined script is returned as a string.</p>
</blockquote>
</blockquote>
<h2 id="example-usage">Example Usage:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = pipescript()
&gt;&gt;&gt; # Execute the entire pipeline
&gt;&gt;&gt; full_script = p.do()
&gt;&gt;&gt; # Execute steps 0 and 2 only
&gt;&gt;&gt; partial_script = p.do([0, 2])
&gt;&gt;&gt; # Execute step 1 with minimal verbosity
&gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)
</code></pre>
<p>Notes:
- The method uses modular arithmetic to handle index wrapping, allowing
for cyclic execution of pipeline steps.
- If the pipeline is empty, the method returns the string "# empty pipe - nothing to do".
- The globalscript is initialized or updated with each step's script,
and the USER definitions are accumulated across the steps.
- The command string self.cmd is updated with the generated script for
each step in the specified range.</p>
<p>Raises:
- None: The method does not raise exceptions directly, but an empty pipeline will
result in the return of "# empty pipe - nothing to do".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_legacy(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
    &#34;&#34;&#34;
    Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

    This method processes the pipeline of script objects, executing each step to generate
    a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
    or for a specified range of indices. The generated script can include comments and
    metadata based on the verbosity level.

    Parameters:
    - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                           If None, all steps from the current position to
                                           the end are executed. A list of indices can be
                                           provided to execute specific steps, or a single
                                           integer can be passed to execute a specific step.
                                           Default is None.
    - printflag (bool, optional): If True, the generated script for each step is printed
                                  to the console. Default is True.
    - verbosity (int, optional): Controls the level of detail in the generated script.
                                 - 0: Minimal output, no comments.
                                 - 1: Basic comments for run steps.
                                 - 2: Detailed comments with additional information.
                                 Default is 2.
    - forced (bool, optional): If True, all scripts are regenerated

    Returns:
    - str: The combined LAMMPS script generated from the specified steps of the pipeline.

    Method Workflow:
    - The method first checks if there are any script objects in the pipeline.
      If the pipeline is empty, it returns a message indicating that there is nothing to execute.
    - It determines the start and stop indices for the range of steps to execute.
      If idx is not provided, it defaults to executing all steps from the last executed position.
    - If a specific index or list of indices is provided, it executes only those steps.
    - The pipeline steps are executed in order, combining the scripts using the
      &gt;&gt; operator for sequential execution.
    - The generated script includes comments indicating the current run step and pipeline range,
      based on the specified verbosity level.
    - The final combined script is returned as a string.

    Example Usage:
    --------------
    &gt;&gt;&gt; p = pipescript()
    &gt;&gt;&gt; # Execute the entire pipeline
    &gt;&gt;&gt; full_script = p.do()
    &gt;&gt;&gt; # Execute steps 0 and 2 only
    &gt;&gt;&gt; partial_script = p.do([0, 2])
    &gt;&gt;&gt; # Execute step 1 with minimal verbosity
    &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

    Notes:
    - The method uses modular arithmetic to handle index wrapping, allowing
      for cyclic execution of pipeline steps.
    - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
    - The globalscript is initialized or updated with each step&#39;s script,
      and the USER definitions are accumulated across the steps.
    - The command string self.cmd is updated with the generated script for
      each step in the specified range.

    Raises:
    - None: The method does not raise exceptions directly, but an empty pipeline will
            result in the return of &#34;# empty pipe - nothing to do&#34;.
    &#34;&#34;&#34;

    verbosity = 0 if verbose is False else verbosity
    if len(self)&gt;0:
        # ranges
        ntot = len(self)
        stop = ntot-1
        if (self.globalscript == None) or (self.globalscript == []) or not self.executed[0] or forced:
            start = 0
            self.cmd = &#34;&#34;
        else:
            start = self.nrun
        if start&gt;stop: return self.cmd
        if idx is None: idx = range(start,stop+1)
        if isinstance(idx,range): idx = list(idx)
        if isinstance(idx,int): idx = [idx]
        start,stop = min(idx),max(idx)
        # do
        for i in idx:
            j = i % ntot
            if j==0:
                self.globalscript = self.listscript[j]
            else:
                self.globalscript = self.globalscript &gt;&gt; self.listscript[j]
            name = &#34;  &#34;+self.name[i]+&#34;  &#34;
            if verbosity&gt;0:
                self.cmd += &#34;\n\n#\t --- run step [%d/%d] --- [%s]  %20s\n&#34; % \
                        (j,ntot-1,name.center(50,&#34;=&#34;),&#34;pipeline [%d]--&gt;[%d]&#34; %(start,stop))
            else:
                self.cmd +=&#34;\n&#34;
            self.globalscript.USER = self.globalscript.USER + self.listUSER[j]
            self.cmd += self.globalscript.do(printflag=printflag,verbose=verbosity&gt;1)
            self.executed[i] = True
        self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;) # remove literal \\n if any (dscript.save add \\n)
        return remove_comments(self.cmd) if verbosity==0 else self.cmd
    else:
        return &#34;# empty pipe - nothing to do&#34;</code></pre>
</details>
</dd>
<dt id="region.pipescript.dscript"><code class="name flex">
<span>def <span class="ident">dscript</span></span>(<span>self, name=None, printflag=None, verbose=None, verbosity=None, clean='fixing', **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the current pipescript object to a dscript object.</p>
<p>This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
in the pipescript into a single dynamic script per step in the dscript.
Each step in the pipescript is transformed into a dynamic script in the dscript,
where variable spaces are combined using the following order:</p>
<ol>
<li>STATIC: Definitions specific to each script in the pipescript.</li>
<li>GLOBAL: User variables shared across steps from a specific point onwards.</li>
<li>LOCAL: User variables for each individual step.</li>
</ol>
<h2 id="parameters">Parameters:</h2>
<p>verbose : bool, optional
Controls verbosity of the dynamic scripts in the resulting dscript object.
If None, the verbosity setting of the pipescript will be used.</p>
<p>clean : "fixing" or "removing"
- 'removing': Completely remove the empty step from TEMPLATE.
- 'fixing': Replace the content of the empty step with a comment.</p>
<p>**USER : scriptobjectdata(), optional
Additional user-defined variables that can override existing static variables
in the dscript object or be added to it.</p>
<h2 id="returns">Returns:</h2>
<p>outd : dscript
A dscript object that contains all steps of the pipescript as dynamic scripts.
Each step from the pipescript is added as a dynamic script with the same content
and combined variable spaces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dscript(self, name=None, printflag=None, verbose=None, verbosity=None, clean=&#34;fixing&#34;, **USER):
    &#34;&#34;&#34;
    Convert the current pipescript object to a dscript object.

    This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
    in the pipescript into a single dynamic script per step in the dscript.
    Each step in the pipescript is transformed into a dynamic script in the dscript,
    where variable spaces are combined using the following order:

    1. STATIC: Definitions specific to each script in the pipescript.
    2. GLOBAL: User variables shared across steps from a specific point onwards.
    3. LOCAL: User variables for each individual step.

    Parameters:
    -----------
    verbose : bool, optional
        Controls verbosity of the dynamic scripts in the resulting dscript object.
        If None, the verbosity setting of the pipescript will be used.

    clean : &#34;fixing&#34; or &#34;removing&#34;
        - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
        - &#39;fixing&#39;: Replace the content of the empty step with a comment.

    **USER : scriptobjectdata(), optional
        Additional user-defined variables that can override existing static variables
        in the dscript object or be added to it.

    Returns:
    --------
    outd : dscript
        A dscript object that contains all steps of the pipescript as dynamic scripts.
        Each step from the pipescript is added as a dynamic script with the same content
        and combined variable spaces.
    &#34;&#34;&#34;
    # Local imports
    from pizza.dscript import dscript, ScriptTemplate, lambdaScriptdata

    # verbosity
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity

    # Adjust name
    if name is None:
        if isinstance(self.name, str):
            name = self.name
        elif isinstance(self.name, list):
            name = (
                self.name[0] if len(self.name) == 1 else self.name[0] + &#34;...&#34; + self.name[-1]
            )

    # Create the dscript container with the pipescript name as the userid
    outd = dscript(userid=name, verbose=self.verbose, **USER)

    # Initialize static merged definitions
    staticmerged_definitions = lambdaScriptdata()

    # Track used variables per step
    step_used_variables = []

    # Loop over each step in the pipescript
    for i, script in enumerate(self.listscript):
        # Merge STATIC, GLOBAL, and LOCAL variables for the current step
        static_vars = self.listUSER[i] # script.DEFINITIONS
        global_vars = script.DEFINITIONS # self.scripts[i].USER
        local_vars = script.USER # self.USER[i]
        refreshed_globalvars = static_vars + global_vars

        # Detect variables used in the current template
        used_variables = set(script.detect_variables())
        step_used_variables.append(used_variables)  # Track used variables for this step

        # Copy all current variables to local_static_updates and remove matching variables from staticmerged_definitions
        local_static_updates = lambdaScriptdata(**local_vars)

        for var, value in refreshed_globalvars.items():
            if var in staticmerged_definitions:
                if (getattr(staticmerged_definitions, var) != value) and (var not in local_vars):
                    setattr(local_static_updates, var, value)
            else:
                setattr(staticmerged_definitions, var, value)

       # Create the dynamic script for this step using the method in dscript
        key_name = i  # Use the index &#39;i&#39; as the key in TEMPLATE
        content = script.TEMPLATE

        # Use the helper method in dscript to add this dynamic script
        outd.add_dynamic_script(
            key=key_name,
            content=content,
            definitions = lambdaScriptdata(**local_static_updates),
            verbose=self.verbose if verbose is None else verbose,
            userid=self.name[i],
            autorefresh=False # prevent the replacement by default values ${}
        )

        # Set eval=True only if variables are detected in the template
        if outd.TEMPLATE[key_name].detect_variables():
            outd.TEMPLATE[key_name].eval = True

    # Compute the union of all used variables across all steps
    global_used_variables = set().union(*step_used_variables)

    # Filter staticmerged_definitions to keep only variables that are used
    filtered_definitions = {
        var: value for var, value in staticmerged_definitions.items() if var in global_used_variables
    }

    # Assign the filtered definitions along with USER variables to outd.DEFINITIONS
    outd.DEFINITIONS = lambdaScriptdata(**filtered_definitions)

    # Clean the entries for empty templates
    outd.clean(verbose=verbose,behavior=clean)

    return outd</code></pre>
</details>
</dd>
<dt id="region.pipescript.generate_report"><code class="name flex">
<span>def <span class="ident">generate_report</span></span>(<span>self, filename, varnames=None, scopes='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a comprehensive report for specified variables and writes it to a file.</p>
<p>Parameters:
- filename (str): Path to the output report file. Must end with .md, .txt, or .html.
- varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to 'all'.
- scopes (str or list/tuple, optional): 'all', a single scope string, or a list of scope strings. Defaults to 'all'.</p>
<p>Raises:
- ValueError: If 'filename' has an unsupported extension.
- Exception: For other unforeseen errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
    &#34;&#34;&#34;
    Generates a comprehensive report for specified variables and writes it to a file.

    Parameters:
    - filename (str): Path to the output report file. Must end with .md, .txt, or .html.
    - varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to &#39;all&#39;.
    - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.

    Raises:
    - ValueError: If &#39;filename&#39; has an unsupported extension.
    - Exception: For other unforeseen errors.
    &#34;&#34;&#34;
    # Validate filename extension
    _, ext = os.path.splitext(filename)
    ext = ext.lower()

    if ext not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;]:
        raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

    # Determine format based on extension
    if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
        export_format = &#39;markdown&#39;
    elif ext == &#39;.html&#39;:
        export_format = &#39;html&#39;

    # Determine variables to include
    if varnames is None or (isinstance(varnames, (list, tuple)) and len(varnames) == 0):
        variables = &#39;all&#39;
    else:
        variables = varnames  # Can be a string or a list/tuple

    # Retrieve VariableOccurrences instances
    if variables == &#39;all&#39;:
        variables_occurrences = self.list_values(varname=None, what=scopes)
    else:
        # Normalize varnames to a list
        if isinstance(variables, str):
            variables = [variables]
        elif isinstance(variables, (list, tuple)):
            variables = list(variables)
        else:
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a string or a list/tuple of strings.&#34;)

        variables_occurrences = {}
        for var in variables:
            vo = self.list_values(varname=var, what=scopes)
            if vo and var in vo.variables:
                variables_occurrences[var] = vo
            else:
                print(f&#34;Warning: Variable &#39;{var}&#39; not found in the specified scopes.&#34;)

    # Initialize report content
    report_content = &#34;&#34;
    timestamp = datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
    caller = &#34;generate_report&#34;

    # Add report header
    if export_format == &#39;markdown&#39;:
        report_content += f&#34;# Comprehensive Variable Report\n\n&#34;
        report_content += f&#34;**Generated on {timestamp} by {caller}**\n\n&#34;
    elif export_format == &#39;html&#39;:
        # Define CSS for HTML
        css = &#34;&#34;&#34;
        &lt;style&gt;
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
            }
            h1, h2, h3, h4, h5 {
                color: #333;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                margin-bottom: 40px;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            th {
                background-color: #4CAF50;
                color: white;
            }
            tr:nth-child(even){background-color: #f2f2f2;}
            tr:hover {background-color: #ddd;}
        &lt;/style&gt;
        &#34;&#34;&#34;
        report_content += f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Comprehensive Variable Report&lt;/title&gt;\n{css}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;
        report_content += f&#34;&lt;h1&gt;Comprehensive Variable Report&lt;/h1&gt;\n&#34;
        report_content += f&#34;&lt;h2&gt;Generated on {timestamp} by {caller}&lt;/h2&gt;\n&#34;

    # Assemble report content using VariableOccurrences.export()
    for var, vo in variables_occurrences.items():
        # Export content without headers and get as string
        var_content = vo.export(filename=filename, # use to identify the format based on its extension
                                scopes=scopes,
                                variables=var,
                                include_headers=False,
                                return_content=True)

        if export_format == &#39;markdown&#39;:
            # Add variable header
            report_content += f&#34;## Variable: `{var}`\n\n&#34;
            report_content += var_content + &#34;\n\n&#34;
            report_content += &#34;---\n\n&#34;  # Horizontal line between variables
        elif export_format == &#39;html&#39;:
            # Add variable header
            report_content += f&#34;&lt;h2&gt;Variable: {var}&lt;/h2&gt;\n&#34;
            report_content += var_content + &#34;\n&lt;hr/&gt;\n&#34;  # Horizontal line between variables

    # Finalize HTML content
    if export_format == &#39;html&#39;:
        report_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

    # Write report to file
    try:
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            file.write(report_content)
        print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
    except Exception as e:
        raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="region.pipescript.getUSER"><code class="name flex">
<span>def <span class="ident">getUSER</span></span>(<span>self, idx, key)</span>
</code></dt>
<dd>
<div class="desc"><p>getUSER get USER variable
getUSER(idx,varname)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUSER(self,idx,key):
    &#34;&#34;&#34;
        getUSER get USER variable
        getUSER(idx,varname)
    &#34;&#34;&#34;
    if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
        self.listUSER[idx].getattr(key)
    else:
        raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)</code></pre>
</details>
</dd>
<dt id="region.pipescript.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self, verbose=True, verbosity=None, style=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a formatted header for the pipescript file.</p>
<h2 id="parameters">Parameters</h2>
<p>verbosity (bool, optional): If specified, overrides the instance's <code>verbose</code> setting.
Defaults to the instance's <code>verbose</code>.
style (int from 1 to 6, optional): ASCII style to frame the header (default=4)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representing the pipescript object.
Returns an empty string if verbosity is False.</dd>
</dl>
<p>The header includes:
- Total number of scripts in the pipeline.
- The verbosity setting.
- The range of scripts from the first to the last script.
- All enclosed within an ASCII frame that adjusts to the content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self, verbose=True,verbosity=None, style=4):
    &#34;&#34;&#34;
    Generate a formatted header for the pipescript file.

    Parameters:
        verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                    Defaults to the instance&#39;s `verbose`.
        style (int from 1 to 6, optional): ASCII style to frame the header (default=4)

    Returns:
        str: A formatted string representing the pipescript object.
             Returns an empty string if verbosity is False.

    The header includes:
        - Total number of scripts in the pipeline.
        - The verbosity setting.
        - The range of scripts from the first to the last script.
        - All enclosed within an ASCII frame that adjusts to the content.
    &#34;&#34;&#34;
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    if not verbosity:
        return &#34;&#34;

    # Prepare the header content
    lines = [
        f&#34;PIPESCRIPT with {self.n} scripts | Verbosity: {verbosity}&#34;,
        &#34;&#34;,
        f&#34;From: &lt;{str(self.scripts[0])}&gt; To: &lt;{str(self.scripts[-1])}&gt;&#34;,
    ]

    # Use the shared method to format the header
    return frame_header(lines,style=style)</code></pre>
</details>
</dd>
<dt id="region.pipescript.list_multiple_values"><code class="name flex">
<span>def <span class="ident">list_multiple_values</span></span>(<span>self, varnames, what='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all occurrences and values of multiple variables across the pipeline scripts.</p>
<p>Parameters:
- varnames (list): A list of variable names to search for.
- what (str or list/tuple): Specifies the scopes to search in.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.</p>
<p>Returns:
- dict: A dictionary mapping each variable name to its VariableOccurrences object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_multiple_values(self, varnames, what=&#34;all&#34;):
    &#34;&#34;&#34;
    Lists all occurrences and values of multiple variables across the pipeline scripts.

    Parameters:
    - varnames (list): A list of variable names to search for.
    - what (str or list/tuple): Specifies the scopes to search in.
                                 Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                 or a list/tuple of any combination of these.

    Returns:
    - dict: A dictionary mapping each variable name to its VariableOccurrences object.
    &#34;&#34;&#34;
    if not isinstance(varnames, (list, tuple)):
        raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

    return self.list_values(varname=varnames, what=what)</code></pre>
</details>
</dd>
<dt id="region.pipescript.list_values"><code class="name flex">
<span>def <span class="ident">list_values</span></span>(<span>self, varname=None, what='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.</p>
<p>Parameters:
- varname (str, optional): The name of the variable to search for. If None, all variables are listed.
- what (str or list/tuple, optional): Specifies the scopes to search in.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.</p>
<p>Returns:
- VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
- dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_values(self, varname=None, what=&#34;all&#34;):
    &#34;&#34;&#34;
    Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.

    Parameters:
    - varname (str, optional): The name of the variable to search for. If None, all variables are listed.
    - what (str or list/tuple, optional): Specifies the scopes to search in.
                                         Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                         or a list/tuple of any combination of these.

    Returns:
    - VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
    - dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.
    &#34;&#34;&#34;
    # Normalize &#39;what&#39; to a list for uniform processing
    if isinstance(what, str):
        if what.lower() == &#34;all&#34;:
            scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
        else:
            scopes = [what.lower()]
    elif isinstance(what, (list, tuple)):
        scopes_lower = [s.lower() for s in what]
        if &#39;all&#39; in scopes_lower:
            scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
        else:
            scopes = scopes_lower
    else:
        raise ValueError(&#34;Parameter &#39;what&#39; must be a string or a list/tuple of strings.&#34;)

    # Initialize data structures
    if varname:
        # Single variable case
        if len(scopes) == 1:
            data = []
        else:
            data = {}
            for scope in scopes:
                data[scope] = []

        # Iterate over each script in the pipeline
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            # Check each requested scope
            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                if varname in vars_dict.keys():
                    value = getattr(vars_dict,varname)
                    if len(scopes) == 1:
                        data.append((i, value))
                    else:
                        data[scope].append((i, value))

        # Return a VariableOccurrences instance for the specified variable
        return VariableOccurrences(data, variables=varname)

    else:
        # All variables case
        all_vars = set()

        # First, collect all variable names across specified scopes and scripts
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                all_vars.update(vars_dict.keys())

        # Initialize a dictionary to hold VariableOccurrences for each variable
        variables_data = {}
        for var in all_vars:
            var_data = {}
            for scope in scopes:
                var_data[scope] = []
            variables_data[var] = var_data

        # Iterate again to populate the data for each variable
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                for var, value in vars_dict.items():
                    variables_data[var][scope].append((i, value))

        # Convert each variable&#39;s data into a VariableOccurrences instance
        variables_occurrences = {}
        for var, data in variables_data.items():
            variables_occurrences[var] = VariableOccurrences(data, variables=var)

        return variables_occurrences</code></pre>
</details>
</dd>
<dt id="region.pipescript.plot_multiple_value_distributions"><code class="name flex">
<span>def <span class="ident">plot_multiple_value_distributions</span></span>(<span>self, varnames, what='all', separate_plots=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the distribution of elements for multiple variables across specified scopes.</p>
<p>Parameters:
- varnames (list): A list of variable names to plot.
- what (str or list/tuple): Specifies the scopes to include in the plot.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.
- separate_plots (bool): If True, plots each variable in a separate subplot.
If False, combines all variables in a single plot for comparison.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_multiple_value_distributions(self, varnames, what=&#34;all&#34;, separate_plots=True):
    &#34;&#34;&#34;
    Plots the distribution of elements for multiple variables across specified scopes.

    Parameters:
    - varnames (list): A list of variable names to plot.
    - what (str or list/tuple): Specifies the scopes to include in the plot.
                                 Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                 or a list/tuple of any combination of these.
    - separate_plots (bool): If True, plots each variable in a separate subplot.
                             If False, combines all variables in a single plot for comparison.
    &#34;&#34;&#34;
    if not isinstance(varnames, (list, tuple)):
        raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

    # Retrieve VariableOccurrences instances
    multiple_vars = self.list_multiple_values(varnames, what=what)

    if separate_plots:
        num_vars = len(multiple_vars)
        fig, axes = plt.subplots(num_vars, 1, figsize=(10, 5 * num_vars))
        if num_vars == 1:
            axes = [axes]  # Make it iterable

        for ax, (var, vo) in zip(axes, multiple_vars.items()):
            summary = vo.summarize()[var]
            for scope, details in summary.items():
                elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                ax.bar(elements, counts, label=scope)
            ax.set_xlabel(&#39;Element&#39;)
            ax.set_ylabel(&#39;Count&#39;)
            ax.set_title(f&#34;Distribution of elements in &#39;{var}&#39;&#34;)
            ax.legend()

        plt.tight_layout()
        plt.show()

    else:
        plt.figure(figsize=(12, 8))
        for var, vo in multiple_vars.items():
            summary = vo.summarize()[var]
            for scope, details in summary.items():
                elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                plt.bar([f&#34;{var}_{elem}&#34; for elem in elements], counts, label=f&#34;{var} - {scope}&#34;)

        plt.xlabel(&#39;Element&#39;)
        plt.ylabel(&#39;Count&#39;)
        plt.title(&#34;Distribution of elements in multiple variables&#34;)
        plt.legend()
        plt.xticks(rotation=45, ha=&#39;right&#39;)
        plt.tight_layout()
        plt.show()</code></pre>
</details>
</dd>
<dt id="region.pipescript.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, name='', idx=None)</span>
</code></dt>
<dd>
<div class="desc"><p>rename scripts in the pipe
p.rename(idx=[0,2,3],name=["A","B","C"])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(self,name=&#34;&#34;,idx=None):
    &#34;&#34;&#34;
        rename scripts in the pipe
            p.rename(idx=[0,2,3],name=[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;])
    &#34;&#34;&#34;
    if isinstance(name,list):
        if len(name)==len(self) and idx==None:
            self.name = name
        elif len(name) == len(idx):
            for i in range(len(idx)):
                self.rename(name[i],idx[i])
        else:
            IndexError(f&#34;the number of indices {len(idx)} does not match the number of names {len(name)}&#34;)
    elif idx !=None and idx&lt;len(self) and name!=&#34;&#34;:
        self.name[idx] = name
    else:
        raise ValueError(&#34;provide a non empty name and valid index&#34;)</code></pre>
</details>
</dd>
<dt id="region.pipescript.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4)</span>
</code></dt>
<dd>
<div class="desc"><p>script the pipeline or parts of the pipeline
s = p.script()
s = p.script([0,2])</p>
<p>Parameters:
- idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
If None, all steps from the current position to
the end are executed. A list of indices can be
provided to execute specific steps, or a single
integer can be passed to execute a specific step.
Default is None.
- printflag (bool, optional): If True, the generated script for each step is printed
to the console. Default is True.
- verbosity (int, optional): Controls the level of detail in the generated script.
- 0: Minimal output, no comments.
- 1: Basic comments for run steps.
- 2: Detailed comments with additional information.
Default is 2.
- forced (bool, optional): If True, all scripts are regenerated
- style (int, optional):
Defines the ASCII frame style for the header.
Valid values are integers from 1 to 6, corresponding to predefined styles:
1. Basic box with <code>+</code>, <code>-</code>, and <code>|</code>
2. Double-line frame with <code>╔</code>, <code>═</code>, and <code>║</code>
3. Rounded corners with <code>.</code>, <code>'</code>, <code>-</code>, and <code>|</code>
4. Thick outer frame with <code>#</code>, <code>=</code>, and <code>#</code>
5. Box drawing characters with <code>┌</code>, <code>─</code>, and <code>│</code>
6. Minimalist dotted frame with <code>.</code>, <code>:</code>, and <code>.</code>
Default is <code>4</code> (thick outer frame).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def script(self,idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4):
    &#34;&#34;&#34;
        script the pipeline or parts of the pipeline
            s = p.script()
            s = p.script([0,2])

    Parameters:
    - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                           If None, all steps from the current position to
                                           the end are executed. A list of indices can be
                                           provided to execute specific steps, or a single
                                           integer can be passed to execute a specific step.
                                           Default is None.
    - printflag (bool, optional): If True, the generated script for each step is printed
                                  to the console. Default is True.
    - verbosity (int, optional): Controls the level of detail in the generated script.
                                 - 0: Minimal output, no comments.
                                 - 1: Basic comments for run steps.
                                 - 2: Detailed comments with additional information.
                                 Default is 2.
    - forced (bool, optional): If True, all scripts are regenerated
    - style (int, optional):
        Defines the ASCII frame style for the header.
        Valid values are integers from 1 to 6, corresponding to predefined styles:
            1. Basic box with `+`, `-`, and `|`
            2. Double-line frame with `╔`, `═`, and `║`
            3. Rounded corners with `.`, `&#39;`, `-`, and `|`
            4. Thick outer frame with `#`, `=`, and `#`
            5. Box drawing characters with `┌`, `─`, and `│`
            6. Minimalist dotted frame with `.`, `:`, and `.`
        Default is `4` (thick outer frame).

    &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity=0 if verbose is False else verbosity
    s = script(printflag=printflag, verbose=verbosity&gt;0)
    s.name = &#34;pipescript&#34;
    s.description = &#34;pipeline with %d scripts&#34; % len(self)
    if len(self)&gt;1:
        s.userid = self.name[0]+&#34;-&gt;&#34;+self.name[-1]
    elif len(self)==1:
        s.userid = self.name[0]
    else:
        s.userid = &#34;empty pipeline&#34;
    s.TEMPLATE = self.header(verbosity=verbosity, style=style) + &#34;\n&#34; +\
        self.do(idx, printflag=printflag, verbosity=verbosity, verbose=verbose, forced=forced)
    s.DEFINITIONS = duplicate(self.globalscript.DEFINITIONS)
    s.USER = duplicate(self.globalscript.USER)
    return s</code></pre>
</details>
</dd>
<dt id="region.pipescript.setUSER"><code class="name flex">
<span>def <span class="ident">setUSER</span></span>(<span>self, idx, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>setUSER sets USER variables
setUSER(idx,varname,varvalue)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUSER(self,idx,key,value):
    &#34;&#34;&#34;
        setUSER sets USER variables
        setUSER(idx,varname,varvalue)
    &#34;&#34;&#34;
    if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
        self.listUSER[idx].setattr(key,value)
    else:
        raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)</code></pre>
</details>
</dd>
<dt id="region.pipescript.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, printflag=False, verbosity=2, verbose=None, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the combined script to a file.</p>
<h2 id="parameters">Parameters</h2>
<p>file (str): The file path where the script will be saved.
printflag (bool): Flag to enable/disable printing of details.
verbosity (int): Level of verbosity for the script generation.
verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance's verbosity.
overwrite (bool): Whether to overwrite the file if it already exists. Default is False.</p>
<p>Returns:
str: The full absolute path of the file written.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and overwrite is False.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>This method combines the individual scripts within the <code><a title="region.pipescript" href="#region.pipescript">pipescript</a></code> object
and saves the resulting script to the specified file.</li>
<li>If <code>overwrite</code> is False and the file exists, an error is raised.</li>
<li>If <code>verbose</code> is True and the file is overwritten, a warning is displayed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, printflag=False, verbosity=2, verbose=None, overwrite=False):
   &#34;&#34;&#34;
   Write the combined script to a file.

   Parameters:
       file (str): The file path where the script will be saved.
       printflag (bool): Flag to enable/disable printing of details.
       verbosity (int): Level of verbosity for the script generation.
       verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance&#39;s verbosity.
       overwrite (bool): Whether to overwrite the file if it already exists. Default is False.

    Returns:
        str: The full absolute path of the file written.

   Raises:
       FileExistsError: If the file already exists and overwrite is False.

   Notes:
       - This method combines the individual scripts within the `pipescript` object
         and saves the resulting script to the specified file.
       - If `overwrite` is False and the file exists, an error is raised.
       - If `verbose` is True and the file is overwritten, a warning is displayed.
   &#34;&#34;&#34;
   # Generate the combined script
   myscript = self.script(printflag=printflag, verbosity=verbosity, verbose=verbose, forced=True)
   # Call the script&#39;s write method with the overwrite parameter
   return myscript.write(file, printflag=printflag, verbose=verbose, overwrite=overwrite)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.pstr"><code class="flex name class">
<span>class <span class="ident">pstr</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-pstr">Class: <code><a title="region.pstr" href="#region.pstr">pstr</a></code></h1>
<p>A specialized string class for handling paths and filenames, derived from <code><a title="region.struct" href="#region.struct">struct</a></code>.
The <code><a title="region.pstr" href="#region.pstr">pstr</a></code> class ensures compatibility with POSIX-style paths and provides enhanced
operations for path manipulation.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Maintains POSIX-style paths.</li>
<li>Automatically handles trailing slashes.</li>
<li>Supports path concatenation using <code>/</code>.</li>
<li>Converts seamlessly back to <code>str</code> for compatibility with string methods.</li>
<li>Includes additional utility methods for path evaluation and formatting.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic Usage</h4>
<pre><code class="language-python">a = pstr(&quot;this/is/mypath//&quot;)
b = pstr(&quot;mylocalfolder/myfile.ext&quot;)
c = a / b
print(c)  # this/is/mypath/mylocalfolder/myfile.ext
</code></pre>
<h4 id="keeping-trailing-slashes">Keeping Trailing Slashes</h4>
<pre><code class="language-python">a = pstr(&quot;this/is/mypath//&quot;)
print(a)  # this/is/mypath/
</code></pre>
<hr>
<h3 id="path-operations">Path Operations</h3>
<h4 id="path-concatenation">Path Concatenation</h4>
<p>Use the <code>/</code> operator to concatenate paths:</p>
<pre><code class="language-python">a = pstr(&quot;folder/subfolder&quot;)
b = pstr(&quot;file.txt&quot;)
c = a / b
print(c)  # folder/subfolder/file.txt
</code></pre>
<h4 id="path-evaluation">Path Evaluation</h4>
<p>Evaluate or convert paths while preserving the <code><a title="region.pstr" href="#region.pstr">pstr</a></code> type:</p>
<pre><code class="language-python">result = pstr.eval(&quot;some/path/afterreplacement&quot;, ispstr=True)
print(result)  # some/path/afterreplacement
</code></pre>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="using-string-methods">Using String Methods</h4>
<p>Methods like <code>replace()</code> convert <code><a title="region.pstr" href="#region.pstr">pstr</a></code> back to <code>str</code>. To retain the <code><a title="region.pstr" href="#region.pstr">pstr</a></code> type:</p>
<pre><code class="language-python">new_path = pstr.eval(a.replace(&quot;mypath&quot;, &quot;newpath&quot;), ispstr=True)
print(new_path)  # this/is/newpath/
</code></pre>
<h4 id="handling-posix-paths">Handling POSIX Paths</h4>
<p>The <code><a title="region.pstr.topath" href="#region.pstr.topath">pstr.topath()</a></code> method ensures the path remains POSIX-compliant:</p>
<pre><code class="language-python">path = pstr(&quot;C:\Windows\Path&quot;)
posix_path = path.topath()
print(posix_path)  # C:/Windows/Path
</code></pre>
<hr>
<h3 id="overloaded-operators">Overloaded Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>/</code>: Concatenates two paths (<code>__truediv__</code>).</li>
<li><code>+</code>: Concatenates strings as paths, resulting in a <code><a title="region.pstr" href="#region.pstr">pstr</a></code> object (<code>__add__</code>).</li>
<li><code>+=</code>: Adds to an existing <code><a title="region.pstr" href="#region.pstr">pstr</a></code> object (<code>__iadd__</code>).</li>
</ul>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eval(value)</code></td>
<td>Evaluates the path or string for compatibility with <code><a title="region.pstr" href="#region.pstr">pstr</a></code>.</td>
</tr>
<tr>
<td><code>topath()</code></td>
<td>Returns the POSIX-compliant path.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>Use <code><a title="region.pstr" href="#region.pstr">pstr</a></code> for consistent and safe handling of file paths across different platforms.</li>
<li>Converts back to <code>str</code> when using non-<code><a title="region.pstr" href="#region.pstr">pstr</a></code> specific methods to ensure compatibility.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pstr(str):
    &#34;&#34;&#34;
    Class: `pstr`
    =============

    A specialized string class for handling paths and filenames, derived from `struct`.
    The `pstr` class ensures compatibility with POSIX-style paths and provides enhanced
    operations for path manipulation.

    ---

    ### Features
    - Maintains POSIX-style paths.
    - Automatically handles trailing slashes.
    - Supports path concatenation using `/`.
    - Converts seamlessly back to `str` for compatibility with string methods.
    - Includes additional utility methods for path evaluation and formatting.

    ---

    ### Examples

    #### Basic Usage
    ```python
    a = pstr(&#34;this/is/mypath//&#34;)
    b = pstr(&#34;mylocalfolder/myfile.ext&#34;)
    c = a / b
    print(c)  # this/is/mypath/mylocalfolder/myfile.ext
    ```

    #### Keeping Trailing Slashes
    ```python
    a = pstr(&#34;this/is/mypath//&#34;)
    print(a)  # this/is/mypath/
    ```

    ---

    ### Path Operations

    #### Path Concatenation
    Use the `/` operator to concatenate paths:
    ```python
    a = pstr(&#34;folder/subfolder&#34;)
    b = pstr(&#34;file.txt&#34;)
    c = a / b
    print(c)  # folder/subfolder/file.txt
    ```

    #### Path Evaluation
    Evaluate or convert paths while preserving the `pstr` type:
    ```python
    result = pstr.eval(&#34;some/path/afterreplacement&#34;, ispstr=True)
    print(result)  # some/path/afterreplacement
    ```

    ---

    ### Advanced Usage

    #### Using String Methods
    Methods like `replace()` convert `pstr` back to `str`. To retain the `pstr` type:
    ```python
    new_path = pstr.eval(a.replace(&#34;mypath&#34;, &#34;newpath&#34;), ispstr=True)
    print(new_path)  # this/is/newpath/
    ```

    #### Handling POSIX Paths
    The `pstr.topath()` method ensures the path remains POSIX-compliant:
    ```python
    path = pstr(&#34;C:\\Windows\\Path&#34;)
    posix_path = path.topath()
    print(posix_path)  # C:/Windows/Path
    ```

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `/`: Concatenates two paths (`__truediv__`).
    - `+`: Concatenates strings as paths, resulting in a `pstr` object (`__add__`).
    - `+=`: Adds to an existing `pstr` object (`__iadd__`).

    ---

    ### Utility Methods

    | Method          | Description                                  |
    |------------------|----------------------------------------------|
    | `eval(value)`    | Evaluates the path or string for compatibility with `pstr`. |
    | `topath()`       | Returns the POSIX-compliant path.           |

    ---

    ### Notes
    - Use `pstr` for consistent and safe handling of file paths across different platforms.
    - Converts back to `str` when using non-`pstr` specific methods to ensure compatibility.
    &#34;&#34;&#34;

    def __repr__(self):
        result = self.topath()
        if result[-1] != &#34;/&#34; and self[-1] == &#34;/&#34;:
            result += &#34;/&#34;
        return result

    def topath(self):
        &#34;&#34;&#34; return a validated path &#34;&#34;&#34;
        value = pstr(PurePath(self))
        if value[-1] != &#34;/&#34; and self [-1]==&#34;/&#34;:
            value += &#34;/&#34;
        return value


    @staticmethod
    def eval(value,ispstr=False):
        &#34;&#34;&#34; evaluate the path of it os a path &#34;&#34;&#34;
        if isinstance(value,pstr):
            return value.topath()
        elif isinstance(value,PurePath) or ispstr:
            return pstr(value).topath()
        else:
            return value

    def __truediv__(self,value):
        &#34;&#34;&#34; overload / &#34;&#34;&#34;
        operand = pstr.eval(value)
        result = pstr(PurePath(self) / operand)
        if result[-1] != &#34;/&#34; and operand[-1] == &#34;/&#34;:
            result += &#34;/&#34;
        return result

    def __add__(self,value):
        return pstr(str(self)+value)

    def __iadd__(self,value):
        return pstr(str(self)+value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="region.pstr.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>value, ispstr=False)</span>
</code></dt>
<dd>
<div class="desc"><p>evaluate the path of it os a path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def eval(value,ispstr=False):
    &#34;&#34;&#34; evaluate the path of it os a path &#34;&#34;&#34;
    if isinstance(value,pstr):
        return value.topath()
    elif isinstance(value,PurePath) or ispstr:
        return pstr(value).topath()
    else:
        return value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.pstr.topath"><code class="name flex">
<span>def <span class="ident">topath</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return a validated path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def topath(self):
    &#34;&#34;&#34; return a validated path &#34;&#34;&#34;
    value = pstr(PurePath(self))
    if value[-1] != &#34;/&#34; and self [-1]==&#34;/&#34;:
        value += &#34;/&#34;
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.region"><code class="flex name class">
<span>class <span class="ident">region</span></span>
<span>(</span><span>name='region container', dimension=3, boundary=None, nbeads=1, units='', mass=1.0, volume=1.0, density=1.0, radius=1.5, contactradius=0.5, velocities=[0.0, 0.0, 0.0], forces=[0.0, 0.0, 0.0], filename='', previewfilename='', index=None, run=1, center=[0.0, 0.0, 0.0], width=10.0, height=10.0, depth=10.0, hasfixmove=False, spacefilling=False, fillingbeadtype=1, boxid='box', regionunits='lattice', separationdistance=5e-06, lattice_scale=0.8442, lattice_spacing=None, lattice_style='fcc', atom_style='smd', atom_modify=['map', 'array'], comm_modify=['vel', 'yes'], neigh_modify=['every', 10, 'delay', 0, 'check', 'yes'], newton='off', live_units='lj', live_atom_style='atomic', livepreview_options={'static': {'run': 1}, 'dynamic': {'run': 100}}, printflag=False, verbose=True, verbosity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="region.region" href="#region.region">region</a></code> class represents a simulation region, centered at the origin (0, 0, 0) by default,
and is characterized by its physical dimensions, properties, and boundary conditions. It supports
setting up lattice structures, particle properties, and options for live previews.</p>
<h2 id="attributes">Attributes:</h2>
<p>name : str, optional
Name of the region (default is 'region container').</p>
<p>dimension : int, optional
Number of spatial dimensions for the simulation (either 2 or 3, default is 3).</p>
<p>boundary : list of str or None, optional
Boundary conditions for each dimension. If None, defaults to ["sm"] * dimension.
Must be a list of length <code>dimension</code>, where "s" indicates shrink-wrapped, and "m" indicates a non-periodic boundary.</p>
<p>nbeads : int, optional
Number of beads in the region (default is 1).</p>
<p>units : str, optional
Units for the simulation box (default is "").</p>
<h2 id="particle-properties">Particle Properties:</h2>
<p>mass : float, optional
Mass of particles in the region (default is 1).</p>
<p>volume : float, optional
Volume of the region (default is 1).</p>
<p>density : float, optional
Density of the region (default is 1).</p>
<p>radius : float, optional
Radius of the particles (default is 1.5).</p>
<p>contactradius : float, optional
Contact radius of the particles (default is 0.5).</p>
<p>velocities : list of floats, optional
Initial velocities of particles (default is [0, 0, 0]).</p>
<p>forces : list of floats, optional
External forces acting on the particles (default is [0, 0, 0]).</p>
<h2 id="other-properties">Other Properties:</h2>
<p>filename : str, optional
Name of the output file (default is an empty string, which will auto-generate a name based on the region name).</p>
<p>index : int, optional
Index or identifier for the region.</p>
<p>run : int, optional
Run configuration parameter (default is 1).</p>
<h2 id="box-properties">Box Properties:</h2>
<p>center : list of floats, optional
Center of the simulation box for coordinate scaling (default is [0, 0, 0]).</p>
<p>width : float, optional
Width of the region (default is 10).</p>
<p>height : float, optional
Height of the region (default is 10).</p>
<p>depth : float, optional
Depth of the region (default is 10).</p>
<p>hasfixmove : bool, optional
Indicates whether the region has a fixed movement (default is False).</p>
<h2 id="spacefilling-design">Spacefilling Design:</h2>
<p>spacefilling : bool, optional
Indicates whether the design is space-filling (default is False).</p>
<p>fillingbeadtype : int, optional
Type of bead used for space filling (default is 1).</p>
<h2 id="lattice-properties">Lattice Properties:</h2>
<p>regionunits : str, optional
Defines the units of the region. Can be either "lattice" (default) or "si".</p>
<p>separationdistance : float, optional
Separation distance between atoms in SI units (default is 5e-6).</p>
<p>lattice_scale : float, optional
Scaling factor for the lattice, used mainly in visualization (default is 0.8442).</p>
<p>lattice_spacing : list or None, optional
Specifies the spacing between lattice points. If None, the default spacing is used. Can be a list of [dx, dy, dz].</p>
<p>lattice_style : str, optional
Specifies the lattice structure style (default is "fcc"). Accepts any LAMMPS valid style, e.g., "sc" for simple cubic.</p>
<h2 id="atom-properties">Atom Properties:</h2>
<p>atom_style : str, optional
Defines the atom style for the region (default is "smd").</p>
<p>atom_modify : list of str, optional
LAMMPS command for atom modification (default is ["map", "array"]).</p>
<p>comm_modify : list of str, optional
LAMMPS command for communication modification (default is ["vel", "yes"]).</p>
<p>neigh_modify : list, optional
LAMMPS command for neighbor list modification (default is ["every", 10, "delay", 0, "check", "yes"]).</p>
<p>newton : str, optional
Specifies the Newton flag (default is "off").</p>
<h2 id="live-preview">Live Preview:</h2>
<p>live_units : str, optional
Units for live preview (default is "lj", for Lennard-Jones units).</p>
<p>live_atom_style : str, optional
Atom style used specifically for live LAMMPS sessions (default is "atomic").</p>
<p>livepreview_options : dict, optional
Contains options for live preview. The dictionary includes 'static' (default: run = 1) and 'dynamic' (default: run = 100) options.</p>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong> :
Constructor method to initialize all the attributes of the <code><a title="region.region" href="#region.region">region</a></code> class.</p>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class region:
    &#34;&#34;&#34;
    The `region` class represents a simulation region, centered at the origin (0, 0, 0) by default,
    and is characterized by its physical dimensions, properties, and boundary conditions. It supports
    setting up lattice structures, particle properties, and options for live previews.

    Attributes:
    ----------
    name : str, optional
        Name of the region (default is &#39;region container&#39;).

    dimension : int, optional
        Number of spatial dimensions for the simulation (either 2 or 3, default is 3).

    boundary : list of str or None, optional
        Boundary conditions for each dimension. If None, defaults to [&#34;sm&#34;] * dimension.
        Must be a list of length `dimension`, where &#34;s&#34; indicates shrink-wrapped, and &#34;m&#34; indicates a non-periodic boundary.

    nbeads : int, optional
        Number of beads in the region (default is 1).

    units : str, optional
        Units for the simulation box (default is &#34;&#34;).

    Particle Properties:
    -------------------
    mass : float, optional
        Mass of particles in the region (default is 1).

    volume : float, optional
        Volume of the region (default is 1).

    density : float, optional
        Density of the region (default is 1).

    radius : float, optional
        Radius of the particles (default is 1.5).

    contactradius : float, optional
        Contact radius of the particles (default is 0.5).

    velocities : list of floats, optional
        Initial velocities of particles (default is [0, 0, 0]).

    forces : list of floats, optional
        External forces acting on the particles (default is [0, 0, 0]).

    Other Properties:
    ----------------
    filename : str, optional
        Name of the output file (default is an empty string, which will auto-generate a name based on the region name).

    index : int, optional
        Index or identifier for the region.

    run : int, optional
        Run configuration parameter (default is 1).

    Box Properties:
    ---------------
    center : list of floats, optional
        Center of the simulation box for coordinate scaling (default is [0, 0, 0]).

    width : float, optional
        Width of the region (default is 10).

    height : float, optional
        Height of the region (default is 10).

    depth : float, optional
        Depth of the region (default is 10).

    hasfixmove : bool, optional
        Indicates whether the region has a fixed movement (default is False).

    Spacefilling Design:
    -------------------
    spacefilling : bool, optional
        Indicates whether the design is space-filling (default is False).

    fillingbeadtype : int, optional
        Type of bead used for space filling (default is 1).

    Lattice Properties:
    ------------------
    regionunits : str, optional
        Defines the units of the region. Can be either &#34;lattice&#34; (default) or &#34;si&#34;.

    separationdistance : float, optional
        Separation distance between atoms in SI units (default is 5e-6).

    lattice_scale : float, optional
        Scaling factor for the lattice, used mainly in visualization (default is 0.8442).

    lattice_spacing : list or None, optional
        Specifies the spacing between lattice points. If None, the default spacing is used. Can be a list of [dx, dy, dz].

    lattice_style : str, optional
        Specifies the lattice structure style (default is &#34;fcc&#34;). Accepts any LAMMPS valid style, e.g., &#34;sc&#34; for simple cubic.

    Atom Properties:
    ----------------
    atom_style : str, optional
        Defines the atom style for the region (default is &#34;smd&#34;).

    atom_modify : list of str, optional
        LAMMPS command for atom modification (default is [&#34;map&#34;, &#34;array&#34;]).

    comm_modify : list of str, optional
        LAMMPS command for communication modification (default is [&#34;vel&#34;, &#34;yes&#34;]).

    neigh_modify : list, optional
        LAMMPS command for neighbor list modification (default is [&#34;every&#34;, 10, &#34;delay&#34;, 0, &#34;check&#34;, &#34;yes&#34;]).

    newton : str, optional
        Specifies the Newton flag (default is &#34;off&#34;).

    Live Preview:
    ------------
    live_units : str, optional
        Units for live preview (default is &#34;lj&#34;, for Lennard-Jones units).

    live_atom_style : str, optional
        Atom style used specifically for live LAMMPS sessions (default is &#34;atomic&#34;).

    livepreview_options : dict, optional
        Contains options for live preview. The dictionary includes &#39;static&#39; (default: run = 1) and &#39;dynamic&#39; (default: run = 100) options.

    Methods:
    -------
    __init__ :
        Constructor method to initialize all the attributes of the `region` class.
    &#34;&#34;&#34;

    _version = &#34;0.9997&#34;
    __custom_documentations__ = &#34;pizza.region.region class&#34;

    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    #
    # CONSTRUCTOR METHOD
    #
    #
    # The constructor include
    #   the main container: objects (a dictionnary)
    #   several attributes covering current and future use of PIZZA.REGION()
    #
    # The original constructor is derived from PIZZA.RASTER() with
    # an intent to allow at some point some forward and backward port between
    # objects of the class PIZZA.RASTER() and PIZZA.REGION().
    #
    # The code will evolve according to the needs, please come back regularly.
    #
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

    # CONSTRUCTOR ----------------------------
    def __init__(self,
                 # container properties
                 name=&#34;region container&#34;,
                 dimension = 3,
                 boundary = None,
                 nbeads=1,
                 units = &#34;&#34;,

                 # particle properties
                 mass=1.0,
                 volume=1.0,
                 density=1.0,
                 radius=1.5,
                 contactradius=0.5,
                 velocities=[0.0,0.0,0.0],
                 forces=[0.0,0.0,0.0],

                 # other properties
                 filename=&#34;&#34;,
                 previewfilename=&#34;&#34;,
                 index = None,
                 run=1,

                 # Box lengths
                 center = [0.0,0.0,0.0],    # center of the box for coordinates scaling
                 width = 10.0,  # along x
                 height = 10.0, # along y
                 depth = 10.0,  # along z
                 hasfixmove = False, # by default no fix move

                 # Spacefilling design (added on 2023-08-10)
                 spacefilling = False,
                 fillingbeadtype = 1,

                 # Lattice properties
                 boxid = &#34;box&#34;,             # default value for ${boxid_arg}
                 regionunits = &#34;lattice&#34;,   # units (&#34;lattice&#34; or &#34;si&#34;)
                 separationdistance = 5e-6, # SI units
                 lattice_scale = 0.8442,    # LJ units (for visualization)
                 lattice_spacing = None,    # lattice spacing is not used by default (set [dx dy dz] if needed)
                 lattice_style = &#34;fcc&#34; ,    # any valid lattice style accepted by LAMMPS (sc=simple cubic)

                 # Atom properties
                 atom_style = &#34;smd&#34;,
                 atom_modify = [&#34;map&#34;,&#34;array&#34;],
                 comm_modify = [&#34;vel&#34;,&#34;yes&#34;],
                 neigh_modify = [&#34;every&#34;,10,&#34;delay&#34;,0,&#34;check&#34;,&#34;yes&#34;],
                 newton =&#34;off&#34;,

                 # Live preview
                 live_units = &#34;lj&#34;,         # units to be used ONLY with livelammps (https://andeplane.github.io/atomify/)
                 live_atom_style = &#34;atomic&#34;,# atom style to be used ONLY with livelammps (https://andeplane.github.io/atomify/)

                 # livepreview options
                 livepreview_options = {
                     &#39;static&#39;:{&#39;run&#39;:1},
                     &#39;dynamic&#39;:{&#39;run&#39;:100}
                     },

                 # common flags (for scripting)
                 printflag = False,
                 verbose = True,
                 verbosity = None

                 ):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        self.name = name

        # Ensure dimension is an integer (must be 2 or 3 for LAMMPS)
        if not isinstance(dimension, int) or dimension not in (2, 3):
            raise ValueError(&#34;dimension must be either 2 or 3.&#34;)

        # Handle boundary input
        if boundary is None:
            boundary = [&#34;sm&#34;] * dimension
        elif isinstance(boundary, list):
            if len(boundary) != dimension:
                raise ValueError(f&#34;The length of boundary ({len(boundary)}) must match the dimension ({dimension}).&#34;)
        else:
            raise ValueError(&#34;boundary must be a list of strings or None.&#34;)

        # Validate regionunits
        if regionunits not in (&#34;lattice&#34;, &#34;si&#34;):
            raise ValueError(&#34;regionunits can only be &#39;lattice&#39; or &#39;si&#39;.&#34;)

        # Lattice scaling logic
        lattice_scale_siunits = lattice_scale if regionunits == &#34;si&#34; else separationdistance
        if lattice_scale_siunits is None or lattice_scale_siunits==&#34;&#34;:
            lattice_scale_siunits = separationdistance
        if lattice_spacing == &#34;&#34;:
            lattice_spacing = None
        elif isinstance(lattice_spacing, (int, float)):
            lattice_spacing = [lattice_spacing] * dimension
        elif isinstance(lattice_spacing, list):
            lattice_spacing = lattice_spacing + [lattice_spacing[-1]] * (dimension - len(lattice_spacing)) if len(lattice_spacing) &lt; dimension else lattice_spacing[:dimension]

        # live data (updated 2024-07-04)
        live_lattice_scale = lattice_scale/separationdistance if regionunits == &#34;si&#34; else lattice_scale
        live_box_scale = 1/lattice_scale_siunits if regionunits == &#34;si&#34; else 1
        self.live = regiondata(nbeads=nbeads,
                               run=run,
                               width=math.ceil(width*live_box_scale),    # live_box_scale force lattice units for live visualization
                               height=math.ceil(height*live_box_scale),  # live_box_scale force lattice units for live visualization
                               depth=math.ceil(depth*live_box_scale),    # live_box_scale force lattice units for live visualization
                               live_units = &#34;$&#34;+live_units,
                               live_atom_style = &#34;$&#34;+live_atom_style,
                               live_lattice_style=&#34;$&#34;+lattice_style,
                               live_lattice_scale=live_lattice_scale)
        # generic SMD properties (to be rescaled)
        self.volume = volume
        self.mass = mass
        self.density = density
        self.radius = radius
        self.contactradius = contactradius
        self.velocities = velocities
        self.forces = forces
        if filename == &#34;&#34;:
            self.filename = f&#34;region_{self.name}&#34;
        else:
            self.filename = filename
        self.index = index
        self.objects = {}    # object container
        self.nobjects = 0    # total number of objects (alive)
        # count objects per type
        self.counter = {
                  &#34;ellipsoid&#34;:0,
                  &#34;block&#34;:0,
                  &#34;sphere&#34;:0,
                  &#34;cone&#34;:0,
                  &#34;cylinder&#34;:0,
                  &#34;prism&#34;:0,
                  &#34;plane&#34;:0,
                  &#34;union&#34;:0,
                  &#34;intersect&#34;:0,
                  &#34;eval&#34;:0,
                  &#34;collection&#34;:0,
                  &#34;all&#34;:0
            }
        # fix move flag
        self.hasfixmove = hasfixmove
        # livelammps (for live sessions) - added 2023-02-06
        self.livelammps = {
            &#34;URL&#34;: livelammpsURL,
         &#34;active&#34;: False,
           &#34;file&#34;: None,
        &#34;options&#34;: livepreview_options
            }
        # space filling  (added 2023-08-10)
        self.spacefilling = {
                   &#34;flag&#34;: spacefilling,
           &#34;fillingstyle&#34;: &#34;$block&#34;,
        &#34;fillingbeadtype&#34;: fillingbeadtype,
           &#34;fillingwidth&#34;: width,
          &#34;fillingheight&#34;: height,
           &#34;fillingdepth&#34;: depth,
           &#34;fillingunits&#34;: units
               }
        # region object units
        self.regionunits = regionunits
        # lattice
        self.units = units
        self.center = center
        self.separationdistance = separationdistance
        self.lattice_scale = lattice_scale
        self.lattice_spacing = lattice_spacing
        self.lattice_scale_siunits = lattice_scale_siunits
        self.lattice_style = lattice_style
        # headers for header scripts (added 2024-09-01)
        # geometry is assumed to be units set by ${boxunits_arg} (new standard 2024-11-26)
        self.headersData = headersRegiondata(
            # use $ and [] to prevent execution
            name = &#34;$&#34;+name,
            previewfilename = &#34;$dump.initial.&#34;+self.filename if previewfilename==&#34;&#34; else &#34;$&#34;+previewfilename,
            # Initialize Lammps
            dimension = dimension,
            units = &#34;$&#34;+units,
            boundary = boundary,
            atom_style = &#34;$&#34; + atom_style,
            atom_modify = atom_modify,
            comm_modify = comm_modify,
            neigh_modify = neigh_modify,
            newton =&#34;$&#34; + newton,
            # Box (added 2024-11-26)
            boxid = &#34;$&#34;+boxid,
            boxunits_arg = &#34;$units box&#34; if regionunits==&#34;si&#34; else &#34;&#34;, # standard on 2025-11-26
            # Lattice
            lattice_style = &#34;$&#34;+lattice_style,
            lattice_scale = lattice_scale,
            lattice_spacing = lattice_spacing,
            # Box
            xmin = -(width/2)  +center[0],
            xmax = +(width/2)   +center[0],
            ymin = -(height/2) +center[1],
            ymax = +(height/2) +center[1],
            zmin = -(depth/2)  +center[2],
            zmax = +(depth/2)  +center[2],
            nbeads = nbeads,
            mass = mass
            )
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity

    # Method for coordinate/length scaling and translation including with formula embedded strings (updated 2024-07-03, fixed 2024-07-04)
    # Note that the translation is not fully required since the scaling applies also to full coordinates.
    # However, an implementation is provided for arbitrary offset.
    def scale_and_translate(self, value, offset=0):
        &#34;&#34;&#34;
        Scale and translate a value or encapsulate the formula within a string.

        If self.regionunits is &#34;si&#34;, only the offset is applied without scaling.
        Otherwise, scaling and translation are performed based on self.units (&#34;si&#34; or &#34;lattice&#34;).

        Parameters:
            value (str or float): The value or formula to be scaled and translated.
            offset (float, optional): The offset to apply. Defaults to 0.

        Returns:
            str or float: The scaled and translated value or formula.
        &#34;&#34;&#34;
        if self.regionunits == &#34;si&#34;:
            # Only apply offset without scaling
            if isinstance(value, str):
                if offset:
                    translated = f&#34;({value}) - {offset}&#34;
                else:
                    translated = f&#34;{value}&#34;
                return translated
            else:
                if offset:
                    return value - offset
                else:
                    return value
        else:
            # Existing behavior based on self.units
            if isinstance(value, str):
                if offset:
                    translated = f&#34;({value}) - {offset}&#34;
                else:
                    translated = f&#34;{value}&#34;
                if self.units == &#34;si&#34;:
                    return f&#34;({translated}) / {self.lattice_scale} + {offset / self.lattice_scale}&#34;
                else:  # &#34;lattice&#34;
                    return f&#34;({translated}) * {self.lattice_scale} + {offset * self.lattice_scale}&#34;
            else:
                if offset:
                    translated = value - offset
                else:
                    translated = value
                if self.units == &#34;si&#34;:
                    return translated / self.lattice_scale + (offset / self.lattice_scale)
                else:  # &#34;lattice&#34;
                    return translated * self.lattice_scale + (offset * self.lattice_scale)



    # space filling attributes (cannot be changed)
    @property
    def isspacefilled(self):
        return self.spacefilling[&#34;flag&#34;]

    @property
    def spacefillingbeadtype(self):
        return self.spacefilling[&#34;fillingbeadtype&#34;]

    # total number of atoms in the region
    @property
    def natoms(self):
        &#34;&#34;&#34;Count the total number of atoms in all objects within the region.&#34;&#34;&#34;
        total_atoms = 0
        for eachobj in self:
            total_atoms += eachobj.natoms
        return total_atoms

    # details if the geometry of the region
    @property
    def geometry(self):
        &#34;&#34;&#34;Display the dimensions and characteristics of the region and its objects.&#34;&#34;&#34;
        details = f&#34;Region: {self.name}\n&#34;
        details += f&#34;Total atoms: {self.natoms}\n&#34;
        details += f&#34;Span: width={self.spacefilling[&#39;fillingwidth&#39;]}, height={self.spacefilling[&#39;fillingheight&#39;]}, depth={self.spacefilling[&#39;fillingdepth&#39;]}\n&#34;
        details += f&#34;Box center: {self.center}\n&#34;
        details += &#34;Objects in the region:\n\n&#34;
        for obj in self:
            details += &#34;\n\n&#34;+&#34;-&#34;*32+&#34;\n&#34;
            details += f&#34;\nObject: {obj.name}\n&#34;
            details += f&#34;Type: {type(obj).__name__}\n&#34;
            if hasattr(obj, &#39;geometry&#39;):
                details += &#34;\n&#34;+&#34;-&#34;*32+&#34;\n&#34;
                details += obj.geometry
            else:
                details += &#34;No geometry information available.\n&#34;
        print(details)

    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    #
    # REGION.GEOMETRY constructors
    #
    #
    #   These methods create the 3D geometry objects (at least their code)
    #   A geometry is a collection of PIZZA.SCRIPT() objects (LAMMPS codelet)
    #   not a real geometry. The distinction between the creation (definition)
    #   and the execution (generation) of the gometry object existed already
    #   in PIZZA.RASTER(), but here they remain codelets as ONLY LAMMPS can
    #   generate the real object.
    #
    #   This level of abstraction makes it possible to mix PIZZA variables
    #   (USER, PIZZA.SCRIPT.USER, PIZZA.PIPESCRIPT.USER) with LAMMPS variables.
    #   The same object template can be used in different LAMMPS scripts with
    #   different values and without writting additional Python code.
    #   In shorts: USER fields store PIZZA.SCRIPT() like variables
    #              (they are compiled [statically] before LAMMPS execution)
    #              VARIABLES are defined in the generated LAMMPS script but
    #              created [dynamically] in LAMMPS. Note that these variables
    #              are defined explicitly with the LAMMPS variable command:
    #                   variable name style args ...
    #   Note: static variables can have only one single value for LAMMPS, which
    #         is known before LAMMPS is launched. The others can be assigned
    #         at runtime when LAMMPS is running.
    #   Example with complex definitions
    #       R.ellipsoid(0,0,0,1,1,1,name=&#34;E2&#34;,side=&#34;out&#34;,
    #                   move=[&#34;left&#34;,&#34;${up}*3&#34;,None],
    #                   up=0.1)
    #       R.E2.VARIABLES.left = &#39;&#34;swiggle(%s,%s,%s)&#34;%(${a},${b},${c})&#39;
    #       R.E2.VARIABLES.a=&#34;${b}-5&#34;
    #       R.E2.VARIABLES.b=5
    #       R.E2.VARIABLES.c=100
    #
    #   The methods PIZZA.REGION.DO(), PIZZA.REGION.DOLIVE() compiles
    #   (statically) and generate the corresponding LAMMPS code. The static
    #   compiler accepts hybrid constructions where USER and VARIABLES are
    #   mixed. Any undefined variables will be assumed to be defined elsewhere
    #   in the LAMMPS code.
    #
    #  Current attributes of PIZZA.REGION.OBJECT cover current and future use
    #  of these objects and will allow some point some forward and backward
    #  compatibility with the same PIZZA.RASTER.OBJECT.
    #
    #
    #   References:
    #       https://docs.lammps.org/region.html
    #       https://docs.lammps.org/variable.html
    #       https://docs.lammps.org/create_atoms.html
    #       https://docs.lammps.org/create_box.html
    #
    #
    #   List of implemented geometries (shown here with the LAMMPS syntax)
    #       block args = xlo xhi ylo yhi zlo zhi
    #       cone args = dim c1 c2 radlo radhi lo hi
    #       cylinder args = dim c1 c2 radius lo hi
    #       ellipsoid args = x y z a b c &lt;-- first method to be implemented
    #       plane args = px py pz nx ny n
    #       prism args = xlo xhi ylo yhi zlo zhi xy xz yz
    #       sphere args = x y z radius
    #       union args = N reg-ID1 reg-ID2 ..
    #       intersect args = N reg-ID1 reg-ID2 ...
    #
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

    # BLOCK method ---------------------------
    # block args = xlo xhi ylo yhi zlo zhi
    # xlo,xhi,ylo,yhi,zlo,zhi = bounds of block in all dimensions (distance units)
    def block(self,xlo=-5,xhi=5,ylo=-5,yhi=5,zlo=-5,zhi=5,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a block region
            xlo,xhi,ylo,yhi,zlo,zhi = bounds of block in all dimensions (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;block001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;block&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object B with B for block
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        B = Block((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density, # added on 2024-06-14
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): B.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: B.beadtype = beadtype # bead type (if not defined, default index will apply)
        B.USER.ID = &#34;$&#34;+B.name        # add $ to prevent its execution
        # geometry args (2024-07-04)  -------------------------------------
        args = [xlo, xhi, ylo, yhi, zlo, zhi]  # args = [....] as defined in the class Block
        args_scaled = [
            self.scale_and_translate(xlo, self.center[0]),
            self.scale_and_translate(xhi, self.center[0]),
            self.scale_and_translate(ylo, self.center[1]),
            self.scale_and_translate(yhi, self.center[1]),
            self.scale_and_translate(zlo, self.center[2]),
            self.scale_and_translate(zhi, self.center[2])
        ]
        if self.units == &#34;si&#34;:
            B.USER.args = args_scaled
            B.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            B.USER.args = args
            B.USER.args_siunits = args_scaled
        # geometry
        B.USER.geometry = (
            f&#34;Block Region: {B.name}\n&#34;
            &#34;Coordinates: [xlo,xhi,ylo,yhi,zlo,zhi] = bounds of block in all dimensions&#34;
            f&#34;Coordinates (scaled): {B.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {B.USER.args_siunits}\n&#34;
            f&#34;\talong x: [{B.USER.args[0]}, {B.USER.args[1]}]\n&#34;
            f&#34;\talong y: [{B.USER.args[2]}, {B.USER.args[3]}]\n&#34;
            f&#34;\talong z: [{B.USER.args[4]}, {B.USER.args[5]}]&#34;
        )
        # other attributes  -------------------------------------
        B.USER.beadtype = B.beadtype  # beadtype to be used for create_atoms
        B.USER.side = B.sidearg(side) # extra parameter side
        B.USER.move = B.movearg(move) # move arg
        B.USER.units = B.unitsarg(units) # units
        B.USER.rotate = B.rotatearg(rotate) # rotate
        B.USER.open = B.openarg(open) # open
        # Create the object if not fake
        if fake:
            return B
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = B
            self.nobjects += 1
            return None

    # CONE method ---------------------------
    # cone args = dim c1 c2 radlo radhi lo hi
    # dim = x or y or z = axis of cone
    # c1,c2 = coords of cone axis in other 2 dimensions (distance units)
    # radlo,radhi = cone radii at lo and hi end (distance units)
    # lo,hi = bounds of cone in dim (distance units)
    def cone(self,dim=&#34;z&#34;,c1=0,c2=0,radlo=2,radhi=5,lo=-10,hi=10,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a cone region
            dim = &#34;x&#34; or &#34;y&#34; or &#34;z&#34; = axis of the cone
                 note: USER, LAMMPS variables are not authorized here
            c1,c2 = coords of cone axis in other 2 dimensions (distance units)
            radlo,radhi = cone radii at lo and hi end (distance units)
            lo,hi = bounds of cone in dim (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;cone001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;cone&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object C with C for cone
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        C = Cone((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density, # added on 2024-06-14
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): C.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: C.beadtype = beadtype # bead type (if not defined, default index will apply)
        C.USER.ID = &#34;$&#34;+C.name        # add $ to prevent its execution
        # geometry args (2024-07-04)  -------------------------------------
        args = [dim, c1, c2, radlo, radhi, lo, hi]  # args = [....] as defined in the class Cone
        if dim == &#34;x&#34;:  # x-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[1]),
                self.scale_and_translate(c2, self.center[2]),
                self.scale_and_translate(radlo, 0),
                self.scale_and_translate(radhi, 0),
                self.scale_and_translate(lo, self.center[0]),
                self.scale_and_translate(hi, self.center[0])
            ]
        elif dim == &#34;y&#34;:  # y-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[0]),
                self.scale_and_translate(c2, self.center[2]),
                self.scale_and_translate(radlo, 0),
                self.scale_and_translate(radhi, 0),
                self.scale_and_translate(lo, self.center[1]),
                self.scale_and_translate(hi, self.center[1])
            ]
        else:  # z-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[0]),
                self.scale_and_translate(c2, self.center[1]),
                self.scale_and_translate(radlo, 0),
                self.scale_and_translate(radhi, 0),
                self.scale_and_translate(lo, self.center[2]),
                self.scale_and_translate(hi, self.center[2])
            ]

        if self.units == &#34;si&#34;:
            C.USER.args = args_scaled
            C.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            C.USER.args = args
            C.USER.args_siunits = args_scaled
        # geometry
        C.USER.geometry = (
            f&#34;Cone Region: {C.name}\n&#34;
            &#34;Coordinates: [dim,c1,c2,radlo,radhi,lo,hi] = dimensions of cone\n&#34;
            f&#34;Coordinates (scaled): {C.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {C.USER.args_siunits}\n&#34;
            f&#34;\tdim: {C.USER.args[0]}\n&#34;
            f&#34;\tc1: {C.USER.args[1]}\n&#34;
            f&#34;\tc2: {C.USER.args[2]}\n&#34;
            f&#34;\tradlo: {C.USER.args[3]}\n&#34;
            f&#34;\tradhi: {C.USER.args[4]}\n&#34;
            f&#34;\tlo: {C.USER.args[5]}\n&#34;
            f&#34;\thi: {C.USER.args[6]}&#34;
        )
        # other attributes  -------------------------------------
        C.USER.beadtype = C.beadtype  # beadtype to be used for create_atoms
        C.USER.side = C.sidearg(side) # extra parameter side
        C.USER.move = C.movearg(move) # move arg
        C.USER.units = C.unitsarg(units) # units
        C.USER.rotate = C.rotatearg(rotate) # rotate
        C.USER.open = C.openarg(open) # open
        # Create the object if not fake
        if fake:
            return C
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = C
            self.nobjects += 1
            return None

    # CYLINDER method ---------------------------
    # cylinder args = dim c1 c2 radius lo hi
    # dim = x or y or z = axis of cylinder
    # c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)
    # radius = cylinder radius (distance units)
    # c1,c2, and radius can be a variable (see below)
    # lo,hi = bounds of cylinder in dim (distance units)
    def cylinder(self,dim=&#34;z&#34;,c1=0,c2=0,radius=4,lo=-10,hi=10,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a cylinder region
              dim = x or y or z = axis of cylinder
              c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)
              radius = cylinder radius (distance units)
              c1,c2, and radius can be a LAMMPS variable
              lo,hi = bounds of cylinder in dim (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;cylinder001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;cylinder&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object C with C for cylinder
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        C = Cylinder((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density,
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): C.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: C.beadtype = beadtype # bead type (if not defined, default index will apply)
        C.USER.ID = &#34;$&#34;+C.name        # add $ to prevent its execution
        # geometry args (2024-07-04)  -------------------------------------
        args = [dim, c1, c2, radius, lo, hi]  # args = [....] as defined in the class Cylinder
        if dim == &#34;x&#34;:  # x-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[1]),
                self.scale_and_translate(c2, self.center[2]),
                self.scale_and_translate(radius, 0),
                self.scale_and_translate(lo, self.center[0]),
                self.scale_and_translate(hi, self.center[0])
            ]
        elif dim == &#34;y&#34;:  # y-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[0]),
                self.scale_and_translate(c2, self.center[2]),
                self.scale_and_translate(radius, 0),
                self.scale_and_translate(lo, self.center[1]),
                self.scale_and_translate(hi, self.center[1])
            ]
        else:  # z-axis
            args_scaled = [
                dim,
                self.scale_and_translate(c1, self.center[0]),
                self.scale_and_translate(c2, self.center[1]),
                self.scale_and_translate(radius, 0),
                self.scale_and_translate(lo, self.center[2]),
                self.scale_and_translate(hi, self.center[2])
            ]
        if self.units == &#34;si&#34;:
            C.USER.args = args_scaled
            C.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            C.USER.args = args
            C.USER.args_siunits = args_scaled
        # geometry
        C.USER.geometry = (
            f&#34;Cylinder Region: {C.name}\n&#34;
            &#34;Coordinates: [dim,c1,c2,radius,lo,hi] = dimensions of cylinder\n&#34;
            f&#34;Coordinates (scaled): {C.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {C.USER.args_siunits}\n&#34;
            f&#34;\tdim: {C.USER.args[0]}\n&#34;
            f&#34;\tc1: {C.USER.args[1]}\n&#34;
            f&#34;\tc2: {C.USER.args[2]}\n&#34;
            f&#34;\tradius: {C.USER.args[3]}\n&#34;
            f&#34;\tlo: {C.USER.args[4]}\n&#34;
            f&#34;\thi: {C.USER.args[5]}&#34;
        )
        # other attributes  -------------------------------------
        C.USER.beadtype = C.beadtype  # beadtype to be used for create_atoms
        C.USER.side = C.sidearg(side) # extra parameter side
        C.USER.move = C.movearg(move) # move arg
        C.USER.units = C.unitsarg(units) # units
        C.USER.rotate = C.rotatearg(rotate) # rotate
        C.USER.open = C.openarg(open) # open
        # Create the object if not fake
        if fake:
            return C
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = C
            self.nobjects += 1
            return None

    # ELLIPSOID method ---------------------------
    # ellipsoid args = x y z a b c
    # x,y,z = center of ellipsoid (distance units)
    # a,b,c = half the length of the principal axes of the ellipsoid (distance units)
    # x,y,z,a,b,c can be variables
    def ellipsoid(self,x=0,y=0,z=0,a=5,b=3,c=2,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates an ellipsoid region
            ellipsoid(x,y,z,a,b,c [,name=None,beadtype=None,property=value,...])
            x,y,z = center of ellipsoid (distance units)
            a,b,c = half the length of the principal axes of the ellipsoid (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;ellipsoid001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
                index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index


            Examples:
                # example with variables created either at creation or later
                    R = region(name=&#34;my region&#34;)
                    R.ellipsoid(0, 0, 0, 1, 1, 1,name=&#34;E1&#34;,toto=3)
                    repr(R.E1)
                    R.E1.VARIABLES.a=1
                    R.E1.VARIABLES.b=2
                    R.E1.VARIABLES.c=&#34;(${a},${b},100)&#34;
                    R.E1.VARIABLES.d = &#39;&#34;%s%s&#34; %(&#34;test&#34;,${c}) # note that test could be replaced by any function&#39;
                # example with extra parameters
                    R.ellipsoid(0,0,0,1,1,1,name=&#34;E2&#34;,side=&#34;out&#34;,move=[&#34;left&#34;,&#34;${up}*3&#34;,None],up=0.1)
                    R.E2.VARIABLES.left = &#39;&#34;swiggle(%s,%s,%s)&#34;%(${a},${b},${c})&#39;
                    R.E2.VARIABLES.a=&#34;${b}-5&#34;
                    R.E2.VARIABLES.b=5
                    R.E2.VARIABLES.c=100
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;ellipsoid&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object E with E for Ellipsoid
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        E = Ellipsoid((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density,
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): E.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: E.beadtype = beadtype # bead type (if not defined, default index will apply)
        E.USER.ID = &#34;$&#34;+E.name        # add $ to prevent its execution
        # geometry args (2024-07-04)  -------------------------------------
        args = [x, y, z, a, b, c]  # args = [....] as defined in the class Ellipsoid
        args_scaled = [
            self.scale_and_translate(x, self.center[0]),
            self.scale_and_translate(y, self.center[1]),
            self.scale_and_translate(z, self.center[2]),
            self.scale_and_translate(a, 0),
            self.scale_and_translate(b, 0),
            self.scale_and_translate(c, 0)
        ]
        if self.units == &#34;si&#34;:
            E.USER.args = args_scaled
            E.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            E.USER.args = args
            E.USER.args_siunits = args_scaled
        # geometry
        E.USER.geometry = (
            f&#34;Ellipsoid Region: {E.name}\n&#34;
            &#34;Coordinates: [x,y,z,a,b,c] = center and radii of ellipsoid\n&#34;
            f&#34;Coordinates (scaled): {E.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {E.USER.args_siunits}\n&#34;
            f&#34;\tcenter: [{E.USER.args[0]}, {E.USER.args[1]}, {E.USER.args[2]}]\n&#34;
            f&#34;\ta: {E.USER.args[3]}\n&#34;
            f&#34;\tb: {E.USER.args[4]}\n&#34;
            f&#34;\tc: {E.USER.args[5]}&#34;
        )
        # other attributes  -------------------------------------
        E.USER.beadtype = E.beadtype  # beadtype to be used for create_atoms
        E.USER.side = E.sidearg(side) # extra parameter side
        E.USER.move = E.movearg(move) # move arg
        E.USER.units = E.unitsarg(units) # units
        E.USER.rotate = E.rotatearg(rotate) # rotate
        E.USER.open = E.openarg(open) # open
        # Create the object if not fake
        if fake:
            return E
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = E
            self.nobjects += 1
            return None

    # PLANE method ---------------------------
    # plane args = px py pz nx ny nz
    # px,py,pz = point on the plane (distance units)
    # nx,ny,nz = direction normal to plane (distance units)
    def plane(self,px=0,py=0,pz=0,nx=0,ny=0,nz=1,
                  name=None,beadtype=None,fake=False,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a plane region
              px,py,pz = point on the plane (distance units)
              nx,ny,nz = direction normal to plane (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;plane001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;plane&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object P with P for plane
        P = Plane((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=self.mass, density=self.density, # added on 2024-06-14
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): P.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: P.beadtype = beadtype # bead type (if not defined, default index will apply)
        P.USER.ID = &#34;$&#34;+P.name        # add $ to prevent its execution
        # geometry args (2024-07-04) ---------------------------
        args = [px, py, pz, nx, ny, nz]  # args = [....] as defined in the class Plane
        args_scaled = [
            self.scale_and_translate(px, self.center[0]),
            self.scale_and_translate(py, self.center[1]),
            self.scale_and_translate(pz, self.center[2]),
            self.scale_and_translate(nx, 0),
            self.scale_and_translate(ny, 0),
            self.scale_and_translate(nz, 0)
        ]
        if self.units == &#34;si&#34;:
            P.USER.args = args_scaled
            P.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            P.USER.args = args
            P.USER.args_siunits = args_scaled
        # geometry
        P.USER.geometry = (
            f&#34;Plane Region: {P.name}\n&#34;
            &#34;Coordinates: [px,py,pz,nx,ny,nz] = point and normal vector of plane\n&#34;
            f&#34;Coordinates (scaled): {P.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {P.USER.args_siunits}\n&#34;
            f&#34;\tpoint: [{P.USER.args[0]}, {P.USER.args[1]}, {P.USER.args[2]}]\n&#34;
            f&#34;\tnormal: [{P.USER.args[3]}, {P.USER.args[4]}, {P.USER.args[5]}]&#34;
            )
        # other attributes ---------------------------
        P.USER.beadtype = P.beadtype  # beadtype to be used for create_atoms
        P.USER.side = P.sidearg(side) # extra parameter side
        P.USER.move = P.movearg(move) # move arg
        P.USER.units = P.unitsarg(units) # units
        P.USER.rotate = P.rotatearg(rotate) # rotate
        P.USER.open = P.openarg(open) # open
        # Create the object if not fake
        if fake:
            return P
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = P
            self.nobjects += 1
            return None

    # PRISM method ---------------------------
    # prism args = xlo xhi ylo yhi zlo zhi xy xz yz
    # xlo,xhi,ylo,yhi,zlo,zhi = bounds of untilted prism (distance units)
    # xy = distance to tilt y in x direction (distance units)
    # xz = distance to tilt z in x direction (distance units)
    # yz = distance to tilt z in y direction (distance units)
    def prism(self,xlo=-5,xhi=5,ylo=-5,yhi=5,zlo=-5,zhi=5,xy=1,xz=1,yz=1,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a prism region
            xlo,xhi,ylo,yhi,zlo,zhi = bounds of untilted prism (distance units)
            xy = distance to tilt y in x direction (distance units)
            xz = distance to tilt z in x direction (distance units)
            yz = distance to tilt z in y direction (distance units)

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;prism001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;prism&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object P with P for prism
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        P = Prism((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density, # added on 2024-06-14
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): P.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: P.beadtype = beadtype # bead type (if not defined, default index will apply)
        P.USER.ID = &#34;$&#34;+P.name        # add $ to prevent its execution
        # geometry args (2024-07-04) ---------------------------
        args = [xlo, xhi, ylo, yhi, zlo, zhi, xy, xz, yz]  # args = [....] as defined in the class Prism
        args_scaled = [
            self.scale_and_translate(xlo, self.center[0]),
            self.scale_and_translate(xhi, self.center[0]),
            self.scale_and_translate(ylo, self.center[1]),
            self.scale_and_translate(yhi, self.center[1]),
            self.scale_and_translate(zlo, self.center[2]),
            self.scale_and_translate(zhi, self.center[2]),
            self.scale_and_translate(xy, 0),
            self.scale_and_translate(xz, 0),
            self.scale_and_translate(yz, 0)
        ]
        if self.units == &#34;si&#34;:
            P.USER.args = args_scaled
            P.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            P.USER.args = args
            P.USER.args_siunits = args_scaled
        # geometry
        P.USER.geometry = (
            f&#34;Prism Region: {P.name}\n&#34;
            &#34;Coordinates: [xlo,xhi,ylo,yhi,zlo,zhi,xy,xz,yz] = bounds and tilts of prism\n&#34;
            f&#34;Coordinates (scaled): {P.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {P.USER.args_siunits}\n&#34;
            f&#34;\tbounds: [{P.USER.args[0]}, {P.USER.args[1]}, {P.USER.args[2]}, {P.USER.args[3]}, {P.USER.args[4]}, {P.USER.args[5]}]\n&#34;
            f&#34;\ttilts: [{P.USER.args[6]}, {P.USER.args[7]}, {P.USER.args[8]}]&#34;
        )
        # other attributes ---------------------------
        P.USER.beadtype = P.beadtype  # beadtype to be used for create_atoms
        P.USER.side = P.sidearg(side) # extra parameter side
        P.USER.move = P.movearg(move) # move arg
        P.USER.units = P.unitsarg(units) # units
        P.USER.rotate = P.rotatearg(rotate) # rotate
        P.USER.open = P.openarg(open) # open
        # Create the object if not fake
        if fake:
            return P
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = P
            self.nobjects += 1
            return None

    # SPHERE method ---------------------------
    # sphere args = x y z radius
    # x,y,z = center of sphere (distance units)
    # radius = radius of sphere (distance units)
    # x,y,z, and radius can be a variable (see below)
    def sphere(self,x=0,y=0,z=0,radius=3,
                  name=None,beadtype=None,fake=False,
                  mass=None, density=None,
                  side=None,units=None,move=None,rotate=None,open=None,
                  index = None,subindex = None,
                  **variables
                  ):
        &#34;&#34;&#34;
        creates a sphere region
              x,y,z = center of sphere (distance units)
              radius = radius of sphere (distance units)
              x,y,z, and radius can be a variable

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;sphere001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex

            Extra properties
                side = &#34;in|out&#34;
               units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
                move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                       with v1,v2,v3 equal-style variables for x,y,z displacement
                       of region over time (distance units)
              rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                       vtheta = equal-style variable for rotation of region over time (in radians)
                       Px,Py,Pz = origin for axis of rotation (distance units)
                       Rx,Ry,Rz = axis of rotation vector
                open = integer from 1-6 corresponding to face index

            See examples for elliposid()
        &#34;&#34;&#34;
        # prepare object creation
        kind = &#34;sphere&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
        # create the object S with S for sphere
        obj_mass = mass if mass is not None else self.mass
        obj_density = density if density is not None else self.density
        S = Sphere((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      spacefilling=self.isspacefilled, # added on 2023-08-11
                      mass=obj_mass, density=obj_density, # added on 2024-06-14
                      index=index,subindex=subindex,
                      lattice_style=self.lattice_style,
                      lattice_scale=self.lattice_scale,
                      lattice_scale_siunits=self.lattice_scale_siunits,
                      **variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): S.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: S.beadtype = beadtype # bead type (if not defined, default index will apply)
        S.USER.ID = &#34;$&#34;+S.name        # add $ to prevent its execution
        # geometry args (2024-07-04) ---------------------------
        args = [x, y, z, radius]  # args = [....] as defined in the class Sphere
        args_scaled = [
            self.scale_and_translate(x, self.center[0]),
            self.scale_and_translate(y, self.center[1]),
            self.scale_and_translate(z, self.center[2]),
            self.scale_and_translate(radius, 0)
        ]
        if self.units == &#34;si&#34;:
            S.USER.args = args_scaled
            S.USER.args_siunits = args
        else:  # &#34;lattice&#34;
            S.USER.args = args
            S.USER.args_siunits = args_scaled
        # geometry
        S.USER.geometry = (
            f&#34;Sphere Region: {S.name}\n&#34;
            &#34;Coordinates: [x,y,z,radius] = center and radius of sphere\n&#34;
            f&#34;Coordinates (scaled): {S.USER.args}\n&#34;
            f&#34;Coordinates (SI units): {S.USER.args_siunits}\n&#34;
            f&#34;\tcenter: [{S.USER.args[0]}, {S.USER.args[1]}, {S.USER.args[2]}]\n&#34;
            f&#34;\tradius: {S.USER.args[3]}&#34;
        )
        # other attributes ---------------------------
        S.USER.beadtype = S.beadtype  # beadtype to be used for create_atoms
        S.USER.side = S.sidearg(side) # extra parameter side
        S.USER.move = S.movearg(move) # move arg
        S.USER.units = S.unitsarg(units) # units
        S.USER.rotate = S.rotatearg(rotate) # rotate
        S.USER.open = S.openarg(open) # open
        # Create the object if not fake
        if fake:
            return S
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = S
            self.nobjects += 1
            return None

    # UNION method ---------------------------
    # union args = N reg-ID1 reg-ID2
    def union(self,*regID,
              name=None,beadtype=1,fake=False,
              index = None,subindex = None,
              **variables):
        &#34;&#34;&#34;
        creates a union region
              union(&#34;reg-ID1&#34;,&#34;reg-ID2&#34;,name=&#34;myname&#34;,beadtype=1,...)
              reg-ID1,reg-ID2, ... = IDs of regions to join together

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;union001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex
        &#34;&#34;&#34;
        kind = &#34;union&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        # create the object U with U for union
        U = Union((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      index=index,subindex=subindex,**variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): U.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: U.beadtype = beadtype # bead type (if not defined, default index will apply)
        U.USER.ID = &#34;$&#34;+U.name        # add $ to prevent its execution
        U.USER.side, U.USER.move, U.USER.units, U.USER.rotate, U.USER.open = &#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;
        # build arguments based on regID
        nregID = len(regID)
        if nregID&lt;2: raise ValueError(&#39;two objects must be given at least for an union&#39;)
        args = [None] # the number of arguments is not known yet
        validID = range(nregID)
        for ireg in validID:
            if isinstance(regID[ireg],int):
                if regID[ireg] in validID:
                    args.append(self.names[regID[ireg]])
                else:
                    raise IndexError(f&#34;the index {regID[ireg]} exceeds the number of objects {len(self)}&#34;)
            elif isinstance(regID[ireg],str):
                if regID[ireg] in self:
                    args.append(regID[ireg])
                else:
                    raise KeyError(f&#39;the object &#34;{regID[ireg]}&#34; does not exist&#39;)
            else:
                raise KeyError(f&#34;the {ireg+1}th object should be given as a string or an index&#34;)
            # prevent the creation of atoms merged (avoid duplicates)
            self.objects[regID[ireg]].FLAGSECTIONS[&#34;create&#34;] = False
        args[0] = len(regID)
        U.USER.args = args   # args = [....] as defined in the class Union
        # Create the object if not fake
        if fake:
            return U
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = U
            self.nobjects += 1
            return None

    # UNION method ---------------------------
    # union args = N reg-ID1 reg-ID2
    def intersect(self,*regID,
              name=None,beadtype=1,fake=False,
              index = None,subindex = None,
              **variables):
        &#34;&#34;&#34;
        creates an intersection region
              intersect(&#34;reg-ID1&#34;,&#34;reg-ID2&#34;,name=&#34;myname&#34;,beadtype=1,...)
              reg-ID1,reg-ID2, ... = IDs of regions to join together

            URL: https://docs.lammps.org/region.html

            Main properties = default value
                name = &#34;intersect001&#34;
            beadtype = 1
                fake = False (use True to test the execution)
     index, subindex = object index and subindex
        &#34;&#34;&#34;
        kind = &#34;intersect&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        # create the object I with I for intersect
        I = Intersect((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                      index=index,subindex=subindex,**variables)
        # feed USER fields
        if name not in (None,&#34;&#34;): I.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: I.beadtype = beadtype # bead type (if not defined, default index will apply)
        I.USER.ID = &#34;$&#34;+I.name        # add $ to prevent its execution
        I.USER.side, I.USER.move, I.USER.units, I.USER.rotate, I.USER.open = &#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;
        # build arguments based on regID
        nregID = len(regID)
        if nregID&lt;2: raise ValueError(&#39;two objects must be given at least for an intersection&#39;)
        args = [None] # the number of arguments is not known yet
        validID = range(nregID)
        for ireg in validID:
            if isinstance(regID[ireg],int):
                if regID[ireg] in validID:
                    args.append(self.names[regID[ireg]])
                else:
                    raise IndexError(f&#34;the index {regID[ireg]} exceeds the number of objects {len(self)}&#34;)
            elif isinstance(regID[ireg],str):
                if regID[ireg] in self:
                    args.append(regID[ireg])
                else:
                    raise KeyError(f&#39;the object &#34;{regID[ireg]}&#34; does not exist&#39;)
            else:
                raise KeyError(f&#34;the {ireg+1}th object should be given as a string or an index&#34;)
            # prevent the creation of atoms (avoid duplicates)
            self.objects[regID[ireg]].FLAGSECTIONS[&#34;create&#34;] = False
        args[0] = len(regID)
        I.USER.args = args   # args = [....] as defined in the class Union
        # Create the object if not fake
        if fake:
            return I
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = I
            self.nobjects += 1
            return None


    # Group method ---------------------------
    def group(self,obj,name=None,fake=False):
        pass


    # COLLECTION method ---------------------------
    def collection(self,*obj,name=None,beadtype=None,fake=False,
              index = None,subindex = None,
              **kwobj):
        kind = &#34;collection&#34;
        if index is None: index = self.counter[&#34;all&#34;]+1
        if subindex is None: subindex = self.counter[kind]+1
        # create the object C with C for collection
        C = Collection((index,subindex))
        if name not in (None,&#34;&#34;): C.name = name # object name (if not defined, default name will be used)
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        if beadtype is not None: C.beadtype = beadtype # bead type (if not defined, default index will apply)
        # add objects
        C.collection = regioncollection(*obj,**kwobj)
        # apply modifications (beadtype, ismask)
        for o in C.collection.keys():
            tmp = C.collection.getattr(o)
            if beadtype != None: tmp.beadtype = beadtype
            C.collection.setattr(o,tmp)
        # Create the object if not fake
        if fake:
            return C
        else:
            self.counter[&#34;all&#34;] += 1
            self.counter[kind] +=1
            self.objects[name] = C
            self.nobjects += 1
            return None

    def scatter(self,
                 E,
                 name=&#34;emulsion&#34;,
                 beadtype=None,
                 ):
        &#34;&#34;&#34;


        Parameters
        ----------
        E : scatter or emulsion object
            codes for x,y,z and r.
        name : string, optional
            name of the collection. The default is &#34;emulsion&#34;.
        beadtype : integer, optional
            for all objects. The default is 1.

        Raises
        ------
        TypeError
            Return an error of the object is not a scatter type.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if isinstance(E,scatter):
            collect = {}
            for i in range(E.n):
                b = E.beadtype[i] if beadtype==None else beadtype
                nameobj = &#34;glob%02d&#34; % i
                collect[nameobj] = self.sphere(E.x[i],E.y[i],E.z[i],E.r[i],
                            name=nameobj,beadtype=b,fake=True)
            self.collection(**collect,name=name)
        else:
            raise TypeError(&#34;the first argument must be an emulsion object&#34;)



    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    #
    # LOW-LEVEL METHODS
    #
    #
    # Low-level methods to manipulate and operate region objects (e.g., R).
    # They implement essentially some Python standards with the following
    # shortcut: R[i] or R[objecti] and R.objecti and R.objects[objecti] are
    # the same ith object where R.objects is the original container
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

    # repr() method ----------------------------
    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        spacefillingstr = f&#34;\n(space filled with beads of type {self.spacefillingbeadtype})&#34; \
            if self.isspacefilled else &#34;&#34;
        print(&#34;-&#34;*40)
        print(&#39;REGION container &#34;%s&#34; with %d objects %s\n(units=&#34;%s&#34;, lattice=&#34;%s&#34;, scale=%0.4g [m])&#39; \
              % (self.name,self.nobjects,spacefillingstr,self.units,self.lattice_style,self.lattice_scale_siunits))
        if self.nobjects&gt;0:
            names = self.names
            l = [len(n) for n in names]
            width = max(10,max(l)+2)
            fmt = &#34;%%%ss:&#34; % width
            for i in range(self.nobjects):
                flags = &#34;(&#34;+self.objects[names[i]].shortflags+&#34;)&#34; if self.objects[names[i]].flags else &#34;(no script)&#34;
                if isinstance(self.objects[names[i]],Collection):
                        print(fmt % names[i],&#34; %s region (%d beadtypes)&#34; % \
                              (self.objects[names[i]].kind,len(self.objects[names[i]].beadtype)),&#34; &gt; &#34;,flags)
                else:
                    print(fmt % names[i],&#34; %s region (beadtype=%d)&#34; % \
                          (self.objects[names[i]].kind,self.objects[names[i]].beadtype),&#34; &gt; &#34;,flags)
            print(wrap(&#34;they are&#34;,&#34;:&#34;,&#34;, &#34;.join(self.names),10,60,80))
        print(&#34;-&#34;*40)
        return &#34;REGION container %s with %d objects (%s)&#34; % \
            (self.name,self.nobjects,&#34;,&#34;.join(self.names))

    # str() method ----------------------------
    def __str__(self):
        &#34;&#34;&#34; string representation of a region &#34;&#34;&#34;
        return &#34;REGION container %s with %d objects (%s)&#34; % \
            (self.name,self.nobjects,&#34;,&#34;.join(self.names))

    # generic GET method ----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.objects:
            return self.objects[name]
        else:
            raise NameError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # getattr() method ----------------------------
    def __getattr__(self,name):
        &#34;&#34;&#34; getattr attribute override &#34;&#34;&#34;
        if (name in self.__dict__) or (name in protectedregionkeys):
            return self.__dict__[name] # higher precedence for root attributes
        if name in protectedregionkeys:
            return getattr(type(self), name).__get__(self) # for methods decorated as properties (@property)
        # Handle special cases like __wrapped__ explicitly
        if name == &#34;__wrapped__&#34;:
            return None  # Default value or appropriate behavior
        # Leave legitimate __dunder__ attributes to the default mechanism
        if name.startswith(&#34;__&#34;) and name.endswith(&#34;__&#34;):
            raise AttributeError(f&#34;{type(self).__name__!r} object has no attribute {name!r}&#34;)
        # Default
        return self.get(name)

    # generic SET method ----------------------------
    def set(self,name,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0:
            if name not in self.objects:
                raise NameError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)
            self.delete(name)
        elif isinstance(value,coregeometry):
            if name in self.objects: self.delete(name)
            if isinstance(value.SECTIONS,pipescript) or isinstance(value,Evalgeometry):
                self.eval(deepduplicate(value),name) # not a scalar
            else: # scalar
                self.objects[name] = deepduplicate(value)
                self.objects[name].name = name
                self.nobjects += 1
                self.counter[&#34;all&#34;] += 1
                self.objects[name].index = self.counter[&#34;all&#34;]
                self.counter[value.kind] += 1

    # setattr() method ----------------------------
    def __setattr__(self,name,value):
        &#34;&#34;&#34; setattr override &#34;&#34;&#34;
        if name in protectedregionkeys: # do not forget to increment protectedregionkeys
            self.__dict__[name] = value # if not, you may enter in infinite loops
        else:
            self.set(name,value)

    # generic HASATTR method ----------------------------
    def hasattr(self,name):
        &#34;&#34;&#34; return true if the object exist &#34;&#34;&#34;
        if not isinstance(name,str): raise TypeError(&#34;please provide a string&#34;)
        return name in self.objects

    # IN operator ----------------------------
    def __contains__(self,obj):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(obj)

    # len() method ----------------------------
    def __len__(self):
        &#34;&#34;&#34; len method &#34;&#34;&#34;
        return len(self.objects)

    # indexing [int] and [&#34;str&#34;] method ----------------------------
    def __getitem__(self,idx):
        &#34;&#34;&#34;
            R[i] returns the ith element of the structure
            R[:4] returns a structure with the four first fields
            R[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.get(self.names[idx])
            raise IndexError(f&#34;the index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,str):
            if idx in self:
                return self.get(idx)
            raise NameError(f&#39;{idx} does not exist, use list() to list objects&#39;)
        elif isinstance(idx,list):
            pass
        elif isinstance(idx,slice):
            return self.__getitem__(self,list(range(*idx.indices(len(self)))))
        else:
            raise IndexError(&#34;not implemented yet&#34;)

    # duplication GET method based on DICT ----------------------------
    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    # duplication SET method based on DICT ----------------------------
    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    # iterator method ----------------------------
    def __iter__(self):
        &#34;&#34;&#34; region iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    # next iterator method ----------------------------
    def __next__(self):
        &#34;&#34;&#34; region iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum region.objects iteration reached {len(self)}&#34;)


    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    #
    # MIDDLE-LEVEL METHODS
    #
    #
    # These methods are specific to PIZZA.REGION() objects.
    # They bring useful methods for the user and developer.
    # Similar methods exist in PIZZA.RASTER()
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

    # LIST method ----------------------------
    def list(self):
        &#34;&#34;&#34; list objects &#34;&#34;&#34;
        fmt = &#34;%%%ss:&#34; % max(10,max([len(n) for n in self.names])+2)
        print(&#39;REGION container &#34;%s&#34; with %d objects&#39; % (self.name,self.nobjects))
        for o in self.objects.keys():
            print(fmt % self.objects[o].name,&#34;%-10s&#34; % self.objects[o].kind,
                  &#34;(beadtype=%d,object index=[%d,%d])&#34; % \
                      (self.objects[o].beadtype,
                       self.objects[o].index,
                       self.objects[o].subindex))

    # NAMES method set as an attribute ----------------------------
    @property
    def names(self):
        &#34;&#34;&#34; return the names of objects sorted as index &#34;&#34;&#34;
        namesunsorted=namessorted=list(self.objects.keys())
        nobj = len(namesunsorted)
        if nobj&lt;1:
            return []
        elif nobj&lt;2:
            return namessorted
        else:
            for iobj in range(nobj):
                namessorted[self.objects[namesunsorted[iobj]].index-1] = namesunsorted[iobj]
            return namessorted

    # NBEADS method set as an attribute
    @property
    def nbeads(self):
        &#34;return the number of beadtypes used&#34;
        if len(self)&gt;0:
            guess = max(len(self.count()),self.live.nbeads)
            return guess+1 if self.isspacefilled else guess
        else:
            return self.live.nbeads

    # COUNT method
    def count(self):
        &#34;&#34;&#34; count objects by type &#34;&#34;&#34;
        typlist = []
        for  o in self.names:
            if isinstance(self.objects[o].beadtype,list):
                typlist += self.objects[o].beadtype
            else:
                typlist.append(self.objects[o].beadtype)
        utypes = list(set(typlist))
        c = []
        for t in utypes:
            c.append((t,typlist.count(t)))
        return c

    # BEADTYPES property
    @property
    def beadtypes(self):
        &#34;&#34;&#34; list the beadtypes &#34;&#34;&#34;
        return [ x[0] for x in self.count() ]

    # DELETE method
    def delete(self,name):
        &#34;&#34;&#34; delete object &#34;&#34;&#34;
        if name in self.objects:
            kind = self.objects[name].kind
            del self.objects[name]
            self.nobjects -= 1
            self.counter[kind] -= 1
            self.counter[&#34;all&#34;] -= 1
        else:
            raise NameError(&#34;%s does not exist (use list()) to list valid objects&#34; % name)

    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
    #
    # HIGH-LEVEL METHODS
    #
    #
    # These methods are connect PIZZA.REGION() objects with their equivalent
    # as PIZZA.SCRIPT() and PIZZA.PIPESCRIPT() objects and methods.
    #
    # They are essential to PIZZA.REGION(). They do not have equivalent in
    # PIZZA.RASTER(). They use extensively the methods attached to :
    #        PIZZA.REGION.LAMMPSGENERIC()
    #        PIZZA.REGION.COREGEOMETRY()
    #
    # Current real-time rendering relies on
    #   https://andeplane.github.io/atomify/
    # which gives better results than
    #   https://editor.lammps.org/
    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

    # EVALUATE algebraic operation on PIZZA.REGION() objects (operation on codes)
    def eval(self,expression,name=None,beadtype = None,
             fake=False,index = None,subindex = None):
        &#34;&#34;&#34;
            evaluates (i.e, combine scripts) an expression combining objects
                R= region(name=&#34;my region&#34;)
                R.eval(o1+o2+...,name=&#39;obj&#39;)
                R.eval(o1|o2|...,name=&#39;obj&#39;)
            R.name will be the resulting object of class region.eval (region.coregeometry)
        &#34;&#34;&#34;
        if not isinstance(expression, coregeometry): raise TypeError(&#34;the argument should be a region.coregeometry&#34;)
        # prepare object creation
        kind = &#34;eval&#34;
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        if index is None: index = self.counter[&#34;all&#34;]
        if subindex is None: subindex = self.counter[kind]
        # create the object E with E for Ellipsoid
        E = Evalgeometry((self.counter[&#34;all&#34;],self.counter[kind]),
                      index=index,subindex=subindex)
        # link expression to E
        if beadtype is not None: E.beadtype = beadtype # bead type (if not defined, default index will apply)
        if name is None: name = expression.name
        if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
        E.name = name
        E.SECTIONS = expression.SECTIONS
        E.USER = expression.USER
        if isinstance(E.SECTIONS,pipescript):
            # set beadtypes for all sections and scripts in the pipeline
            for i in E.SECTIONS.keys():
                for j in range(len(E.SECTIONS[i])):
                    E.SECTIONS[i].USER[j].beadtype = E.beadtype
        E.USER.beadtype = beadtype
        # Create the object if not fake
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[kind] -= 1
            return E
        else:
            self.objects[name] = E
            self.nobjects += 1
            return None

    # PIPESCRIPT method generates a pipe for all objects and sections
    def pipescript(self,printflag=False,verbose=False,verbosity=0):
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        &#34;&#34;&#34; pipescript all objects in the region &#34;&#34;&#34;
        if len(self)&lt;1: return pipescript()
        # execute all objects
        for myobj in self:
            if not isinstance(myobj,Collection): myobj.do(printflag=printflag,verbosity=verbosity)
        # concatenate all objects into a pipe script
        # for collections, only group is accepted
        liste = [x.SECTIONS[&#34;variables&#34;] for x in self if not isinstance(x,Collection) and x.hasvariables] + \
                [x.SECTIONS[&#34;region&#34;]    for x in self if not isinstance(x,Collection) and x.hasregion] + \
                [x.SECTIONS[&#34;create&#34;]    for x in self if not isinstance(x,Collection) and x.hascreate] + \
                [x.SECTIONS[&#34;group&#34;]     for x in self if not isinstance(x,Collection) and x.hasgroup] + \
                [x.SECTIONS[&#34;setgroup&#34;]  for x in self if not isinstance(x,Collection) and x.hassetgroup] + \
                [x.SECTIONS[&#34;move&#34;]      for x in self if not isinstance(x,Collection) and x.hasmove]
        # add the objects within the collection
        for x in self:
            if isinstance(x,Collection): liste += x.group()
        # add the eventual group for the collection
        liste += [x.SECTIONS[&#34;group&#34;] for x in self if isinstance(x,Collection) and x.hasgroup]
        # chain all scripts
        return pipescript.join(liste)

    # SCRIPT add header and footer to PIPECRIPT
    def script(self,live=False, printflag=None, verbose=None, verbosity=None):
        &#34;&#34;&#34; script all objects in the region &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        s = self.pipescript(printflag=printflag,verbose=verbose,verbosity=verbosity).script(printflag=printflag,verbose=verbose,verbosity=verbosity)
        if self.isspacefilled:
            USERspacefilling =regiondata(**self.spacefilling)
            s = LammpsSpacefilling(**USERspacefilling)+s
        if live:
            beadtypes = self.beadtypes
            USER = regiondata(**self.live)
            USER.nbeads = self.nbeads
            USER.mass = &#34;$&#34;
            USER.pair_coeff = &#34;$&#34;
            # list beadtype and prepare  mass, pair_coeff
            beadtypes = [ x[0] for x in self.count() ]
            if self.isspacefilled and self.spacefillingbeadtype not in beadtypes:
                beadtypes = [self.spacefillingbeadtype]+beadtypes
            for b in beadtypes:
                USER.mass += livetemplate[&#34;mass&#34;] % b +&#34;\n&#34;
                USER.pair_coeff += livetemplate[&#34;pair_coeff&#34;] %(b,b) +&#34;\n&#34;
            for b1 in beadtypes:
                for b2 in beadtypes:
                    if b2&gt;b1:
                        USER.pair_coeff += livetemplate[&#34;pair_coeff&#34;] %(b1,b2) +&#34;\n&#34;
            livemode = &#34;dynamic&#34; if self.hasfixmove else &#34;static&#34;
            USER.run =self.livelammps[&#34;options&#34;][livemode][&#34;run&#34;]
            s = LammpsHeader(**USER)+s+LammpsFooter(**USER)
        return s

    # SCRIPTHEADERS add header scripts for initializing script, lattice, box for region
    def scriptHeaders(self, what=[&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;], pipescript=False, **userdefinitions):
        &#34;&#34;&#34;
            Generate and return LAMMPS header scripts for initializing the simulation, defining the lattice,
            and specifying the simulation box for all region objects.

            Parameters:
            - what (list of str): Specifies which scripts to generate. Options are &#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;, &#34;mass&#34; and &#34;preview&#34;.
                                  Multiple scripts can be generated by passing a list of these options.
                                  Default is [&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;].
            - pipescript (bool): If True, the generated scripts are combined with `|` instead of `+`. Default is False.

            Property/pair value
            - nbeads (int): Specifies the number of beads, overriding the default if larger than `self.nbeads`.
                            Default is 1.
            - mass (real value or list): Sets the mass for each bead, overrriding `self.mass`
                            Default is 1.0.


            Returns:
            - object: The combined header scripts as a single object.
                      Header values can be overridden by updating `self.headersData`.

            Raises:
            - Exception: If no valid script options are provided in `what`.

            Example usage:
                sRheader = R.scriptHeaders(&#34;box&#34;).do()  # Generate the box header script.
                sRallheaders = R.scriptHeaders([&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;])  # Generate all headers.

                Example usage without naming parameters:
                sRheader = R.scriptHeaders(&#34;box&#34;)  # &#34;what&#34; specified as &#34;box&#34;, nbeads defaults to 1.

                Example of overriding values
                sRheader = R.scriptHeaders(&#34;lattice&#34;,lattice_style = &#34;$sq&#34;)  # Generate the lattice header script with the overridden value.
        &#34;&#34;&#34;
        # handle overrides
        USERregion = self.headersData + regiondata(**userdefinitions)
        # Fix singletons
        if not isinstance(what, list):
            what = [what]
        # Generate the initialization script
        scripts = []  # Store all generated script objects here
        if &#34;init&#34; in what:
            scripts.append(LammpsHeaderInit(**USERregion))
        # Generate the lattice script
        if &#34;lattice&#34; in what:
            scripts.append(LammpsHeaderLattice(**USERregion))
        # Generate the box script
        if &#34;box&#34; in what:
            scripts.append(LammpsHeaderBox(**USERregion))
            if self.isspacefilled:
                scripts.append(LammpsSpacefilling(**self.spacefilling))
        # Generate the mass script
        if &#34;mass&#34; in what:
            scripts.append(LammpsHeaderMass(**USERregion))
        # Generate the preview script
        if &#34;preview&#34; in what:
            scripts.append(LammpsFooterPreview(**USERregion))
        if not scripts:
            raise Exception(&#39;nothing to do (use: &#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;, &#34;mass&#34; or &#34;preview&#34; within [ ])&#39;)

        # Combine the scripts based on the pipescript flag
        combined_script = scripts[0]  # Initialize the combined script with the first element
        for script in scripts[1:]:
            if pipescript:
                # Combine scripts using the | operator, maintaining pipescript format
                combined_script = combined_script | script  # p_ab = s_a | s_b or p_ab = s_a | p_b
            else:
                # Combine scripts using the + operator, maintaining regular script format
                combined_script = combined_script + script  # s_ab = s_a + s_b
        return combined_script


    def pscriptHeaders(self, what=[&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;], **userdefinitions):
        &#34;&#34;&#34;
        Surrogate method for generating LAMMPS pipescript headers.
        Calls the `scriptHeaders` method with `pipescript=True`.

        Parameters:
        - what (list of str): Specifies which scripts to generate. Options are &#34;init&#34;, &#34;lattice&#34;, and &#34;box&#34;.
                              Multiple scripts can be generated by passing a list of these options.
                              Default is [&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;].
        Property/pair value
        - nbeads (int): Specifies the number of beads, overriding the default if larger than `self.nbeads`.
                        Default is 1.
        - mass (real value or list): Sets the mass for each bead, overrriding `self.mass`
                        Default is 1.0.
        Returns:
        - object: The combined pipescript header scripts as a single object.
        &#34;&#34;&#34;
        # Call scriptHeaders with pipescript=True
        return self.scriptHeaders(what=what, pipescript=True, **userdefinitions)


    # DO METHOD = main static compiler
    def do(self, printflag=False, verbosity=1):
        &#34;&#34;&#34; execute the entire script &#34;&#34;&#34;
        return self.pipescript().do(printflag=printflag, verbosity=verbosity)

    # DOLIVE = fast code generation for online rendering
    def dolive(self):
        &#34;&#34;&#34;
            execute the entire script for online testing
            see: https://editor.lammps.org/
        &#34;&#34;&#34;
        self.livelammps[&#34;file&#34;] = self.script(live=True).tmpwrite()
        if not self.livelammps[&#34;active&#34;]:
            livelammps(self.livelammps[&#34;URL&#34;],new=0)
            self.livelammps[&#34;active&#34;] = True
        return self.livelammps[&#34;file&#34;]</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="region.region.beadtypes"><code class="name">var <span class="ident">beadtypes</span></code></dt>
<dd>
<div class="desc"><p>list the beadtypes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beadtypes(self):
    &#34;&#34;&#34; list the beadtypes &#34;&#34;&#34;
    return [ x[0] for x in self.count() ]</code></pre>
</details>
</dd>
<dt id="region.region.geometry"><code class="name">var <span class="ident">geometry</span></code></dt>
<dd>
<div class="desc"><p>Display the dimensions and characteristics of the region and its objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def geometry(self):
    &#34;&#34;&#34;Display the dimensions and characteristics of the region and its objects.&#34;&#34;&#34;
    details = f&#34;Region: {self.name}\n&#34;
    details += f&#34;Total atoms: {self.natoms}\n&#34;
    details += f&#34;Span: width={self.spacefilling[&#39;fillingwidth&#39;]}, height={self.spacefilling[&#39;fillingheight&#39;]}, depth={self.spacefilling[&#39;fillingdepth&#39;]}\n&#34;
    details += f&#34;Box center: {self.center}\n&#34;
    details += &#34;Objects in the region:\n\n&#34;
    for obj in self:
        details += &#34;\n\n&#34;+&#34;-&#34;*32+&#34;\n&#34;
        details += f&#34;\nObject: {obj.name}\n&#34;
        details += f&#34;Type: {type(obj).__name__}\n&#34;
        if hasattr(obj, &#39;geometry&#39;):
            details += &#34;\n&#34;+&#34;-&#34;*32+&#34;\n&#34;
            details += obj.geometry
        else:
            details += &#34;No geometry information available.\n&#34;
    print(details)</code></pre>
</details>
</dd>
<dt id="region.region.isspacefilled"><code class="name">var <span class="ident">isspacefilled</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isspacefilled(self):
    return self.spacefilling[&#34;flag&#34;]</code></pre>
</details>
</dd>
<dt id="region.region.names"><code class="name">var <span class="ident">names</span></code></dt>
<dd>
<div class="desc"><p>return the names of objects sorted as index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def names(self):
    &#34;&#34;&#34; return the names of objects sorted as index &#34;&#34;&#34;
    namesunsorted=namessorted=list(self.objects.keys())
    nobj = len(namesunsorted)
    if nobj&lt;1:
        return []
    elif nobj&lt;2:
        return namessorted
    else:
        for iobj in range(nobj):
            namessorted[self.objects[namesunsorted[iobj]].index-1] = namesunsorted[iobj]
        return namessorted</code></pre>
</details>
</dd>
<dt id="region.region.natoms"><code class="name">var <span class="ident">natoms</span></code></dt>
<dd>
<div class="desc"><p>Count the total number of atoms in all objects within the region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def natoms(self):
    &#34;&#34;&#34;Count the total number of atoms in all objects within the region.&#34;&#34;&#34;
    total_atoms = 0
    for eachobj in self:
        total_atoms += eachobj.natoms
    return total_atoms</code></pre>
</details>
</dd>
<dt id="region.region.nbeads"><code class="name">var <span class="ident">nbeads</span></code></dt>
<dd>
<div class="desc"><p>return the number of beadtypes used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nbeads(self):
    &#34;return the number of beadtypes used&#34;
    if len(self)&gt;0:
        guess = max(len(self.count()),self.live.nbeads)
        return guess+1 if self.isspacefilled else guess
    else:
        return self.live.nbeads</code></pre>
</details>
</dd>
<dt id="region.region.spacefillingbeadtype"><code class="name">var <span class="ident">spacefillingbeadtype</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spacefillingbeadtype(self):
    return self.spacefilling[&#34;fillingbeadtype&#34;]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.region.block"><code class="name flex">
<span>def <span class="ident">block</span></span>(<span>self, xlo=-5, xhi=5, ylo=-5, yhi=5, zlo=-5, zhi=5, name=None, beadtype=None, fake=False, mass=None, density=None, side=None, units=None, move=None, rotate=None, open=None, index=None, subindex=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a block region
xlo,xhi,ylo,yhi,zlo,zhi = bounds of block in all dimensions (distance units)</p>
<pre><code>   URL: &lt;https://docs.lammps.org/region.html&gt;

   Main properties = default value
       name = "block001"
   beadtype = 1
       fake = False (use True to test the execution)
</code></pre>
<p>index, subindex = object index and subindex</p>
<pre><code>   Extra properties
       side = "in|out"
      units = "lattice|box" ("box" is forced if regionunits=="si")
       move = "[${v1} ${v2} ${v3}]" or [v1,v2,v3] as a list
              with v1,v2,v3 equal-style variables for x,y,z displacement
              of region over time (distance units)
     rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
              vtheta = equal-style variable for rotation of region over time (in radians)
              Px,Py,Pz = origin for axis of rotation (distance units)
              Rx,Ry,Rz = axis of rotation vector
       open = integer from 1-6 corresponding to face index

   See examples for elliposid()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block(self,xlo=-5,xhi=5,ylo=-5,yhi=5,zlo=-5,zhi=5,
              name=None,beadtype=None,fake=False,
              mass=None, density=None,
              side=None,units=None,move=None,rotate=None,open=None,
              index = None,subindex = None,
              **variables
              ):
    &#34;&#34;&#34;
    creates a block region
        xlo,xhi,ylo,yhi,zlo,zhi = bounds of block in all dimensions (distance units)

        URL: https://docs.lammps.org/region.html

        Main properties = default value
            name = &#34;block001&#34;
        beadtype = 1
            fake = False (use True to test the execution)
 index, subindex = object index and subindex

        Extra properties
            side = &#34;in|out&#34;
           units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
            move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                   with v1,v2,v3 equal-style variables for x,y,z displacement
                   of region over time (distance units)
          rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                   vtheta = equal-style variable for rotation of region over time (in radians)
                   Px,Py,Pz = origin for axis of rotation (distance units)
                   Rx,Ry,Rz = axis of rotation vector
            open = integer from 1-6 corresponding to face index

        See examples for elliposid()
    &#34;&#34;&#34;
    # prepare object creation
    kind = &#34;block&#34;
    if index is None: index = self.counter[&#34;all&#34;]+1
    if subindex is None: subindex = self.counter[kind]+1
    units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
    # create the object B with B for block
    obj_mass = mass if mass is not None else self.mass
    obj_density = density if density is not None else self.density
    B = Block((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                  spacefilling=self.isspacefilled, # added on 2023-08-11
                  mass=obj_mass, density=obj_density, # added on 2024-06-14
                  index=index,subindex=subindex,
                  lattice_style=self.lattice_style,
                  lattice_scale=self.lattice_scale,
                  lattice_scale_siunits=self.lattice_scale_siunits,
                  **variables)
    # feed USER fields
    if name not in (None,&#34;&#34;): B.name = name # object name (if not defined, default name will be used)
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    if beadtype is not None: B.beadtype = beadtype # bead type (if not defined, default index will apply)
    B.USER.ID = &#34;$&#34;+B.name        # add $ to prevent its execution
    # geometry args (2024-07-04)  -------------------------------------
    args = [xlo, xhi, ylo, yhi, zlo, zhi]  # args = [....] as defined in the class Block
    args_scaled = [
        self.scale_and_translate(xlo, self.center[0]),
        self.scale_and_translate(xhi, self.center[0]),
        self.scale_and_translate(ylo, self.center[1]),
        self.scale_and_translate(yhi, self.center[1]),
        self.scale_and_translate(zlo, self.center[2]),
        self.scale_and_translate(zhi, self.center[2])
    ]
    if self.units == &#34;si&#34;:
        B.USER.args = args_scaled
        B.USER.args_siunits = args
    else:  # &#34;lattice&#34;
        B.USER.args = args
        B.USER.args_siunits = args_scaled
    # geometry
    B.USER.geometry = (
        f&#34;Block Region: {B.name}\n&#34;
        &#34;Coordinates: [xlo,xhi,ylo,yhi,zlo,zhi] = bounds of block in all dimensions&#34;
        f&#34;Coordinates (scaled): {B.USER.args}\n&#34;
        f&#34;Coordinates (SI units): {B.USER.args_siunits}\n&#34;
        f&#34;\talong x: [{B.USER.args[0]}, {B.USER.args[1]}]\n&#34;
        f&#34;\talong y: [{B.USER.args[2]}, {B.USER.args[3]}]\n&#34;
        f&#34;\talong z: [{B.USER.args[4]}, {B.USER.args[5]}]&#34;
    )
    # other attributes  -------------------------------------
    B.USER.beadtype = B.beadtype  # beadtype to be used for create_atoms
    B.USER.side = B.sidearg(side) # extra parameter side
    B.USER.move = B.movearg(move) # move arg
    B.USER.units = B.unitsarg(units) # units
    B.USER.rotate = B.rotatearg(rotate) # rotate
    B.USER.open = B.openarg(open) # open
    # Create the object if not fake
    if fake:
        return B
    else:
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        self.objects[name] = B
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="region.region.collection"><code class="name flex">
<span>def <span class="ident">collection</span></span>(<span>self, *obj, name=None, beadtype=None, fake=False, index=None, subindex=None, **kwobj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collection(self,*obj,name=None,beadtype=None,fake=False,
          index = None,subindex = None,
          **kwobj):
    kind = &#34;collection&#34;
    if index is None: index = self.counter[&#34;all&#34;]+1
    if subindex is None: subindex = self.counter[kind]+1
    # create the object C with C for collection
    C = Collection((index,subindex))
    if name not in (None,&#34;&#34;): C.name = name # object name (if not defined, default name will be used)
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    if beadtype is not None: C.beadtype = beadtype # bead type (if not defined, default index will apply)
    # add objects
    C.collection = regioncollection(*obj,**kwobj)
    # apply modifications (beadtype, ismask)
    for o in C.collection.keys():
        tmp = C.collection.getattr(o)
        if beadtype != None: tmp.beadtype = beadtype
        C.collection.setattr(o,tmp)
    # Create the object if not fake
    if fake:
        return C
    else:
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        self.objects[name] = C
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="region.region.cone"><code class="name flex">
<span>def <span class="ident">cone</span></span>(<span>self, dim='z', c1=0, c2=0, radlo=2, radhi=5, lo=-10, hi=10, name=None, beadtype=None, fake=False, mass=None, density=None, side=None, units=None, move=None, rotate=None, open=None, index=None, subindex=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a cone region
dim = "x" or "y" or "z" = axis of the cone
note: USER, LAMMPS variables are not authorized here
c1,c2 = coords of cone axis in other 2 dimensions (distance units)
radlo,radhi = cone radii at lo and hi end (distance units)
lo,hi = bounds of cone in dim (distance units)</p>
<pre><code>   URL: &lt;https://docs.lammps.org/region.html&gt;

   Main properties = default value
       name = "cone001"
   beadtype = 1
       fake = False (use True to test the execution)
</code></pre>
<p>index, subindex = object index and subindex</p>
<pre><code>   Extra properties
       side = "in|out"
      units = "lattice|box" ("box" is forced if regionunits=="si")
       move = "[${v1} ${v2} ${v3}]" or [v1,v2,v3] as a list
              with v1,v2,v3 equal-style variables for x,y,z displacement
              of region over time (distance units)
     rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
              vtheta = equal-style variable for rotation of region over time (in radians)
              Px,Py,Pz = origin for axis of rotation (distance units)
              Rx,Ry,Rz = axis of rotation vector
       open = integer from 1-6 corresponding to face index

   See examples for elliposid()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cone(self,dim=&#34;z&#34;,c1=0,c2=0,radlo=2,radhi=5,lo=-10,hi=10,
              name=None,beadtype=None,fake=False,
              mass=None, density=None,
              side=None,units=None,move=None,rotate=None,open=None,
              index = None,subindex = None,
              **variables
              ):
    &#34;&#34;&#34;
    creates a cone region
        dim = &#34;x&#34; or &#34;y&#34; or &#34;z&#34; = axis of the cone
             note: USER, LAMMPS variables are not authorized here
        c1,c2 = coords of cone axis in other 2 dimensions (distance units)
        radlo,radhi = cone radii at lo and hi end (distance units)
        lo,hi = bounds of cone in dim (distance units)

        URL: https://docs.lammps.org/region.html

        Main properties = default value
            name = &#34;cone001&#34;
        beadtype = 1
            fake = False (use True to test the execution)
 index, subindex = object index and subindex

        Extra properties
            side = &#34;in|out&#34;
           units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
            move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                   with v1,v2,v3 equal-style variables for x,y,z displacement
                   of region over time (distance units)
          rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                   vtheta = equal-style variable for rotation of region over time (in radians)
                   Px,Py,Pz = origin for axis of rotation (distance units)
                   Rx,Ry,Rz = axis of rotation vector
            open = integer from 1-6 corresponding to face index

        See examples for elliposid()
    &#34;&#34;&#34;
    # prepare object creation
    kind = &#34;cone&#34;
    if index is None: index = self.counter[&#34;all&#34;]+1
    if subindex is None: subindex = self.counter[kind]+1
    units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
    # create the object C with C for cone
    obj_mass = mass if mass is not None else self.mass
    obj_density = density if density is not None else self.density
    C = Cone((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                  spacefilling=self.isspacefilled, # added on 2023-08-11
                  mass=obj_mass, density=obj_density, # added on 2024-06-14
                  index=index,subindex=subindex,
                  lattice_style=self.lattice_style,
                  lattice_scale=self.lattice_scale,
                  lattice_scale_siunits=self.lattice_scale_siunits,
                  **variables)
    # feed USER fields
    if name not in (None,&#34;&#34;): C.name = name # object name (if not defined, default name will be used)
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    if beadtype is not None: C.beadtype = beadtype # bead type (if not defined, default index will apply)
    C.USER.ID = &#34;$&#34;+C.name        # add $ to prevent its execution
    # geometry args (2024-07-04)  -------------------------------------
    args = [dim, c1, c2, radlo, radhi, lo, hi]  # args = [....] as defined in the class Cone
    if dim == &#34;x&#34;:  # x-axis
        args_scaled = [
            dim,
            self.scale_and_translate(c1, self.center[1]),
            self.scale_and_translate(c2, self.center[2]),
            self.scale_and_translate(radlo, 0),
            self.scale_and_translate(radhi, 0),
            self.scale_and_translate(lo, self.center[0]),
            self.scale_and_translate(hi, self.center[0])
        ]
    elif dim == &#34;y&#34;:  # y-axis
        args_scaled = [
            dim,
            self.scale_and_translate(c1, self.center[0]),
            self.scale_and_translate(c2, self.center[2]),
            self.scale_and_translate(radlo, 0),
            self.scale_and_translate(radhi, 0),
            self.scale_and_translate(lo, self.center[1]),
            self.scale_and_translate(hi, self.center[1])
        ]
    else:  # z-axis
        args_scaled = [
            dim,
            self.scale_and_translate(c1, self.center[0]),
            self.scale_and_translate(c2, self.center[1]),
            self.scale_and_translate(radlo, 0),
            self.scale_and_translate(radhi, 0),
            self.scale_and_translate(lo, self.center[2]),
            self.scale_and_translate(hi, self.center[2])
        ]

    if self.units == &#34;si&#34;:
        C.USER.args = args_scaled
        C.USER.args_siunits = args
    else:  # &#34;lattice&#34;
        C.USER.args = args
        C.USER.args_siunits = args_scaled
    # geometry
    C.USER.geometry = (
        f&#34;Cone Region: {C.name}\n&#34;
        &#34;Coordinates: [dim,c1,c2,radlo,radhi,lo,hi] = dimensions of cone\n&#34;
        f&#34;Coordinates (scaled): {C.USER.args}\n&#34;
        f&#34;Coordinates (SI units): {C.USER.args_siunits}\n&#34;
        f&#34;\tdim: {C.USER.args[0]}\n&#34;
        f&#34;\tc1: {C.USER.args[1]}\n&#34;
        f&#34;\tc2: {C.USER.args[2]}\n&#34;
        f&#34;\tradlo: {C.USER.args[3]}\n&#34;
        f&#34;\tradhi: {C.USER.args[4]}\n&#34;
        f&#34;\tlo: {C.USER.args[5]}\n&#34;
        f&#34;\thi: {C.USER.args[6]}&#34;
    )
    # other attributes  -------------------------------------
    C.USER.beadtype = C.beadtype  # beadtype to be used for create_atoms
    C.USER.side = C.sidearg(side) # extra parameter side
    C.USER.move = C.movearg(move) # move arg
    C.USER.units = C.unitsarg(units) # units
    C.USER.rotate = C.rotatearg(rotate) # rotate
    C.USER.open = C.openarg(open) # open
    # Create the object if not fake
    if fake:
        return C
    else:
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        self.objects[name] = C
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="region.region.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>count objects by type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self):
    &#34;&#34;&#34; count objects by type &#34;&#34;&#34;
    typlist = []
    for  o in self.names:
        if isinstance(self.objects[o].beadtype,list):
            typlist += self.objects[o].beadtype
        else:
            typlist.append(self.objects[o].beadtype)
    utypes = list(set(typlist))
    c = []
    for t in utypes:
        c.append((t,typlist.count(t)))
    return c</code></pre>
</details>
</dd>
<dt id="region.region.cylinder"><code class="name flex">
<span>def <span class="ident">cylinder</span></span>(<span>self, dim='z', c1=0, c2=0, radius=4, lo=-10, hi=10, name=None, beadtype=None, fake=False, mass=None, density=None, side=None, units=None, move=None, rotate=None, open=None, index=None, subindex=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a cylinder region
dim = x or y or z = axis of cylinder
c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)
radius = cylinder radius (distance units)
c1,c2, and radius can be a LAMMPS variable
lo,hi = bounds of cylinder in dim (distance units)</p>
<pre><code>   URL: &lt;https://docs.lammps.org/region.html&gt;

   Main properties = default value
       name = "cylinder001"
   beadtype = 1
       fake = False (use True to test the execution)
</code></pre>
<p>index, subindex = object index and subindex</p>
<pre><code>   Extra properties
       side = "in|out"
      units = "lattice|box" ("box" is forced if regionunits=="si")
       move = "[${v1} ${v2} ${v3}]" or [v1,v2,v3] as a list
              with v1,v2,v3 equal-style variables for x,y,z displacement
              of region over time (distance units)
     rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
              vtheta = equal-style variable for rotation of region over time (in radians)
              Px,Py,Pz = origin for axis of rotation (distance units)
              Rx,Ry,Rz = axis of rotation vector
       open = integer from 1-6 corresponding to face index

   See examples for elliposid()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cylinder(self,dim=&#34;z&#34;,c1=0,c2=0,radius=4,lo=-10,hi=10,
              name=None,beadtype=None,fake=False,
              mass=None, density=None,
              side=None,units=None,move=None,rotate=None,open=None,
              index = None,subindex = None,
              **variables
              ):
    &#34;&#34;&#34;
    creates a cylinder region
          dim = x or y or z = axis of cylinder
          c1,c2 = coords of cylinder axis in other 2 dimensions (distance units)
          radius = cylinder radius (distance units)
          c1,c2, and radius can be a LAMMPS variable
          lo,hi = bounds of cylinder in dim (distance units)

        URL: https://docs.lammps.org/region.html

        Main properties = default value
            name = &#34;cylinder001&#34;
        beadtype = 1
            fake = False (use True to test the execution)
 index, subindex = object index and subindex

        Extra properties
            side = &#34;in|out&#34;
           units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
            move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                   with v1,v2,v3 equal-style variables for x,y,z displacement
                   of region over time (distance units)
          rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                   vtheta = equal-style variable for rotation of region over time (in radians)
                   Px,Py,Pz = origin for axis of rotation (distance units)
                   Rx,Ry,Rz = axis of rotation vector
            open = integer from 1-6 corresponding to face index

        See examples for elliposid()
    &#34;&#34;&#34;
    # prepare object creation
    kind = &#34;cylinder&#34;
    if index is None: index = self.counter[&#34;all&#34;]+1
    if subindex is None: subindex = self.counter[kind]+1
    units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
    # create the object C with C for cylinder
    obj_mass = mass if mass is not None else self.mass
    obj_density = density if density is not None else self.density
    C = Cylinder((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                  spacefilling=self.isspacefilled, # added on 2023-08-11
                  mass=obj_mass, density=obj_density,
                  index=index,subindex=subindex,
                  lattice_style=self.lattice_style,
                  lattice_scale=self.lattice_scale,
                  lattice_scale_siunits=self.lattice_scale_siunits,
                  **variables)
    # feed USER fields
    if name not in (None,&#34;&#34;): C.name = name # object name (if not defined, default name will be used)
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    if beadtype is not None: C.beadtype = beadtype # bead type (if not defined, default index will apply)
    C.USER.ID = &#34;$&#34;+C.name        # add $ to prevent its execution
    # geometry args (2024-07-04)  -------------------------------------
    args = [dim, c1, c2, radius, lo, hi]  # args = [....] as defined in the class Cylinder
    if dim == &#34;x&#34;:  # x-axis
        args_scaled = [
            dim,
            self.scale_and_translate(c1, self.center[1]),
            self.scale_and_translate(c2, self.center[2]),
            self.scale_and_translate(radius, 0),
            self.scale_and_translate(lo, self.center[0]),
            self.scale_and_translate(hi, self.center[0])
        ]
    elif dim == &#34;y&#34;:  # y-axis
        args_scaled = [
            dim,
            self.scale_and_translate(c1, self.center[0]),
            self.scale_and_translate(c2, self.center[2]),
            self.scale_and_translate(radius, 0),
            self.scale_and_translate(lo, self.center[1]),
            self.scale_and_translate(hi, self.center[1])
        ]
    else:  # z-axis
        args_scaled = [
            dim,
            self.scale_and_translate(c1, self.center[0]),
            self.scale_and_translate(c2, self.center[1]),
            self.scale_and_translate(radius, 0),
            self.scale_and_translate(lo, self.center[2]),
            self.scale_and_translate(hi, self.center[2])
        ]
    if self.units == &#34;si&#34;:
        C.USER.args = args_scaled
        C.USER.args_siunits = args
    else:  # &#34;lattice&#34;
        C.USER.args = args
        C.USER.args_siunits = args_scaled
    # geometry
    C.USER.geometry = (
        f&#34;Cylinder Region: {C.name}\n&#34;
        &#34;Coordinates: [dim,c1,c2,radius,lo,hi] = dimensions of cylinder\n&#34;
        f&#34;Coordinates (scaled): {C.USER.args}\n&#34;
        f&#34;Coordinates (SI units): {C.USER.args_siunits}\n&#34;
        f&#34;\tdim: {C.USER.args[0]}\n&#34;
        f&#34;\tc1: {C.USER.args[1]}\n&#34;
        f&#34;\tc2: {C.USER.args[2]}\n&#34;
        f&#34;\tradius: {C.USER.args[3]}\n&#34;
        f&#34;\tlo: {C.USER.args[4]}\n&#34;
        f&#34;\thi: {C.USER.args[5]}&#34;
    )
    # other attributes  -------------------------------------
    C.USER.beadtype = C.beadtype  # beadtype to be used for create_atoms
    C.USER.side = C.sidearg(side) # extra parameter side
    C.USER.move = C.movearg(move) # move arg
    C.USER.units = C.unitsarg(units) # units
    C.USER.rotate = C.rotatearg(rotate) # rotate
    C.USER.open = C.openarg(open) # open
    # Create the object if not fake
    if fake:
        return C
    else:
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        self.objects[name] = C
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="region.region.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>delete object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self,name):
    &#34;&#34;&#34; delete object &#34;&#34;&#34;
    if name in self.objects:
        kind = self.objects[name].kind
        del self.objects[name]
        self.nobjects -= 1
        self.counter[kind] -= 1
        self.counter[&#34;all&#34;] -= 1
    else:
        raise NameError(&#34;%s does not exist (use list()) to list valid objects&#34; % name)</code></pre>
</details>
</dd>
<dt id="region.region.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, printflag=False, verbosity=1)</span>
</code></dt>
<dd>
<div class="desc"><p>execute the entire script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, printflag=False, verbosity=1):
    &#34;&#34;&#34; execute the entire script &#34;&#34;&#34;
    return self.pipescript().do(printflag=printflag, verbosity=verbosity)</code></pre>
</details>
</dd>
<dt id="region.region.dolive"><code class="name flex">
<span>def <span class="ident">dolive</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>execute the entire script for online testing
see: <a href="https://editor.lammps.org/">https://editor.lammps.org/</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dolive(self):
    &#34;&#34;&#34;
        execute the entire script for online testing
        see: https://editor.lammps.org/
    &#34;&#34;&#34;
    self.livelammps[&#34;file&#34;] = self.script(live=True).tmpwrite()
    if not self.livelammps[&#34;active&#34;]:
        livelammps(self.livelammps[&#34;URL&#34;],new=0)
        self.livelammps[&#34;active&#34;] = True
    return self.livelammps[&#34;file&#34;]</code></pre>
</details>
</dd>
<dt id="region.region.ellipsoid"><code class="name flex">
<span>def <span class="ident">ellipsoid</span></span>(<span>self, x=0, y=0, z=0, a=5, b=3, c=2, name=None, beadtype=None, fake=False, mass=None, density=None, side=None, units=None, move=None, rotate=None, open=None, index=None, subindex=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>creates an ellipsoid region
ellipsoid(x,y,z,a,b,c [,name=None,beadtype=None,property=value,&hellip;])
x,y,z = center of ellipsoid (distance units)
a,b,c = half the length of the principal axes of the ellipsoid (distance units)</p>
<pre><code>URL: &lt;https://docs.lammps.org/region.html&gt;

Main properties = default value
    name = "ellipsoid001"
beadtype = 1
    fake = False (use True to test the execution)
    index, subindex = object index and subindex

Extra properties
    side = "in|out"
   units = "lattice|box" ("box" is forced if regionunits=="si")
    move = "[${v1} ${v2} ${v3}]" or [v1,v2,v3] as a list
           with v1,v2,v3 equal-style variables for x,y,z displacement
           of region over time (distance units)
  rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
           vtheta = equal-style variable for rotation of region over time (in radians)
           Px,Py,Pz = origin for axis of rotation (distance units)
           Rx,Ry,Rz = axis of rotation vector
    open = integer from 1-6 corresponding to face index


Examples:
    # example with variables created either at creation or later
        R = region(name="my region")
        R.ellipsoid(0, 0, 0, 1, 1, 1,name="E1",toto=3)
        repr(R.E1)
        R.E1.VARIABLES.a=1
        R.E1.VARIABLES.b=2
        R.E1.VARIABLES.c="(${a},${b},100)"
        R.E1.VARIABLES.d = '"%s%s" %("test",${c}) # note that test could be replaced by any function'
    # example with extra parameters
        R.ellipsoid(0,0,0,1,1,1,name="E2",side="out",move=["left","${up}*3",None],up=0.1)
        R.E2.VARIABLES.left = '"swiggle(%s,%s,%s)"%(${a},${b},${c})'
        R.E2.VARIABLES.a="${b}-5"
        R.E2.VARIABLES.b=5
        R.E2.VARIABLES.c=100
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ellipsoid(self,x=0,y=0,z=0,a=5,b=3,c=2,
              name=None,beadtype=None,fake=False,
              mass=None, density=None,
              side=None,units=None,move=None,rotate=None,open=None,
              index = None,subindex = None,
              **variables
              ):
    &#34;&#34;&#34;
    creates an ellipsoid region
        ellipsoid(x,y,z,a,b,c [,name=None,beadtype=None,property=value,...])
        x,y,z = center of ellipsoid (distance units)
        a,b,c = half the length of the principal axes of the ellipsoid (distance units)

        URL: https://docs.lammps.org/region.html

        Main properties = default value
            name = &#34;ellipsoid001&#34;
        beadtype = 1
            fake = False (use True to test the execution)
            index, subindex = object index and subindex

        Extra properties
            side = &#34;in|out&#34;
           units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
            move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                   with v1,v2,v3 equal-style variables for x,y,z displacement
                   of region over time (distance units)
          rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                   vtheta = equal-style variable for rotation of region over time (in radians)
                   Px,Py,Pz = origin for axis of rotation (distance units)
                   Rx,Ry,Rz = axis of rotation vector
            open = integer from 1-6 corresponding to face index


        Examples:
            # example with variables created either at creation or later
                R = region(name=&#34;my region&#34;)
                R.ellipsoid(0, 0, 0, 1, 1, 1,name=&#34;E1&#34;,toto=3)
                repr(R.E1)
                R.E1.VARIABLES.a=1
                R.E1.VARIABLES.b=2
                R.E1.VARIABLES.c=&#34;(${a},${b},100)&#34;
                R.E1.VARIABLES.d = &#39;&#34;%s%s&#34; %(&#34;test&#34;,${c}) # note that test could be replaced by any function&#39;
            # example with extra parameters
                R.ellipsoid(0,0,0,1,1,1,name=&#34;E2&#34;,side=&#34;out&#34;,move=[&#34;left&#34;,&#34;${up}*3&#34;,None],up=0.1)
                R.E2.VARIABLES.left = &#39;&#34;swiggle(%s,%s,%s)&#34;%(${a},${b},${c})&#39;
                R.E2.VARIABLES.a=&#34;${b}-5&#34;
                R.E2.VARIABLES.b=5
                R.E2.VARIABLES.c=100
    &#34;&#34;&#34;
    # prepare object creation
    kind = &#34;ellipsoid&#34;
    if index is None: index = self.counter[&#34;all&#34;]+1
    if subindex is None: subindex = self.counter[kind]+1
    units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
    # create the object E with E for Ellipsoid
    obj_mass = mass if mass is not None else self.mass
    obj_density = density if density is not None else self.density
    E = Ellipsoid((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                  spacefilling=self.isspacefilled, # added on 2023-08-11
                  mass=obj_mass, density=obj_density,
                  index=index,subindex=subindex,
                  lattice_style=self.lattice_style,
                  lattice_scale=self.lattice_scale,
                  lattice_scale_siunits=self.lattice_scale_siunits,
                  **variables)
    # feed USER fields
    if name not in (None,&#34;&#34;): E.name = name # object name (if not defined, default name will be used)
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    if beadtype is not None: E.beadtype = beadtype # bead type (if not defined, default index will apply)
    E.USER.ID = &#34;$&#34;+E.name        # add $ to prevent its execution
    # geometry args (2024-07-04)  -------------------------------------
    args = [x, y, z, a, b, c]  # args = [....] as defined in the class Ellipsoid
    args_scaled = [
        self.scale_and_translate(x, self.center[0]),
        self.scale_and_translate(y, self.center[1]),
        self.scale_and_translate(z, self.center[2]),
        self.scale_and_translate(a, 0),
        self.scale_and_translate(b, 0),
        self.scale_and_translate(c, 0)
    ]
    if self.units == &#34;si&#34;:
        E.USER.args = args_scaled
        E.USER.args_siunits = args
    else:  # &#34;lattice&#34;
        E.USER.args = args
        E.USER.args_siunits = args_scaled
    # geometry
    E.USER.geometry = (
        f&#34;Ellipsoid Region: {E.name}\n&#34;
        &#34;Coordinates: [x,y,z,a,b,c] = center and radii of ellipsoid\n&#34;
        f&#34;Coordinates (scaled): {E.USER.args}\n&#34;
        f&#34;Coordinates (SI units): {E.USER.args_siunits}\n&#34;
        f&#34;\tcenter: [{E.USER.args[0]}, {E.USER.args[1]}, {E.USER.args[2]}]\n&#34;
        f&#34;\ta: {E.USER.args[3]}\n&#34;
        f&#34;\tb: {E.USER.args[4]}\n&#34;
        f&#34;\tc: {E.USER.args[5]}&#34;
    )
    # other attributes  -------------------------------------
    E.USER.beadtype = E.beadtype  # beadtype to be used for create_atoms
    E.USER.side = E.sidearg(side) # extra parameter side
    E.USER.move = E.movearg(move) # move arg
    E.USER.units = E.unitsarg(units) # units
    E.USER.rotate = E.rotatearg(rotate) # rotate
    E.USER.open = E.openarg(open) # open
    # Create the object if not fake
    if fake:
        return E
    else:
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        self.objects[name] = E
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="region.region.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>self, expression, name=None, beadtype=None, fake=False, index=None, subindex=None)</span>
</code></dt>
<dd>
<div class="desc"><p>evaluates (i.e, combine scripts) an expression combining objects
R= region(name="my region")
R.eval(o1+o2+&hellip;,name='obj')
R.eval(o1|o2|&hellip;,name='obj')
R.name will be the resulting object of class region.eval (region.coregeometry)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval(self,expression,name=None,beadtype = None,
         fake=False,index = None,subindex = None):
    &#34;&#34;&#34;
        evaluates (i.e, combine scripts) an expression combining objects
            R= region(name=&#34;my region&#34;)
            R.eval(o1+o2+...,name=&#39;obj&#39;)
            R.eval(o1|o2|...,name=&#39;obj&#39;)
        R.name will be the resulting object of class region.eval (region.coregeometry)
    &#34;&#34;&#34;
    if not isinstance(expression, coregeometry): raise TypeError(&#34;the argument should be a region.coregeometry&#34;)
    # prepare object creation
    kind = &#34;eval&#34;
    self.counter[&#34;all&#34;] += 1
    self.counter[kind] +=1
    if index is None: index = self.counter[&#34;all&#34;]
    if subindex is None: subindex = self.counter[kind]
    # create the object E with E for Ellipsoid
    E = Evalgeometry((self.counter[&#34;all&#34;],self.counter[kind]),
                  index=index,subindex=subindex)
    # link expression to E
    if beadtype is not None: E.beadtype = beadtype # bead type (if not defined, default index will apply)
    if name is None: name = expression.name
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    E.name = name
    E.SECTIONS = expression.SECTIONS
    E.USER = expression.USER
    if isinstance(E.SECTIONS,pipescript):
        # set beadtypes for all sections and scripts in the pipeline
        for i in E.SECTIONS.keys():
            for j in range(len(E.SECTIONS[i])):
                E.SECTIONS[i].USER[j].beadtype = E.beadtype
    E.USER.beadtype = beadtype
    # Create the object if not fake
    if fake:
        self.counter[&#34;all&#34;] -= 1
        self.counter[kind] -= 1
        return E
    else:
        self.objects[name] = E
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="region.region.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self,name):
    &#34;&#34;&#34; returns the object &#34;&#34;&#34;
    if name in self.objects:
        return self.objects[name]
    else:
        raise NameError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)</code></pre>
</details>
</dd>
<dt id="region.region.group"><code class="name flex">
<span>def <span class="ident">group</span></span>(<span>self, obj, name=None, fake=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group(self,obj,name=None,fake=False):
    pass</code></pre>
</details>
</dd>
<dt id="region.region.hasattr"><code class="name flex">
<span>def <span class="ident">hasattr</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>return true if the object exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasattr(self,name):
    &#34;&#34;&#34; return true if the object exist &#34;&#34;&#34;
    if not isinstance(name,str): raise TypeError(&#34;please provide a string&#34;)
    return name in self.objects</code></pre>
</details>
</dd>
<dt id="region.region.intersect"><code class="name flex">
<span>def <span class="ident">intersect</span></span>(<span>self, *regID, name=None, beadtype=1, fake=False, index=None, subindex=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>creates an intersection region
intersect("reg-ID1","reg-ID2",name="myname",beadtype=1,&hellip;)
reg-ID1,reg-ID2, &hellip; = IDs of regions to join together</p>
<pre><code>   URL: &lt;https://docs.lammps.org/region.html&gt;

   Main properties = default value
       name = "intersect001"
   beadtype = 1
       fake = False (use True to test the execution)
</code></pre>
<p>index, subindex = object index and subindex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersect(self,*regID,
          name=None,beadtype=1,fake=False,
          index = None,subindex = None,
          **variables):
    &#34;&#34;&#34;
    creates an intersection region
          intersect(&#34;reg-ID1&#34;,&#34;reg-ID2&#34;,name=&#34;myname&#34;,beadtype=1,...)
          reg-ID1,reg-ID2, ... = IDs of regions to join together

        URL: https://docs.lammps.org/region.html

        Main properties = default value
            name = &#34;intersect001&#34;
        beadtype = 1
            fake = False (use True to test the execution)
 index, subindex = object index and subindex
    &#34;&#34;&#34;
    kind = &#34;intersect&#34;
    if index is None: index = self.counter[&#34;all&#34;]+1
    if subindex is None: subindex = self.counter[kind]+1
    # create the object I with I for intersect
    I = Intersect((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                  index=index,subindex=subindex,**variables)
    # feed USER fields
    if name not in (None,&#34;&#34;): I.name = name # object name (if not defined, default name will be used)
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    if beadtype is not None: I.beadtype = beadtype # bead type (if not defined, default index will apply)
    I.USER.ID = &#34;$&#34;+I.name        # add $ to prevent its execution
    I.USER.side, I.USER.move, I.USER.units, I.USER.rotate, I.USER.open = &#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;
    # build arguments based on regID
    nregID = len(regID)
    if nregID&lt;2: raise ValueError(&#39;two objects must be given at least for an intersection&#39;)
    args = [None] # the number of arguments is not known yet
    validID = range(nregID)
    for ireg in validID:
        if isinstance(regID[ireg],int):
            if regID[ireg] in validID:
                args.append(self.names[regID[ireg]])
            else:
                raise IndexError(f&#34;the index {regID[ireg]} exceeds the number of objects {len(self)}&#34;)
        elif isinstance(regID[ireg],str):
            if regID[ireg] in self:
                args.append(regID[ireg])
            else:
                raise KeyError(f&#39;the object &#34;{regID[ireg]}&#34; does not exist&#39;)
        else:
            raise KeyError(f&#34;the {ireg+1}th object should be given as a string or an index&#34;)
        # prevent the creation of atoms (avoid duplicates)
        self.objects[regID[ireg]].FLAGSECTIONS[&#34;create&#34;] = False
    args[0] = len(regID)
    I.USER.args = args   # args = [....] as defined in the class Union
    # Create the object if not fake
    if fake:
        return I
    else:
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        self.objects[name] = I
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="region.region.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>list objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self):
    &#34;&#34;&#34; list objects &#34;&#34;&#34;
    fmt = &#34;%%%ss:&#34; % max(10,max([len(n) for n in self.names])+2)
    print(&#39;REGION container &#34;%s&#34; with %d objects&#39; % (self.name,self.nobjects))
    for o in self.objects.keys():
        print(fmt % self.objects[o].name,&#34;%-10s&#34; % self.objects[o].kind,
              &#34;(beadtype=%d,object index=[%d,%d])&#34; % \
                  (self.objects[o].beadtype,
                   self.objects[o].index,
                   self.objects[o].subindex))</code></pre>
</details>
</dd>
<dt id="region.region.pipescript"><code class="name flex">
<span>def <span class="ident">pipescript</span></span>(<span>self, printflag=False, verbose=False, verbosity=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipescript(self,printflag=False,verbose=False,verbosity=0):
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    &#34;&#34;&#34; pipescript all objects in the region &#34;&#34;&#34;
    if len(self)&lt;1: return pipescript()
    # execute all objects
    for myobj in self:
        if not isinstance(myobj,Collection): myobj.do(printflag=printflag,verbosity=verbosity)
    # concatenate all objects into a pipe script
    # for collections, only group is accepted
    liste = [x.SECTIONS[&#34;variables&#34;] for x in self if not isinstance(x,Collection) and x.hasvariables] + \
            [x.SECTIONS[&#34;region&#34;]    for x in self if not isinstance(x,Collection) and x.hasregion] + \
            [x.SECTIONS[&#34;create&#34;]    for x in self if not isinstance(x,Collection) and x.hascreate] + \
            [x.SECTIONS[&#34;group&#34;]     for x in self if not isinstance(x,Collection) and x.hasgroup] + \
            [x.SECTIONS[&#34;setgroup&#34;]  for x in self if not isinstance(x,Collection) and x.hassetgroup] + \
            [x.SECTIONS[&#34;move&#34;]      for x in self if not isinstance(x,Collection) and x.hasmove]
    # add the objects within the collection
    for x in self:
        if isinstance(x,Collection): liste += x.group()
    # add the eventual group for the collection
    liste += [x.SECTIONS[&#34;group&#34;] for x in self if isinstance(x,Collection) and x.hasgroup]
    # chain all scripts
    return pipescript.join(liste)</code></pre>
</details>
</dd>
<dt id="region.region.plane"><code class="name flex">
<span>def <span class="ident">plane</span></span>(<span>self, px=0, py=0, pz=0, nx=0, ny=0, nz=1, name=None, beadtype=None, fake=False, side=None, units=None, move=None, rotate=None, open=None, index=None, subindex=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a plane region
px,py,pz = point on the plane (distance units)
nx,ny,nz = direction normal to plane (distance units)</p>
<pre><code>   URL: &lt;https://docs.lammps.org/region.html&gt;

   Main properties = default value
       name = "plane001"
   beadtype = 1
       fake = False (use True to test the execution)
</code></pre>
<p>index, subindex = object index and subindex</p>
<pre><code>   Extra properties
       side = "in|out"
      units = "lattice|box" ("box" is forced if regionunits=="si")
       move = "[${v1} ${v2} ${v3}]" or [v1,v2,v3] as a list
              with v1,v2,v3 equal-style variables for x,y,z displacement
              of region over time (distance units)
     rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
              vtheta = equal-style variable for rotation of region over time (in radians)
              Px,Py,Pz = origin for axis of rotation (distance units)
              Rx,Ry,Rz = axis of rotation vector
       open = integer from 1-6 corresponding to face index

   See examples for elliposid()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plane(self,px=0,py=0,pz=0,nx=0,ny=0,nz=1,
              name=None,beadtype=None,fake=False,
              side=None,units=None,move=None,rotate=None,open=None,
              index = None,subindex = None,
              **variables
              ):
    &#34;&#34;&#34;
    creates a plane region
          px,py,pz = point on the plane (distance units)
          nx,ny,nz = direction normal to plane (distance units)

        URL: https://docs.lammps.org/region.html

        Main properties = default value
            name = &#34;plane001&#34;
        beadtype = 1
            fake = False (use True to test the execution)
 index, subindex = object index and subindex

        Extra properties
            side = &#34;in|out&#34;
           units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
            move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                   with v1,v2,v3 equal-style variables for x,y,z displacement
                   of region over time (distance units)
          rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                   vtheta = equal-style variable for rotation of region over time (in radians)
                   Px,Py,Pz = origin for axis of rotation (distance units)
                   Rx,Ry,Rz = axis of rotation vector
            open = integer from 1-6 corresponding to face index

        See examples for elliposid()
    &#34;&#34;&#34;
    # prepare object creation
    kind = &#34;plane&#34;
    if index is None: index = self.counter[&#34;all&#34;]+1
    if subindex is None: subindex = self.counter[kind]+1
    units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
    # create the object P with P for plane
    P = Plane((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                  spacefilling=self.isspacefilled, # added on 2023-08-11
                  mass=self.mass, density=self.density, # added on 2024-06-14
                  index=index,subindex=subindex,
                  lattice_style=self.lattice_style,
                  lattice_scale=self.lattice_scale,
                  lattice_scale_siunits=self.lattice_scale_siunits,
                  **variables)
    # feed USER fields
    if name not in (None,&#34;&#34;): P.name = name # object name (if not defined, default name will be used)
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    if beadtype is not None: P.beadtype = beadtype # bead type (if not defined, default index will apply)
    P.USER.ID = &#34;$&#34;+P.name        # add $ to prevent its execution
    # geometry args (2024-07-04) ---------------------------
    args = [px, py, pz, nx, ny, nz]  # args = [....] as defined in the class Plane
    args_scaled = [
        self.scale_and_translate(px, self.center[0]),
        self.scale_and_translate(py, self.center[1]),
        self.scale_and_translate(pz, self.center[2]),
        self.scale_and_translate(nx, 0),
        self.scale_and_translate(ny, 0),
        self.scale_and_translate(nz, 0)
    ]
    if self.units == &#34;si&#34;:
        P.USER.args = args_scaled
        P.USER.args_siunits = args
    else:  # &#34;lattice&#34;
        P.USER.args = args
        P.USER.args_siunits = args_scaled
    # geometry
    P.USER.geometry = (
        f&#34;Plane Region: {P.name}\n&#34;
        &#34;Coordinates: [px,py,pz,nx,ny,nz] = point and normal vector of plane\n&#34;
        f&#34;Coordinates (scaled): {P.USER.args}\n&#34;
        f&#34;Coordinates (SI units): {P.USER.args_siunits}\n&#34;
        f&#34;\tpoint: [{P.USER.args[0]}, {P.USER.args[1]}, {P.USER.args[2]}]\n&#34;
        f&#34;\tnormal: [{P.USER.args[3]}, {P.USER.args[4]}, {P.USER.args[5]}]&#34;
        )
    # other attributes ---------------------------
    P.USER.beadtype = P.beadtype  # beadtype to be used for create_atoms
    P.USER.side = P.sidearg(side) # extra parameter side
    P.USER.move = P.movearg(move) # move arg
    P.USER.units = P.unitsarg(units) # units
    P.USER.rotate = P.rotatearg(rotate) # rotate
    P.USER.open = P.openarg(open) # open
    # Create the object if not fake
    if fake:
        return P
    else:
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        self.objects[name] = P
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="region.region.prism"><code class="name flex">
<span>def <span class="ident">prism</span></span>(<span>self, xlo=-5, xhi=5, ylo=-5, yhi=5, zlo=-5, zhi=5, xy=1, xz=1, yz=1, name=None, beadtype=None, fake=False, mass=None, density=None, side=None, units=None, move=None, rotate=None, open=None, index=None, subindex=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a prism region
xlo,xhi,ylo,yhi,zlo,zhi = bounds of untilted prism (distance units)
xy = distance to tilt y in x direction (distance units)
xz = distance to tilt z in x direction (distance units)
yz = distance to tilt z in y direction (distance units)</p>
<pre><code>   URL: &lt;https://docs.lammps.org/region.html&gt;

   Main properties = default value
       name = "prism001"
   beadtype = 1
       fake = False (use True to test the execution)
</code></pre>
<p>index, subindex = object index and subindex</p>
<pre><code>   Extra properties
       side = "in|out"
      units = "lattice|box" ("box" is forced if regionunits=="si")
       move = "[${v1} ${v2} ${v3}]" or [v1,v2,v3] as a list
              with v1,v2,v3 equal-style variables for x,y,z displacement
              of region over time (distance units)
     rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
              vtheta = equal-style variable for rotation of region over time (in radians)
              Px,Py,Pz = origin for axis of rotation (distance units)
              Rx,Ry,Rz = axis of rotation vector
       open = integer from 1-6 corresponding to face index

   See examples for elliposid()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prism(self,xlo=-5,xhi=5,ylo=-5,yhi=5,zlo=-5,zhi=5,xy=1,xz=1,yz=1,
              name=None,beadtype=None,fake=False,
              mass=None, density=None,
              side=None,units=None,move=None,rotate=None,open=None,
              index = None,subindex = None,
              **variables
              ):
    &#34;&#34;&#34;
    creates a prism region
        xlo,xhi,ylo,yhi,zlo,zhi = bounds of untilted prism (distance units)
        xy = distance to tilt y in x direction (distance units)
        xz = distance to tilt z in x direction (distance units)
        yz = distance to tilt z in y direction (distance units)

        URL: https://docs.lammps.org/region.html

        Main properties = default value
            name = &#34;prism001&#34;
        beadtype = 1
            fake = False (use True to test the execution)
 index, subindex = object index and subindex

        Extra properties
            side = &#34;in|out&#34;
           units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
            move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                   with v1,v2,v3 equal-style variables for x,y,z displacement
                   of region over time (distance units)
          rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                   vtheta = equal-style variable for rotation of region over time (in radians)
                   Px,Py,Pz = origin for axis of rotation (distance units)
                   Rx,Ry,Rz = axis of rotation vector
            open = integer from 1-6 corresponding to face index

        See examples for elliposid()
    &#34;&#34;&#34;
    # prepare object creation
    kind = &#34;prism&#34;
    if index is None: index = self.counter[&#34;all&#34;]+1
    if subindex is None: subindex = self.counter[kind]+1
    units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
    # create the object P with P for prism
    obj_mass = mass if mass is not None else self.mass
    obj_density = density if density is not None else self.density
    P = Prism((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                  spacefilling=self.isspacefilled, # added on 2023-08-11
                  mass=obj_mass, density=obj_density, # added on 2024-06-14
                  index=index,subindex=subindex,
                  lattice_style=self.lattice_style,
                  lattice_scale=self.lattice_scale,
                  lattice_scale_siunits=self.lattice_scale_siunits,
                  **variables)
    # feed USER fields
    if name not in (None,&#34;&#34;): P.name = name # object name (if not defined, default name will be used)
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    if beadtype is not None: P.beadtype = beadtype # bead type (if not defined, default index will apply)
    P.USER.ID = &#34;$&#34;+P.name        # add $ to prevent its execution
    # geometry args (2024-07-04) ---------------------------
    args = [xlo, xhi, ylo, yhi, zlo, zhi, xy, xz, yz]  # args = [....] as defined in the class Prism
    args_scaled = [
        self.scale_and_translate(xlo, self.center[0]),
        self.scale_and_translate(xhi, self.center[0]),
        self.scale_and_translate(ylo, self.center[1]),
        self.scale_and_translate(yhi, self.center[1]),
        self.scale_and_translate(zlo, self.center[2]),
        self.scale_and_translate(zhi, self.center[2]),
        self.scale_and_translate(xy, 0),
        self.scale_and_translate(xz, 0),
        self.scale_and_translate(yz, 0)
    ]
    if self.units == &#34;si&#34;:
        P.USER.args = args_scaled
        P.USER.args_siunits = args
    else:  # &#34;lattice&#34;
        P.USER.args = args
        P.USER.args_siunits = args_scaled
    # geometry
    P.USER.geometry = (
        f&#34;Prism Region: {P.name}\n&#34;
        &#34;Coordinates: [xlo,xhi,ylo,yhi,zlo,zhi,xy,xz,yz] = bounds and tilts of prism\n&#34;
        f&#34;Coordinates (scaled): {P.USER.args}\n&#34;
        f&#34;Coordinates (SI units): {P.USER.args_siunits}\n&#34;
        f&#34;\tbounds: [{P.USER.args[0]}, {P.USER.args[1]}, {P.USER.args[2]}, {P.USER.args[3]}, {P.USER.args[4]}, {P.USER.args[5]}]\n&#34;
        f&#34;\ttilts: [{P.USER.args[6]}, {P.USER.args[7]}, {P.USER.args[8]}]&#34;
    )
    # other attributes ---------------------------
    P.USER.beadtype = P.beadtype  # beadtype to be used for create_atoms
    P.USER.side = P.sidearg(side) # extra parameter side
    P.USER.move = P.movearg(move) # move arg
    P.USER.units = P.unitsarg(units) # units
    P.USER.rotate = P.rotatearg(rotate) # rotate
    P.USER.open = P.openarg(open) # open
    # Create the object if not fake
    if fake:
        return P
    else:
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        self.objects[name] = P
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="region.region.pscriptHeaders"><code class="name flex">
<span>def <span class="ident">pscriptHeaders</span></span>(<span>self, what=['init', 'lattice', 'box'], **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Surrogate method for generating LAMMPS pipescript headers.
Calls the <code>scriptHeaders</code> method with <code>pipescript=True</code>.</p>
<p>Parameters:
- what (list of str): Specifies which scripts to generate. Options are "init", "lattice", and "box".
Multiple scripts can be generated by passing a list of these options.
Default is ["init", "lattice", "box"].
Property/pair value
- nbeads (int): Specifies the number of beads, overriding the default if larger than <code>self.nbeads</code>.
Default is 1.
- mass (real value or list): Sets the mass for each bead, overrriding <code>self.mass</code>
Default is 1.0.
Returns:
- object: The combined pipescript header scripts as a single object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pscriptHeaders(self, what=[&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;], **userdefinitions):
    &#34;&#34;&#34;
    Surrogate method for generating LAMMPS pipescript headers.
    Calls the `scriptHeaders` method with `pipescript=True`.

    Parameters:
    - what (list of str): Specifies which scripts to generate. Options are &#34;init&#34;, &#34;lattice&#34;, and &#34;box&#34;.
                          Multiple scripts can be generated by passing a list of these options.
                          Default is [&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;].
    Property/pair value
    - nbeads (int): Specifies the number of beads, overriding the default if larger than `self.nbeads`.
                    Default is 1.
    - mass (real value or list): Sets the mass for each bead, overrriding `self.mass`
                    Default is 1.0.
    Returns:
    - object: The combined pipescript header scripts as a single object.
    &#34;&#34;&#34;
    # Call scriptHeaders with pipescript=True
    return self.scriptHeaders(what=what, pipescript=True, **userdefinitions)</code></pre>
</details>
</dd>
<dt id="region.region.scale_and_translate"><code class="name flex">
<span>def <span class="ident">scale_and_translate</span></span>(<span>self, value, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale and translate a value or encapsulate the formula within a string.</p>
<p>If self.regionunits is "si", only the offset is applied without scaling.
Otherwise, scaling and translation are performed based on self.units ("si" or "lattice").</p>
<h2 id="parameters">Parameters</h2>
<p>value (str or float): The value or formula to be scaled and translated.
offset (float, optional): The offset to apply. Defaults to 0.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>float</code></dt>
<dd>The scaled and translated value or formula.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_and_translate(self, value, offset=0):
    &#34;&#34;&#34;
    Scale and translate a value or encapsulate the formula within a string.

    If self.regionunits is &#34;si&#34;, only the offset is applied without scaling.
    Otherwise, scaling and translation are performed based on self.units (&#34;si&#34; or &#34;lattice&#34;).

    Parameters:
        value (str or float): The value or formula to be scaled and translated.
        offset (float, optional): The offset to apply. Defaults to 0.

    Returns:
        str or float: The scaled and translated value or formula.
    &#34;&#34;&#34;
    if self.regionunits == &#34;si&#34;:
        # Only apply offset without scaling
        if isinstance(value, str):
            if offset:
                translated = f&#34;({value}) - {offset}&#34;
            else:
                translated = f&#34;{value}&#34;
            return translated
        else:
            if offset:
                return value - offset
            else:
                return value
    else:
        # Existing behavior based on self.units
        if isinstance(value, str):
            if offset:
                translated = f&#34;({value}) - {offset}&#34;
            else:
                translated = f&#34;{value}&#34;
            if self.units == &#34;si&#34;:
                return f&#34;({translated}) / {self.lattice_scale} + {offset / self.lattice_scale}&#34;
            else:  # &#34;lattice&#34;
                return f&#34;({translated}) * {self.lattice_scale} + {offset * self.lattice_scale}&#34;
        else:
            if offset:
                translated = value - offset
            else:
                translated = value
            if self.units == &#34;si&#34;:
                return translated / self.lattice_scale + (offset / self.lattice_scale)
            else:  # &#34;lattice&#34;
                return translated * self.lattice_scale + (offset * self.lattice_scale)</code></pre>
</details>
</dd>
<dt id="region.region.scatter"><code class="name flex">
<span>def <span class="ident">scatter</span></span>(<span>self, E, name='emulsion', beadtype=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>E</code></strong> :&ensp;<code><a title="region.scatter" href="#region.scatter">scatter</a></code> or <code><a title="region.emulsion" href="#region.emulsion">emulsion</a> object</code></dt>
<dd>codes for x,y,z and r.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>name of the collection. The default is "emulsion".</dd>
<dt><strong><code>beadtype</code></strong> :&ensp;<code>integer</code>, optional</dt>
<dd>for all objects. The default is 1.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Return an error of the object is not a scatter type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatter(self,
             E,
             name=&#34;emulsion&#34;,
             beadtype=None,
             ):
    &#34;&#34;&#34;


    Parameters
    ----------
    E : scatter or emulsion object
        codes for x,y,z and r.
    name : string, optional
        name of the collection. The default is &#34;emulsion&#34;.
    beadtype : integer, optional
        for all objects. The default is 1.

    Raises
    ------
    TypeError
        Return an error of the object is not a scatter type.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if isinstance(E,scatter):
        collect = {}
        for i in range(E.n):
            b = E.beadtype[i] if beadtype==None else beadtype
            nameobj = &#34;glob%02d&#34; % i
            collect[nameobj] = self.sphere(E.x[i],E.y[i],E.z[i],E.r[i],
                        name=nameobj,beadtype=b,fake=True)
        self.collection(**collect,name=name)
    else:
        raise TypeError(&#34;the first argument must be an emulsion object&#34;)</code></pre>
</details>
</dd>
<dt id="region.region.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>self, live=False, printflag=None, verbose=None, verbosity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>script all objects in the region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def script(self,live=False, printflag=None, verbose=None, verbosity=None):
    &#34;&#34;&#34; script all objects in the region &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    s = self.pipescript(printflag=printflag,verbose=verbose,verbosity=verbosity).script(printflag=printflag,verbose=verbose,verbosity=verbosity)
    if self.isspacefilled:
        USERspacefilling =regiondata(**self.spacefilling)
        s = LammpsSpacefilling(**USERspacefilling)+s
    if live:
        beadtypes = self.beadtypes
        USER = regiondata(**self.live)
        USER.nbeads = self.nbeads
        USER.mass = &#34;$&#34;
        USER.pair_coeff = &#34;$&#34;
        # list beadtype and prepare  mass, pair_coeff
        beadtypes = [ x[0] for x in self.count() ]
        if self.isspacefilled and self.spacefillingbeadtype not in beadtypes:
            beadtypes = [self.spacefillingbeadtype]+beadtypes
        for b in beadtypes:
            USER.mass += livetemplate[&#34;mass&#34;] % b +&#34;\n&#34;
            USER.pair_coeff += livetemplate[&#34;pair_coeff&#34;] %(b,b) +&#34;\n&#34;
        for b1 in beadtypes:
            for b2 in beadtypes:
                if b2&gt;b1:
                    USER.pair_coeff += livetemplate[&#34;pair_coeff&#34;] %(b1,b2) +&#34;\n&#34;
        livemode = &#34;dynamic&#34; if self.hasfixmove else &#34;static&#34;
        USER.run =self.livelammps[&#34;options&#34;][livemode][&#34;run&#34;]
        s = LammpsHeader(**USER)+s+LammpsFooter(**USER)
    return s</code></pre>
</details>
</dd>
<dt id="region.region.scriptHeaders"><code class="name flex">
<span>def <span class="ident">scriptHeaders</span></span>(<span>self, what=['init', 'lattice', 'box'], pipescript=False, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and return LAMMPS header scripts for initializing the simulation, defining the lattice,
and specifying the simulation box for all region objects.</p>
<p>Parameters:
- what (list of str): Specifies which scripts to generate. Options are "init", "lattice", "box", "mass" and "preview".
Multiple scripts can be generated by passing a list of these options.
Default is ["init", "lattice", "box"].
- pipescript (bool): If True, the generated scripts are combined with <code>|</code> instead of <code>+</code>. Default is False.</p>
<p>Property/pair value
- nbeads (int): Specifies the number of beads, overriding the default if larger than <code>self.nbeads</code>.
Default is 1.
- mass (real value or list): Sets the mass for each bead, overrriding <code>self.mass</code>
Default is 1.0.</p>
<p>Returns:
- object: The combined header scripts as a single object.
Header values can be overridden by updating <code>self.headersData</code>.</p>
<p>Raises:
- Exception: If no valid script options are provided in <code>what</code>.</p>
<p>Example usage:
sRheader = R.scriptHeaders("box").do()
# Generate the box header script.
sRallheaders = R.scriptHeaders(["init", "lattice", "box"])
# Generate all headers.</p>
<pre><code>Example usage without naming parameters:
sRheader = R.scriptHeaders("box")  # "what" specified as "box", nbeads defaults to 1.

Example of overriding values
sRheader = R.scriptHeaders("lattice",lattice_style = "$sq")  # Generate the lattice header script with the overridden value.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scriptHeaders(self, what=[&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;], pipescript=False, **userdefinitions):
    &#34;&#34;&#34;
        Generate and return LAMMPS header scripts for initializing the simulation, defining the lattice,
        and specifying the simulation box for all region objects.

        Parameters:
        - what (list of str): Specifies which scripts to generate. Options are &#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;, &#34;mass&#34; and &#34;preview&#34;.
                              Multiple scripts can be generated by passing a list of these options.
                              Default is [&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;].
        - pipescript (bool): If True, the generated scripts are combined with `|` instead of `+`. Default is False.

        Property/pair value
        - nbeads (int): Specifies the number of beads, overriding the default if larger than `self.nbeads`.
                        Default is 1.
        - mass (real value or list): Sets the mass for each bead, overrriding `self.mass`
                        Default is 1.0.


        Returns:
        - object: The combined header scripts as a single object.
                  Header values can be overridden by updating `self.headersData`.

        Raises:
        - Exception: If no valid script options are provided in `what`.

        Example usage:
            sRheader = R.scriptHeaders(&#34;box&#34;).do()  # Generate the box header script.
            sRallheaders = R.scriptHeaders([&#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;])  # Generate all headers.

            Example usage without naming parameters:
            sRheader = R.scriptHeaders(&#34;box&#34;)  # &#34;what&#34; specified as &#34;box&#34;, nbeads defaults to 1.

            Example of overriding values
            sRheader = R.scriptHeaders(&#34;lattice&#34;,lattice_style = &#34;$sq&#34;)  # Generate the lattice header script with the overridden value.
    &#34;&#34;&#34;
    # handle overrides
    USERregion = self.headersData + regiondata(**userdefinitions)
    # Fix singletons
    if not isinstance(what, list):
        what = [what]
    # Generate the initialization script
    scripts = []  # Store all generated script objects here
    if &#34;init&#34; in what:
        scripts.append(LammpsHeaderInit(**USERregion))
    # Generate the lattice script
    if &#34;lattice&#34; in what:
        scripts.append(LammpsHeaderLattice(**USERregion))
    # Generate the box script
    if &#34;box&#34; in what:
        scripts.append(LammpsHeaderBox(**USERregion))
        if self.isspacefilled:
            scripts.append(LammpsSpacefilling(**self.spacefilling))
    # Generate the mass script
    if &#34;mass&#34; in what:
        scripts.append(LammpsHeaderMass(**USERregion))
    # Generate the preview script
    if &#34;preview&#34; in what:
        scripts.append(LammpsFooterPreview(**USERregion))
    if not scripts:
        raise Exception(&#39;nothing to do (use: &#34;init&#34;, &#34;lattice&#34;, &#34;box&#34;, &#34;mass&#34; or &#34;preview&#34; within [ ])&#39;)

    # Combine the scripts based on the pipescript flag
    combined_script = scripts[0]  # Initialize the combined script with the first element
    for script in scripts[1:]:
        if pipescript:
            # Combine scripts using the | operator, maintaining pipescript format
            combined_script = combined_script | script  # p_ab = s_a | s_b or p_ab = s_a | p_b
        else:
            # Combine scripts using the + operator, maintaining regular script format
            combined_script = combined_script + script  # s_ab = s_a + s_b
    return combined_script</code></pre>
</details>
</dd>
<dt id="region.region.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>set field and value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self,name,value):
    &#34;&#34;&#34; set field and value &#34;&#34;&#34;
    if isinstance(value,list) and len(value)==0:
        if name not in self.objects:
            raise NameError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)
        self.delete(name)
    elif isinstance(value,coregeometry):
        if name in self.objects: self.delete(name)
        if isinstance(value.SECTIONS,pipescript) or isinstance(value,Evalgeometry):
            self.eval(deepduplicate(value),name) # not a scalar
        else: # scalar
            self.objects[name] = deepduplicate(value)
            self.objects[name].name = name
            self.nobjects += 1
            self.counter[&#34;all&#34;] += 1
            self.objects[name].index = self.counter[&#34;all&#34;]
            self.counter[value.kind] += 1</code></pre>
</details>
</dd>
<dt id="region.region.sphere"><code class="name flex">
<span>def <span class="ident">sphere</span></span>(<span>self, x=0, y=0, z=0, radius=3, name=None, beadtype=None, fake=False, mass=None, density=None, side=None, units=None, move=None, rotate=None, open=None, index=None, subindex=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a sphere region
x,y,z = center of sphere (distance units)
radius = radius of sphere (distance units)
x,y,z, and radius can be a variable</p>
<pre><code>   URL: &lt;https://docs.lammps.org/region.html&gt;

   Main properties = default value
       name = "sphere001"
   beadtype = 1
       fake = False (use True to test the execution)
</code></pre>
<p>index, subindex = object index and subindex</p>
<pre><code>   Extra properties
       side = "in|out"
      units = "lattice|box" ("box" is forced if regionunits=="si")
       move = "[${v1} ${v2} ${v3}]" or [v1,v2,v3] as a list
              with v1,v2,v3 equal-style variables for x,y,z displacement
              of region over time (distance units)
     rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
              vtheta = equal-style variable for rotation of region over time (in radians)
              Px,Py,Pz = origin for axis of rotation (distance units)
              Rx,Ry,Rz = axis of rotation vector
       open = integer from 1-6 corresponding to face index

   See examples for elliposid()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sphere(self,x=0,y=0,z=0,radius=3,
              name=None,beadtype=None,fake=False,
              mass=None, density=None,
              side=None,units=None,move=None,rotate=None,open=None,
              index = None,subindex = None,
              **variables
              ):
    &#34;&#34;&#34;
    creates a sphere region
          x,y,z = center of sphere (distance units)
          radius = radius of sphere (distance units)
          x,y,z, and radius can be a variable

        URL: https://docs.lammps.org/region.html

        Main properties = default value
            name = &#34;sphere001&#34;
        beadtype = 1
            fake = False (use True to test the execution)
 index, subindex = object index and subindex

        Extra properties
            side = &#34;in|out&#34;
           units = &#34;lattice|box&#34; (&#34;box&#34; is forced if regionunits==&#34;si&#34;)
            move = &#34;[${v1} ${v2} ${v3}]&#34; or [v1,v2,v3] as a list
                   with v1,v2,v3 equal-style variables for x,y,z displacement
                   of region over time (distance units)
          rotate = string or 1x7 list (see move) coding for vtheta Px Py Pz Rx Ry Rz
                   vtheta = equal-style variable for rotation of region over time (in radians)
                   Px,Py,Pz = origin for axis of rotation (distance units)
                   Rx,Ry,Rz = axis of rotation vector
            open = integer from 1-6 corresponding to face index

        See examples for elliposid()
    &#34;&#34;&#34;
    # prepare object creation
    kind = &#34;sphere&#34;
    if index is None: index = self.counter[&#34;all&#34;]+1
    if subindex is None: subindex = self.counter[kind]+1
    units = &#34;box&#34; if self.regionunits==&#34;si&#34; and units is None else units  # force box units of regionunits==&#34;si&#34;
    # create the object S with S for sphere
    obj_mass = mass if mass is not None else self.mass
    obj_density = density if density is not None else self.density
    S = Sphere((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                  spacefilling=self.isspacefilled, # added on 2023-08-11
                  mass=obj_mass, density=obj_density, # added on 2024-06-14
                  index=index,subindex=subindex,
                  lattice_style=self.lattice_style,
                  lattice_scale=self.lattice_scale,
                  lattice_scale_siunits=self.lattice_scale_siunits,
                  **variables)
    # feed USER fields
    if name not in (None,&#34;&#34;): S.name = name # object name (if not defined, default name will be used)
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    if beadtype is not None: S.beadtype = beadtype # bead type (if not defined, default index will apply)
    S.USER.ID = &#34;$&#34;+S.name        # add $ to prevent its execution
    # geometry args (2024-07-04) ---------------------------
    args = [x, y, z, radius]  # args = [....] as defined in the class Sphere
    args_scaled = [
        self.scale_and_translate(x, self.center[0]),
        self.scale_and_translate(y, self.center[1]),
        self.scale_and_translate(z, self.center[2]),
        self.scale_and_translate(radius, 0)
    ]
    if self.units == &#34;si&#34;:
        S.USER.args = args_scaled
        S.USER.args_siunits = args
    else:  # &#34;lattice&#34;
        S.USER.args = args
        S.USER.args_siunits = args_scaled
    # geometry
    S.USER.geometry = (
        f&#34;Sphere Region: {S.name}\n&#34;
        &#34;Coordinates: [x,y,z,radius] = center and radius of sphere\n&#34;
        f&#34;Coordinates (scaled): {S.USER.args}\n&#34;
        f&#34;Coordinates (SI units): {S.USER.args_siunits}\n&#34;
        f&#34;\tcenter: [{S.USER.args[0]}, {S.USER.args[1]}, {S.USER.args[2]}]\n&#34;
        f&#34;\tradius: {S.USER.args[3]}&#34;
    )
    # other attributes ---------------------------
    S.USER.beadtype = S.beadtype  # beadtype to be used for create_atoms
    S.USER.side = S.sidearg(side) # extra parameter side
    S.USER.move = S.movearg(move) # move arg
    S.USER.units = S.unitsarg(units) # units
    S.USER.rotate = S.rotatearg(rotate) # rotate
    S.USER.open = S.openarg(open) # open
    # Create the object if not fake
    if fake:
        return S
    else:
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        self.objects[name] = S
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="region.region.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, *regID, name=None, beadtype=1, fake=False, index=None, subindex=None, **variables)</span>
</code></dt>
<dd>
<div class="desc"><p>creates a union region
union("reg-ID1","reg-ID2",name="myname",beadtype=1,&hellip;)
reg-ID1,reg-ID2, &hellip; = IDs of regions to join together</p>
<pre><code>   URL: &lt;https://docs.lammps.org/region.html&gt;

   Main properties = default value
       name = "union001"
   beadtype = 1
       fake = False (use True to test the execution)
</code></pre>
<p>index, subindex = object index and subindex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self,*regID,
          name=None,beadtype=1,fake=False,
          index = None,subindex = None,
          **variables):
    &#34;&#34;&#34;
    creates a union region
          union(&#34;reg-ID1&#34;,&#34;reg-ID2&#34;,name=&#34;myname&#34;,beadtype=1,...)
          reg-ID1,reg-ID2, ... = IDs of regions to join together

        URL: https://docs.lammps.org/region.html

        Main properties = default value
            name = &#34;union001&#34;
        beadtype = 1
            fake = False (use True to test the execution)
 index, subindex = object index and subindex
    &#34;&#34;&#34;
    kind = &#34;union&#34;
    if index is None: index = self.counter[&#34;all&#34;]+1
    if subindex is None: subindex = self.counter[kind]+1
    # create the object U with U for union
    U = Union((self.counter[&#34;all&#34;]+1,self.counter[kind]+1),
                  index=index,subindex=subindex,**variables)
    # feed USER fields
    if name not in (None,&#34;&#34;): U.name = name # object name (if not defined, default name will be used)
    if name in self.name: raise NameError(&#39;the name &#34;%s&#34; is already used&#39; % name)
    if beadtype is not None: U.beadtype = beadtype # bead type (if not defined, default index will apply)
    U.USER.ID = &#34;$&#34;+U.name        # add $ to prevent its execution
    U.USER.side, U.USER.move, U.USER.units, U.USER.rotate, U.USER.open = &#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;,&#34;&#34;
    # build arguments based on regID
    nregID = len(regID)
    if nregID&lt;2: raise ValueError(&#39;two objects must be given at least for an union&#39;)
    args = [None] # the number of arguments is not known yet
    validID = range(nregID)
    for ireg in validID:
        if isinstance(regID[ireg],int):
            if regID[ireg] in validID:
                args.append(self.names[regID[ireg]])
            else:
                raise IndexError(f&#34;the index {regID[ireg]} exceeds the number of objects {len(self)}&#34;)
        elif isinstance(regID[ireg],str):
            if regID[ireg] in self:
                args.append(regID[ireg])
            else:
                raise KeyError(f&#39;the object &#34;{regID[ireg]}&#34; does not exist&#39;)
        else:
            raise KeyError(f&#34;the {ireg+1}th object should be given as a string or an index&#34;)
        # prevent the creation of atoms merged (avoid duplicates)
        self.objects[regID[ireg]].FLAGSECTIONS[&#34;create&#34;] = False
    args[0] = len(regID)
    U.USER.args = args   # args = [....] as defined in the class Union
    # Create the object if not fake
    if fake:
        return U
    else:
        self.counter[&#34;all&#34;] += 1
        self.counter[kind] +=1
        self.objects[name] = U
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.regioncollection"><code class="flex name class">
<span>class <span class="ident">regioncollection</span></span>
<span>(</span><span>*obj, **kwobj)</span>
</code></dt>
<dd>
<div class="desc"><p>regioncollection class container (not to be called directly) </p>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class regioncollection(struct):
    &#34;&#34;&#34; regioncollection class container (not to be called directly) &#34;&#34;&#34;
    _type = &#34;collect&#34;               # object type
    _fulltype = &#34;Collections&#34;    # full name
    _ftype = &#34;collection&#34;        # field name
    def __init__(self,*obj,**kwobj):
        # store the objects with their alias
        super().__init__(**kwobj)
        # store objects with their real names
        for o in obj:
            if isinstance(o,region):
                s = struct.dict2struct(o.objects)
                list_s = s.keys()
                for i in range(len(list_s)): self.setattr(list_s[i], s[i].copy())
            elif o!=None:
                self.setattr(o.name, o.copy())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="region.regiondata"><code class="flex name class">
<span>class <span class="ident">regiondata</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>class of script parameters
Typical constructor:
DEFINITIONS = regiondata(
var1 = value1,
var2 = value2
)
See script, struct, param to get review all methods attached to it</p>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class regiondata(paramauto):
    &#34;&#34;&#34;
        class of script parameters
            Typical constructor:
                DEFINITIONS = regiondata(
                    var1 = value1,
                    var2 = value2
                    )
        See script, struct, param to get review all methods attached to it
    &#34;&#34;&#34;
    _type = &#34;RD&#34;
    _fulltype = &#34;region data&#34;
    _ftype = &#34;definition&#34;

    def generatorforlammps(self,verbose=False,hasvariables=False):
        &#34;&#34;&#34;
            generate LAMMPS code from regiondata (struct)
            generatorforlammps(verbose,hasvariables)
            hasvariables = False is used to prevent a call of generatorforLammps()
            for scripts others than LammpsGeneric ones
        &#34;&#34;&#34;
        nk = len(self)
        if nk&gt;0:
            self.sortdefinitions(raiseerror=False)
            s = self.tostruct()
            ik = 0
            fmt = &#34;variable %s equal %s&#34;
            cmd = &#34;\n#&#34;+&#34;_&#34;*40+&#34;\n&#34;+f&#34;#[{str(datetime.now())}]\n&#34; if verbose else &#34;&#34;
            cmd += f&#34;\n# Definition of {nk} variables (URL: https://docs.lammps.org/variable.html)\n&#34;
            if hasvariables:
                for k in s.keys():
                    ik += 1
                    end = &#34;\n&#34; if ik&lt;nk else &#34;\n&#34;*2
                    v = getattr(s,k)
                    if v is None: v = &#34;NULL&#34;
                    if isinstance(v,(int,float)) or v == None:
                        cmd += fmt % (k,v)+end
                    elif isinstance(v,str):
                        cmd += fmt % (k,f&#39;{v}&#39;)+end
                    elif isinstance(v,(list,tuple)):
                        cmd += fmt % (k,span(v))+end
                    else:
                        raise TypeError(f&#34;unsupported type for the variable {k} set to {v}&#34;)
                if verbose: cmd += &#34;#&#34;+&#34;_&#34;*40+&#34;\n&#34;
        return cmd</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.paramauto</li>
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="region.headersRegiondata" href="#region.headersRegiondata">headersRegiondata</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="region.regiondata.generatorforlammps"><code class="name flex">
<span>def <span class="ident">generatorforlammps</span></span>(<span>self, verbose=False, hasvariables=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generate LAMMPS code from regiondata (struct)
generatorforlammps(verbose,hasvariables)
hasvariables = False is used to prevent a call of generatorforLammps()
for scripts others than LammpsGeneric ones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generatorforlammps(self,verbose=False,hasvariables=False):
    &#34;&#34;&#34;
        generate LAMMPS code from regiondata (struct)
        generatorforlammps(verbose,hasvariables)
        hasvariables = False is used to prevent a call of generatorforLammps()
        for scripts others than LammpsGeneric ones
    &#34;&#34;&#34;
    nk = len(self)
    if nk&gt;0:
        self.sortdefinitions(raiseerror=False)
        s = self.tostruct()
        ik = 0
        fmt = &#34;variable %s equal %s&#34;
        cmd = &#34;\n#&#34;+&#34;_&#34;*40+&#34;\n&#34;+f&#34;#[{str(datetime.now())}]\n&#34; if verbose else &#34;&#34;
        cmd += f&#34;\n# Definition of {nk} variables (URL: https://docs.lammps.org/variable.html)\n&#34;
        if hasvariables:
            for k in s.keys():
                ik += 1
                end = &#34;\n&#34; if ik&lt;nk else &#34;\n&#34;*2
                v = getattr(s,k)
                if v is None: v = &#34;NULL&#34;
                if isinstance(v,(int,float)) or v == None:
                    cmd += fmt % (k,v)+end
                elif isinstance(v,str):
                    cmd += fmt % (k,f&#39;{v}&#39;)+end
                elif isinstance(v,(list,tuple)):
                    cmd += fmt % (k,span(v))+end
                else:
                    raise TypeError(f&#34;unsupported type for the variable {k} set to {v}&#34;)
            if verbose: cmd += &#34;#&#34;+&#34;_&#34;*40+&#34;\n&#34;
    return cmd</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.rigidwall"><code class="flex name class">
<span>class <span class="ident">rigidwall</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>rigid walls (smd:none):
rigidwall()
rigidwall(beadtype=index, userid="wall", USER=&hellip;)</p>
<p>override any propery with USER.parameter (set only the parameters you want to override)
USER.rho: density in kg/m3 (default=3000)
USER.c0: speed of the sound in m/s (default=10.0)
USER.contact_scale: scaling coefficient for contact (default=1.5)
USER.contact_stiffness: contact stifness in Pa (default="2.5<em>${c0}^2</em>${rho}")</p>
<p>rigidwall forcefield:
rigidwall(beadtype=index, userid="mywall")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class rigidwall(none):
    &#34;&#34;&#34; rigid walls (smd:none):
            rigidwall()
            rigidwall(beadtype=index, userid=&#34;wall&#34;, USER=...)

            override any propery with USER.parameter (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=3000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = none.name + struct(material=&#34;walls&#34;)
    description = none.description + struct(material=&#34;rigid walls&#34;)
    userid = &#39;solidfood&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; rigidwall forcefield:
            rigidwall(beadtype=index, userid=&#34;mywall&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            rho = 3000,
            c0 = 10.0,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;,
            contact_scale = 1.5
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.none</li>
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.rigidwall.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.rigidwall.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.rigidwall.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.rigidwall.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="region.saltTLSPH"><code class="flex name class">
<span>class <span class="ident">saltTLSPH</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>SALTLSPH (smd:tlsph): ongoing "salting" beadtype for rheology control
saltTLSPH()
saltTLSPH(beadtype=index, userid="salt", USER=&hellip;)</p>
<p>override any property with USER.property = value</p>
<p>saltTLSPH forcefield:
saltTLSPH(beadtype=index, userid="salt")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class saltTLSPH(tlsph):
    &#34;&#34;&#34; SALTLSPH (smd:tlsph): ongoing &#34;salting&#34; beadtype for rheology control
            saltTLSPH()
            saltTLSPH(beadtype=index, userid=&#34;salt&#34;, USER=...)

            override any property with USER.property = value
    &#34;&#34;&#34;
    name = tlsph.name + struct(material=&#34;solidfood&#34;)
    description = tlsph.description + struct(material=&#34;food beads - solid behavior&#34;)
    userid = &#39;&#34;salt&#34;&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; saltTLSPH forcefield:
            saltTLSPH(beadtype=index, userid=&#34;salt&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # food-food interactions
            rho = 1000,
            c0 = 10.0,
            E = &#39;5*${c0}^2*${rho}&#39;,
            nu = 0.3,
            q1 = 1.0,
            q2 = 0.0,
            Hg = 10,
            Cp = 1.0,
            sigma_yield = &#39;0.1*${E}&#39;,
            hardening = 0,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.tlsph</li>
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.saltTLSPH.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.saltTLSPH.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.saltTLSPH.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.saltTLSPH.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="region.scatter"><code class="flex name class">
<span>class <span class="ident">scatter</span></span>
</code></dt>
<dd>
<div class="desc"><p>generic top scatter class </p>
<p>The scatter class provides an easy constructor
to distribute in space objects according to their
positions x,y,z size r (radius) and beadtype.</p>
<p>The class is used to derive emulsions.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scatter():
    &#34;&#34;&#34; generic top scatter class &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        The scatter class provides an easy constructor
        to distribute in space objects according to their
        positions x,y,z size r (radius) and beadtype.

        The class is used to derive emulsions.

        Returns
        -------
        None.
        &#34;&#34;&#34;
        self.x = np.array([],dtype=int)
        self.y = np.array([],dtype=int)
        self.z = np.array([],dtype=int)
        self.r = np.array([],dtype=int)
        self.beadtype = []

    @property
    def n(self):
        return len(self.x)

    def pairdist(self,x,y,z):
        &#34;&#34;&#34; pair distance to the surface of all disks/spheres &#34;&#34;&#34;
        if self.n==0:
            return np.Inf
        else:
            return np.sqrt((x-self.x)**2+(y-self.y)**2+(z-self.z)**2)-self.r</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="region.emulsion" href="#region.emulsion">emulsion</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="region.scatter.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    return len(self.x)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.scatter.pairdist"><code class="name flex">
<span>def <span class="ident">pairdist</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>pair distance to the surface of all disks/spheres</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pairdist(self,x,y,z):
    &#34;&#34;&#34; pair distance to the surface of all disks/spheres &#34;&#34;&#34;
    if self.n==0:
        return np.Inf
    else:
        return np.sqrt((x-self.x)**2+(y-self.y)**2+(z-self.z)**2)-self.r</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.script"><code class="flex name class">
<span>class <span class="ident">script</span></span>
<span>(</span><span>persistentfile=True, persistentfolder=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>script: A Core Class for Flexible LAMMPS Script Generation</p>
<p>The <code><a title="region.script" href="#region.script">script</a></code> class provides a flexible framework for generating dynamic LAMMPS
script sections. It supports various LAMMPS sections such as "GLOBAL", "INITIALIZE",
"GEOMETRY", "INTERACTIONS", and more, while allowing users to define custom sections
with variable definitions, templates, and dynamic evaluation of script content.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Dynamic Script Generation</strong>: Easily define and manage script sections,
using templates and definitions to dynamically generate LAMMPS-compatible scripts.</li>
<li><strong>Script Concatenation</strong>: Combine multiple script sections while managing
variable precedence and ensuring that definitions propagate as expected.</li>
<li><strong>Flexible Variable Management</strong>: Separate <code>DEFINITIONS</code> for static variables and
<code>USER</code> for user-defined variables, with clear rules for inheritance and precedence.</li>
<li><strong>Operators for Advanced Script Handling</strong>: Use <code>+</code>, <code>&amp;</code>, <code>&gt;&gt;</code>, <code>|</code>, and <code>**</code> operators
for script merging, static execution, right-shifting of definitions, and more.</li>
<li><strong>Pipeline Support</strong>: Integrate scripts into pipelines, with full support for
staged execution, variable inheritance, and reordering of script sections.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>LAMMPS Automation</strong>: Automate the generation of complex LAMMPS scripts by defining
reusable script sections with variables and templates.</li>
<li><strong>Multi-Step Simulations</strong>: Manage multi-step simulations by splitting large scripts
into smaller, manageable sections and combining them as needed.</li>
<li><strong>Advanced Script Control</strong>: Dynamically modify script behavior by overriding variables
or using advanced operators to concatenate, pipe, or merge scripts.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, persistentfile=True, persistentfolder=None, printflag=False, verbose=False, **userdefinitions):
Initializes a new <code><a title="region.script" href="#region.script">script</a></code> object, with optional user-defined variables
passed as <code>userdefinitions</code>.</p>
<p>do(self, printflag=None, verbose=None):
Generates the LAMMPS script based on the current configuration, evaluating
templates and definitions to produce the final output.</p>
<p>script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Generate the final LAMMPS script from the pipeline or a subset of the pipeline.</p>
<p>add(self, s):
Overloads the <code>+</code> operator to concatenate script objects, merging definitions
and templates while maintaining variable precedence.</p>
<p>and(self, s):
Overloads the <code>&amp;</code> operator for static execution, combining the generated scripts
of two script objects without merging their definitions.</p>
<p><strong>mul</strong>(self, ntimes):
Overloads the <code>*</code> operator to repeat the script <code>ntimes</code>, returning a new script
object with repeated sections.</p>
<p><strong>pow</strong>(self, ntimes):
Overloads the <code>**</code> operator to concatenate the script with itself <code>ntimes</code>,
similar to the <code>&amp;</code> operator, but repeated.</p>
<p><strong>or</strong>(self, pipe):
Overloads the pipe (<code>|</code>) operator to integrate the script into a pipeline,
returning a <code><a title="region.pipescript" href="#region.pipescript">pipescript</a></code> object.</p>
<p>write(self, file, printflag=True, verbose=False):
Writes the generated script to a file, including headers with metadata.</p>
<p>tmpwrite(self):
Writes the script to a temporary file, creating both a full version and a clean
version without comments.</p>
<p>printheader(txt, align="^", width=80, filler="~"):
Static method to print formatted headers, useful for organizing output.</p>
<p><strong>copy</strong>(self):
Creates a shallow copy of the script object.</p>
<p><strong>deepcopy</strong>(self, memo):
Creates a deep copy of the script object, duplicating all internal variables.</p>
<h2 id="additional-features">Additional Features:</h2>
<ul>
<li><strong>Customizable Templates</strong>: Use string templates with variable placeholders
(e.g., <code>${value}</code>) to dynamically generate script lines.</li>
<li><strong>Static and User-Defined Variables</strong>: Manage global <code>DEFINITIONS</code> for static
variables and <code>USER</code> variables for dynamic, user-defined settings.</li>
<li><strong>Advanced Operators</strong>: Leverage a range of operators (<code>+</code>, <code>&gt;&gt;</code>, <code>|</code>, <code>&amp;</code>) to
manipulate script content, inherit definitions, and control variable precedence.</li>
<li><strong>Verbose Output</strong>: Control verbosity to include detailed comments and debugging
information in generated scripts.</li>
</ul>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="region.script" href="#region.script">script</a></code> class supports LAMMPS section generation and variable management with
features such as:
- <strong>Dynamic Evaluation of Scripts</strong>: Definitions and templates are evaluated at runtime,
allowing for flexible and reusable scripts.
- <strong>Inheritance of Definitions</strong>: Variable definitions can be inherited from previous
sections, allowing for modular script construction.
- <strong>Precedence Rules for Variables</strong>: When scripts are concatenated, definitions from
the left take precedence, ensuring that the first defined values are preserved.
- <strong>Instance and Global Variables</strong>: Instance variables are set via the <code>USER</code> object,
while global variables (shared across instances) are managed in <code>DEFINITIONS</code>.
- <strong>Script Pipelines</strong>: Scripts can be integrated into pipelines for sequential execution
and dynamic variable propagation.
- <strong>Flexible Output Formats</strong>: Lists are expanded into space-separated strings, while
tuples are expanded with commas, making the output more readable.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>from pizza.script import script, scriptdata

class example_section(script):
    DEFINITIONS = scriptdata(
        X = 10,
        Y = 20,
        result = &quot;${X} + ${Y}&quot;
    )
    TEMPLATE = &quot;${result} = ${X} + ${Y}&quot;

s1 = example_section()
s1.USER.X = 5
s1.do()
</code></pre>
<p>The output for <code>s1.do()</code> will be:</p>
<pre><code>25 = 5 + 20
</code></pre>
<p>With additional sections, scripts can be concatenated and executed as a single
entity, with inheritance of variables and customizable behavior.</p>
<pre><code>--------------------------------------
   OVERVIEW ANDE DETAILED FEATURES
--------------------------------------

The class script enables to generate dynamically LAMMPS sections
"NONE","GLOBAL","INITIALIZE","GEOMETRY","DISCRETIZATION",
"BOUNDARY","INTERACTIONS","INTEGRATION","DUMP","STATUS","RUN"


# %% This the typical construction for a class
class XXXXsection(script):
    "" " LAMMPS script: XXXX session "" "
    name = "XXXXXX"
    description = name+" section"
    position = 0
    section = 0
    userid = "example"
    version = 0.1

    DEFINITIONS = scriptdata(
         value= 1,
    expression= "${value+1}",
          text= "$my text"
        )

    TEMPLATE = "" "
# :UNDEF SECTION:
#   to be defined
LAMMPS code with ${value}, ${expression}, ${text}
    "" "

DEFINTIONS can be inherited from a previous section
DEFINITIONS = previousection.DEFINTIONS + scriptdata(
         value= 1,
    expression= "${value+1}",
          text= "$my text"
    )


Recommandation: Split a large script into a small classes or actions
An example of use could be:
    move1 = translation(displacement=10)+rotation(angle=30)
    move2 = shear(rate=0.1)+rotation(angle=20)
    bigmove = move1+move2+move1
    script = bigmove.do() generates the script

NOTE1: Use the print() and the method do() to get the script interpreted

NOTE2: DEFINITIONS can be pretified using DEFINITIONS.generator()

NOTE3: Variables can extracted from a template using TEMPLATE.scan()

NOTE4: Scripts can be joined (from top down to bottom).
The first definitions keep higher precedence. Please do not use
a variable twice with different contents.

myscript = s1 + s2 + s3 will propagate the definitions
without overwritting previous values). myscript will be
defined as s1 (same name, position, userid, etc.)

myscript += s appends the script section s to myscript

NOTE5: rules of precedence when script are concatenated
The attributes from the class (name, description...) are kept from the left
The values of the right overwrite all DEFINITIONS

NOTE6: user variables (instance variables) can set with USER or at the construction
myclass_instance = myclass(myvariable = myvalue)
myclass_instance.USER.myvariable = myvalue

NOTE7: how to change variables for all instances at once?
In the example below, let x is a global variable (instance independent)
and y a local variable (instance dependent)
instance1 = myclass(y=1) --&gt; y=1 in instance1
instance2 = myclass(y=2) --&gt; y=2 in instance2
instance3.USER.y=3 --&gt; y=3 in instance3
instance1.DEFINITIONS.x = 10 --&gt; x=10 in all instances (1,2,3)

If x is also defined in the USER section, its value will be used
Setting instance3.USER.x = 30 will assign x=30 only in instance3

NOTE8: if a the script is used with different values for a same parameter
use the operator &amp; to concatenate the results instead of the script
example: load(file="myfile1") &amp; load(file="myfile2) &amp; load(file="myfile3")+...

NOTE9: lists (e.g., [1,2,'a',3] are expanded ("1 2 a 3")
       tuples (e.g. (1,2)) are expanded ("1,2")
       It is easier to read ["lost","ignore"] than "$ lost ignore"

NOTE 10: New operators &gt;&gt; and || extend properties
    + merge all scripts but overwrite definitions
    &amp; execute statically script content
    &gt;&gt; pass only DEFINITIONS but not TEMPLATE to the right
    | pipe execution such as in Bash, the result is a pipeline

NOTE 11: Scripts in pipelines are very flexible, they support
full indexing à la Matlab, including staged executions
    method do(idx) generates the script corresponding to indices idx
    method script(idx) generates the corresponding script object

--------------------------[ FULL EXAMPLE ]-----------------------------

# Import the class
from pizza.script import *

# Override the class globalsection
class scriptexample(globalsection):
    description = "demonstrate commutativity of additions"
    verbose = True

    DEFINITIONS = scriptdata(
        X = 10,
        Y = 20,
        R1 = "${X}+${Y}",
        R2 = "${Y}+${X}"
        )
    TEMPLATE = "" "
    # Property of the addition
    ${R1} = ${X} + ${Y}
    ${R2} = ${Y} + ${X}
 "" "

# derived from scriptexample, X and Y are reused
class scriptexample2(scriptexample):
    description = "demonstrate commutativity of multiplications"
    verbose = True
    DEFINITIONS = scriptexample.DEFINITIONS + scriptdata(
        R3 = "${X} * ${Y}",
        R4 = "${Y} * ${X}",
        )
    TEMPLATE = "" "
    # Property of the multiplication
    ${R3} = ${X} * ${Y}
    ${R4} = ${Y} * ${X}
 "" "

# call the first class and override the values X and Y
s1 = scriptexample()
s1.USER.X = 1  # method 1 of override
s1.USER.Y = 2
s1.do()
# call the second class and override the values X and Y
s2 = scriptexample2(X=1000,Y=2000) # method 2
s2.do()
# Merge the two scripts
s = s1+s2
print("this is my full script")
s.description
s.do()

# The result for s1 is
    3 = 1 + 2
    3 = 2 + 1
# The result for s2 is
    2000000 = 1000 * 2000
    2000000 = 2000 * 1000
# The result for s=s1+s2 is
    # Property of the addition
    3000 = 1000 + 2000
    3000 = 2000 + 1000
    # Property of the multiplication
    2000000 = 1000 * 2000
    2000000 = 2000 * 1000
</code></pre>
<p>constructor adding instance definitions stored in USER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class script:
    &#34;&#34;&#34;
    script: A Core Class for Flexible LAMMPS Script Generation

    The `script` class provides a flexible framework for generating dynamic LAMMPS
    script sections. It supports various LAMMPS sections such as &#34;GLOBAL&#34;, &#34;INITIALIZE&#34;,
    &#34;GEOMETRY&#34;, &#34;INTERACTIONS&#34;, and more, while allowing users to define custom sections
    with variable definitions, templates, and dynamic evaluation of script content.

    Key Features:
    -------------
    - **Dynamic Script Generation**: Easily define and manage script sections,
      using templates and definitions to dynamically generate LAMMPS-compatible scripts.
    - **Script Concatenation**: Combine multiple script sections while managing
      variable precedence and ensuring that definitions propagate as expected.
    - **Flexible Variable Management**: Separate `DEFINITIONS` for static variables and
      `USER` for user-defined variables, with clear rules for inheritance and precedence.
    - **Operators for Advanced Script Handling**: Use `+`, `&amp;`, `&gt;&gt;`, `|`, and `**` operators
      for script merging, static execution, right-shifting of definitions, and more.
    - **Pipeline Support**: Integrate scripts into pipelines, with full support for
      staged execution, variable inheritance, and reordering of script sections.

    Practical Use Cases:
    --------------------
    - **LAMMPS Automation**: Automate the generation of complex LAMMPS scripts by defining
      reusable script sections with variables and templates.
    - **Multi-Step Simulations**: Manage multi-step simulations by splitting large scripts
      into smaller, manageable sections and combining them as needed.
    - **Advanced Script Control**: Dynamically modify script behavior by overriding variables
      or using advanced operators to concatenate, pipe, or merge scripts.

    Methods:
    --------
    __init__(self, persistentfile=True, persistentfolder=None, printflag=False, verbose=False, **userdefinitions):
        Initializes a new `script` object, with optional user-defined variables
        passed as `userdefinitions`.

    do(self, printflag=None, verbose=None):
        Generates the LAMMPS script based on the current configuration, evaluating
        templates and definitions to produce the final output.

    script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Generate the final LAMMPS script from the pipeline or a subset of the pipeline.

    add(self, s):
        Overloads the `+` operator to concatenate script objects, merging definitions
        and templates while maintaining variable precedence.

    and(self, s):
        Overloads the `&amp;` operator for static execution, combining the generated scripts
        of two script objects without merging their definitions.

    __mul__(self, ntimes):
        Overloads the `*` operator to repeat the script `ntimes`, returning a new script
        object with repeated sections.

    __pow__(self, ntimes):
        Overloads the `**` operator to concatenate the script with itself `ntimes`,
        similar to the `&amp;` operator, but repeated.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the script into a pipeline,
        returning a `pipescript` object.

    write(self, file, printflag=True, verbose=False):
        Writes the generated script to a file, including headers with metadata.

    tmpwrite(self):
        Writes the script to a temporary file, creating both a full version and a clean
        version without comments.

    printheader(txt, align=&#34;^&#34;, width=80, filler=&#34;~&#34;):
        Static method to print formatted headers, useful for organizing output.

    __copy__(self):
        Creates a shallow copy of the script object.

    __deepcopy__(self, memo):
        Creates a deep copy of the script object, duplicating all internal variables.

    Additional Features:
    --------------------
    - **Customizable Templates**: Use string templates with variable placeholders
      (e.g., `${value}`) to dynamically generate script lines.
    - **Static and User-Defined Variables**: Manage global `DEFINITIONS` for static
      variables and `USER` variables for dynamic, user-defined settings.
    - **Advanced Operators**: Leverage a range of operators (`+`, `&gt;&gt;`, `|`, `&amp;`) to
      manipulate script content, inherit definitions, and control variable precedence.
    - **Verbose Output**: Control verbosity to include detailed comments and debugging
      information in generated scripts.

    Original Content:
    -----------------
    The `script` class supports LAMMPS section generation and variable management with
    features such as:
    - **Dynamic Evaluation of Scripts**: Definitions and templates are evaluated at runtime,
      allowing for flexible and reusable scripts.
    - **Inheritance of Definitions**: Variable definitions can be inherited from previous
      sections, allowing for modular script construction.
    - **Precedence Rules for Variables**: When scripts are concatenated, definitions from
      the left take precedence, ensuring that the first defined values are preserved.
    - **Instance and Global Variables**: Instance variables are set via the `USER` object,
      while global variables (shared across instances) are managed in `DEFINITIONS`.
    - **Script Pipelines**: Scripts can be integrated into pipelines for sequential execution
      and dynamic variable propagation.
    - **Flexible Output Formats**: Lists are expanded into space-separated strings, while
      tuples are expanded with commas, making the output more readable.

    Example Usage:
    --------------
    ```
    from pizza.script import script, scriptdata

    class example_section(script):
        DEFINITIONS = scriptdata(
            X = 10,
            Y = 20,
            result = &#34;${X} + ${Y}&#34;
        )
        TEMPLATE = &#34;${result} = ${X} + ${Y}&#34;

    s1 = example_section()
    s1.USER.X = 5
    s1.do()
    ```

    The output for `s1.do()` will be:
    ```
    25 = 5 + 20
    ```

    With additional sections, scripts can be concatenated and executed as a single
    entity, with inheritance of variables and customizable behavior.


        --------------------------------------
           OVERVIEW ANDE DETAILED FEATURES
        --------------------------------------

        The class script enables to generate dynamically LAMMPS sections
        &#34;NONE&#34;,&#34;GLOBAL&#34;,&#34;INITIALIZE&#34;,&#34;GEOMETRY&#34;,&#34;DISCRETIZATION&#34;,
        &#34;BOUNDARY&#34;,&#34;INTERACTIONS&#34;,&#34;INTEGRATION&#34;,&#34;DUMP&#34;,&#34;STATUS&#34;,&#34;RUN&#34;


        # %% This the typical construction for a class
        class XXXXsection(script):
            &#34;&#34; &#34; LAMMPS script: XXXX session &#34;&#34; &#34;
            name = &#34;XXXXXX&#34;
            description = name+&#34; section&#34;
            position = 0
            section = 0
            userid = &#34;example&#34;
            version = 0.1

            DEFINITIONS = scriptdata(
                 value= 1,
            expression= &#34;${value+1}&#34;,
                  text= &#34;$my text&#34;
                )

            TEMPLATE = &#34;&#34; &#34;
        # :UNDEF SECTION:
        #   to be defined
        LAMMPS code with ${value}, ${expression}, ${text}
            &#34;&#34; &#34;

        DEFINTIONS can be inherited from a previous section
        DEFINITIONS = previousection.DEFINTIONS + scriptdata(
                 value= 1,
            expression= &#34;${value+1}&#34;,
                  text= &#34;$my text&#34;
            )


        Recommandation: Split a large script into a small classes or actions
        An example of use could be:
            move1 = translation(displacement=10)+rotation(angle=30)
            move2 = shear(rate=0.1)+rotation(angle=20)
            bigmove = move1+move2+move1
            script = bigmove.do() generates the script

        NOTE1: Use the print() and the method do() to get the script interpreted

        NOTE2: DEFINITIONS can be pretified using DEFINITIONS.generator()

        NOTE3: Variables can extracted from a template using TEMPLATE.scan()

        NOTE4: Scripts can be joined (from top down to bottom).
        The first definitions keep higher precedence. Please do not use
        a variable twice with different contents.

        myscript = s1 + s2 + s3 will propagate the definitions
        without overwritting previous values). myscript will be
        defined as s1 (same name, position, userid, etc.)

        myscript += s appends the script section s to myscript

        NOTE5: rules of precedence when script are concatenated
        The attributes from the class (name, description...) are kept from the left
        The values of the right overwrite all DEFINITIONS

        NOTE6: user variables (instance variables) can set with USER or at the construction
        myclass_instance = myclass(myvariable = myvalue)
        myclass_instance.USER.myvariable = myvalue

        NOTE7: how to change variables for all instances at once?
        In the example below, let x is a global variable (instance independent)
        and y a local variable (instance dependent)
        instance1 = myclass(y=1) --&gt; y=1 in instance1
        instance2 = myclass(y=2) --&gt; y=2 in instance2
        instance3.USER.y=3 --&gt; y=3 in instance3
        instance1.DEFINITIONS.x = 10 --&gt; x=10 in all instances (1,2,3)

        If x is also defined in the USER section, its value will be used
        Setting instance3.USER.x = 30 will assign x=30 only in instance3

        NOTE8: if a the script is used with different values for a same parameter
        use the operator &amp; to concatenate the results instead of the script
        example: load(file=&#34;myfile1&#34;) &amp; load(file=&#34;myfile2) &amp; load(file=&#34;myfile3&#34;)+...

        NOTE9: lists (e.g., [1,2,&#39;a&#39;,3] are expanded (&#34;1 2 a 3&#34;)
               tuples (e.g. (1,2)) are expanded (&#34;1,2&#34;)
               It is easier to read [&#34;lost&#34;,&#34;ignore&#34;] than &#34;$ lost ignore&#34;

        NOTE 10: New operators &gt;&gt; and || extend properties
            + merge all scripts but overwrite definitions
            &amp; execute statically script content
            &gt;&gt; pass only DEFINITIONS but not TEMPLATE to the right
            | pipe execution such as in Bash, the result is a pipeline

        NOTE 11: Scripts in pipelines are very flexible, they support
        full indexing à la Matlab, including staged executions
            method do(idx) generates the script corresponding to indices idx
            method script(idx) generates the corresponding script object

        --------------------------[ FULL EXAMPLE ]-----------------------------

        # Import the class
        from pizza.script import *

        # Override the class globalsection
        class scriptexample(globalsection):
            description = &#34;demonstrate commutativity of additions&#34;
            verbose = True

            DEFINITIONS = scriptdata(
                X = 10,
                Y = 20,
                R1 = &#34;${X}+${Y}&#34;,
                R2 = &#34;${Y}+${X}&#34;
                )
            TEMPLATE = &#34;&#34; &#34;
            # Property of the addition
            ${R1} = ${X} + ${Y}
            ${R2} = ${Y} + ${X}
         &#34;&#34; &#34;

        # derived from scriptexample, X and Y are reused
        class scriptexample2(scriptexample):
            description = &#34;demonstrate commutativity of multiplications&#34;
            verbose = True
            DEFINITIONS = scriptexample.DEFINITIONS + scriptdata(
                R3 = &#34;${X} * ${Y}&#34;,
                R4 = &#34;${Y} * ${X}&#34;,
                )
            TEMPLATE = &#34;&#34; &#34;
            # Property of the multiplication
            ${R3} = ${X} * ${Y}
            ${R4} = ${Y} * ${X}
         &#34;&#34; &#34;

        # call the first class and override the values X and Y
        s1 = scriptexample()
        s1.USER.X = 1  # method 1 of override
        s1.USER.Y = 2
        s1.do()
        # call the second class and override the values X and Y
        s2 = scriptexample2(X=1000,Y=2000) # method 2
        s2.do()
        # Merge the two scripts
        s = s1+s2
        print(&#34;this is my full script&#34;)
        s.description
        s.do()

        # The result for s1 is
            3 = 1 + 2
            3 = 2 + 1
        # The result for s2 is
            2000000 = 1000 * 2000
            2000000 = 2000 * 1000
        # The result for s=s1+s2 is
            # Property of the addition
            3000 = 1000 + 2000
            3000 = 2000 + 1000
            # Property of the multiplication
            2000000 = 1000 * 2000
            2000000 = 2000 * 1000

    &#34;&#34;&#34;

    # metadata
    metadata = get_metadata()               # retrieve all metadata

    type = &#34;script&#34;                         # type (class name)
    name = &#34;empty script&#34;                   # name
    description = &#34;it is an empty script&#34;   # description
    position = 0                            # 0 = root
    section = 0                             # section (0=undef)
    userid = &#34;undefined&#34;                    # user name
    version = metadata[&#34;version&#34;]           # version
    license = metadata[&#34;license&#34;]
    email = metadata[&#34;email&#34;]               # email

    verbose = False                         # set it to True to force verbosity
    _contact = (&#34;INRAE\SAYFOOD\olivier.vitrac@agroparistech.fr&#34;,
                &#34;INRAE\SAYFOOD\william.jenkinson@agroparistech.fr&#34;,
                &#34;INRAE\SAYFOOD\han.chen@inrae.fr&#34;)

    SECTIONS = [&#34;NONE&#34;,&#34;GLOBAL&#34;,&#34;INITIALIZE&#34;,&#34;GEOMETRY&#34;,&#34;DISCRETIZATION&#34;,
                &#34;BOUNDARY&#34;,&#34;INTERACTIONS&#34;,&#34;INTEGRATION&#34;,&#34;DUMP&#34;,&#34;STATUS&#34;,&#34;RUN&#34;]

    # Main class variables
    # These definitions are for instances
    DEFINITIONS = scriptdata()
    TEMPLATE = &#34;&#34;&#34;
        # empty LAMMPS script
    &#34;&#34;&#34;

    # constructor
    def __init__(self,persistentfile=True,
                 persistentfolder = None,
                 printflag = False,
                 verbose = False,
                 verbosity = None,
                 **userdefinitions):
        &#34;&#34;&#34; constructor adding instance definitions stored in USER &#34;&#34;&#34;
        if persistentfolder is None: persistentfolder = get_tmp_location()
        self.persistentfile = persistentfile
        self.persistentfolder = persistentfolder
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.USER = scriptdata(**userdefinitions)

    # print method for headers (static, no implicit argument)
    @staticmethod
    def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
        &#34;&#34;&#34; print header &#34;&#34;&#34;
        if txt==&#34;&#34;:
            print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
        else:
            print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))

    # String representation
    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self.type}:{self.name}:{self.userid}&#34;

    # Display/representation method
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        stamp = str(self)
        self.printheader(f&#34;{stamp} | version={self.version}&#34;,filler=&#34;/&#34;)
        self.printheader(&#34;POSITION &amp; DESCRIPTION&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        print(f&#34;     position: {self.position}&#34;)
        print(f&#34;         role: {self.role} (section={self.section})&#34;)
        print(f&#34;  description: {self.description}&#34;)
        self.printheader(&#34;DEFINITIONS&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        if len(self.DEFINITIONS)&lt;15:
            self.DEFINITIONS.__repr__()
        else:
            print(&#34;too many definitions: &#34;,self.DEFINITIONS)
        if self.verbose:
            self.printheader(&#34;USER&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
            self.USER.__repr__()
            self.printheader(&#34;TEMPLATE&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
            print(self.TEMPLATE)
            self.printheader(&#34;SCRIPT&#34;,filler=&#34;-&#34;,align=&#34;&gt;&#34;)
        print(self.do(printflag=False))
        self.printheader(&#34;&#34;)
        return stamp

    # Extract attributes within the class
    def getallattributes(self):
        &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
        return {k: getattr(self, k) for k in dir(self) \
                if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}

    # Generate the script
    def do(self,printflag=None,verbose=None):
        &#34;&#34;&#34;
        Generate the LAMMPS script based on the current configuration.

        This method generates a LAMMPS-compatible script from the templates and definitions
        stored in the `script` object. The generated script can be displayed, returned,
        and optionally include comments for debugging or clarity.

        Parameters:
        -----------
        - printflag (bool, optional): If True, the generated script is printed to the console.
                                      Default is True.
        - verbose (bool, optional): If True, comments and additional information are included
                                    in the generated script. If False, comments are removed.
                                    Default is True.

        Returns:
        ---------
        - str: The generated LAMMPS script.

        Method Behavior:
        - The method first collects all key-value pairs from `DEFINITIONS` and `USER` objects,
          which store the configuration data for the script.
        - Lists and tuples in the collected data are formatted into a readable string with proper
          separators (space for lists, comma for tuples) and prefixed with a &#39;%&#39; to indicate comments.
        - The generated command template is formatted and evaluated using the collected data.
        - If `verbose` is set to False, comments in the generated script are removed.
        - The script is then printed if `printflag` is True.
        - Finally, the formatted script is returned as a string.


        Example Usage:
        --------------
        &gt;&gt;&gt; s = script()
        &gt;&gt;&gt; s.do(printflag=True, verbose=True)
        units           si
        dimension       3
        boundary        f f f
        # Additional script commands...

        &gt;&gt;&gt; s.do(printflag=False, verbose=False)
        &#39;units si\ndimension 3\nboundary f f f\n# Additional script commands...&#39;

        Notes:
        - Comments are indicated in the script with &#39;%&#39; or &#39;#&#39;.
        - The [position {self.position}:{self.userid}] marker is inserted for tracking
          script sections or modifications.


        Known Issues for indexed variables
        ----------------------------------
        List and tupples used indexed in templates, such as varlist[1], are not converted into strings so that
        each element can be considered as a variable and accessed as ${varlist[1]}. If varlist is also used in
        full, such as ${varlist}. Then it is preferable to define varlist as a string:
            &#34;![v1,v2,...]&#34; where v1,v2,v3 can be int, float, static str or evaluable str (i.e., subjected to nested
             evaluation).
        The control character ! in lists, such as in var=![v1,v2,v3] preserves the Pythonic definition by do()
        at later stages during the evaluation so that its content can be indexed.

        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        inputs = self.DEFINITIONS + self.USER
        usedvariables = self.detect_variables(with_index=False,only_indexed=False)
        variables_used_with_index = self.detect_variables(with_index=False,only_indexed=True)
        usedvariables_withoutindex = [ var for var in usedvariables if var not in variables_used_with_index ]
        for k in inputs.keys():
            if k in usedvariables_withoutindex:
                if isinstance(inputs.getattr(k),list):
                    inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k)))
                elif isinstance(inputs.getattr(k),tuple):
                    inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k),sep=&#34;,&#34;))
        cmd = inputs.formateval(self.TEMPLATE)
        cmd = cmd.replace(&#34;[comment]&#34;,f&#34;[position {self.position}:{self.userid}]&#34;)
        if not verbose: cmd=remove_comments(cmd)
        if printflag: print(cmd)
        return cmd

    # Return the role of the script (based on section)
    @property
    def role(self):
        &#34;&#34;&#34; convert section index into a role (section name) &#34;&#34;&#34;
        if self.section in range(len(self.SECTIONS)):
            return self.SECTIONS[self.section]
        else:
            return &#34;&#34;

    # override +
    def __add__(self,s):
        &#34;&#34;&#34; overload addition operator &#34;&#34;&#34;
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        if isinstance(s,script):
            dup = duplicate(self)
            dup.DEFINITIONS = dup.DEFINITIONS + s.DEFINITIONS
            dup.USER = dup.USER + s.USER
            dup.TEMPLATE = &#34;\n&#34;.join([dup.TEMPLATE,s.TEMPLATE])
            return dup
        elif isinstance(s,pipescript):
            return pipescript(self, printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity) | s
        elif isinstance(s,dscript):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        elif isinstance(s, scriptobjectgroup):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s, group):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        elif isinstance(s, groupcollection):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s,region):
            return self + s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        raise TypeError(f&#34;the second operand in + must a script, pipescript, scriptobjectgroup,\n group, groupcollection or region object not {type(s)}&#34;)

    # override +=
    def _iadd__(self,s):
        &#34;&#34;&#34; overload addition operator &#34;&#34;&#34;
        if isinstance(s,script):
            self.DEFINITIONS = self.DEFINITIONS + s.DEFINITIONS
            self.USER = self.USER + s.USER
            self.TEMPLATE = &#34;\n&#34;.join([self.TEMPLATE,s.TEMPLATE])
        else:
            raise TypeError(&#34;the second operand must a script object&#34;)

    # override &gt;&gt;
    def __rshift__(self,s):
        &#34;&#34;&#34; overload right  shift operator (keep only the last template) &#34;&#34;&#34;
        if isinstance(s,script):
            dup = duplicate(self)
            dup.DEFINITIONS = dup.DEFINITIONS + s.DEFINITIONS
            dup.USER = dup.USER + s.USER
            dup.TEMPLATE = s.TEMPLATE
            return dup
        else:
            raise TypeError(f&#34;the second operand in &gt;&gt; must a script object not {type(s)}&#34;)

    # override &amp;
    def __and__(self,s):
        &#34;&#34;&#34; overload and operator &#34;&#34;&#34;
        if isinstance(s,script):
            dup = duplicate(self)
            dup.TEMPLATE = &#34;\n&#34;.join([self.do(printflag=False,verbose=False),s.do(printflag=False,verbose=False)])
            return dup
        raise TypeError(f&#34;the second operand in &amp; must a script object not {type(s)}&#34;)

    # override *
    def __mul__(self,ntimes):
        &#34;&#34;&#34; overload * operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
           res = duplicate(self)
           if ntimes&gt;1:
               for n in range(1,ntimes): res += self
           return res
        raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)

    # override **
    def __pow__(self,ntimes):
        &#34;&#34;&#34; overload ** operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
           res = duplicate(self)
           if ntimes&gt;1:
               for n in range(1,ntimes): res = res &amp; self
           return res
        raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)

    # pipe scripts
    def __or__(self,pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        if isinstance(pipe, dscript):
            rightarg = pipe.pipescript(printflag=pipe.printflag,verbose=pipe.verbose,verbosity=pipe.verbosity)
        elif isinstance(pipe,group):
            rightarg = pipe.script(printflag=pipe.printflag,verbose=pipe.verbose,verbosity=pipe.verbosity)
        elif isinstance(pipe,groupcollection):
            rightarg = pipe.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(pipe,region):
            rightarg = pipe.pscript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        else:
            rightarg = pipe
        if isinstance(rightarg,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | rightarg
        else:
            raise ValueError(&#34;the argument in | must a pipescript, a scriptobject or a scriptobjectgroup not {type(s)}&#34;)


    def header(self, verbose=True, verbosity=None, style=2):
        &#34;&#34;&#34;
        Generate a formatted header for the script file.

        Parameters:
            verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                        Defaults to the instance&#39;s `verbose`.
            style (int from 1 to 6, optional): ASCII style to frame the header (default=2)

        Returns:
            str: A formatted string representing the script&#39;s metadata and initialization details.
                 Returns an empty string if verbosity is False.

        The header includes:
            - Script version, license, and contact email.
            - User ID and the number of initialized definitions.
            - Current system user, hostname, and working directory.
            - Persistent filename and folder path.
            - Timestamp of the header generation.
        &#34;&#34;&#34;
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        if not verbose:
            return &#34;&#34;
        # Prepare the header content
        lines = [
            f&#34;PIZZA.SCRIPT FILE v{script.version} | License: {script.license} | Email: {script.email}&#34;,
            &#34;&#34;,
            f&#34;&lt;{str(self)}&gt;&#34;,
            f&#34;Initialized with {len(self.USER)} definitions | Verbosity: {verbosity}&#34;,
            f&#34;Persistent file: \&#34;{self.persistentfile}\&#34; | Folder: \&#34;{self.persistentfolder}\&#34;&#34;,
            &#34;&#34;,
            f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
            f&#34;{datetime.datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
        ]
        # Use the shared method to format the header
        return frame_header(lines,style=style)


    # write file
    def write(self, file, printflag=True, verbose=False, overwrite=False, style=2):
        &#34;&#34;&#34;
        Write the script to a file.

        Parameters:
            - file (str): The file path where the script will be saved.
            - printflag (bool): Flag to enable/disable printing of details.
            - verbose (bool): Flag to enable/disable verbose mode.
            - overwrite (bool): Whether to overwrite the file if it already exists.
            - style (int, optional):
                Defines the ASCII frame style for the header.
                Valid values are integers from 1 to 6, corresponding to predefined styles:
                    1. Basic box with `+`, `-`, and `|`
                    2. Double-line frame with `╔`, `═`, and `║`
                    3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                    4. Thick outer frame with `#`, `=`, and `#`
                    5. Box drawing characters with `┌`, `─`, and `│`
                    6. Minimalist dotted frame with `.`, `:`, and `.`
                Default is `2` (frame with rounded corners).

        Returns:
            str: The full absolute path of the file written.

        Raises:
            FileExistsError: If the file already exists and overwrite is False.
        &#34;&#34;&#34;
        # Resolve full path
        full_path = os.path.abspath(file)
        if os.path.exists(full_path) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{full_path}&#39; already exists. Use overwrite=True to overwrite it.&#34;)
        if os.path.exists(full_path) and overwrite and verbose:
            print(f&#34;Warning: Overwriting the existing file &#39;{full_path}&#39;.&#34;)
        # Generate the script and write to the file
        cmd = self.do(printflag=printflag, verbose=verbose)
        with open(full_path, &#34;w&#34;) as f:
            print(self.header(verbosity=verbose, style=style), &#34;\n&#34;, file=f)
            print(cmd, file=f)
        # Return the full path of the written file
        return full_path

    def tmpwrite(self, verbose=False, style=1):
        &#34;&#34;&#34;
        Write the script to a temporary file and create optional persistent copies.

        Parameters:
            verbose (bool, optional): Controls verbosity during script generation. Defaults to False.

        The method:
            - Creates a temporary file for the script, with platform-specific behavior:
                - On Windows (`os.name == &#39;nt&#39;`), the file is not automatically deleted.
                - On other systems, the file is temporary and deleted upon closure.
            - Writes a header and the script content into the temporary file.
            - Optionally creates a persistent copy in the `self.persistentfolder` directory:
                - `script.preview.&lt;suffix&gt;`: A persistent copy of the temporary file.
                - `script.preview.clean.&lt;suffix&gt;`: A clean copy with comments and empty lines removed.
            - Handles cleanup and exceptions gracefully to avoid leaving orphaned files.
            - style (int, optional):
                Defines the ASCII frame style for the header.
                Valid values are integers from 1 to 6, corresponding to predefined styles:
                    1. Basic box with `+`, `-`, and `|`
                    2. Double-line frame with `╔`, `═`, and `║`
                    3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                    4. Thick outer frame with `#`, `=`, and `#`
                    5. Box drawing characters with `┌`, `─`, and `│`
                    6. Minimalist dotted frame with `.`, `:`, and `.`
                Default is `1` (basic box).

        Returns:
            TemporaryFile: The temporary file handle (non-Windows systems only).
            None: On Windows, the file is closed and not returned.

        Raises:
            Exception: If there is an error creating or writing to the temporary file.
        &#34;&#34;&#34;
        try:
            # OS-specific temporary file behavior
            if os.name == &#39;nt&#39;:  # Windows
                ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;, delete=False)
            else:  # Other platforms
                ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;)

            # Generate header and content
            header = (
                f&#34;# TEMPORARY PIZZA.SCRIPT FILE\n&#34;
                f&#34;# {&#39;-&#39; * 40}\n&#34;
                f&#34;{self.header(verbosity=verbose, style=style)}&#34;
            )
            content = (
                header
                + &#34;\n# This is a temporary file (it will be deleted automatically)\n\n&#34;
                + self.do(printflag=False, verbose=verbose)
            )

            # Write content to the temporary file
            ftmp.write(BOM_UTF8 + content.encode(&#39;utf-8&#39;))
            ftmp.seek(0)  # Reset file pointer to the beginning

        except Exception as e:
            # Handle errors gracefully
            ftmp.close()
            os.remove(ftmp.name)  # Clean up the temporary file
            raise Exception(f&#34;Failed to write to or handle the temporary file: {e}&#34;) from None

        print(&#34;\nTemporary File Header:\n&#34;, header, &#34;\n&#34;)
        print(&#34;A temporary file has been generated here:\n&#34;, ftmp.name)

        # Persistent copy creation
        if self.persistentfile:
            ftmpname = os.path.basename(ftmp.name)
            fcopyname = os.path.join(self.persistentfolder, f&#34;script.preview.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
            copyfile(ftmp.name, fcopyname)
            print(&#34;A persistent copy has been created here:\n&#34;, fcopyname)

            # Create a clean copy without empty lines or comments
            with open(ftmp.name, &#34;r&#34;) as f:
                lines = f.readlines()
            bom_utf8_str = BOM_UTF8.decode(&#34;utf-8&#34;)
            clean_lines = [
                line for line in lines
                if line.strip() and not line.lstrip().startswith(&#34;#&#34;) and not line.startswith(bom_utf8_str)
            ]
            fcleanname = os.path.join(self.persistentfolder, f&#34;script.preview.clean.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
            with open(fcleanname, &#34;w&#34;) as f:
                f.writelines(clean_lines)
            print(&#34;A clean copy has been created here:\n&#34;, fcleanname)

            # Handle file closure for Windows
            if os.name == &#39;nt&#39;:
                ftmp.close()
                return None
            else:
                return ftmp


    # Note that it was not the original intent to copy scripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo))
        return copie


    def detect_variables(self, with_index=False, only_indexed=False):
        &#34;&#34;&#34;
        Detects variables in the content of the template using an extended pattern
        to include indexed variables (e.g., ${var[i]}) if `with_index` is True.

        Parameters:
        -----------
        with_index : bool, optional
            If True, include indexed variables with their indices (e.g., ${var[i]}). Default is False.
        only_indexed : bool, optional
            If True, target only variables that are used with an index (e.g., ${var[i]}). Default is False.

        Returns:
        --------
        list
            A list of unique variable names detected in the content based on the flags.
        &#34;&#34;&#34;
        # Regular expression to match variables with optional indexing
        variable_pattern = re.compile(r&#39;\$\{(\w+)(\[\w+\])?\}&#39;)
        # Ensure TEMPLATE is iterable (split string into lines if needed)
        if isinstance(self.TEMPLATE, str):
            lines = self.TEMPLATE.splitlines()  # Split string into lines
        elif isinstance(self.TEMPLATE, list):
            lines = self.TEMPLATE
        else:
            raise TypeError(&#34;TEMPLATE must be a string or a list of strings.&#34;)
        # Detect variables from all lines
        detected_vars = set()
        for line in lines:
            matches = variable_pattern.findall(line)
            for match in matches:
                variable_name = match[0]  # Base variable name
                index = match[1]          # Optional index (e.g., &#39;[i]&#39;)
                if only_indexed and not index:
                    continue  # Skip non-indexed variables if targeting only indexed ones
                if with_index and index:
                    detected_vars.add(f&#34;{variable_name}{index}&#34;)  # Include the full indexed variable
                elif not with_index:
                    detected_vars.add(variable_name)  # Include only the base variable

        # Return the list of unique variables
        return list(detected_vars)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.dscript.lamdaScript</li>
<li>pizza.region.LammpsGeneric</li>
<li>pizza.script.boundarysection</li>
<li>pizza.script.discretizationsection</li>
<li>pizza.script.dumpsection</li>
<li>pizza.script.geometrysection</li>
<li>pizza.script.globalsection</li>
<li>pizza.script.initializesection</li>
<li>pizza.script.integrationsection</li>
<li>pizza.script.interactionsection</li>
<li>pizza.script.runsection</li>
<li>pizza.script.statussection</li>
<li><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.script.DEFINITIONS"><code class="name">var <span class="ident">DEFINITIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.SECTIONS"><code class="name">var <span class="ident">SECTIONS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.email"><code class="name">var <span class="ident">email</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.license"><code class="name">var <span class="ident">license</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.metadata"><code class="name">var <span class="ident">metadata</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.section"><code class="name">var <span class="ident">section</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.script.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="region.script.printheader"><code class="name flex">
<span>def <span class="ident">printheader</span></span>(<span>txt, align='^', width=80, filler='~')</span>
</code></dt>
<dd>
<div class="desc"><p>print header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def printheader(txt,align=&#34;^&#34;,width=80,filler=&#34;~&#34;):
    &#34;&#34;&#34; print header &#34;&#34;&#34;
    if txt==&#34;&#34;:
        print(&#34;\n&#34;+filler*(width+6)+&#34;\n&#34;)
    else:
        print((&#34;\n{:&#34;+filler+&#34;{align}{width}}\n&#34;).format(&#39; [ &#39;+txt+&#39; ] &#39;, align=align, width=str(width)))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="region.script.role"><code class="name">var <span class="ident">role</span></code></dt>
<dd>
<div class="desc"><p>convert section index into a role (section name)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def role(self):
    &#34;&#34;&#34; convert section index into a role (section name) &#34;&#34;&#34;
    if self.section in range(len(self.SECTIONS)):
        return self.SECTIONS[self.section]
    else:
        return &#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.script.detect_variables"><code class="name flex">
<span>def <span class="ident">detect_variables</span></span>(<span>self, with_index=False, only_indexed=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects variables in the content of the template using an extended pattern
to include indexed variables (e.g., ${var[i]}) if <code>with_index</code> is True.</p>
<h2 id="parameters">Parameters:</h2>
<p>with_index : bool, optional
If True, include indexed variables with their indices (e.g., ${var[i]}). Default is False.
only_indexed : bool, optional
If True, target only variables that are used with an index (e.g., ${var[i]}). Default is False.</p>
<h2 id="returns">Returns:</h2>
<p>list
A list of unique variable names detected in the content based on the flags.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_variables(self, with_index=False, only_indexed=False):
    &#34;&#34;&#34;
    Detects variables in the content of the template using an extended pattern
    to include indexed variables (e.g., ${var[i]}) if `with_index` is True.

    Parameters:
    -----------
    with_index : bool, optional
        If True, include indexed variables with their indices (e.g., ${var[i]}). Default is False.
    only_indexed : bool, optional
        If True, target only variables that are used with an index (e.g., ${var[i]}). Default is False.

    Returns:
    --------
    list
        A list of unique variable names detected in the content based on the flags.
    &#34;&#34;&#34;
    # Regular expression to match variables with optional indexing
    variable_pattern = re.compile(r&#39;\$\{(\w+)(\[\w+\])?\}&#39;)
    # Ensure TEMPLATE is iterable (split string into lines if needed)
    if isinstance(self.TEMPLATE, str):
        lines = self.TEMPLATE.splitlines()  # Split string into lines
    elif isinstance(self.TEMPLATE, list):
        lines = self.TEMPLATE
    else:
        raise TypeError(&#34;TEMPLATE must be a string or a list of strings.&#34;)
    # Detect variables from all lines
    detected_vars = set()
    for line in lines:
        matches = variable_pattern.findall(line)
        for match in matches:
            variable_name = match[0]  # Base variable name
            index = match[1]          # Optional index (e.g., &#39;[i]&#39;)
            if only_indexed and not index:
                continue  # Skip non-indexed variables if targeting only indexed ones
            if with_index and index:
                detected_vars.add(f&#34;{variable_name}{index}&#34;)  # Include the full indexed variable
            elif not with_index:
                detected_vars.add(variable_name)  # Include only the base variable

    # Return the list of unique variables
    return list(detected_vars)</code></pre>
</details>
</dd>
<dt id="region.script.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, printflag=None, verbose=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the LAMMPS script based on the current configuration.</p>
<pre><code>    This method generates a LAMMPS-compatible script from the templates and definitions
    stored in the &lt;code&gt;&lt;a title="region.script" href="#region.script"&gt;script&lt;/a&gt;&lt;/code&gt; object. The generated script can be displayed, returned,
    and optionally include comments for debugging or clarity.

    Parameters:
    -----------
    - printflag (bool, optional): If True, the generated script is printed to the console.
                                  Default is True.
    - verbose (bool, optional): If True, comments and additional information are included
                                in the generated script. If False, comments are removed.
                                Default is True.

    Returns:
    ---------
    - str: The generated LAMMPS script.

    Method Behavior:
    - The method first collects all key-value pairs from &lt;code&gt;DEFINITIONS&lt;/code&gt; and &lt;code&gt;USER&lt;/code&gt; objects,
      which store the configuration data for the script.
    - Lists and tuples in the collected data are formatted into a readable string with proper
      separators (space for lists, comma for tuples) and prefixed with a '%' to indicate comments.
    - The generated command template is formatted and evaluated using the collected data.
    - If &lt;code&gt;verbose&lt;/code&gt; is set to False, comments in the generated script are removed.
    - The script is then printed if &lt;code&gt;printflag&lt;/code&gt; is True.
    - Finally, the formatted script is returned as a string.


    Example Usage:
    --------------
    &gt;&gt;&gt; s = script()
    &gt;&gt;&gt; s.do(printflag=True, verbose=True)
    units           si
    dimension       3
    boundary        f f f
    # Additional script commands...

    &gt;&gt;&gt; s.do(printflag=False, verbose=False)
    'units si
</code></pre>
<p>dimension 3
boundary f f f</p>
<h1 id="additional-script-commands">Additional script commands&hellip;'</h1>
<pre><code>    Notes:
    - Comments are indicated in the script with '%' or '#'.
    - The [position {self.position}:{self.userid}] marker is inserted for tracking
      script sections or modifications.


    Known Issues for indexed variables
    ----------------------------------
    List and tupples used indexed in templates, such as varlist[1], are not converted into strings so that
    each element can be considered as a variable and accessed as ${varlist[1]}. If varlist is also used in
    full, such as ${varlist}. Then it is preferable to define varlist as a string:
        "![v1,v2,...]" where v1,v2,v3 can be int, float, static str or evaluable str (i.e., subjected to nested
         evaluation).
    The control character ! in lists, such as in var=![v1,v2,v3] preserves the Pythonic definition by do()
    at later stages during the evaluation so that its content can be indexed.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self,printflag=None,verbose=None):
    &#34;&#34;&#34;
    Generate the LAMMPS script based on the current configuration.

    This method generates a LAMMPS-compatible script from the templates and definitions
    stored in the `script` object. The generated script can be displayed, returned,
    and optionally include comments for debugging or clarity.

    Parameters:
    -----------
    - printflag (bool, optional): If True, the generated script is printed to the console.
                                  Default is True.
    - verbose (bool, optional): If True, comments and additional information are included
                                in the generated script. If False, comments are removed.
                                Default is True.

    Returns:
    ---------
    - str: The generated LAMMPS script.

    Method Behavior:
    - The method first collects all key-value pairs from `DEFINITIONS` and `USER` objects,
      which store the configuration data for the script.
    - Lists and tuples in the collected data are formatted into a readable string with proper
      separators (space for lists, comma for tuples) and prefixed with a &#39;%&#39; to indicate comments.
    - The generated command template is formatted and evaluated using the collected data.
    - If `verbose` is set to False, comments in the generated script are removed.
    - The script is then printed if `printflag` is True.
    - Finally, the formatted script is returned as a string.


    Example Usage:
    --------------
    &gt;&gt;&gt; s = script()
    &gt;&gt;&gt; s.do(printflag=True, verbose=True)
    units           si
    dimension       3
    boundary        f f f
    # Additional script commands...

    &gt;&gt;&gt; s.do(printflag=False, verbose=False)
    &#39;units si\ndimension 3\nboundary f f f\n# Additional script commands...&#39;

    Notes:
    - Comments are indicated in the script with &#39;%&#39; or &#39;#&#39;.
    - The [position {self.position}:{self.userid}] marker is inserted for tracking
      script sections or modifications.


    Known Issues for indexed variables
    ----------------------------------
    List and tupples used indexed in templates, such as varlist[1], are not converted into strings so that
    each element can be considered as a variable and accessed as ${varlist[1]}. If varlist is also used in
    full, such as ${varlist}. Then it is preferable to define varlist as a string:
        &#34;![v1,v2,...]&#34; where v1,v2,v3 can be int, float, static str or evaluable str (i.e., subjected to nested
         evaluation).
    The control character ! in lists, such as in var=![v1,v2,v3] preserves the Pythonic definition by do()
    at later stages during the evaluation so that its content can be indexed.

    &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = self.verbose if verbose is None else verbose
    inputs = self.DEFINITIONS + self.USER
    usedvariables = self.detect_variables(with_index=False,only_indexed=False)
    variables_used_with_index = self.detect_variables(with_index=False,only_indexed=True)
    usedvariables_withoutindex = [ var for var in usedvariables if var not in variables_used_with_index ]
    for k in inputs.keys():
        if k in usedvariables_withoutindex:
            if isinstance(inputs.getattr(k),list):
                inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k)))
            elif isinstance(inputs.getattr(k),tuple):
                inputs.setattr(k,&#34;% &#34;+span(inputs.getattr(k),sep=&#34;,&#34;))
    cmd = inputs.formateval(self.TEMPLATE)
    cmd = cmd.replace(&#34;[comment]&#34;,f&#34;[position {self.position}:{self.userid}]&#34;)
    if not verbose: cmd=remove_comments(cmd)
    if printflag: print(cmd)
    return cmd</code></pre>
</details>
</dd>
<dt id="region.script.getallattributes"><code class="name flex">
<span>def <span class="ident">getallattributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>advanced method to get all attributes including class ones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getallattributes(self):
    &#34;&#34;&#34; advanced method to get all attributes including class ones&#34;&#34;&#34;
    return {k: getattr(self, k) for k in dir(self) \
            if (not k.startswith(&#39;_&#39;)) and (not isinstance(getattr(self, k),types.MethodType))}</code></pre>
</details>
</dd>
<dt id="region.script.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self, verbose=True, verbosity=None, style=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a formatted header for the script file.</p>
<h2 id="parameters">Parameters</h2>
<p>verbosity (bool, optional): If specified, overrides the instance's <code>verbose</code> setting.
Defaults to the instance's <code>verbose</code>.
style (int from 1 to 6, optional): ASCII style to frame the header (default=2)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representing the script's metadata and initialization details.
Returns an empty string if verbosity is False.</dd>
</dl>
<p>The header includes:
- Script version, license, and contact email.
- User ID and the number of initialized definitions.
- Current system user, hostname, and working directory.
- Persistent filename and folder path.
- Timestamp of the header generation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self, verbose=True, verbosity=None, style=2):
    &#34;&#34;&#34;
    Generate a formatted header for the script file.

    Parameters:
        verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                    Defaults to the instance&#39;s `verbose`.
        style (int from 1 to 6, optional): ASCII style to frame the header (default=2)

    Returns:
        str: A formatted string representing the script&#39;s metadata and initialization details.
             Returns an empty string if verbosity is False.

    The header includes:
        - Script version, license, and contact email.
        - User ID and the number of initialized definitions.
        - Current system user, hostname, and working directory.
        - Persistent filename and folder path.
        - Timestamp of the header generation.
    &#34;&#34;&#34;
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    if not verbose:
        return &#34;&#34;
    # Prepare the header content
    lines = [
        f&#34;PIZZA.SCRIPT FILE v{script.version} | License: {script.license} | Email: {script.email}&#34;,
        &#34;&#34;,
        f&#34;&lt;{str(self)}&gt;&#34;,
        f&#34;Initialized with {len(self.USER)} definitions | Verbosity: {verbosity}&#34;,
        f&#34;Persistent file: \&#34;{self.persistentfile}\&#34; | Folder: \&#34;{self.persistentfolder}\&#34;&#34;,
        &#34;&#34;,
        f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
        f&#34;{datetime.datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
    ]
    # Use the shared method to format the header
    return frame_header(lines,style=style)</code></pre>
</details>
</dd>
<dt id="region.script.tmpwrite"><code class="name flex">
<span>def <span class="ident">tmpwrite</span></span>(<span>self, verbose=False, style=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the script to a temporary file and create optional persistent copies.</p>
<h2 id="parameters">Parameters</h2>
<p>verbose (bool, optional): Controls verbosity during script generation. Defaults to False.</p>
<p>The method:
- Creates a temporary file for the script, with platform-specific behavior:
- On Windows (<code>os.name == 'nt'</code>), the file is not automatically deleted.
- On other systems, the file is temporary and deleted upon closure.
- Writes a header and the script content into the temporary file.
- Optionally creates a persistent copy in the <code>self.persistentfolder</code> directory:
- <code>script.preview.&lt;suffix&gt;</code>: A persistent copy of the temporary file.
- <code>script.preview.clean.&lt;suffix&gt;</code>: A clean copy with comments and empty lines removed.
- Handles cleanup and exceptions gracefully to avoid leaving orphaned files.
- style (int, optional):
Defines the ASCII frame style for the header.
Valid values are integers from 1 to 6, corresponding to predefined styles:
1. Basic box with <code>+</code>, <code>-</code>, and <code>|</code>
2. Double-line frame with <code>╔</code>, <code>═</code>, and <code>║</code>
3. Rounded corners with <code>.</code>, <code>'</code>, <code>-</code>, and <code>|</code>
4. Thick outer frame with <code>#</code>, <code>=</code>, and <code>#</code>
5. Box drawing characters with <code>┌</code>, <code>─</code>, and <code>│</code>
6. Minimalist dotted frame with <code>.</code>, <code>:</code>, and <code>.</code>
Default is <code>1</code> (basic box).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>TemporaryFile</code></dt>
<dd>The temporary file handle (non-Windows systems only).</dd>
<dt><code>None</code></dt>
<dd>On Windows, the file is closed and not returned.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>If there is an error creating or writing to the temporary file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tmpwrite(self, verbose=False, style=1):
    &#34;&#34;&#34;
    Write the script to a temporary file and create optional persistent copies.

    Parameters:
        verbose (bool, optional): Controls verbosity during script generation. Defaults to False.

    The method:
        - Creates a temporary file for the script, with platform-specific behavior:
            - On Windows (`os.name == &#39;nt&#39;`), the file is not automatically deleted.
            - On other systems, the file is temporary and deleted upon closure.
        - Writes a header and the script content into the temporary file.
        - Optionally creates a persistent copy in the `self.persistentfolder` directory:
            - `script.preview.&lt;suffix&gt;`: A persistent copy of the temporary file.
            - `script.preview.clean.&lt;suffix&gt;`: A clean copy with comments and empty lines removed.
        - Handles cleanup and exceptions gracefully to avoid leaving orphaned files.
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with `╔`, `═`, and `║`
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with `┌`, `─`, and `│`
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `1` (basic box).

    Returns:
        TemporaryFile: The temporary file handle (non-Windows systems only).
        None: On Windows, the file is closed and not returned.

    Raises:
        Exception: If there is an error creating or writing to the temporary file.
    &#34;&#34;&#34;
    try:
        # OS-specific temporary file behavior
        if os.name == &#39;nt&#39;:  # Windows
            ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;, delete=False)
        else:  # Other platforms
            ftmp = tempfile.NamedTemporaryFile(mode=&#34;w+b&#34;, prefix=&#34;script_&#34;, suffix=&#34;.txt&#34;)

        # Generate header and content
        header = (
            f&#34;# TEMPORARY PIZZA.SCRIPT FILE\n&#34;
            f&#34;# {&#39;-&#39; * 40}\n&#34;
            f&#34;{self.header(verbosity=verbose, style=style)}&#34;
        )
        content = (
            header
            + &#34;\n# This is a temporary file (it will be deleted automatically)\n\n&#34;
            + self.do(printflag=False, verbose=verbose)
        )

        # Write content to the temporary file
        ftmp.write(BOM_UTF8 + content.encode(&#39;utf-8&#39;))
        ftmp.seek(0)  # Reset file pointer to the beginning

    except Exception as e:
        # Handle errors gracefully
        ftmp.close()
        os.remove(ftmp.name)  # Clean up the temporary file
        raise Exception(f&#34;Failed to write to or handle the temporary file: {e}&#34;) from None

    print(&#34;\nTemporary File Header:\n&#34;, header, &#34;\n&#34;)
    print(&#34;A temporary file has been generated here:\n&#34;, ftmp.name)

    # Persistent copy creation
    if self.persistentfile:
        ftmpname = os.path.basename(ftmp.name)
        fcopyname = os.path.join(self.persistentfolder, f&#34;script.preview.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
        copyfile(ftmp.name, fcopyname)
        print(&#34;A persistent copy has been created here:\n&#34;, fcopyname)

        # Create a clean copy without empty lines or comments
        with open(ftmp.name, &#34;r&#34;) as f:
            lines = f.readlines()
        bom_utf8_str = BOM_UTF8.decode(&#34;utf-8&#34;)
        clean_lines = [
            line for line in lines
            if line.strip() and not line.lstrip().startswith(&#34;#&#34;) and not line.startswith(bom_utf8_str)
        ]
        fcleanname = os.path.join(self.persistentfolder, f&#34;script.preview.clean.{ftmpname.rsplit(&#39;_&#39;, 1)[1]}&#34;)
        with open(fcleanname, &#34;w&#34;) as f:
            f.writelines(clean_lines)
        print(&#34;A clean copy has been created here:\n&#34;, fcleanname)

        # Handle file closure for Windows
        if os.name == &#39;nt&#39;:
            ftmp.close()
            return None
        else:
            return ftmp</code></pre>
</details>
</dd>
<dt id="region.script.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, printflag=True, verbose=False, overwrite=False, style=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the script to a file.</p>
<h2 id="parameters">Parameters</h2>
<ul>
<li>file (str): The file path where the script will be saved.</li>
<li>printflag (bool): Flag to enable/disable printing of details.</li>
<li>verbose (bool): Flag to enable/disable verbose mode.</li>
<li>overwrite (bool): Whether to overwrite the file if it already exists.</li>
<li>style (int, optional):
Defines the ASCII frame style for the header.
Valid values are integers from 1 to 6, corresponding to predefined styles:
1. Basic box with <code>+</code>, <code>-</code>, and <code>|</code>
2. Double-line frame with <code>╔</code>, <code>═</code>, and <code>║</code>
3. Rounded corners with <code>.</code>, <code>'</code>, <code>-</code>, and <code>|</code>
4. Thick outer frame with <code>#</code>, <code>=</code>, and <code>#</code>
5. Box drawing characters with <code>┌</code>, <code>─</code>, and <code>│</code>
6. Minimalist dotted frame with <code>.</code>, <code>:</code>, and <code>.</code>
Default is <code>2</code> (frame with rounded corners).</li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The full absolute path of the file written.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and overwrite is False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, printflag=True, verbose=False, overwrite=False, style=2):
    &#34;&#34;&#34;
    Write the script to a file.

    Parameters:
        - file (str): The file path where the script will be saved.
        - printflag (bool): Flag to enable/disable printing of details.
        - verbose (bool): Flag to enable/disable verbose mode.
        - overwrite (bool): Whether to overwrite the file if it already exists.
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with `╔`, `═`, and `║`
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with `┌`, `─`, and `│`
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `2` (frame with rounded corners).

    Returns:
        str: The full absolute path of the file written.

    Raises:
        FileExistsError: If the file already exists and overwrite is False.
    &#34;&#34;&#34;
    # Resolve full path
    full_path = os.path.abspath(file)
    if os.path.exists(full_path) and not overwrite:
        raise FileExistsError(f&#34;The file &#39;{full_path}&#39; already exists. Use overwrite=True to overwrite it.&#34;)
    if os.path.exists(full_path) and overwrite and verbose:
        print(f&#34;Warning: Overwriting the existing file &#39;{full_path}&#39;.&#34;)
    # Generate the script and write to the file
    cmd = self.do(printflag=printflag, verbose=verbose)
    with open(full_path, &#34;w&#34;) as f:
        print(self.header(verbosity=verbose, style=style), &#34;\n&#34;, file=f)
        print(cmd, file=f)
    # Return the full path of the written file
    return full_path</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.scriptdata"><code class="flex name class">
<span>class <span class="ident">scriptdata</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>class of script parameters
Typical constructor:
DEFINITIONS = scriptdata(
var1 = value1,
var2 = value2
)
See script, struct, param to get review all methods attached to it</p>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scriptdata(param):
    &#34;&#34;&#34;
        class of script parameters
            Typical constructor:
                DEFINITIONS = scriptdata(
                    var1 = value1,
                    var2 = value2
                    )
        See script, struct, param to get review all methods attached to it
    &#34;&#34;&#34;
    _type = &#34;SD&#34;
    _fulltype = &#34;script data&#34;
    _ftype = &#34;definition&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="region.scriptobject"><code class="flex name class">
<span>class <span class="ident">scriptobject</span></span>
<span>(</span><span>beadtype=1, name=None, fullname='', filename='', style='smd', mass=1.0, forcefield=LAMMPS:SMD:none:walls, group=[], USER=script data (SD object) with 0 definitions)</span>
</code></dt>
<dd>
<div class="desc"><p>scriptobject: A Class for Managing Script Objects in LAMMPS</p>
<p>The <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> class is designed to represent individual objects in LAMMPS scripts,
such as beads, atoms, or other components. Each object is associated with a <code><a title="region.forcefield" href="#region.forcefield">forcefield</a></code>
instance that defines the physical interactions of the object, and the class supports
a variety of properties for detailed object definition. Additionally, <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code>
instances can be grouped together and compared based on their properties, such as
<code>beadtype</code> and <code>name</code>.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Forcefield Integration</strong>: Each <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> is associated with a <code><a title="region.forcefield" href="#region.forcefield">forcefield</a></code>
instance, allowing for customized physical interactions. Forcefields can be passed
via the <code>USER</code> keyword for dynamic parameterization.</li>
<li><strong>Grouping</strong>: Multiple <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> instances can be combined into a
<code>scriptobjectgroup</code> using the <code>+</code> operator, allowing for complex collections of objects.</li>
<li><strong>Object Comparison</strong>: <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> instances can be compared and sorted based on
their <code>beadtype</code> and <code>name</code>, enabling efficient organization and manipulation of objects.</li>
<li><strong>Piping and Execution</strong>: Supports the pipe (<code>|</code>) operator, allowing <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code>
instances to be used in script pipelines alongside other script elements.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>Object Definition in LAMMPS</strong>: Use <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> to represent individual objects in
a simulation, including their properties and associated forcefields.</li>
<li><strong>Forcefield Parameterization</strong>: Pass customized parameters to the forcefield via the
<code>USER</code> keyword to dynamically adjust the physical interactions.</li>
<li><strong>Grouping and Sorting</strong>: Combine multiple objects into groups, or sort them based
on their properties (e.g., <code>beadtype</code>) for easier management in complex simulations.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, beadtype=1, name="undefined", fullname="", filename="", style="smd",
forcefield=rigidwall(), group=[], USER=scriptdata()):
Initializes a new <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> with the specified properties, including <code>beadtype</code>,
<code>name</code>, <code><a title="region.forcefield" href="#region.forcefield">forcefield</a></code>, and optional <code>group</code>.</p>
<p><strong>str</strong>(self):
Returns a string representation of the <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code>, showing its <code>beadtype</code> and <code>name</code>.</p>
<p><strong>add</strong>(self, SO):
Combines two <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> instances or a <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> with a <code>scriptobjectgroup</code>.
Raises an error if the two objects have the same <code>name</code> or if the second operand is not
a valid <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> or <code>scriptobjectgroup</code>.</p>
<p><strong>or</strong>(self, pipe):
Overloads the pipe (<code>|</code>) operator to integrate the <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> into a pipeline.</p>
<p><strong>eq</strong>(self, SO):
Compares two <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> instances, returning <code>True</code> if they have the same
<code>beadtype</code> and <code>name</code>.</p>
<p><strong>ne</strong>(self, SO):
Returns <code>True</code> if the two <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> instances differ in either <code>beadtype</code> or <code>name</code>.</p>
<p><strong>lt</strong>(self, SO):
Compares the <code>beadtype</code> of two <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> instances, returning <code>True</code> if the
left object's <code>beadtype</code> is less than the right object's.</p>
<p><strong>gt</strong>(self, SO):
Compares the <code>beadtype</code> of two <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> instances, returning <code>True</code> if the
left object's <code>beadtype</code> is greater than the right object's.</p>
<p><strong>le</strong>(self, SO):
Returns <code>True</code> if the <code>beadtype</code> of the left <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> is less than or equal to
the right <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code>.</p>
<p><strong>ge</strong>(self, SO):
Returns <code>True</code> if the <code>beadtype</code> of the left <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> is greater than or equal
to the right <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code>.</p>
<h2 id="attributes">Attributes:</h2>
<p>beadtype : int
The type of bead or object, used for distinguishing between different types in the simulation.
name : str
A short name for the object, useful for quick identification.
fullname : str
A comprehensive name for the object. If not provided, defaults to the <code>name</code> with "object definition".
filename : str
The path to the file containing the input data for the object.
style : str
The style of the object (e.g., "smd" for smoothed dynamics).
forcefield : forcefield
The forcefield instance associated with the object, defining its physical interactions.
group : list
A list of other <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> instances that are grouped with this object.
USER : scriptdata
A collection of user-defined variables for customizing the forcefield or other properties.</p>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> class enables the definition of objects within LAMMPS scripts, providing:
- <strong>Beadtype and Naming</strong>: Objects are distinguished by their <code>beadtype</code> and <code>name</code>, allowing
for comparison and sorting based on these properties.
- <strong>Forcefield Support</strong>: Objects are linked to a forcefield instance, and user-defined forcefield
parameters can be passed through the <code>USER</code> keyword.
- <strong>Group Management</strong>: Multiple objects can be grouped together using the <code>+</code> operator, forming
a <code>scriptobjectgroup</code>.
- <strong>Comparison Operators</strong>: Objects can be compared based on their <code>beadtype</code> and <code>name</code>, using
standard comparison operators (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, etc.).
- <strong>Pipelines</strong>: <code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code> instances can be integrated into pipelines, supporting the <code>|</code>
operator for use in sequential script execution.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>from pizza.scriptobject import scriptobject, rigidwall, scriptdata

# Define a script object with custom properties
obj1 = scriptobject(beadtype=1, name=&quot;bead1&quot;, forcefield=rigidwall(USER=scriptdata(param1=10)))

# Combine two objects into a group
obj2 = scriptobject(beadtype=2, name=&quot;bead2&quot;)
group = obj1 + obj2

# Print object information
print(obj1)
print(group)
</code></pre>
<p>The output will be:</p>
<pre><code>script object | type=1 | name=bead1
scriptobjectgroup containing 2 objects
</code></pre>
<h2 id="overview">Overview</h2>
<pre><code>class of script object
    OBJ = scriptobject(...)
    Implemented properties:
        beadtype=1,2,...
        name="short name"
        fullname = "comprehensive name"
        filename = "/path/to/your/inputfile"
        style = "smd"
        forcefield = any valid forcefield instance (default = rigidwall())
        mass = 1.0

note: use a forcefield instance with the keywork USER to pass user FF parameters
examples:   rigidwall(USER=scriptdata(...))
            solidfood(USER==scriptdata(...))
            water(USER==scriptdata(...))

group objects with OBJ1+OBJ2... into scriptobjectgroups

objects can be compared and sorted based on beadtype and name
</code></pre>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scriptobject(struct):
    &#34;&#34;&#34;
    scriptobject: A Class for Managing Script Objects in LAMMPS

    The `scriptobject` class is designed to represent individual objects in LAMMPS scripts,
    such as beads, atoms, or other components. Each object is associated with a `forcefield`
    instance that defines the physical interactions of the object, and the class supports
    a variety of properties for detailed object definition. Additionally, `scriptobject`
    instances can be grouped together and compared based on their properties, such as
    `beadtype` and `name`.

    Key Features:
    -------------
    - **Forcefield Integration**: Each `scriptobject` is associated with a `forcefield`
      instance, allowing for customized physical interactions. Forcefields can be passed
      via the `USER` keyword for dynamic parameterization.
    - **Grouping**: Multiple `scriptobject` instances can be combined into a
      `scriptobjectgroup` using the `+` operator, allowing for complex collections of objects.
    - **Object Comparison**: `scriptobject` instances can be compared and sorted based on
      their `beadtype` and `name`, enabling efficient organization and manipulation of objects.
    - **Piping and Execution**: Supports the pipe (`|`) operator, allowing `scriptobject`
      instances to be used in script pipelines alongside other script elements.

    Practical Use Cases:
    --------------------
    - **Object Definition in LAMMPS**: Use `scriptobject` to represent individual objects in
      a simulation, including their properties and associated forcefields.
    - **Forcefield Parameterization**: Pass customized parameters to the forcefield via the
      `USER` keyword to dynamically adjust the physical interactions.
    - **Grouping and Sorting**: Combine multiple objects into groups, or sort them based
      on their properties (e.g., `beadtype`) for easier management in complex simulations.

    Methods:
    --------
    __init__(self, beadtype=1, name=&#34;undefined&#34;, fullname=&#34;&#34;, filename=&#34;&#34;, style=&#34;smd&#34;,
             forcefield=rigidwall(), group=[], USER=scriptdata()):
        Initializes a new `scriptobject` with the specified properties, including `beadtype`,
        `name`, `forcefield`, and optional `group`.

    __str__(self):
        Returns a string representation of the `scriptobject`, showing its `beadtype` and `name`.

    __add__(self, SO):
        Combines two `scriptobject` instances or a `scriptobject` with a `scriptobjectgroup`.
        Raises an error if the two objects have the same `name` or if the second operand is not
        a valid `scriptobject` or `scriptobjectgroup`.

    __or__(self, pipe):
        Overloads the pipe (`|`) operator to integrate the `scriptobject` into a pipeline.

    __eq__(self, SO):
        Compares two `scriptobject` instances, returning `True` if they have the same
        `beadtype` and `name`.

    __ne__(self, SO):
        Returns `True` if the two `scriptobject` instances differ in either `beadtype` or `name`.

    __lt__(self, SO):
        Compares the `beadtype` of two `scriptobject` instances, returning `True` if the
        left object&#39;s `beadtype` is less than the right object&#39;s.

    __gt__(self, SO):
        Compares the `beadtype` of two `scriptobject` instances, returning `True` if the
        left object&#39;s `beadtype` is greater than the right object&#39;s.

    __le__(self, SO):
        Returns `True` if the `beadtype` of the left `scriptobject` is less than or equal to
        the right `scriptobject`.

    __ge__(self, SO):
        Returns `True` if the `beadtype` of the left `scriptobject` is greater than or equal
        to the right `scriptobject`.

    Attributes:
    -----------
    beadtype : int
        The type of bead or object, used for distinguishing between different types in the simulation.
    name : str
        A short name for the object, useful for quick identification.
    fullname : str
        A comprehensive name for the object. If not provided, defaults to the `name` with &#34;object definition&#34;.
    filename : str
        The path to the file containing the input data for the object.
    style : str
        The style of the object (e.g., &#34;smd&#34; for smoothed dynamics).
    forcefield : forcefield
        The forcefield instance associated with the object, defining its physical interactions.
    group : list
        A list of other `scriptobject` instances that are grouped with this object.
    USER : scriptdata
        A collection of user-defined variables for customizing the forcefield or other properties.

    Original Content:
    -----------------
    The `scriptobject` class enables the definition of objects within LAMMPS scripts, providing:
    - **Beadtype and Naming**: Objects are distinguished by their `beadtype` and `name`, allowing
      for comparison and sorting based on these properties.
    - **Forcefield Support**: Objects are linked to a forcefield instance, and user-defined forcefield
      parameters can be passed through the `USER` keyword.
    - **Group Management**: Multiple objects can be grouped together using the `+` operator, forming
      a `scriptobjectgroup`.
    - **Comparison Operators**: Objects can be compared based on their `beadtype` and `name`, using
      standard comparison operators (`==`, `&lt;`, `&gt;`, etc.).
    - **Pipelines**: `scriptobject` instances can be integrated into pipelines, supporting the `|`
      operator for use in sequential script execution.

    Example Usage:
    --------------
    ```
    from pizza.scriptobject import scriptobject, rigidwall, scriptdata

    # Define a script object with custom properties
    obj1 = scriptobject(beadtype=1, name=&#34;bead1&#34;, forcefield=rigidwall(USER=scriptdata(param1=10)))

    # Combine two objects into a group
    obj2 = scriptobject(beadtype=2, name=&#34;bead2&#34;)
    group = obj1 + obj2

    # Print object information
    print(obj1)
    print(group)
    ```

    The output will be:
    ```
    script object | type=1 | name=bead1
    scriptobjectgroup containing 2 objects
    ```

    OVERVIEW
    --------------

        class of script object
            OBJ = scriptobject(...)
            Implemented properties:
                beadtype=1,2,...
                name=&#34;short name&#34;
                fullname = &#34;comprehensive name&#34;
                filename = &#34;/path/to/your/inputfile&#34;
                style = &#34;smd&#34;
                forcefield = any valid forcefield instance (default = rigidwall())
                mass = 1.0

        note: use a forcefield instance with the keywork USER to pass user FF parameters
        examples:   rigidwall(USER=scriptdata(...))
                    solidfood(USER==scriptdata(...))
                    water(USER==scriptdata(...))

        group objects with OBJ1+OBJ2... into scriptobjectgroups

        objects can be compared and sorted based on beadtype and name

    &#34;&#34;&#34;
    _type = &#34;SO&#34;
    _fulltype = &#34;script object&#34;
    _ftype = &#34;propertie&#34;

    def __init__(self,
                 beadtype = 1,
                 name = None,
                 fullname=&#34;&#34;,
                 filename=&#34;&#34;,
                 style=&#34;smd&#34;,
                 mass=1.0, # added on 2024-11-29
                 forcefield=rigidwall(),
                 group=[],
                 USER = scriptdata()
                 ):
        name = f&#34;beadtype={beadtype}&#34; if name is None else name
        if not isinstance(name,str):
            TypeError(f&#34;name must a string or None got {type(name)}&#34;)
        if fullname==&#34;&#34;: fullname = name + &#34; object definition&#34;
        if not isinstance(group,list): group = [group]
        forcefield.beadtype = beadtype
        forcefield.userid = name
        forcefield.USER = USER
        super(scriptobject,self).__init__(
              beadtype = beadtype,
                  name = name,
              fullname = fullname,
              filename = filename,
                 style = style,
            forcefield = forcefield,
                  mass = mass,
                 group = group,
                  USER = USER
                 )

    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;{self._fulltype} | type={self.beadtype} | name={self.name}&#34;

    def __add__(self, SO):
        if isinstance(SO,scriptobject):
            if SO.name != self.name:
                if SO.beadtype == self.beadtype:
                   SO.beadtype =  self.beadtype+1
                return scriptobjectgroup(self,SO)
            else:
                raise ValueError(&#39;the object &#34;%s&#34; already exists&#39; % SO.name)
        elif isinstance(SO,scriptobjectgroup):
            return scriptobjectgroup(self)+SO
        else:
            return ValueError(&#34;The object should a script object or its container&#34;)

    def __or__(self, pipe):
        &#34;&#34;&#34; overload | or for pipe &#34;&#34;&#34;
        if isinstance(pipe,(pipescript,script,scriptobject,scriptobjectgroup)):
            return pipescript(self) | pipe
        else:
            raise ValueError(&#34;the argument must a pipescript, a scriptobject or a scriptobjectgroup&#34;)

    def __eq__(self, SO):
        return isinstance(SO,scriptobject) and (self.beadtype == SO.beadtype) and (self.mass == SO.mass) \
            and (self.name == SO.name)

    def __ne__(self, SO):
        return not isinstance(SO,scriptobject) or (self.beadtype != SO.beadtype) or (self.mass != SO.mass) or (self.name != SO.name)

    def __lt__(self, SO):
        return self.beadtype &lt; SO.beadtype

    def __gt__(self, SO):
        return self.beadtype &gt; SO.beadtype

    def __le__(self, SO):
        return self.beadtype &lt;= SO.beadtype

    def __ge__(self, SO):
        return self.beadtype &gt;= SO.beadtype</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.mstruct.struct</li>
</ul>
</dd>
<dt id="region.smd"><code class="flex name class">
<span>class <span class="ident">smd</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD forcefield</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class smd(forcefield):
    &#34;&#34;&#34; SMD forcefield &#34;&#34;&#34;
    name = forcefield.name + struct(forcefield=&#34;LAMMPS:SMD&#34;)
    description = forcefield.description + struct(forcefield=&#34;LAMMPS:SMD - solid, liquid, rigid forcefields (continuum mechanics)&#34;)

    # forcefield definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_STYLE = &#34;&#34;&#34;
    # [comment] PAIR STYLE SMD
    pair_style      hybrid/overlay smd/ulsph *DENSITY_CONTINUITY *VELOCITY_GRADIENT *NO_GRADIENT_CORRECTION &amp;
                                   smd/tlsph smd/hertz ${contact_scale}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.none</li>
<li>pizza.forcefield.tlsph</li>
<li>pizza.forcefield.ulsph</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.smd.PAIR_STYLE"><code class="name">var <span class="ident">PAIR_STYLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.smd.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.smd.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="region.solidfood"><code class="flex name class">
<span>class <span class="ident">solidfood</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>solidfood material (smd:tlsph): model solid food object
solidfood()
solidfood(beadtype=index, userid="myfood", USER=&hellip;)</p>
<p>override any propery with USER.property=value (set only the parameters you want to override)
USER.rho: density in kg/m3 (default=1000)
USER.c0: speed of the sound in m/s (default=10.0)
USER.E: Young's modulus in Pa (default="5<em>${c0}^2</em>${rho}")
USER.nu: Poisson ratio (default=0.3)
USER.q1: standard artificial viscosity linear coefficient (default=1.0)
USER.q2: standard artificial viscosity quadratic coefficient (default=0)
USER.Hg: hourglass control coefficient (default=10.0)
USER.Cp: heat capacity of material &ndash; not used here (default=1.0)
USER.sigma_yield: plastic yield stress in Pa (default="0.1<em>${E}")
USER.hardening: hardening parameter (default=0)
USER.contact_scale: scaling coefficient for contact (default=1.5)
USER.contact_stiffness: contact stifness in Pa (default="2.5</em>${c0}^2*${rho}")</p>
<p>food forcefield:
solidfood(beadtype=index, userid="myfood")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class solidfood(tlsph):
    &#34;&#34;&#34; solidfood material (smd:tlsph): model solid food object
            solidfood()
            solidfood(beadtype=index, userid=&#34;myfood&#34;, USER=...)

            override any propery with USER.property=value (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=1000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.E: Young&#39;s modulus in Pa (default=&#34;5*${c0}^2*${rho}&#34;)
                USER.nu: Poisson ratio (default=0.3)
                USER.q1: standard artificial viscosity linear coefficient (default=1.0)
                USER.q2: standard artificial viscosity quadratic coefficient (default=0)
                USER.Hg: hourglass control coefficient (default=10.0)
                USER.Cp: heat capacity of material -- not used here (default=1.0)
                USER.sigma_yield: plastic yield stress in Pa (default=&#34;0.1*${E}&#34;)
                USER.hardening: hardening parameter (default=0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = tlsph.name + struct(material=&#34;solidfood&#34;)
    description = tlsph.description + struct(material=&#34;food beads - solid behavior&#34;)
    userid = &#39;solidfood&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; food forcefield:
            solidfood(beadtype=index, userid=&#34;myfood&#34;) &#34;&#34;&#34;
        # super().__init__()
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # food-food interactions
            rho = 1000,
            c0 = 10.0,
            E = &#34;5*${c0}^2*${rho}&#34;,
            nu = 0.3,
            q1 = 1.0,
            q2 = 0.0,
            Hg = 10.0,
            Cp = 1.0,
            sigma_yield = &#34;0.1*${E}&#34;,
            hardening = 0,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#34;2.5*${c0}^2*${rho}&#34;
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.tlsph</li>
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.solidfood.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.solidfood.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.solidfood.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.solidfood.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="region.struct"><code class="flex name class">
<span>class <span class="ident">struct</span></span>
<span>(</span><span>debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-struct">Class: <code><a title="region.struct" href="#region.struct">struct</a></code></h1>
<p>A lightweight class that mimics Matlab-like structures, with additional features
such as dynamic field creation, indexing, concatenation, and compatibility with
evaluated parameters (<code><a title="region.param" href="#region.param">param</a></code>).</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Dynamic creation of fields.</li>
<li>Indexing and iteration support for fields.</li>
<li>Concatenation and subtraction of structures.</li>
<li>Conversion to and from dictionaries.</li>
<li>Compatible with <code><a title="region.param" href="#region.param">param</a></code> and <code><a title="region.paramauto" href="#region.paramauto">paramauto</a></code> for evaluation and dependency handling.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic Usage</h4>
<pre><code class="language-python">s = struct(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
print(s.a)  # 1
s.d = 11    # Append a new field
delattr(s, 'd')  # Delete the field
</code></pre>
<h4 id="using-param-for-evaluation">Using <code><a title="region.param" href="#region.param">param</a></code> for Evaluation</h4>
<pre><code class="language-python">p = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
p.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-subtraction">Concatenation and Subtraction</h3>
<p>Fields from the right-most structure overwrite existing values.</p>
<pre><code class="language-python">a = struct(a=1, b=2)
b = struct(c=3, d=&quot;d&quot;, e=&quot;e&quot;)
c = a + b
e = c - a
</code></pre>
<hr>
<h3 id="practical-shorthands">Practical Shorthands</h3>
<h4 id="constructing-a-structure-from-keys">Constructing a Structure from Keys</h4>
<pre><code class="language-python">s = struct.fromkeys([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
# Output:
# --------
#      a: None
#      b: None
#      c: None
#      d: None
# --------
</code></pre>
<h4 id="building-a-structure-from-variables-in-a-string">Building a Structure from Variables in a String</h4>
<pre><code class="language-python">s = struct.scan(&quot;${a} + ${b} * ${c} / ${d} --- ${ee}&quot;)
s.a = 1
s.b = &quot;test&quot;
s.c = [1, &quot;a&quot;, 2]
s.generator()
# Output:
# X = struct(
#      a=1,
#      b=&quot;test&quot;,
#      c=[1, 'a', 2],
#      d=None,
#      ee=None
# )
</code></pre>
<h4 id="indexing-and-iteration">Indexing and Iteration</h4>
<p>Structures can be indexed or sliced like lists.</p>
<pre><code class="language-python">c = a + b
c[0]      # Access the first field
c[-1]     # Access the last field
c[:2]     # Slice the structure
for field in c:
    print(field)
</code></pre>
<hr>
<h3 id="dynamic-dependency-management">Dynamic Dependency Management</h3>
<p><code><a title="region.struct" href="#region.struct">struct</a></code> provides control over dependencies, sorting, and evaluation.</p>
<pre><code class="language-python">s = struct(d=3, e=&quot;${c} + {d}&quot;, c='${a} + ${b}', a=1, b=2)
s.sortdefinitions()
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}
#      e: ${c} + ${d}
# --------
</code></pre>
<p>For dynamic evaluation, use <code><a title="region.param" href="#region.param">param</a></code>:</p>
<pre><code class="language-python">p = param(sortdefinitions=True, d=3, e=&quot;${c} + ${d}&quot;, c='${a} + ${b}', a=1, b=2)
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}  (= 3)
#      e: ${c} + ${d}  (= 6)
# --------
</code></pre>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two structures (<code>__add__</code>).</li>
<li><code>-</code>: Subtraction of fields (<code>__sub__</code>).</li>
<li><code>len()</code>: Number of fields (<code>__len__</code>).</li>
<li><code>in</code>: Check for field existence (<code>__contains__</code>).</li>
</ul>
<h4 id="method-overview">Method Overview</h4>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>check(default)</code></td>
<td>Populate fields with defaults if missing.</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>Remove all fields.</td>
</tr>
<tr>
<td><code>dict2struct(dico)</code></td>
<td>Create a structure from a dictionary.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display the structure.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate expressions within fields.</td>
</tr>
<tr>
<td><code>fromkeys(keys)</code></td>
<td>Create a structure from a list of keys.</td>
</tr>
<tr>
<td><code>generator()</code></td>
<td>Generate Python code representing the structure.</td>
</tr>
<tr>
<td><code>items()</code></td>
<td>Return key-value pairs.</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>Return all keys in the structure.</td>
</tr>
<tr>
<td><code>read(file)</code></td>
<td>Load structure fields from a file.</td>
</tr>
<tr>
<td><code>scan(string)</code></td>
<td>Extract variables from a string and populate fields.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>struct2dict()</code></td>
<td>Convert the structure to a dictionary.</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>Return all field values.</td>
</tr>
<tr>
<td><code>write(file)</code></td>
<td>Save the structure to a file.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="dynamic-properties">Dynamic Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isempty</code></td>
<td><code>True</code> if the structure is empty.</td>
</tr>
<tr>
<td><code>isdefined</code></td>
<td><code>True</code> if all fields are defined.</td>
</tr>
</tbody>
</table>
<hr>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class struct():
    &#34;&#34;&#34;
    Class: `struct`
    ================

    A lightweight class that mimics Matlab-like structures, with additional features
    such as dynamic field creation, indexing, concatenation, and compatibility with
    evaluated parameters (`param`).

    ---

    ### Features
    - Dynamic creation of fields.
    - Indexing and iteration support for fields.
    - Concatenation and subtraction of structures.
    - Conversion to and from dictionaries.
    - Compatible with `param` and `paramauto` for evaluation and dependency handling.

    ---

    ### Examples

    #### Basic Usage
    ```python
    s = struct(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    print(s.a)  # 1
    s.d = 11    # Append a new field
    delattr(s, &#39;d&#39;)  # Delete the field
    ```

    #### Using `param` for Evaluation
    ```python
    p = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    p.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    # --------
    ```

    ---

    ### Concatenation and Subtraction
    Fields from the right-most structure overwrite existing values.
    ```python
    a = struct(a=1, b=2)
    b = struct(c=3, d=&#34;d&#34;, e=&#34;e&#34;)
    c = a + b
    e = c - a
    ```

    ---

    ### Practical Shorthands

    #### Constructing a Structure from Keys
    ```python
    s = struct.fromkeys([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;])
    # Output:
    # --------
    #      a: None
    #      b: None
    #      c: None
    #      d: None
    # --------
    ```

    #### Building a Structure from Variables in a String
    ```python
    s = struct.scan(&#34;${a} + ${b} * ${c} / ${d} --- ${ee}&#34;)
    s.a = 1
    s.b = &#34;test&#34;
    s.c = [1, &#34;a&#34;, 2]
    s.generator()
    # Output:
    # X = struct(
    #      a=1,
    #      b=&#34;test&#34;,
    #      c=[1, &#39;a&#39;, 2],
    #      d=None,
    #      ee=None
    # )
    ```

    #### Indexing and Iteration
    Structures can be indexed or sliced like lists.
    ```python
    c = a + b
    c[0]      # Access the first field
    c[-1]     # Access the last field
    c[:2]     # Slice the structure
    for field in c:
        print(field)
    ```

    ---

    ### Dynamic Dependency Management
    `struct` provides control over dependencies, sorting, and evaluation.

    ```python
    s = struct(d=3, e=&#34;${c} + {d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    s.sortdefinitions()
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}
    #      e: ${c} + ${d}
    # --------
    ```

    For dynamic evaluation, use `param`:
    ```python
    p = param(sortdefinitions=True, d=3, e=&#34;${c} + ${d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}  (= 3)
    #      e: ${c} + ${d}  (= 6)
    # --------
    ```

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two structures (`__add__`).
    - `-`: Subtraction of fields (`__sub__`).
    - `len()`: Number of fields (`__len__`).
    - `in`: Check for field existence (`__contains__`).

    #### Method Overview
    | Method                | Description                                             |
    |-----------------------|---------------------------------------------------------|
    | `check(default)`      | Populate fields with defaults if missing.               |
    | `clear()`             | Remove all fields.                                      |
    | `dict2struct(dico)`   | Create a structure from a dictionary.                   |
    | `disp()`              | Display the structure.                                  |
    | `eval()`              | Evaluate expressions within fields.                     |
    | `fromkeys(keys)`      | Create a structure from a list of keys.                 |
    | `generator()`         | Generate Python code representing the structure.        |
    | `items()`             | Return key-value pairs.                                 |
    | `keys()`              | Return all keys in the structure.                       |
    | `read(file)`          | Load structure fields from a file.                      |
    | `scan(string)`        | Extract variables from a string and populate fields.    |
    | `sortdefinitions()`   | Sort fields to resolve dependencies.                    |
    | `struct2dict()`       | Convert the structure to a dictionary.                  |
    | `values()`            | Return all field values.                                |
    | `write(file)`         | Save the structure to a file.                           |

    ---

    ### Dynamic Properties
    | Property    | Description                            |
    |-------------|----------------------------------------|
    | `isempty`   | `True` if the structure is empty.      |
    | `isdefined` | `True` if all fields are defined.      |

    ---
    &#34;&#34;&#34;

    # attributes to be overdefined
    _type = &#34;struct&#34;        # object type
    _fulltype = &#34;structure&#34; # full name
    _ftype = &#34;field&#34;        # field name
    _evalfeature = False    # true if eval() is available
    _maxdisplay = 40        # maximum number of characters to display (should be even)
    _propertyasattribute = False

    # attributes for the iterator method
    # Please keep it static, duplicate the object before changing _iter_
    _iter_ = 0

    # excluded attributes (keep the , in the Tupple if it is singleton)
    _excludedattr = {&#39;_iter_&#39;,&#39;__class__&#39;,&#39;_protection&#39;,&#39;_evaluation&#39;,&#39;_returnerror&#39;,&#39;_debug&#39;} # used by keys() and len()


    # Methods
    def __init__(self,debug=False,**kwargs):
        &#34;&#34;&#34; constructor, use debug=True to report eval errors&#34;&#34;&#34;
        # Optionally extend _excludedattr here
        self._excludedattr = self._excludedattr | {&#39;_excludedattr&#39;, &#39;_type&#39;, &#39;_fulltype&#39;,&#39;_ftype&#39;} # addition 2024-10-11
        self._debug = debug
        self.set(**kwargs)

    def zip(self):
        &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
        return zip(self.keys(),self.values())

    @staticmethod
    def dict2struct(dico,makeparam=False):
        &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
        if isinstance(dico,dict):
            s = param() if makeparam else struct()
            s.set(**dico)
            return s
        raise TypeError(&#34;the argument must be a dictionary&#34;)

    def struct2dict(self):
        &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
        return dict(self.zip())

    def struct2param(self,protection=False,evaluation=True):
        &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
        p = param(**self.struct2dict())
        for i in range(len(self)):
            if isinstance(self[i],pstr): p[i] = pstr(p[i])
        p._protection = protection
        p._evaluation = evaluation
        return p

    def set(self,**kwargs):
        &#34;&#34;&#34; initialization &#34;&#34;&#34;
        self.__dict__.update(kwargs)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value

    def getattr(self,key):
        &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
        if key in self.__dict__:
            return self.__dict__[key]
        elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
             key not in self._excludedattr and \
             key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
            # If _propertyasattribute is True and it&#39;s a property, get its value
            return self.__class__.__dict__[key].fget(self)
        else:
            raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)

    def hasattr(self, key):
        &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
        return key in self.__dict__ or (
            getattr(self, &#39;_propertyasattribute&#39;, False) and
            key not in self._excludedattr and
            key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
        )

    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return pstr.eval(self.getattr(key))

    def __setattr__(self,key,value):
        &#34;&#34;&#34; set attribute override &#34;&#34;&#34;
        self.setattr(key,value)

    def __contains__(self,item):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(item)

    def keys(self):
        &#34;&#34;&#34; return the fields &#34;&#34;&#34;
        # keys() is used by struct() and its iterator
        return [key for key in self.__dict__.keys() if key not in self._excludedattr]

    def keyssorted(self,reverse=True):
        &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
        klist = self.keys()
        l = [len(k) for k in klist]
        return [k for _,k in sorted(zip(l,klist),reverse=reverse)]

    def values(self):
        &#34;&#34;&#34; return the values &#34;&#34;&#34;
        # values() is used by struct() and its iterator
        return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]

    @staticmethod
    def fromkeysvalues(keys,values,makeparam=False):
        &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
            use makeparam = True to create a param instead of struct
        &#34;&#34;&#34;
        if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
        if not isinstance(keys,_list_types): keys = [keys]
        if not isinstance(values,_list_types): values = [values]
        nk,nv = len(keys), len(values)
        s = param() if makeparam else struct()
        if nk&gt;0 and nv&gt;0:
            iv = 0
            for ik in range(nk):
                s.setattr(keys[ik], values[iv])
                iv = min(nv-1,iv+1)
            for ik in range(nk,nv):
                s.setattr(f&#34;key{ik}&#34;, values[ik])
        return s

    def items(self):
        &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
        return self.zip()

    def __getitem__(self,idx):
        &#34;&#34;&#34;
            s[i] returns the ith element of the structure
            s[:4] returns a structure with the four first fields
            s[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.getattr(self.keys()[idx])
            raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            return struct.fromkeysvalues(self.keys()[idx], self.values()[idx])
        elif isinstance(idx,(list,tuple)):
            k,v= self.keys(), self.values()
            nk = len(k)
            s = param() if isinstance(self,param) else struct()
            for i in idx:
                if isinstance(i,int) and i&gt;=0 and i&lt;nk:
                    s.setattr(k[i],v[i])
                else:
                    raise IndexError(&#34;idx must contains only integers ranged between 0 and %d&#34; % (nk-1))
            return s
        elif isinstance(idx,str):
            return self.getattr(idx)
        else:
            raise TypeError(&#34;The index must be an integer or a slice and not a %s&#34; % type(idx).__name__)

    def __setitem__(self,idx,value):
        &#34;&#34;&#34; set the ith element of the structure  &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                self.setattr(self.keys()[idx], value)
            else:
                raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            k = self.keys()[idx]
            if len(value)&lt;=1:
                for i in range(len(k)): self.setattr(k[i], value)
            elif len(k) == len(value):
                for i in range(len(k)): self.setattr(k[i], value[i])
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of elements in the slive (%d)&#34; \
                       % (len(value),len(idx)))
        elif isinstance(idx,(list,tuple)):
            if len(value)&lt;=1:
                for i in range(len(idx)): self[idx[i]]=value
            elif len(idx) == len(value):
                for i in range(len(idx)): self[idx[i]]=value[i]
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of indices (%d)&#34; \
                                 % (len(value),len(idx)))

    def __len__(self):
        &#34;&#34;&#34; return the number of fields &#34;&#34;&#34;
        # len() is used by struct() and its iterator
        return len(self.keys())

    def __iter__(self):
        &#34;&#34;&#34; struct iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    def __next__(self):
        &#34;&#34;&#34; increment iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum {self._ftype} iteration reached {len(self)}&#34;)

    def __add__(self,s,sortdefinitions=False,raiseerror=True, silentmode=True):
        &#34;&#34;&#34; add a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        dup.__dict__.update(s.__dict__)
        if sortdefinitions: dup.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return dup

    def __iadd__(self,s,sortdefinitions=False,raiseerror=False, silentmode=True):
        &#34;&#34;&#34; iadd a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        self.__dict__.update(s.__dict__)
        if sortdefinitions: self.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return self

    def __sub__(self,s):
        &#34;&#34;&#34; sub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        listofkeys = dup.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(dup,k)
        return dup

    def __isub__(self,s):
        &#34;&#34;&#34; isub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        listofkeys = self.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(self,k)
        return self

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        if self.__dict__=={}:
            print(f&#34;empty {self._fulltype} ({self._type} object) with no {self._type}s&#34;)
            return f&#34;empty {self._fulltype}&#34;
        else:
            tmp = self.eval() if self._evalfeature else []
            keylengths = [len(key) for key in self.__dict__]
            width = max(10,max(keylengths)+2)
            fmt = &#34;%%%ss:&#34; % width
            fmteval = fmt[:-1]+&#34;=&#34;
            fmtcls =  fmt[:-1]+&#34;:&#34;
            line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
            print(line)
            for key,value in self.__dict__.items():
                if key not in self._excludedattr:
                    if isinstance(value,_numeric_types):
                        # old code (removed on 2025-01-18)
                        # if isinstance(value,pstr):
                        #     print(fmt % key,&#39;p&#34;&#39;+self.dispmax(value)+&#39;&#34;&#39;)
                        # if isinstance(value,str) and value==&#34;&#34;:
                        #     print(fmt % key,&#39;&#34;&#34;&#39;)
                        # else:
                        #     print(fmt % key,self.dispmax(value))
                        if isinstance(value,np.ndarray):
                            print(fmt % key, struct.format_array(value))
                        else:
                            print(fmt % key,self.dispmax(value))
                    elif isinstance(value,struct):
                        print(fmt % key,self.dispmax(value.__str__()))
                    elif isinstance(value,type):
                        print(fmt % key,self.dispmax(str(value)))
                    else:
                        print(fmt % key,type(value))
                        print(fmtcls % &#34;&#34;,self.dispmax(str(value)))
                    if self._evalfeature:
                        if isinstance(self,paramauto):
                            try:
                                if isinstance(value,pstr):
                                    print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                                elif isinstance(value,str):
                                    if value == &#34;&#34;:
                                        print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(tmp.getattr(key)))
                            except Exception as err:
                                print(fmteval % &#34;&#34;,err.message, err.args)
                        else:
                            if isinstance(value,pstr):
                                print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                            elif isinstance(value,str):
                                if value == &#34;&#34;:
                                    print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                else:
                                    calcvalue =tmp.getattr(key)
                                    if isinstance(calcvalue, str) and &#34;error&#34; in calcvalue.lower():
                                        print(fmteval % &#34;&#34;,calcvalue)
                                    else:
                                        if isinstance(calcvalue,np.ndarray):
                                            print(fmteval % &#34;&#34;, struct.format_array(calcvalue))
                                        else:
                                            print(fmteval % &#34;&#34;,self.dispmax(calcvalue))
            print(line)
            return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    def disp(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        self.__repr__()

    def __str__(self):
        return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    @property
    def isempty(self):
        &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
        return len(self)==0

    def clear(self):
        &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
        for k in self.keys(): delattr(self,k)

    def format(self, s, escape=False, raiseerror=True):
        &#34;&#34;&#34;
            Format a string with fields using {field} as placeholders.
            Handles expressions like ${variable1}.

            Args:
                s (str): The input string to format.
                escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
                raiseerror (bool): If True, raises errors for missing fields.

            Note:
                NumPy vectors and matrices are converted into their text representation (default behavior)
                If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

            Returns:
                str: The formatted string.
        &#34;&#34;&#34;
        tmp = self.np2str()
        if raiseerror:
            try:
                if escape:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.format_map(AttrErrorDict(self.__dict__))
                else:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
            except AttributeError as attr_err:
                # Handle AttributeError for expressions with operators
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
                return s_  # Revert to using &#39;${&#39; for unresolved expressions
            except IndexError as idx_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
                raise IndexError from idx_err
            except Exception as other_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                raise RuntimeError from other_err
        else:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except:  # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))

    def format_legacy(self,s,escape=False,raiseerror=True):
        &#34;&#34;&#34;
            format a string with field (use {field} as placeholders)
                s.replace(string), s.replace(string,escape=True)
                where:
                    s is a struct object
                    string is a string with possibly ${variable1}
                    escape is a flag to prevent ${} replaced by {}
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format(**self.__dict__)
                else:
                    return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
            except KeyError as kerr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
                return s_ # instead of s (we put back $) - OV 2023/01/27
            except Exception as othererr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                raise RuntimeError from othererr
        else:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)

    def fromkeys(self,keys):
        &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
        return self+struct(**dict.fromkeys(keys,None))

    @staticmethod
    def scan(s):
        &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
        tmp = struct()
        #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
        found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
        uniq = []
        for x in found:
            if x not in uniq: uniq.append(x)
        return tmp.fromkeys(uniq)

    @staticmethod
    def isstrexpression(s):
        &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        return re.search(r&#34;\$\{.*?\}&#34;,s) is not None

    @property
    def isexpression(self):
        &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        for k,v in self.items():
            if isinstance(v,str):
                s.setattr(k,struct.isstrexpression(v))
            else:
                s.setattr(k,False)
        return s

    @staticmethod
    def isstrdefined(s,ref):
        &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        if struct.isstrexpression(s):
            k = struct.scan(s).keys()
            allfound,i,nk = True,0,len(k)
            while (i&lt;nk) and allfound:
                allfound = k[i] in ref
                i += 1
            return allfound
        else:
            return False


    def isdefined(self,ref=None):
        &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
        nk = len(k)
        if ref is None:
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
                else:
                    s.setattr(k[i],True)
        else:
            if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],ref))
                else:
                    s.setattr(k[i],True)
        return s

    def sortdefinitions(self,raiseerror=True,silentmode=False):
        &#34;&#34;&#34; sortdefintions sorts all definitions
            so that they can be executed as param().
            If any inconsistency is found, an error message is generated.

            Flags = default values
                raiseerror=True show erros of True
                silentmode=False no warning if True
        &#34;&#34;&#34;
        find = lambda xlist: [i for i, x in enumerate(xlist) if x]
        findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
        k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
        istatic = findnot(isexpr)
        idynamic = find(isexpr)
        static = struct.fromkeysvalues(
            [ k[i] for i in istatic ],
            [ v[i] for i in istatic ],
            makeparam = False)
        dynamic = struct.fromkeysvalues(
            [ k[i] for i in idynamic ],
            [ v[i] for i in idynamic ],
            makeparam=False)
        current = static # make static the current structure
        nmissing, anychange, errorfound = len(dynamic), False, False
        while nmissing:
            itst, found = 0, False
            while itst&lt;nmissing and not found:
                teststruct = current + dynamic[[itst]] # add the test field
                found = all(list(teststruct.isdefined()))
                ifound = itst
                itst += 1
            if found:
                current = teststruct # we accept the new field
                dynamic[ifound] = []
                nmissing -= 1
                anychange = True
            else:
                if raiseerror:
                    raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                                   (nmissing,len(self),self._ftype))
                else:
                    if (not errorfound) and (not silentmode):
                        print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                              (nmissing,len(self),self._ftype))
                    current = teststruct # we accept the new field (even if it cannot be interpreted)
                    dynamic[ifound] = []
                    nmissing -= 1
                    errorfound = True
        if anychange:
            self.clear() # reset all fields and assign them in the proper order
            k,v = current.keys(), current.values()
            for i in range(len(k)):
                self.setattr(k[i],v[i])

    def generator(self):
        &#34;&#34;&#34; generate Python code of the equivalent structure &#34;&#34;&#34;
        nk = len(self)
        if nk==0:
            print(&#34;X = struct()&#34;)
        else:
            ik = 0
            fmt = &#34;%%%ss=&#34; % max(10,max([len(k) for k in self.keys()])+2)
            print(&#34;\nX = struct(&#34;)
            for k in self.keys():
                ik += 1
                end = &#34;,\n&#34; if ik&lt;nk else &#34;\n&#34;+(fmt[:-1] % &#34;)&#34;)+&#34;\n&#34;
                v = getattr(self,k)
                if isinstance(v,(int,float)) or v == None:
                    print(fmt % k,v,end=end)
                elif isinstance(v,str):
                    print(fmt % k,f&#39;&#34;{v}&#34;&#39;,end=end)
                elif isinstance(v,(list,tuple)):
                    print(fmt % k,v,end=end)
                else:
                    print(fmt % k,&#34;/* unsupported type */&#34;,end=end)

    # copy and deep copy methpds for the class
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, duplicatedeep(v, memo))
        return copie


    # write a file
    def write(self, file, overwrite=True, mkdir=False):
        &#34;&#34;&#34;
            write the equivalent structure (not recursive for nested struct)
                write(filename, overwrite=True, mkdir=False)

            Parameters:
            - file: The file path to write to.
            - overwrite: Whether to overwrite the file if it exists (default: True).
            - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()

        # Check if the directory exists or if mkdir is set to True, create it
        if mkdir:
            file_path.parent.mkdir(parents=True, exist_ok=True)
        elif not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If overwrite is False and the file already exists, raise an exception
        if not overwrite and file_path.exists():
            raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
        # Open and write to the file using the resolved path
        with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
            print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
            for k, v in self.items():
                if v is None:
                    print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
                elif isinstance(v, (int, float)):
                    print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
                elif isinstance(v, str):
                    print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
                else:
                    print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)


    # read a file
    @staticmethod
    def read(file):
        &#34;&#34;&#34;
            read the equivalent structure
                read(filename)

            Parameters:
            - file: The file path to read from.
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()
        # Check if the parent directory exists, otherwise raise an error
        if not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If the file does not exist, raise an exception
        if not file_path.exists():
            raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
        # Open and read the file
        with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            s = struct()  # Assuming struct is defined elsewhere
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                expr = line.split(sep=&#34;=&#34;)
                if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                    lhs = expr[0]
                    rhs = &#34;&#34;.join(expr[1:]).strip()
                    if len(rhs) == 0 or rhs == &#34;None&#34;:
                        v = None
                    else:
                        v = eval(rhs)
                    s.setattr(lhs, v)
        return s

    # argcheck
    def check(self,default):
        &#34;&#34;&#34;
        populate fields from a default structure
            check(defaultstruct)
            missing field, None and [] values are replaced by default ones

            Note: a.check(b) is equivalent to b+a except for [] and None values
        &#34;&#34;&#34;
        if not isinstance(default,struct):
            raise TypeError(&#34;the first argument must be a structure&#34;)
        for f in default.keys():
            ref = default.getattr(f)
            if f not in self:
                self.setattr(f, ref)
            else:
                current = self.getattr(f)
                if ((current is None)  or (current==[])) and \
                    ((ref is not None) and (ref!=[])):
                        self.setattr(f, ref)


    # update values based on key:value
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple fields at once, while protecting certain attributes.

        Parameters:
        -----------
        **kwargs : dict
            The fields to update and their new values.

        Protected attributes defined in _excludedattr are not updated.

        Usage:
        ------
        s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
        &#34;&#34;&#34;
        protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

        for key, value in kwargs.items():
            if key in protected_attributes:
                print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
            else:
                self.setattr(key, value)


    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract a sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            A new instance of the same class as the original, containing
            only the specified keys.

        Usage:
        ------
        sub_struct = s(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        # Create a new instance of the same class
        sub_struct = self.__class__()

        # Get the full type and field type for error messages
        fulltype = getattr(self, &#39;_fulltype&#39;, &#39;structure&#39;)
        ftype = getattr(self, &#39;_ftype&#39;, &#39;field&#39;)

        # Add only the specified keys to the new sub-structure
        for key in keys:
            if key in self:
                sub_struct.setattr(key, self.getattr(key))
            else:
                raise KeyError(f&#34;{fulltype} does not contain the {ftype} &#39;{key}&#39;.&#34;)

        return sub_struct


    def __delattr__(self, key):
        &#34;&#34;&#34; Delete an instance attribute if it exists and is not a class or excluded attribute. &#34;&#34;&#34;
        if key in self._excludedattr:
            raise AttributeError(f&#34;Cannot delete excluded attribute &#39;{key}&#39;&#34;)
        elif key in self.__class__.__dict__:  # Check if it&#39;s a class attribute
            raise AttributeError(f&#34;Cannot delete class attribute &#39;{key}&#39;&#34;)
        elif key in self.__dict__:  # Delete only if in instance&#39;s __dict__
            del self.__dict__[key]
        else:
            raise AttributeError(f&#34;{self._type} has no attribute &#39;{key}&#39;&#34;)


    # A la Matlab display method of vectors, matrices and ND-arrays
    @staticmethod
    def format_array(value):
        &#34;&#34;&#34;
        Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
        Recursively formats multi-dimensional arrays without introducing unwanted commas.

        Args:
            value (np.ndarray): The NumPy array to format.

        Returns:
            str: A formatted string representation of the array.
        &#34;&#34;&#34;
        dtype_str = {
            np.float64: &#34;double&#34;,
            np.float32: &#34;single&#34;,
            np.int32: &#34;int32&#34;,
            np.int64: &#34;int64&#34;,
            np.complex64: &#34;complex single&#34;,
            np.complex128: &#34;complex double&#34;,
        }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

        max_display = 10  # Maximum number of elements to display

        def format_recursive(arr):
            &#34;&#34;&#34;
            Recursively formats the array based on its dimensions.

            Args:
                arr (np.ndarray): The array or sub-array to format.

            Returns:
                str: Formatted string of the array.
            &#34;&#34;&#34;
            if arr.ndim == 0:
                return f&#34;{arr.item()}&#34;

            if arr.ndim == 1:
                if len(arr) &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in arr) + &#34;]&#34;
                else:
                    return f&#34;[{len(arr)} elements]&#34;

            if arr.ndim == 2:
                if arr.shape[1] == 1:
                    # Column vector
                    if arr.shape[0] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in arr) + &#34;]T&#34;
                    else:
                        return f&#34;[{arr.shape[0]}×1 vector]&#34;
                elif arr.shape[0] == 1:
                    # Row vector
                    if arr.shape[1] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in arr[0]) + &#34;]&#34;
                    else:
                        return f&#34;[1×{arr.shape[1]} vector]&#34;
                else:
                    # General matrix
                    return f&#34;[{arr.shape[0]}×{arr.shape[1]} matrix]&#34;

            # For higher dimensions
            shape_str = &#34;×&#34;.join(map(str, arr.shape))
            if arr.size &lt;= max_display:
                # Show full content
                if arr.ndim &gt; 2:
                    # Represent multi-dimensional arrays with nested brackets
                    return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
            return f&#34;[{shape_str} array ({dtype_str})]&#34;

        if value.size == 0:
            return &#34;[]&#34;

        if value.ndim == 0 or value.size == 1:
            return f&#34;{value.item()} ({dtype_str})&#34;

        if value.ndim == 1 or value.ndim == 2:
            # Use existing logic for vectors and matrices
            if value.ndim == 1:
                if len(value) &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{len(value)}×1 {dtype_str}]&#34;
            elif value.ndim == 2:
                rows, cols = value.shape
                if cols == 1:  # Column vector
                    if rows &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[{rows}×1 {dtype_str}]&#34;
                elif rows == 1:  # Row vector
                    if cols &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[1×{cols} {dtype_str}]&#34;
                else:  # General matrix
                    formatted = f&#34;[{rows}×{cols} {dtype_str}]&#34;
            return formatted

        # For higher-dimensional arrays
        if value.size &lt;= max_display:
            formatted = format_recursive(value)
        else:
            shape_str = &#34;×&#34;.join(map(str, value.shape))
            formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

        return formatted


    # convert all NumPy entries to &#34;nestable&#34; expressions
    def np2str(self):
        &#34;&#34;&#34; Convert all np entries of s into their string representations  &#34;&#34;&#34;
        out = struct()
        def format_numpy_result(value):
            &#34;&#34;&#34;
            Converts a NumPy array or scalar into a string representation:
            - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
            - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
            - Non-ndarray inputs are returned without modification.

            Args:
                value (np.ndarray, scalar, or other): The value to format.

            Returns:
                str or original type: A properly formatted string for NumPy arrays/scalars or the original value.
            &#34;&#34;&#34;
            if np.isscalar(value):
                # If the value is a scalar, return it directly
                return repr(value)
            elif isinstance(value, np.ndarray):
                # Check if the array has exactly one element
                if value.size == 1:
                    # Extract the scalar value
                    return repr(value.item())
                # Convert the array to a nested list
                nested_list = value.tolist()
                # Recursively format the nested list into a valid string
                def list_to_string(lst):
                    if isinstance(lst, list):
                        # Format lists with proper commas
                        return &#34;[&#34; + &#34;, &#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                    else:
                        # Format scalars in the list
                        return repr(lst)

                return list_to_string(nested_list)
            else:
                # Return the input unmodified if not a NumPy array or scalar
                return value
        # process all entries in s
        for key,value in self.items():
            out.setattr(key,format_numpy_result(value))
        return out</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.private.mstruct.param</li>
<li>pizza.raster.collection</li>
<li>pizza.region.regioncollection</li>
<li>pizza.script.scriptobject</li>
<li>pizza.script.scriptobjectgroup</li>
<li><a title="region.regioncollection" href="#region.regioncollection">regioncollection</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="region.struct.dict2struct"><code class="name flex">
<span>def <span class="ident">dict2struct</span></span>(<span>dico, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>create a structure from a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dict2struct(dico,makeparam=False):
    &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
    if isinstance(dico,dict):
        s = param() if makeparam else struct()
        s.set(**dico)
        return s
    raise TypeError(&#34;the argument must be a dictionary&#34;)</code></pre>
</details>
</dd>
<dt id="region.struct.format_array"><code class="name flex">
<span>def <span class="ident">format_array</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
Recursively formats multi-dimensional arrays without introducing unwanted commas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The NumPy array to format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representation of the array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_array(value):
    &#34;&#34;&#34;
    Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
    Recursively formats multi-dimensional arrays without introducing unwanted commas.

    Args:
        value (np.ndarray): The NumPy array to format.

    Returns:
        str: A formatted string representation of the array.
    &#34;&#34;&#34;
    dtype_str = {
        np.float64: &#34;double&#34;,
        np.float32: &#34;single&#34;,
        np.int32: &#34;int32&#34;,
        np.int64: &#34;int64&#34;,
        np.complex64: &#34;complex single&#34;,
        np.complex128: &#34;complex double&#34;,
    }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

    max_display = 10  # Maximum number of elements to display

    def format_recursive(arr):
        &#34;&#34;&#34;
        Recursively formats the array based on its dimensions.

        Args:
            arr (np.ndarray): The array or sub-array to format.

        Returns:
            str: Formatted string of the array.
        &#34;&#34;&#34;
        if arr.ndim == 0:
            return f&#34;{arr.item()}&#34;

        if arr.ndim == 1:
            if len(arr) &lt;= max_display:
                return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in arr) + &#34;]&#34;
            else:
                return f&#34;[{len(arr)} elements]&#34;

        if arr.ndim == 2:
            if arr.shape[1] == 1:
                # Column vector
                if arr.shape[0] &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in arr) + &#34;]T&#34;
                else:
                    return f&#34;[{arr.shape[0]}×1 vector]&#34;
            elif arr.shape[0] == 1:
                # Row vector
                if arr.shape[1] &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in arr[0]) + &#34;]&#34;
                else:
                    return f&#34;[1×{arr.shape[1]} vector]&#34;
            else:
                # General matrix
                return f&#34;[{arr.shape[0]}×{arr.shape[1]} matrix]&#34;

        # For higher dimensions
        shape_str = &#34;×&#34;.join(map(str, arr.shape))
        if arr.size &lt;= max_display:
            # Show full content
            if arr.ndim &gt; 2:
                # Represent multi-dimensional arrays with nested brackets
                return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
        return f&#34;[{shape_str} array ({dtype_str})]&#34;

    if value.size == 0:
        return &#34;[]&#34;

    if value.ndim == 0 or value.size == 1:
        return f&#34;{value.item()} ({dtype_str})&#34;

    if value.ndim == 1 or value.ndim == 2:
        # Use existing logic for vectors and matrices
        if value.ndim == 1:
            if len(value) &lt;= max_display:
                formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
            else:
                formatted = f&#34;[{len(value)}×1 {dtype_str}]&#34;
        elif value.ndim == 2:
            rows, cols = value.shape
            if cols == 1:  # Column vector
                if rows &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:.4g}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{rows}×1 {dtype_str}]&#34;
            elif rows == 1:  # Row vector
                if cols &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:.4g}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[1×{cols} {dtype_str}]&#34;
            else:  # General matrix
                formatted = f&#34;[{rows}×{cols} {dtype_str}]&#34;
        return formatted

    # For higher-dimensional arrays
    if value.size &lt;= max_display:
        formatted = format_recursive(value)
    else:
        shape_str = &#34;×&#34;.join(map(str, value.shape))
        formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

    return formatted</code></pre>
</details>
</dd>
<dt id="region.struct.fromkeysvalues"><code class="name flex">
<span>def <span class="ident">fromkeysvalues</span></span>(<span>keys, values, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>struct.keysvalues(keys,values) creates a structure from keys and values
use makeparam = True to create a param instead of struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromkeysvalues(keys,values,makeparam=False):
    &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
        use makeparam = True to create a param instead of struct
    &#34;&#34;&#34;
    if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
    if not isinstance(keys,_list_types): keys = [keys]
    if not isinstance(values,_list_types): values = [values]
    nk,nv = len(keys), len(values)
    s = param() if makeparam else struct()
    if nk&gt;0 and nv&gt;0:
        iv = 0
        for ik in range(nk):
            s.setattr(keys[ik], values[iv])
            iv = min(nv-1,iv+1)
        for ik in range(nk,nv):
            s.setattr(f&#34;key{ik}&#34;, values[ik])
    return s</code></pre>
</details>
</dd>
<dt id="region.struct.isstrdefined"><code class="name flex">
<span>def <span class="ident">isstrdefined</span></span>(<span>s, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrdefined(string,ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrdefined(s,ref):
    &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
    if struct.isstrexpression(s):
        k = struct.scan(s).keys()
        allfound,i,nk = True,0,len(k)
        while (i&lt;nk) and allfound:
            allfound = k[i] in ref
            i += 1
        return allfound
    else:
        return False</code></pre>
</details>
</dd>
<dt id="region.struct.isstrexpression"><code class="name flex">
<span>def <span class="ident">isstrexpression</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrexpression(string) returns true if s contains an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrexpression(s):
    &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    return re.search(r&#34;\$\{.*?\}&#34;,s) is not None</code></pre>
</details>
</dd>
<dt id="region.struct.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>read the equivalent structure
read(filename)</p>
<p>Parameters:
- file: The file path to read from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read(file):
    &#34;&#34;&#34;
        read the equivalent structure
            read(filename)

        Parameters:
        - file: The file path to read from.
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()
    # Check if the parent directory exists, otherwise raise an error
    if not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If the file does not exist, raise an exception
    if not file_path.exists():
        raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
    # Open and read the file
    with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
        s = struct()  # Assuming struct is defined elsewhere
        while True:
            line = f.readline()
            if not line:
                break
            line = line.strip()
            expr = line.split(sep=&#34;=&#34;)
            if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                lhs = expr[0]
                rhs = &#34;&#34;.join(expr[1:]).strip()
                if len(rhs) == 0 or rhs == &#34;None&#34;:
                    v = None
                else:
                    v = eval(rhs)
                s.setattr(lhs, v)
    return s</code></pre>
</details>
</dd>
<dt id="region.struct.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>scan(string) scan a string for variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def scan(s):
    &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
    tmp = struct()
    #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
    found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
    uniq = []
    for x in found:
        if x not in uniq: uniq.append(x)
    return tmp.fromkeys(uniq)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="region.struct.isempty"><code class="name">var <span class="ident">isempty</span></code></dt>
<dd>
<div class="desc"><p>isempty is set to True for an empty structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isempty(self):
    &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
    return len(self)==0</code></pre>
</details>
</dd>
<dt id="region.struct.isexpression"><code class="name">var <span class="ident">isexpression</span></code></dt>
<dd>
<div class="desc"><p>same structure with True if it is an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isexpression(self):
    &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    for k,v in self.items():
        if isinstance(v,str):
            s.setattr(k,struct.isstrexpression(v))
        else:
            s.setattr(k,False)
    return s</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="region.struct.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, default)</span>
</code></dt>
<dd>
<div class="desc"><p>populate fields from a default structure
check(defaultstruct)
missing field, None and [] values are replaced by default ones</p>
<pre><code>Note: a.check(b) is equivalent to b+a except for [] and None values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self,default):
    &#34;&#34;&#34;
    populate fields from a default structure
        check(defaultstruct)
        missing field, None and [] values are replaced by default ones

        Note: a.check(b) is equivalent to b+a except for [] and None values
    &#34;&#34;&#34;
    if not isinstance(default,struct):
        raise TypeError(&#34;the first argument must be a structure&#34;)
    for f in default.keys():
        ref = default.getattr(f)
        if f not in self:
            self.setattr(f, ref)
        else:
            current = self.getattr(f)
            if ((current is None)  or (current==[])) and \
                ((ref is not None) and (ref!=[])):
                    self.setattr(f, ref)</code></pre>
</details>
</dd>
<dt id="region.struct.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear() delete all fields while preserving the original class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
    for k in self.keys(): delattr(self,k)</code></pre>
</details>
</dd>
<dt id="region.struct.disp"><code class="name flex">
<span>def <span class="ident">disp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>display method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disp(self):
    &#34;&#34;&#34; display method &#34;&#34;&#34;
    self.__repr__()</code></pre>
</details>
</dd>
<dt id="region.struct.dispmax"><code class="name flex">
<span>def <span class="ident">dispmax</span></span>(<span>self, content)</span>
</code></dt>
<dd>
<div class="desc"><p>optimize display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispmax(self,content):
    &#34;&#34;&#34; optimize display &#34;&#34;&#34;
    strcontent = str(content)
    if len(strcontent)&gt;self._maxdisplay:
        nchar = round(self._maxdisplay/2)
        return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
    else:
        return content</code></pre>
</details>
</dd>
<dt id="region.struct.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Format a string with fields using {field} as placeholders.
Handles expressions like ${variable1}.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>The input string to format.</dd>
<dt><strong><code>escape</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, prevents replacing '${' with '{'.</dd>
<dt><strong><code>raiseerror</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, raises errors for missing fields.</dd>
</dl>
<h2 id="note">Note</h2>
<p>NumPy vectors and matrices are converted into their text representation (default behavior)
If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, s, escape=False, raiseerror=True):
    &#34;&#34;&#34;
        Format a string with fields using {field} as placeholders.
        Handles expressions like ${variable1}.

        Args:
            s (str): The input string to format.
            escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
            raiseerror (bool): If True, raises errors for missing fields.

        Note:
            NumPy vectors and matrices are converted into their text representation (default behavior)
            If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

        Returns:
            str: The formatted string.
    &#34;&#34;&#34;
    tmp = self.np2str()
    if raiseerror:
        try:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
        except AttributeError as attr_err:
            # Handle AttributeError for expressions with operators
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
            return s_  # Revert to using &#39;${&#39; for unresolved expressions
        except IndexError as idx_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            if self._debug:
                print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
            raise IndexError from idx_err
        except Exception as other_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            raise RuntimeError from other_err
    else:
        if escape:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.format_map(AttrErrorDict(tmp.__dict__))
            except: # if an error occurs, we use the orginal content
                return s.format_map(AttrErrorDict(self.__dict__))
        else:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
            except:  # if an error occurs, we use the orginal content
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))</code></pre>
</details>
</dd>
<dt id="region.struct.format_legacy"><code class="name flex">
<span>def <span class="ident">format_legacy</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>format a string with field (use {field} as placeholders)
s.replace(string), s.replace(string,escape=True)
where:
s is a struct object
string is a string with possibly ${variable1}
escape is a flag to prevent ${} replaced by {}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_legacy(self,s,escape=False,raiseerror=True):
    &#34;&#34;&#34;
        format a string with field (use {field} as placeholders)
            s.replace(string), s.replace(string,escape=True)
            where:
                s is a struct object
                string is a string with possibly ${variable1}
                escape is a flag to prevent ${} replaced by {}
    &#34;&#34;&#34;
    if raiseerror:
        try:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
        except KeyError as kerr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
            return s_ # instead of s (we put back $) - OV 2023/01/27
        except Exception as othererr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            raise RuntimeError from othererr
    else:
        if escape:
            return s.format(**self.__dict__)
        else:
            return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)</code></pre>
</details>
</dd>
<dt id="region.struct.fromkeys"><code class="name flex">
<span>def <span class="ident">fromkeys</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a structure from keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromkeys(self,keys):
    &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
    return self+struct(**dict.fromkeys(keys,None))</code></pre>
</details>
</dd>
<dt id="region.struct.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>generate Python code of the equivalent structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self):
    &#34;&#34;&#34; generate Python code of the equivalent structure &#34;&#34;&#34;
    nk = len(self)
    if nk==0:
        print(&#34;X = struct()&#34;)
    else:
        ik = 0
        fmt = &#34;%%%ss=&#34; % max(10,max([len(k) for k in self.keys()])+2)
        print(&#34;\nX = struct(&#34;)
        for k in self.keys():
            ik += 1
            end = &#34;,\n&#34; if ik&lt;nk else &#34;\n&#34;+(fmt[:-1] % &#34;)&#34;)+&#34;\n&#34;
            v = getattr(self,k)
            if isinstance(v,(int,float)) or v == None:
                print(fmt % k,v,end=end)
            elif isinstance(v,str):
                print(fmt % k,f&#39;&#34;{v}&#34;&#39;,end=end)
            elif isinstance(v,(list,tuple)):
                print(fmt % k,v,end=end)
            else:
                print(fmt % k,&#34;/* unsupported type */&#34;,end=end)</code></pre>
</details>
</dd>
<dt id="region.struct.getattr"><code class="name flex">
<span>def <span class="ident">getattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get attribute override to access both instance attributes and properties if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getattr(self,key):
    &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
    if key in self.__dict__:
        return self.__dict__[key]
    elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
         key not in self._excludedattr and \
         key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
        # If _propertyasattribute is True and it&#39;s a property, get its value
        return self.__class__.__dict__[key].fget(self)
    else:
        raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)</code></pre>
</details>
</dd>
<dt id="region.struct.hasattr"><code class="name flex">
<span>def <span class="ident">hasattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the field exists, considering properties as regular attributes if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasattr(self, key):
    &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
    return key in self.__dict__ or (
        getattr(self, &#39;_propertyasattribute&#39;, False) and
        key not in self._excludedattr and
        key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
    )</code></pre>
</details>
</dd>
<dt id="region.struct.isdefined"><code class="name flex">
<span>def <span class="ident">isdefined</span></span>(<span>self, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>isdefined(ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdefined(self,ref=None):
    &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
    nk = len(k)
    if ref is None:
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
            else:
                s.setattr(k[i],True)
    else:
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],ref))
            else:
                s.setattr(k[i],True)
    return s</code></pre>
</details>
</dd>
<dt id="region.struct.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all elements as iterable key, value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
    return self.zip()</code></pre>
</details>
</dd>
<dt id="region.struct.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34; return the fields &#34;&#34;&#34;
    # keys() is used by struct() and its iterator
    return [key for key in self.__dict__.keys() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="region.struct.keyssorted"><code class="name flex">
<span>def <span class="ident">keyssorted</span></span>(<span>self, reverse=True)</span>
</code></dt>
<dd>
<div class="desc"><p>sort keys by length()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyssorted(self,reverse=True):
    &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
    klist = self.keys()
    l = [len(k) for k in klist]
    return [k for _,k in sorted(zip(l,klist),reverse=reverse)]</code></pre>
</details>
</dd>
<dt id="region.struct.np2str"><code class="name flex">
<span>def <span class="ident">np2str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all np entries of s into their string representations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def np2str(self):
    &#34;&#34;&#34; Convert all np entries of s into their string representations  &#34;&#34;&#34;
    out = struct()
    def format_numpy_result(value):
        &#34;&#34;&#34;
        Converts a NumPy array or scalar into a string representation:
        - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
        - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
        - Non-ndarray inputs are returned without modification.

        Args:
            value (np.ndarray, scalar, or other): The value to format.

        Returns:
            str or original type: A properly formatted string for NumPy arrays/scalars or the original value.
        &#34;&#34;&#34;
        if np.isscalar(value):
            # If the value is a scalar, return it directly
            return repr(value)
        elif isinstance(value, np.ndarray):
            # Check if the array has exactly one element
            if value.size == 1:
                # Extract the scalar value
                return repr(value.item())
            # Convert the array to a nested list
            nested_list = value.tolist()
            # Recursively format the nested list into a valid string
            def list_to_string(lst):
                if isinstance(lst, list):
                    # Format lists with proper commas
                    return &#34;[&#34; + &#34;, &#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                else:
                    # Format scalars in the list
                    return repr(lst)

            return list_to_string(nested_list)
        else:
            # Return the input unmodified if not a NumPy array or scalar
            return value
    # process all entries in s
    for key,value in self.items():
        out.setattr(key,format_numpy_result(value))
    return out</code></pre>
</details>
</dd>
<dt id="region.struct.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self,**kwargs):
    &#34;&#34;&#34; initialization &#34;&#34;&#34;
    self.__dict__.update(kwargs)</code></pre>
</details>
</dd>
<dt id="region.struct.setattr"><code class="name flex">
<span>def <span class="ident">setattr</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>set field and value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setattr(self,key,value):
    &#34;&#34;&#34; set field and value &#34;&#34;&#34;
    if isinstance(value,list) and len(value)==0 and key in self:
        delattr(self, key)
    else:
        self.__dict__[key] = value</code></pre>
</details>
</dd>
<dt id="region.struct.sortdefinitions"><code class="name flex">
<span>def <span class="ident">sortdefinitions</span></span>(<span>self, raiseerror=True, silentmode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>sortdefintions sorts all definitions
so that they can be executed as param().
If any inconsistency is found, an error message is generated.</p>
<p>Flags = default values
raiseerror=True show erros of True
silentmode=False no warning if True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortdefinitions(self,raiseerror=True,silentmode=False):
    &#34;&#34;&#34; sortdefintions sorts all definitions
        so that they can be executed as param().
        If any inconsistency is found, an error message is generated.

        Flags = default values
            raiseerror=True show erros of True
            silentmode=False no warning if True
    &#34;&#34;&#34;
    find = lambda xlist: [i for i, x in enumerate(xlist) if x]
    findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
    k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
    istatic = findnot(isexpr)
    idynamic = find(isexpr)
    static = struct.fromkeysvalues(
        [ k[i] for i in istatic ],
        [ v[i] for i in istatic ],
        makeparam = False)
    dynamic = struct.fromkeysvalues(
        [ k[i] for i in idynamic ],
        [ v[i] for i in idynamic ],
        makeparam=False)
    current = static # make static the current structure
    nmissing, anychange, errorfound = len(dynamic), False, False
    while nmissing:
        itst, found = 0, False
        while itst&lt;nmissing and not found:
            teststruct = current + dynamic[[itst]] # add the test field
            found = all(list(teststruct.isdefined()))
            ifound = itst
            itst += 1
        if found:
            current = teststruct # we accept the new field
            dynamic[ifound] = []
            nmissing -= 1
            anychange = True
        else:
            if raiseerror:
                raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                               (nmissing,len(self),self._ftype))
            else:
                if (not errorfound) and (not silentmode):
                    print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                          (nmissing,len(self),self._ftype))
                current = teststruct # we accept the new field (even if it cannot be interpreted)
                dynamic[ifound] = []
                nmissing -= 1
                errorfound = True
    if anychange:
        self.clear() # reset all fields and assign them in the proper order
        k,v = current.keys(), current.values()
        for i in range(len(k)):
            self.setattr(k[i],v[i])</code></pre>
</details>
</dd>
<dt id="region.struct.struct2dict"><code class="name flex">
<span>def <span class="ident">struct2dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create a dictionary from the current structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2dict(self):
    &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
    return dict(self.zip())</code></pre>
</details>
</dd>
<dt id="region.struct.struct2param"><code class="name flex">
<span>def <span class="ident">struct2param</span></span>(<span>self, protection=False, evaluation=True)</span>
</code></dt>
<dd>
<div class="desc"><p>convert an object struct() to param()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2param(self,protection=False,evaluation=True):
    &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
    p = param(**self.struct2dict())
    for i in range(len(self)):
        if isinstance(self[i],pstr): p[i] = pstr(p[i])
    p._protection = protection
    p._evaluation = evaluation
    return p</code></pre>
</details>
</dd>
<dt id="region.struct.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update multiple fields at once, while protecting certain attributes.</p>
<h2 id="parameters">Parameters:</h2>
<p>**kwargs : dict
The fields to update and their new values.</p>
<p>Protected attributes defined in _excludedattr are not updated.</p>
<h2 id="usage">Usage:</h2>
<p>s.update(a=10, b=[1, 2, 3], new_field="new_value")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update multiple fields at once, while protecting certain attributes.

    Parameters:
    -----------
    **kwargs : dict
        The fields to update and their new values.

    Protected attributes defined in _excludedattr are not updated.

    Usage:
    ------
    s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
    &#34;&#34;&#34;
    protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())

    for key, value in kwargs.items():
        if key in protected_attributes:
            print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
        else:
            self.setattr(key, value)</code></pre>
</details>
</dd>
<dt id="region.struct.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34; return the values &#34;&#34;&#34;
    # values() is used by struct() and its iterator
    return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="region.struct.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, overwrite=True, mkdir=False)</span>
</code></dt>
<dd>
<div class="desc"><p>write the equivalent structure (not recursive for nested struct)
write(filename, overwrite=True, mkdir=False)</p>
<p>Parameters:
- file: The file path to write to.
- overwrite: Whether to overwrite the file if it exists (default: True).
- mkdir: Whether to create the directory if it doesn't exist (default: False).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, overwrite=True, mkdir=False):
    &#34;&#34;&#34;
        write the equivalent structure (not recursive for nested struct)
            write(filename, overwrite=True, mkdir=False)

        Parameters:
        - file: The file path to write to.
        - overwrite: Whether to overwrite the file if it exists (default: True).
        - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()

    # Check if the directory exists or if mkdir is set to True, create it
    if mkdir:
        file_path.parent.mkdir(parents=True, exist_ok=True)
    elif not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If overwrite is False and the file already exists, raise an exception
    if not overwrite and file_path.exists():
        raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
    # Open and write to the file using the resolved path
    with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
        print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
        for k, v in self.items():
            if v is None:
                print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
            elif isinstance(v, (int, float)):
                print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
            elif isinstance(v, str):
                print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
            else:
                print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="region.struct.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>zip keys and values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self):
    &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
    return zip(self.keys(),self.values())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="region.tlsph"><code class="flex name class">
<span>class <span class="ident">tlsph</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD:TLSPH forcefield (total Lagrangian)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tlsph(smd):
    &#34;&#34;&#34; SMD:TLSPH forcefield (total Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;tlsph&#34;)
    description = smd.description + struct(style=&#34;SMD:TLSPH - total Lagrangian for solids&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Diagonal pair coefficient tlsph
    pair_coeff      %d %d smd/tlsph *COMMON ${rho} ${E} ${nu} ${q1} ${q2} ${Hg} ${Cp} &amp;
                    *STRENGTH_LINEAR_PLASTIC ${sigma_yield} ${hardening} &amp;
                    *EOS_LINEAR &amp;
                    *END
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.saltTLSPH</li>
<li>pizza.forcefield.solidfood</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.tlsph.PAIR_DIAGCOEFF"><code class="name">var <span class="ident">PAIR_DIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.tlsph.PAIR_OFFDIAGCOEFF"><code class="name">var <span class="ident">PAIR_OFFDIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.tlsph.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.tlsph.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="region.ulsph"><code class="flex name class">
<span>class <span class="ident">ulsph</span></span>
</code></dt>
<dd>
<div class="desc"><p>SMD:ULSPH forcefield (updated Lagrangian)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ulsph(smd):
    &#34;&#34;&#34; SMD:ULSPH forcefield (updated Lagrangian) &#34;&#34;&#34;
    name = smd.name + struct(style=&#34;ulsph&#34;)
    description = smd.description + struct(style=&#34;SMD:ULSPH - updated Lagrangian for fluids - SPH-like&#34;)

    # style definition (LAMMPS code between triple &#34;&#34;&#34;)
    PAIR_DIAGCOEFF = &#34;&#34;&#34;
    # [comment] Pair diagonal coefficient ulsph
    pair_coeff      %d %d smd/ulsph *COMMON ${rho} ${c0} ${q1} ${Cp} 0 &amp;
                    *EOS_TAIT ${taitexponent} &amp;
                    *END
    &#34;&#34;&#34;
    PAIR_OFFDIAGCOEFF = &#34;&#34;&#34;
    # [comment] Off-diagonal pair coefficient (generic)
    pair_coeff      %d %d smd/hertz ${contact_stiffness}
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pizza.forcefield.water</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.ulsph.PAIR_DIAGCOEFF"><code class="name">var <span class="ident">PAIR_DIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.ulsph.PAIR_OFFDIAGCOEFF"><code class="name">var <span class="ident">PAIR_OFFDIAGCOEFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.ulsph.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.ulsph.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="region.water"><code class="flex name class">
<span>class <span class="ident">water</span></span>
<span>(</span><span>beadtype=1, userid=None, USER=forcefield (FF object) with 0 parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>water material (smd:ulsph): generic water model
water()
water(beadtype=index, userid="myfluid", USER=&hellip;)</p>
<p>override any propery with USER.parameter (set only the parameters you want to override)
USER.rho: density in kg/m3 (default=1000)
USER.c0: speed of the sound in m/s (default=10.0)
USER.q1: standard artificial viscosity linear coefficient (default=1.0)
USER.Cp: heat capacity of material &ndash; not used here (default=1.0)
USER.contact_scale: scaling coefficient for contact (default=1.5)
USER.contact_stiffness: contact stifness in Pa (default="2.5<em>${c0}^2</em>${rho}")</p>
<p>water forcefield:
water(beadtype=index, userid="myfluid")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class water(ulsph):
    &#34;&#34;&#34; water material (smd:ulsph): generic water model
            water()
            water(beadtype=index, userid=&#34;myfluid&#34;, USER=...)

            override any propery with USER.parameter (set only the parameters you want to override)
                USER.rho: density in kg/m3 (default=1000)
                USER.c0: speed of the sound in m/s (default=10.0)
                USER.q1: standard artificial viscosity linear coefficient (default=1.0)
                USER.Cp: heat capacity of material -- not used here (default=1.0)
                USER.contact_scale: scaling coefficient for contact (default=1.5)
                USER.contact_stiffness: contact stifness in Pa (default=&#34;2.5*${c0}^2*${rho}&#34;)
    &#34;&#34;&#34;
    name = ulsph.name + struct(material=&#34;water&#34;)
    description = ulsph.description + struct(material=&#34;water beads - SPH-like&#34;)
    userid = &#39;water&#39;
    version = 0.1

    # constructor (do not forgert to include the constuctor)
    def __init__(self, beadtype=1, userid=None, USER=parameterforcefield()):
        &#34;&#34;&#34; water forcefield:
            water(beadtype=index, userid=&#34;myfluid&#34;) &#34;&#34;&#34;
        if userid!=None: self.userid = userid
        self.beadtype = beadtype
        self.parameters = parameterforcefield(
            # water-water interactions
            rho = 1000,
            c0 = 10.0,
            q1 = 1.0,
            Cp = 1.0,
            taitexponent = 7,
            # hertz contacts
            contact_scale = 1.5,
            contact_stiffness = &#39;2.5*${c0}^2*${rho}&#39;
            ) + USER # update with user properties if any</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.forcefield.ulsph</li>
<li>pizza.forcefield.smd</li>
<li>pizza.forcefield.forcefield</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="region.water.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.water.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.water.userid"><code class="name">var <span class="ident">userid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="region.water.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#public-features">Public Features</a></li>
<li><a href="#classes-and-methods">Classes and Methods</a><ul>
<li><a href="#class-region">Class: region</a><ul>
<li><a href="#description">Description:</a></li>
<li><a href="#methods">Methods:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#examples">Examples</a></li>
<li><a href="#advanced-features">Advanced features</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#license">License</a></li>
<li><a href="#contact">Contact</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="region.cleanname" href="#region.cleanname">cleanname</a></code></li>
<li><code><a title="region.span" href="#region.span">span</a></code></li>
<li><code><a title="region.wrap" href="#region.wrap">wrap</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="region.AttrErrorDict" href="#region.AttrErrorDict">AttrErrorDict</a></code></h4>
</li>
<li>
<h4><code><a title="region.Block" href="#region.Block">Block</a></code></h4>
<ul class="">
<li><code><a title="region.Block.volume" href="#region.Block.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.Collection" href="#region.Collection">Collection</a></code></h4>
<ul class="two-column">
<li><code><a title="region.Collection.beadtype" href="#region.Collection.beadtype">beadtype</a></code></li>
<li><code><a title="region.Collection.creategroup" href="#region.Collection.creategroup">creategroup</a></code></li>
<li><code><a title="region.Collection.flags" href="#region.Collection.flags">flags</a></code></li>
<li><code><a title="region.Collection.get" href="#region.Collection.get">get</a></code></li>
<li><code><a title="region.Collection.group" href="#region.Collection.group">group</a></code></li>
<li><code><a title="region.Collection.hasgroup" href="#region.Collection.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.Collection.list" href="#region.Collection.list">list</a></code></li>
<li><code><a title="region.Collection.removegroup" href="#region.Collection.removegroup">removegroup</a></code></li>
<li><code><a title="region.Collection.script" href="#region.Collection.script">script</a></code></li>
<li><code><a title="region.Collection.shortflags" href="#region.Collection.shortflags">shortflags</a></code></li>
<li><code><a title="region.Collection.update" href="#region.Collection.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.Cone" href="#region.Cone">Cone</a></code></h4>
<ul class="">
<li><code><a title="region.Cone.volume" href="#region.Cone.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.Cylinder" href="#region.Cylinder">Cylinder</a></code></h4>
<ul class="">
<li><code><a title="region.Cylinder.volume" href="#region.Cylinder.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.Ellipsoid" href="#region.Ellipsoid">Ellipsoid</a></code></h4>
<ul class="">
<li><code><a title="region.Ellipsoid.volume" href="#region.Ellipsoid.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.Evalgeometry" href="#region.Evalgeometry">Evalgeometry</a></code></h4>
</li>
<li>
<h4><code><a title="region.Intersect" href="#region.Intersect">Intersect</a></code></h4>
</li>
<li>
<h4><code><a title="region.LammpsCollectionGroup" href="#region.LammpsCollectionGroup">LammpsCollectionGroup</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsCollectionGroup.DEFINITIONS" href="#region.LammpsCollectionGroup.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsCollectionGroup.SECTIONS" href="#region.LammpsCollectionGroup.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsCollectionGroup.TEMPLATE" href="#region.LammpsCollectionGroup.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsCollectionGroup.description" href="#region.LammpsCollectionGroup.description">description</a></code></li>
<li><code><a title="region.LammpsCollectionGroup.name" href="#region.LammpsCollectionGroup.name">name</a></code></li>
<li><code><a title="region.LammpsCollectionGroup.position" href="#region.LammpsCollectionGroup.position">position</a></code></li>
<li><code><a title="region.LammpsCollectionGroup.role" href="#region.LammpsCollectionGroup.role">role</a></code></li>
<li><code><a title="region.LammpsCollectionGroup.userid" href="#region.LammpsCollectionGroup.userid">userid</a></code></li>
<li><code><a title="region.LammpsCollectionGroup.verbose" href="#region.LammpsCollectionGroup.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsCollectionGroup.version" href="#region.LammpsCollectionGroup.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsCreate" href="#region.LammpsCreate">LammpsCreate</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsCreate.DEFINITIONS" href="#region.LammpsCreate.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsCreate.SECTIONS" href="#region.LammpsCreate.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsCreate.TEMPLATE" href="#region.LammpsCreate.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsCreate.description" href="#region.LammpsCreate.description">description</a></code></li>
<li><code><a title="region.LammpsCreate.name" href="#region.LammpsCreate.name">name</a></code></li>
<li><code><a title="region.LammpsCreate.position" href="#region.LammpsCreate.position">position</a></code></li>
<li><code><a title="region.LammpsCreate.role" href="#region.LammpsCreate.role">role</a></code></li>
<li><code><a title="region.LammpsCreate.userid" href="#region.LammpsCreate.userid">userid</a></code></li>
<li><code><a title="region.LammpsCreate.verbose" href="#region.LammpsCreate.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsCreate.version" href="#region.LammpsCreate.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsFooter" href="#region.LammpsFooter">LammpsFooter</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsFooter.DEFINITIONS" href="#region.LammpsFooter.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsFooter.SECTIONS" href="#region.LammpsFooter.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsFooter.TEMPLATE" href="#region.LammpsFooter.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsFooter.description" href="#region.LammpsFooter.description">description</a></code></li>
<li><code><a title="region.LammpsFooter.name" href="#region.LammpsFooter.name">name</a></code></li>
<li><code><a title="region.LammpsFooter.position" href="#region.LammpsFooter.position">position</a></code></li>
<li><code><a title="region.LammpsFooter.role" href="#region.LammpsFooter.role">role</a></code></li>
<li><code><a title="region.LammpsFooter.userid" href="#region.LammpsFooter.userid">userid</a></code></li>
<li><code><a title="region.LammpsFooter.verbose" href="#region.LammpsFooter.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsFooter.version" href="#region.LammpsFooter.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsFooterPreview" href="#region.LammpsFooterPreview">LammpsFooterPreview</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsFooterPreview.DEFINITIONS" href="#region.LammpsFooterPreview.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsFooterPreview.SECTIONS" href="#region.LammpsFooterPreview.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsFooterPreview.TEMPLATE" href="#region.LammpsFooterPreview.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsFooterPreview.description" href="#region.LammpsFooterPreview.description">description</a></code></li>
<li><code><a title="region.LammpsFooterPreview.name" href="#region.LammpsFooterPreview.name">name</a></code></li>
<li><code><a title="region.LammpsFooterPreview.position" href="#region.LammpsFooterPreview.position">position</a></code></li>
<li><code><a title="region.LammpsFooterPreview.role" href="#region.LammpsFooterPreview.role">role</a></code></li>
<li><code><a title="region.LammpsFooterPreview.userid" href="#region.LammpsFooterPreview.userid">userid</a></code></li>
<li><code><a title="region.LammpsFooterPreview.verbose" href="#region.LammpsFooterPreview.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsFooterPreview.version" href="#region.LammpsFooterPreview.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsGeneric" href="#region.LammpsGeneric">LammpsGeneric</a></code></h4>
<ul class="">
<li><code><a title="region.LammpsGeneric.do" href="#region.LammpsGeneric.do">do</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsGroup" href="#region.LammpsGroup">LammpsGroup</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsGroup.DEFINITIONS" href="#region.LammpsGroup.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsGroup.SECTIONS" href="#region.LammpsGroup.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsGroup.TEMPLATE" href="#region.LammpsGroup.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsGroup.description" href="#region.LammpsGroup.description">description</a></code></li>
<li><code><a title="region.LammpsGroup.name" href="#region.LammpsGroup.name">name</a></code></li>
<li><code><a title="region.LammpsGroup.position" href="#region.LammpsGroup.position">position</a></code></li>
<li><code><a title="region.LammpsGroup.role" href="#region.LammpsGroup.role">role</a></code></li>
<li><code><a title="region.LammpsGroup.userid" href="#region.LammpsGroup.userid">userid</a></code></li>
<li><code><a title="region.LammpsGroup.verbose" href="#region.LammpsGroup.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsGroup.version" href="#region.LammpsGroup.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsHeader" href="#region.LammpsHeader">LammpsHeader</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsHeader.DEFINITIONS" href="#region.LammpsHeader.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsHeader.SECTIONS" href="#region.LammpsHeader.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsHeader.TEMPLATE" href="#region.LammpsHeader.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsHeader.description" href="#region.LammpsHeader.description">description</a></code></li>
<li><code><a title="region.LammpsHeader.name" href="#region.LammpsHeader.name">name</a></code></li>
<li><code><a title="region.LammpsHeader.position" href="#region.LammpsHeader.position">position</a></code></li>
<li><code><a title="region.LammpsHeader.role" href="#region.LammpsHeader.role">role</a></code></li>
<li><code><a title="region.LammpsHeader.userid" href="#region.LammpsHeader.userid">userid</a></code></li>
<li><code><a title="region.LammpsHeader.verbose" href="#region.LammpsHeader.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsHeader.version" href="#region.LammpsHeader.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsHeaderBox" href="#region.LammpsHeaderBox">LammpsHeaderBox</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsHeaderBox.DEFINITIONS" href="#region.LammpsHeaderBox.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsHeaderBox.SECTIONS" href="#region.LammpsHeaderBox.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsHeaderBox.TEMPLATE" href="#region.LammpsHeaderBox.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsHeaderBox.description" href="#region.LammpsHeaderBox.description">description</a></code></li>
<li><code><a title="region.LammpsHeaderBox.name" href="#region.LammpsHeaderBox.name">name</a></code></li>
<li><code><a title="region.LammpsHeaderBox.position" href="#region.LammpsHeaderBox.position">position</a></code></li>
<li><code><a title="region.LammpsHeaderBox.role" href="#region.LammpsHeaderBox.role">role</a></code></li>
<li><code><a title="region.LammpsHeaderBox.userid" href="#region.LammpsHeaderBox.userid">userid</a></code></li>
<li><code><a title="region.LammpsHeaderBox.verbose" href="#region.LammpsHeaderBox.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsHeaderBox.version" href="#region.LammpsHeaderBox.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsHeaderInit" href="#region.LammpsHeaderInit">LammpsHeaderInit</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsHeaderInit.DEFINITIONS" href="#region.LammpsHeaderInit.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsHeaderInit.SECTIONS" href="#region.LammpsHeaderInit.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsHeaderInit.description" href="#region.LammpsHeaderInit.description">description</a></code></li>
<li><code><a title="region.LammpsHeaderInit.generate_template" href="#region.LammpsHeaderInit.generate_template">generate_template</a></code></li>
<li><code><a title="region.LammpsHeaderInit.name" href="#region.LammpsHeaderInit.name">name</a></code></li>
<li><code><a title="region.LammpsHeaderInit.position" href="#region.LammpsHeaderInit.position">position</a></code></li>
<li><code><a title="region.LammpsHeaderInit.role" href="#region.LammpsHeaderInit.role">role</a></code></li>
<li><code><a title="region.LammpsHeaderInit.userid" href="#region.LammpsHeaderInit.userid">userid</a></code></li>
<li><code><a title="region.LammpsHeaderInit.verbose" href="#region.LammpsHeaderInit.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsHeaderInit.version" href="#region.LammpsHeaderInit.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsHeaderLattice" href="#region.LammpsHeaderLattice">LammpsHeaderLattice</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsHeaderLattice.DEFINITIONS" href="#region.LammpsHeaderLattice.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsHeaderLattice.SECTIONS" href="#region.LammpsHeaderLattice.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsHeaderLattice.description" href="#region.LammpsHeaderLattice.description">description</a></code></li>
<li><code><a title="region.LammpsHeaderLattice.generate_template" href="#region.LammpsHeaderLattice.generate_template">generate_template</a></code></li>
<li><code><a title="region.LammpsHeaderLattice.name" href="#region.LammpsHeaderLattice.name">name</a></code></li>
<li><code><a title="region.LammpsHeaderLattice.position" href="#region.LammpsHeaderLattice.position">position</a></code></li>
<li><code><a title="region.LammpsHeaderLattice.role" href="#region.LammpsHeaderLattice.role">role</a></code></li>
<li><code><a title="region.LammpsHeaderLattice.userid" href="#region.LammpsHeaderLattice.userid">userid</a></code></li>
<li><code><a title="region.LammpsHeaderLattice.verbose" href="#region.LammpsHeaderLattice.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsHeaderLattice.version" href="#region.LammpsHeaderLattice.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsHeaderMass" href="#region.LammpsHeaderMass">LammpsHeaderMass</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsHeaderMass.DEFINITIONS" href="#region.LammpsHeaderMass.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsHeaderMass.SECTIONS" href="#region.LammpsHeaderMass.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsHeaderMass.description" href="#region.LammpsHeaderMass.description">description</a></code></li>
<li><code><a title="region.LammpsHeaderMass.generate_template" href="#region.LammpsHeaderMass.generate_template">generate_template</a></code></li>
<li><code><a title="region.LammpsHeaderMass.name" href="#region.LammpsHeaderMass.name">name</a></code></li>
<li><code><a title="region.LammpsHeaderMass.position" href="#region.LammpsHeaderMass.position">position</a></code></li>
<li><code><a title="region.LammpsHeaderMass.role" href="#region.LammpsHeaderMass.role">role</a></code></li>
<li><code><a title="region.LammpsHeaderMass.userid" href="#region.LammpsHeaderMass.userid">userid</a></code></li>
<li><code><a title="region.LammpsHeaderMass.verbose" href="#region.LammpsHeaderMass.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsHeaderMass.version" href="#region.LammpsHeaderMass.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsMove" href="#region.LammpsMove">LammpsMove</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsMove.DEFINITIONS" href="#region.LammpsMove.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsMove.SECTIONS" href="#region.LammpsMove.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsMove.TEMPLATE" href="#region.LammpsMove.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsMove.description" href="#region.LammpsMove.description">description</a></code></li>
<li><code><a title="region.LammpsMove.name" href="#region.LammpsMove.name">name</a></code></li>
<li><code><a title="region.LammpsMove.position" href="#region.LammpsMove.position">position</a></code></li>
<li><code><a title="region.LammpsMove.role" href="#region.LammpsMove.role">role</a></code></li>
<li><code><a title="region.LammpsMove.userid" href="#region.LammpsMove.userid">userid</a></code></li>
<li><code><a title="region.LammpsMove.verbose" href="#region.LammpsMove.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsMove.version" href="#region.LammpsMove.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsRegion" href="#region.LammpsRegion">LammpsRegion</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsRegion.DEFINITIONS" href="#region.LammpsRegion.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsRegion.SECTIONS" href="#region.LammpsRegion.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsRegion.TEMPLATE" href="#region.LammpsRegion.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsRegion.description" href="#region.LammpsRegion.description">description</a></code></li>
<li><code><a title="region.LammpsRegion.name" href="#region.LammpsRegion.name">name</a></code></li>
<li><code><a title="region.LammpsRegion.position" href="#region.LammpsRegion.position">position</a></code></li>
<li><code><a title="region.LammpsRegion.role" href="#region.LammpsRegion.role">role</a></code></li>
<li><code><a title="region.LammpsRegion.userid" href="#region.LammpsRegion.userid">userid</a></code></li>
<li><code><a title="region.LammpsRegion.verbose" href="#region.LammpsRegion.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsRegion.version" href="#region.LammpsRegion.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsSetGroup" href="#region.LammpsSetGroup">LammpsSetGroup</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsSetGroup.DEFINITIONS" href="#region.LammpsSetGroup.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsSetGroup.SECTIONS" href="#region.LammpsSetGroup.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsSetGroup.TEMPLATE" href="#region.LammpsSetGroup.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsSetGroup.description" href="#region.LammpsSetGroup.description">description</a></code></li>
<li><code><a title="region.LammpsSetGroup.name" href="#region.LammpsSetGroup.name">name</a></code></li>
<li><code><a title="region.LammpsSetGroup.position" href="#region.LammpsSetGroup.position">position</a></code></li>
<li><code><a title="region.LammpsSetGroup.role" href="#region.LammpsSetGroup.role">role</a></code></li>
<li><code><a title="region.LammpsSetGroup.userid" href="#region.LammpsSetGroup.userid">userid</a></code></li>
<li><code><a title="region.LammpsSetGroup.verbose" href="#region.LammpsSetGroup.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsSetGroup.version" href="#region.LammpsSetGroup.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsSpacefilling" href="#region.LammpsSpacefilling">LammpsSpacefilling</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsSpacefilling.DEFINITIONS" href="#region.LammpsSpacefilling.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsSpacefilling.SECTIONS" href="#region.LammpsSpacefilling.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsSpacefilling.TEMPLATE" href="#region.LammpsSpacefilling.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsSpacefilling.description" href="#region.LammpsSpacefilling.description">description</a></code></li>
<li><code><a title="region.LammpsSpacefilling.name" href="#region.LammpsSpacefilling.name">name</a></code></li>
<li><code><a title="region.LammpsSpacefilling.position" href="#region.LammpsSpacefilling.position">position</a></code></li>
<li><code><a title="region.LammpsSpacefilling.role" href="#region.LammpsSpacefilling.role">role</a></code></li>
<li><code><a title="region.LammpsSpacefilling.userid" href="#region.LammpsSpacefilling.userid">userid</a></code></li>
<li><code><a title="region.LammpsSpacefilling.verbose" href="#region.LammpsSpacefilling.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsSpacefilling.version" href="#region.LammpsSpacefilling.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.LammpsVariables" href="#region.LammpsVariables">LammpsVariables</a></code></h4>
<ul class="two-column">
<li><code><a title="region.LammpsVariables.DEFINITIONS" href="#region.LammpsVariables.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.LammpsVariables.SECTIONS" href="#region.LammpsVariables.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.LammpsVariables.TEMPLATE" href="#region.LammpsVariables.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.LammpsVariables.description" href="#region.LammpsVariables.description">description</a></code></li>
<li><code><a title="region.LammpsVariables.name" href="#region.LammpsVariables.name">name</a></code></li>
<li><code><a title="region.LammpsVariables.position" href="#region.LammpsVariables.position">position</a></code></li>
<li><code><a title="region.LammpsVariables.role" href="#region.LammpsVariables.role">role</a></code></li>
<li><code><a title="region.LammpsVariables.userid" href="#region.LammpsVariables.userid">userid</a></code></li>
<li><code><a title="region.LammpsVariables.verbose" href="#region.LammpsVariables.verbose">verbose</a></code></li>
<li><code><a title="region.LammpsVariables.version" href="#region.LammpsVariables.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.Plane" href="#region.Plane">Plane</a></code></h4>
<ul class="">
<li><code><a title="region.Plane.volume" href="#region.Plane.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.Prism" href="#region.Prism">Prism</a></code></h4>
<ul class="">
<li><code><a title="region.Prism.volume" href="#region.Prism.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.SafeEvaluator" href="#region.SafeEvaluator">SafeEvaluator</a></code></h4>
<ul class="two-column">
<li><code><a title="region.SafeEvaluator.evaluate" href="#region.SafeEvaluator.evaluate">evaluate</a></code></li>
<li><code><a title="region.SafeEvaluator.generic_visit" href="#region.SafeEvaluator.generic_visit">generic_visit</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_Attribute" href="#region.SafeEvaluator.visit_Attribute">visit_Attribute</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_BinOp" href="#region.SafeEvaluator.visit_BinOp">visit_BinOp</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_Call" href="#region.SafeEvaluator.visit_Call">visit_Call</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_Constant" href="#region.SafeEvaluator.visit_Constant">visit_Constant</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_ExtSlice" href="#region.SafeEvaluator.visit_ExtSlice">visit_ExtSlice</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_Index" href="#region.SafeEvaluator.visit_Index">visit_Index</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_List" href="#region.SafeEvaluator.visit_List">visit_List</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_Name" href="#region.SafeEvaluator.visit_Name">visit_Name</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_Slice" href="#region.SafeEvaluator.visit_Slice">visit_Slice</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_Subscript" href="#region.SafeEvaluator.visit_Subscript">visit_Subscript</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_Tuple" href="#region.SafeEvaluator.visit_Tuple">visit_Tuple</a></code></li>
<li><code><a title="region.SafeEvaluator.visit_UnaryOp" href="#region.SafeEvaluator.visit_UnaryOp">visit_UnaryOp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.Sphere" href="#region.Sphere">Sphere</a></code></h4>
<ul class="">
<li><code><a title="region.Sphere.volume" href="#region.Sphere.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.Union" href="#region.Union">Union</a></code></h4>
</li>
<li>
<h4><code><a title="region.coregeometry" href="#region.coregeometry">coregeometry</a></code></h4>
<ul class="two-column">
<li><code><a title="region.coregeometry.VARIABLES" href="#region.coregeometry.VARIABLES">VARIABLES</a></code></li>
<li><code><a title="region.coregeometry.copy" href="#region.coregeometry.copy">copy</a></code></li>
<li><code><a title="region.coregeometry.creategroup" href="#region.coregeometry.creategroup">creategroup</a></code></li>
<li><code><a title="region.coregeometry.createmove" href="#region.coregeometry.createmove">createmove</a></code></li>
<li><code><a title="region.coregeometry.do" href="#region.coregeometry.do">do</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargs" href="#region.coregeometry.fixmoveargs">fixmoveargs</a></code></li>
<li><code><a title="region.coregeometry.fixmoveargvalidator" href="#region.coregeometry.fixmoveargvalidator">fixmoveargvalidator</a></code></li>
<li><code><a title="region.coregeometry.flags" href="#region.coregeometry.flags">flags</a></code></li>
<li><code><a title="region.coregeometry.geometry" href="#region.coregeometry.geometry">geometry</a></code></li>
<li><code><a title="region.coregeometry.get_fixmovesyntax" href="#region.coregeometry.get_fixmovesyntax">get_fixmovesyntax</a></code></li>
<li><code><a title="region.coregeometry.hascreate" href="#region.coregeometry.hascreate">hascreate</a></code></li>
<li><code><a title="region.coregeometry.hasgroup" href="#region.coregeometry.hasgroup">hasgroup</a></code></li>
<li><code><a title="region.coregeometry.hasmove" href="#region.coregeometry.hasmove">hasmove</a></code></li>
<li><code><a title="region.coregeometry.hasregion" href="#region.coregeometry.hasregion">hasregion</a></code></li>
<li><code><a title="region.coregeometry.hassetgroup" href="#region.coregeometry.hassetgroup">hassetgroup</a></code></li>
<li><code><a title="region.coregeometry.hasvariables" href="#region.coregeometry.hasvariables">hasvariables</a></code></li>
<li><code><a title="region.coregeometry.isspacefilled" href="#region.coregeometry.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.coregeometry.movearg" href="#region.coregeometry.movearg">movearg</a></code></li>
<li><code><a title="region.coregeometry.natoms" href="#region.coregeometry.natoms">natoms</a></code></li>
<li><code><a title="region.coregeometry.openarg" href="#region.coregeometry.openarg">openarg</a></code></li>
<li><code><a title="region.coregeometry.regiondetails" href="#region.coregeometry.regiondetails">regiondetails</a></code></li>
<li><code><a title="region.coregeometry.removegroup" href="#region.coregeometry.removegroup">removegroup</a></code></li>
<li><code><a title="region.coregeometry.removemove" href="#region.coregeometry.removemove">removemove</a></code></li>
<li><code><a title="region.coregeometry.rotatearg" href="#region.coregeometry.rotatearg">rotatearg</a></code></li>
<li><code><a title="region.coregeometry.script" href="#region.coregeometry.script">script</a></code></li>
<li><code><a title="region.coregeometry.scriptobject" href="#region.coregeometry.scriptobject">scriptobject</a></code></li>
<li><code><a title="region.coregeometry.setgroup" href="#region.coregeometry.setgroup">setgroup</a></code></li>
<li><code><a title="region.coregeometry.shortflags" href="#region.coregeometry.shortflags">shortflags</a></code></li>
<li><code><a title="region.coregeometry.sidearg" href="#region.coregeometry.sidearg">sidearg</a></code></li>
<li><code><a title="region.coregeometry.unitsarg" href="#region.coregeometry.unitsarg">unitsarg</a></code></li>
<li><code><a title="region.coregeometry.update" href="#region.coregeometry.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.emulsion" href="#region.emulsion">emulsion</a></code></h4>
<ul class="two-column">
<li><code><a title="region.emulsion.accepted" href="#region.emulsion.accepted">accepted</a></code></li>
<li><code><a title="region.emulsion.dist" href="#region.emulsion.dist">dist</a></code></li>
<li><code><a title="region.emulsion.insertion" href="#region.emulsion.insertion">insertion</a></code></li>
<li><code><a title="region.emulsion.insertone" href="#region.emulsion.insertone">insertone</a></code></li>
<li><code><a title="region.emulsion.rand" href="#region.emulsion.rand">rand</a></code></li>
<li><code><a title="region.emulsion.setbeadtype" href="#region.emulsion.setbeadtype">setbeadtype</a></code></li>
<li><code><a title="region.emulsion.walldist" href="#region.emulsion.walldist">walldist</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.forcefield" href="#region.forcefield">forcefield</a></code></h4>
<ul class="two-column">
<li><code><a title="region.forcefield.beadtype" href="#region.forcefield.beadtype">beadtype</a></code></li>
<li><code><a title="region.forcefield.description" href="#region.forcefield.description">description</a></code></li>
<li><code><a title="region.forcefield.getallattributes" href="#region.forcefield.getallattributes">getallattributes</a></code></li>
<li><code><a title="region.forcefield.name" href="#region.forcefield.name">name</a></code></li>
<li><code><a title="region.forcefield.pair_diagcoeff" href="#region.forcefield.pair_diagcoeff">pair_diagcoeff</a></code></li>
<li><code><a title="region.forcefield.pair_offdiagcoeff" href="#region.forcefield.pair_offdiagcoeff">pair_offdiagcoeff</a></code></li>
<li><code><a title="region.forcefield.pair_style" href="#region.forcefield.pair_style">pair_style</a></code></li>
<li><code><a title="region.forcefield.parameters" href="#region.forcefield.parameters">parameters</a></code></li>
<li><code><a title="region.forcefield.printheader" href="#region.forcefield.printheader">printheader</a></code></li>
<li><code><a title="region.forcefield.userid" href="#region.forcefield.userid">userid</a></code></li>
<li><code><a title="region.forcefield.version" href="#region.forcefield.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.headersRegiondata" href="#region.headersRegiondata">headersRegiondata</a></code></h4>
</li>
<li>
<h4><code><a title="region.none" href="#region.none">none</a></code></h4>
<ul class="">
<li><code><a title="region.none.PAIR_DIAGCOEFF" href="#region.none.PAIR_DIAGCOEFF">PAIR_DIAGCOEFF</a></code></li>
<li><code><a title="region.none.PAIR_OFFDIAGCOEFF" href="#region.none.PAIR_OFFDIAGCOEFF">PAIR_OFFDIAGCOEFF</a></code></li>
<li><code><a title="region.none.description" href="#region.none.description">description</a></code></li>
<li><code><a title="region.none.name" href="#region.none.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.param" href="#region.param">param</a></code></h4>
<ul class="">
<li><code><a title="region.param.escape" href="#region.param.escape">escape</a></code></li>
<li><code><a title="region.param.eval" href="#region.param.eval">eval</a></code></li>
<li><code><a title="region.param.formateval" href="#region.param.formateval">formateval</a></code></li>
<li><code><a title="region.param.protect" href="#region.param.protect">protect</a></code></li>
<li><code><a title="region.param.replace_matrix_shorthand" href="#region.param.replace_matrix_shorthand">replace_matrix_shorthand</a></code></li>
<li><code><a title="region.param.safe_fstring" href="#region.param.safe_fstring">safe_fstring</a></code></li>
<li><code><a title="region.param.tostatic" href="#region.param.tostatic">tostatic</a></code></li>
<li><code><a title="region.param.tostruct" href="#region.param.tostruct">tostruct</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.paramauto" href="#region.paramauto">paramauto</a></code></h4>
</li>
<li>
<h4><code><a title="region.parameterforcefield" href="#region.parameterforcefield">parameterforcefield</a></code></h4>
</li>
<li>
<h4><code><a title="region.pipescript" href="#region.pipescript">pipescript</a></code></h4>
<ul class="">
<li><code><a title="region.pipescript.USER" href="#region.pipescript.USER">USER</a></code></li>
<li><code><a title="region.pipescript.clear" href="#region.pipescript.clear">clear</a></code></li>
<li><code><a title="region.pipescript.do" href="#region.pipescript.do">do</a></code></li>
<li><code><a title="region.pipescript.do_legacy" href="#region.pipescript.do_legacy">do_legacy</a></code></li>
<li><code><a title="region.pipescript.dscript" href="#region.pipescript.dscript">dscript</a></code></li>
<li><code><a title="region.pipescript.generate_report" href="#region.pipescript.generate_report">generate_report</a></code></li>
<li><code><a title="region.pipescript.getUSER" href="#region.pipescript.getUSER">getUSER</a></code></li>
<li><code><a title="region.pipescript.header" href="#region.pipescript.header">header</a></code></li>
<li><code><a title="region.pipescript.join" href="#region.pipescript.join">join</a></code></li>
<li><code><a title="region.pipescript.list_multiple_values" href="#region.pipescript.list_multiple_values">list_multiple_values</a></code></li>
<li><code><a title="region.pipescript.list_values" href="#region.pipescript.list_values">list_values</a></code></li>
<li><code><a title="region.pipescript.n" href="#region.pipescript.n">n</a></code></li>
<li><code><a title="region.pipescript.nrun" href="#region.pipescript.nrun">nrun</a></code></li>
<li><code><a title="region.pipescript.plot_multiple_value_distributions" href="#region.pipescript.plot_multiple_value_distributions">plot_multiple_value_distributions</a></code></li>
<li><code><a title="region.pipescript.rename" href="#region.pipescript.rename">rename</a></code></li>
<li><code><a title="region.pipescript.script" href="#region.pipescript.script">script</a></code></li>
<li><code><a title="region.pipescript.scripts" href="#region.pipescript.scripts">scripts</a></code></li>
<li><code><a title="region.pipescript.setUSER" href="#region.pipescript.setUSER">setUSER</a></code></li>
<li><code><a title="region.pipescript.write" href="#region.pipescript.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.pstr" href="#region.pstr">pstr</a></code></h4>
<ul class="">
<li><code><a title="region.pstr.eval" href="#region.pstr.eval">eval</a></code></li>
<li><code><a title="region.pstr.topath" href="#region.pstr.topath">topath</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.region" href="#region.region">region</a></code></h4>
<ul class="">
<li><code><a title="region.region.beadtypes" href="#region.region.beadtypes">beadtypes</a></code></li>
<li><code><a title="region.region.block" href="#region.region.block">block</a></code></li>
<li><code><a title="region.region.collection" href="#region.region.collection">collection</a></code></li>
<li><code><a title="region.region.cone" href="#region.region.cone">cone</a></code></li>
<li><code><a title="region.region.count" href="#region.region.count">count</a></code></li>
<li><code><a title="region.region.cylinder" href="#region.region.cylinder">cylinder</a></code></li>
<li><code><a title="region.region.delete" href="#region.region.delete">delete</a></code></li>
<li><code><a title="region.region.do" href="#region.region.do">do</a></code></li>
<li><code><a title="region.region.dolive" href="#region.region.dolive">dolive</a></code></li>
<li><code><a title="region.region.ellipsoid" href="#region.region.ellipsoid">ellipsoid</a></code></li>
<li><code><a title="region.region.eval" href="#region.region.eval">eval</a></code></li>
<li><code><a title="region.region.geometry" href="#region.region.geometry">geometry</a></code></li>
<li><code><a title="region.region.get" href="#region.region.get">get</a></code></li>
<li><code><a title="region.region.group" href="#region.region.group">group</a></code></li>
<li><code><a title="region.region.hasattr" href="#region.region.hasattr">hasattr</a></code></li>
<li><code><a title="region.region.intersect" href="#region.region.intersect">intersect</a></code></li>
<li><code><a title="region.region.isspacefilled" href="#region.region.isspacefilled">isspacefilled</a></code></li>
<li><code><a title="region.region.list" href="#region.region.list">list</a></code></li>
<li><code><a title="region.region.names" href="#region.region.names">names</a></code></li>
<li><code><a title="region.region.natoms" href="#region.region.natoms">natoms</a></code></li>
<li><code><a title="region.region.nbeads" href="#region.region.nbeads">nbeads</a></code></li>
<li><code><a title="region.region.pipescript" href="#region.region.pipescript">pipescript</a></code></li>
<li><code><a title="region.region.plane" href="#region.region.plane">plane</a></code></li>
<li><code><a title="region.region.prism" href="#region.region.prism">prism</a></code></li>
<li><code><a title="region.region.pscriptHeaders" href="#region.region.pscriptHeaders">pscriptHeaders</a></code></li>
<li><code><a title="region.region.scale_and_translate" href="#region.region.scale_and_translate">scale_and_translate</a></code></li>
<li><code><a title="region.region.scatter" href="#region.region.scatter">scatter</a></code></li>
<li><code><a title="region.region.script" href="#region.region.script">script</a></code></li>
<li><code><a title="region.region.scriptHeaders" href="#region.region.scriptHeaders">scriptHeaders</a></code></li>
<li><code><a title="region.region.set" href="#region.region.set">set</a></code></li>
<li><code><a title="region.region.spacefillingbeadtype" href="#region.region.spacefillingbeadtype">spacefillingbeadtype</a></code></li>
<li><code><a title="region.region.sphere" href="#region.region.sphere">sphere</a></code></li>
<li><code><a title="region.region.union" href="#region.region.union">union</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.regioncollection" href="#region.regioncollection">regioncollection</a></code></h4>
</li>
<li>
<h4><code><a title="region.regiondata" href="#region.regiondata">regiondata</a></code></h4>
<ul class="">
<li><code><a title="region.regiondata.generatorforlammps" href="#region.regiondata.generatorforlammps">generatorforlammps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.rigidwall" href="#region.rigidwall">rigidwall</a></code></h4>
<ul class="">
<li><code><a title="region.rigidwall.description" href="#region.rigidwall.description">description</a></code></li>
<li><code><a title="region.rigidwall.name" href="#region.rigidwall.name">name</a></code></li>
<li><code><a title="region.rigidwall.userid" href="#region.rigidwall.userid">userid</a></code></li>
<li><code><a title="region.rigidwall.version" href="#region.rigidwall.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.saltTLSPH" href="#region.saltTLSPH">saltTLSPH</a></code></h4>
<ul class="">
<li><code><a title="region.saltTLSPH.description" href="#region.saltTLSPH.description">description</a></code></li>
<li><code><a title="region.saltTLSPH.name" href="#region.saltTLSPH.name">name</a></code></li>
<li><code><a title="region.saltTLSPH.userid" href="#region.saltTLSPH.userid">userid</a></code></li>
<li><code><a title="region.saltTLSPH.version" href="#region.saltTLSPH.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.scatter" href="#region.scatter">scatter</a></code></h4>
<ul class="">
<li><code><a title="region.scatter.n" href="#region.scatter.n">n</a></code></li>
<li><code><a title="region.scatter.pairdist" href="#region.scatter.pairdist">pairdist</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.script" href="#region.script">script</a></code></h4>
<ul class="two-column">
<li><code><a title="region.script.DEFINITIONS" href="#region.script.DEFINITIONS">DEFINITIONS</a></code></li>
<li><code><a title="region.script.SECTIONS" href="#region.script.SECTIONS">SECTIONS</a></code></li>
<li><code><a title="region.script.TEMPLATE" href="#region.script.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="region.script.description" href="#region.script.description">description</a></code></li>
<li><code><a title="region.script.detect_variables" href="#region.script.detect_variables">detect_variables</a></code></li>
<li><code><a title="region.script.do" href="#region.script.do">do</a></code></li>
<li><code><a title="region.script.email" href="#region.script.email">email</a></code></li>
<li><code><a title="region.script.getallattributes" href="#region.script.getallattributes">getallattributes</a></code></li>
<li><code><a title="region.script.header" href="#region.script.header">header</a></code></li>
<li><code><a title="region.script.license" href="#region.script.license">license</a></code></li>
<li><code><a title="region.script.metadata" href="#region.script.metadata">metadata</a></code></li>
<li><code><a title="region.script.name" href="#region.script.name">name</a></code></li>
<li><code><a title="region.script.position" href="#region.script.position">position</a></code></li>
<li><code><a title="region.script.printheader" href="#region.script.printheader">printheader</a></code></li>
<li><code><a title="region.script.role" href="#region.script.role">role</a></code></li>
<li><code><a title="region.script.section" href="#region.script.section">section</a></code></li>
<li><code><a title="region.script.tmpwrite" href="#region.script.tmpwrite">tmpwrite</a></code></li>
<li><code><a title="region.script.type" href="#region.script.type">type</a></code></li>
<li><code><a title="region.script.userid" href="#region.script.userid">userid</a></code></li>
<li><code><a title="region.script.verbose" href="#region.script.verbose">verbose</a></code></li>
<li><code><a title="region.script.version" href="#region.script.version">version</a></code></li>
<li><code><a title="region.script.write" href="#region.script.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.scriptdata" href="#region.scriptdata">scriptdata</a></code></h4>
</li>
<li>
<h4><code><a title="region.scriptobject" href="#region.scriptobject">scriptobject</a></code></h4>
</li>
<li>
<h4><code><a title="region.smd" href="#region.smd">smd</a></code></h4>
<ul class="">
<li><code><a title="region.smd.PAIR_STYLE" href="#region.smd.PAIR_STYLE">PAIR_STYLE</a></code></li>
<li><code><a title="region.smd.description" href="#region.smd.description">description</a></code></li>
<li><code><a title="region.smd.name" href="#region.smd.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.solidfood" href="#region.solidfood">solidfood</a></code></h4>
<ul class="">
<li><code><a title="region.solidfood.description" href="#region.solidfood.description">description</a></code></li>
<li><code><a title="region.solidfood.name" href="#region.solidfood.name">name</a></code></li>
<li><code><a title="region.solidfood.userid" href="#region.solidfood.userid">userid</a></code></li>
<li><code><a title="region.solidfood.version" href="#region.solidfood.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.struct" href="#region.struct">struct</a></code></h4>
<ul class="two-column">
<li><code><a title="region.struct.check" href="#region.struct.check">check</a></code></li>
<li><code><a title="region.struct.clear" href="#region.struct.clear">clear</a></code></li>
<li><code><a title="region.struct.dict2struct" href="#region.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="region.struct.disp" href="#region.struct.disp">disp</a></code></li>
<li><code><a title="region.struct.dispmax" href="#region.struct.dispmax">dispmax</a></code></li>
<li><code><a title="region.struct.format" href="#region.struct.format">format</a></code></li>
<li><code><a title="region.struct.format_array" href="#region.struct.format_array">format_array</a></code></li>
<li><code><a title="region.struct.format_legacy" href="#region.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="region.struct.fromkeys" href="#region.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="region.struct.fromkeysvalues" href="#region.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="region.struct.generator" href="#region.struct.generator">generator</a></code></li>
<li><code><a title="region.struct.getattr" href="#region.struct.getattr">getattr</a></code></li>
<li><code><a title="region.struct.hasattr" href="#region.struct.hasattr">hasattr</a></code></li>
<li><code><a title="region.struct.isdefined" href="#region.struct.isdefined">isdefined</a></code></li>
<li><code><a title="region.struct.isempty" href="#region.struct.isempty">isempty</a></code></li>
<li><code><a title="region.struct.isexpression" href="#region.struct.isexpression">isexpression</a></code></li>
<li><code><a title="region.struct.isstrdefined" href="#region.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="region.struct.isstrexpression" href="#region.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="region.struct.items" href="#region.struct.items">items</a></code></li>
<li><code><a title="region.struct.keys" href="#region.struct.keys">keys</a></code></li>
<li><code><a title="region.struct.keyssorted" href="#region.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="region.struct.np2str" href="#region.struct.np2str">np2str</a></code></li>
<li><code><a title="region.struct.read" href="#region.struct.read">read</a></code></li>
<li><code><a title="region.struct.scan" href="#region.struct.scan">scan</a></code></li>
<li><code><a title="region.struct.set" href="#region.struct.set">set</a></code></li>
<li><code><a title="region.struct.setattr" href="#region.struct.setattr">setattr</a></code></li>
<li><code><a title="region.struct.sortdefinitions" href="#region.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="region.struct.struct2dict" href="#region.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="region.struct.struct2param" href="#region.struct.struct2param">struct2param</a></code></li>
<li><code><a title="region.struct.update" href="#region.struct.update">update</a></code></li>
<li><code><a title="region.struct.values" href="#region.struct.values">values</a></code></li>
<li><code><a title="region.struct.write" href="#region.struct.write">write</a></code></li>
<li><code><a title="region.struct.zip" href="#region.struct.zip">zip</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.tlsph" href="#region.tlsph">tlsph</a></code></h4>
<ul class="">
<li><code><a title="region.tlsph.PAIR_DIAGCOEFF" href="#region.tlsph.PAIR_DIAGCOEFF">PAIR_DIAGCOEFF</a></code></li>
<li><code><a title="region.tlsph.PAIR_OFFDIAGCOEFF" href="#region.tlsph.PAIR_OFFDIAGCOEFF">PAIR_OFFDIAGCOEFF</a></code></li>
<li><code><a title="region.tlsph.description" href="#region.tlsph.description">description</a></code></li>
<li><code><a title="region.tlsph.name" href="#region.tlsph.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.ulsph" href="#region.ulsph">ulsph</a></code></h4>
<ul class="">
<li><code><a title="region.ulsph.PAIR_DIAGCOEFF" href="#region.ulsph.PAIR_DIAGCOEFF">PAIR_DIAGCOEFF</a></code></li>
<li><code><a title="region.ulsph.PAIR_OFFDIAGCOEFF" href="#region.ulsph.PAIR_OFFDIAGCOEFF">PAIR_OFFDIAGCOEFF</a></code></li>
<li><code><a title="region.ulsph.description" href="#region.ulsph.description">description</a></code></li>
<li><code><a title="region.ulsph.name" href="#region.ulsph.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="region.water" href="#region.water">water</a></code></h4>
<ul class="">
<li><code><a title="region.water.description" href="#region.water.description">description</a></code></li>
<li><code><a title="region.water.name" href="#region.water.name">name</a></code></li>
<li><code><a title="region.water.userid" href="#region.water.userid">userid</a></code></li>
<li><code><a title="region.water.version" href="#region.water.version">version</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>