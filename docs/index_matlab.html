<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<title>Pizza3 Matlab Documentation</title>
<style>
body {
    font-family: 'Segoe UI', Arial, sans-serif; 
    margin: 0; 
    padding: 0; 
    line-height: 1.6; 
    background-color: #f9f9f9; 
    color: #333;
}
header {
    background: #4CAF50; 
    color: #fff; 
    padding: 10px;
    position: relative; /* For positioning the toggle button */
}
header h1 {
    margin: 0; 
    font-size: 1.5em;
    color: #fff; /* Explicitly set to white */
    padding-left: 50px; /* Space for the toggle button */
}
#content {
    display: flex;
    height: calc(100vh - 50px); /* Adjusted for header height */
    transition: all 0.3s ease; /* Enable transitions for smooth animations */
}
#nav {
    width: 300px; /* Set a fixed width */
    background: #fff;
    border-right: 1px solid #ddd;
    padding: 20px;
    overflow-y: auto;
    box-sizing: border-box;
    transition: width 0.3s ease, padding 0.3s ease; /* Transition for smooth animations */
    flex-shrink: 0; /* Prevent flexbox from shrinking */
}
#nav.collapsed {
    width: 0; /* Hide the sidebar completely */
    padding: 20px 0; /* Optionally adjust padding */
}
#main {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    box-sizing: border-box;
    transition: all 0.3s ease; /* Enable transitions for smooth animations */
}
header .toggle-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%); /* Center the button vertically */
    left: 10px; /* Place the button on the left */
    background-color: #4CAF50; /* Green background */
    border: none;
    color: white; /* Ensure the hamburger icon is white */
    padding: 10px 12px; /* Adjust padding for larger button */
    cursor: pointer;
    font-size: 1.2em; /* Increase font size for better visibility */
    border-radius: 4px;
    z-index: 1001; /* Ensure the button is above other elements */
}
header .toggle-btn:hover {
    background-color: #45a049;
}
header .toggle-btn kbd {
    font-family: 'Arial', sans-serif; /* Match the header font */
    color: white; /* Ensure the hamburger icon is white */
    font-size: 1.2em; /* Same size as the button text */
    background: none; /* Remove any background styling from <kbd> */
    border: none; /* Remove any borders from <kbd> */
}
h1 {
    font-size: 1.8em;
    color: #333;
}
h2 {
    color: #333; 
    border-bottom: 2px solid #4CAF50; 
    padding-bottom: 5px;
}
a {
    text-decoration: none; 
    color: #007BFF;
}
a:hover {
    text-decoration: underline;
}
ul {
    list-style-type: none; 
    padding-left: 0;
    margin: 0;
}
li {
    margin: 5px 0;
}
.folder-title {
    font-weight: bold; 
    color: #333; 
    padding: 5px 0;
    cursor: pointer;
}
.folder-content {
    margin-left: 20px;
    display: none; /* start collapsed */
}
.file {
    margin-left: 20px;
}
hr {
    margin: 20px 0; 
    border: 1px solid #ddd;
}
footer {
    font-size: 0.9em; 
    color: #666; 
    margin-top: 20px; 
    text-align: center;
}
/* Enhanced Table Styling with Banded Colors */
table {
    border-collapse: collapse;
    width: 100%;
}
th, td {
    border: 1px solid #ddd;
    padding: 8px;
}
th {
    background-color: #4CAF50;
    color: white;
}
tr:nth-child(even) {
    background-color: #f2f2f2; /* Light gray for even rows */
}
tr:nth-child(odd) {
    background-color: rgba(76, 175, 80, 0.1); /* Light green for odd rows */
}
/* Collapsible Code Section */
.collapsible {
    background-color: #f1f1f1;
    color: #333;
    cursor: pointer;
    padding: 10px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 1em;
}
.active, .collapsible:hover {
    background-color: #ddd;
}
.content {
    padding: 0 18px;
    display: none;
    overflow: hidden;
    background-color: #f9f9f9;
}
/* Minimal Syntax Highlighting */
.code {
    background-color: #f4f4f4;
    padding: 10px;
    border: 1px solid #ddd;
    overflow-x: auto;
    font-family: 'Courier New', Courier, monospace;
    color: #333;
}
.keyword {
    color: #007BFF;
    font-weight: bold;
}
.comment {
    color: #6a9955;
    font-style: italic;
}
.string {
    color: #a31515;
}

/* Responsive Design */
@media screen and (max-width: 768px) {
    #nav {
        position: absolute;
        left: 0;
        top: 50px; /* Height of the header */
        height: calc(100% - 50px);
        z-index: 1000;
    }
    #nav.collapsed {
        width: 0; /* Hide the sidebar completely */
        padding: 20px 0; /* Adjust padding */
    }
    #main {
        flex: 1;
    }
    /* Add overlay when sidebar is open on mobile */
    body.nav-open::before {
        content: "";
        position: fixed;
        top: 50px;
        left: 0;
        width: 100%;
        height: calc(100% - 50px);
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
    }
}
</style>
</head>
<body>
<header>
    <!-- Toggle Sidebar Button -->
    <button class='toggle-btn' id='toggleSidebar' aria-label='Toggle Sidebar' aria-expanded='false'>
        <kbd>&#9776;</kbd>
    </button>
    <h1>Pizza3 Documentation</h1>
</header>
<div id='content'>
<div id='nav'>
<p><strong>Version:</strong> Pizza3 v.1.003</p>
<p><strong>Maintained by:</strong> INRAE\olivier.vitrac@agroparistech.fr</p>
<hr>
<ul class='folder-list'>
<li class='folder'>
<div class='folder-title' onclick='toggleFolder(this)'>misc</div>
<ul class='folder-content'>
<li class='file'><a href='#Hertz_forces' onclick="loadDoc('Hertz_forces')">Hertz_forces</a></li>
<li class='file'><a href='#Landshoff_forces' onclick="loadDoc('Landshoff_forces')">Landshoff_forces</a></li>
<li class='file'><a href='#Landshoff_forces_obsctacle' onclick="loadDoc('Landshoff_forces_obsctacle')">Landshoff_forces_obsctacle</a></li>
</ul>
</li>
<li class='folder'>
<div class='folder-title' onclick='toggleFolder(this)'>post</div>
<ul class='folder-content'>
<li class='file'><a href='#Billy_results_template' onclick="loadDoc('Billy_results_template')">Billy_results_template</a></li>
<li class='file'><a href='#Billy_results_template_PBC' onclick="loadDoc('Billy_results_template_PBC')">Billy_results_template_PBC</a></li>
<li class='file'><a href='#Billy_results_template_PBC_alt' onclick="loadDoc('Billy_results_template_PBC_alt')">Billy_results_template_PBC_alt</a></li>
<li class='file'><a href='#Billy_results_template_PBC_relative_velocity' onclick="loadDoc('Billy_results_template_PBC_relative_velocity')">Billy_results_template_PBC_relative_velocity</a></li>
<li class='file'><a href='#Billy_results_template_cross_section' onclick="loadDoc('Billy_results_template_cross_section')">Billy_results_template_cross_section</a></li>
<li class='file'><a href='#Bily_suspension_interpretation' onclick="loadDoc('Bily_suspension_interpretation')">Bily_suspension_interpretation</a></li>
<li class='file'><a href='#KE_t' onclick="loadDoc('KE_t')">KE_t</a></li>
<li class='file'><a href='#MDunidrnd' onclick="loadDoc('MDunidrnd')">MDunidrnd</a></li>
<li class='file'><a href='#PBCgrid' onclick="loadDoc('PBCgrid')">PBCgrid</a></li>
<li class='file'><a href='#PBCgridshift' onclick="loadDoc('PBCgridshift')">PBCgridshift</a></li>
<li class='file'><a href='#PBCimages' onclick="loadDoc('PBCimages')">PBCimages</a></li>
<li class='file'><a href='#PBCimages0' onclick="loadDoc('PBCimages0')">PBCimages0</a></li>
<li class='file'><a href='#PBCimagesshift' onclick="loadDoc('PBCimagesshift')">PBCimagesshift</a></li>
<li class='file'><a href='#PBCincell' onclick="loadDoc('PBCincell')">PBCincell</a></li>
<li class='file'><a href='#PBCoutcell' onclick="loadDoc('PBCoutcell')">PBCoutcell</a></li>
<li class='file'><a href='#SetQuiverColor' onclick="loadDoc('SetQuiverColor')">SetQuiverColor</a></li>
<li class='file'><a href='#SetQuiverLength' onclick="loadDoc('SetQuiverLength')">SetQuiverLength</a></li>
<li class='file'><a href='#Yao_template' onclick="loadDoc('Yao_template')">Yao_template</a></li>
<li class='file'><a href='#add_bead' onclick="loadDoc('add_bead')">add_bead</a></li>
<li class='file'><a href='#arrow' onclick="loadDoc('arrow')">arrow</a></li>
<li class='file'><a href='#buildVerletList' onclick="loadDoc('buildVerletList')">buildVerletList</a></li>
<li class='file'><a href='#buildVerletList3' onclick="loadDoc('buildVerletList3')">buildVerletList3</a></li>
<li class='file'><a href='#checkfiles' onclick="loadDoc('checkfiles')">checkfiles</a></li>
<li class='file'><a href='#color_line3' onclick="loadDoc('color_line3')">color_line3</a></li>
<li class='file'><a href='#curve2tangent' onclick="loadDoc('curve2tangent')">curve2tangent</a></li>
<li class='file'><a href='#defgradSPH' onclick="loadDoc('defgradSPH')">defgradSPH</a></li>
<li class='file'><a href='#dispb' onclick="loadDoc('dispb')">dispb</a></li>
<li class='file'><a href='#dispf' onclick="loadDoc('dispf')">dispf</a></li>
<li class='file'><a href='#example1' onclick="loadDoc('example1')">example1</a></li>
<li class='file'><a href='#example2' onclick="loadDoc('example2')">example2</a></li>
<li class='file'><a href='#example2bis' onclick="loadDoc('example2bis')">example2bis</a></li>
<li class='file'><a href='#example3' onclick="loadDoc('example3')">example3</a></li>
<li class='file'><a href='#explore' onclick="loadDoc('explore')">explore</a></li>
<li class='file'><a href='#fileinfo' onclick="loadDoc('fileinfo')">fileinfo</a></li>
<li class='file'><a href='#fillstreamline2' onclick="loadDoc('fillstreamline2')">fillstreamline2</a></li>
<li class='file'><a href='#fitCircleFromPoints' onclick="loadDoc('fitCircleFromPoints')">fitCircleFromPoints</a></li>
<li class='file'><a href='#forceHertz' onclick="loadDoc('forceHertz')">forceHertz</a></li>
<li class='file'><a href='#forceHertzAB' onclick="loadDoc('forceHertzAB')">forceHertzAB</a></li>
<li class='file'><a href='#forceLandshoff' onclick="loadDoc('forceLandshoff')">forceLandshoff</a></li>
<li class='file'><a href='#hourglassSPH' onclick="loadDoc('hourglassSPH')">hourglassSPH</a></li>
<li class='file'><a href='#interp2SPH' onclick="loadDoc('interp2SPH')">interp2SPH</a></li>
<li class='file'><a href='#interp2SPHVerlet' onclick="loadDoc('interp2SPHVerlet')">interp2SPHVerlet</a></li>
<li class='file'><a href='#interp3SPH' onclick="loadDoc('interp3SPH')">interp3SPH</a></li>
<li class='file'><a href='#interp3SPHVerlet' onclick="loadDoc('interp3SPHVerlet')">interp3SPHVerlet</a></li>
<li class='file'><a href='#interp3cauchy' onclick="loadDoc('interp3cauchy')">interp3cauchy</a></li>
<li class='file'><a href='#kernelSPH' onclick="loadDoc('kernelSPH')">kernelSPH</a></li>
<li class='file'><a href='#lamdumpread2' onclick="loadDoc('lamdumpread2')">lamdumpread2</a></li>
<li class='file'><a href='#lastdir' onclick="loadDoc('lastdir')">lastdir</a></li>
<li class='file'><a href='#nearestpoint' onclick="loadDoc('nearestpoint')">nearestpoint</a></li>
<li class='file'><a href='#packSPH' onclick="loadDoc('packSPH')">packSPH</a></li>
<li class='file'><a href='#packing' onclick="loadDoc('packing')">packing</a></li>
<li class='file'><a href='#packing_WJbranch' onclick="loadDoc('packing_WJbranch')">packing_WJbranch</a></li>
<li class='file'><a href='#particle_flux' onclick="loadDoc('particle_flux')">particle_flux</a></li>
<li class='file'><a href='#partitionVerletList' onclick="loadDoc('partitionVerletList')">partitionVerletList</a></li>
<li class='file'><a href='#plot3D' onclick="loadDoc('plot3D')">plot3D</a></li>
<li class='file'><a href='#quiverc' onclick="loadDoc('quiverc')">quiverc</a></li>
<li class='file'><a href='#rootdir' onclick="loadDoc('rootdir')">rootdir</a></li>
<li class='file'><a href='#selfVerletList' onclick="loadDoc('selfVerletList')">selfVerletList</a></li>
<li class='file'><a href='#shapeSPH' onclick="loadDoc('shapeSPH')">shapeSPH</a></li>
<li class='file'><a href='#trajunwrap' onclick="loadDoc('trajunwrap')">trajunwrap</a></li>
<li class='file'><a href='#unwrapPBC' onclick="loadDoc('unwrapPBC')">unwrapPBC</a></li>
<li class='file'><a href='#updateVerletList' onclick="loadDoc('updateVerletList')">updateVerletList</a></li>
<li class='file'><a href='#wallstress' onclick="loadDoc('wallstress')">wallstress</a></li>
<li class='file'><a href='#yao_initialization' onclick="loadDoc('yao_initialization')">yao_initialization</a></li>
<li class='file'><a href='#yao_sedimentation' onclick="loadDoc('yao_sedimentation')">yao_sedimentation</a></li>
<li class='file'><a href='#yao_stress' onclick="loadDoc('yao_stress')">yao_stress</a></li>
<li class='file'><a href='#yao_stress_vertical_xz' onclick="loadDoc('yao_stress_vertical_xz')">yao_stress_vertical_xz</a></li>
<li class='file'><a href='#yao_stress_vertical_yz' onclick="loadDoc('yao_stress_vertical_yz')">yao_stress_vertical_yz</a></li>
</ul>
</li>
<li class='folder'>
<div class='folder-title' onclick='toggleFolder(this)'>utils/obsolete</div>
<ul class='folder-content'>
<li class='file'><a href='#interp2SPH' onclick="loadDoc('interp2SPH')">interp2SPH</a></li>
<li class='file'><a href='#interp3SPH' onclick="loadDoc('interp3SPH')">interp3SPH</a></li>
<li class='file'><a href='#kernelSPH' onclick="loadDoc('kernelSPH')">kernelSPH</a></li>
<li class='file'><a href='#packSPH' onclick="loadDoc('packSPH')">packSPH</a></li>
<li class='file'><a href='#packing' onclick="loadDoc('packing')">packing</a></li>
</ul>
</li>
</ul>
</div>
<div id='main'>
<div id='welcome-message'>
<h2>Welcome to Pizza3 Matlab Documentation</h2>
<p>Select a function in the left menu to view its documentation.</p>
<p>POST examples are fully detailed <a href='post/index_post.html' target='_blank'>here</a>.</p>
<p>Back to the <a href='index.html'>Python'Pizza3 documentation</a>.</p>
<hr>
<p><i>When no function is selected, you see this welcome page.</i></p>
Generated on: 2025-01-19 19:10:14</div>
<div id='Hertz_forces' class='doc-content' style='display: none;'>
<h1>Code to explain the displacement of SPH particles (amorphous) along a rigid wall made with beads of the same size (organized)</h1>
<p>INRAE\Olivier Vitrac, Han Chen - 2023-02-23</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">%% Code to explain the displacement of SPH particles (amorphous) along a rigid wall made with beads of the same size (organized)</span>
<span class="comment">% INRAE\Olivier Vitrac, Han Chen - 2023-02-23</span>

<span class="comment">% [ SYNOPSIS ] This code simulates the displacement of spherical particles in a rigid wall made with beads of the</span>
<span class="comment">% same size, by calculating the normal force and contact radius between the particles % and the wall. The contact</span>
<span class="comment">% depth between each pair of particles and the wall is calculated using the Hertz model.</span>

<span class="comment">% [ DESCRIPTION ] The code simulates the displacement of amorphous fluid particles along a</span>
<span class="comment">% rigid wall made of beads of the same size that are organized in a fixed pattern. The code</span>
<span class="comment">% defines the initial configuration of the system, with the wall and fluid beads arranged in their</span>
<span class="comment">% respective layers. The fluid beads are then redistributed with some randomness along the x-axis.</span>
<span class="comment">% The code then finds the closest wall bead to each fluid bead and calculates the contraction</span>
<span class="comment">% required <span class="keyword">for</span> the fluid bead to move towards the wall bead. The final configuration of the fluid</span>
<span class="comment">% beads is then computed with the required contraction, and the physical interpretation of the</span>
<span class="comment">% contraction is calculated using Hertz contact mechanics. The dynamic configuration is then plotted,</span>
<span class="comment">% showing the motion of the fluid beads towards the wall beads, with arrows indicating the force</span>
<span class="comment">% direction and magnitude. The code also allows the user to record a video of the dynamic configuration.</span>

<span class="comment">%% layer definitions and initial configuration</span>
<span class="comment">% The code defines the properties of the wall and the fluid particles,</span>
<span class="comment">% including their size, number, and position. The particles are initially</span>
<span class="comment">% randomly distributed along the x-axis, and then redistributed to the</span>
<span class="comment">% nearest wall bead with some randomness.</span>

<span class="comment">% layer plot</span>
layerplot = @(X) viscircles([X.x X.y],X.R*ones(X.n,1),<span class="string">'color'</span>,X.color);
<span class="comment">% bead size</span>
r = 0.5;
wall = struct( ...
    <span class="string">'R'</span>,r, ...
    <span class="string">'n'</span>,14,...
    <span class="string">'y'</span>,-r,...
    <span class="string">'dx'</span>,1e-2,...
    <span class="string">'dy'</span>,0,...
    <span class="string">'color'</span>,rgb(<span class="string">'DarkBlue'</span>) ...
    );

fluid = struct( ...
    <span class="string">'R'</span>,r,...
    <span class="string">'n'</span>,10,...
    <span class="string">'y'</span>,+r,...
    <span class="string">'dx'</span>,1e-2,...
    <span class="string">'dy'</span>,1e-2,...
    <span class="string">'color'</span>,rgb(<span class="string">'Gold'</span>) ...
    );
wall.x  = linspace(-(wall.dx+wall.R*2)*(wall.n-1)/2,(wall.dx+wall.R*2)*(wall.n-1)/2,wall.n)<span class="string">';
fluid.x = linspace(-(fluid.dx+fluid.R*2)*(fluid.n-1)/2,(fluid.dx+fluid.R*2)*(fluid.n-1)/2,fluid.n)'</span>;
wall.y = ones(wall.n,1) * (wall.y + wall.dy);
fluid.y = ones(fluid.n,1) * (fluid.y + fluid.dy);
<span class="comment">% redistribute with some randomness fluid beads along x</span>
x0 = fluid.x(1);
dx = diff(fluid.x);
dxrandom = abs(randn(fluid.n,1))*fluid.R*0.5;
x = x0+[cumsum([0;dx]+dxrandom)];
fluid.x = x - mean(x);

<span class="comment">% find the closest wall bead and calculate the final configuration (used to get fmax)</span>
distance = @(i) sqrt((wall.x-fluid.x(i)).^2 + (wall.y-fluid.y(i)).^2);
iclosest = arrayfun( @(i) find( distance(i)==min(distance(i)),1),1:fluid.n );
distance2closest = sqrt((wall.x(iclosest)-fluid.x).^2 + (wall.y(iclosest)-fluid.y).^2);
dtarget = wall.R*2*(1-abs(randn(fluid.n,1)*0.02));
contraction_required = 1-dtarget./distance2closest;
final = fluid;
final.x = final.x + (wall.x(iclosest)-final.x) .* contraction_required;
final.y = final.y + (wall.y(iclosest)-final.y) .* contraction_required;


<span class="comment">% Physical intepretation</span>
<span class="comment">% The force required to maintain the contact between the particles and the wall is</span>
<span class="comment">% calculated based on the Hertz model, and the dynamic configuration of the particles</span>
<span class="comment">% is then calculated using the applied load.</span>
distance2closest = sqrt((wall.x(iclosest)-final.x).^2 + (wall.y(iclosest)-final.y).^2);
E = 1e5;
rcut = wall.R + final.R;
direction = - [wall.x(iclosest)-final.x (wall.y(iclosest)-final.y)]./distance2closest(:,[1 1]);
f = E * sqrt((rcut-distance2closest)*wall.R*final.R/rcut);
f(distance2closest>rcut) = 0;
fmax = max(f);

<span class="comment">% dynamic configuration</span>
nt = 200;
t = linspace(0,1,nt);
clf, hold on, axis equal
layerplot(wall)
[hp,ha] = deal([]);
axis off
RECORD = true; <span class="comment">% set it to true to record a video</span>

<span class="comment">% The code then iterates over a certain number of time steps,calculating</span>
<span class="comment">% the dynamic configuration of the particles in each step and plotting their</span>
<span class="comment">% positions and contact depths using the Hertz model.</span>
<span class="keyword">for</span> it = 1:nt
    layerplot(fluid)
    config = fluid;
    config.x = config.x + (wall.x(iclosest)-config.x) .* contraction_required*t(it);
    config.y = config.y + (wall.y(iclosest)-config.y) .* contraction_required*t(it);

    <span class="comment">% Physical intepretation</span>
    distance2closest = sqrt((wall.x(iclosest)-config.x).^2 + (wall.y(iclosest)-config.y).^2);
    min(distance2closest)
    rcut = wall.R + config.R;

    direction = - [wall.x(iclosest)-config.x (wall.y(iclosest)-config.y)]./distance2closest(:,[1 1]);
    f = E * sqrt((rcut-distance2closest)*wall.R*config.R/rcut);
    f(distance2closest>rcut) = 0;
    fmax = max(f);
    fscale = 2*r/fmax;
    start = [config.x config.y];
    stop = start + direction.*f*fscale;
    start(f==0,:)=[];
    stop(f==0,:)=[];

    <span class="comment">% plot</span>
    <span class="keyword">if</span> ~isempty(hp), delete(hp); <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(ha), delete(ha); <span class="keyword">end</span>
    hp = layerplot(config);
    <span class="keyword">if</span> any(start)
        ha = [
            arrow(start,stop,<span class="string">'length'</span>,8,<span class="string">'BaseAngle'</span>,60,<span class="string">'Linewidth'</span>,2,<span class="string">'color'</span>,rgb(<span class="string">'ForestGreen'</span>),<span class="string">'Edgecolor'</span>,rgb(<span class="string">'ForestGreen'</span>))
            arrow(start,[stop(:,1) start(:,2)],<span class="string">'length'</span>,4,<span class="string">'BaseAngle'</span>,60,<span class="string">'color'</span>,rgb(<span class="string">'Tomato'</span>))
            arrow(start,[start(:,1) stop(:,2)],<span class="string">'length'</span>,4,<span class="string">'BaseAngle'</span>,60,<span class="string">'color'</span>,rgb(<span class="string">'Tomato'</span>),<span class="string">'EdgeColor'</span>,rgb(<span class="string">'Tomato'</span>))
            ];
    <span class="keyword">else</span>
        ha = [];
    <span class="keyword">end</span>
    drawnow

   <span class="comment">% record video</span>
   <span class="keyword">if</span> RECORD
       gif_add_frame(gca,<span class="string">'hertz.gif'</span>,15);
   <span class="keyword">end</span>

<span class="keyword">end</span>
    
<span class="comment">%% Template</span>
<span class="comment">% A similar code template is also provided at the <span class="keyword">end</span>, which calculates the Hertz contact depth</span>
<span class="comment">% between two series of parallel spheres aligned along the x-axis, with a fixed distance between</span>
<span class="comment">% adjacent spheres. It calculates the normal force and contact radius based on the material</span>
<span class="comment">% properties of the spheres, and then loops over all possible pairs of spheres to calculate</span>
<span class="comment">% the Hertz contact depth between them. Finally, it plots the sphere positions and contact depths.</span>


<span class="comment">% % This code assumes that the two series of parallel spheres are aligned </span>
<span class="comment">% % along the x-axis, with a fixed distance between adjacent spheres. </span>
<span class="comment">% % It calculates the normal force and contact radius based on the material </span>
<span class="comment">% % properties of the spheres, and then loops over all possible pairs of spheres</span>
<span class="comment">% % to calculate the Hertz contact depth between them. </span>
<span class="comment">% % Finally, it plots the sphere positions and contact depths. </span>
<span class="comment">% % You can modify the code to suit your specific geometry and material properties.</span>
<span class="comment">% </span>
<span class="comment">% % Define material properties</span>
<span class="comment">% E = 2.1e11; % Young<span class="string">'s modulus in Pa</span>
<span class="comment">% v = 0.3; % Poisson'</span>s ratio</span>
<span class="comment">% R = 0.5e-3; % Sphere radius in m</span>
<span class="comment">% </span>
<span class="comment">% % Define sphere geometry and spacing</span>
<span class="comment">% n1 = 10; % Number of spheres in the first row</span>
<span class="comment">% n2 = 10; % Number of spheres in the second row</span>
<span class="comment">% d = 1e-3; % Distance between spheres in m</span>
<span class="comment">% </span>
<span class="comment">% % Calculate normal force and contact radius</span>
<span class="comment">% P = 1; % Applied load in N</span>
<span class="comment">% a = (3*P*(1-v^2)/(4*E))^(1/3); % Contact radius in m</span>
<span class="comment">% F = 4/3*E*sqrt(R)*a^(3/2); % Normal force in N</span>
<span class="comment">% </span>
<span class="comment">% % Define sphere positions</span>
<span class="comment">% x1 = linspace(-d*(n1-1)/2,d*(n1-1)/2,n1);</span>
<span class="comment">% x2 = linspace(-d*(n2-1)/2,d*(n2-1)/2,n2)+1e-4;</span>
<span class="comment">% y1 = -R;</span>
<span class="comment">% y2 = 0.98*R;</span>
<span class="comment">% </span>
<span class="comment">% % Initialize contact matrix</span>
<span class="comment">% C = zeros(n1,n2);</span>
<span class="comment">% </span>
<span class="comment">% % Loop over all sphere pairs and calculate contact</span>
<span class="comment">% <span class="keyword">for</span> i = 1:n1</span>
<span class="comment">%     <span class="keyword">for</span> j = 1:n2</span>
<span class="comment">%         dx = x2(j) - x1(i);</span>
<span class="comment">%         <span class="keyword">if</span> abs(dx) > d</span>
<span class="comment">%             % Spheres are too far apart to be in contact</span>
<span class="comment">%             continue;</span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%         r = sqrt( (x2(j) - x1(i))^2 + (y2 - y1)^2 );</span>
<span class="comment">%         <span class="keyword">if</span> r >= 2*R</span>
<span class="comment">%             % Spheres are not in contact</span>
<span class="comment">%             continue</span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%         C(i,j) = a - sqrt((2*R-r)*r); % Hertz contact depth in m</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% %% Plot sphere positions and contact depths</span>
<span class="comment">% figure, hold on</span>
<span class="comment">% <span class="keyword">for</span> i = 1:n1</span>
<span class="comment">%     viscircles([x1(i) y1],R,<span class="string">'color'</span>,<span class="string">'b'</span>);</span>
<span class="comment">%     <span class="keyword">for</span> j = 1:n2</span>
<span class="comment">%         viscircles([x2(j) y2],R-C(i,j),<span class="string">'color'</span>,<span class="string">'r'</span>);</span>
<span class="comment">%         <span class="keyword">if</span> C(i,j) > 0</span>
<span class="comment">%             plot([x1(i),x2(j)],[y1+R,y1+R-C(i,j)],<span class="string">'k'</span>);</span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% axis equal</span></code></pre></div>
</div>
<div id='Landshoff_forces' class='doc-content' style='display: none;'>
<h1>Code to illustrate the developement Landshoff forces between two horizontal layers of layer particles</h1>
<p>translating respectively to each other with a velocity difference</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">%% Code to illustrate the developement Landshoff forces between two horizontal layers of layer particles</span>
<span class="comment">% translating respectively to each other with a velocity difference</span>

<span class="comment">% INRAE\Olivier Vitrac, Han Chen - 2023-02-23</span>

<span class="comment">% [ SYNOPSIS ] This code simulates the displacement of two layers of particles</span>
<span class="comment">% in a fluid using smoothed particle hydrodynamics (SPH). The two layers are</span>
<span class="comment">% represented by the "fixed" and "movable" structures, which contain information</span>
<span class="comment">% about the size, number, position, and velocity of the particles in each layer.</span>

<span class="comment">% [ DESCRIPTION ] The code simulates the movement of two layers of particles in a fluid</span>
<span class="comment">% using smoothed particle hydrodynamics (SPH). The particles in the two layers are</span>
<span class="comment">% represented by the "fixed" and "movable" structures, which contain information about</span>
<span class="comment">% the size, number, position, and velocity of the particles in each layer. The Landshoff</span>
<span class="comment">% forces between particles in the two layers are calculated using the kernel <span class="keyword">function</span> and</span>
<span class="comment">% SPH parameters, and the positions of the particles in the "movable" layer are adjusted</span>
<span class="comment">% to be as close as possible to the particles in the "fixed" layer. The forces are plotted</span>
<span class="comment">% as arrows on the particle plot using the "arrow" <span class="keyword">function</span>, and the plot is updated with</span>
<span class="comment">% each iteration. The code also includes options <span class="keyword">for</span> recording the plot as a GIF.</span>


<span class="comment">%% The code begins by defining the "layerplot" <span class="keyword">function</span>, which creates a scatter plot of the particles</span>
<span class="comment">% in a layer using circles with a radius equal to the particle size.</span>
<span class="comment">% The particle size is set to 0.5 units <span class="keyword">for</span> both layers, and the "fixed" layer contains 14 particles,</span>
<span class="comment">% <span class="keyword">while</span> the "movable" layer contains 10 particles. The particles in the "fixed" layer are arbitrarily</span>
<span class="comment">% fixed in place, <span class="keyword">while</span> the particles in the "movable" layer are free to move.</span>
<span class="comment">% layer plot</span>
layerplot = @(X) viscircles([X.x X.y],X.R*ones(X.n,1),<span class="string">'color'</span>,X.color);
<span class="comment">% bead size</span>
r = 0.5;
fixed = struct( ...these particles are arbitrarily fixed
    <span class="string">'R'</span>,r, ...
    <span class="string">'n'</span>,14,...
    <span class="string">'y'</span>,-r,...
    <span class="string">'dx'</span>,1e-2,...
    <span class="string">'dy'</span>,0,...
    <span class="string">'color'</span>,rgb(<span class="string">'DodgerBlue'</span>),...
    <span class="string">'id'</span>,0 ...
    );

movable = struct( ... movable particles
    <span class="string">'R'</span>,r,...
    <span class="string">'n'</span>,10,...
    <span class="string">'y'</span>,+r,...
    <span class="string">'dx'</span>,1e-2,...
    <span class="string">'dy'</span>,1e-2,...
    <span class="string">'color'</span>,rgb(<span class="string">'DeepSkyBlue'</span>), ...
    <span class="string">'id'</span>,1 ...
    );

<span class="comment">% The positions of the particles in each layer are initiallyset up in a linear array along the x-axis,</span>
<span class="comment">% with some randomness added to the spacing between particles.</span>
<span class="comment">% The positions of the particles in the "fixed" layer are then shifted along the y-axis</span>
<span class="comment">% by a fixed amount, <span class="keyword">while</span> the positions of the particles in the "movable" layer are shifted</span>
<span class="comment">% by a smaller amount along both the x- and y-axes.</span>
fixed.x  = linspace(-(fixed.dx+fixed.R*2)*(fixed.n-1)/2,(fixed.dx+fixed.R*2)*(fixed.n-1)/2,fixed.n)<span class="string">';
movable.x = linspace(-(movable.dx+movable.R*2)*(movable.n-1)/2,(movable.dx+movable.R*2)*(movable.n-1)/2,movable.n)'</span>;
fixed.y = ones(fixed.n,1) * (fixed.y + fixed.dy);
movable.y = ones(movable.n,1) * (movable.y + movable.dy);

<span class="comment">% redistribute with some randomness fixed beads along x</span>
x0 = fixed.x(1);
dx = diff(fixed.x);
dxrandom = abs(randn(fixed.n,1))*fixed.R*0.25;
x = x0+[cumsum([0;dx]+dxrandom)];
fixed.x = x - mean(x);

<span class="comment">% redistribute with some randomness top beads along x</span>
x0 = movable.x(1);
dx = diff(movable.x);
dxrandom = abs(randn(movable.n,1))*movable.R*0.4;
x = x0+[cumsum([0;dx]+dxrandom)];
movable.x = x - x(1) + mean(fixed.x(1:2));

<span class="comment">% Next, the kernel <span class="keyword">function</span> and SPH parameters are defined.</span>
<span class="comment">% The kernel <span class="keyword">function</span> is used to calculate the smoothing <span class="keyword">function</span></span>
<span class="comment">% <span class="keyword">for</span> the SPH method, and the parameters include the smoothing length (h),</span>
<span class="comment">% the density (rho), and the coefficients (c0 and q1) used in the Landshoff force calculation.</span>
h = 2 * r;
dWdr = @(r) (r<h) .* ( (1.0./h.^3.*(r./h-1.0).^3.*-1.5e+1)./pi-(1.0./h.^3.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*1.5e+1)./pi );
c0 = 10;
q1 = 1;
rho = 1000;


<span class="comment">% initial position</span>
v = 0.1; <span class="comment">% velocity (arbitrary units)</span>
dt = 0.1;
config = movable;
clf, hold on, axis equal
layerplot(fixed)
[hp,ha] = deal([]);
axis off
RECORD = true; <span class="comment">% set it to true to record a video</span>

<span class="comment">% The code then enters a loop that simulates the movement of the particles over time.</span>
<span class="comment">% In each iteration, the position of the "movable" layer is shifted by a fixed amount</span>
<span class="comment">% along the x-axis, and the particles are then repacked along the y-axis to be as close</span>
<span class="comment">% as possible to the particles in the "fixed" layer. This is done using the "distance"</span>
<span class="comment">% and "iclosest" functions to find the closest particle in the "fixed" layer to each</span>
<span class="comment">% particle in the "movable" layer, and then adjusting the positions of the particles</span>
<span class="comment">% in the "movable" layer accordingly.</span>
<span class="keyword">for</span> it=1:350
    shift = dt * v;
    config.x = config.x + shift;
    <span class="comment">% repack the top layer respectively to the fixed</span>
    distance = @(i) sqrt((fixed.x-config.x(i)).^2 + (fixed.y-config.y(i)).^2);
    iclosest = arrayfun( @(i) find( distance(i)==min(distance(i)),1),1:config.n );
    distance2closest = sqrt((fixed.x(iclosest)-config.x).^2 + (fixed.y(iclosest)-config.y).^2);
    dtarget = fixed.R*2*(1-abs(randn(config.n,1)*0.01));
    contraction_required = 1-dtarget./distance2closest;
    config.x = config.x + (fixed.x(iclosest)-config.x) .* contraction_required;
    config.y = config.y + (fixed.y(iclosest)-config.y) .* contraction_required;

    <span class="comment">%The Landshoff forces are then calculated using a nested loop that iterates</span>
    <span class="comment">% over all pairs of particles in both layers. The forces are calculated using</span>
    <span class="comment">% the kernel <span class="keyword">function</span> and the Landshoff force formula, which includes the velocity</span>
    <span class="comment">% difference and distance between particles, as well as the SPH parameters</span>
    id = [ fixed.id * ones(fixed.n,1); config.id * ones(config.n,1) ];
    xy = [fixed.x fixed.y; config.x config.y];
    vxy = [repmat([0 0],fixed.n,1); repmat([v 0],config.n,1)];
    n = fixed.n + config.n;
    [mu,nu] = deal(zeros(n,n));
    F = zeros(n,n,2);
    <span class="keyword">for</span> i = 1:n
        <span class="keyword">for</span> j = 1:n
            rij = xy(i,:)-xy(j,:);
            vij = vxy(i,:)-vxy(j,:);
            <span class="keyword">if</span> dot(rij,vij)<0
                mu(i,j) = h * dot(rij,vij)/(dot(rij,rij)+0.01*h^2);
                nu(i,j) = (1/rho) * (-q1*c0*mu(i,j));
                rij_d = norm(rij);
                rij_n = rij/rij_d;
                F(i,j,:) = -nu(i,j)*dWdr(rij_d) * permute(rij_n,[1 3 2]);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    Fbalance = squeeze(sum(F,2));
    f = sum(Fbalance.^2,2);
    fmedian = median(f);
    fmin = fmedian/50;
    fscale = 0.2*r/fmedian;

    <span class="comment">%Finally, the forces are plotted as arrows on the particle plot using the "arrow" <span class="keyword">function</span>,</span>
    <span class="comment">% and the plot is updated with each iteration. </span>
    start = xy;
    stop = start + Fbalance*fscale;
    start(f<fmin,:) = [];
    stop(f<fmin,:) = [];
    <span class="keyword">if</span> ~isempty(hp), delete(hp); <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(ha), delete(ha); <span class="keyword">end</span>
    hp = layerplot(config);
    ha = [
        arrow(start,stop,<span class="string">'length'</span>,8,<span class="string">'BaseAngle'</span>,60,<span class="string">'Linewidth'</span>,2,<span class="string">'color'</span>,rgb(<span class="string">'ForestGreen'</span>),<span class="string">'Edgecolor'</span>,rgb(<span class="string">'ForestGreen'</span>))
        arrow(start,[stop(:,1) start(:,2)],<span class="string">'length'</span>,4,<span class="string">'BaseAngle'</span>,60,<span class="string">'color'</span>,rgb(<span class="string">'Tomato'</span>))
        arrow(start,[start(:,1) stop(:,2)],<span class="string">'length'</span>,4,<span class="string">'BaseAngle'</span>,60,<span class="string">'color'</span>,rgb(<span class="string">'Tomato'</span>),<span class="string">'EdgeColor'</span>,rgb(<span class="string">'Tomato'</span>))
    ];
    drawnow

   <span class="comment">%If the "RECORD" flag is set to true, the plot is also recorded as a GIF using the "gif_add_frame" <span class="keyword">function</span>.</span>
   <span class="keyword">if</span> RECORD
       gif_add_frame(gca,<span class="string">'landshoff.gif'</span>,15);
   <span class="keyword">end</span>

<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='Landshoff_forces_obsctacle' class='doc-content' style='display: none;'>
<h1>Landshoff forces in a wakeflow</h1>
<p>INRAE\Olivier Vitrac - rev. 25/02/2023</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">%% Landshoff forces in a wakeflow</span>
<span class="comment">% INRAE\Olivier Vitrac - rev. 25/02/2023</span>

<span class="comment">% [ SYNOPSIS ] This code simulates the movement of particles in a wake flow,</span>
<span class="comment">% in which an obstacle is placed in front of a flow to create a wake downstream.</span>
<span class="comment">% The simulation includes particles in several layers, with particles in each</span>
<span class="comment">% layer connected by a force that is calculated based on the Landshoff force formula.</span>
<span class="comment">% The code uses the SPH (Smoothed Particle Hydrodynamics) method to simulate the motion</span>
<span class="comment">% of the particles and the arrows plotted on the particle plot indicate the forces</span>
<span class="comment">% between particles. The code also includes a GIF recording <span class="keyword">function</span> to capture the</span>
<span class="comment">% animation of the particle movements and forces.</span>

<span class="comment">%% General definitions</span>

<span class="comment">% layout definitions and plot customized <span class="keyword">function</span></span>
layercolors = struct( ...
    <span class="string">'fixed'</span>,rgb(<span class="string">'DodgerBlue'</span>),...
    <span class="string">'layer1'</span>,rgb(<span class="string">'DeepSkyBlue'</span>),...
    <span class="string">'layer2'</span>,rgb(<span class="string">'Aqua'</span>),...
    <span class="string">'layer3'</span>,rgb(<span class="string">'PaleTurquoise'</span>),...
    <span class="string">'obstacle'</span>,rgb(<span class="string">'Crimson'</span>) ...
);
layerplot = @(X) viscircles([X.xy],X.R*ones(X.n,1),<span class="string">'color'</span>,layercolors.(X.tag));

<span class="comment">% configuration functions</span>
layercoord = @(X) transpose([
            linspace(-(X.dx+X.R*2)*(X.n-1)/2,(X.dx+X.R*2)*(X.n-1)/2,X.n)
            ones(1,X.n) * (X.y + X.dy)
            ]);
layersliding = @(X) ones(X.n,1)*X.slidingdirection;
layerredistribute = @(X,x0) x0+[cumsum([0;diff(X.xy(:,1))]+abs(randn(X.n,1))*X.R*0.25)];

<span class="comment">% mathematical functions <span class="keyword">for</span> managing bead displacements</span>
imin = @(d) find(d==min(d),1,<span class="string">'first'</span>);
imin2 = @(d) find(d==min(d(d>min(d))),1,<span class="string">'first'</span>);
distance = @(xy) sqrt(sum(xy.^2,2));
dist2ref = @(ref,testxy) distance(ref.xy-testxy);
iclosest = @(ref,test) cellfun(@(testxy) imin(dist2ref(ref,testxy)),num2cell(test.xy,2));
iclosest2 = @(ref,test) cellfun(@(testxy) imin2(dist2ref(ref,testxy)),num2cell(test.xy,2));
distance2closest = @(ref,test) distance(ref.xy(iclosest(ref,test),:)-test.xy);
distance2closest2 = @(ref,test) distance(ref.xy(iclosest2(ref,test),:)-test.xy);
contractionfactor = @(ref,test) 1 - ref.R*2*(1-abs(randn(test.n,1)*0.02)) ./ distance2closest(ref,test);
contractionfactor2 = @(ref,test) 1 - ref.R*2*(1-abs(randn(test.n,1)*0.02)) ./ distance2closest(ref,test);
updatexy = @(ref,test) test.xy + (ref.xy(iclosest(ref,test),:)-test.xy) .* contractionfactor(ref,test);
updatexy2 = @(ref,test) test.xy + (ref.xy(iclosest2(ref,test),:)-test.xy) .* contractionfactor2(ref,test);
thermostat = @(v) v .*(1+randn(size(v))*0.04);

<span class="comment">% bead size (r) </span>
r = 0.5;

<span class="comment">% Kernel definitions</span>
<span class="comment">% The kernel <span class="keyword">function</span> is used to calculate the smoothing <span class="keyword">function</span></span>
<span class="comment">% <span class="keyword">for</span> the SPH method, and the parameters include the smoothing length (h),</span>
<span class="comment">% the density (rho), and the coefficients (c0 and q1) used in the Landshoff force calculation.</span>
h = 2 * r;
dWdr = @(r) (r<h) .* (1.0./h.^3.*(r./h-1.0).^3.*-1.5e+1)./pi-(1.0./h.^3.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*1.5e+1)./pi;
c0 = 10;
q1 = 1;
rho = 1000;

<span class="comment">%% Fixed layer</span>
fixed = struct( ...these particles are arbitrarily fixed
    <span class="string">'R'</span>,r, ... radius
    <span class="string">'n'</span>,32,... number of beads
    <span class="string">'xy'</span>,[],... coordinates
    <span class="string">'y'</span>,-r,... initial position
    <span class="string">'dx'</span>,1e-2,... distance between beads
    <span class="string">'dy'</span>,0,...
    <span class="string">'slidingdirection'</span>,[1 0],...
    <span class="string">'tag'</span>,<span class="string">'fixed'</span>,...
    <span class="string">'id'</span>,0 ...
    );
fixed.xy = layercoord(fixed);
fixed.xy(:,1) = layerredistribute(fixed,0);
fixed.slidingdirection = layersliding(fixed);

<span class="comment">%% Layer 1 (in contact with the fixed layer)</span>
layer1 = struct( ...these particles are arbitrarily fixed
    <span class="string">'R'</span>,r, ... radius
    <span class="string">'n'</span>,16,... number of beads
    <span class="string">'xy'</span>,[],... coordinates
    <span class="string">'y'</span>,+r,... initial position
    <span class="string">'dx'</span>,1e-2,... distance between beads
    <span class="string">'dy'</span>,1e-2,...
    <span class="string">'slidingdirection'</span>,[1 0],...
    <span class="string">'tag'</span>,<span class="string">'layer1'</span>,...
    <span class="string">'id'</span>,1 ...
    );
layer1.xy = layercoord(layer1);
layer1.xy(:,1) = layerredistribute(layer1,fixed.R);
layer1.slidingdirection = layersliding(layer1);


<span class="comment">% %% Layer 2 (in contact with the fixed layer)</span>
layer2 = struct( ...these particles are arbitrarily fixed
    <span class="string">'R'</span>,r, ... radius
    <span class="string">'n'</span>,14,... number of beads
    <span class="string">'xy'</span>,[],... coordinates
    <span class="string">'y'</span>,+2*r,... initial position
    <span class="string">'dx'</span>,1e-2,... distance between beads
    <span class="string">'dy'</span>,1e-2,...
    <span class="string">'slidingdirection'</span>,[1 0],...
    <span class="string">'tag'</span>,<span class="string">'layer2'</span>,...
    <span class="string">'id'</span>,2 ...
    );
layer2.xy = layercoord(layer2);
layer2.xy(:,1) = layerredistribute(layer2,layer1.xy(3,1)-fixed.R);
layer2.slidingdirection = layersliding(layer2);

<span class="comment">% %% Layer 3 (in contact with the fixed layer)</span>
layer3 = struct( ...these particles are arbitrarily fixed
    <span class="string">'R'</span>,r, ... radius
    <span class="string">'n'</span>,12,... number of beads
    <span class="string">'xy'</span>,[],... coordinates
    <span class="string">'y'</span>,+3*r,... initial position
    <span class="string">'dx'</span>,1e-2,... distance between beads
    <span class="string">'dy'</span>,1e-2,...
    <span class="string">'slidingdirection'</span>,[1 0],...
    <span class="string">'tag'</span>,<span class="string">'layer3'</span>,...
    <span class="string">'id'</span>,3 ...
    );
layer3.xy = layercoord(layer3);
layer3.xy(:,1) = layerredistribute(layer3,layer1.xy(4,1));
layer3.slidingdirection = layersliding(layer3);

<span class="comment">%% obstacle (in contact with the fixed layer)</span>
[i,j] = meshgrid(-1:1,-1:1); [i,j] = deal(i(:),j(:));
centers = [ 2*i + mod(j,2), sqrt(3)*j ]*r;
centers(sum(centers.^2,2)>1,:)=[];
obstacle = struct( ...these particles are arbitrarily fixed
    <span class="string">'R'</span>,r, ... radius
    <span class="string">'n'</span>,size(centers,1),... number of beads
    <span class="string">'xy'</span>,[
        centers(:,1)+fixed.xy(floor(fixed.n/2),1)+fixed.R*5-min(centers(:,1)), ...
        centers(:,2)+fixed.y+fixed.dy+fixed.R+r-min(centers(:,2))
        ],... coordinates
    <span class="string">'y'</span>,+r,... initial position
    <span class="string">'dx'</span>,0,... distance between beads
    <span class="string">'dy'</span>,0,...
    <span class="string">'slidingdirection'</span>,[
         0      1     <span class="comment">% SW</span>
         0      1     <span class="comment">% W</span>
         0.5    0.5   <span class="comment">% NW</span>
         1   -0.2        <span class="comment">% SE</span>
         NaN  NaN     <span class="comment">% center</span>
         0.5  -0.5    <span class="comment">% NE</span>
         0.5  -0.5    <span class="comment">% E</span>
         ],...
    <span class="string">'tag'</span>,<span class="string">'obstacle'</span>,...
    <span class="string">'id'</span>,100 ...
    );

<span class="comment">%% all fixed (<span class="keyword">for</span> collision only)</span>
allfixed = fixed;
allfixed.xy = [fixed.xy;obstacle.xy];
allfixed.slidingdirection = [fixed.slidingdirection;obstacle.slidingdirection];
allfixed.n = fixed.n + obstacle.n;

<span class="comment">%% control (only <span class="keyword">for</span> validating the design)</span>
clf, axis equal, hold on
layerplot(fixed)
layerplot(layer1)
layerplot(layer2)
layerplot(layer3)
ho=layerplot(obstacle);


<span class="comment">%% Dynamic plot</span>

<span class="comment">% initial position</span>
v = 4*0.1; <span class="comment">% velocity (arbitrary units)</span>
dt = 0.1;
[config1,config2,config3]  = deal(layer1, layer2, layer3);
clf, hold on, axis equal
layerplot(fixed);
ho=layerplot(obstacle);
[hp,ha] = deal([],{});
ax = axis;
axis off
RECORD = false; <span class="comment">% set it to true to record a video</span>

<span class="comment">% The code then enters a loop that simulates the movement of the particles over time.</span>
<span class="keyword">for</span> it=1:800
    <span class="comment">% layer2 neighbor</span>
    ineigh12 = iclosest(config1,config2);
    ineigh13 = iclosest(config1,config3);
    <span class="comment">% move of layer 1</span>
    vshift1 = thermostat(v * allfixed.slidingdirection(iclosest(allfixed,config1),:));
    vshift1 = distance(v)*vshift1./distance(vshift1);
    shift1 = dt * vshift1;
    lastxy1 = config1.xy;
    config1.xy = config1.xy + shift1;
    alternativexy = updatexy2(allfixed,config1); <span class="comment">% only alternative point</span>
    config1.xy = updatexy(allfixed,config1);
    realdisplacement1 = distance(config1.xy-lastxy1);
    istuck1 = realdisplacement1<0.01;
    <span class="keyword">if</span> any(istuck1)
        config1.xy(istuck1,:) = alternativexy(istuck1,:);
    <span class="keyword">end</span>
    <span class="comment">% move of layer 2</span>
    directionlayer1 = config1.xy-lastxy1./distance(config1.xy-lastxy1);
    vshift2 = thermostat(v * directionlayer1(iclosest(layer1,config2),:));
    shift1update = thermostat(config1.xy-lastxy1);
    shift2 = shift1update(ineigh12,:);
    vshift2 = shift2/dt;
    config2.xy = config2.xy + shift2;
    config2.xy = updatexy(config1,config2);

    <span class="comment">% move of layer 3</span>
    vshift3 = thermostat(v * directionlayer1(iclosest(layer1,config3),:));
    shift3 = shift1update(ineigh13,:);
    vshift3 = shift3/dt;
    config3.xy = config3.xy + shift3;
    config3.xy = updatexy(config2,config3);


    <span class="comment">%The Landshoff forces are then calculated using a nested loop that iterates</span>
    <span class="comment">% over all pairs of particles in both layers. The forces are calculated using</span>
    <span class="comment">% the kernel <span class="keyword">function</span> and the Landshoff force formula, which includes the velocity</span>
    <span class="comment">% difference and distance between particles, as well as the SPH parameters</span>
    id = [ allfixed.id * ones(allfixed.n,1); config1.id * ones(config1.n,1); config2.id * ones(config2.n,1); config3.id * ones(config3.n,1)];
    xy = [allfixed.xy; config1.xy; config2.xy; config3.xy];
    vxy = [repmat([0 0],allfixed.n,1); vshift1; vshift2; vshift3];
    n = allfixed.n + config1.n + config2.n + + config3.n;
    [mu,nu] = deal(zeros(n,n));
    F = zeros(n,n,2);
    <span class="keyword">for</span> i = 1:n
        <span class="keyword">for</span> j = 1:n
            rij = xy(i,:)-xy(j,:);
            vij = vxy(i,:)-vxy(j,:);
            <span class="keyword">if</span> dot(rij,vij)<0
                mu(i,j) = h * dot(rij,vij)/(dot(rij,rij)+0.01*h^2);
                nu(i,j) = (1/rho) * (-q1*c0*mu(i,j));
                rij_d = norm(rij);
                rij_n = rij/rij_d;
                F(i,j,:) = -nu(i,j)*dWdr(rij_d) * permute(rij_n,[1 3 2]);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    Fbalance = squeeze(sum(F,2));
    f = sum(Fbalance.^2,2);
    flog = log(1+f);
    flogmedian = median(flog(flog>0));
    flogmin = flogmedian/100;
    flogscale = 2*r/flogmedian;
    
    <span class="comment">%Finally, the forces are plotted as arrows on the particle plot using the "arrow" <span class="keyword">function</span>,</span>
    <span class="comment">% and the plot is updated with each iteration. </span>
    start = xy;
    stop = start + Fbalance./distance(Fbalance).*flog*flogscale;
    start(flog<flogmin,:) = [];
    stop(flog<flogmin,:) = [];
    <span class="keyword">if</span> ~isempty(hp), delete(hp{1}), delete(hp{2}), delete(hp{3}), <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(ha), delete(ha); <span class="keyword">end</span>
    hp = {layerplot(config1); layerplot(config2); layerplot(config3)};
    ha = [
        arrow(start,stop,<span class="string">'length'</span>,4,<span class="string">'BaseAngle'</span>,60,<span class="string">'Linewidth'</span>,1,<span class="string">'color'</span>,rgb(<span class="string">'ForestGreen'</span>),<span class="string">'Edgecolor'</span>,rgb(<span class="string">'ForestGreen'</span>))
        <span class="comment">%arrow(start,[stop(:,1) start(:,2)],<span class="string">'length'</span>,4,<span class="string">'BaseAngle'</span>,60,<span class="string">'color'</span>,rgb(<span class="string">'Tomato'</span>))</span>
        <span class="comment">%arrow(start,[start(:,1) stop(:,2)],<span class="string">'length'</span>,4,<span class="string">'BaseAngle'</span>,60,<span class="string">'color'</span>,rgb(<span class="string">'Tomato'</span>),<span class="string">'EdgeColor'</span>,rgb(<span class="string">'Tomato'</span>))</span>
    ];
    axis(ax)
    drawnow

   <span class="comment">%If the "RECORD" flag is set to true, the plot is also recorded as a GIF using the "gif_add_frame" <span class="keyword">function</span>.</span>
   <span class="keyword">if</span> RECORD
       gif_add_frame(gca,<span class="string">'landshoff_obstacle.gif'</span>,15);
   <span class="keyword">end</span>

<span class="keyword">end</span></code></pre></div>
</div>
<div id='Billy_results_template' class='doc-content' style='display: none;'>
<h1>First template to retrieve Billy&#x27;s paper 2 simulation data</h1>
<p>rev. 2024/03/07</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% First template to retrieve Billy<span class="string">'s paper 2 simulation data </span>
<span class="comment">% rev. 2024/03/07</span>

<span class="comment">% 2024/03/07 implementation of reverse streamlines, streamline binning from their initial positions, subsampling</span>
<span class="comment">% 2024/03/12 implement bead along streamlines (bug:NaN and Inf not allowed.) </span>
<span class="comment">%% path and metadata</span>
originalroot = '</span>/media/olivi/T7 Shield/Thomazo_V2<span class="string">';
<span class="keyword">if</span> exist(originalroot,'</span>dir<span class="string">')
    root = originalroot;
<span class="keyword">else</span>
    root = fullfile(pwd,'</span>smalldumps<span class="string">');
<span class="keyword">end</span>

simfolder = ...
    struct(...
    '</span>A1<span class="string">',struct('</span>artificial<span class="string">',...
'</span>Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz<span class="string">',...
    '</span>Morris<span class="string">',...
'</span>Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz<span class="string">' ...
                ),...
    '</span>A2<span class="string">',struct('</span>artificial<span class="string">',...
'</span>./Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_2.tar.gz<span class="string">' ...
    ),...
    '</span>B1<span class="string">',struct('</span>Morris<span class="string">',...
'</span>./Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft.tar.gz<span class="string">' ...
    ),...
    '</span>B2<span class="string">',struct('</span>Morris<span class="string">',...
'</span>Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_1.tar.gz<span class="string">' ...
    ),...
    '</span>B3<span class="string">',struct('</span>Morris<span class="string">',...
'</span>/Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_2_3.tar.gz<span class="string">' ...
    ) ...
    );

<span class="comment">% selection (not change it <span class="keyword">if</span> you do not have the full dataset/hard disk attached to your system)</span>
config = '</span>A1<span class="string">';
viscosity = '</span>Morris<span class="string">';
sourcefolder= fullfile(root,rootdir(simfolder.(config).(viscosity)));
sourcefile = regexprep(lastdir(simfolder.(config).(viscosity)),'</span>.tar.gz$<span class="string">','</span><span class="string">');
dumpfile = fullfile(sourcefolder,sourcefile);

<span class="comment">%% extract information</span>
X0 = lamdumpread2(dumpfile); <span class="comment">% first frame</span>
natoms = X0.NUMBER;
timesteps = X0.TIMESTEPS;
X1 = lamdumpread2(dumpfile,'</span>usesplit<span class="string">',[],timesteps(2));
dt = (X1.TIME-X0.TIME)/(timesteps(2)-timesteps(1)); <span class="comment">% integration time step</span>
times = double(timesteps * dt); <span class="comment">% in seconds </span>
atomtypes = unique(X0.ATOMS.type);
ntimesteps = length(timesteps);
T = X0.ATOMS.type;
natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
[~,ind] = sort(natomspertype,'</span>descend<span class="string">');
<span class="comment">% Thomazo simulation details</span>
fluidtype  = ind(1);
pillartype = ind(2);
walltype   = ind(3);
spheretype = ind(4);
coords = {'</span>z<span class="string">','</span>x<span class="string">','</span>y<span class="string">'}; <span class="comment">% to match Thomazo'</span>s movies</span>
vcoords = cellfun(@(c) sprintf(<span class="string">'v<span class="comment">%s'</span>,c),coords,<span class="string">'UniformOutput'</span>,false);</span>
<span class="comment">% Simulation parameters</span>
mbead = 4.38e-12; <span class="comment">% kg</span>
rho = 1000; <span class="comment">% kg / m3 (density of the fluid)</span>
Vbead = mbead/rho;

<span class="comment">%% Estimate bead size from the first frame</span>
<span class="comment">% first estimate assuming that the bead is a cube</span>
fluidxyz0 = X0.ATOMS{T==fluidtype,coords};
boxdims = X0.BOX(:,2) - X0.BOX(:,1);
Vbead_guess = prod(boxdims)/natoms;
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
[verletList,cutoff,dmin,config,dist] = buildVerletList(fluidxyz0,cutoff); <span class="comment">%#ok<ASGLU></span>
rbead = dmin/2;
s = 2*rbead; <span class="comment">% separation distance</span>
h = 2*s;     <span class="comment">% smoothing length</span>

<span class="comment">%% load the frame closest to simulation time: tframe</span>
<span class="comment">% with the mini dataset, are available:</span>
<span class="comment">% 0.30s 0.40s 0.45s 0.50s 0.55s 0.60s 0.65s 0.70s 0.75s 0.80s 0.85s 0.90s 0.95s 1.00s 1.05s 1.10s </span>
tframe = 0.8; <span class="comment">% s <-------------------- select time here </span>
iframe = nearestpoint(tframe,times); <span class="comment">% closest index</span>
Xframe = lamdumpread2(dumpfile,<span class="string">'usesplit'</span>,[],timesteps(iframe));
Xframe.ATOMS.isfluid = Xframe.ATOMS.type==fluidtype;
Xframe.ATOMS.ispillar = Xframe.ATOMS.type==pillartype;
Xframe.ATOMS.issphere = Xframe.ATOMS.type==spheretype;
Xframe.ATOMS.issolid = Xframe.ATOMS.type==spheretype | Xframe.ATOMS.type==pillartype;
fluidxyz = Xframe.ATOMS{Xframe.ATOMS.isfluid,coords};
fluidid = X0.ATOMS{Xframe.ATOMS.isfluid,<span class="string">'id'</span>};
pillarxyz = Xframe.ATOMS{Xframe.ATOMS.ispillar,coords};
pillarid = X0.ATOMS{Xframe.ATOMS.ispillar,<span class="string">'id'</span>};
spherexyz = Xframe.ATOMS{Xframe.ATOMS.issphere,coords};
sphereid = X0.ATOMS{Xframe.ATOMS.issphere,<span class="string">'id'</span>};
solidxyz = Xframe.ATOMS{Xframe.ATOMS.issolid,coords};
solidid = X0.ATOMS{Xframe.ATOMS.issolid,<span class="string">'id'</span>};
ztop = max(pillarxyz(:,3)); <span class="comment">% pillar top</span>

<span class="comment">%% Interpolate velocity field at z = ztop</span>
fluidbox = [ min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords})
    max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords}) ]<span class="string">';
fluidboxsize = double(diff(fluidbox,1,2)); <span class="comment">% <span class="keyword">for</span> control</span>
<span class="comment">% restrict interpolation to the viewbox</span>
viewbox = fluidbox; viewbox(3,:) = [ztop-2*h ztop+2*h];
insideviewbox = true(height(Xframe.ATOMS),1);
<span class="keyword">for</span> icoord = 1:3
    insideviewbox = insideviewbox ...
        & Xframe.ATOMS{:,coords{icoord}}>=viewbox(icoord,1) ...
        & Xframe.ATOMS{:,coords{icoord}}<=viewbox(icoord,2);
<span class="keyword">end</span>
XYZ  = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,coords}; <span class="comment">% fluid kernel centers</span>
vXYZ = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,vcoords}; <span class="comment">% velocity of fluid kernel centers</span>
XYZs = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.issolid,coords};
<span class="comment">% interpolation grid</span>
nresolution = [1024 1024 1];
xw = linspace(viewbox(1,1),viewbox(1,2),nresolution(1));
yw = linspace(viewbox(2,1),viewbox(2,2),nresolution(1));
zw = ztop;
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];
<span class="comment">% grid neighbors <span class="keyword">for</span> interpolation and discarding grid points overlapping solid</span>
VXYZ  = buildVerletList({XYZgrid XYZ},1.2*h);  <span class="comment">% neighbors = fluid particles</span>
VXYZs = buildVerletList({XYZgrid XYZs},0.85*s); <span class="comment">% neighbors = solid particles</span>
icontactsolid = find(cellfun(@length,VXYZs)>0);
VXYZ(icontactsolid) = repmat({[]},length(icontactsolid),1);
<span class="comment">% neighbors statistics <span class="keyword">for</span> control</span>
<span class="comment">% example with grid points having 20 neighbors or less: plot(XYZgrid(nn<20,1),XYZgrid(nn<20,2),'</span>o<span class="string">','</span>markerfacecolor<span class="string">','</span>k<span class="string">')</span>
<span class="comment">%{</span>
    nn = cellfun(@length,VXYZ);
    [nnu,~,innu] = unique(nn);
    cnnu = accumarray(innu,nn,[],@length);
<span class="comment">%}</span>

<span class="comment">% interpolation stuff</span>
W = kernelSPH(h,'</span>lucy<span class="string">',3); <span class="comment">% kernel expression</span>
v3XYZgrid = interp3SPHVerlet(XYZ,vXYZ,XYZgrid,VXYZ,W,Vbead);
vxXYZgrid = reshape(v3XYZgrid(:,1),size(Xw)); <span class="comment">%vxXYZgrid(isnan(vxXYZgrid)) = 0;</span>
vyXYZgrid = reshape(v3XYZgrid(:,2),size(Xw)); <span class="comment">%vyXYZgrid(isnan(vyXYZgrid)) = 0;</span>
vzXYZgrid = reshape(v3XYZgrid(:,3),size(Xw)); <span class="comment">%vzXYZgrid(isnan(vzXYZgrid)) = 0;</span>
vXYZgrid  = reshape(sqrt(sum(v3XYZgrid.^2,2)),size(Xw));

<span class="comment">%% Plot (attention 2D)</span>
figure, hold on
<span class="comment">% velocity magnitude</span>
imagesc(xw,yw,vXYZgrid)
axis tight, axis equal
<span class="comment">% quiver configuration and plot</span>
step = 8;
boundaries = [ nearestpoint(double(xw([1,<span class="keyword">end</span>]))+fluidboxsize(1)/30*[1 -1],double(xw))
               nearestpoint(double(yw([1,<span class="keyword">end</span>]))+fluidboxsize(2)/30*[1 -1],double(yw))
             ];
indxquiver = boundaries(1,1):step:boundaries(1,2);
indyquiver = boundaries(2,1):step:boundaries(2,2);
quiver(Xw(indxquiver,indyquiver),Yw(indxquiver,indyquiver), ...
          vxXYZgrid(indxquiver,indyquiver),vyXYZgrid(indxquiver,indyquiver), ...
        '</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',1)
<span class="comment">% streamline configuration and plot</span>
boundaries = [ nearestpoint(double(xw([1,<span class="keyword">end</span>]))+fluidboxsize(1)/30*[1 -1]*1.5,double(xw))
               nearestpoint(double(yw([1,<span class="keyword">end</span>]))+fluidboxsize(2)/30*[1 -1]*1,double(yw))
             ];
step = step/2;
indxstreamline = boundaries(1,1):step:boundaries(1,2);
indystreamline = boundaries(2,1):step:boundaries(2,2);
nstreamlines = length(indxstreamline);
<span class="comment">% streamlines from bottom to top</span>
[startX,startY,startZ] = meshgrid(double(xw(indxstreamline)),double(yw(indystreamline(1))),double(ztop));
vertices = stream2(double(Xw),double(Yw),vxXYZgrid,vyXYZgrid,startX,startY);
xinitialposition = cellfun(@(v) v(1,1),vertices);
yinitialposition = cellfun(@(v) v(1,2),vertices);
xfinalposition = cellfun(@(v) v(<span class="keyword">end</span>,1),vertices);
yfinalposition = cellfun(@(v) v(<span class="keyword">end</span>,2),vertices);
yfinaldefaultposition = yfinalposition(find(~isnan(yfinalposition),1,'</span>first<span class="string">'));
indclosestToInitial = nearestpoint(xfinalposition,xinitialposition);
isinterrupted = isnan(yfinalposition);
<span class="comment">% Build the adjacency matrix the initial and final position</span>
A = false(nstreamlines,nstreamlines); <span class="comment">%initial x final positions</span>
<span class="keyword">for</span> i=1:nstreamlines
    <span class="keyword">if</span> ~isnan(indclosestToInitial(i))
        A(i,indclosestToInitial(i)) = true;
    <span class="keyword">end</span>
<span class="keyword">end</span>
isreached = any(A,1);
<span class="comment">% Missinf streamlines from top to bottom</span>
[startX2,startY2,startZ2] = meshgrid(xinitialposition(~isreached),yfinaldefaultposition,double(ztop));
vertices2 = stream2(double(Xw),double(Yw),-vxXYZgrid,-vyXYZgrid,startX2,startY2);
<span class="comment">% streamlines from top to bottom (<span class="keyword">for</span> unreached positions)</span>

<span class="comment">% control plot</span>
<span class="comment">% figure, hold on</span>
<span class="comment">% colors = tooclear(parula(nstreamlines));</span>
<span class="comment">% <span class="keyword">for</span> i=1:nstreamlines</span>
<span class="comment">%     <span class="keyword">if</span> isinterrupted(i)</span>
<span class="comment">%         plot(vertices{i}(:,1),vertices{i}(:,2),'</span>-<span class="string">','</span>linewidth<span class="string">',2,'</span>color<span class="string">',colors(i,:));</span>
<span class="comment">%     <span class="keyword">else</span></span>
<span class="comment">%         plot(vertices{i}(:,1),vertices{i}(:,2),'</span>--<span class="string">','</span>linewidth<span class="string">',2,'</span>color<span class="string">',colors(i,:));</span>
<span class="comment">%         plot( [xinitialposition(i);xinitialposition(indclosestToInitial(i))],...</span>
<span class="comment">%               [yinitialposition(i);yfinaldefaultposition],...</span>
<span class="comment">%               '</span>-<span class="string">','</span>linewidth<span class="string">',2,'</span>color<span class="string">',colors(i,:))</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">%     text(xinitialposition(i),yinitialposition(i),sprintf('</span>%d<span class="string">',i),'</span>fontsize<span class="string">',8,'</span>fontweight<span class="string">','</span>bold<span class="string">','</span>HorizontalAlignment<span class="string">','</span>center<span class="string">','</span>VerticalAlignment<span class="string">','</span>middle<span class="string">')</span>
<span class="comment">%     <span class="keyword">if</span> isreached(i), col = '</span>blue<span class="string">'; <span class="keyword">else</span> col = '</span>red<span class="string">'; <span class="keyword">end</span></span>
<span class="comment">%     text(xinitialposition(i),yfinaldefaultposition,sprintf('</span>%d<span class="string">',i),'</span>fontsize<span class="string">',8,'</span>fontweight<span class="string">','</span>bold<span class="string">','</span>HorizontalAlignment<span class="string">','</span>center<span class="string">','</span>VerticalAlignment<span class="string">','</span>middle<span class="string">','</span>color<span class="string">',col)</span>
<span class="comment">% <span class="keyword">end</span></span>

<span class="comment">% Merge all streamlines and create flags</span>
allvertices = [vertices,vertices2];
idvertices = [ones(1,length(vertices)),2*ones(1,length(vertices2))];
[xallvertices,ind] = sort(cellfun(@(v) v(1,1),allvertices),'</span>ascend<span class="string">'); <span class="comment">% mean(v(:,1),'</span>omitnan<span class="string">')</span>
allvertices = allvertices(ind);
idvertices = idvertices(ind);
allbroken = cellfun(@(v) any(isnan(v(:,1))),allvertices);
allcomplete = ~allbroken;
allup =  cellfun(@(v) v(2,2)>v(1,2),allvertices);
alldown = ~allup;

<span class="comment">% Pick streamlines from binning</span>
nbins = 80;
xbins = linspace(xinitialposition(1),xinitialposition(<span class="keyword">end</span>),nbins); <span class="comment">% desired bin centers</span>
dxbins = xbins(2)-xbins(1); <span class="comment">% bin width (<span class="keyword">for</span> control)</span>
<span class="comment">% Binning <span class="keyword">for</span> complete streamlines</span>
ibinsall = nearestpoint(xbins,xallvertices); <span class="comment">%interpleft(xallvertices,1:length(allvertices),xbins);</span>
ibinsall = ibinsall(allcomplete(ibinsall)); <span class="comment">% we keep complete</span>
<span class="comment">% extract the initial (0) and final (1) positions of up/down streamlines</span>
isselected = false(1,length(allvertices)); isselected(ibinsall)=true;
x0up = cellfun(@(v) v(1,1),allvertices(isselected & allup));
x1up = cellfun(@(v) v(<span class="keyword">end</span>,1),allvertices(isselected & allup));
x0down = cellfun(@(v) v(1,1),allvertices(isselected & alldown));
x1down = cellfun(@(v) v(<span class="keyword">end</span>,1),allvertices(isselected & alldown));
xdeviation = cellfun(@(v) abs(v(1,1)-v(<span class="keyword">end</span>,1)),allvertices(isselected)); <span class="comment">% <span class="keyword">for</span> control</span>
<span class="comment">% Binning from incomplete (broken) streamlines</span>
<span class="comment">% all bins required</span>
xbins_broken = xbins(setdiff(1:nbins,nearestpoint(xallvertices(ibinsall),xbins)));
<span class="keyword">if</span> isempty(x1down)
    valid_up = true(size(xbins_broken));
<span class="keyword">else</span>
    valid_up = abs(x1down(nearestpoint(xbins_broken,x1down))-xbins_broken)>(0.5*dxbins);
<span class="keyword">end</span>
<span class="keyword">if</span> isempty(x1up)
    valid_down = true(size(xbins_broken));
<span class="keyword">else</span>
    valid_down = abs(x1up(nearestpoint(xbins_broken,x1up))-xbins_broken)>(0.5*dxbins);
<span class="keyword">end</span>
iupbroken = find(allup & allbroken);
xupbroken = xallvertices(iupbroken);
ibinsupbroken = iupbroken(nearestpoint(xbins_broken(valid_up),xupbroken));
idownbroken = find(alldown & allbroken);
xdownbroken = xallvertices(idownbroken);
ibinsdownbroken = idownbroken(nearestpoint(xbins_broken(valid_down),xdownbroken));
<span class="comment">% Merge and sort all bins</span>
ibins = unique([ibinsall,ibinsdownbroken,ibinsupbroken]);

<span class="comment">% check <span class="keyword">for</span> holes/gaps between streamlines and overlopping streamlines</span>
<span class="comment">% The two passes are sequenced to avoid an infinite loop between fill/remove steps</span>
<span class="comment">% pass 1: fill the gaps (bottom and top) iteratively</span>
<span class="comment">% pass 1: remove ovelaps (bottom and top) iteratively (this step is always after the first filling procedure)</span>
<span class="comment">% pass 2: fill the gaps (bottom and top)</span>
[holechecked, overlapchecked] = deal(false);
gapthreshmax = 1.9; <span class="comment">% max gap (1=bin distance)</span>
gapthreshmin = 0.5; <span class="comment">% minimum gap</span>
iter = 0; maxiter = 100;
pass2 = false;
<span class="keyword">while</span> (~holechecked || ~overlapchecked) && iter<maxiter
    iter = iter + 1;
    ispicked = false(1,length(allvertices)); ispicked(ibins)=true;
    xbottom = union(cellfun(@(v) v(1,1),allvertices(ispicked & allup)),...
                    cellfun(@(v) v(<span class="keyword">end</span>,1),allvertices(ispicked & allcomplete & alldown)));
    dxbottom = diff(xbottom)/dxbins;
    <span class="keyword">if</span> any(dxbottom>gapthreshmax) && ~holechecked
        xholebottom = xallvertices(ibins(nearestpoint(xbottom(dxbottom>gapthreshmax),xallvertices(ibins))))+dxbins;
        iup = find(allup);
        ibinsholebottom = iup(nearestpoint(xholebottom,xallvertices(allup)));
        ibins = union(ibins,ibinsholebottom);
        holecheckbottom = false;
        overlapcheckbottom = false;
        dispf('</span>add <span class="comment">%d streamlines to the bottom<span class="string">',length(ibinsholebottom))</span>
    <span class="keyword">elseif</span> ~holechecked
        holecheckbottom = true;
    <span class="keyword">elseif</span> any(dxbottom<gapthreshmin) && ~pass2
        ioverlapbottom = nearestpoint(xbottom(dxbottom<gapthreshmin),xallvertices(ibins));
        ibins(ioverlapbottom) = [];
        overlapcheckbottom = false;
        dispf('</span>remove <span class="comment">%d streamlines from the bottom<span class="string">',length(ioverlapbottom))</span>
    <span class="keyword">else</span>
         overlapcheckbottom = true;
    <span class="keyword">end</span>
    ispicked = false(1,length(allvertices)); ispicked(ibins)=true;
    xtop = union(   cellfun(@(v) v(<span class="keyword">end</span>,1),allvertices(ispicked & allcomplete & allup)),...
                    cellfun(@(v) v(1,1),allvertices(ispicked & alldown)));
    dxtop = diff(xtop)/dxbins;
    <span class="keyword">if</span> any(dxtop>gapthreshmax) && ~holechecked
        xholetop = xallvertices(ibins(nearestpoint(xtop(dxtop>gapthreshmax),xallvertices(ibins))))+dxbins;
        idown = find(alldown);
        ibinsholetop = idown(nearestpoint(xholetop,xallvertices(alldown)));
        ibins = union(ibins,ibinsholetop);
        holechecktop = false;
        overlapchecktop = false;
        dispf('</span>add <span class="comment">%d streamlines to the top<span class="string">',length(ibinsholetop))</span>
    <span class="keyword">elseif</span> ~holechecked
        holechecktop = true;
    <span class="keyword">elseif</span> any(dxtop<gapthreshmin) && ~pass2
        ioverlaptop = nearestpoint(xbottom(dxtop<gapthreshmin),xallvertices(ibins));
        ibins(ioverlaptop) = [];
        overlapcheckbottom = false;
        dispf('</span>remove <span class="comment">%d streamlines from the top<span class="string">',length(ioverlaptop))</span>
    <span class="keyword">else</span>
        overlapchecktop = true;
    <span class="keyword">end</span>
    holechecked = holecheckbottom && holechecktop;
    overlapchecked = overlapcheckbottom && overlapchecktop;
    <span class="keyword">if</span> overlapchecked && ~pass2
        pass2=true;
        holechecked = false; <span class="comment">% we restart the filling gap correction</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> iter>=maxiter, error('</span>Gaps cannot be filled, decrease step (current=<span class="comment">%d) !<span class="string">', step), <span class="keyword">end</span></span>

<span class="comment">% plot streamlines</span>
hsl = streamline(allvertices); set(hsl,'</span>linewidth<span class="string">',0.1,'</span>color<span class="string">',[0.8 0.8 0.8]);
hsl = streamline(allvertices(ibins)); set(hsl,'</span>linewidth<span class="string">',2,'</span>color<span class="string">',[0.4375    0.5000    0.5625])
plot(startX(:),startY(:),'</span>ro<span class="string">','</span>markerfacecolor<span class="string">',[0.4375    0.5000    0.5625])


<span class="comment">%% put beads along selected streamlines </span>
<span class="comment">% get informations of streamlines</span>
sl = allvertices(ibins);
nsl = length(sl); <span class="comment">% number of selected streamlines</span>
sall = cell(1,nsl);
<span class="keyword">for</span> i=1:nsl
    csl = sl{i}; <span class="comment">% select current streamline</span>
    xcsl = csl(:,1); ycsl = csl(:,2);
    Tcsl = [diff(xcsl) diff(ycsl); NaN NaN];
    Tcsl_norm = Tcsl./sqrt(sum(Tcsl.^2,2));
    lcsl = [0; cumsum(sqrt(sum(Tcsl(1:<span class="keyword">end</span>-1,:).^2,2)))];
    Vxcsl = interp2(Xw,Yw,vxXYZgrid,xcsl,ycsl);
    Vycsl = interp2(Xw,Yw,vyXYZgrid,xcsl,ycsl);
    Vcsl = [Vxcsl,Vycsl];
    Vlcsl = dot(Vcsl,Tcsl_norm,2);
    s = table(xcsl,ycsl,lcsl,Tcsl_norm,Vcsl,Vlcsl,'</span>VariableNames',["x","y","l","T","V","Vl"]);
    sall{i} = s;
<span class="keyword">end</span>
<span class="comment">% put beads</span>
dt = 0.01;
figure, hold on
<span class="keyword">for</span> i=1:nsl
    [x,y,Vl,l] = add_bead(sall{i},rbead,dt);
    centers = [x,y];
    viscircles(centers,rbead)
<span class="keyword">end</span></code></pre></div>
</div>
<div id='Billy_results_template_PBC' class='doc-content' style='display: none;'>
<h1>First template to retrieve Billy&#x27;s paper 2 simulation data</h1>
<p>rev. 2024/03/17 - forked in 2024/03/16 with PBC</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% First template to retrieve Billy<span class="string">'s paper 2 simulation data </span>
<span class="comment">% rev. 2024/03/17 - forked in 2024/03/16 with PBC</span>

<span class="comment">% 2024/03/07 implementation of reverse streamlines, streamline binning from their initial positions, subsampling</span>
<span class="comment">% 2024/03/12 implement bead along streamlines (bug:NaN and Inf not allowed.) </span>
<span class="comment">% 2024/03/16 fork from Billy_results_template.m (MAJOR UPDATE)</span>
<span class="comment">% 2024/03/17 release candidate</span>
<span class="comment">% 2024/03/21 preproduction on minidump</span>
<span class="comment">% 2024/03/24 major update: full implementation of density correction and force contours around objects</span>
<span class="comment">% 2024/03/24 selective copy possible <span class="keyword">if</span> originalroot is made available</span>
<span class="comment">% 2024/03/24 add prefetch management</span>
<span class="comment">% 2024/03/25 first batch of preproduction tframe 0.3->1.1 (step 0.01)</span>
<span class="comment">% 2024/03/26 second batch of preproduction tframe 0.11->0.4 (step 0.01)</span>
<span class="comment">% 2024/03/27 fix streamlines when less than one bead must be added (tframe = 0.11 and 0.27)</span>
<span class="comment">% 2024/03/27 fix contour, tangents/normals, add perssure</span>
<span class="comment">% 2024/03/27 Senstivity challenge test using ngenerations = 8 and xshift = double(mod(igen-1,2)*(xwPBC(indxstreamline(2))-xwPBC(indxstreamline(1))));</span>
<span class="comment">% 2024/03/30 full implementation of Landshoff forces</span>
<span class="comment">% 2024/03/31 add FLAGS, documentation and save results capability (R0 and R1 <span class="keyword">for</span> original and informed results, respectively) </span>
<span class="comment">% 2024/03/31 full rewritting of PLOT capabilities to use exclusively R0 and R1 <span class="keyword">for</span> plotting</span>

<span class="comment">% SUMMARY</span>

<span class="comment">% This MATLAB script is a comprehensive framework <span class="keyword">for</span> analyzing fluid dynamics simulations, specifically focusing on the distribution and movement of particles or beads in a fluid environment. Key functionalities include:</span>
<span class="comment">% </span>
<span class="comment">% 1. Environment Setup:</span>
<span class="comment">%   Initializes the simulation environment by clearing variables, setting up output folders, and defining file paths to simulation data, with adjustments <span class="keyword">for</span> periodic boundary conditions (PBC).</span>
<span class="comment">% 2. Data Retrieval:</span>
<span class="comment">%   Loads simulation data from specified file paths, handling different configurations and viscosity models.</span>
<span class="comment">% 3. Simulation Analysis:</span>
<span class="comment">%   Processes the simulation data to calculate parameters such as bead sizes, timestep intervals, and spatial distributions of particles.</span>
<span class="comment">% 4. Frame Selection:</span>
<span class="comment">%   Identifies simulation frames <span class="keyword">for</span> detailed analysis based on time criteria, with capabilities to adjust <span class="keyword">for</span> available data subsets.</span>
<span class="comment">% 5. Velocity Field and Density Calculation:</span>
<span class="comment">%   Computes the velocity field at a specific plane in the simulation domain and estimates the local density of particles.</span>
<span class="comment">% 6. Streamline and Bead Distribution Analysis:</span>
<span class="comment">%   Generates streamlines and distributes beads along these lines, incorporating PBC adjustments to simulate continuous fluid flow across boundaries.</span>
<span class="comment">% 7. Overlap Removal:</span>
<span class="comment">%   Implements algorithms to remove overlapping beads based on their spatial proximity and streamline generation, ensuring a realistic particle distribution.</span>
<span class="comment">% 8. Density Filtering:</span>
<span class="comment">%   Filters out beads in regions of excessively high simulated density to adhere to physical constraints.</span>
<span class="comment">% 9. Contact Detection with Objects:</span>
<span class="comment">%   Identifies beads in contact with solid objects within the simulation, leveraging density information to infer interaction dynamics.</span>
<span class="comment">% 10. Visual Representation:</span>
<span class="comment">%   Provides extensive plotting capabilities to visualize various aspects of the simulation, including velocity fields, bead distributions, and pressure around objects, with options to export figures.</span>


<span class="comment">%% Definitions (it is a script accepting ONE variable and FLAGS)</span>
<span class="comment">%</span>
<span class="comment">%   List of of variables</span>
<span class="comment">%           tframe <-- use this variable a in <span class="keyword">for</span>-loop or choose a particular frame before calling this script</span>
<span class="comment">%       tframelist (not used)</span>
<span class="comment">%</span>
<span class="comment">%   List of available FLAGS</span>
<span class="comment">%       RESETPREFETCH forces all prefetch files to be regenerated in true (default=false)</span>
<span class="comment">%              PLOTON enables to plot results (default=true)</span>
<span class="comment">%             PRINTON prints figures as PNG images <span class="keyword">for</span> control (in outputfolder) (default=false)</span>
<span class="comment">%              SAVEON saves the results R0 (original), R1 (informed) (default=true)</span>
<span class="comment">%           OVERWRITE enables already saved results to overwritte (default=false)</span>

<span class="comment">% close, delete everything except variables and FLAGS</span>
clc
close all
clearvars -except tframe tframelist RESETPREFETCH PLOTON PRINTON SAVEON OVERWRITE
t0_ = clock;

<span class="comment">% check folders</span>
outputfolder = fullfile(pwd,'</span>preproduction<span class="string">');
savefolder = fullfile(pwd,'</span>results<span class="string">');
prefetchfolder = fullfile(pwd,'</span>prefetch<span class="string">');
<span class="keyword">if</span> ~exist(outputfolder,'</span>dir<span class="string">'), mkdir(outputfolder); <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(prefetchfolder,'</span>dir<span class="string">'), mkdir(prefetchfolder); <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(savefolder,'</span>dir<span class="string">'), mkdir(savefolder); <span class="keyword">end</span>

<span class="comment">% Assign default values <span class="keyword">if</span> needed</span>
<span class="keyword">if</span> ~exist('</span>RESETPREFETCH<span class="string">','</span>var<span class="string">'), RESETPREFETCH = false; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist('</span>PLOTON<span class="string">','</span>var<span class="string">'), PLOTON = true; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist('</span>PRINTON<span class="string">','</span>var<span class="string">'), PRINTON = false; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist('</span>SAVEON<span class="string">','</span>var<span class="string">'), SAVEON = true; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist('</span>OVERWRITE<span class="string">','</span>var<span class="string">'), OVERWRITE = false; <span class="keyword">end</span>

<span class="comment">% Anonymous functions</span>
prefetchvar = @(varargin) fullfile(prefetchfolder,sprintf('</span>t<span class="comment">%0.4f_%s.mat<span class="string">',tframe,varargin{1}));</span>
isprefetch = @(varargin) exist(prefetchvar(varargin{1}),'</span>file<span class="string">') && ~RESETPREFETCH;
dispsection = @(s) dispf('</span>\n<span class="comment">%s\ntframe=%0.4g s \t[  %s  ]   elapsed time: %4g s\n%s<span class="string">',repmat('</span>*<span class="string">',1,120),tframe,regexprep(upper(s),'</span>.<span class="string">','</span>$0 <span class="string">'),etime(clock,t0_),repmat('</span>*<span class="string">',1,120)); %#ok<DETIM></span>
fighandle = @(id) formatfig(figure,'</span>figname<span class="string">',sprintf('</span>t<span class="comment">%0.3g_%s<span class="string">',tframe,id));</span>
printhandle = @(hfig) print_png(300,fullfile(outputfolder,[get(hfig,'</span>filename<span class="string">') '</span>.png<span class="string">']),'</span><span class="string">','</span><span class="string">',0,0,0);

<span class="comment">% results saved in two variables to avoid any confusion</span>
R0 = struct([]); <span class="comment">% reference data</span>
R1 = struct([]);  <span class="comment">% informed ones</span>

<span class="comment">%% path and metadata</span>
dispsection('</span>INITIALIZATION<span class="string">')
originalroot = '</span>/media/olivi/T7 Shield/Thomazo_V2<span class="string">';
<span class="keyword">if</span> exist(originalroot,'</span>dir<span class="string">')
    root = originalroot;
    rootlocal = fullfile(pwd,'</span>smalldumps<span class="string">');
    copymode = true;
<span class="keyword">else</span>
    root = fullfile(pwd,'</span>smalldumps<span class="string">');
    copymode = false;
<span class="keyword">end</span>

simfolder = ...
    struct(...
    '</span>A1<span class="string">',struct('</span>artificial<span class="string">',...
'</span>Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz<span class="string">',...
    '</span>Morris<span class="string">',...
'</span>Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz<span class="string">' ...
                ),...
    '</span>A2<span class="string">',struct('</span>artificial<span class="string">',...
'</span>./Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_2.tar.gz<span class="string">' ...
    ),...
    '</span>B1<span class="string">',struct('</span>Morris<span class="string">',...
'</span>./Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft.tar.gz<span class="string">' ...
    ),...
    '</span>B2<span class="string">',struct('</span>Morris<span class="string">',...
'</span>Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_1.tar.gz<span class="string">' ...
    ),...
    '</span>B3<span class="string">',struct('</span>Morris<span class="string">',...
'</span>/Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_2_3.tar.gz<span class="string">' ...
    ) ...
    );

<span class="comment">% selection (not change it <span class="keyword">if</span> you do not have the full dataset/hard disk attached to your system)</span>
config = '</span>A1<span class="string">';
viscosity = '</span>Morris<span class="string">';
sourcefolder= fullfile(root,rootdir(simfolder.(config).(viscosity)));
sourcefile = regexprep(lastdir(simfolder.(config).(viscosity)),'</span>.tar.gz$<span class="string">','</span><span class="string">');
dumpfile = fullfile(sourcefolder,sourcefile);
dispf('</span>config: <span class="comment">%s | viscosity: %s | source: %s<span class="string">',config,viscosity,dumpfile)</span>

<span class="comment">%% extract information</span>
dispsection('</span>OVERVIEW<span class="string">')
X0 = lamdumpread2(dumpfile); <span class="comment">% first frame</span>
natoms = X0.NUMBER;
timesteps = X0.TIMESTEPS;
X1 = lamdumpread2(dumpfile,'</span>usesplit<span class="string">',[],timesteps(2));
dt = (X1.TIME-X0.TIME)/(timesteps(2)-timesteps(1)); <span class="comment">% integration time step</span>
times = double(timesteps * dt); <span class="comment">% in seconds </span>
atomtypes = unique(X0.ATOMS.type);
ntimesteps = length(timesteps);
T = X0.ATOMS.type;
natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
[~,ind] = sort(natomspertype,'</span>descend<span class="string">');
<span class="comment">% Thomazo simulation details</span>
fluidtype  = ind(1);
pillartype = ind(2);
walltype   = ind(3);
spheretype = ind(4);
coords = {'</span>z<span class="string">','</span>x<span class="string">','</span>y<span class="string">'}; <span class="comment">% to match Thomazo'</span>s movies</span>
vcoords = cellfun(@(c) sprintf(<span class="string">'v<span class="comment">%s'</span>,c),coords,<span class="string">'UniformOutput'</span>,false);</span>
icoords = cellfun(@(c) find(ismember({<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>},c)),coords); <span class="comment">%<- use this index <span class="keyword">for</span> BOX</span>
<span class="comment">% Simulation parameters</span>
<span class="comment">% Billy choose a reference density of 900 kg/m3 <span class="keyword">for</span> a physical density of 1000 kg/m3</span>
<span class="comment">% Viscosity: 0.13 Pa.s</span>
mbead = 4.38e-12; <span class="comment">% kg</span>
rho = 1000; <span class="comment">% kg / m3 (density of the fluid)</span>
Vbead = mbead/rho;
dispf(<span class="string">'SUMMARY: natoms: <span class="comment">%d | dt: %0.3g s | rho: %0.4g'</span>,natoms,dt,rho)</span>

<span class="comment">%% selective copy of PREFETCH files (<span class="keyword">if</span> possible)</span>
<span class="keyword">if</span> copymode
    dispsection(<span class="string">'COPY'</span>)
    myprefetchfile = @(itime) sprintf(<span class="string">'<span class="comment">%s%09d.mat'</span>,<span class="string">'TIMESTEP_'</span>,itime);</span>
    myprefetchfolder = @(d) fullfile(d,sprintf(<span class="string">'PREFETCH_<span class="comment">%s'</span>,lastdir(dumpfile)));</span>
    destinationfolder = fullfile(rootlocal,rootdir(simfolder.(config).(viscosity)));
    sourcefolderPREFETCH = myprefetchfolder(sourcefolder);
    destinationfolderPREFETCH = myprefetchfolder(destinationfolder);
    <span class="comment">% Choose the frames needed here</span>
    tcopy = 0.0:0.01:1.2;
    <span class="comment">% files to copy</span>
    tfile = arrayfun(@(t) myprefetchfile(t), timesteps(unique(nearestpoint(tcopy,times))),<span class="string">'UniformOutput'</span>,false);
    oksource = all(cellfun(@(f) exist(fullfile(sourcefolderPREFETCH,f),<span class="string">'file'</span>),tfile));
    <span class="keyword">if</span> ~oksource, error(<span class="string">'the source folder is corrupted, please check'</span>), <span class="keyword">end</span>
    existingfiles = cellfun(@(f) exist(fullfile(destinationfolderPREFETCH,f),<span class="string">'file'</span>),tfile);
    dispf(<span class="string">'Number of files to copy: <span class="comment">%d (%d already available)'</span>,length(find(~existingfiles)),length(find(existingfiles)))</span>
    copysuccess = cellfun(@(f) copyfile(fullfile(sourcefolderPREFETCH,f),fullfile(destinationfolderPREFETCH,f)),tfile(~existingfiles));
    dispf(<span class="string">'<span class="comment">%d of %d files have been copied'</span>,length(find(copysuccess)),length(copysuccess));</span>
<span class="keyword">end</span>

<span class="comment">%% Estimate bead size from the first frame</span>
<span class="comment">% first estimate assuming that the bead is a cube</span>
dispsection(<span class="string">'BEAD SIZE'</span>)
fluidxyz0 = X0.ATOMS{T==fluidtype,coords};
boxdims = X0.BOX(:,2) - X0.BOX(:,1);
Vbead_guess = prod(boxdims)/natoms;
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
<span class="keyword">if</span> isprefetch(<span class="string">'verletList'</span>)
    load(prefetchvar(<span class="string">'verletList'</span>))
<span class="keyword">else</span>
    [verletList,cutoff,dmin,config,dist] = buildVerletList(fluidxyz0,cutoff);
    save(prefetchvar(<span class="string">'verletList'</span>),<span class="string">'verletList'</span>,<span class="string">'cutoff'</span>,<span class="string">'dmin'</span>,<span class="string">'config'</span>,<span class="string">'dist'</span>)
<span class="keyword">end</span>
rbead = dmin/2;
s = 2*rbead; <span class="comment">% separation distance</span>
h = 2*s;     <span class="comment">% smoothing length</span>
dispf(<span class="string">'SUMMARY: s: <span class="comment">%0.4g m | h: %0.4g m'</span>,s,h)</span>
<span class="comment">%% load the frame closest to simulation time: tframe</span>
<span class="comment">% with the mini dataset, are available:</span>
<span class="comment">% 0.30s 0.40s 0.45s 0.50s 0.55s 0.60s 0.65s 0.70s 0.75s 0.80s 0.85s 0.90s 0.95s 1.00s 1.05s 1.10s </span>
<span class="comment">% tframelist = [0.3 0.4 0.45:0.05:1.10]; % verysmalldumps</span>
tframelist = 0.0:0.01:1.2; <span class="comment">% updated time frames</span>
<span class="keyword">if</span> ~exist(<span class="string">'tframe'</span>,<span class="string">'var'</span>)
    tframe = 0.85; <span class="comment">%0.55; % s <-------------------- select time here</span>
<span class="keyword">else</span>
    tframe = tframelist(nearestpoint(tframe,tframelist)); <span class="comment">% restrict to existing tframes</span>
<span class="keyword">end</span>
iframe = nearestpoint(tframe,times); <span class="comment">% closest index</span>
Xframe = lamdumpread2(dumpfile,<span class="string">'usesplit'</span>,[],timesteps(iframe));
Xframe.ATOMS.isfluid = Xframe.ATOMS.type==fluidtype;
Xframe.ATOMS.ispillar = Xframe.ATOMS.type==pillartype;
Xframe.ATOMS.issphere = Xframe.ATOMS.type==spheretype;
Xframe.ATOMS.issolid = Xframe.ATOMS.type==spheretype | Xframe.ATOMS.type==pillartype;
fluidxyz = Xframe.ATOMS{Xframe.ATOMS.isfluid,coords};
fluidid = X0.ATOMS{Xframe.ATOMS.isfluid,<span class="string">'id'</span>};
pillarxyz = Xframe.ATOMS{Xframe.ATOMS.ispillar,coords};
pillarid = X0.ATOMS{Xframe.ATOMS.ispillar,<span class="string">'id'</span>};
spherexyz = Xframe.ATOMS{Xframe.ATOMS.issphere,coords};
sphereid = X0.ATOMS{Xframe.ATOMS.issphere,<span class="string">'id'</span>};
solidxyz = Xframe.ATOMS{Xframe.ATOMS.issolid,coords};
solidid = X0.ATOMS{Xframe.ATOMS.issolid,<span class="string">'id'</span>};
ztop = max(pillarxyz(:,3)); <span class="comment">% pillar top</span>

<span class="comment">% Definitions based on actual tframe</span>
dispsection = @(s) dispf(<span class="string">'\n<span class="comment">%s\ntframe=%0.4g s \t[  %s  ]   elapsed time: %4g s\n%s'</span>,repmat(<span class="string">'*'</span>,1,120),tframe,regexprep(upper(s),<span class="string">'.'</span>,<span class="string">'$0 '</span>),etime(clock,t0_),repmat(<span class="string">'*'</span>,1,120)); %#ok<DETIM></span>
prefetchvar = @(varargin) fullfile(prefetchfolder,sprintf(<span class="string">'t<span class="comment">%0.4f_%s.mat'</span>,tframe,varargin{1}));</span>
isprefetch = @(varargin) exist(prefetchvar(varargin{1}),<span class="string">'file'</span>) && ~RESETPREFETCH;
savefile = @() fullfile(savefolder,sprintf(<span class="string">'Rt.<span class="comment">%0.4f.mat'</span>,tframe));</span>


<span class="comment">%% Interpolate velocity field at z = ztop</span>
dispsection(<span class="string">'REFERENCE VELOCITY FIELD'</span>)
<span class="comment">% full box (note that atoms may be outside of this box)</span>
box = Xframe.BOX(icoords,:); <span class="comment">% note that the order is given by coords, here {<span class="string">'z'</span>}    {<span class="string">'x'</span>}    {<span class="string">'y'</span>}</span>
boxsize = diff(box,1,2);
<span class="comment">% fluidbox (box <span class="keyword">for</span> atoms to consider)</span>
xmin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{1}});
xmax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{1}});
ymin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{2}});
ymax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{2}});
zmin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{3}});
zmax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{3}});
fluidbox = [xmin xmax;ymin ymax;zmin zmax];
<span class="comment">% restrict interpolation to the viewbox</span>
viewbox = fluidbox; viewbox(3,:) = [ztop-2*h ztop+2*h];
insideviewbox = true(height(Xframe.ATOMS),1);
<span class="keyword">for</span> icoord = 1:3
    insideviewbox = insideviewbox ...
        & Xframe.ATOMS{:,coords{icoord}}>=viewbox(icoord,1) ...
        & Xframe.ATOMS{:,coords{icoord}}<=viewbox(icoord,2);
<span class="keyword">end</span>
XYZ  = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,coords};  <span class="comment">% fluid kernel centers</span>
vXYZ = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,vcoords}; <span class="comment">% velocity of fluid kernel centers</span>
XYZs = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.issolid,coords};  <span class="comment">% solid kernel centers</span>
rhobeadXYZ = Xframe.ATOMS.c_rho_smd(insideviewbox & Xframe.ATOMS.isfluid); <span class="comment">% volume of the bead</span>

<span class="comment">% force incell (this step is needed to apply PBC)</span>
XYZ = PBCincell(XYZ,box,[true,true,false]);
XYZs = PBCincell(XYZs,box,[true,true,false]);

<span class="comment">% add PBC images</span>
[XYZimagesONLY ,indXimagesONLY]= PBCimages(XYZ,box,[true,true,false],2*h);
XYZwithImages = [XYZ;XYZimagesONLY];
vXYZwithImages = [vXYZ;vXYZ(indXimagesONLY,:)];
rhobeadXYZwithImages = [rhobeadXYZ;rhobeadXYZ(indXimagesONLY)];
VbeadXYZwithImages = mbead./rhobeadXYZwithImages;
isImages = true(size(XYZwithImages,1),1); isImages(1:size(XYZ,1))=false;

<span class="comment">% Plot PBC (plot saved in R0) </span>
R0(1).XYZ = XYZ;
R0(1).indXimagesONLY = indXimagesONLY;
R0(1).XYZimagesONLY = XYZimagesONLY;
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R0) **********</span>
    figure, hold on, plot3D(XYZ,<span class="string">'go'</span>)
    plot3D(R0(1).XYZ(R0(1).indXimagesONLY,:),<span class="string">'go'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'g'</span>)
    plot3D(R0(1).XYZimagesONLY,<span class="string">'ro'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>), view(3), axis equal, view(2)
<span class="keyword">end</span>


<span class="comment">% interpolation grid (central grid, no images)</span>
nresolution = [1024 1024 1];
xw = linspace(box(1,1),box(1,2),nresolution(1));
yw = linspace(box(2,1),box(2,2),nresolution(1));
zw = ztop;
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];

<span class="comment">% grid neighbors (incl. images) <span class="keyword">for</span> interpolation and discarding grid points overlapping solid</span>
<span class="keyword">if</span> isprefetch(<span class="string">'VXYZ'</span>)
    load(prefetchvar(<span class="string">'VXYZ'</span>))
<span class="keyword">else</span>
    VXYZ  = buildVerletList({XYZgrid XYZwithImages},1.2*h);  <span class="comment">% neighbors = fluid particles</span>
    VXYZs = buildVerletList({XYZgrid XYZs},0.85*s); <span class="comment">% neighbors = solid particles</span>
    save(prefetchvar(<span class="string">'VXYZ'</span>),<span class="string">'VXYZ'</span>,<span class="string">'VXYZs'</span>)
<span class="keyword">end</span>
icontactsolid = find(cellfun(@length,VXYZs)>0);
VXYZ(icontactsolid) = repmat({[]},length(icontactsolid),1);

<span class="comment">% interpolation on the grid of the 3D velocity (central grid)</span>
<span class="comment">% Do not forget even <span class="keyword">if</span> we are applying a 2D interpretation, we use a 3D simulation</span>
<span class="comment">% 3D velocity are projected on 2D streamlines even <span class="keyword">if</span> the projection of the 3rd component is 0</span>
W = kernelSPH(h,<span class="string">'lucy'</span>,3); <span class="comment">% kernel expression</span>
<span class="keyword">if</span> isprefetch(<span class="string">'v3XYZgrid'</span>)
    load(prefetchvar(<span class="string">'v3XYZgrid'</span>))
<span class="keyword">else</span>
    v3XYZgrid = interp3SPHVerlet(XYZwithImages,vXYZwithImages,XYZgrid,VXYZ,W,VbeadXYZwithImages);
    save(prefetchvar(<span class="string">'v3XYZgrid'</span>),<span class="string">'v3XYZgrid'</span>)
<span class="keyword">end</span>
vxXYZgrid = reshape(v3XYZgrid(:,1),size(Xw)); <span class="comment">%vxXYZgrid(isnan(vxXYZgrid)) = 0;</span>
vyXYZgrid = reshape(v3XYZgrid(:,2),size(Xw)); <span class="comment">%vyXYZgrid(isnan(vyXYZgrid)) = 0;</span>
vzXYZgrid = reshape(v3XYZgrid(:,3),size(Xw)); <span class="comment">%vzXYZgrid(isnan(vzXYZgrid)) = 0;</span>
vXYZgrid  = reshape(sqrt(sum(v3XYZgrid.^2,2)),size(Xw));

<span class="comment">% density on the grid (with a possible different h)</span>
<span class="keyword">if</span> isprefetch(<span class="string">'rhobeadXYZgrid'</span>)
    load(prefetchvar(<span class="string">'rhobeadXYZgrid'</span>))
<span class="keyword">else</span>
    rhobeadXYZgrid = interp3SPHVerlet(XYZwithImages,rhobeadXYZwithImages,XYZgrid,VXYZ,W,VbeadXYZwithImages);
    save(prefetchvar(<span class="string">'rhobeadXYZgrid'</span>),<span class="string">'rhobeadXYZgrid'</span>)
<span class="keyword">end</span>
rhobeadXYZgrid = reshape(rhobeadXYZgrid,size(Xw));

<span class="comment">% add PBC (add periodic PBC)</span>
[vxXYZPBC,XwPBC,YwPBC] = PBCgrid(Xw,Yw,vxXYZgrid,[true,true],boxsize(1:2)./[8;2]);
rhobeadXYZPBC = PBCgrid(Xw,Yw,rhobeadXYZgrid,[true,true],boxsize(1:2)./[8;2]);
xwPBC = XwPBC(1,:); ywPBC = YwPBC(:,1)<span class="string">';
fluidboxPBC = double([xwPBC([1 <span class="keyword">end</span>]);ywPBC([1 <span class="keyword">end</span>]);fluidbox(3,:)]);
fluidboxsizePBC = diff(fluidboxPBC,1,2);
vyXYZPBC = PBCgrid(Xw,Yw,vyXYZgrid,[true,true],boxsize(1:2)./[8;2]);
vzXYZPBC = PBCgrid(Xw,Yw,vzXYZgrid,[true,true],boxsize(1:2)./[8;2]);
vXYZPBC = sqrt(vxXYZPBC.^2 + vyXYZPBC.^2 + vzXYZPBC.^2);

<span class="comment">% Plot PBC (saved in R0)</span>
R0(1).fluidboxPBC = fluidboxPBC;
R0(1).fluidboxsizePBC = fluidboxsizePBC;
R0(1).xwPBC = xwPBC;
R0(1).ywPBC = ywPBC;
R0(1).XwPBC = XwPBC;
R0(1).YwPBC = YwPBC;
R0(1).vxXYZPBC = vxXYZPBC;
R0(1).vyXYZPBC = vyXYZPBC;
R0(1).vXYZPBC = vXYZPBC;
R0(1).rhobeadXYZPBC = rhobeadXYZPBC;
R0(1).rhobeadXYZgrid = rhobeadXYZgrid;
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R0) **********</span>
    figure, mesh(R0(1).XwPBC,R0(1).YwPBC,R0(1).vXYZPBC), axis equal, view(2), colorbar, title(sprintf('</span>t=<span class="comment">%0.3f s - velocity (m/s)<span class="string">',tframe))</span>
    figure, mesh(R0(1).XwPBC,R0(1).YwPBC,R0(1).rhobeadXYZPBC); axis equal, view(2), colorbar, title(sprintf('</span>t=<span class="comment">%0.3f s - density (kg/m3)<span class="string">',tframe))</span>
<span class="keyword">end</span>

<span class="comment">%% Plot (attention 2D, meshgrid convention)</span>
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R0) **********</span>
    figure, hold on
    <span class="comment">% velocity magnitude</span>
    imagesc(R0(1).xwPBC,R0(1).ywPBC,R0(1).vXYZPBC)
    axis tight, axis equal
    colorbar
    title(sprintf('</span>t=<span class="comment">%0.3f s - velocity (m/s)<span class="string">',tframe))</span>
    
    <span class="comment">% quiver configuration and plot (boundaries are with PBC)</span>
    stepPBC = 16;
    boundariesPBC = ...
                 [ nearestpoint(double(R0(1).xwPBC([1,<span class="keyword">end</span>]))+R0(1).fluidboxsizePBC(1)/100*[1 -1],double(R0(1).xwPBC)) <span class="comment">% x</span>
                   nearestpoint(double(R0(1).ywPBC([1,<span class="keyword">end</span>]))+R0(1).fluidboxsizePBC(2)/100*[1 -1],double(R0(1).ywPBC)) <span class="comment">% y</span>
                 ];
    indxquiver = boundariesPBC(1,1):stepPBC:boundariesPBC(1,2); <span class="comment">% x indices</span>
    indyquiver = boundariesPBC(2,1):stepPBC:boundariesPBC(2,2); <span class="comment">% y indices</span>
    quiver(R0(1).XwPBC(indyquiver,indxquiver),R0(1).YwPBC(indyquiver,indxquiver), ...
              R0(1).vxXYZPBC(indyquiver,indxquiver),R0(1).vyXYZPBC(indyquiver,indxquiver), ...
            '</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',1)
<span class="keyword">end</span>

<span class="comment">%% streamlines</span>
dispsection('</span>STREAMLINES<span class="string">')
<span class="comment">% UP from bottom (starting position) to top</span>
<span class="comment">% DOWN from top to bottom (same starting position by reversing the velocity field)</span>
<span class="comment">% assembled as [flipud(DOWN(2:<span class="keyword">end</span>,:));UP]</span>
<span class="comment">% CELL streamlines along a y period, the separation distance is added to avoid gap</span>

<span class="comment">% streamline configuration and plot</span>
boundaries = [ nearestpoint(double(xw([1,<span class="keyword">end</span>])),double(xwPBC))
               nearestpoint(double(yw([1,<span class="keyword">end</span>])),double(ywPBC))
             ];
step = 8;
indxstreamline = boundaries(1,1):step:boundaries(1,2);
indystreamline = boundaries(2,1):step:boundaries(2,2);
nstreamlines = length(indxstreamline);

<span class="comment">% Generative streamlines</span>
ngenerations = 4;
xshift = 0.0;
iygen = unique(round(linspace(indystreamline(1),indystreamline(<span class="keyword">end</span>),ngenerations)));
ngenerations = length(iygen);
[verticesgenUP,verticesgenDOWN,verticesgen,verticesgenCELL,verticesgenCELLid] = deal({});
validstreamline = @(v) (v(:,2)-v(1,2))<=(boxsize(2)*1.5) & (v(:,2)-v(1,2))>=(boxsize(2)*0.01); <span class="comment">% longer than 1% but not exceeding 150%</span>
<span class="keyword">for</span> igen = 1:ngenerations
    <span class="comment">% ith generation of stream line (from indystreamline(1))</span>
    dispf('</span>generate the <span class="comment">%dth of %d generation of streamlines<span class="string">',igen,ngenerations)</span>
    <span class="comment">%xshift = double(mod(igen-1,2)*(xwPBC(indxstreamline(2))-xwPBC(indxstreamline(1))));</span>
    [startgenX,startgenY,startgenZ] = meshgrid(...
        double(xwPBC(indxstreamline))+xshift,...
        double(ywPBC(iygen(igen))),double(ztop));
    verticesgenUP{igen} = stream2(double(XwPBC),double(YwPBC),vxXYZPBC,vyXYZPBC,startgenX,startgenY,[0.03 5e4]);
    verticesgenDOWN{igen} = stream2(double(XwPBC),double(YwPBC),-vxXYZPBC,-vyXYZPBC,startgenX,startgenY,[0.03 5e4]);
    verticesgen{igen} = cellfun(@(d,u) [flipud(d(2:<span class="keyword">end</span>,:)); u],verticesgenDOWN{igen},verticesgenUP{igen},'</span>UniformOutput<span class="string">',false);
    verticesgen{igen} = cellfun(@(v) v(~isnan(v(:,2)),:),verticesgen{igen},'</span>UniformOutput<span class="string">',false);
    verticesgenCELL{igen} = cellfun(@(v) v(validstreamline(v),:),verticesgen{igen},'</span>UniformOutput<span class="string">',false);
    verticesgenCELLid{igen} = igen*ones(1,length(verticesgenCELL{igen}));
<span class="keyword">end</span>

<span class="comment">% merge all verticesCELL</span>
verticesCELL = cat(2,verticesgenCELL{:});
verticesCELLid = cat(2,verticesgenCELLid{:});
okverticesCELL = cellfun(@length,verticesCELL)>100; <span class="comment">% remove empty and too short streamlines (as a result of filtering by validstreamline)</span>
verticesCELL = verticesCELL(okverticesCELL);
verticesCELLid = verticesCELLid(okverticesCELL);

<span class="comment">% retrieve the separation distance</span>
sLagrangian = startgenX(1,2,1) - startgenX(1,1,1); <span class="comment">% separation distance between streamlines at injection/starting</span>
rLagrangian = sLagrangian/2;


<span class="comment">% detect interruption (<span class="keyword">for</span> control)</span>
<span class="comment">% yfinalposition1UP = cellfun(@(v) v(<span class="keyword">end</span>,2),vertices1UP);</span>
<span class="comment">% yfinalposition1DOWN = cellfun(@(v) v(<span class="keyword">end</span>,2),vertices1DOWN);</span>
<span class="comment">% isinterrupted1 = isnan(yfinalposition1UP) | isnan(yfinalposition1DOWN);</span>

<span class="comment">% control plot (saved in R1, partial with decimation)</span>
R1(1).box = box;
R1(1).sLagrangian = sLagrangian;
R1(1).rLagrangian = rLagrangian;
R1(1).ngenerations = ngenerations;
R1(1).nstreamlines = nstreamlines;
R1(1).verticesgen = cell(size(verticesgen));
R1(1).verticesgenCELL = cell(size(verticesgenCELL));
decimation = 100;
<span class="keyword">for</span> igen = 1:ngenerations
    R1(1).verticesgen{igen} = cell(size(verticesgen{igen}));
    R1(1).verticesgenCELL{igen} = cell(size(verticesgenCELL{igen}));
    <span class="keyword">for</span> i=1:nstreamlines
        R1(1).verticesgen{igen}{i} = verticesgen{igen}{i}(1:decimation:<span class="keyword">end</span>,:); 
        R1(1).verticesgenCELL{igen}{i} = verticesgenCELL{igen}{i}(1:decimation:<span class="keyword">end</span>,:); 
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1) **********</span>
    figure, hold on
    imagesc(R0(1).xwPBC,R0(1).ywPBC,R0(1).vXYZPBC)
    colors = jet(R1(1).ngenerations);
    
    <span class="keyword">for</span> igen = 1:R1(1).ngenerations
        <span class="keyword">for</span> i=1:R1(1).nstreamlines
            plot(R1(1).verticesgen{igen}{i}(:,1),R1(1).verticesgen{igen}{i}(:,2),'</span>-<span class="string">','</span>LineWidth<span class="string">',0.5,'</span>color<span class="string">',colors(igen,:))
            plot(R1(1).verticesgenCELL{igen}{i}(:,1),R1(1).verticesgenCELL{igen}{i}(:,2),'</span>-<span class="string">','</span>linewidth<span class="string">',1,'</span>color<span class="string">',colors(igen,:));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    axis equal
    title(sprintf('</span>t=<span class="comment">%0.3f s - streamlines<span class="string">',tframe))</span>
<span class="keyword">end</span>

<span class="comment">%% Distribute beads along streamlines tagged as CELL</span>
<span class="comment">% Once PBC are applied, space is filled with possibly overlaping streamlines</span>
<span class="comment">% the control plot is showing this effect</span>
dispsection('</span>INFORMED BEADS<span class="string">')
traj = fillstreamline2(verticesCELL,XwPBC,YwPBC,vxXYZPBC,vyXYZPBC,rLagrangian,0);
ntraj = length(traj);
<span class="comment">%trajUP = fillstreamline2(verticesUPCELL,XwPBC,YwPBC,vxXYZPBC,vyXYZPBC,rLagrangian,0);</span>
<span class="comment">%traj(~isinterrupted) = trajUP(~isinterrupted);</span>
XYZbeads = arrayfun(@(t) t.cart_distribution,traj,'</span>UniformOutput<span class="string">',false);
<span class="comment">% we apply PBC <span class="keyword">while</span> keeping the id of the streamline</span>
[XYZbeadsPBC,XYZbeadsPBCid] = deal(cell(ntraj,1));
<span class="keyword">for</span> itraj=1:ntraj <span class="comment">% trajectories and streamlines are assumed equivalent at steady state</span>
    XYZbeadsPBC{itraj} = PBCincell(XYZbeads{itraj},box(1:2,:),[true true]); <span class="comment">% wrapping along PBC</span>
    XYZbeadsPBCid{itraj} = ones(size(XYZbeadsPBC{itraj},1),1)*verticesCELLid(itraj);
<span class="keyword">end</span>

<span class="comment">% control plots (saved in R1)</span>
R1(1).ntraj = ntraj;
R1(1).XYZbeadsPBC = XYZbeadsPBC;
R1(1).XYZbeadsPBCid = XYZbeadsPBCid;
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1) **********</span>
    figure, hold on
    colors = tooclear(jet(R1(1).ntraj));
    <span class="keyword">for</span> itraj = 1:R1(1).ntraj
        plot(R1(1).XYZbeadsPBC{itraj}(:,1),R1(1).XYZbeadsPBC{itraj}(:,2),'</span>o<span class="string">',...
            '</span>markerfacecolor<span class="string">',colors(itraj,:),'</span>markeredgecolor<span class="string">',colors(itraj,:))
    <span class="keyword">end</span>
    title(sprintf('</span>t=<span class="comment">%0.3f s - colors match streamline index<span class="string">',tframe))</span>
    
    figure, hold on
    colors = tooclear(jet(R1(1).ngenerations));
    <span class="keyword">for</span> itraj = 1:R1(1).ntraj
        plot(R1(1).XYZbeadsPBC{itraj}(:,1),R1(1).XYZbeadsPBC{itraj}(:,2),'</span>o<span class="string">',...
            '</span>markerfacecolor<span class="string">',colors(R1(1).XYZbeadsPBCid{itraj}(1),:),'</span>markeredgecolor<span class="string">',colors(R1(1).XYZbeadsPBCid{itraj}(1),:))
    <span class="keyword">end</span>
    title(sprintf('</span>t=<span class="comment">%0.3f s - colors match generation index<span class="string">',tframe))</span>
<span class="keyword">end</span>

<span class="comment">%% remove duplicated beads between streamlines (too close)</span>
<span class="comment">% defined as beads from another streamline located at less than rbead</span>
<span class="comment">% this version incorporate the effect of the generational distance (somekind of age)</span>
<span class="comment">% beads from other injections points should emerge from positions farther from first generations (older ones)</span>
<span class="comment">% the generation index starts from the source of the flow (bottom), using streamlines from other positions is discouraged (since younger)</span>
<span class="comment">% </span>
<span class="comment">% Note: streamlines are indexed from oldest (closest to the source) to youngest (farthest from the source)</span>
dispsection('</span>CLEAN OVERLAPPED BEADS<span class="string">')
<span class="comment">% beads from different streamlines</span>
<span class="keyword">for</span> i=1:ntraj <span class="comment">% reference streamline (higher precedence)</span>
    <span class="keyword">for</span> j=1:ntraj <span class="comment">% the other streamline</span>
        <span class="keyword">if</span> i~=j
            indj = find(~isnan(XYZbeadsPBC{j}(:,1)));
            dij=pdist2(XYZbeadsPBC{i},XYZbeadsPBC{j}(indj,:)); <span class="comment">% Euclidian distance</span>
            <span class="comment">% the criterion on age is too strict</span>
            <span class="comment">%dgenij = pdist2(XYZbeadsPBCid{i},XYZbeadsPBCid{j}(indj,:)); % generational distance (0 <span class="keyword">for</span> the same generation)</span>
            <span class="comment">%XYZbeadsPBC{j}(indj(any(dij<rLagrangian*sqrt(2)*(1+dgenij),1)),:) = NaN;</span>
            XYZbeadsPBC{j}(indj(any(dij<rLagrangian*sqrt(2),1)),:) = NaN;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% beads from the same streamline</span>
<span class="comment">% two populations of beads are created (those inside and those outside (images) that could overlap those inside when they coordinates are wrapped)</span>
<span class="comment">%</span>
<span class="comment">% Note: we do not consider the overlapping of north and south images (the total height of a streamline is considered not to exceed 150% of the box height)</span>
<span class="keyword">for</span> i=1:ntraj
    isoutside =  (XYZbeads{i}(:,1)<box(1,1)) | (XYZbeads{i}(:,1)>box(1,2)) | ...
                 (XYZbeads{i}(:,2)<box(2,1)) | (XYZbeads{i}(:,2)>box(2,2) );
    isvalid = ~isnan(XYZbeadsPBC{i}(:,1));
    ioutside = find(isoutside & isvalid);  <span class="comment">% these beads are possible images of beads already inside</span>
    iinside =  find(~isoutside & isvalid); <span class="comment">% these beads have higher precedence, they are already inside</span>
    divsout=pdist2(XYZbeadsPBC{i}(iinside,:),XYZbeadsPBC{i}(ioutside,:));
    XYZbeadsPBC{i}(ioutside(any(divsout<rLagrangian*sqrt(2),1)),:) = NaN;
<span class="keyword">end</span>

XYZbeadsPBCall = cat(1,XYZbeadsPBC{:});
XYZbeadsPBCidall = cat(1,XYZbeadsPBCid{:});
isPBCallok = ~isnan(XYZbeadsPBCall(:,1));
XYZbeadsPBCall = XYZbeadsPBCall(isPBCallok,:);
XYZbeadsPBCidall = XYZbeadsPBCidall(isPBCallok,:);

<span class="comment">% control <span class="keyword">while</span> keeping the generational index (saved in R1)</span>
R1(1).XYZbeadsPBCall = XYZbeadsPBCall;
R1(1).XYZbeadsPBCidall = XYZbeadsPBCidall;
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1) **********</span>
    hfig = fighandle('</span>packing<span class="string">');  hold on
    colors = tooclear(hsv(R1(1).ngenerations)); <span class="comment">%turbo</span>
    <span class="keyword">for</span> igen=1:R1(1).ngenerations
        viscircles(R1(1).XYZbeadsPBCall(R1(1).XYZbeadsPBCidall==igen,:),R1(1).rLagrangian,'</span>color<span class="string">',colors(igen,:));
    <span class="keyword">end</span>
    title(sprintf('</span>t=<span class="comment">%0.3f s - one color per injection line<span class="string">',tframe)), axis equal</span>
    <span class="keyword">if</span> PRINTON, printhandle(hfig), <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% Filtering: remove overlapping from different injections using a first estimate of density</span>
dispsection('</span>CLEAN BEAD DENSITY<span class="string">')
<span class="comment">% Summary</span>
<span class="comment">% This methodology effectively redistributes beads to ensure that local densities do not exceed</span>
<span class="comment">% the physical limits of the simulation, enhancing realism and accuracy. By adjusting bead </span>
<span class="comment">% distributions based on calculated densities and employing PBC to handle edge cases, the script </span>
<span class="comment">% ensures a uniformly plausible representation of bead distributions across the simulation domain.</span>

hfilter = 4*rLagrangian;
XYbeadsfilterid = XYZbeadsPBCidall;
XYbeadsfilter = XYZbeadsPBCall; 
nfilter = size(XYbeadsfilter,1);
XYbeadsfilter_images= PBCimages(XYbeadsfilter,box(1:2,:),[true,true],2*hfilter);
XYbeadsfilterwithImages = [XYbeadsfilter;XYbeadsfilter_images];
Vbeadsfilter = buildVerletList(XYbeadsfilter,hfilter);
VbeadsfilterBC = buildVerletList({XYbeadsfilter XYbeadsfilterwithImages},hfilter);
Volfilter = length(find(~isnan(rhobeadXYZgrid(:))))/numel(rhobeadXYZgrid) * boxsize(1) * boxsize(2) * s;
mfilter = rho*Volfilter/size(XYbeadsfilter,1); <span class="comment">% mass of a single bead (informed)</span>
Vfilter = mfilter/rho;
Wfilter = kernelSPH(hfilter,'</span>lucy<span class="string">',2);
rhofilter = interp2SPHVerlet(...
    XYbeadsfilterwithImages,...
    rho*ones(size(XYbeadsfilterwithImages,1),1),...
    XYbeadsfilter,VbeadsfilterBC,Wfilter,Vfilter)/s; 

<span class="comment">% target</span>
rhomax = 1500;
ok = rhofilter<=rhomax;

<span class="comment">% before (saved in R1)</span>
R1(1).XYbeadsfilter = XYbeadsfilter;
R1(1).ok = ok;
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1) **********</span>
    hfig = fighandle('</span>packing_rhomax<span class="string">');  hold on
    viscircles(R1(1).XYbeadsfilter(R1(1).ok,:),R1(1).rLagrangian,'</span>color<span class="string">','</span>b<span class="string">');
    viscircles(R1(1).XYbeadsfilter(~R1(1).ok,:),R1(1).rLagrangian,'</span>color<span class="string">','</span>r<span class="string">');
    title(sprintf('</span>t=<span class="comment">%0.3f s - in red: excess density<span class="string">',tframe)), axis equal</span>
    <span class="keyword">if</span> PRINTON, printhandle(hfig), <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% do filter</span>
itoohigh = find(~ok);
[rhotoohigh,ind] = sort(rhofilter(itoohigh),'</span>descend<span class="string">');
itoohigh = itoohigh(ind);
kept = true(nfilter,1);
<span class="keyword">for</span> k=1:length(itoohigh)
    <span class="comment">% valid neighbors (only)</span>
    jBC = VbeadsfilterBC{itoohigh(k)}; <span class="comment">% it includes self with images</span>
    njBC = length(jBC);
    j = Vbeadsfilter{itoohigh(k)}; <span class="comment">% it includes self without images</span>
    j = j(kept(j));
    [idj,ind] = sort(XYbeadsfilterid(j),'</span>ascend<span class="string">');
    j = j(ind);  nj = length(j);
    jdeletable = j(find(idj>min(idj),1,'</span>first<span class="string">'):<span class="keyword">end</span>); <span class="comment">% we keep the first type</span>
    [rhojdeletable,ind] = sort(rhofilter(jdeletable),'</span>descend<span class="string">');
    jdeletable = jdeletable(ind); njdeletable = length(jdeletable);
    njexcess = floor( (1 - rhomax/rhotoohigh(k)) * njBC );
    kept(jdeletable(1:min(njexcess,njdeletable))) = false;
<span class="keyword">end</span>

<span class="comment">% after  (saved in R1)</span>
R1(1).kept = kept;
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1) **********</span>
    hfig = fighandle('</span>packing_rhomax_fix<span class="string">');  hold on
    viscircles(R1(1).XYbeadsfilter(R1(1).kept,:),R1(1).rLagrangian,'</span>color<span class="string">','</span>g<span class="string">');
    viscircles(R1(1).XYbeadsfilter(~R1(1).kept,:),R1(1).rLagrangian,'</span>color<span class="string">','</span>r<span class="string">');
    title(sprintf('</span>t=<span class="comment">%0.3f s - in red: removed beads<span class="string">',tframe)), axis equal</span>
    <span class="keyword">if</span> PRINTON, printhandle(hfig), <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">%% calculate density</span>
dispsection('</span>INFORMED DENSITY<span class="string">')
XYinformed = PBCincell(XYZbeadsPBCall(kept,:),box,[true true]); <span class="comment">% PBC just to be sure</span>
ninformed = size(XYinformed,1);
rinformed = rLagrangian; <span class="comment">%radius</span>
sinformed = 2*rinformed; <span class="comment">% separation distance</span>
hinformed = 5*sinformed; <span class="comment">% <span class="keyword">for</span> integration</span>

<span class="comment">% add PBC images</span>
[XYinformed_images ,indimages]= PBCimages(XYinformed,box(1:2,:),[true,true],2*hinformed);
XYinformedwithImages = [XYinformed;XYinformed_images];
<span class="comment">% Verlet list <span class="keyword">for</span> the original grid</span>
XYgrid = [Xw(:) Yw(:)];
<span class="keyword">if</span> isprefetch('</span>VXYinformed<span class="string">')
    load(prefetchvar('</span>VXYinformed<span class="string">'))
<span class="keyword">else</span>
    VXYinformed  = buildVerletList({XYgrid XYinformedwithImages},hinformed);
    save(prefetchvar('</span>VXYinformed<span class="string">'),'</span>VXYinformed<span class="string">')
<span class="keyword">end</span>
<span class="comment">% Verlet list <span class="keyword">for</span> the informed beads</span>
<span class="keyword">if</span> isprefetch('</span>VXYbeadinformed<span class="string">')
    load(prefetchvar('</span>VXYbeadinformed<span class="string">'))
<span class="keyword">else</span>
    VXYbeadinformed = buildVerletList({XYinformed XYinformedwithImages},hinformed);
    save(prefetchvar('</span>VXYbeadinformed<span class="string">'),'</span>VXYbeadinformed<span class="string">')
<span class="keyword">end</span>
   

<span class="comment">% Calculate the mass of informed beads</span>
<span class="comment">% total volume of fluid in the image</span>
Volinformed = length(find(~isnan(rhobeadXYZgrid(:))))/numel(rhobeadXYZgrid) * boxsize(1) * boxsize(2) * s;
mbeadinformed = rho*Volinformed/ninformed; <span class="comment">% mass of a single bead (informed)</span>

<span class="comment">% 2D Kernel</span>
Winformed = kernelSPH(hinformed,'</span>lucy<span class="string">',2); <span class="comment">% kernel expression [/m2]</span>

<span class="comment">% Calculate the volume of the beads</span>
Vbeadinformedguess = mbeadinformed/rho; <span class="comment">% first guess</span>
<span class="comment">% density at the centers of the informed beads</span>
rhobeadinformed = interp2SPHVerlet(XYinformedwithImages,rho*ones(size(XYinformedwithImages,1),1),XYinformed,VXYbeadinformed,Winformed,Vbeadinformedguess);
rhobeadinformed = rhobeadinformed/s; <span class="comment">% the thickness is not known, s is used instead of sinformed <span class="keyword">for</span> consistency</span>
rhobeadinformedwithImages = [rhobeadinformed;rhobeadinformed(indimages)];
<span class="comment">% rhobeadinformed(rhobeadinformed<200) = NaN;</span>
<span class="comment">% rhobeadinformed(isnan(rhobeadinformed)) = median(rhobeadinformed,'</span>omitmissing<span class="string">'); </span>

<span class="comment">% volume of the informed beads</span>
Vbeadinformed = mbeadinformed./rhobeadinformed;
<span class="comment">% normalized radius of informed beads</span>
rbeadinformed = sqrt(Vbeadinformed/(s*pi));
rbeadinformed = rbeadinformed/median(rbeadinformed,'</span>omitmissing<span class="string">') * rLagrangian;

<span class="comment">% control figure  (saved in R1)</span>
R1(1).rinformed = rinformed;
R1(1).sinformed = sinformed;
R1(1).hinformed = hinformed;
R1(1).XYinformed = XYinformed;
R1(1).rhobeadinformed = rhobeadinformed;
R1(1).rbeadinformed = rbeadinformed;
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1) **********</span>
    figure, viscircles(R1(1).XYinformed,R1(1).rLagrangian,'</span>color<span class="string">','</span>g<span class="string">'); axis equal, hold on
    viscircles(R1(1).XYinformed,R1(1).rbeadinformed,'</span>color<span class="string">','</span>r<span class="string">');
<span class="keyword">end</span>

<span class="comment">% reference density at the same positions (saved in R0)</span>
XYZeqinformed = [XYinformed ones(ninformed,1)*ztop];
VXYZeqinformed  = buildVerletList({XYZeqinformed XYZwithImages},1.2*h);
rhobeadXYZ2XYinformed = interp3SPHVerlet(XYZwithImages,rhobeadXYZwithImages,XYZeqinformed,VXYZeqinformed,W,VbeadXYZwithImages);
R0(1).XYZeqinformed = XYZeqinformed;
R0(1).rhobeadXYZ2XYinformed = rhobeadXYZ2XYinformed;

<span class="comment">% density on the grid (saved in R1)</span>
<span class="keyword">if</span> isprefetch('</span>dgrid<span class="string">')
    load(prefetchvar('</span>dgrid<span class="string">'))
<span class="keyword">else</span>
    <span class="comment">% note that rho and Vbeadinformedguess should have the same origin so that rho*Vbeadinformedguess equals mbeadinformed</span>
    dgrid = interp2SPHVerlet(XYinformedwithImages,rho*ones(size(XYinformedwithImages,1),1),XYgrid,VXYinformed,Winformed,Vbeadinformedguess);
    save(prefetchvar('</span>dgrid<span class="string">'),'</span>dgrid<span class="string">')
<span class="keyword">end</span>
dgrid = reshape(dgrid/s,size(Xw)); <span class="comment">% /s to get in kg/m3 from kg/m2</span>
dgrid(isnan(rhobeadXYZgrid)) = NaN; <span class="comment">% we mask the objects (pillar and sphere) the same way as in the reference</span>
R1(1).dgrid = dgrid;

<span class="comment">%% Evaluate Landshoff forces - added 29,30/03/2024</span>
dispsection('</span>LANDSHOFF<span class="string">')
<span class="comment">% reference velocity</span>
XYZinformed = [XYinformed ones(size(XYinformed,1),1)*ztop];
VXYZ_forinformed = buildVerletList({XYZinformed XYZwithImages},1.2*hinformed);
<span class="keyword">if</span> isprefetch('</span>Velocity_beadinformed<span class="string">')
    load(prefetchvar('</span>Velocity_beadinformed<span class="string">'))
<span class="keyword">else</span>
    Velocity_beadinformed = interp3SPHVerlet(XYZwithImages,vXYZwithImages,XYZinformed,VXYZ_forinformed,W,VbeadXYZwithImages);
    save(prefetchvar('</span>Velocity_beadinformed<span class="string">'),'</span>Velocity_beadinformed<span class="string">')
<span class="keyword">end</span>
Velocity_beadinformed_withimages = [Velocity_beadinformed;Velocity_beadinformed(indimages,:)];

<span class="comment">% configuration <span class="keyword">for</span> Landshoff</span>
<span class="comment">% Since the scaling is not clear in 2D, q1 is left to one</span>

<span class="comment">% maxVelocity = max(vXYZ,[],'</span>all<span class="string">');</span>
<span class="comment">% MachTarget = 0.1;</span>
c0 = 1500; <span class="comment">% maxVelocity / MachTarget;</span>
dynamicViscosity = 0.13; <span class="comment">% Pa.s</span>
q1 = 1; <span class="comment">% 8 * dynamicViscosity / (hinformed*c0*rho);</span>
config  = struct( ...real dynamic viscosity: rho * q1 * h * c0 / 8 (2D) or 10 (3D)
   '</span>gradkernel<span class="string">', kernelSPH(hinformed,'</span>lucyder<span class="string">',2),...<span class="comment">% kernel gradient (note that h is bound with the kernel)</span>
            '</span>h<span class="string">', hinformed,...smoothing length
           '</span>c0<span class="string">',c0,...        speed of the sound
           '</span>q1<span class="string">',q1,...         constant
          '</span>rho<span class="string">', rhobeadinformedwithImages, ...    fluid density
         '</span>mass<span class="string">', mbeadinformed,...        bead weight
          '</span>vol<span class="string">', sinformed * mbeadinformed./rhobeadinformedwithImages, ...       bead volume (uniquely <span class="keyword">for</span> virial stress)
'</span>repulsiononly<span class="string">', false ...    <span class="keyword">if</span> true, only Landshoff forces when dot(rij,vij)<0
    );

<span class="comment">% Landshoff forces</span>
VXYZ_forinformedwithImages = buildVerletList(XYinformedwithImages,1.2*hinformed);
[FXY_tmp,WXY_tmp] = forceLandshoff(...
    XYinformedwithImages,...
    Velocity_beadinformed_withimages(:,1:2),...
    VXYZ_forinformedwithImages,...
    config);
FXY_beadsinformedwithImages = [FXY_tmp(1:size(XYinformed,1),:); FXY_tmp(indimages,:)];
WXY_beadsinformedwithImages = [WXY_tmp(1:size(XYinformed,1),:); WXY_tmp(indimages,:)];
<span class="keyword">if</span> isprefetch('</span>FXYgrid<span class="string">')
    load(prefetchvar('</span>FXYgrid<span class="string">'))
<span class="keyword">else</span>
    FXYgrid = interp2SPHVerlet(XYinformedwithImages,FXY_beadsinformedwithImages,XYgrid,VXYinformed,Winformed,Vbeadinformedguess);
    save(prefetchvar('</span>FXYgrid<span class="string">'),'</span>FXYgrid<span class="string">')
<span class="keyword">end</span>
<span class="keyword">if</span> isprefetch('</span>WXYgrid<span class="string">')
    load(prefetchvar('</span>WXYgrid<span class="string">'))
<span class="keyword">else</span>
    WXYgrid = interp2SPHVerlet(XYinformedwithImages,WXY_beadsinformedwithImages,XYgrid,VXYinformed,Winformed,Vbeadinformedguess);
    save(prefetchvar('</span>WXYgrid<span class="string">'),'</span>WXYgrid<span class="string">')
<span class="keyword">end</span>
F1XYgrid = reshape(FXYgrid(:,1),size(Xw));
F2XYgrid = reshape(FXYgrid(:,2),size(Xw));
W11XYgrid = reshape(WXYgrid(:,1),size(Xw)); 
W22XYgrid = reshape(WXYgrid(:,4),size(Xw));
W12XYgrid = reshape(WXYgrid(:,2),size(Xw));
W21XYgrid = reshape(WXYgrid(:,3),size(Xw));
F1XYgrid(isnan(rhobeadXYZgrid)) = NaN;
F2XYgrid(isnan(rhobeadXYZgrid)) = NaN;
W11XYgrid(isnan(rhobeadXYZgrid)) = NaN;
W22XYgrid(isnan(rhobeadXYZgrid)) = NaN;
W12XYgrid(isnan(rhobeadXYZgrid)) = NaN;

<span class="comment">% save results in R1</span>
R1(1).xw = xw;
R1(1).yw = yw;
R1(1).Xw = Xw;
R1(1).Yw = Yw;
R1(1).F1XYgrid = F1XYgrid;
R1(1).F2XYgrid = F2XYgrid;
R1(1).W11XYgrid = W11XYgrid;
R1(1).W22XYgrid = W22XYgrid;
R1(1).W12XYgrid = W12XYgrid;
R1(1).W21XYgrid = W21XYgrid;

<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1) **********</span>
    <span class="comment">% distribution of Landshoff forces (not meaningful on a grid) - just <span class="keyword">for</span> control</span>
    figure,  hold on
    hp = pcolor(R1(1).xw,R1(1).yw,abs(R1(1).W12XYgrid)); hp.EdgeColor = '</span>none<span class="string">'; colorbar
    step = 25;
    quiver(R1(1).Xw(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),R1(1).Yw(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),...
        R1(1).F1XYgrid(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),R1(1).F2XYgrid(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),2,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',0.5)
    title(sprintf('</span>[t=<span class="comment">%0.3g s] informed shear stress (kg/m3)<span class="string">',tframe)), axis equal %, clim([500 1300])</span>
    <span class="comment">% distribution of Landshoff stresses</span>
    hfig = fighandle('</span>Landshoff_stress<span class="string">');  hold on
    hp = pcolor(R1(1).xw,R1(1).yw,abs(R1(1).W12XYgrid)); hp.EdgeColor = '</span>none<span class="string">'; colorbar
    step = 25;
    quiver(R1(1).Xw(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),R1(1).Yw(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),...
        R1(1).W11XYgrid(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),R1(1).W22XYgrid(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),2,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',0.5)
    title(sprintf('</span>[t=<span class="comment">%0.3g s] Landshoff - shear (abs(Lxy)) - Lxx,Lyy (Pa)<span class="string">',tframe)), axis equal %, clim([500 1300])</span>
<span class="keyword">end</span>

<span class="comment">% gradient of velocity (saved in R1)</span>
[gxx,gxy] = gradient(vxXYZgrid,Xw(1,2)-Xw(1,1));
[gyx,gyy] = gradient(vyXYZgrid,Yw(2,1)-Yw(1,1));
R1(1).gxx = gxx;
R1(1).gxy = gxy;
R1(1).gyx = gyx;
R1(1).gyy = gyy;

<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1) **********</span>
    figure, hold on, title('</span>Gradient of velocity: xx, yy and xy<span class="string">')
    hp = pcolor(R1(1).xw,R1(1).yw,abs(R1(1).gxy+R1(1).gyx)/2); hp.EdgeColor = '</span>none<span class="string">'; colorbar
    step = 25;
    quiver(R1(1).Xw(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),R1(1).Yw(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),...
        R1(1).gxx(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),R1(1).gyy(1:step:<span class="keyword">end</span>,1:step:<span class="keyword">end</span>),2,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',0.5)
<span class="keyword">end</span>

<span class="comment">% Viscosity control (saved in R1)</span>
r = abs(W12XYgrid./gxy); r(isinf(r)) = NaN;
dynamicViscosity_estimated = r/(sinformed*rho);
R1(1).r = r;
R1(1).dynamicViscosity = dynamicViscosity;
R1(1).dynamicViscosity_estimated = dynamicViscosity_estimated;

<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1) **********</span>
    <span class="comment">% map</span>
    hfig(<span class="keyword">end</span>+1) = fighandle('</span>Viscosity_estimate<span class="string">');  hold on
    imagesc(log10(R1(1).dynamicViscosity_estimated/R1(1).dynamicViscosity)), colorbar, clim([-2 2])
    title(sprintf('</span>[t=<span class="comment">%0.3g s] Estimated/Real Viscosity (log)<span class="string">',tframe)), axis equal</span>
    <span class="comment">% distribution</span>
    hfig(<span class="keyword">end</span>+1) = fighandle('</span>Viscosity_estimate_dist<span class="string">');  hold on
    histogram(log10(R1(1).dynamicViscosity_estimated/R1(1).dynamicViscosity))
    title(sprintf('</span>[t=<span class="comment">%0.3g s] Estimated/Real Viscosity (log)<span class="string">',tframe))</span>
<span class="keyword">end</span>

<span class="comment">% print</span>
<span class="keyword">if</span> PRINTON && PLOTON
    <span class="keyword">for</span> i=1:length(hfig)
        figure(hfig(i)), drawnow
        printhandle(hfig(i))
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% ---------------------------- PRODUCTION FIGURES</span>
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1 and R0) **********</span>
    hfig = []; close all

    <span class="comment">% Density mapped on beads</span>
    hfig(<span class="keyword">end</span>+1) = fighandle('</span>d_bead_informed<span class="string">'); hold on, title(sprintf('</span>[t=<span class="comment">%0.3g s] density mapped to informed beads<span class="string">',tframe))</span>
    scatter(R1(1).XYinformed(:,1),R1(1).XYinformed(:,2),100*(R1(1).rbeadinformed/min(R1(1).rbeadinformed)).^2,R1(1).rhobeadinformed,'</span>filled<span class="string">'), colorbar
    hfig(<span class="keyword">end</span>+1) = fighandle('</span>d_bead_reference<span class="string">'); hold on, title(sprintf('</span>[t=<span class="comment">%0.3g s] reference density mapped to informed beads<span class="string">',tframe))</span>
    scatter(R0(1).XYZeqinformed(:,1),R0(1).XYZeqinformed(:,2),100*(R1(1).rbeadinformed/min(R1(1).rbeadinformed)).^2,R1(1).rhobeadXYZ2XYinformed,'</span>filled<span class="string">'), colorbar
    hfig(<span class="keyword">end</span>+1) = fighandle('</span>d_bead_informed_vs_reference<span class="string">'); plot(R0(1).rhobeadXYZ2XYinformed(:),R1(1).rhobeadinformed(:),'</span>ro<span class="string">'), xlabel('</span>reference density (back mapped)<span class="string">'), ylabel('</span>informed density<span class="string">')
    title(sprintf('</span>[t=<span class="comment">%0.3g s] informed vs. reference density<span class="string">',tframe))</span>

    <span class="comment">% density mapped on the grid</span>
    hfig(<span class="keyword">end</span>+1) = fighandle('</span>d_grid_informed<span class="string">'); hp = pcolor(R1(1).xw,R1(1).yw,R1(1).dgrid); hp.EdgeColor = '</span>none<span class="string">'; colorbar, title(sprintf('</span>[t=<span class="comment">%0.3g s] informed density (kg/m3)<span class="string">',tframe)), axis equal %, clim([500 1300])</span>
    haxtomodify = gca;
    hfig(<span class="keyword">end</span>+1) = fighandle('</span>d_grid_reference<span class="string">'); hp = pcolor(R1(1).xw,R1(1).yw,R0(1).rhobeadXYZgrid); hp.EdgeColor = '</span>none<span class="string">'; colorbar, title(sprintf('</span>[t=<span class="comment">%0.3g s] reference density (kg/m3)<span class="string">',tframe)), axis equal %, clim([500 1300])</span>
    clim(haxtomodify,clim)

    <span class="comment">% distribution of densities</span>
    hfig(<span class="keyword">end</span>+1) = fighandle('</span>distribution_rho<span class="string">');  hold on
    histogram(R1(1).rhobeadinformed), histogram(R0(1).rhobeadXYZ2XYinformed), legend({'</span>informed density<span class="string">','</span>reference density<span class="string">'})
    title(sprintf('</span>[t=<span class="comment">%0.3g s] Density distributions<span class="string">',tframe))</span>
<span class="keyword">end</span>

<span class="comment">%% -- identify the beads in contact with objects based on density</span>
<span class="comment">% SUMMARY.</span>
<span class="comment">% This section outlines a methodology <span class="keyword">for</span> identifying beads in contact with solid objects</span>
<span class="comment">% in a fluid simulation, particularly focusing on density-based criteria to determine close</span>
<span class="comment">% interactions and potential contact forces.</span>
dispsection('</span>OBJECT DETECTION<span class="string">')
<span class="comment">% Attention the sphere can exceed the area observed (overflow condition)</span>
<span class="comment">% Safe coordinates are only use <span class="keyword">for</span> contour identification</span>
isynan = isnan(mean(rhobeadXYZgrid(:,floor(size(rhobeadXYZgrid,2)*0.6):<span class="keyword">end</span>),2));
isoverflow =  (find(isynan,1,'</span>last<span class="string">')-find(isynan,1,'</span>first<span class="string">')+1)==size(rhobeadXYZgrid,1);
<span class="keyword">if</span> (find(isynan,1,'</span>last<span class="string">')-find(isynan,1,'</span>first<span class="string">')+1)==size(rhobeadXYZgrid,1) <span class="comment">% reach top</span>
    iyoverflow = find(~isynan,1,'</span>first<span class="string">');
    iymargin = round(size(rhobeadXYZgrid,1)*0.1); <span class="comment">% margin to add</span>
    iysafe = iyoverflow+iymargin;          <span class="comment">% index translation (along y)</span>
    dysafe = -iysafe * ( Yw(2,1)-Yw(1,1) ); <span class="comment">% distance translation (along y)</span>
    [rXYgridsafe,Xwsafe,Ywsafe] = PBCgridshift(Xw,Yw,rhobeadXYZgrid,[0 iysafe]); <span class="comment">% translate</span>
    dgridsafe = PBCgridshift(Xw,Yw,dgrid,[0 iysafe]); <span class="comment">% translate</span>
    [XYinformedsafe,boxsafe] = PBCimagesshift(XYinformed,[0 dysafe],box(1:2,1:2));
<span class="keyword">elseif</span> find(isynan,1,'</span>first<span class="string">')==1
    iymargin = round(size(rhobeadXYZgrid,1)*0.1); <span class="comment">% margin to add</span>
    iyoverflow = iymargin;
    <span class="keyword">if</span> isynan(<span class="keyword">end</span>), iyoverflow = iyoverflow + length(iyoverflow)-find(~isynan,1,'</span>last<span class="string">'); <span class="keyword">end</span>
    iysafe = -iyoverflow;
    dysafe = -iysafe * ( Yw(2,1)-Yw(1,1) ); <span class="comment">% distance translation (along y)</span>
    [rXYgridsafe,Xwsafe,Ywsafe] = PBCgridshift(Xw,Yw,rhobeadXYZgrid,[0 iysafe]); <span class="comment">% translate</span>
    dgridsafe = PBCgridshift(Xw,Yw,dgrid,[0 iysafe]); <span class="comment">% translate</span>
    [XYinformedsafe,boxsafe] = PBCimagesshift(XYinformed,[0 dysafe],box(1:2,1:2));
<span class="keyword">else</span>
    dysafe = 0;
    [rXYgridsafe,Xwsafe,Ywsafe] = deal(rhobeadXYZgrid,Xw,Yw);
    [dgridsafe,XYinformedsafe,boxsafe] = deal(dgrid,XYinformed,box);
<span class="keyword">end</span>

<span class="comment">% Volume of objects (GRID points): XYobjects where density is NaN vy definition</span>
XYobjects = [Xwsafe(:) Ywsafe(:)];
XYobjects = XYobjects(isnan(rXYgridsafe),:);
<span class="comment">% Looking <span class="keyword">for</span> beads in contact with XYobjects (grid points)</span>
V2 = buildVerletList({XYinformedsafe XYobjects},3*sinformed);
<span class="comment">% Index of beads in contact with XYobjects (grid points)</span>
icontact = find(cellfun(@length,V2)>0);
XYcontact = double(XYinformedsafe(icontact,:));
<span class="comment">% Enclosed beads</span>
k = boundary(XYcontact,1); nk = length(k);
XYcontactk = XYcontact(k,:);

<span class="comment">% separation of the objects, contour parameterization, tangents, normals</span>
<span class="comment">% the pillar is assumed fixed</span>
pillarcenter = [2.87,3.08]*1e-4; <span class="comment">% 0.2880e-3    0.3131e-3, mean(objects(1).XY)</span>
ispillar = vecnorm(XYcontactk - pillarcenter,2,2)<0.8e-4; <span class="comment">%  7.7859e-05, max(vecnorm(XYcontactk(ispillar,:) - pillarcenters,2,2))</span>
objects = struct('</span>name<span class="string">',{'</span>pillar<span class="string">','</span>sphere<span class="string">'},'</span>XY<span class="string">',{XYcontactk(ispillar,:) XYcontactk(~ispillar,:)},'</span>marker<span class="string">',{'</span>bo<span class="string">','</span>ms<span class="string">'},'</span>line<span class="string">',{'</span>b-<span class="string">','</span>m-<span class="string">'},'</span>color<span class="string">',{'</span>b<span class="string">','</span>m<span class="string">'});
anglestep = pi/32;
angles = (-pi:anglestep:pi)'</span>;
<span class="keyword">for</span> k = 1:length(objects)
    <span class="comment">% fit each object as a circle to try to close the boundaries</span>
    objects(k).fit = fitCircleFromPoints(objects(k).XY);
    missingangles = angles(abs(angles-objects(k).fit.angles(nearestpoint(angles,objects(k).fit.angles)))>anglestep);
    XYtoadd = objects(k).fit.XYgenerator(missingangles);
    XYclosed = [objects(k).XY;XYtoadd]; nXYclosed = floor(size(XYclosed,1)/2)*2;
    [anglesclosed,ind] = sort(objects(k).fit.angleGenerator(XYclosed));
    XYclosed = XYclosed (ind,:); <span class="comment">% sort points according to angles</span>
    <span class="comment">% enforce periodic conditions along the index dimension</span>
    objects(k).XYclosed = [XYclosed((nXYclosed/2+1):<span class="keyword">end</span>,:) ; XYclosed ; XYclosed(1:(nXYclosed/2),:)];
    objects(k).n = size(objects(k).XYclosed,1);

    <span class="comment">% First pass - contour twice longer than the real one</span>
    <span class="comment">% fit each obhect using a regularized spline approximation</span>
    sp = csaps((1:objects(k).n)<span class="string">',objects(k).XYclosed'</span>,0.25); <span class="comment">% smoothed cubic spline</span>
    <span class="comment">%sp = spaps((1:objects(k).n)<span class="string">',objects(k).XYclosed'</span>,0.001*sum(var(objects(k).XYclosed))*objects(k).n);</span>
    spder = fnder(sp,1);

    <span class="comment">% Second pass - approximation based on angles</span>
    xycontours = fnval(sp,sp.breaks)<span class="string">';
    dxycontours = fnval(spder,sp.breaks)'</span>;
    xycircle = fitCircleFromPoints(xycontours);
    [xyangles,ind] = sort(xycircle.angles,<span class="string">'ascend'</span>);
    minangle = min(xyangles);
    maxangle = max(xyangles);
    xyangles = (2*(xyangles-minangle)/(maxangle-minangle)-1) * pi; <span class="comment">% rescaled to close the figure</span>
    xycontoursf = [ smooth(xyangles,xycontours(ind,1),0.15,<span class="string">'rloess'</span>),...
                    smooth(xyangles,xycontours(ind,2),0.15,<span class="string">'rloess'</span>) ];
    dxycontoursf = [ smooth(xyangles,dxycontours(ind,1),0.15,<span class="string">'rloess'</span>),...
                    smooth(xyangles,dxycontours(ind,2),0.15,<span class="string">'rloess'</span>) ];

    <span class="comment">% Make all data unique</span>
    [xyangles,ind] = unique(xyangles,<span class="string">'stable'</span>);
    xycontoursf = xycontoursf(ind,:);
    dxycontoursf = dxycontoursf(ind,:);
    xycontoursf([1 <span class="keyword">end</span>],:) = [1;1] * mean(xycontoursf([1 <span class="keyword">end</span>],:));
    dxycontoursf([1 <span class="keyword">end</span>],:) = [1;1] * mean(dxycontoursf([1 <span class="keyword">end</span>],:));

    <span class="comment">% Third Pass using contour length instead of angle as variable</span>
    <span class="comment">% ATTENTION: <span class="keyword">for</span> averaging it is preferable to use curvilinear coordinates</span>
    lxycontour = [0; cumsum(sqrt(sum(diff(xycontoursf,1,1).^2,2)))];
    sp2 = csaps(lxycontour<span class="string">',xycontoursf'</span>);


    <span class="comment">% Extract tangents at prescribed curvilinear coordinates</span>
    xp = linspace(lxycontour(1),lxycontour(<span class="keyword">end</span>),objects(k).n)<span class="string">';
    <span class="comment">% center and apparent radius (<span class="keyword">for</span> visualizing the force acting on the object)</span>
    objects(k).XYboundary = fnval(sp2,xp)'</span>;
    objects(k).center = mean(objects(k).XYboundary);
    objects(k).radius = min(vecnorm(objects(k).XYboundary-objects(k).center,2,2));
    <span class="comment">% tangents (from the spline approximation)</span>
    <span class="comment">%objects(k).tangents = ndf(xp,objects(k).XYboundary,1,[],<span class="string">'makeuniform'</span>,true); %curve2tangent(objects(k).XYboundary); %fnval(fnder(sp2,1),xp)<span class="string">';</span>
    objects(k).tangents = fnval(fnder(sp2,1),xp)'</span>;
    objects(k).tangents = objects(k).tangents./vecnorm(objects(k).tangents,2,2); <span class="comment">% Normalize the tangent vectors</span>
    <span class="comment">% normals (turn the normals to be inwards using inpolygon)</span>
    objects(k).normals = [-objects(k).tangents(:,2),objects(k).tangents(:,1)]; <span class="comment">% % Calculate the centroid of the shape</span>
    testPoints = objects(k).XYboundary + 0.01 * objects(k).radius * objects(k).normals; <span class="comment">% Choose a test point slightly offset from each boundary point along the normal</span>
    isInside = inpolygon(testPoints(:,1), testPoints(:,2),...
        objects(k).XYboundary(:,1), objects(k).XYboundary(:,2)); <span class="comment">% Use inpolygon to check <span class="keyword">if</span> each test point is inside the shape</span>
    objects(k).normals(~isInside, :) = -objects(k).normals(~isInside, :); <span class="comment">% Flip the normals where the test point is outside the shape</span>
    <span class="comment">% add density, pressure information (look <span class="keyword">for</span> the nearest beads closest to the boundary, average the value)</span>
    objects(k).Vcontact = buildVerletList({objects(k).XYboundary XYcontact},3*sinformed);
    objects(k).Vcontact = cellfun(@(v) icontact(v)<span class="string">',objects(k).Vcontact,'</span>UniformOutput<span class="string">',false); <span class="comment">% Vcontact{i} index of beads in contact with XYboundary(i,:)</span>
    objects(k).rhocontact = cellfun(@(v) mean(rhobeadinformed(v)),objects(k).Vcontact);
    objects(k).Pcontact = 1 + (objects(k).rhocontact/rho).^7-1; <span class="comment">% reduced pressure P/B with P0/B=1</span>
    objects(k).densitynormals = objects(k).rhocontact.*objects(k).normals/rho;
    objects(k).avdensitynormals = mean(objects(k).densitynormals,'</span>omitmissing<span class="string">');
    objects(k).pressurenormals = objects(k).Pcontact.*objects(k).normals;
    objects(k).avpressurenormals = mean(objects(k).pressurenormals,'</span>omitmissing<span class="string">');
<span class="keyword">end</span>

<span class="comment">% save results in R1</span>
R1(1).XYcontact = XYcontact;
R1(1).objects = {objects.name};
<span class="keyword">for</span> k=1:length(objects)
    R1(1).(objects(k).name) = objects(k);
<span class="keyword">end</span>
R1(1).Xwsafe = Xwsafe;
R1(1).Ywsafe = Ywsafe;
R1(1).dgridsafe = dgridsafe;

<span class="comment">% plot</span>
<span class="keyword">if</span> PLOTON <span class="comment">% <<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-<<-(saved in R1) **********</span>
    hfig(<span class="keyword">end</span>+1) = fighandle('</span>distribution_forces<span class="string">');  hold on
    set(hfig(<span class="keyword">end</span>),'</span>PaperPosition<span class="string">',[ -2.0000    1.7000   30.0000   30.0000])
    step = 2;
    hp = pcolor(Xwsafe(1,:),Ywsafe(:,1),dgridsafe); hp.EdgeColor = '</span>none<span class="string">'; colorbar
    quiv = struct('</span>xy<span class="string">',[],'</span>nxy<span class="string">',[],'</span>mag<span class="string">',[],'</span>nscale<span class="string">',2);
    <span class="keyword">for</span> k = 1:length(R1(1).objects)
        currentobject = R1(1).objects{k};
        <span class="comment">% viscircles(R1(1).XYcontact,R1(1).rinformed,'</span>color<span class="string">','</span>r<span class="string">');</span>
        <span class="comment">% plot(R1(1).(currentobject).XY(:,1),R1(1).(currentobject).XY(:,2),R1(1).(currentobject).marker)</span>
        plot(R1(1).(currentobject).XYboundary(:,1),R1(1).(currentobject).XYboundary(:,2),R1(1).(currentobject).line,'</span>linewidth<span class="string">',2,'</span>marker<span class="string">','</span>x<span class="string">')
        quiv.xy  = [quiv.xy;  R1(1).(currentobject).XYboundary(1:step:<span class="keyword">end</span>,:);  R1(1).(currentobject).center];
        quiv.nxy = [quiv.nxy; R1(1).(currentobject).pressurenormals(1:step:<span class="keyword">end</span>,:); quiv.nscale*R1(1).(currentobject).avpressurenormals];
        quiv.mag = [quiv.mag; R1(1).(currentobject).Pcontact(1:step:<span class="keyword">end</span>);mean(R1(1).(currentobject).Pcontact,'</span>omitmissing<span class="string">')];
    <span class="keyword">end</span>
    <span class="comment">% all quivers at once (color</span>
    hq = quiver(quiv.xy(:,1),quiv.xy(:,2),quiv.nxy(:,1),quiv.nxy(:,2),3,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',0.5);
    SetQuiverColor(hq,tooclear(jet),'</span>mags<span class="string">',quiv.mag,'</span>range<span class="string">',[0 0.5])
    axis equal, title(sprintf('</span>[t=<span class="comment">%0.3g s] Pressure around objects<span class="string">',tframe))</span>
<span class="keyword">end</span>



<span class="comment">%% print</span>
<span class="keyword">if</span> PRINTON && PLOTON
    <span class="keyword">for</span> i=1:length(hfig)
        figure(hfig(i)), drawnow
        printhandle(hfig(i))
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% save</span>
<span class="keyword">if</span> ~exist(savefile(),'</span>file<span class="string">') || OVERWRITE
    save(savefile(),'</span>R0<span class="string">','</span>R1<span class="string">')
    dispf('</span>\n-->Results <span class="keyword">for</span> tframe=<span class="comment">%0.4g s have been saved<span class="string">',tframe)</span>
    fileinfo(savefile())
<span class="keyword">end</span>

dispsection('</span>100<span class="comment">% complete<span class="string">')</span>


<span class="comment">% relative pressure via Tait equation</span>
<span class="comment">% Pref = (rhobeadXYZgrid./rho).^7 - 1; % reference pressure</span>
<span class="comment">% Pbead = (rhobeadinformed./rho).^7 - 1; % pressure at kernel positions</span>
<span class="comment">% Pgrid = (dgrid./rho).^7 - 1; % pressure at grid nodes</span>
<span class="comment">% Pgrid = min(Pref(:)) + (max(Pref(:))-min(Pref(:)))*(Pgrid-min(Pgrid(:)))/(max(Pgrid(:))-min(Pgrid(:)));</span>
<span class="comment">% figure, imagesc(xw,yw,Pgrid), colorbar, title('</span>dimensionless pressure (-)<span class="string">'), axis equal</span>
<span class="comment">% clim([-1 3]), colorbar</span>
<span class="comment">% figure, imagesc(xw,yw,Pref), colorbar, title('</span>reference dimensionless pressure (-)<span class="string">'), axis equal</span>
<span class="comment">% clim([-1 3]), colorbar</span>
<span class="comment">% figure, scatter(XYinformed(:,1),XYinformed(:,2),rbeadinformed,Pbead,'</span>filled')</span></code></pre></div>
</div>
<div id='Billy_results_template_PBC_alt' class='doc-content' style='display: none;'>
<h1>####################################################################################</h1>
<p>This is fork of the main script Billy_reusults_template_PBC<br/>To be used for testing alternative parameters on a non main stream machine<br/>####################################################################################</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% ####################################################################################</span>
<span class="comment">%   This is fork of the main script Billy_reusults_template_PBC</span>
<span class="comment">%   To be used <span class="keyword">for</span> testing alternative parameters on a non main stream machine</span>
<span class="comment">% ####################################################################################</span>

<span class="comment">% First template to retrieve Billy<span class="string">'s paper 2 simulation data </span>
<span class="comment">% rev. 2024/03/17 - forked in 2024/03/16 with PBC</span>

<span class="comment">% 2024/03/07 implementation of reverse streamlines, streamline binning from their initial positions, subsampling</span>
<span class="comment">% 2024/03/12 implement bead along streamlines (bug:NaN and Inf not allowed.) </span>
<span class="comment">% 2024/03/16 fork from Billy_results_template.m (MAJOR UPDATE)</span>
<span class="comment">% 2024/03/17 release candidate</span>
<span class="comment">% 2024/03/21 preproduction</span>
<span class="comment">% 2024/03/24 major update: full implementation of density correction and force contours around objects</span>
<span class="comment">% 2024/03/24 selective copy possible <span class="keyword">if</span> originalroot is made available</span>
<span class="comment">% 2024/03/24 add prefetch management</span>
<span class="comment">% 2024/03/25 first batch of preproduction tframe 0.3->1.1 (step 0.01)</span>
<span class="comment">% 2024/03/26 second batch of preproduction tframe 0.11->0.4 (step 0.01)</span>
<span class="comment">% 2024/03/27 fix streamlines when less than one bead must be added (tframe = 0.11 and 0.27)</span>
<span class="comment">% 2024/03/27 fix contour, tangents/normals, add perssure</span>
<span class="comment">% 2024/03/27 Senstivity challenge test using ngenerations = 8 and xshift = double(mod(igen-1,2)*(xwPBC(indxstreamline(2))-xwPBC(indxstreamline(1))));</span>


<span class="comment">% SUMMARY</span>

<span class="comment">% This MATLAB script is a comprehensive framework <span class="keyword">for</span> analyzing fluid dynamics simulations, specifically focusing on the distribution and movement of particles or beads in a fluid environment. Key functionalities include:</span>
<span class="comment">% </span>
<span class="comment">% 1. Environment Setup:</span>
<span class="comment">%   Initializes the simulation environment by clearing variables, setting up output folders, and defining file paths to simulation data, with adjustments <span class="keyword">for</span> periodic boundary conditions (PBC).</span>
<span class="comment">% 2. Data Retrieval:</span>
<span class="comment">%   Loads simulation data from specified file paths, handling different configurations and viscosity models.</span>
<span class="comment">% 3. Simulation Analysis:</span>
<span class="comment">%   Processes the simulation data to calculate parameters such as bead sizes, timestep intervals, and spatial distributions of particles.</span>
<span class="comment">% 4. Frame Selection:</span>
<span class="comment">%   Identifies simulation frames <span class="keyword">for</span> detailed analysis based on time criteria, with capabilities to adjust <span class="keyword">for</span> available data subsets.</span>
<span class="comment">% 5. Velocity Field and Density Calculation:</span>
<span class="comment">%   Computes the velocity field at a specific plane in the simulation domain and estimates the local density of particles.</span>
<span class="comment">% 6. Streamline and Bead Distribution Analysis:</span>
<span class="comment">%   Generates streamlines and distributes beads along these lines, incorporating PBC adjustments to simulate continuous fluid flow across boundaries.</span>
<span class="comment">% 7. Overlap Removal:</span>
<span class="comment">%   Implements algorithms to remove overlapping beads based on their spatial proximity and streamline generation, ensuring a realistic particle distribution.</span>
<span class="comment">% 8. Density Filtering:</span>
<span class="comment">%   Filters out beads in regions of excessively high simulated density to adhere to physical constraints.</span>
<span class="comment">% 9. Contact Detection with Objects:</span>
<span class="comment">%   Identifies beads in contact with solid objects within the simulation, leveraging density information to infer interaction dynamics.</span>
<span class="comment">% 10. Visual Representation:</span>
<span class="comment">%   Provides extensive plotting capabilities to visualize various aspects of the simulation, including velocity fields, bead distributions, and pressure around objects, with options to export figures.</span>

<span class="comment">%% Definitions</span>
close all
clearvars -except tframe tframelist RESETPREFETCH
outputfolder = fullfile(pwd,'</span>preproduction<span class="string">');
prefetchfolder = fullfile(pwd,'</span>prefetch<span class="string">');
<span class="keyword">if</span> ~exist(outputfolder,'</span>dir<span class="string">'), mkdir(outputfolder); <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(prefetchfolder,'</span>dir<span class="string">'), mkdir(prefetchfolder); <span class="keyword">end</span>
fighandle = @(id) formatfig(figure,'</span>figname<span class="string">',sprintf('</span>t<span class="comment">%0.3g_%s<span class="string">',tframe,id));</span>
printhandle = @(hfig) print_png(300,fullfile(outputfolder,[get(hfig,'</span>filename<span class="string">') '</span>.png<span class="string">']),'</span><span class="string">','</span><span class="string">',0,0,0);
<span class="keyword">if</span> ~exist('</span>RESETPREFETCH<span class="string">','</span>var<span class="string">'), RESETPREFETCH = false; <span class="keyword">end</span>
prefetchvar = @(varargin) fullfile(prefetchfolder,sprintf('</span>t<span class="comment">%0.4f_%s.mat<span class="string">',tframe,varargin{1}));</span>
isprefetch = @(varargin) exist(prefetchvar(varargin{1}),'</span>file<span class="string">') && ~RESETPREFETCH;

<span class="comment">%% path and metadata</span>
originalroot = '</span>/media/olivi/T7 Shield/Thomazo_V2<span class="string">';
<span class="keyword">if</span> exist(originalroot,'</span>dir<span class="string">')
    root = originalroot;
    rootlocal = fullfile(pwd,'</span>smalldumps<span class="string">');
    copymode = true;
<span class="keyword">else</span>
    root = fullfile(pwd,'</span>smalldumps<span class="string">');
    copymode = false;
<span class="keyword">end</span>

simfolder = ...
    struct(...
    '</span>A1<span class="string">',struct('</span>artificial<span class="string">',...
'</span>Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz<span class="string">',...
    '</span>Morris<span class="string">',...
'</span>Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz<span class="string">' ...
                ),...
    '</span>A2<span class="string">',struct('</span>artificial<span class="string">',...
'</span>./Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_2.tar.gz<span class="string">' ...
    ),...
    '</span>B1<span class="string">',struct('</span>Morris<span class="string">',...
'</span>./Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft.tar.gz<span class="string">' ...
    ),...
    '</span>B2<span class="string">',struct('</span>Morris<span class="string">',...
'</span>Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_1.tar.gz<span class="string">' ...
    ),...
    '</span>B3<span class="string">',struct('</span>Morris<span class="string">',...
'</span>/Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_2_3.tar.gz<span class="string">' ...
    ) ...
    );

<span class="comment">% selection (not change it <span class="keyword">if</span> you do not have the full dataset/hard disk attached to your system)</span>
config = '</span>A1<span class="string">';
viscosity = '</span>Morris<span class="string">';
sourcefolder= fullfile(root,rootdir(simfolder.(config).(viscosity)));
sourcefile = regexprep(lastdir(simfolder.(config).(viscosity)),'</span>.tar.gz$<span class="string">','</span><span class="string">');
dumpfile = fullfile(sourcefolder,sourcefile);

<span class="comment">%% extract information</span>
X0 = lamdumpread2(dumpfile); <span class="comment">% first frame</span>
natoms = X0.NUMBER;
timesteps = X0.TIMESTEPS;
X1 = lamdumpread2(dumpfile,'</span>usesplit<span class="string">',[],timesteps(2));
dt = (X1.TIME-X0.TIME)/(timesteps(2)-timesteps(1)); <span class="comment">% integration time step</span>
times = double(timesteps * dt); <span class="comment">% in seconds </span>
atomtypes = unique(X0.ATOMS.type);
ntimesteps = length(timesteps);
T = X0.ATOMS.type;
natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
[~,ind] = sort(natomspertype,'</span>descend<span class="string">');
<span class="comment">% Thomazo simulation details</span>
fluidtype  = ind(1);
pillartype = ind(2);
walltype   = ind(3);
spheretype = ind(4);
coords = {'</span>z<span class="string">','</span>x<span class="string">','</span>y<span class="string">'}; <span class="comment">% to match Thomazo'</span>s movies</span>
vcoords = cellfun(@(c) sprintf(<span class="string">'v<span class="comment">%s'</span>,c),coords,<span class="string">'UniformOutput'</span>,false);</span>
icoords = cellfun(@(c) find(ismember({<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>},c)),coords); <span class="comment">%<- use this index <span class="keyword">for</span> BOX</span>
<span class="comment">% Simulation parameters</span>
mbead = 4.38e-12; <span class="comment">% kg</span>
rho = 1000; <span class="comment">% kg / m3 (density of the fluid)</span>
Vbead = mbead/rho;


<span class="comment">%% copy files (<span class="keyword">if</span> possible)</span>
<span class="keyword">if</span> copymode
    myprefetchfile = @(itime) sprintf(<span class="string">'<span class="comment">%s%09d.mat'</span>,<span class="string">'TIMESTEP_'</span>,itime);</span>
    myprefetchfolder = @(d) fullfile(d,sprintf(<span class="string">'PREFETCH_<span class="comment">%s'</span>,lastdir(dumpfile)));</span>
    destinationfolder = fullfile(rootlocal,rootdir(simfolder.(config).(viscosity)));
    sourcefolderPREFETCH = myprefetchfolder(sourcefolder);
    destinationfolderPREFETCH = myprefetchfolder(destinationfolder);
    tcopy = 0.1:0.01:1.1;
    tfile = arrayfun(@(t) myprefetchfile(t), timesteps(unique(nearestpoint(tcopy,times))),<span class="string">'UniformOutput'</span>,false);
    oksource = all(cellfun(@(f) exist(fullfile(sourcefolderPREFETCH,f),<span class="string">'file'</span>),tfile));
    <span class="keyword">if</span> ~oksource, error(<span class="string">'the source folder is corrupted, please check'</span>), <span class="keyword">end</span>
    existingfiles = cellfun(@(f) exist(fullfile(destinationfolderPREFETCH,f),<span class="string">'file'</span>),tfile);
    dispf(<span class="string">'Number of files to copy: <span class="comment">%d (%d already available)'</span>,length(find(~existingfiles)),length(find(existingfiles)))</span>
    copysuccess = cellfun(@(f) copyfile(fullfile(sourcefolderPREFETCH,f),fullfile(destinationfolderPREFETCH,f)),tfile(~existingfiles));
    dispf(<span class="string">'<span class="comment">%d of %d files have been copied'</span>,length(find(copysuccess)),length(copysuccess));</span>
<span class="keyword">end</span>

<span class="comment">%% Estimate bead size from the first frame</span>
<span class="comment">% first estimate assuming that the bead is a cube</span>
fluidxyz0 = X0.ATOMS{T==fluidtype,coords};
boxdims = X0.BOX(:,2) - X0.BOX(:,1);
Vbead_guess = prod(boxdims)/natoms;
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
<span class="keyword">if</span> isprefetch(<span class="string">'verletList'</span>)
    load(prefetchvar(<span class="string">'verletList'</span>))
<span class="keyword">else</span>
    [verletList,cutoff,dmin,config,dist] = buildVerletList(fluidxyz0,cutoff);
    save(prefetchvar(<span class="string">'verletList'</span>),<span class="string">'verletList'</span>,<span class="string">'cutoff'</span>,<span class="string">'dmin'</span>,<span class="string">'config'</span>,<span class="string">'dist'</span>)
<span class="keyword">end</span>
rbead = dmin/2;
s = 2*rbead; <span class="comment">% separation distance</span>
h = 2*s;     <span class="comment">% smoothing length</span>

<span class="comment">%% load the frame closest to simulation time: tframe</span>
<span class="comment">% with the mini dataset, are available:</span>
<span class="comment">% 0.30s 0.40s 0.45s 0.50s 0.55s 0.60s 0.65s 0.70s 0.75s 0.80s 0.85s 0.90s 0.95s 1.00s 1.05s 1.10s </span>
<span class="comment">% tframelist = [0.3 0.4 0.45:0.05:1.10]; % verysmalldumps</span>
tframelist = 0.1:0.01:1.1; <span class="comment">% updated time frames</span>
<span class="keyword">if</span> ~exist(<span class="string">'tframe'</span>,<span class="string">'var'</span>)
    tframe = 0.85; <span class="comment">%0.55; % s <-------------------- select time here</span>
<span class="keyword">else</span>
    tframe = tframelist(nearestpoint(tframe,tframelist)); <span class="comment">% restrict to existing tframes</span>
<span class="keyword">end</span>
iframe = nearestpoint(tframe,times); <span class="comment">% closest index</span>
Xframe = lamdumpread2(dumpfile,<span class="string">'usesplit'</span>,[],timesteps(iframe));
Xframe.ATOMS.isfluid = Xframe.ATOMS.type==fluidtype;
Xframe.ATOMS.ispillar = Xframe.ATOMS.type==pillartype;
Xframe.ATOMS.issphere = Xframe.ATOMS.type==spheretype;
Xframe.ATOMS.issolid = Xframe.ATOMS.type==spheretype | Xframe.ATOMS.type==pillartype;
fluidxyz = Xframe.ATOMS{Xframe.ATOMS.isfluid,coords};
fluidid = X0.ATOMS{Xframe.ATOMS.isfluid,<span class="string">'id'</span>};
pillarxyz = Xframe.ATOMS{Xframe.ATOMS.ispillar,coords};
pillarid = X0.ATOMS{Xframe.ATOMS.ispillar,<span class="string">'id'</span>};
spherexyz = Xframe.ATOMS{Xframe.ATOMS.issphere,coords};
sphereid = X0.ATOMS{Xframe.ATOMS.issphere,<span class="string">'id'</span>};
solidxyz = Xframe.ATOMS{Xframe.ATOMS.issolid,coords};
solidid = X0.ATOMS{Xframe.ATOMS.issolid,<span class="string">'id'</span>};
ztop = max(pillarxyz(:,3)); <span class="comment">% pillar top</span>

<span class="comment">%% Interpolate velocity field at z = ztop</span>
<span class="comment">% full box (note that atoms may be outside of this box)</span>
box = Xframe.BOX(icoords,:); <span class="comment">% note that the order is given by coords, here {<span class="string">'z'</span>}    {<span class="string">'x'</span>}    {<span class="string">'y'</span>}</span>
boxsize = diff(box,1,2);
<span class="comment">% fluidbox (box <span class="keyword">for</span> atoms to consider)</span>
xmin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{1}});
xmax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{1}});
ymin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{2}});
ymax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{2}});
zmin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{3}});
zmax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{3}});
fluidbox = [xmin xmax;ymin ymax;zmin zmax];
<span class="comment">% restrict interpolation to the viewbox</span>
viewbox = fluidbox; viewbox(3,:) = [ztop-2*h ztop+2*h];
insideviewbox = true(height(Xframe.ATOMS),1);
<span class="keyword">for</span> icoord = 1:3
    insideviewbox = insideviewbox ...
        & Xframe.ATOMS{:,coords{icoord}}>=viewbox(icoord,1) ...
        & Xframe.ATOMS{:,coords{icoord}}<=viewbox(icoord,2);
<span class="keyword">end</span>
XYZ  = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,coords};  <span class="comment">% fluid kernel centers</span>
vXYZ = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,vcoords}; <span class="comment">% velocity of fluid kernel centers</span>
XYZs = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.issolid,coords};  <span class="comment">% solid kernel centers</span>
rhobeadXYZ = Xframe.ATOMS.c_rho_smd(insideviewbox & Xframe.ATOMS.isfluid); <span class="comment">% volume of the bead</span>

<span class="comment">% force incell (this step is needed to apply PBC)</span>
XYZ = PBCincell(XYZ,box,[true,true,false]);
XYZs = PBCincell(XYZs,box,[true,true,false]);

<span class="comment">% add PBC images</span>
[XYZimagesONLY ,indXimagesONLY]= PBCimages(XYZ,box,[true,true,false],2*h);
figure, hold on, plot3D(XYZ,<span class="string">'go'</span>)
plot3D(XYZ(indXimagesONLY,:),<span class="string">'go'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'g'</span>)
plot3D(XYZimagesONLY,<span class="string">'ro'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>), view(3), axis equal, view(2)
XYZwithImages = [XYZ;XYZimagesONLY];
vXYZwithImages = [vXYZ;vXYZ(indXimagesONLY,:)];
rhobeadXYZwithImages = [rhobeadXYZ;rhobeadXYZ(indXimagesONLY)];
VbeadXYZwithImages = mbead./rhobeadXYZwithImages;
isImages = true(size(XYZwithImages,1),1); isImages(1:size(XYZ,1))=false;

<span class="comment">% interpolation grid (central grid, no images)</span>
nresolution = [1024 1024 1];
xw = linspace(box(1,1),box(1,2),nresolution(1));
yw = linspace(box(2,1),box(2,2),nresolution(1));
zw = ztop;
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];

<span class="comment">% grid neighbors (incl. images) <span class="keyword">for</span> interpolation and discarding grid points overlapping solid</span>
<span class="keyword">if</span> isprefetch(<span class="string">'VXYZ'</span>)
    load(prefetchvar(<span class="string">'VXYZ'</span>))
<span class="keyword">else</span>
    VXYZ  = buildVerletList({XYZgrid XYZwithImages},1.2*h);  <span class="comment">% neighbors = fluid particles</span>
    VXYZs = buildVerletList({XYZgrid XYZs},0.85*s); <span class="comment">% neighbors = solid particles</span>
    save(prefetchvar(<span class="string">'VXYZ'</span>),<span class="string">'VXYZ'</span>,<span class="string">'VXYZs'</span>)
<span class="keyword">end</span>
icontactsolid = find(cellfun(@length,VXYZs)>0);
VXYZ(icontactsolid) = repmat({[]},length(icontactsolid),1);

<span class="comment">% interpolation on the grid of the 3D velocity (central grid)</span>
<span class="comment">% Do not forget even <span class="keyword">if</span> we are applying a 2D interpretation, we use a 3D simulation</span>
<span class="comment">% 3D velocity are projected on 2D streamlines even <span class="keyword">if</span> the projection of the 3rd component is 0</span>
W = kernelSPH(h,<span class="string">'lucy'</span>,3); <span class="comment">% kernel expression</span>
<span class="keyword">if</span> isprefetch(<span class="string">'v3XYZgrid'</span>)
    load(prefetchvar(<span class="string">'v3XYZgrid'</span>))
<span class="keyword">else</span>
    v3XYZgrid = interp3SPHVerlet(XYZwithImages,vXYZwithImages,XYZgrid,VXYZ,W,VbeadXYZwithImages);
    save(prefetchvar(<span class="string">'v3XYZgrid'</span>),<span class="string">'v3XYZgrid'</span>)
<span class="keyword">end</span>
vxXYZgrid = reshape(v3XYZgrid(:,1),size(Xw)); <span class="comment">%vxXYZgrid(isnan(vxXYZgrid)) = 0;</span>
vyXYZgrid = reshape(v3XYZgrid(:,2),size(Xw)); <span class="comment">%vyXYZgrid(isnan(vyXYZgrid)) = 0;</span>
vzXYZgrid = reshape(v3XYZgrid(:,3),size(Xw)); <span class="comment">%vzXYZgrid(isnan(vzXYZgrid)) = 0;</span>
vXYZgrid  = reshape(sqrt(sum(v3XYZgrid.^2,2)),size(Xw));

<span class="comment">% density on the grid (with a possible different h)</span>
<span class="keyword">if</span> isprefetch(<span class="string">'rhobeadXYZgrid'</span>)
    load(prefetchvar(<span class="string">'rhobeadXYZgrid'</span>))
<span class="keyword">else</span>
    rhobeadXYZgrid = interp3SPHVerlet(XYZwithImages,rhobeadXYZwithImages,XYZgrid,VXYZ,W,VbeadXYZwithImages);
    save(prefetchvar(<span class="string">'rhobeadXYZgrid'</span>),<span class="string">'rhobeadXYZgrid'</span>)
<span class="keyword">end</span>
rhobeadXYZgrid = reshape(rhobeadXYZgrid,size(Xw));

<span class="comment">% add PBC (add periodic PBC)</span>
[vxXYZPBC,XwPBC,YwPBC] = PBCgrid(Xw,Yw,vxXYZgrid,[true,true],boxsize(1:2)./[8;2]);
rhobeadXYZPBC = PBCgrid(Xw,Yw,rhobeadXYZgrid,[true,true],boxsize(1:2)./[8;2]);
xwPBC = XwPBC(1,:); ywPBC = YwPBC(:,1)<span class="string">';
fluidboxPBC = double([xwPBC([1 <span class="keyword">end</span>]);ywPBC([1 <span class="keyword">end</span>]);fluidbox(3,:)]);
fluidboxsizePBC = diff(fluidboxPBC,1,2);
vyXYZPBC = PBCgrid(Xw,Yw,vyXYZgrid,[true,true],boxsize(1:2)./[8;2]);
vzXYZPBC = PBCgrid(Xw,Yw,vzXYZgrid,[true,true],boxsize(1:2)./[8;2]);
vXYZPBC = sqrt(vxXYZPBC.^2 + vyXYZPBC.^2 + vzXYZPBC.^2);
figure, mesh(XwPBC,YwPBC,vXYZPBC), axis equal, view(2), colorbar, title(sprintf('</span>t=<span class="comment">%0.3f s - velocity (m/s)<span class="string">',tframe))</span>
figure, mesh(XwPBC,YwPBC,rhobeadXYZPBC); axis equal, view(2), colorbar, title(sprintf('</span>t=<span class="comment">%0.3f s - density (kg/m3)<span class="string">',tframe))</span>

<span class="comment">%% Plot (attention 2D, meshgrid convention)</span>
figure, hold on
<span class="comment">% velocity magnitude</span>
imagesc(xwPBC,ywPBC,vXYZPBC)
axis tight, axis equal
colorbar
title(sprintf('</span>t=<span class="comment">%0.3f s - velocity (m/s)<span class="string">',tframe))</span>

<span class="comment">% quiver configuration and plot (boundaries are with PBC)</span>
stepPBC = 16;
boundariesPBC = ...
             [ nearestpoint(double(xwPBC([1,<span class="keyword">end</span>]))+fluidboxsizePBC(1)/100*[1 -1],double(xwPBC)) <span class="comment">% x</span>
               nearestpoint(double(ywPBC([1,<span class="keyword">end</span>]))+fluidboxsizePBC(2)/100*[1 -1],double(ywPBC)) <span class="comment">% y</span>
             ];
indxquiver = boundariesPBC(1,1):stepPBC:boundariesPBC(1,2); <span class="comment">% x indices</span>
indyquiver = boundariesPBC(2,1):stepPBC:boundariesPBC(2,2); <span class="comment">% y indices</span>
quiver(XwPBC(indyquiver,indxquiver),YwPBC(indyquiver,indxquiver), ...
          vxXYZPBC(indyquiver,indxquiver),vyXYZPBC(indyquiver,indxquiver), ...
        '</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',1)


<span class="comment">%% streamlines</span>
<span class="comment">% UP from bottom (starting position) to top</span>
<span class="comment">% DOWN from top to bottom (same starting position by reversing the velocity field)</span>
<span class="comment">% assembled as [flipud(DOWN(2:<span class="keyword">end</span>,:));UP]</span>
<span class="comment">% CELL streamlines along a y period, the separation distance is added to avoid gap</span>

<span class="comment">% streamline configuration and plot</span>
boundaries = [ nearestpoint(double(xw([1,<span class="keyword">end</span>])),double(xwPBC))
               nearestpoint(double(yw([1,<span class="keyword">end</span>])),double(ywPBC))
             ];
step = 8;
indxstreamline = boundaries(1,1):step:boundaries(1,2);
indystreamline = boundaries(2,1):step:boundaries(2,2);
nstreamlines = length(indxstreamline);

<span class="comment">% Generative streamlines</span>
ngenerations = 4*2;
iygen = unique(round(linspace(indystreamline(1),indystreamline(<span class="keyword">end</span>),ngenerations)));
ngenerations = length(iygen);
[verticesgenUP,verticesgenDOWN,verticesgen,verticesgenCELL,verticesgenCELLid] = deal({});
validstreamline = @(v) (v(:,2)-v(1,2))<=(boxsize(2)*1.5) & (v(:,2)-v(1,2))>=(boxsize(2)*0.01); <span class="comment">% longer than 1% but not exceeding 150%</span>
<span class="keyword">for</span> igen = 1:ngenerations
    <span class="comment">% ith generation of stream line (from indystreamline(1))</span>
    dispf('</span>generates the <span class="comment">%dth of %d generation of streamlines<span class="string">',igen,ngenerations)</span>
    xshift = double(mod(igen-1,2)*(xwPBC(indxstreamline(2))-xwPBC(indxstreamline(1))));
    [startgenX,startgenY,startgenZ] = meshgrid(...
        double(xwPBC(indxstreamline))+xshift,...
        double(ywPBC(iygen(igen))),double(ztop));
    verticesgenUP{igen} = stream2(double(XwPBC),double(YwPBC),vxXYZPBC,vyXYZPBC,startgenX,startgenY,[0.03 5e4]);
    verticesgenDOWN{igen} = stream2(double(XwPBC),double(YwPBC),-vxXYZPBC,-vyXYZPBC,startgenX,startgenY,[0.03 5e4]);
    verticesgen{igen} = cellfun(@(d,u) [flipud(d(2:<span class="keyword">end</span>,:)); u],verticesgenDOWN{igen},verticesgenUP{igen},'</span>UniformOutput<span class="string">',false);
    verticesgen{igen} = cellfun(@(v) v(~isnan(v(:,2)),:),verticesgen{igen},'</span>UniformOutput<span class="string">',false);
    verticesgenCELL{igen} = cellfun(@(v) v(validstreamline(v),:),verticesgen{igen},'</span>UniformOutput<span class="string">',false);
    verticesgenCELLid{igen} = igen*ones(1,length(verticesgenCELL{igen}));
<span class="keyword">end</span>

<span class="comment">% merge all verticesCELL</span>
verticesCELL = cat(2,verticesgenCELL{:});
verticesCELLid = cat(2,verticesgenCELLid{:});
okverticesCELL = cellfun(@length,verticesCELL)>100; <span class="comment">% remove empty and too short streamlines (as a result of filtering by validstreamline)</span>
verticesCELL = verticesCELL(okverticesCELL);
verticesCELLid = verticesCELLid(okverticesCELL);

<span class="comment">% retrieve the separation distance</span>
sLagrangian = startgenX(1,2,1) - startgenX(1,1,1); <span class="comment">% separation distance between streamlines at injection/starting</span>
rLagrangian = sLagrangian/2;


<span class="comment">% detect interruption (<span class="keyword">for</span> control)</span>
<span class="comment">% yfinalposition1UP = cellfun(@(v) v(<span class="keyword">end</span>,2),vertices1UP);</span>
<span class="comment">% yfinalposition1DOWN = cellfun(@(v) v(<span class="keyword">end</span>,2),vertices1DOWN);</span>
<span class="comment">% isinterrupted1 = isnan(yfinalposition1UP) | isnan(yfinalposition1DOWN);</span>

<span class="comment">% control plot</span>
figure, hold on
imagesc(xwPBC,ywPBC,vXYZPBC)
colors = jet(ngenerations);

<span class="keyword">for</span> igen = 1:ngenerations
    <span class="keyword">for</span> i=1:nstreamlines
        plot(verticesgen{igen}{i}(:,1),verticesgen{igen}{i}(:,2),'</span>-<span class="string">','</span>LineWidth<span class="string">',0.5,'</span>color<span class="string">',colors(igen,:))
        plot(verticesgenCELL{igen}{i}(:,1),verticesgenCELL{igen}{i}(:,2),'</span>-<span class="string">','</span>linewidth<span class="string">',1,'</span>color<span class="string">',colors(igen,:));
    <span class="keyword">end</span>
<span class="keyword">end</span>
axis equal
title(sprintf('</span>t=<span class="comment">%0.3f s - streamlines<span class="string">',tframe))</span>

<span class="comment">%% Distribute beads along streamlines tagged as CELL</span>
<span class="comment">% Once PBC are applied, space is filled with possibly overlaping streamlines</span>
<span class="comment">% the control plot is showing this effect</span>


traj = fillstreamline2(verticesCELL,XwPBC,YwPBC,vxXYZPBC,vyXYZPBC,rLagrangian,0);
ntraj = length(traj);
<span class="comment">%trajUP = fillstreamline2(verticesUPCELL,XwPBC,YwPBC,vxXYZPBC,vyXYZPBC,rLagrangian,0);</span>
<span class="comment">%traj(~isinterrupted) = trajUP(~isinterrupted);</span>
XYZbeads = arrayfun(@(t) t.cart_distribution,traj,'</span>UniformOutput<span class="string">',false);
<span class="comment">% we apply PBC <span class="keyword">while</span> keeping the id of the streamline</span>
[XYZbeadsPBC,XYZbeadsPBCid] = deal(cell(ntraj,1));
<span class="keyword">for</span> itraj=1:ntraj <span class="comment">% trajectories and streamlines are assumed equivalent at steady state</span>
    XYZbeadsPBC{itraj} = PBCincell(XYZbeads{itraj},box(1:2,:),[true true]); <span class="comment">% wrapping along PBC</span>
    XYZbeadsPBCid{itraj} = ones(size(XYZbeadsPBC{itraj},1),1)*verticesCELLid(itraj);
<span class="keyword">end</span>

<span class="comment">% control plots</span>
figure, hold on
colors = tooclear(jet(ntraj));
<span class="keyword">for</span> itraj = 1:ntraj
    plot(XYZbeadsPBC{itraj}(:,1),XYZbeadsPBC{itraj}(:,2),'</span>o<span class="string">','</span>markerfacecolor<span class="string">',colors(itraj,:),'</span>markeredgecolor<span class="string">',colors(itraj,:))
<span class="keyword">end</span>
title(sprintf('</span>t=<span class="comment">%0.3f s - colors match streamline index<span class="string">',tframe))</span>

figure, hold on
colors = tooclear(jet(ngenerations));
<span class="keyword">for</span> itraj = 1:ntraj
    plot(XYZbeadsPBC{itraj}(:,1),XYZbeadsPBC{itraj}(:,2),'</span>o<span class="string">','</span>markerfacecolor<span class="string">',colors(XYZbeadsPBCid{itraj}(1),:),'</span>markeredgecolor<span class="string">',colors(XYZbeadsPBCid{itraj}(1),:))
<span class="keyword">end</span>
title(sprintf('</span>t=<span class="comment">%0.3f s - colors match generation index<span class="string">',tframe))</span>

<span class="comment">%% remove duplicated beads between streamlines (too close)</span>
<span class="comment">% defined as beads from another streamline located at less than rbead</span>
<span class="comment">% this version incorporate the effect of the generational distance (somekind of age)</span>
<span class="comment">% beads from other injections points should emerge from positions farther from first generations (older ones)</span>
<span class="comment">% the generation index starts from the source of the flow (bottom), using streamlines from other positions is discouraged (since younger)</span>
<span class="comment">% </span>
<span class="comment">% Note: streamlines are indexed from oldest (closest to the source) to youngest (farthest from the source)</span>

<span class="comment">% beads from different streamlines</span>
<span class="keyword">for</span> i=1:ntraj <span class="comment">% reference streamline (higher precedence)</span>
    <span class="keyword">for</span> j=1:ntraj <span class="comment">% the other streamline</span>
        <span class="keyword">if</span> i~=j
            indj = find(~isnan(XYZbeadsPBC{j}(:,1)));
            dij=pdist2(XYZbeadsPBC{i},XYZbeadsPBC{j}(indj,:)); <span class="comment">% Euclidian distance</span>
            <span class="comment">% the criterion on age is too strict</span>
            <span class="comment">%dgenij = pdist2(XYZbeadsPBCid{i},XYZbeadsPBCid{j}(indj,:)); % generational distance (0 <span class="keyword">for</span> the same generation)</span>
            <span class="comment">%XYZbeadsPBC{j}(indj(any(dij<rLagrangian*sqrt(2)*(1+dgenij),1)),:) = NaN;</span>
            XYZbeadsPBC{j}(indj(any(dij<rLagrangian*sqrt(2),1)),:) = NaN;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% beads from the same streamline</span>
<span class="comment">% two populations of beads are created (those inside and those outside (images) that could overlap those inside when they coordinates are wrapped)</span>
<span class="comment">%</span>
<span class="comment">% Note: we do not consider the overlapping of north and south images (the total height of a streamline is considered not to exceed 150% of the box height)</span>
<span class="keyword">for</span> i=1:ntraj
    isoutside =  (XYZbeads{i}(:,1)<box(1,1)) | (XYZbeads{i}(:,1)>box(1,2)) | ...
                 (XYZbeads{i}(:,2)<box(2,1)) | (XYZbeads{i}(:,2)>box(2,2) );
    isvalid = ~isnan(XYZbeadsPBC{i}(:,1));
    ioutside = find(isoutside & isvalid);  <span class="comment">% these beads are possible images of beads already inside</span>
    iinside =  find(~isoutside & isvalid); <span class="comment">% these beads have higher precedence, they are already inside</span>
    divsout=pdist2(XYZbeadsPBC{i}(iinside,:),XYZbeadsPBC{i}(ioutside,:));
    XYZbeadsPBC{i}(ioutside(any(divsout<rLagrangian*sqrt(2),1)),:) = NaN;
<span class="keyword">end</span>

XYZbeadsPBCall = cat(1,XYZbeadsPBC{:});
XYZbeadsPBCidall = cat(1,XYZbeadsPBCid{:});
isPBCallok = ~isnan(XYZbeadsPBCall(:,1));
XYZbeadsPBCall = XYZbeadsPBCall(isPBCallok,:);
XYZbeadsPBCidall = XYZbeadsPBCidall(isPBCallok,:);

<span class="comment">% control <span class="keyword">while</span> keeping the generational index</span>
hfig = fighandle('</span>packing<span class="string">');  hold on
colors = tooclear(hsv(ngenerations)); <span class="comment">%turbo</span>
<span class="keyword">for</span> igen=1:ngenerations
    viscircles(XYZbeadsPBCall(XYZbeadsPBCidall==igen,:),rLagrangian,'</span>color<span class="string">',colors(igen,:));
<span class="keyword">end</span>
title(sprintf('</span>t=<span class="comment">%0.3f s - one color per injection line<span class="string">',tframe)), axis equal</span>

PRINTON = true;
<span class="keyword">if</span> PRINTON, printhandle(hfig), <span class="keyword">end</span>

<span class="comment">%% Filtering: remove overlapping from different injections using a first estimate of density</span>

<span class="comment">% Summary</span>
<span class="comment">% This methodology effectively redistributes beads to ensure that local densities do not exceed</span>
<span class="comment">% the physical limits of the simulation, enhancing realism and accuracy. By adjusting bead </span>
<span class="comment">% distributions based on calculated densities and employing PBC to handle edge cases, the script </span>
<span class="comment">% ensures a uniformly plausible representation of bead distributions across the simulation domain.</span>

hfilter = 4*rLagrangian;
XYbeadsfilterid = XYZbeadsPBCidall;
XYbeadsfilter = XYZbeadsPBCall; 
nfilter = size(XYbeadsfilter,1);
XYbeadsfilter_images= PBCimages(XYbeadsfilter,box(1:2,:),[true,true],2*hfilter);
XYbeadsfilterwithImages = [XYbeadsfilter;XYbeadsfilter_images];
Vbeadsfilter = buildVerletList(XYbeadsfilter,hfilter);
VbeadsfilterBC = buildVerletList({XYbeadsfilter XYbeadsfilterwithImages},hfilter);
Volfilter = length(find(~isnan(rhobeadXYZgrid(:))))/numel(rhobeadXYZgrid) * boxsize(1) * boxsize(2) * s;
mfilter = rho*Volfilter/size(XYbeadsfilter,1); <span class="comment">% mass of a single bead (informed)</span>
Vfilter = mfilter/rho;
Wfilter = kernelSPH(hfilter,'</span>lucy<span class="string">',2);
rhofilter = interp2SPHVerlet(...
    XYbeadsfilterwithImages,...
    rho*ones(size(XYbeadsfilterwithImages,1),1),...
    XYbeadsfilter,VbeadsfilterBC,Wfilter,Vfilter)/s; 

<span class="comment">% target</span>
rhomax = 1500;
ok = rhofilter<=rhomax;

<span class="comment">% before</span>
hfig = fighandle('</span>packing_rhomax<span class="string">');  hold on
viscircles(XYbeadsfilter(ok,:),rLagrangian,'</span>color<span class="string">','</span>b<span class="string">');
viscircles(XYbeadsfilter(~ok,:),rLagrangian,'</span>color<span class="string">','</span>r<span class="string">');
title(sprintf('</span>t=<span class="comment">%0.3f s - in red: excess density<span class="string">',tframe)), axis equal</span>


PRINTON = true;
<span class="keyword">if</span> PRINTON, printhandle(hfig), <span class="keyword">end</span>

<span class="comment">% do filter</span>
itoohigh = find(~ok);
[rhotoohigh,ind] = sort(rhofilter(itoohigh),'</span>descend<span class="string">');
itoohigh = itoohigh(ind);
kept = true(nfilter,1);
<span class="keyword">for</span> k=1:length(itoohigh)
    <span class="comment">% valid neighbors (only)</span>
    jBC = VbeadsfilterBC{itoohigh(k)}; <span class="comment">% it includes self with images</span>
    njBC = length(jBC);
    j = Vbeadsfilter{itoohigh(k)}; <span class="comment">% it includes self without images</span>
    j = j(kept(j));
    [idj,ind] = sort(XYbeadsfilterid(j),'</span>ascend<span class="string">');
    j = j(ind);  nj = length(j);
    jdeletable = j(find(idj>min(idj),1,'</span>first<span class="string">'):<span class="keyword">end</span>); <span class="comment">% we keep the first type</span>
    [rhojdeletable,ind] = sort(rhofilter(jdeletable),'</span>descend<span class="string">');
    jdeletable = jdeletable(ind); njdeletable = length(jdeletable);
    njexcess = floor( (1 - rhomax/rhotoohigh(k)) * njBC );
    kept(jdeletable(1:min(njexcess,njdeletable))) = false;
<span class="keyword">end</span>

<span class="comment">% after</span>
hfig = fighandle('</span>packing_rhomax_fix<span class="string">');  hold on
viscircles(XYbeadsfilter(kept,:),rLagrangian,'</span>color<span class="string">','</span>g<span class="string">');
viscircles(XYbeadsfilter(~kept,:),rLagrangian,'</span>color<span class="string">','</span>r<span class="string">');
title(sprintf('</span>t=<span class="comment">%0.3f s - in red: removed beads<span class="string">',tframe)), axis equal</span>

<span class="keyword">if</span> PRINTON, printhandle(hfig), <span class="keyword">end</span>



<span class="comment">%% calculate density</span>
XYinformed = PBCincell(XYZbeadsPBCall(kept,:),box,[true true]); <span class="comment">% PBC just to be sure</span>
ninformed = size(XYinformed,1);
rinformed = rLagrangian; <span class="comment">%radius</span>
sinformed = 2*rinformed; <span class="comment">% separation distance</span>
hinformed = 5*sinformed; <span class="comment">% <span class="keyword">for</span> integration</span>

<span class="comment">% add PBC images</span>
[XYinformed_images ,indimages]= PBCimages(XYinformed,box(1:2,:),[true,true],2*hinformed);
XYinformedwithImages = [XYinformed;XYinformed_images];
<span class="comment">% Verlet list <span class="keyword">for</span> the original grid</span>
XYgrid = [Xw(:) Yw(:)];
<span class="keyword">if</span> isprefetch('</span>VXYinformed<span class="string">')
    load(prefetchvar('</span>VXYinformed<span class="string">'))
<span class="keyword">else</span>
    VXYinformed  = buildVerletList({XYgrid XYinformedwithImages},hinformed);
    save(prefetchvar('</span>VXYinformed<span class="string">'),'</span>VXYinformed<span class="string">')
<span class="keyword">end</span>
<span class="comment">% Verlet list <span class="keyword">for</span> the informed beads</span>
<span class="keyword">if</span> isprefetch('</span>VXYbeadinformed<span class="string">')
    load(prefetchvar('</span>VXYbeadinformed<span class="string">'))
<span class="keyword">else</span>
    VXYbeadinformed = buildVerletList({XYinformed XYinformedwithImages},hinformed);
    save(prefetchvar('</span>VXYbeadinformed<span class="string">'),'</span>VXYbeadinformed<span class="string">')
<span class="keyword">end</span>
   

<span class="comment">% Calculate the mass of informed beads</span>
<span class="comment">% total volume of fluid in the image</span>
Volinformed = length(find(~isnan(rhobeadXYZgrid(:))))/numel(rhobeadXYZgrid) * boxsize(1) * boxsize(2) * s;
mbeadinformed = rho*Volinformed/ninformed; <span class="comment">% mass of a single bead (informed)</span>

<span class="comment">% 2D Kernel</span>
Winformed = kernelSPH(hinformed,'</span>lucy<span class="string">',2); <span class="comment">% kernel expression [/m2]</span>

<span class="comment">% Calculate the volume of the beads</span>
Vbeadinformedguess = mbeadinformed/rho; <span class="comment">% first guess</span>
<span class="comment">% density at the centers of the informed beads</span>
rhobeadinformed = interp2SPHVerlet(XYinformedwithImages,rho*ones(size(XYinformedwithImages,1),1),XYinformed,VXYbeadinformed,Winformed,Vbeadinformedguess);
rhobeadinformed = rhobeadinformed/s;
<span class="comment">% rhobeadinformed(rhobeadinformed<200) = NaN;</span>
<span class="comment">% rhobeadinformed(isnan(rhobeadinformed)) = median(rhobeadinformed,'</span>omitmissing<span class="string">'); </span>

<span class="comment">% volume of the informed beads</span>
Vbeadinformed = mbeadinformed./rhobeadinformed;
<span class="comment">% normalized radius of informed beads</span>
rbeadinformed = sqrt(Vbeadinformed/(s*pi));
rbeadinformed = rbeadinformed/median(rbeadinformed,'</span>omitmissing<span class="string">') * rLagrangian;
<span class="comment">% control figure</span>
figure, viscircles(XYinformed,rLagrangian,'</span>color<span class="string">','</span>g<span class="string">'), axis equal, hold on
viscircles(XYinformed,rbeadinformed,'</span>color<span class="string">','</span>r<span class="string">')

<span class="comment">% reference density at the same positions</span>
XYZeqinformed = [XYinformed ones(ninformed,1)*ztop];
VXYZeqinformed  = buildVerletList({XYZeqinformed XYZwithImages},1.2*h);
rhobeadXYZ2XYinformed = interp3SPHVerlet(XYZwithImages,rhobeadXYZwithImages,XYZeqinformed,VXYZeqinformed,W,VbeadXYZwithImages);

<span class="comment">% density on the grid</span>
<span class="keyword">if</span> isprefetch('</span>dgrid<span class="string">')
    load(prefetchvar('</span>dgrid<span class="string">'))
<span class="keyword">else</span>
    dgrid = interp2SPHVerlet(XYinformedwithImages,rho*ones(size(XYinformedwithImages,1),1),XYgrid,VXYinformed,Winformed,Vbeadinformedguess);
    save(prefetchvar('</span>dgrid<span class="string">'),'</span>dgrid<span class="string">')
<span class="keyword">end</span>
dgrid = reshape(dgrid/s,size(Xw)); <span class="comment">% /s to get in kg/m3 from kg/m2</span>
dgrid(isnan(rhobeadXYZgrid)) = NaN; <span class="comment">% we mask the objects (pillar and sphere) the same way as in the reference</span>


<span class="comment">%% ---------------------------- PRODUCTION FIGURES</span>
hfig = []; close all

<span class="comment">% Density mapped on beads</span>
hfig(<span class="keyword">end</span>+1) = fighandle('</span>d_bead_informed<span class="string">'); hold on, title(sprintf('</span>[t=<span class="comment">%0.3g s] density mapped to informed beads<span class="string">',tframe))</span>
scatter(XYinformed(:,1),XYinformed(:,2),100*(rbeadinformed/min(rbeadinformed)).^2,rhobeadinformed,'</span>filled<span class="string">'), colorbar
hfig(<span class="keyword">end</span>+1) = fighandle('</span>d_bead_reference<span class="string">'); hold on, title(sprintf('</span>[t=<span class="comment">%0.3g s] reference density mapped to informed beads<span class="string">',tframe))</span>
scatter(XYZeqinformed(:,1),XYZeqinformed(:,2),100*(rbeadinformed/min(rbeadinformed)).^2,rhobeadXYZ2XYinformed,'</span>filled<span class="string">'), colorbar
hfig(<span class="keyword">end</span>+1) = fighandle('</span>d_bead_informed_vs_reference<span class="string">'); plot(rhobeadXYZ2XYinformed(:),rhobeadinformed(:),'</span>ro<span class="string">'), xlabel('</span>reference density (back mapped)<span class="string">'), ylabel('</span>informed density<span class="string">')
title(sprintf('</span>[t=<span class="comment">%0.3g s] informed vs. reference density<span class="string">',tframe))</span>

<span class="comment">% density mapped on the grid</span>
hfig(<span class="keyword">end</span>+1) = fighandle('</span>d_grid_informed<span class="string">'); hp = pcolor(xw,yw,dgrid); hp.EdgeColor = '</span>none<span class="string">'; colorbar, title(sprintf('</span>[t=<span class="comment">%0.3g s] informed density (kg/m3)<span class="string">',tframe)), axis equal %, clim([500 1300])</span>
haxtomodify = gca;
hfig(<span class="keyword">end</span>+1) = fighandle('</span>d_grid_reference<span class="string">'); hp = pcolor(xw,yw,rhobeadXYZgrid); hp.EdgeColor = '</span>none<span class="string">'; colorbar, title(sprintf('</span>[t=<span class="comment">%0.3g s] reference density (kg/m3)<span class="string">',tframe)), axis equal %, clim([500 1300])</span>
clim(haxtomodify,clim)

<span class="comment">% distribution of densities</span>
hfig(<span class="keyword">end</span>+1) = fighandle('</span>distribution_rho<span class="string">');  hold on
histogram(rhobeadinformed), histogram(rhobeadXYZ2XYinformed), legend({'</span>informed density<span class="string">','</span>reference density<span class="string">'})
title(sprintf('</span>[t=<span class="comment">%0.3g s] Density distributions<span class="string">',tframe))</span>


<span class="comment">%% -- identify the beads in contact with objects based on density</span>
<span class="comment">% SUMMARY.</span>
<span class="comment">% This section outlines a methodology <span class="keyword">for</span> identifying beads in contact with solid objects</span>
<span class="comment">% in a fluid simulation, particularly focusing on density-based criteria to determine close</span>
<span class="comment">% interactions and potential contact forces.</span>

<span class="comment">% Attention the sphere can exceed the area observed (overflow condition)</span>
<span class="comment">% Safe coordinates are only use <span class="keyword">for</span> contour identification</span>
isynan = isnan(mean(rhobeadXYZgrid(:,floor(size(rhobeadXYZgrid,2)*0.6):<span class="keyword">end</span>),2));
isoverflow =  (find(isynan,1,'</span>last<span class="string">')-find(isynan,1,'</span>first<span class="string">')+1)==size(rhobeadXYZgrid,1);
<span class="keyword">if</span> (find(isynan,1,'</span>last<span class="string">')-find(isynan,1,'</span>first<span class="string">')+1)==size(rhobeadXYZgrid,1) <span class="comment">% reach top</span>
    iyoverflow = find(~isynan,1,'</span>first<span class="string">');
    iymargin = round(size(rhobeadXYZgrid,1)*0.1); <span class="comment">% margin to add</span>
    iysafe = iyoverflow+iymargin;          <span class="comment">% index translation (along y)</span>
    dysafe = -iysafe * ( Yw(2,1)-Yw(1,1) ); <span class="comment">% distance translation (along y)</span>
    [rXYgridsafe,Xwsafe,Ywsafe] = PBCgridshift(Xw,Yw,rhobeadXYZgrid,[0 iysafe]); <span class="comment">% translate</span>
    dgridsafe = PBCgridshift(Xw,Yw,dgrid,[0 iysafe]); <span class="comment">% translate</span>
    [XYinformedsafe,boxsafe] = PBCimagesshift(XYinformed,[0 dysafe],box(1:2,1:2));
<span class="keyword">elseif</span> find(isynan,1,'</span>first<span class="string">')==1
    iymargin = round(size(rhobeadXYZgrid,1)*0.1); <span class="comment">% margin to add</span>
    iyoverflow = iymargin;
    <span class="keyword">if</span> isynan(<span class="keyword">end</span>), iyoverflow = iyoverflow + length(iyoverflow)-find(~isynan,1,'</span>last<span class="string">'); <span class="keyword">end</span>
    iysafe = -iyoverflow;
    dysafe = -iysafe * ( Yw(2,1)-Yw(1,1) ); <span class="comment">% distance translation (along y)</span>
    [rXYgridsafe,Xwsafe,Ywsafe] = PBCgridshift(Xw,Yw,rhobeadXYZgrid,[0 iysafe]); <span class="comment">% translate</span>
    dgridsafe = PBCgridshift(Xw,Yw,dgrid,[0 iysafe]); <span class="comment">% translate</span>
    [XYinformedsafe,boxsafe] = PBCimagesshift(XYinformed,[0 dysafe],box(1:2,1:2));
<span class="keyword">else</span>
    dysafe = 0;
    [rXYgridsafe,Xwsafe,Ywsafe] = deal(rhobeadXYZgrid,Xw,Yw);
    [dgridsafe,XYinformedsafe,boxsafe] = deal(dgrid,XYinformed,box);
<span class="keyword">end</span>

<span class="comment">% Volume of objects (GRID points): XYobjects where density is NaN vy definition</span>
XYobjects = [Xwsafe(:) Ywsafe(:)];
XYobjects = XYobjects(isnan(rXYgridsafe),:);
<span class="comment">% Looking <span class="keyword">for</span> beads in contact with XYobjects (grid points)</span>
V2 = buildVerletList({XYinformedsafe XYobjects},3*sinformed);
<span class="comment">% Index of beads in contact with XYobjects (grid points)</span>
icontact = find(cellfun(@length,V2)>0);
XYcontact = double(XYinformedsafe(icontact,:));
<span class="comment">% Enclosed beads</span>
k = boundary(XYcontact,1); nk = length(k);
XYcontactk = XYcontact(k,:);

<span class="comment">% separation of the objects, contour parameterization, tangents, normals</span>
<span class="comment">% the pillar is assumed fixed</span>
pillarcenter = [2.87,3.08]*1e-4; <span class="comment">% 0.2880e-3    0.3131e-3, mean(objects(1).XY)</span>
ispillar = vecnorm(XYcontactk - pillarcenter,2,2)<0.8e-4; <span class="comment">%  7.7859e-05, max(vecnorm(XYcontactk(ispillar,:) - pillarcenters,2,2))</span>
objects = struct('</span>XY<span class="string">',{XYcontactk(ispillar,:) XYcontactk(~ispillar,:)},'</span>marker<span class="string">',{'</span>bo<span class="string">','</span>ms<span class="string">'},'</span>line<span class="string">',{'</span>b-<span class="string">','</span>m-<span class="string">'},'</span>color<span class="string">',{'</span>b<span class="string">','</span>m<span class="string">'});
anglestep = pi/32;
angles = (-pi:anglestep:pi)'</span>;
<span class="keyword">for</span> k = 1:length(objects)
    <span class="comment">% fit each object as a circle to try to close the boundaries</span>
    objects(k).fit = fitCircleFromPoints(objects(k).XY);
    missingangles = angles(abs(angles-objects(k).fit.angles(nearestpoint(angles,objects(k).fit.angles)))>anglestep);
    XYtoadd = objects(k).fit.XYgenerator(missingangles);
    XYclosed = [objects(k).XY;XYtoadd]; nXYclosed = floor(size(XYclosed,1)/2)*2;
    [anglesclosed,ind] = sort(objects(k).fit.angleGenerator(XYclosed));
    XYclosed = XYclosed (ind,:); <span class="comment">% sort points according to angles</span>
    <span class="comment">% enforce periodic conditions along the index dimension</span>
    objects(k).XYclosed = [XYclosed((nXYclosed/2+1):<span class="keyword">end</span>,:) ; XYclosed ; XYclosed(1:(nXYclosed/2),:)];
    objects(k).n = size(objects(k).XYclosed,1);

    <span class="comment">% First pass - contour twice longer than the real one</span>
    <span class="comment">% fit each obhect using a regularized spline approximation</span>
    sp = csaps((1:objects(k).n)<span class="string">',objects(k).XYclosed'</span>,0.25); <span class="comment">% smoothed cubic spline</span>
    <span class="comment">%sp = spaps((1:objects(k).n)<span class="string">',objects(k).XYclosed'</span>,0.001*sum(var(objects(k).XYclosed))*objects(k).n);</span>
    spder = fnder(sp,1);

    <span class="comment">% Second pass - approximation based on angles</span>
    xycontours = fnval(sp,sp.breaks)<span class="string">';
    dxycontours = fnval(spder,sp.breaks)'</span>;
    xycircle = fitCircleFromPoints(xycontours);
    [xyangles,ind] = sort(xycircle.angles,<span class="string">'ascend'</span>);
    minangle = min(xyangles);
    maxangle = max(xyangles);
    xyangles = (2*(xyangles-minangle)/(maxangle-minangle)-1) * pi; <span class="comment">% rescaled to close the figure</span>
    xycontoursf = [ smooth(xyangles,xycontours(ind,1),0.15,<span class="string">'rloess'</span>),...
                    smooth(xyangles,xycontours(ind,2),0.15,<span class="string">'rloess'</span>) ];
    dxycontoursf = [ smooth(xyangles,dxycontours(ind,1),0.15,<span class="string">'rloess'</span>),...
                    smooth(xyangles,dxycontours(ind,2),0.15,<span class="string">'rloess'</span>) ];

    <span class="comment">% Make all data unique</span>
    [xyangles,ind] = unique(xyangles,<span class="string">'stable'</span>);
    xycontoursf = xycontoursf(ind,:);
    dxycontoursf = dxycontoursf(ind,:);
    xycontoursf([1 <span class="keyword">end</span>],:) = [1;1] * mean(xycontoursf([1 <span class="keyword">end</span>],:));
    dxycontoursf([1 <span class="keyword">end</span>],:) = [1;1] * mean(dxycontoursf([1 <span class="keyword">end</span>],:));

    <span class="comment">% Third Pass using contour length instead of angle as variable</span>
    <span class="comment">% ATTENTION: <span class="keyword">for</span> averaging it is preferable to use curvilinear coordinates</span>
    lxycontour = [0; cumsum(sqrt(sum(diff(xycontoursf,1,1).^2,2)))];
    sp2 = csaps(lxycontour<span class="string">',xycontoursf'</span>);


    <span class="comment">% Extract tangents at prescribed curvilinear coordinates</span>
    xp = linspace(lxycontour(1),lxycontour(<span class="keyword">end</span>),objects(k).n)<span class="string">';
    <span class="comment">% center and apparent radius (<span class="keyword">for</span> visualizing the force acting on the object)</span>
    objects(k).XYboundary = fnval(sp2,xp)'</span>;
    objects(k).center = mean(objects(k).XYboundary);
    objects(k).radius = min(vecnorm(objects(k).XYboundary-objects(k).center,2,2));
    <span class="comment">% tangents (from the spline approximation)</span>
    <span class="comment">%objects(k).tangents = ndf(xp,objects(k).XYboundary,1,[],<span class="string">'makeuniform'</span>,true); %curve2tangent(objects(k).XYboundary); %fnval(fnder(sp2,1),xp)<span class="string">';</span>
    objects(k).tangents = fnval(fnder(sp2,1),xp)'</span>;
    objects(k).tangents = objects(k).tangents./vecnorm(objects(k).tangents,2,2); <span class="comment">% Normalize the tangent vectors</span>
    <span class="comment">% normals (turn the normals to be inwards using inpolygon)</span>
    objects(k).normals = [-objects(k).tangents(:,2),objects(k).tangents(:,1)]; <span class="comment">% % Calculate the centroid of the shape</span>
    testPoints = objects(k).XYboundary + 0.01 * objects(k).radius * objects(k).normals; <span class="comment">% Choose a test point slightly offset from each boundary point along the normal</span>
    isInside = inpolygon(testPoints(:,1), testPoints(:,2),...
        objects(k).XYboundary(:,1), objects(k).XYboundary(:,2)); <span class="comment">% Use inpolygon to check <span class="keyword">if</span> each test point is inside the shape</span>
    objects(k).normals(~isInside, :) = -objects(k).normals(~isInside, :); <span class="comment">% Flip the normals where the test point is outside the shape</span>
    <span class="comment">% add density, pressure information (look <span class="keyword">for</span> the nearest beads closest to the boundary, average the value)</span>
    objects(k).Vcontact = buildVerletList({objects(k).XYboundary XYcontact},3*sinformed);
    objects(k).Vcontact = cellfun(@(v) icontact(v)<span class="string">',objects(k).Vcontact,'</span>UniformOutput<span class="string">',false); <span class="comment">% Vcontact{i} index of beads in contact with XYboundary(i,:)</span>
    objects(k).rhocontact = cellfun(@(v) mean(rhobeadinformed(v)),objects(k).Vcontact);
    objects(k).Pcontact = 1 + (objects(k).rhocontact/rho).^7-1; <span class="comment">% reduced pressure P/B with P0/B=1</span>
    objects(k).densitynormals = objects(k).rhocontact.*objects(k).normals/rho;
    objects(k).avdensitynormals = mean(objects(k).densitynormals,'</span>omitmissing<span class="string">');
    objects(k).pressurenormals = objects(k).Pcontact.*objects(k).normals;
    objects(k).avpressurenormals = mean(objects(k).pressurenormals,'</span>omitmissing<span class="string">');
<span class="keyword">end</span>

<span class="comment">% plot</span>
hfig(<span class="keyword">end</span>+1) = fighandle('</span>distribution_forces<span class="string">');  hold on
set(hfig(<span class="keyword">end</span>),'</span>PaperPosition<span class="string">',[ -2.0000    1.7000   30.0000   30.0000])
step = 2;
hp = pcolor(Xwsafe(1,:),Ywsafe(:,1),dgridsafe); hp.EdgeColor = '</span>none<span class="string">'; colorbar
quiv = struct('</span>xy<span class="string">',[],'</span>nxy<span class="string">',[],'</span>mag<span class="string">',[],'</span>nscale<span class="string">',2);
<span class="keyword">for</span> k = 1:length(objects)
    <span class="comment">% viscircles(XYcontact,rinformed,'</span>color<span class="string">','</span>r<span class="string">')</span>
    <span class="comment">% plot(objects(k).XY(:,1),objects(k).XY(:,2),objects(k).marker)</span>
    <span class="comment">% plot(objects(k).XYboundary(:,1),objects(k).XYboundary(:,2),objects(k).line,'</span>linewidth<span class="string">',2,'</span>marker<span class="string">','</span>x<span class="string">')</span>
    quiv.xy  = [quiv.xy;  objects(k).XYboundary(1:step:<span class="keyword">end</span>,:);      objects(k).center];
    quiv.nxy = [quiv.nxy; objects(k).pressurenormals(1:step:<span class="keyword">end</span>,:); quiv.nscale*objects(k).avpressurenormals];
    quiv.mag = [quiv.mag; objects(k).Pcontact(1:step:<span class="keyword">end</span>);mean(objects(k).Pcontact,'</span>omitmissing<span class="string">')];
<span class="keyword">end</span>
<span class="comment">% all quivers at once (color </span>
hq = quiver(quiv.xy(:,1),quiv.xy(:,2),quiv.nxy(:,1),quiv.nxy(:,2),3,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',0.5);
SetQuiverColor(hq,tooclear(jet),'</span>mags<span class="string">',quiv.mag,'</span>range<span class="string">',[0 0.5])
axis equal, title(sprintf('</span>[t=<span class="comment">%0.3g s] Pressure around objects<span class="string">',tframe))</span>

<span class="comment">%% print</span>
PRINTON = true;
<span class="keyword">if</span> PRINTON
    <span class="keyword">for</span> i=1:length(hfig)
        figure(hfig(i)), drawnow
        printhandle(hfig(i))
    <span class="keyword">end</span>
<span class="keyword">end</span>



<span class="comment">% relative pressure via Tait equation</span>
<span class="comment">% Pref = (rhobeadXYZgrid./rho).^7 - 1; % reference pressure</span>
<span class="comment">% Pbead = (rhobeadinformed./rho).^7 - 1; % pressure at kernel positions</span>
<span class="comment">% Pgrid = (dgrid./rho).^7 - 1; % pressure at grid nodes</span>
<span class="comment">% Pgrid = min(Pref(:)) + (max(Pref(:))-min(Pref(:)))*(Pgrid-min(Pgrid(:)))/(max(Pgrid(:))-min(Pgrid(:)));</span>
<span class="comment">% figure, imagesc(xw,yw,Pgrid), colorbar, title('</span>dimensionless pressure (-)<span class="string">'), axis equal</span>
<span class="comment">% clim([-1 3]), colorbar</span>
<span class="comment">% figure, imagesc(xw,yw,Pref), colorbar, title('</span>reference dimensionless pressure (-)<span class="string">'), axis equal</span>
<span class="comment">% clim([-1 3]), colorbar</span>
<span class="comment">% figure, scatter(XYinformed(:,1),XYinformed(:,2),rbeadinformed,Pbead,'</span>filled')</span></code></pre></div>
</div>
<div id='Billy_results_template_PBC_relative_velocity' class='doc-content' style='display: none;'>
<h1>Relative fluid-to-sphere velocity field</h1>
<p>rev. 2024/04/04</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% Relative fluid-to-sphere velocity field</span>
<span class="comment">% rev. 2024/04/04</span>

<span class="comment">% 2024/04/02 fork of Billy_results_template_cross_section.m (version 2024/02/31)</span>
<span class="comment">% SUMMARY</span>

<span class="comment">%% initialization</span>
close all
clearvars -except tframe tframelist PLOTON SAVEON OVERWRITE


<span class="comment">%% Definitions</span>

<span class="comment">% tframe = 0.67; % central</span>
<span class="comment">% tframe = 0.57; % central-0.1</span>
<span class="comment">% tframe = 0.77; % central+0.1</span>
<span class="comment">% tframe = 0.62; % central-0.05</span>
<span class="comment">% tframe = 0.72; % central+0.05</span>
<span class="comment">% tframe = 0.15;</span>
t0_ = clock;

<span class="comment">% check folders</span>
prefetchfolder = fullfile(pwd,<span class="string">'prefetch'</span>);
savefolder = fullfile(pwd,<span class="string">'results'</span>);
<span class="keyword">if</span> ~exist(savefolder,<span class="string">'dir'</span>), mkdir(savefolder); <span class="keyword">end</span>

<span class="comment">% Assign default values <span class="keyword">if</span> needed</span>
<span class="keyword">if</span> ~exist(<span class="string">'PLOTON'</span>,<span class="string">'var'</span>), PLOTON = true; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(<span class="string">'SAVEON'</span>,<span class="string">'var'</span>), SAVEON = true; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(<span class="string">'OVERWRITE'</span>,<span class="string">'var'</span>), OVERWRITE = false; <span class="keyword">end</span>

<span class="comment">% Some anaonymous functions</span>
prefetchvar = @(varargin) fullfile(prefetchfolder,sprintf(<span class="string">'t<span class="comment">%0.4f_%s.mat'</span>,tframe,varargin{1}));</span>
isprefetch = @(varargin) exist(prefetchvar(varargin{1}),<span class="string">'file'</span>);
savefile = @() fullfile(savefolder,sprintf(<span class="string">'3DRt.<span class="comment">%0.4f.mat'</span>,tframe));</span>
dispsection = @(s) dispf(<span class="string">'\n<span class="comment">%s\ntframe=%0.4g s \t[  %s  ]   elapsed time: %4g s\n%s'</span>,repmat(<span class="string">'*'</span>,1,120),tframe,regexprep(upper(s),<span class="string">'.'</span>,<span class="string">'$0 '</span>),etime(clock,t0_),repmat(<span class="string">'*'</span>,1,120)); %#ok<DETIM></span>





<span class="comment">%% path and metadata</span>
dispsection(<span class="string">'INITIALIZATION'</span>)
originalroot = <span class="string">'/media/olivi/T7 Shield/Thomazo_V2'</span>;
<span class="keyword">if</span> exist(originalroot,<span class="string">'dir'</span>)
    root = originalroot;
    rootlocal = fullfile(pwd,<span class="string">'smalldumps'</span>);
    copymode = true;
<span class="keyword">else</span>
    root = fullfile(pwd,<span class="string">'smalldumps'</span>);
    copymode = false;
<span class="keyword">end</span>

simfolder = ...
    struct(...
    <span class="string">'A1'</span>,struct(<span class="string">'artificial'</span>,...
<span class="string">'Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz'</span>,...
    <span class="string">'Morris'</span>,...
<span class="string">'Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz'</span> ...
                ),...
    <span class="string">'A2'</span>,struct(<span class="string">'artificial'</span>,...
<span class="string">'./Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_2.tar.gz'</span> ...
    ),...
    <span class="string">'B1'</span>,struct(<span class="string">'Morris'</span>,...
<span class="string">'./Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft.tar.gz'</span> ...
    ),...
    <span class="string">'B2'</span>,struct(<span class="string">'Morris'</span>,...
<span class="string">'Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_1.tar.gz'</span> ...
    ),...
    <span class="string">'B3'</span>,struct(<span class="string">'Morris'</span>,...
<span class="string">'/Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_2_3.tar.gz'</span> ...
    ) ...
    );

<span class="comment">% selection (not change it <span class="keyword">if</span> you do not have the full dataset/hard disk attached to your system)</span>
config = <span class="string">'A1'</span>;
viscosity = <span class="string">'Morris'</span>;
sourcefolder= fullfile(root,rootdir(simfolder.(config).(viscosity)));
sourcefile = regexprep(lastdir(simfolder.(config).(viscosity)),<span class="string">'.tar.gz$'</span>,<span class="string">''</span>);
dumpfile = fullfile(sourcefolder,sourcefile);
dispf(<span class="string">'config: <span class="comment">%s | viscosity: %s | source: %s'</span>,config,viscosity,dumpfile)</span>

<span class="comment">%% extract information</span>
dispsection(<span class="string">'OVERVIEW'</span>)
X0 = lamdumpread2(dumpfile); <span class="comment">% first frame</span>
natoms = X0.NUMBER;
timesteps = X0.TIMESTEPS;
X1 = lamdumpread2(dumpfile,<span class="string">'usesplit'</span>,[],timesteps(2));
dt = (X1.TIME-X0.TIME)/(timesteps(2)-timesteps(1)); <span class="comment">% integration time step</span>
times = double(timesteps * dt); <span class="comment">% in seconds </span>
atomtypes = unique(X0.ATOMS.type);
ntimesteps = length(timesteps);
T = X0.ATOMS.type;
natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
[~,ind] = sort(natomspertype,<span class="string">'descend'</span>);
<span class="comment">% Thomazo simulation details</span>
fluidtype  = ind(1);
pillartype = ind(2);
walltype   = ind(3);
spheretype = ind(4);
coords = {<span class="string">'z'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>}; <span class="comment">% to match Thomazo<span class="string">'s movies</span>
vcoords = cellfun(@(c) sprintf('</span>v<span class="comment">%s<span class="string">',c),coords,'</span>UniformOutput<span class="string">',false);</span>
icoords = cellfun(@(c) find(ismember({'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'},c)),coords); <span class="comment">%<- use this index <span class="keyword">for</span> BOX</span>
<span class="comment">% Simulation parameters</span>
<span class="comment">% Billy choose a reference density of 900 kg/m3 <span class="keyword">for</span> a physical density of 1000 kg/m3</span>
<span class="comment">% Viscosity: 0.13 Pa.s</span>
mbead = 4.38e-12; <span class="comment">% kg</span>
rho = 1000; <span class="comment">% kg / m3 (density of the fluid)</span>
Vbead = mbead/rho;
dispf('</span>SUMMARY: natoms: <span class="comment">%d | dt: %0.3g s | rho: %0.4g<span class="string">',natoms,dt,rho)</span>

<span class="comment">%% Estimate bead size from the first frame</span>
<span class="comment">% first estimate assuming that the bead is a cube</span>
dispsection('</span>BEAD SIZE<span class="string">')
fluidxyz0 = X0.ATOMS{T==fluidtype,coords};
boxdims = X0.BOX(:,2) - X0.BOX(:,1);
Vbead_guess = prod(boxdims)/natoms;
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
<span class="keyword">if</span> isprefetch('</span>verletList<span class="string">')
    load(prefetchvar('</span>verletList<span class="string">'))
<span class="keyword">else</span>
    [verletList,cutoff,dmin,config,dist] = buildVerletList(fluidxyz0,cutoff);
    save(prefetchvar('</span>verletList<span class="string">'),'</span>verletList<span class="string">','</span>cutoff<span class="string">','</span>dmin<span class="string">','</span>config<span class="string">','</span>dist<span class="string">')
<span class="keyword">end</span>
rbead = dmin/2;
s = 2*rbead; <span class="comment">% separation distance</span>
h = 2*s;     <span class="comment">% smoothing length</span>
dispf('</span>SUMMARY: s: <span class="comment">%0.4g m | h: %0.4g m<span class="string">',s,h)</span>
<span class="comment">%% load the frame closest to simulation time: tframe</span>
<span class="comment">% with the mini dataset, are available:</span>
<span class="comment">% 0.30s 0.40s 0.45s 0.50s 0.55s 0.60s 0.65s 0.70s 0.75s 0.80s 0.85s 0.90s 0.95s 1.00s 1.05s 1.10s </span>
<span class="comment">% tframelist = [0.3 0.4 0.45:0.05:1.10]; % verysmalldumps</span>
tframelist = 0.0:0.01:1.2; <span class="comment">% updated time frames</span>
<span class="keyword">if</span> ~exist('</span>tframe<span class="string">','</span>var<span class="string">')
    tframe = 0.85; <span class="comment">%0.55; % s <-------------------- select time here</span>
<span class="keyword">else</span>
    tframe = tframelist(nearestpoint(tframe,tframelist)); <span class="comment">% restrict to existing tframes</span>
<span class="keyword">end</span>
iframe = nearestpoint(tframe,times); <span class="comment">% closest index</span>
Xframe = lamdumpread2(dumpfile,'</span>usesplit<span class="string">',[],timesteps(iframe));
Xframe.ATOMS.isfluid = Xframe.ATOMS.type==fluidtype;
Xframe.ATOMS.ispillar = Xframe.ATOMS.type==pillartype;
Xframe.ATOMS.issphere = Xframe.ATOMS.type==spheretype;
Xframe.ATOMS.issolid = Xframe.ATOMS.type==spheretype | Xframe.ATOMS.type==pillartype;
box = Xframe.BOX(icoords,:); <span class="comment">% note that the order is given by coords, here {'</span>z<span class="string">'}    {'</span>x<span class="string">'}    {'</span>y<span class="string">'}</span>
boxsize = diff(box,1,2);

<span class="comment">%% Unwrap all coordinates</span>
Pshift = [0 boxsize(2)/2 0];
PBC = [true true false];

spherexyz = Xframe.ATOMS{Xframe.ATOMS.issphere,coords};
spherebox = [min(spherexyz)'</span> max(spherexyz)<span class="string">'];
sphereboxsize = diff(spherebox,1,2);
spherexyz_ = spherexyz; <span class="comment">% initial position</span>

<span class="keyword">if</span> any(sphereboxsize>boxsize/2)
    disp('</span>shift UP<span class="string">')
    Pshift = [0 boxsize(2)/2 0];
    XYZunwrapped =  unwrapPBC(PBCincell(Xframe.ATOMS{:,coords},box,PBC),Pshift,box,PBC);
    spherexyz = XYZunwrapped(Xframe.ATOMS.issphere,:);
    spherebox = [min(spherexyz)'</span> max(spherexyz)<span class="string">'];
    sphereboxsize = diff(spherebox,1,2);
    <span class="keyword">if</span> any(sphereboxsize>boxsize/2)
        Pshift = [0 -boxsize(2)/2 0];
        disp('</span>shift DOWN<span class="string">')
        XYZunwrapped =  unwrapPBC(PBCincell(Xframe.ATOMS{:,coords},box,PBC),Pshift,box,PBC);
    <span class="keyword">end</span>
<span class="keyword">else</span>
    Pshift = [0 0 0];
    XYZunwrapped = Xframe.ATOMS{:,coords};
<span class="keyword">end</span>
fluidxyz = XYZunwrapped(Xframe.ATOMS.isfluid,:);
spherexyz = XYZunwrapped(Xframe.ATOMS.issphere,:);
Pshiftactual = spherexyz_ - spherexyz;

<span class="comment">%% Extract sphere properties</span>
dispsection('</span>SPHERE INFORMATION<span class="string">')
R01 = struct('</span>tframe<span class="string">',tframe,'</span>box<span class="string">',box,'</span>boxdim<span class="string">',boxsize,'</span>Pshift<span class="string">',Pshift,'</span>Pshiftactual<span class="string">',mean(Pshiftactual,1),...
    '</span>sphereXYZ0<span class="string">',[],'</span>fluidXYZ<span class="string">',[],'</span>vfluidXYZ<span class="string">',[],'</span>fluidXYZ0<span class="string">',[],'</span>vfluidXYZ0<span class="string">',[]);
R01.sphereXYZ0 = mean(spherexyz);
spherebox = [min(spherexyz)'</span> max(spherexyz)<span class="string">'];
sphereboxdim = diff(spherebox,1,2);
viewbox = spherebox + [-0.25 0.25].*sphereboxdim;
viewboxsize = diff(viewbox,1,2);
insideviewbox = true(height(Xframe.ATOMS),1);
<span class="keyword">for</span> icoord = 1:3
    insideviewbox = insideviewbox ...
        & XYZunwrapped(:,icoord)>=viewbox(icoord,1) ...
        & XYZunwrapped(:,icoord)<=viewbox(icoord,2);
<span class="keyword">end</span>
XYZ  = XYZunwrapped(insideviewbox & Xframe.ATOMS.isfluid,:);  <span class="comment">% fluid kernel centers</span>
vXYZ = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,vcoords}; <span class="comment">% velocity of fluid kernel centers</span>
Vcontact = buildVerletList({XYZ spherexyz},2*s);
iscontact = cellfun(@length,Vcontact)>0;
XYZcontact = XYZ(iscontact,:);
<span class="keyword">if</span> PLOTON
    figure, hold on, plot3D(spherexyz,'</span>ro<span class="string">','</span>markerfacecolor<span class="string">','</span>r<span class="string">'), plot3D(XYZ(iscontact,:),'</span>bo<span class="string">','</span>markerfacecolor<span class="string">','</span>b<span class="string">'), plot3D(XYZ(~iscontact,:),'</span>co<span class="string">','</span>markerfacecolor<span class="string">','</span>c<span class="string">'), view(3), axis equal
    drawnow
<span class="keyword">end</span>
R01.fluidXYZ = XYZ(iscontact,:);
R01.fluidXYZ0 = mean(R01.fluidXYZ,1);
R01.vfluidXYZ = vXYZ(iscontact,:);
R01.vfluidXYZ0 = mean(R01.vfluidXYZ);

<span class="comment">%% save</span>
<span class="keyword">if</span> SAVEON && (~exist(savefile(),'</span>file<span class="string">') || OVERWRITE)
    save(savefile(),'</span>R01')
<span class="keyword">end</span></code></pre></div>
</div>
<div id='Billy_results_template_cross_section' class='doc-content' style='display: none;'>
<h1>First template to retrieve Billy&#x27;s paper 2 simulation data</h1>
<p>rev. 2024/03/17 - forked in 2024/03/16 with PBC</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% First template to retrieve Billy<span class="string">'s paper 2 simulation data </span>
<span class="comment">% rev. 2024/03/17 - forked in 2024/03/16 with PBC</span>

<span class="comment">% 2024/04/02 fork of Billy_results_template_PBC (version 2024/02/31)</span>
<span class="comment">% SUMMARY</span>


<span class="comment">%% Definitions</span>
tframe = 0.67; <span class="comment">% central</span>
tframe = 0.57; <span class="comment">% central-0.1</span>
tframe = 0.77; <span class="comment">% central+0.1</span>
tframe = 0.62; <span class="comment">% central-0.05</span>
tframe = 0.72; <span class="comment">% central+0.05</span>
t0_ = clock;

<span class="comment">% check folders</span>
prefetchfolder = fullfile(pwd,'</span>prefetch<span class="string">');
savefolder = fullfile(pwd,'</span>results<span class="string">');
<span class="keyword">if</span> ~exist(savefolder,'</span>dir<span class="string">'), mkdir(savefolder); <span class="keyword">end</span>

<span class="comment">% Assign default values <span class="keyword">if</span> needed</span>
<span class="keyword">if</span> ~exist('</span>RESETPREFETCH<span class="string">','</span>var<span class="string">'), RESETPREFETCH = false; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist('</span>PLOTON<span class="string">','</span>var<span class="string">'), PLOTON = true; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist('</span>PRINTON<span class="string">','</span>var<span class="string">'), PRINTON = false; <span class="keyword">end</span>

<span class="comment">% Some anaonymous functions</span>
prefetchvar = @(varargin) fullfile(prefetchfolder,sprintf('</span>t<span class="comment">%0.4f_%s.mat<span class="string">',tframe,varargin{1}));</span>
isprefetch = @(varargin) exist(prefetchvar(varargin{1}),'</span>file<span class="string">') && ~RESETPREFETCH;
dispsection = @(s) dispf('</span>\n<span class="comment">%s\ntframe=%0.4g s \t[  %s  ]   elapsed time: %4g s\n%s<span class="string">',repmat('</span>*<span class="string">',1,120),tframe,regexprep(upper(s),'</span>.<span class="string">','</span>$0 <span class="string">'),etime(clock,t0_),repmat('</span>*<span class="string">',1,120)); %#ok<DETIM></span>
fighandle = @(id) formatfig(figure,'</span>figname<span class="string">',sprintf('</span>t<span class="comment">%0.3g_%s<span class="string">',tframe,id));</span>
printhandle = @(hfig) print_png(300,fullfile(outputfolder,[get(hfig,'</span>filename<span class="string">') '</span>.png<span class="string">']),'</span><span class="string">','</span><span class="string">',0,0,0);

<span class="comment">% video recording parameters</span>
fps = 10;
moviefolder = fullfile(rootdir(savefolder),'</span>foodsim2024<span class="string">','</span>movies<span class="string">');
moviefile = sprintf('</span>crossection_t<span class="comment">%0.4g.gif<span class="string">',tframe);</span>
snapfile = sprintf('</span>crossection_t<span class="comment">%0.4g.png<span class="string">',tframe);</span>
<span class="keyword">if</span> ~exist(moviefolder,'</span>dir<span class="string">'), mkdir(moviefolder), <span class="keyword">end</span>
fullmoviefile = fullfile(moviefolder,moviefile);
fullsnapfile = fullfile(moviefolder,snapfile);
existmoviefile = @() exist(fullmoviefile,'</span>file<span class="string">');
existsnapfile = @() exist(fullsnapfile,'</span>file<span class="string">');
makemovie = @(hax) gif_add_frame(hax,fullmoviefile,fps);
makesnap = @() print_png(300,fullsnapfile,'</span><span class="string">','</span><span class="string">',0,0,0);

<span class="comment">%% path and metadata</span>
dispsection('</span>INITIALIZATION<span class="string">')
originalroot = '</span>/media/olivi/T7 Shield/Thomazo_V2<span class="string">';
<span class="keyword">if</span> exist(originalroot,'</span>dir<span class="string">')
    root = originalroot;
    rootlocal = fullfile(pwd,'</span>smalldumps<span class="string">');
    copymode = true;
<span class="keyword">else</span>
    root = fullfile(pwd,'</span>smalldumps<span class="string">');
    copymode = false;
<span class="keyword">end</span>

simfolder = ...
    struct(...
    '</span>A1<span class="string">',struct('</span>artificial<span class="string">',...
'</span>Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz<span class="string">',...
    '</span>Morris<span class="string">',...
'</span>Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz<span class="string">' ...
                ),...
    '</span>A2<span class="string">',struct('</span>artificial<span class="string">',...
'</span>./Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_2.tar.gz<span class="string">' ...
    ),...
    '</span>B1<span class="string">',struct('</span>Morris<span class="string">',...
'</span>./Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft.tar.gz<span class="string">' ...
    ),...
    '</span>B2<span class="string">',struct('</span>Morris<span class="string">',...
'</span>Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_1.tar.gz<span class="string">' ...
    ),...
    '</span>B3<span class="string">',struct('</span>Morris<span class="string">',...
'</span>/Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_2_3.tar.gz<span class="string">' ...
    ) ...
    );

<span class="comment">% selection (not change it <span class="keyword">if</span> you do not have the full dataset/hard disk attached to your system)</span>
config = '</span>A1<span class="string">';
viscosity = '</span>Morris<span class="string">';
sourcefolder= fullfile(root,rootdir(simfolder.(config).(viscosity)));
sourcefile = regexprep(lastdir(simfolder.(config).(viscosity)),'</span>.tar.gz$<span class="string">','</span><span class="string">');
dumpfile = fullfile(sourcefolder,sourcefile);
dispf('</span>config: <span class="comment">%s | viscosity: %s | source: %s<span class="string">',config,viscosity,dumpfile)</span>

<span class="comment">%% extract information</span>
dispsection('</span>OVERVIEW<span class="string">')
X0 = lamdumpread2(dumpfile); <span class="comment">% first frame</span>
natoms = X0.NUMBER;
timesteps = X0.TIMESTEPS;
X1 = lamdumpread2(dumpfile,'</span>usesplit<span class="string">',[],timesteps(2));
dt = (X1.TIME-X0.TIME)/(timesteps(2)-timesteps(1)); <span class="comment">% integration time step</span>
times = double(timesteps * dt); <span class="comment">% in seconds </span>
atomtypes = unique(X0.ATOMS.type);
ntimesteps = length(timesteps);
T = X0.ATOMS.type;
natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
[~,ind] = sort(natomspertype,'</span>descend<span class="string">');
<span class="comment">% Thomazo simulation details</span>
fluidtype  = ind(1);
pillartype = ind(2);
walltype   = ind(3);
spheretype = ind(4);
coords = {'</span>z<span class="string">','</span>x<span class="string">','</span>y<span class="string">'}; <span class="comment">% to match Thomazo'</span>s movies</span>
vcoords = cellfun(@(c) sprintf(<span class="string">'v<span class="comment">%s'</span>,c),coords,<span class="string">'UniformOutput'</span>,false);</span>
icoords = cellfun(@(c) find(ismember({<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>},c)),coords); <span class="comment">%<- use this index <span class="keyword">for</span> BOX</span>
<span class="comment">% Simulation parameters</span>
<span class="comment">% Billy choose a reference density of 900 kg/m3 <span class="keyword">for</span> a physical density of 1000 kg/m3</span>
<span class="comment">% Viscosity: 0.13 Pa.s</span>
mbead = 4.38e-12; <span class="comment">% kg</span>
rho = 1000; <span class="comment">% kg / m3 (density of the fluid)</span>
Vbead = mbead/rho;
dispf(<span class="string">'SUMMARY: natoms: <span class="comment">%d | dt: %0.3g s | rho: %0.4g'</span>,natoms,dt,rho)</span>

<span class="comment">%% Estimate bead size from the first frame</span>
<span class="comment">% first estimate assuming that the bead is a cube</span>
dispsection(<span class="string">'BEAD SIZE'</span>)
fluidxyz0 = X0.ATOMS{T==fluidtype,coords};
boxdims = X0.BOX(:,2) - X0.BOX(:,1);
Vbead_guess = prod(boxdims)/natoms;
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
<span class="keyword">if</span> isprefetch(<span class="string">'verletList'</span>)
    load(prefetchvar(<span class="string">'verletList'</span>))
<span class="keyword">else</span>
    [verletList,cutoff,dmin,config,dist] = buildVerletList(fluidxyz0,cutoff);
    save(prefetchvar(<span class="string">'verletList'</span>),<span class="string">'verletList'</span>,<span class="string">'cutoff'</span>,<span class="string">'dmin'</span>,<span class="string">'config'</span>,<span class="string">'dist'</span>)
<span class="keyword">end</span>
rbead = dmin/2;
s = 2*rbead; <span class="comment">% separation distance</span>
h = 2*s;     <span class="comment">% smoothing length</span>
dispf(<span class="string">'SUMMARY: s: <span class="comment">%0.4g m | h: %0.4g m'</span>,s,h)</span>
<span class="comment">%% load the frame closest to simulation time: tframe</span>
<span class="comment">% with the mini dataset, are available:</span>
<span class="comment">% 0.30s 0.40s 0.45s 0.50s 0.55s 0.60s 0.65s 0.70s 0.75s 0.80s 0.85s 0.90s 0.95s 1.00s 1.05s 1.10s </span>
<span class="comment">% tframelist = [0.3 0.4 0.45:0.05:1.10]; % verysmalldumps</span>
tframelist = 0.0:0.01:1.2; <span class="comment">% updated time frames</span>
<span class="keyword">if</span> ~exist(<span class="string">'tframe'</span>,<span class="string">'var'</span>)
    tframe = 0.85; <span class="comment">%0.55; % s <-------------------- select time here</span>
<span class="keyword">else</span>
    tframe = tframelist(nearestpoint(tframe,tframelist)); <span class="comment">% restrict to existing tframes</span>
<span class="keyword">end</span>
iframe = nearestpoint(tframe,times); <span class="comment">% closest index</span>
Xframe = lamdumpread2(dumpfile,<span class="string">'usesplit'</span>,[],timesteps(iframe));
Xframe.ATOMS.isfluid = Xframe.ATOMS.type==fluidtype;
Xframe.ATOMS.ispillar = Xframe.ATOMS.type==pillartype;
Xframe.ATOMS.issphere = Xframe.ATOMS.type==spheretype;
Xframe.ATOMS.issolid = Xframe.ATOMS.type==spheretype | Xframe.ATOMS.type==pillartype;
fluidxyz = Xframe.ATOMS{Xframe.ATOMS.isfluid,coords};
fluidid = X0.ATOMS{Xframe.ATOMS.isfluid,<span class="string">'id'</span>};
pillarxyz = Xframe.ATOMS{Xframe.ATOMS.ispillar,coords};
pillarid = X0.ATOMS{Xframe.ATOMS.ispillar,<span class="string">'id'</span>};
spherexyz = Xframe.ATOMS{Xframe.ATOMS.issphere,coords};
sphereid = X0.ATOMS{Xframe.ATOMS.issphere,<span class="string">'id'</span>};
solidxyz = Xframe.ATOMS{Xframe.ATOMS.issolid,coords};
solidid = X0.ATOMS{Xframe.ATOMS.issolid,<span class="string">'id'</span>};
ztop = max(pillarxyz(:,3)); <span class="comment">% pillar top</span>
spherebox = [min(spherexyz)<span class="string">' max(spherexyz)'</span>];
halftoppillar = pillarxyz(:,3)>ztop/2;
pillarbox = [min(pillarxyz(halftoppillar,:))<span class="string">' max(pillarxyz(halftoppillar,:))'</span>];
spherepillarbox = [ min(spherebox(:,1),pillarbox(:,1)) max(spherebox(:,2),pillarbox(:,2)) ]; spherepillarboxdim=diff(spherepillarbox,1,2);
viewbox3d = [(spherepillarbox(:,1)-[0.15;0.5;0].*spherepillarboxdim),...
    (spherepillarbox(:,2)+[0.15;0.5;0.02].*spherepillarboxdim)];


<span class="comment">%% Interpolate velocity field at z = ztop</span>
dispsection(<span class="string">'REFERENCE VELOCITY FIELD'</span>)
<span class="comment">% full box (note that atoms may be outside of this box)</span>
box = Xframe.BOX(icoords,:); <span class="comment">% note that the order is given by coords, here {<span class="string">'z'</span>}    {<span class="string">'x'</span>}    {<span class="string">'y'</span>}</span>
boxsize = diff(box,1,2);
<span class="comment">% fluidbox (box <span class="keyword">for</span> atoms to consider)</span>
xmin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{1}});
xmax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{1}});
ymin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{2}});
ymax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{2}});
zmin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{3}});
zmax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{3}});
fluidbox = [xmin xmax;ymin ymax;zmin zmax];
<span class="comment">% restrict interpolation to the viewbox</span>
viewbox = viewbox3d; <span class="comment">%fluidbox; viewbox(3,:) = [ztop-2*h ztop+2*h];</span>
viewboxsize = diff(viewbox,1,2);
insideviewbox = true(height(Xframe.ATOMS),1);
<span class="keyword">for</span> icoord = 1:3
    insideviewbox = insideviewbox ...
        & Xframe.ATOMS{:,coords{icoord}}>=viewbox(icoord,1) ...
        & Xframe.ATOMS{:,coords{icoord}}<=viewbox(icoord,2);
<span class="keyword">end</span>
XYZall  = Xframe.ATOMS{Xframe.ATOMS.isfluid,coords};  <span class="comment">% fluid kernel centers</span>
vXYZall = Xframe.ATOMS{Xframe.ATOMS.isfluid,vcoords}; <span class="comment">% velocity of fluid kernel centers</span>
XYZ  = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,coords};  <span class="comment">% fluid kernel centers</span>
vXYZ = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,vcoords}; <span class="comment">% velocity of fluid kernel centers</span>
XYZp = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.ispillar,coords};  <span class="comment">% solid kernel centers</span>
XYZs = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.issphere,coords}; 
rhobeadXYZall = Xframe.ATOMS.c_rho_smd(Xframe.ATOMS.isfluid); <span class="comment">% volume of the bead</span>
rhobeadXYZ = Xframe.ATOMS.c_rho_smd(insideviewbox & Xframe.ATOMS.isfluid); <span class="comment">% volume of the bead</span>
VbeadXYZall = mbead./rhobeadXYZall;
VbeadXYZ = mbead./rhobeadXYZ;


<span class="comment">% Plot</span>
<span class="keyword">if</span> PLOTON
    figure, hold on
    plot3D(XYZ,<span class="string">'bo'</span>)
    plot3D(XYZs,<span class="string">'ro'</span>)
    plot3D(XYZp,<span class="string">'go'</span>)
    view(3)
<span class="keyword">end</span>


<span class="comment">% interpolation grid (central grid, no images)</span>
<span class="comment">%nresolution = [128 128 128];</span>
nresolution = round(128*diff(viewbox,1,2)<span class="string">'/max(diff(viewbox,1,2)));
xw = linspace(viewbox(1,1),viewbox(1,2),nresolution(1));
yw = linspace(viewbox(2,1),viewbox(2,2),nresolution(2));
zw = linspace(viewbox(3,1),viewbox(3,2),nresolution(3));
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];

<span class="comment">% grid neighbors (incl. images) <span class="keyword">for</span> interpolation and discarding grid points overlapping solid</span>
VXYZ  = buildVerletList({XYZgrid XYZall},1.2*h);  <span class="comment">% neighbors = fluid particles</span>
VXYZs = buildVerletList({XYZgrid XYZs},0.85*s); <span class="comment">% neighbors = solid particles</span>

icontactsolid = find(cellfun(@length,VXYZs)>0);
<span class="comment">%VXYZ(icontactsolid) = repmat({[]},length(icontactsolid),1);</span>

<span class="comment">% interpolation on the grid of the 3D velocity (central grid)</span>
<span class="comment">% Do not forget even <span class="keyword">if</span> we are applying a 2D interpretation, we use a 3D simulation</span>
<span class="comment">% 3D velocity are projected on 2D streamlines even <span class="keyword">if</span> the projection of the 3rd component is 0</span>
W = kernelSPH(h,'</span>lucy<span class="string">',3); <span class="comment">% kernel expression</span>
v3XYZgrid = interp3SPHVerlet(XYZall,vXYZall,XYZgrid,VXYZ,W,VbeadXYZall);
vxXYZgrid = reshape(v3XYZgrid(:,1),size(Xw)); vxXYZgrid(icontactsolid) = NaN;
vyXYZgrid = reshape(v3XYZgrid(:,2),size(Xw)); vyXYZgrid(icontactsolid) = NaN;
vzXYZgrid = reshape(v3XYZgrid(:,3),size(Xw)); vzXYZgrid(icontactsolid) = NaN;
vXYZgrid  = reshape(sqrt(sum(v3XYZgrid.^2,2)),size(Xw));

<span class="comment">% density on the grid (with a possible different h)</span>
Wd = kernelSPH(1.08*s,'</span>lucy<span class="string">',3); <span class="comment">% kernel expression</span>
rhobeadXYZgrid = interp3SPHVerlet(XYZall,rhobeadXYZall,XYZgrid,VXYZ,Wd,VbeadXYZall);
rhobeadXYZgrid = reshape(rhobeadXYZgrid,size(Xw)); rhobeadXYZgrid(icontactsolid) = NaN;

<span class="comment">% Plot</span>
<span class="keyword">if</span> PLOTON
    figure, slice(Xw,Yw,Zw,vXYZgrid,mean(viewbox(1,:)),mean(viewbox(2,:)),mean(viewbox(3,:))), axis equal, view(2), colorbar, title(sprintf('</span>t=<span class="comment">%0.3f s - velocity (m/s)<span class="string">',tframe)), view(3)</span>
    figure, slice(Xw,Yw,Zw,rhobeadXYZgrid,mean(viewbox(1,:)),mean(viewbox(2,:)),mean(viewbox(3,:))); axis equal, view(2), colorbar, title(sprintf('</span>t=<span class="comment">%0.3f s - density (kg/m3)<span class="string">',tframe)), view(3)</span>
<span class="keyword">end</span>

<span class="comment">%% Plot pillar and sphere atoms, quiver, streamlines</span>
figure, hold on
[xs,ys,zs] = sphere(20); [xs,ys,zs] = deal(xs*rbead,ys*rbead,zs*rbead);
colors = struct('</span>pillar<span class="string">',rgb('</span>DarkGreen<span class="string">'),'</span>sphere<span class="string">',rgb('</span>FireBrick<span class="string">'));
<span class="keyword">for</span> i=1:size(XYZs,1)
    surf(xs+ XYZs(i,1), ys + XYZs(i,2), zs+ XYZs(i,3),'</span>FaceColor<span class="string">',colors.sphere,'</span>EdgeColor<span class="string">','</span>none<span class="string">');
<span class="keyword">end</span>
<span class="keyword">for</span> i=1:size(XYZp,1)
    surf(xs+ XYZp(i,1), ys + XYZp(i,2), zs+ XYZp(i,3),'</span>FaceColor<span class="string">',colors.pillar,'</span>EdgeColor<span class="string">','</span>none<span class="string">');
<span class="keyword">end</span>
lighting phong, camlight left, camlight right, axis equal, view(3)

<span class="comment">% quiver</span>
step = 12;
boundaries = ...
    [ nearestpoint(double(xw([1,<span class="keyword">end</span>])+viewboxsize(1)/100*[1 -1]),double(xw)) <span class="comment">% x</span>
      nearestpoint(double(yw([1,<span class="keyword">end</span>])+viewboxsize(2)/100*[1 -1]),double(yw)) <span class="comment">% y</span>
      nearestpoint(double(zw([1,<span class="keyword">end</span>])+viewboxsize(3)/100*[1 -1]),double(zw)) <span class="comment">% z</span>
                 ];
indxquiver = boundaries(1,1):step:boundaries(1,2); <span class="comment">% x indices</span>
indyquiver = boundaries(2,1):step:boundaries(2,2); <span class="comment">% y indices</span>
indzquiver = boundaries(3,1):step:boundaries(3,2); <span class="comment">% y indices</span>
quiver3( Xw(indyquiver,indxquiver,indzquiver),...
         Yw(indyquiver,indxquiver,indzquiver), ...
         Zw(indyquiver,indxquiver,indzquiver), ...
         vxXYZgrid(indyquiver,indxquiver,indzquiver),...
         vyXYZgrid(indyquiver,indxquiver,indzquiver),...
         vzXYZgrid(indyquiver,indxquiver,indzquiver),...
            '</span>color<span class="string">',rgb('</span>Navy<span class="string">'),'</span>LineWidth<span class="string">',2)

<span class="comment">% streamlines</span>
step = 6;
boundaries = ...
    [ nearestpoint(double(xw([1,<span class="keyword">end</span>])+viewboxsize(1)/100*[1 -1]),double(xw)) <span class="comment">% x</span>
      nearestpoint(double(yw([1,<span class="keyword">end</span>])+viewboxsize(2)/100*[1 -1]),double(yw)) <span class="comment">% y</span>
      nearestpoint(double(zw([1,<span class="keyword">end</span>])+viewboxsize(3)/100*[1 -1]),double(zw)) <span class="comment">% z</span>
                 ];
indxstreamline = boundaries(1,1):step:boundaries(1,2); <span class="comment">% x indices</span>
indystreamline = boundaries(2,1):step:boundaries(2,2); <span class="comment">% y indices</span>
indzstreamline = boundaries(3,1):step:boundaries(3,2); <span class="comment">% y indices</span>
[startgenX,startgenY,startgenZ] = meshgrid(double(xw(indxstreamline)),double(yw(indystreamline)),double(ztop));
vxXYZgrid_ = vxXYZgrid; vxXYZgrid_(isnan(vxXYZgrid))=0;
vyXYZgrid_ = vyXYZgrid; vyXYZgrid_(isnan(vyXYZgrid))=0;
vzXYZgrid_ = vzXYZgrid; vzXYZgrid_(isnan(vzXYZgrid))=0;
hstr = streamribbon(double(Xw),double(Yw),double(Zw),vxXYZgrid_,vyXYZgrid_,vzXYZgrid_,startgenX,startgenY,startgenZ);
set(hstr,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facecolor<span class="string">',rgb('</span>DeepSkyBlue<span class="string">'),'</span>facealpha<span class="string">',0.4)


<span class="comment">% Plot density</span>
<span class="comment">% figure, hold on</span>
[Xwcut,Ywcut,Zwcut,Rwcut] = deal(Xw,Yw,Zw,rhobeadXYZgrid);
[Xwcut2,Ywcut2,Zwcut2,Rwcut2] = deal(Xw,Yw,Zw,rhobeadXYZgrid);
zcut = 3e-4;
xcut = 3.1e-4;
Xwcut(:,:,zw>zcut) = [];
Ywcut(:,:,zw>zcut) = [];
Zwcut(:,:,zw>zcut) = [];
Rwcut(:,:,zw>zcut) = [];
Xwcut2(:,xw>xcut,:) = [];
Ywcut2(:,xw>xcut,:) = [];
Zwcut2(:,xw>xcut,:) = [];
Rwcut2(:,xw>xcut,:) = [];
isorho = 1200;
<span class="comment">% Rwcut2(Rwcut2<=isorho)=isorho;</span>
p1a = patch(isosurface(Xwcut2,Ywcut2,Zwcut2,Rwcut2, isorho),'</span>FaceColor<span class="string">',rgb('</span>Navy<span class="string">'),'</span>EdgeColor<span class="string">','</span>none<span class="string">');
p1b = patch(isosurface(Xwcut2,Ywcut2,Zwcut2,Rwcut2, isorho-200),'</span>FaceColor<span class="string">',rgb('</span>MediumBlue<span class="string">'),'</span>EdgeColor<span class="string">','</span>none<span class="string">');
p1c = patch(isosurface(Xwcut2,Ywcut2,Zwcut2,Rwcut2, isorho-400),'</span>FaceColor<span class="string">',rgb('</span>RoyalBlue<span class="string">'),'</span>EdgeColor<span class="string">','</span>none<span class="string">');
p1d = patch(isosurface(Xwcut2,Ywcut2,Zwcut2,Rwcut2, isorho-600),'</span>FaceColor<span class="string">',rgb('</span>DodgerBlue<span class="string">'),'</span>EdgeColor<span class="string">','</span>none<span class="string">');
p2 = patch(isocaps(Xwcut,Ywcut,Zwcut,Rwcut, 200),'</span>FaceColor<span class="string">','</span>interp<span class="string">','</span>EdgeColor<span class="string">','</span>none<span class="string">');
colormap(bone(100)), axis equal
<span class="comment">%camlight left, camlight right, lighting gouraud, view(-138,28), axis equal</span>
camlight left; <span class="comment">% Adds a light to the left of the camera</span>
camlight right; <span class="comment">% Adds a light to the right of the camera</span>
light('</span>Position<span class="string">',[-1 -1 0.5],'</span>Style<span class="string">','</span>infinite<span class="string">'); <span class="comment">% Additional light source from a specific direction</span>
ambientLight = light('</span>Position<span class="string">',[1 1 1],'</span>Style<span class="string">','</span>infinite<span class="string">');
set(ambientLight,'</span>Color<span class="string">',[0.3 0.3 0.3]); <span class="comment">% A soft, white ambient light</span>
lighting phong;

view([-199 24])
camproj perspective
hfig = gcf; hax = gca;
formatfig(hfig,'</span>color<span class="string">','</span>k<span class="string">','</span>InvertHardcopy<span class="string">',false,'</span>position<span class="string">',[-2143   -123    1600    1200],'</span>PaperPosition<span class="string">',[0.6350    7.0918   19.7300   15.5164])
axis off
set(hax,'</span>color<span class="string">','</span>k<span class="string">')
axis([0.2142    0.5488    0.1409    0.4544    0.2046    0.5135]*1e-3)

<span class="comment">%% Assuming you have your scene set up before this script</span>
MOVIEON = true;

<span class="keyword">if</span> ~existsnapfile()
    set(hfig,'</span>color<span class="string">','</span>w<span class="string">')
    set(hax,'</span>color<span class="string">','</span>w<span class="string">')
    makesnap()
    set(hfig,'</span>color<span class="string">','</span>k<span class="string">')
    set(hax,'</span>color<span class="string">','</span>k<span class="string">')
<span class="keyword">end</span>

<span class="keyword">if</span> existmoviefile()
    MOVIEON = false;
    dispf('</span>delete(<span class="string">''</span><span class="comment">%s<span class="string">''</span>)<span class="string">',fullmoviefile)</span>
    warning('</span>delete the movie file<span class="string">')
<span class="keyword">else</span>
    set(hfig,'</span>color<span class="string">','</span>k<span class="string">')
    set(hax,'</span>color<span class="string">','</span>k<span class="string">')
<span class="keyword">end</span>

<span class="comment">% Number of frames <span class="keyword">for</span> the video</span>
nFrames = 360; <span class="comment">% This can be adjusted <span class="keyword">for</span> smoother animation</span>

<span class="comment">% Initial view settings</span>
initialAzimuth = -199; <span class="comment">% Adjusting <span class="keyword">for</span> MATLAB'</span>s view system</span>
initialElevation = 24;

<span class="comment">% Normalize initialAzimuth to ensure smooth transition</span>
<span class="comment">% MATLAB<span class="string">'s view system handles azimuths mod 360</span>
<span class="keyword">if</span> initialAzimuth < 0
    initialAzimuth = 360 + initialAzimuth; <span class="comment">% Converts -199 to 161</span>
<span class="keyword">end</span>

<span class="comment">% Animation parameters</span>
azimuthEnd = initialAzimuth + 360; <span class="comment">% Completes a full circle</span>
elevationMin = 4; <span class="comment">% Minimum elevation</span>
elevationMax = 54; <span class="comment">% Maximum elevation</span>
midElevation = (elevationMin + elevationMax) / 2; <span class="comment">% Midpoint <span class="keyword">for</span> elevation</span>
elevationAmplitude = (elevationMax - elevationMin) / 2; <span class="comment">% Elevation change amplitude</span>

<span class="comment">% Time vector <span class="keyword">for</span> sinusoidal elevation change, adjusted to start/<span class="keyword">end</span> at initial elevation</span>
t = linspace(0, 2*pi, nFrames);

<span class="comment">% Pre-calculation <span class="keyword">for</span> azimuth and elevation</span>
azimuths = linspace(initialAzimuth, azimuthEnd, nFrames);
elevations = midElevation + elevationAmplitude * sin(t);

<span class="comment">% Make the start and <span class="keyword">end</span> elevations match the initial setting by adjusting the first and last values</span>
elevations(1) = initialElevation;
elevations(<span class="keyword">end</span>) = initialElevation;

<span class="comment">% Animation loop</span>
<span class="keyword">for</span> k = 1:nFrames
    <span class="comment">% Calculate current azimuth and elevation</span>
    currentAzimuth = azimuths(k);
    currentElevation = elevations(k);
    
    <span class="comment">% Ensure the azimuth is within the 0° to 360° range <span class="keyword">for</span> viewing</span>
    currentAzimuth = mod(currentAzimuth, 360);
    
    <span class="comment">% Update view</span>
    view(currentAzimuth, currentElevation);
    
    <span class="comment">% Update the scene</span>
    drawnow;
    
    <span class="comment">% Optionally, capture the frame <span class="keyword">for</span> video creation</span>
    <span class="comment">% frame = getframe(gcf);</span>
    <span class="comment">% writeVideo(videoObject, frame);</span>
    <span class="keyword">if</span> MOVIEON
        makemovie(hfig)
    <span class="keyword">end</span>
<span class="keyword">end</span>



<span class="comment">% slice</span>
<span class="comment">% figure, hs= slice(Xw,Yw,Zw,sumW,single(1:3),single(1:3),single([])); set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha',0.5), axis equal</span>

</code></pre></div>
</div>
<div id='Bily_suspension_interpretation' class='doc-content' style='display: none;'>
<h1>Interpretation O. Vitrac - rev. 2024-07-12-31</h1>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab">
<span class="comment">% Interpretation O. Vitrac - rev. 2024-07-12-31</span>


clearvars -except d it forcedsave PREVIOUSdumpFile dataFile

<span class="comment">% Definitions</span>
<span class="keyword">switch</span> localname
    <span class="keyword">case</span> <span class="string">'WS-OLIVIER2023'</span>
        root = <span class="string">'D:\Sensory_viscosimeter_V0'</span>;
    <span class="keyword">otherwise</span>
        error(<span class="string">'Set your machine '</span><span class="string">'<span class="comment">%s'</span><span class="string">' first'</span>,localname)</span>
<span class="keyword">end</span>
subdatafolder = <span class="string">'/Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary'</span>;
datafolder = fullfile(root,subdatafolder);

<span class="comment">% POST template</span>
allDumpFiles = {
    <span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with80SuspendedParticle_10Yparticle'</span>,
    <span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with80SuspendedParticle_1000Yparticle'</span>,
    <span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with80SuspendedParticle_100000Yparticle'</span>
    };

jumps = 30000*30;
allTimesteps = {
    [0:jumps:10650000],
    [0:jumps:10500000],
    [0:jumps:10530000]
    };

D = 0.001;
BOX_DIMENSIONS = [0 2*D -0.1*D 1.1*D 0 2*D];
BOUNDARIES = [1 0 1]; <span class="comment">% 1 <span class="keyword">if</span> periodic</span>
S = D / 48;
R = 0.5 * S; <span class="comment">% radius of the particle (please, be very accurate)</span>
E = 2000; <span class="comment">% Hertz contact stiffness</span>
A = 4 * D * D; <span class="comment">% Area of the wall</span>
H = 2 * R;
MU = 0.01;
NU = MU/1000;
U = 0.01;

<span class="comment">%% choose file, backup file</span>
<span class="keyword">if</span> ~exist(<span class="string">'PREVIOUSdumpFile'</span>,<span class="string">'var'</span>), PREVIOUSdumpFile = <span class="string">''</span>; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(<span class="string">'dataFile'</span>,<span class="string">'var'</span>), dataFile = []; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(<span class="string">'d'</span>,<span class="string">'var'</span>), d = 1; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(<span class="string">'it'</span>,<span class="string">'var'</span>), it = 3; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(<span class="string">'forcedsave'</span>,<span class="string">'var'</span>), forcedsave = false; <span class="keyword">end</span>

<span class="comment">% root folder</span>
rootsaveresultfolder = fullfile(datafolder,<span class="string">'RESULTS_OV'</span>);
<span class="keyword">if</span> ~exist(rootsaveresultfolder,<span class="string">'dir'</span>), mkdir(rootsaveresultfolder); <span class="keyword">end</span>

<span class="comment">%% retrieve all frame results (<span class="keyword">if</span> they exist)</span>
<span class="keyword">if</span> ischar(d) && strcmp(d,<span class="string">'all'</span>)
    fres = explore(<span class="string">'*.mat'</span>,rootsaveresultfolder,3,<span class="string">'abbreviate'</span>);
    fresu = unique({fres.subpath},<span class="string">'stable'</span>);
    Elist = str2double(uncell(regexp(fresu,<span class="string">'\_(\d+)Yparticle'</span>,<span class="string">'tokens'</span>)));
    nE = length(Elist);
    leg = arrayfun(@(e) sprintf(<span class="string">'E=<span class="comment">%s'</span>,formatsci(e,<span class="string">'eco'</span>)),Elist,<span class="string">'UniformOutput'</span>,false);</span>
    formatfig(figure,<span class="string">'figname'</span>,<span class="string">'resultsOV_meta'</span>,<span class="string">'PaperPosition'</span>,[4.6933    9.2937   11.6133   11.1125]); <span class="comment">%<span class="string">'Paperposition'</span>)</span>
    hold on
    col = tooclear(parula(nE+1));
    hp = zeros(nE,1);
    nmax = 0;
    <span class="keyword">for</span> i=1:nE
        k = find(ismember({fres.subpath},fresu(i)));
        nk = length(k);
        T = [];
        <span class="keyword">for</span> j=1:nk
            tmp = load(fullfile(fres(k(j)).path,fres(k(j)).file));
            tmp.Rcurrent.E = Elist(i) * ones(height(tmp.Rcurrent),1);
            T = [T;tmp.Rcurrent]; <span class="comment">%#ok<AGROW></span>
        <span class="keyword">end</span>
        T = T(T.timestep>0,:);
        hp(i) = plot(T.nNodes,T.fractalDim,<span class="string">'o'</span>,<span class="string">'markersize'</span>,10,<span class="string">'markeredgecolor'</span>,col(i,:),<span class="string">'markerfacecolor'</span>,col(i,:));
        nmax= max(nmax,max(T.nNodes));
    <span class="keyword">end</span>
    n = 1:(nmax+1);
    hp(<span class="keyword">end</span>+1) = plot(n,(n-1)./n,<span class="string">'k-'</span>,<span class="string">'linewidth'</span>,1);
    uistack(hp(<span class="keyword">end</span>),"bottom")
    formatax(gca,<span class="string">'fontsize'</span>,12)
    xlabel(<span class="string">'Number of particles in the cluster'</span>)
    ylabel(<span class="string">'Fractal dimension (-)'</span>)
    hl = legend(hp,[leg;{<span class="string">'linear cluster (theory)'</span>}],<span class="string">'box'</span>,<span class="string">'off'</span>,<span class="string">'location'</span>,<span class="string">'SouthEast'</span>);
    print_png(400,fullfile(rootsaveresultfolder,get(gcf,<span class="string">'filename'</span>)),<span class="string">''</span>,<span class="string">''</span>,0,0,0)
    <span class="keyword">return</span>
<span class="keyword">end</span>

<span class="comment">%% selected frame</span>
dumpFile = allDumpFiles{d};
timesteps = allTimesteps{d};
DEBUGmode = false; <span class="comment">% true to force intermediate plots</span>

<span class="comment">% results files <span class="keyword">for</span> the selected frame</span>
saveresultfolder = fullfile(rootsaveresultfolder,regexprep(dumpFile,<span class="string">'^dump\.'</span>,<span class="string">''</span>));
<span class="keyword">if</span> ~exist(saveresultfolder,<span class="string">'dir'</span>), mkdir(saveresultfolder); <span class="keyword">end</span>
saveresultfile = fullfile(saveresultfolder,sprintf(<span class="string">'graph_it<span class="comment">%d_T%d.mat'</span>,it,timesteps(it)));</span>
saveresultfig2D = fullfile(saveresultfolder,sprintf(<span class="string">'graph2D_it<span class="comment">%d_T%d.png'</span>,it,timesteps(it)));</span>
saveresultfig3D = fullfile(saveresultfolder,sprintf(<span class="string">'graph3D_it<span class="comment">%d_T%d.png'</span>,it,timesteps(it)));</span>
<span class="keyword">if</span> exist(saveresultfile,<span class="string">'file'</span>) && exist(saveresultfig2D,<span class="string">'file'</span>) && exist(saveresultfig3D,<span class="string">'file'</span>) && ~forcedsave
    warning(<span class="string">'this iteration is discarded, set forcedsave=true or delete the file in\n <span class="comment">%s\n\t or use\n delete('</span><span class="string">'%s'</span><span class="string">')\n delete('</span><span class="string">'%s'</span><span class="string">')\n delete('</span><span class="string">'%s'</span><span class="string">')'</span>, ...</span>
        saveresultfolder,saveresultfile,saveresultfig2D,saveresultfig3D)
    <span class="keyword">return</span>
<span class="keyword">end</span>
close all
resultfigs = [figure; figure];

<span class="comment">%% Load file</span>
<span class="keyword">if</span> ~strcmp(dumpFile,PREVIOUSdumpFile) || isempty(dataFile)
    dataFile = lamdumpread2(fullfile(datafolder, dumpFile), <span class="string">'usesplit'</span>, [], timesteps);
    PREVIOUSdumpFile = dumpFile;
<span class="keyword">end</span>

<span class="comment">% Box size</span>
coords = {<span class="string">'x'</span>, <span class="string">'z'</span>, <span class="string">'y'</span>};
icoords = cellfun(@(c) find(ismember({<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>}, c)), coords);
box = dataFile.BOX(icoords, :); <span class="comment">% note that the order is given by coords, here {<span class="string">'z'</span>}    {<span class="string">'x'</span>}    {<span class="string">'y'</span>}</span>
boxsize = diff(box, 1, 2);
PBC = [true, false, true]; <span class="comment">% true <span class="keyword">if</span> periodic</span>
PBC = PBC(icoords);
PBCthickness = max(0.4 * boxsize(PBC));

<span class="comment">%% First analysis (raw)</span>
selection = dataFile.ATOMS(dataFile.ATOMS.TIMESTEP == timesteps(it) & dataFile.ATOMS.type >= 4, :);
XYZselection = PBCincell(selection{:, coords}, box, PBC);
[XYZimagesONLY, indXimagesONLY, copyimagesIdx] = PBCimages(XYZselection, box, PBC, PBCthickness);

<span class="keyword">if</span> DEBUGmode
    figure, hold on, plot3D(XYZselection, <span class="string">'kx'</span>), plot3D(XYZimagesONLY, <span class="string">'ro'</span>), view(3), axis equal
<span class="keyword">end</span>
selectionimage = selection(indXimagesONLY, :);
selectionimage{:, coords} = XYZimagesONLY;
selectionimage.type = selectionimage.type + 1000 * copyimagesIdx;
selectionwithimages = [selection; selectionimage];
selectionwithimages.isimages = selectionwithimages.type > 1000;

stypes = unique(selectionwithimages.type); 
nstypes = length(stypes);
[XYZ, stypesfull] = deal(cell(nstypes, 1));
isimages = stypes > 1000;
<span class="keyword">for</span> i = 1:nstypes
    XYZ{i} = selectionwithimages{selectionwithimages.type == stypes(i), coords};
    stypesfull{i} = selectionwithimages.type(selectionwithimages.type == stypes(i));
<span class="keyword">end</span>

<span class="comment">% Control figure</span>
<span class="keyword">if</span> DEBUGmode
    figure, hold on, col = parula(nstypes);
    <span class="keyword">for</span> i = 1:nstypes
        plot3D(XYZ{i}, <span class="string">'o'</span>, <span class="string">'color'</span>, col(i, :));
    <span class="keyword">end</span>
    view(3), axis equal
<span class="keyword">end</span>

<span class="comment">%% Contact pairwise distance (based on contacts)</span>
others = 1:nstypes;
C = repmat(struct(<span class="string">'XYZ'</span>, [], <span class="string">'i'</span>, [], <span class="string">'type'</span>, NaN, <span class="string">'n'</span>, NaN, <span class="string">'center'</span>, [], <span class="string">'jneigh'</span>, [], <span class="string">'tneigh'</span>, [], <span class="string">'dneigh'</span>, [], ...
    <span class="string">'isReunited'</span>, false, <span class="string">'deleted'</span>, false, <span class="string">'tobeupdated'</span>, true, <span class="string">'ifull'</span>, []), nstypes, 1);
imagestoremove = [];
<span class="keyword">for</span> i = 1:nstypes
    dispf(<span class="string">'\n-- object <span class="comment">%d of %d --'</span>, i, nstypes)</span>
    j = setdiff(others, i);
    sti = stypes(i);
    stj = cat(1, stypesfull{j});
    XYZothers = cat(1, XYZ{j});
    [VXYZ, ~, ~, ~, dij] = buildVerletList({XYZ{i}, XYZothers}, 2 * H, false, 1);
    found = find(~cellfun(@isempty, VXYZ));
    currentNeigh = [VXYZ{found}];
    currenttyp = stj(currentNeigh);
    currenttypu = unique(currenttyp, <span class="string">'stable'</span>)<span class="string">';
    currentDist = [dij{found}];
    currentDistu = arrayfun(@(t) min(currentDist(currenttyp == t)), currenttypu) / H;
    
    <span class="comment">% Record</span>
    C(i).i = i;
    C(i).n = size(XYZ{i}, 1);
    C(i).jneigh = j;
    C(i).type = sti;
    C(i).tneigh = currenttypu;
    C(i).jneigh = arrayfun(@(t) find(stypes == t), currenttypu);
    C(i).dneigh = currentDistu'</span>;
    C(i).XYZ = XYZ{i};
    C(i).tobeupdated = false;
<span class="keyword">end</span>
Cbackup = C;

<span class="comment">%% Identify split globules and reunite them</span>
C = Cbackup;
nodes_tobeupdated = [];
<span class="keyword">for</span> i = 1:nstypes
    dispf(<span class="string">'object <span class="comment">%d of %d'</span>, i, nstypes)</span>
    <span class="keyword">if</span> (C(i).type < 1000) ... <span class="comment">% not an image (images of split globules are managed in the same time)</span>
            || (~C(i).tobeupdated && ~C(i).deleted && ~C(i).isReunited) <span class="comment">% not examined image</span>
        [reunitedXYZ, isReunited] = PBCoutcell(XYZ{i}, box, PBC);
    <span class="keyword">else</span>
        isReunited = false;
    <span class="keyword">end</span>
    <span class="keyword">if</span> isReunited
        C(i).XYZ = reunitedXYZ;
        tk = intersect(C(i).tneigh, (1:26) * 1000 + C(i).type); <span class="comment">% <span class="keyword">for</span> each image, we try to reunite them on the size they are</span>
        k = arrayfun(@(t) find(stypes == t), tk);
        
        <span class="comment">% Merge entries</span>
        <span class="keyword">if</span> ~isempty(k)
            XYZtmp = PBCoutcell(cat(1, C(k).XYZ), box, PBC);
            C(k(1)).XYZ = XYZtmp;
            C(k(1)).tobeupdated = true;
            [C(k(2:<span class="keyword">end</span>)).deleted] = deal(true);
        <span class="keyword">end</span>
        
        <span class="comment">% Set updates</span>
        C(i).tobeupdated = true;
        [C(C(i).jneigh).tobeupdated] = deal(true);
    <span class="keyword">elseif</span> ~C(i).tobeupdated
        <span class="keyword">if</span> ~C(i).deleted
            C(i).XYZ = XYZ{i};
        <span class="keyword">else</span>
            C(i).XYZ = [];
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    
    <span class="comment">% Default update behavior</span>
    <span class="keyword">if</span> ~C(i).deleted
        C(i).n = size(C(i).XYZ, 1);
        C(i).ifull = ones(C(i).n, 1) * i;
        C(i).center = mean(C(i).XYZ, 1);
        C(i).isReunited = isReunited;
    <span class="keyword">else</span>
        C(i).n = 0;
        C(i).center = [];
        C(i).ifull = [];
        C(i).tobeupdated = false;
    <span class="keyword">end</span>
    
    <span class="keyword">if</span> C(i).tobeupdated
        nodes_tobeupdated(<span class="keyword">end</span> + 1) = i; <span class="comment">%#ok<SAGROW></span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% Update the nodes</span>
<span class="keyword">for</span> i =  1:nstypes
    <span class="keyword">if</span> ismember(i,nodes_tobeupdated) <span class="comment">% to be updated</span>
        <span class="keyword">if</span> ~C(i).deleted
            j = setdiff(others, i);
            j = j(~[C(j).deleted]);
            XYZothers = cat(1, C(j).XYZ);
            jothers = cat(1, C(j).ifull);
            [VXYZ, ~, ~, ~, dij] = buildVerletList({C(i).XYZ, XYZothers}, 2 * H, false, 1);
            found = find(~cellfun(@isempty, VXYZ));
            currentNeigh = [VXYZ{found}];
            currentjneigh = jothers(currentNeigh);
            C(i).oldjneigh = C(i).jneigh;
            C(i).jneigh = unique(currentjneigh, <span class="string">'stable'</span>)<span class="string">';
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="keyword">if</span> ~isfield(C(i),'</span>oldjneigh<span class="string">') || isempty(C(i).oldjneigh)
            C(i).oldjneigh = C(i).jneigh;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    C(i).jneigh = C(i).jneigh(~[C(C(i).jneigh).deleted]);
<span class="keyword">end</span>


<span class="comment">%% Result container ----------------------------</span>
Rtemplate = table('</span>Size<span class="string">',[1 10],...
    '</span>VariableTypes<span class="string">',{'</span>string<span class="string">'    ,'</span>string<span class="string">'  ,'</span>double<span class="string">'  ,'</span>cell<span class="string">','</span>double<span class="string">','</span>double<span class="string">'    ,'</span>cell<span class="string">'    ,'</span>double<span class="string">','</span>cell<span class="string">'       ,'</span>cell<span class="string">'}, ...
    '</span>VariableNames<span class="string">',{'</span>datafolder<span class="string">','</span>dumpfile<span class="string">','</span>timestep<span class="string">','</span>graph<span class="string">' ,'</span>nNodes<span class="string">','</span>fractalDim<span class="string">','</span>XYZ<span class="string">'   ,'</span>counts<span class="string">','</span>nodeDegrees<span class="string">','</span>color<span class="string">'});
Rtemplate.datafolder = datafolder;
Rtemplate.dumpfile = dumpFile;
Rtemplate.timestep = timesteps(it);

<span class="comment">%% Build the contact matrix: A</span>
nC = length(C);
A = sparse(nC, nC);
D = sparse(nC, nC);
dmax = max(boxsize);
nmax = max([C.n]);
<span class="keyword">for</span> i = find([C.type]<1000)
    <span class="keyword">if</span> ~C(i).deleted
        j = C(i).jneigh;
        j = j(~[C(j).deleted]);
        <span class="keyword">if</span> any(C(i).jneigh)
            dtmp = vecnorm(cat(1,C(j).center)-C(i).center,2,2)'</span>;
            D(i,j) = dtmp;
        <span class="keyword">else</span>
            dtmp=0;
        <span class="keyword">end</span>
        <span class="keyword">if</span> ~isempty(j), j = j(dtmp<=dmax/2); <span class="keyword">end</span>
        A(i, j) = 1;
        A(j, i) = 1; <span class="comment">% Ensure symmetry</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Create a table <span class="keyword">for</span> node information</span>
nodeInfo = table((1:nC)<span class="string">', '</span>VariableNames<span class="string">', {'</span>OriginalIndex<span class="string">'}); <span class="comment">% Create table with original indices</span>
<span class="comment">% Add additional properties to the table <span class="keyword">if</span> needed</span>
nodeInfo.XYZ = cell(nC, 1);
nodeInfo.Degree = zeros(nC, 1);

<span class="keyword">for</span> i = 1:nC
    nodeInfo.XYZ{i} = C(i).XYZ;
    nodeInfo.Degree(i) = numel(C(i).jneigh); <span class="comment">% Example: store the degree (number of neighbors)</span>
<span class="keyword">end</span>
<span class="comment">% Create the graph</span>
G = graph(A);
G.Nodes = nodeInfo;

<span class="comment">% Display the graph'</span>s nodes table</span>
disp(G.Nodes);


<span class="comment">% Create a table <span class="keyword">for</span> node information</span>
nodeInfo = table((1:nC)<span class="string">', '</span>VariableNames<span class="string">', {'</span>OriginalIndex<span class="string">'}); <span class="comment">% Create table with original indices</span>

<span class="comment">% Add additional properties to the table <span class="keyword">if</span> needed</span>
nodeInfo.XYZ = cell(nC, 1);
nodeInfo.Degree = zeros(nC, 1);

<span class="keyword">for</span> i = 1:nC
    nodeInfo.XYZ{i} = C(i).XYZ;
    nodeInfo.Degree(i) = numel(C(i).jneigh); <span class="comment">% Example: store the degree (number of neighbors)</span>
<span class="keyword">end</span>

<span class="comment">% Create the graph</span>
G = graph(A);
G.Nodes = nodeInfo;

<span class="comment">% Display the graph'</span>s nodes table</span>
disp(G.Nodes);

<span class="comment">% Plot the topology</span>
<span class="comment">% Identify unique subgraphs</span>
bins = conncomp(G); <span class="comment">% Find connected components</span>
uniqueSubgraphs = containers.Map;
uniqueSubgraphsCounts = containers.Map;

<span class="keyword">for</span> i = 1:max(bins)
    subG = subgraph(G, bins == i);
    sortedEdges = sortrows(table2array(subG.Edges), 1:2);
    subgraphStr = mat2str(sortedEdges);
    
    <span class="keyword">if</span> ~isKey(uniqueSubgraphs, subgraphStr)
        uniqueSubgraphs(subgraphStr) = subG;
        uniqueSubgraphsCounts(subgraphStr) = 0;
    <span class="keyword">end</span>
    uniqueSubgraphsCounts(subgraphStr) = uniqueSubgraphsCounts(subgraphStr) + 1;
<span class="keyword">end</span>

<span class="comment">% Calculate properties</span>
subgraphProperties = [];
subgraphList = keys(uniqueSubgraphs);

<span class="keyword">for</span> k = 1:length(subgraphList)
    subG = uniqueSubgraphs(subgraphList{k});
    nNodes = numnodes(subG);
    fractalDim = numedges(subG) / numnodes(subG);
    count = uniqueSubgraphsCounts(subgraphList{k});
    <span class="comment">% Store node mapping</span>
    nodeIndices = subG.Nodes.OriginalIndex; <span class="comment">% Use the OriginalIndex from G.Nodes</span>
    subgraphProperties = [subgraphProperties; struct(<span class="string">'graph'</span>, subG, <span class="string">'nNodes'</span>, nNodes, <span class="string">'fractalDim'</span>, fractalDim, <span class="string">'count'</span>, count, <span class="string">'NodeMapping'</span>, nodeIndices)];
<span class="keyword">end</span>

<span class="comment">% Sort subgraphs by number of nodes and remove duplicates</span>
[~, sortIdx] = sort([subgraphProperties.nNodes], <span class="string">'descend'</span>);
sortedSubgraphProperties = subgraphProperties(sortIdx);

<span class="comment">% Remove duplicates based on fractalDim and structure</span>
uniqueSubgraphProperties = [];
uniqueKeys = containers.Map;

<span class="keyword">for</span> i = 1:length(sortedSubgraphProperties)
    subG = sortedSubgraphProperties(i).graph;
    fractalDim = sortedSubgraphProperties(i).fractalDim;
    nNodes = sortedSubgraphProperties(i).nNodes;
    uniqueKey = sprintf(<span class="string">'<span class="comment">%.2f-%d'</span>, fractalDim, nNodes); % Unique key based on fractal dimension and number of nodes</span>
    
    <span class="keyword">if</span> ~isKey(uniqueKeys, uniqueKey)
        uniqueKeys(uniqueKey) = true;
        uniqueSubgraphProperties = [uniqueSubgraphProperties; sortedSubgraphProperties(i)];
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Plot unique subgraphs</span>
figure(resultfigs(1))
formatfig(resultfigs(1),<span class="string">'figname'</span>,lastdir(saveresultfig2D),<span class="string">'PaperPosition'</span>,[-0.3939    3.6647   21.7719   22.393]);
clf(resultfigs(1))
nUnique = length(uniqueSubgraphProperties);
nCols = floor(sqrt(nUnique));
nRows = ceil(nUnique / nCols);
Rcurrent = repmat(Rtemplate,nUnique,1);

<span class="comment">% Choose color</span>
cmap = colormap(jet);
normDegree = @(nodeDegrees) (nodeDegrees - min(nodeDegrees)) / (max(nodeDegrees) - min(nodeDegrees)); <span class="comment">% Normalize degree</span>
colorDegree = @(nodeDegrees) interp1(linspace(0, 1, size(cmap, 1)), cmap, normDegree(nodeDegrees));

<span class="comment">% <span class="keyword">for</span> each unique <span class="keyword">case</span></span>
<span class="keyword">for</span> idx = 1:nUnique
    subGData = uniqueSubgraphProperties(idx);
    subGData.NodeDetails = G.Nodes(subGData.NodeMapping,:);
    subplot(nRows, nCols, idx);
    
    <span class="comment">% Get node degrees</span>
    nodeDegrees = degree(subGData.graph);
    
    <span class="comment">% Plot the graph with nodes colored according to their degrees</span>
    Nodelabel = cell(subGData.nNodes,1);
    <span class="keyword">if</span> DEBUGmode
        <span class="keyword">for</span> inl = 1:subGData.nNodes
            Nodelabel{inl} = sprintf(<span class="string">'\\bf<span class="comment">%d\\rm: %d-%d-%d-%d'</span>,subGData.graph.Nodes.OriginalIndex(inl), ...</span>
                C(subGData.graph.Nodes.OriginalIndex(inl)).n,...
                C(subGData.graph.Nodes.OriginalIndex(inl)).deleted,...
                C(subGData.graph.Nodes.OriginalIndex(inl)).isReunited,...
                C(subGData.graph.Nodes.OriginalIndex(inl)).tobeupdated);
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        Nodelabel = {};
    <span class="keyword">end</span>

    p = plot(subGData.graph, <span class="string">'Layout'</span>, <span class="string">'force'</span>, <span class="string">'NodeLabel'</span>, Nodelabel);
    p.NodeCData = nodeDegrees;
    
    <span class="comment">% Adjust colorbar</span>
    colormap(jet)
    cb = colorbar(<span class="string">'eastoutside'</span>);
    cb.Label.String = <span class="string">'Node Degree'</span>;
    pos = cb.Position;
    cb.Position = [pos(1) + 4*pos(3), pos(2) + 0.25 * pos(4), 0.25 * pos(3), 0.5 * pos(4)];
    
    <span class="comment">% Set color limits ensuring valid range</span>
    <span class="keyword">if</span> max(nodeDegrees) > 1
        clim([1, max(nodeDegrees)]);
    <span class="keyword">else</span>
        clim([1, 2]); <span class="comment">% Set a default valid range <span class="keyword">if</span> max degree is 1</span>
    <span class="keyword">end</span>

    title(sprintf(<span class="string">'Nodes: <span class="comment">%d, Fractal Dim: %.2f, Count: %d'</span>, subGData.nNodes, subGData.fractalDim, subGData.count));</span>

    <span class="comment">% store results</span>
    Rcurrent.graph{idx} = subGData.graph;
    Rcurrent.nNodes(idx) = subGData.nNodes;
    Rcurrent.fractalDim(idx) = subGData.fractalDim;
    Rcurrent.count(idx) = subGData.count;
    Rcurrent.nodeDegrees{idx} = nodeDegrees;
    Rcurrent.XYZ{idx} = subGData.NodeDetails.XYZ;
    Rcurrent.color{idx} = colorDegree(nodeDegrees);

<span class="keyword">end</span>

<span class="comment">% global title</span>
sgtitle(sprintf(<span class="string">'Time Step: <span class="comment">%d'</span>,timesteps(it)))</span>

<span class="comment">% Save results and print figure</span>
save(saveresultfile,<span class="string">'Rcurrent'</span>)
print_png(400,fullfile(saveresultfolder,get(resultfigs(1),<span class="string">'filename'</span>)),<span class="string">''</span>,<span class="string">''</span>,0,0,0)



<span class="comment">%% Identify unique subgraphs</span>
<span class="comment">% bins = conncomp(G); % Find connected components</span>
<span class="comment">% uniqueSubgraphs = containers.Map;</span>
<span class="comment">% uniqueSubgraphsCounts = containers.Map;</span>
<span class="comment">% </span>
<span class="comment">% <span class="keyword">for</span> i = 1:max(bins)</span>
<span class="comment">%     subG = subgraph(G, bins == i);</span>
<span class="comment">%     sortedEdges = sortrows(table2array(subG.Edges), 1:2);</span>
<span class="comment">%     subgraphStr = mat2str(sortedEdges);</span>
<span class="comment">% </span>
<span class="comment">%     <span class="keyword">if</span> ~isKey(uniqueSubgraphs, subgraphStr)</span>
<span class="comment">%         uniqueSubgraphs(subgraphStr) = subG;</span>
<span class="comment">%         uniqueSubgraphsCounts(subgraphStr) = 0;</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">%     uniqueSubgraphsCounts(subgraphStr) = uniqueSubgraphsCounts(subgraphStr) + 1;</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% %%Calculate properties</span>
<span class="comment">% subgraphProperties = [];</span>
<span class="comment">% subgraphList = keys(uniqueSubgraphs);</span>
<span class="comment">% </span>
<span class="comment">% <span class="keyword">for</span> k = 1:length(subgraphList)</span>
<span class="comment">%     subG = uniqueSubgraphs(subgraphList{k});</span>
<span class="comment">%     nNodes = numnodes(subG);</span>
<span class="comment">%     fractalDim = numedges(subG) / numnodes(subG);</span>
<span class="comment">%     count = uniqueSubgraphsCounts(subgraphList{k});</span>
<span class="comment">% </span>
<span class="comment">%     % Store node mapping</span>
<span class="comment">%     nodeIndices = subG.Nodes.OriginalIndex; % Use the OriginalIndex from G.Nodes</span>
<span class="comment">%     subgraphProperties = [subgraphProperties; struct(<span class="string">'graph'</span>, subG, <span class="string">'nNodes'</span>, nNodes, <span class="string">'fractalDim'</span>, fractalDim, <span class="string">'count'</span>, count, <span class="string">'NodeMapping'</span>, nodeIndices)];</span>
<span class="comment">% <span class="keyword">end</span></span>

<span class="comment">% Filter subgraphs with fractal dimension >= 1</span>
filteredSubgraphProperties = subgraphProperties([subgraphProperties.fractalDim] > 0.6);

<span class="comment">% Plot filtered subgraphs in 3D</span>
figure(resultfigs(2))
formatfig(resultfigs(2),<span class="string">'figname'</span>,lastdir(saveresultfig3D),<span class="string">'PaperPosition'</span>,[-0.0000    0.3500   21.0000   29.0000]);
clf(resultfigs(2))
nFiltered = length(filteredSubgraphProperties);
nCols = floor(sqrt(nFiltered));
nRows = ceil(nFiltered / nCols);

<span class="keyword">for</span> idx = 1:nFiltered
    subGData = filteredSubgraphProperties(idx);
    subplot(nRows, nCols, idx);
    
    <span class="comment">% Get node degrees</span>
    nodeDegrees = subGData.graph.Nodes.Degree;
    
    <span class="comment">% Plot each globule in the subgraph</span>
    hold on;
    <span class="keyword">for</span> j = 1:numel(subGData.NodeMapping)
        nodeIdx = subGData.NodeMapping(j);
        <span class="keyword">if</span> nodeIdx > 0 <span class="comment">% Ensure valid index</span>
            globuleXYZ = G.Nodes.XYZ{nodeIdx};
            globuleDegree = nodeDegrees(j);
            
            <span class="comment">% Map degree to color</span>
            cmap = colormap(jet);
            clim([1 max(nodeDegrees)]);
            normDegree = (globuleDegree - min(nodeDegrees)) / (max(nodeDegrees) - min(nodeDegrees)); <span class="comment">% Normalize degree</span>
            color = interp1(linspace(0, 1, size(cmap, 1)), cmap, normDegree);
            
            <span class="comment">% Plot the 3D scatter plot <span class="keyword">for</span> the globule</span>
            <span class="keyword">if</span> ~isempty(globuleXYZ)
                scatter3(globuleXYZ(:, 1), globuleXYZ(:, 2), globuleXYZ(:, 3), 36, repmat(color, size(globuleXYZ, 1), 1), <span class="string">'filled'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    hold off;
    
    <span class="comment">% Add colorbar and set limits</span>
    cb = colorbar(<span class="string">'eastoutside'</span>);
    cb.Label.String = <span class="string">'Node Degree'</span>;
    pos = cb.Position;
    cb.Position = [pos(1) + 5*pos(3), pos(2) + 0.25 * pos(4), pos(3) * 0.25, pos(4) * 0.5];
    
    <span class="comment">% Set color limits ensuring valid range</span>
    <span class="keyword">if</span> max(nodeDegrees) > 1
        clim([1, max(nodeDegrees)]);
    <span class="keyword">else</span>
        clim([1, 2]); <span class="comment">% Set a default valid range <span class="keyword">if</span> max degree is 1</span>
    <span class="keyword">end</span>
    axis equal, axis tight, view(3)

    <span class="comment">% Title <span class="keyword">for</span> the plot</span>
    title(sprintf(<span class="string">'Nodes: <span class="comment">%d, Fractal Dim: %.2f, Count: %d'</span>, subGData.nNodes, subGData.fractalDim, subGData.count));</span>

<span class="keyword">end</span>
<span class="comment">% global title</span>
sgtitle(sprintf(<span class="string">'Time Step: <span class="comment">%d'</span>,timesteps(it)))</span>


<span class="comment">% Save results and print figure</span>
print_png(400,fullfile(saveresultfolder,get(resultfigs(2),<span class="string">'filename'</span>)),<span class="string">''</span>,<span class="string">''</span>,0,0,0)

<span class="comment">% My old code</span>
<span class="comment">% % Interpretation O. Vitrac - rev. 2024-07-12</span>
<span class="comment">% </span>
<span class="comment">% % Definitions</span>
<span class="comment">% <span class="keyword">switch</span> localname</span>
<span class="comment">%     <span class="keyword">case</span> <span class="string">'WS-OLIVIER2023'</span></span>
<span class="comment">%         root = <span class="string">'D:\Sensory_viscosimeter_V0'</span>;</span>
<span class="comment">%     <span class="keyword">otherwise</span></span>
<span class="comment">%         error(<span class="string">'Set your machine '</span><span class="string">'%s'</span><span class="string">' first'</span>,localname)</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% subdatafolder = <span class="string">'/Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary'</span>;</span>
<span class="comment">% datafolder = fullfile(root,subdatafolder);</span>
<span class="comment">% </span>
<span class="comment">% % POST template</span>
<span class="comment">% allDumpFiles = {</span>
<span class="comment">%     %<span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with40SuspendedParticle_10Yparticle'</span>,</span>
<span class="comment">%     %<span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with40SuspendedParticle_1000Yparticle'</span>,</span>
<span class="comment">%     %<span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with40SuspendedParticle_100000Yparticle'</span>,</span>
<span class="comment">%     <span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with80SuspendedParticle_10Yparticle'</span>,</span>
<span class="comment">%     <span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with80SuspendedParticle_1000Yparticle'</span>,</span>
<span class="comment">%     <span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with80SuspendedParticle_100000Yparticle'</span></span>
<span class="comment">%     };</span>
<span class="comment">% </span>
<span class="comment">% jumps = 30000*30;</span>
<span class="comment">% allTimesteps = {</span>
<span class="comment">%     %[0:jumps:10080000],</span>
<span class="comment">%     %[0:jumps:9990000],</span>
<span class="comment">%     %[0:jumps:10170000],</span>
<span class="comment">%     [0:jumps:10650000],</span>
<span class="comment">%     [0:jumps:10500000],</span>
<span class="comment">%     [0:jumps:10530000]</span>
<span class="comment">%     };</span>
<span class="comment">% </span>
<span class="comment">% D = 0.001;</span>
<span class="comment">% BOX_DIMENSIONS = [0 2*D -0.1*D 1.1*D 0 2*D];</span>
<span class="comment">% BOUNDARIES = [1 0 1]; % 1 <span class="keyword">if</span> periodic</span>
<span class="comment">% S = D / 48;</span>
<span class="comment">% R = 0.5 * S; % radius of the particle (please, be very accurate)</span>
<span class="comment">% E = 2000; % Hertz contact stiffness</span>
<span class="comment">% A = 4 * D * D; % Area of the wall</span>
<span class="comment">% H = 2 * R;</span>
<span class="comment">% MU = 0.01;</span>
<span class="comment">% NU = MU/1000;</span>
<span class="comment">% U= 0.01;</span>
<span class="comment">% </span>
<span class="comment">% % load file</span>
<span class="comment">% d = 1;</span>
<span class="comment">% dumpFile = allDumpFiles{d};</span>
<span class="comment">% timesteps = allTimesteps{d};</span>
<span class="comment">% dataFile=lamdumpread2(fullfile(datafolder,dumpFile),<span class="string">'usesplit'</span>,[], timesteps);</span>
<span class="comment">% </span>
<span class="comment">% % box size</span>
<span class="comment">% coords = {<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>};</span>
<span class="comment">% icoords = cellfun(@(c) find(ismember({<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>},c)),coords);</span>
<span class="comment">% box = dataFile.BOX(icoords,:); % note that the order is given by coords, here {<span class="string">'z'</span>}    {<span class="string">'x'</span>}    {<span class="string">'y'</span>}</span>
<span class="comment">% boxsize = diff(box,1,2);</span>
<span class="comment">% PBC = [true,false,true]; % true <span class="keyword">if</span> periodic</span>
<span class="comment">% PBCthickness = max(0.4*boxsize(PBC));</span>
<span class="comment">% </span>
<span class="comment">% %% First analysis (raw)</span>
<span class="comment">% it = 3;</span>
<span class="comment">% selection = dataFile.ATOMS(dataFile.ATOMS.TIMESTEP==timesteps(it) & dataFile.ATOMS.type>=4,:);</span>
<span class="comment">% XYZselection = PBCincell(selection{:,coords},box,PBC);</span>
<span class="comment">% [XYZimagesONLY ,indXimagesONLY,copyimagesIdx]= PBCimages(XYZselection,box,PBC,PBCthickness);</span>
<span class="comment">% figure, hold on, plot3D(XYZselection,<span class="string">'kx'</span>), plot3D(XYZimagesONLY,<span class="string">'ro'</span>), view(3), axis equal</span>
<span class="comment">% selectionimage = selection(indXimagesONLY,:);</span>
<span class="comment">% selectionimage{:,coords} = XYZimagesONLY;</span>
<span class="comment">% selectionimage.type = selectionimage.type+1000*copyimagesIdx;</span>
<span class="comment">% selectionwithimages = [selection;selectionimage];</span>
<span class="comment">% selectionwithimages.isimages = selectionwithimages.type>1000;</span>
<span class="comment">% </span>
<span class="comment">% stypes = unique(selectionwithimages.type); nstypes = length(stypes);</span>
<span class="comment">% [XYZ,stypesfull] = deal(cell(nstypes,1));</span>
<span class="comment">% isimages = stypes>1000;</span>
<span class="comment">% <span class="keyword">for</span> i = 1:nstypes</span>
<span class="comment">%     XYZ{i} = selectionwithimages{selectionwithimages.type == stypes(i),coords};</span>
<span class="comment">%     stypesfull{i} = selectionwithimages.type(selectionwithimages.type == stypes(i));</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% % control figure</span>
<span class="comment">% figure, hold on, col = parula(nstypes); <span class="keyword">for</span> i=1:nstypes, plot3D(XYZ{i},<span class="string">'o'</span>,<span class="string">'color'</span>,col(i,:)), <span class="keyword">end</span>, view(3), axis equal</span>
<span class="comment">% </span>
<span class="comment">% </span>
<span class="comment">% %% Contact pair wise distance (based on contacts)</span>
<span class="comment">% % i = 45, j = 125</span>
<span class="comment">% others = 1:nstypes;</span>
<span class="comment">% C = repmat(struct(<span class="string">'XYZ'</span>,[],<span class="string">'i'</span>,[],<span class="string">'type'</span>,NaN,<span class="string">'n'</span>,NaN,<span class="string">'center'</span>,[],<span class="string">'jneigh'</span>,[],<span class="string">'tneigh'</span>,[],<span class="string">'dneigh'</span>,[],...</span>
<span class="comment">%     <span class="string">'isReunited'</span>,false,<span class="string">'deleted'</span>,false,<span class="string">'tobeupdated'</span>,true,<span class="string">'ifull'</span>,[]),nstypes,1);</span>
<span class="comment">% imagestoremove = [];</span>
<span class="comment">% <span class="keyword">for</span> i=1:nstypes</span>
<span class="comment">%     dispf(<span class="string">'\n-- object %d of %d --'</span>,i,nstypes)</span>
<span class="comment">%     j = setdiff(others,i);</span>
<span class="comment">%     sti = stypes(i);</span>
<span class="comment">%     stj = cat(1,stypesfull{j});</span>
<span class="comment">%     XYZothers = cat(1,XYZ{j});</span>
<span class="comment">%     [VXYZ,~,~,~,dij]  = buildVerletList({XYZ{i} XYZothers},2*H,false,1);</span>
<span class="comment">%     found = find(~cellfun(@isempty,VXYZ));</span>
<span class="comment">%     currentNeigh = [VXYZ{found}];</span>
<span class="comment">%     currenttyp = stj(currentNeigh);</span>
<span class="comment">%     currenttypu = unique(currenttyp,<span class="string">'stable'</span>)<span class="string">';</span>
<span class="comment">%     currentDist = [dij{found}];</span>
<span class="comment">%     currentDistu = arrayfun(@(t) min(currentDist(currenttyp==t)),currenttypu)/H;</span>
<span class="comment">%     % record</span>
<span class="comment">%     C(i).i = i;</span>
<span class="comment">%     C(i).n = size(XYZ{i},1);</span>
<span class="comment">%     C(i).jneigh = j;</span>
<span class="comment">%     C(i).type = sti;</span>
<span class="comment">%     C(i).tneigh = currenttypu;</span>
<span class="comment">%     C(i).jneigh = arrayfun(@(t) find(stypes==t), currenttypu);</span>
<span class="comment">%     C(i).dneigh = currentDistu'</span>;</span>
<span class="comment">%     C(i).XYZ = XYZ{i};</span>
<span class="comment">%     C(i).tobeupdated = false;</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% Cbackup = C;</span>
<span class="comment">% </span>
<span class="comment">% %% Identify split globules and reunite them</span>
<span class="comment">% C = Cbackup;</span>
<span class="comment">% nodes_tobeupdated = [];</span>
<span class="comment">% <span class="keyword">for</span> i=1:nstypes</span>
<span class="comment">%     dispf(<span class="string">'object %d of %d'</span>,i,nstypes)</span>
<span class="comment">%     <span class="keyword">if</span> C(i).type<1000</span>
<span class="comment">%         [reunitedXYZ, isReunited] = PBCoutcell(XYZ{i}, box, PBC);</span>
<span class="comment">%     <span class="keyword">else</span></span>
<span class="comment">%         isReunited = false;</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">if</span> isReunited</span>
<span class="comment">%         C(i).XYZ = reunitedXYZ;</span>
<span class="comment">%         tk = intersect(C(i).tneigh,(1:26)*1000+C(i).type); % <span class="keyword">for</span> each image, we try to reunite them on the size they are</span>
<span class="comment">%         k = arrayfun(@(t)find(stypes==t),tk);</span>
<span class="comment">%         % merge entries</span>
<span class="comment">%         XYZtmp = PBCoutcell(cat(1,C(k).XYZ),box,PBC);</span>
<span class="comment">%         C(k(1)).XYZ = XYZtmp;</span>
<span class="comment">%         C(k(1)).tobeupdated = true;</span>
<span class="comment">%         [C(k(2:<span class="keyword">end</span>)).deleted] = deal(true);</span>
<span class="comment">%         % set updates</span>
<span class="comment">%         C(i).tobeupdated = true;</span>
<span class="comment">%         [C(C(i).jneigh).tobeupdated] = deal(true);</span>
<span class="comment">%     <span class="keyword">else</span></span>
<span class="comment">%         <span class="keyword">if</span> ~C(i).deleted</span>
<span class="comment">%             C(i).XYZ = XYZ{i};</span>
<span class="comment">%         <span class="keyword">else</span></span>
<span class="comment">%             C(i).XYZ = [];</span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">%     % default update behavior</span>
<span class="comment">%     <span class="keyword">if</span> ~C(i).deleted</span>
<span class="comment">%         C(i).n = size(C(i).XYZ,1);</span>
<span class="comment">%         C(i).ifull = ones(C(i).n,1)*i;</span>
<span class="comment">%         C(i).center = mean(C(i).XYZ,1);</span>
<span class="comment">%         C(i).isReunited = isReunited;</span>
<span class="comment">%     <span class="keyword">else</span></span>
<span class="comment">%         C(i).n = [];</span>
<span class="comment">%         C(i).center = [];</span>
<span class="comment">%         C(i).ifull = [];</span>
<span class="comment">%         C(i).tobeupdated = false;</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">if</span> C(i).tobeupdated</span>
<span class="comment">%         nodes_tobeupdated(<span class="keyword">end</span>+1) = i; %#ok<SAGROW></span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% %% Update the nodes</span>
<span class="comment">% <span class="keyword">for</span> i = nodes_tobeupdated</span>
<span class="comment">%     j = setdiff(others,i);</span>
<span class="comment">%     XYZothers = cat(1,C(j).XYZ);</span>
<span class="comment">%     jothers = cat(1,C(j).ifull);</span>
<span class="comment">%     [VXYZ,~,~,~,dij]  = buildVerletList({C(i).XYZ XYZothers},2*H,false,1);</span>
<span class="comment">%     found = find(~cellfun(@isempty,VXYZ));</span>
<span class="comment">%     currentNeigh = [VXYZ{found}];</span>
<span class="comment">%     currentjneigh = jothers(currentNeigh);</span>
<span class="comment">%     C(i).oldjneigh = C(i).jneigh;</span>
<span class="comment">%     C(i).jneigh = unique(currentjneigh,<span class="string">'stable'</span>)';</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% %% Build the contact matrix: A</span>
<span class="comment">% nC = length(C);</span>
<span class="comment">% A = zeros(nC,nC);</span>
<span class="comment">% <span class="keyword">for</span> i=1:length(C)</span>
<span class="comment">%     A(i,C(i).jneigh) = 1;</span>
<span class="comment">%     A(C(i).jneigh,i) = 1;</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% G = graph(A);</span>
<span class="comment">% </span>
</code></pre></div>
</div>
<div id='KE_t' class='doc-content' style='display: none;'>
<h1>KE_t for post-treatment of Billy&#x27; dump files (3D viscosimeter)</h1>
<p>INRAE\Olivier Vitrac - rev. 2023-03-26<br/>INRAE\William Jenkinson</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% KE_t <span class="keyword">for</span> post-treatment of Billy<span class="string">' dump files (3D viscosimeter)</span>
<span class="comment">% INRAE\Olivier Vitrac - rev. 2023-03-26</span>
<span class="comment">% INRAE\William Jenkinson</span>

<span class="comment">% Dependencies (not included in MS, at least not yet)</span>
<span class="comment">%   lamdumpread2()    version 2023-03-23 or later</span>
<span class="comment">%   buildVerletList() version 2023-03-25 or later</span>
<span class="comment">%</span>
<span class="comment">% note: be sure Olivier/INRA/Codes/MS is in your Path (MS=Molecular Studio)</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-03-23 RC, early design based on dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_Hertzdiv100_lite</span>
<span class="comment">% 2023-03-24 first interaction with Billy</span>
<span class="comment">%            the file <span class="keyword">for</span> design was shifted to dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_Hertzdiv10_lite</span>
<span class="comment">% 2023-03-25 implementation of a full Verletlist, automatic identification of fluid-solid contacts without using any</span>
<span class="comment">%            particular topology, the template is fully operational and used to plot the number of contacts with time</span>
<span class="comment">% 2023-03-06 first implementation of Hertz contacts (to be validated and extended)</span>
<span class="comment">%            better figure management (previous results can be reloaded)</span>
<span class="comment">% 2023-03-29 [BRANCH - WJ] script taken to template the kinetic energy vs time</span>
<span class="comment">% 2023-03-31 WJ - meta data and script are up-to-date <span class="keyword">for</span> the calculation of Kinetic Energy</span>

<span class="comment">%% read datafile</span>

<span class="comment">% path definitions (please add your machine name by typing localname in your command window)</span>
<span class="keyword">switch</span> localname
    <span class="keyword">case</span> '</span>LP-OLIVIER2022<span class="string">'
        local = '</span>C:\Users\olivi\OneDrive - agroparistech.fr\Billy\ProductionSandbox_toOV_23-03-2023<span class="string">';
    <span class="keyword">case</span> '</span>LX-Willy2021<span class="string">'
        local = '</span>/Data/billy/Results/Viscosimeter_SMJ_V6/ProductionSandbox_toOV_23-03-2023<span class="string">';
    <span class="keyword">case</span> '</span>YOUR MACHINE<span class="string">'
        local = '</span>it is the path where the dump file is located, results are stored at the sample place<span class="string">';
    <span class="keyword">otherwise</span>
        error('</span>add a <span class="keyword">case</span> with your machine name, which is <span class="string">''</span><span class="comment">%s<span class="string">''</span><span class="string">',localname)</span>
<span class="keyword">end</span>
datafile = '</span>dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_Hertzdiv100_lite<span class="string">';
<span class="comment">%datafile = '</span>dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1<span class="string">';</span>
fulldatafile = fullfile(local,datafile); <span class="comment">% concatenate path (local) and data filename</span>
X = lamdumpread2(fulldatafile); <span class="comment">% be sure the last version of lamdumpread2() is in the same folder as this script</span>

<span class="comment">% result file (to store results)</span>
resultfile = fullfile(local,['</span>RESULT_<span class="string">' datafile '</span>.mat<span class="string">']);

<span class="comment">%% Region-based definitions:  Wall and fluid regions</span>
<span class="comment">% note that the interface between regions is defined from pair-distances</span>
types = struct('</span>wall<span class="string">',1,'</span>fluid<span class="string">',2);
X.ATOMS.iswall = X.ATOMS.type==types.wall;  <span class="comment">% add the column iswall to the table X.ATOMS</span>
X.ATOMS.isfluid = X.ATOMS.type==types.fluid;<span class="comment">% add the column isfluid to the table X.ATOMS</span>
X.ATOMS.isundef = ~X.ATOMS.iswall & ~X.ATOMS.isfluid; <span class="comment">% add the column isundef to the table X.ATOMS</span>

<span class="comment">%% Control frame</span>
<span class="comment">% note that the data are stored in data.ATOMS, which is a table with named colums allowing hybrid indexing</span>
nsteps = length(X.TIMESTEP);
icurrenttime = ceil(0.5*nsteps); <span class="comment">% index of the control frame (used to set basic definitions before more advanced interpretation)</span>
currenttime = X.TIMESTEP(icurrenttime);
rawframe = X.ATOMS(X.ATOMS.TIMESTEP==currenttime,{'</span>id<span class="string">','</span>type<span class="string">','</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">','</span>iswall<span class="string">','</span>isfluid<span class="string">','</span>isundef<span class="string">'});
frame = table2array(rawframe(:,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'})); <span class="comment">% generate an array of coordinates</span>

<span class="comment">% Build the main Verlet list (<span class="keyword">for</span> all particles)</span>
<span class="comment">% V use the natural indexing instead of rawframe.id</span>
cutoff = 60e-6; <span class="comment">% empty or NaN value will force an automatic estimation of cutoff</span>
[V,cutoff,dmin] = buildVerletList(frame,cutoff); <span class="comment">% cutoff can be omitted</span>
 
<span class="comment">% Build the secondary Verlet lists (highly vectorized code)</span>
<span class="comment">% V1 the neighbors of type 2 (fluid) <span class="keyword">for</span> type 1 atoms (1..n1)</span>
<span class="comment">% V2 the neighbors of type 1 (wall) <span class="keyword">for</span> type 2 atoms (1..n2)</span>
idx1 = find(rawframe.type==1); n1 = length(idx1); <span class="comment">% indices of the wall particles in the current frame</span>
idx2 = find(rawframe.type==2); n2 = length(idx2); <span class="comment">% indices of the fluid particles in the current frame</span>
V1 = cellfun(@(v) v(rawframe.type(v)==2),V(idx1),'</span>UniformOutput<span class="string">',false); <span class="comment">% Verlet list <span class="keyword">for</span> type 1 in contact with type 2</span>
V2 = cellfun(@(v) v(rawframe.type(v)==1),V(idx2),'</span>UniformOutput<span class="string">',false); <span class="comment">% Verlet list <span class="keyword">for</span> type 1 in contact with type 2</span>
<span class="comment">% corresponding distances d1,d2</span>
<span class="comment">% some distances can be empty <span class="keyword">for</span> d2</span>
d1 = arrayfun(@(i) pdist2(frame(idx1(i),:),frame(V1{i},:)),(1:n1)'</span>,<span class="string">'UniformOutput'</span>,false); <span class="comment">% evaluate the distance <span class="keyword">for</span> each idx1(i)</span>
d2 = arrayfun(@(i) pdist2(frame(idx2(i),:),frame(V2{i},:)),(1:n2)<span class="string">','</span>UniformOutput<span class="string">',false); <span class="comment">% evaluate the distance <span class="keyword">for</span> each idx2(i)</span>
d1min = cellfun(@min,d1); <span class="comment">% minimum distance <span class="keyword">for</span> each idx1()</span>
d2min = cellfun(@min,d2,'</span>UniformOutput<span class="string">',false); <span class="comment">% minimum distance <span class="keyword">for</span> each idx2()</span>
[d2min{cellfun(@isempty,d2)}] = deal(NaN); <span class="comment">% populate empty distances with NaN</span>
d2min = cat(1,d2min{:}); <span class="comment">% we collect all now all distances (since the fluid is moving with respect with the wall)</span>
 
<span class="comment">% Identify beads of type 1 (wall) directly in contact with fluids</span>
<span class="comment">% this method is general and relies only on pair distances</span>
<span class="comment">% the term "contact" is general (vincinity) not a "real" contact as set later</span>
iswallcontact = d1min < 1.5 * dmin;  <span class="comment">% condition <span class="keyword">for</span> a wall particle to be considered possibly in contact with the fluid</span>
isfluidcontact = ~isnan(d2min);      <span class="comment">% the condition is less restrictive <span class="keyword">for</span> the fluid, based on the cutoff distance</span>
V1contact = V1(iswallcontact);       <span class="comment">% "contact" Verlet list corresponding to V1</span>
V2contact = V2(isfluidcontact);      <span class="comment">% "contact" Verlet list corresponding to V1</span>
iwallcontact = idx1(iswallcontact);
ifluidcontact = unique(cat(2,V1contact{:})); <span class="comment">% within cutoff</span>
<span class="comment">% </span>
<span class="comment">% control plot</span>
<span class="comment">% one color is assigned to each phase</span>
<span class="comment">% symbols are filled <span class="keyword">if</span> they are included in the contact Verlet list</span>
<span class="comment">% type figure, rgb() to list all available colors</span>
colors = struct('</span>wall<span class="string">',rgb('</span>Crimson<span class="string">'),'</span>fluid<span class="string">',rgb('</span>DeepSkyBlue<span class="string">'),'</span>none<span class="string">','</span>None<span class="string">');
figure, hold on
plot3D(frame(rawframe.isundef,:),'</span>ko<span class="string">');
plot3D(frame(rawframe.iswall,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.wall,'</span>MarkerFaceColor<span class="string">',colors.none);
plot3D(frame(iwallcontact,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.none,'</span>MarkerFaceColor<span class="string">',colors.wall);
plot3D(frame(rawframe.isfluid,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.fluid,'</span>MarkerFaceColor<span class="string">',colors.none);
plot3D(frame(ifluidcontact,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.none,'</span>MarkerFaceColor<span class="string">',colors.fluid);
axis equal, axis tight, view(3)

<span class="comment">%% [1:X] INTERPRETATION: counting the number of contact with time</span>
<span class="comment">% count the number of fluid beads in contact with wall (within 2*R)</span>
R = 0.5*0.001/48; <span class="comment">% radius of the particle (please, be very accurate)</span>
dbond = 2*R; <span class="comment">% bond = link between 2 atoms</span>
wall_id  = rawframe.id(iwallcontact);   <span class="comment">% extract the ids matching the contact condition in the reference frame</span>
fluid_id = rawframe.id(ifluidcontact);  <span class="comment">% idem <span class="keyword">for</span> the fluid particles within the contact Verlet list</span>
<span class="comment">% config setup</span>
E = 2e4 ; <span class="comment">% ref:2e6, Hertzdiv10:2e5, Hertzdiv100:2e4</span>
Hertzconfig = struct('</span>name<span class="string">',{'</span>wall<span class="string">','</span>fluid<span class="string">'},'</span>R<span class="string">',R,'</span>E<span class="string">',E); <span class="comment">% entries are duplicated <span class="keyword">if</span> not mentioned</span>

<span class="comment">% prepare to calculate pair distances between different beads</span>
pairdist = @(X,Y) triu(pdist2(X,Y),0); <span class="comment">% note that the diagonal is included here (since X and Y are different)</span>
ncontacts = zeros(nsteps,1);
KEnergy = zeros(nsteps,1);
[t_,t__] = deal(clock); <span class="comment">%#ok<*CLOCK> </span>
screen = '</span><span class="string">';
<span class="keyword">for</span> icurrenttime = 1:nsteps
    currenttime = X.TIMESTEP(icurrenttime);
    <span class="comment">% --- some display, to encourage the user to be patient</span>
    <span class="keyword">if</span> mod(icurrenttime,5)
        <span class="keyword">if</span> etime(clock,t__)>2 <span class="comment">%#ok<*DETIM></span>
            t__ = clock; dt = etime(t__,t_); done = 100*(icurrenttime-1)/nsteps;
            screen = dispb(screen,'</span>[<span class="comment">%d/%d] interpretation [ done %0.3g %% | elapsed %0.3g s | remaining %0.3g s ] ...<span class="string">', ...</span>
                icurrenttime,nsteps,done,dt,dt*(100/done-1));
        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">% --- <span class="keyword">end</span> of display</span>
    Vel = table2array(X.ATOMS((X.ATOMS.TIMESTEP==currenttime) & (X.ATOMS.type==1),{'</span>vx<span class="string">','</span>vy<span class="string">','</span>vz<span class="string">','</span>mass<span class="string">'})); <span class="comment">% raw data <span class="keyword">for</span> the current frame</span>
    V_mag_sq = Vel(:,1).^2 + Vel(:,2).^2 + Vel(:,3).^2;
    KEnergy(icurrenttime) = sum(0.5*Vel(:,4).*V_mag_sq); <span class="comment">% sum forces along x</span>
<span class="keyword">end</span>

<span class="comment">% save the data to enable a refresh of the figure without restarting this block</span>
timesteps = X.TIMESTEP;
save(resultfile,'</span>datafile<span class="string">','</span>KEnergy<span class="string">','</span>ncontacts<span class="string">','</span>timesteps<span class="string">','</span>Hertzconfig<span class="string">')
dispf('</span>Results saved (<span class="comment">%s):<span class="string">',datafile), fileinfo(resultfile)</span>

<span class="comment">%% PLots and figure management</span>

<span class="comment">% reload the data</span>
<span class="keyword">if</span> exist(resultfile,'</span>file<span class="string">'), load(resultfile), <span class="keyword">end</span>

<span class="comment">% plot number of contacts vs. time</span>
contactfigure = figure;
formatfig(contactfigure,'</span>figname<span class="string">',['</span>NumberContact<span class="string">' datafile],'</span>PaperPosition<span class="string">',[1.5000    9.2937   18.0000   11.1125])
plot(timesteps,ncontacts,'</span>linewidth<span class="string">',0.5,'</span>Color<span class="string">',rgb('</span>Crimson<span class="string">'))
formatax(gca,'</span>fontsize<span class="string">',14)
xlabel('</span>time (units)<span class="string">','</span>fontsize<span class="string">',16)
ylabel('</span>Kinetic energy of particles ()<span class="string">','</span>fontsize<span class="string">',16)
wtitle = textwrap({'</span>\bfdump file:\rm<span class="string">';datafile},40);
title(regexprep(wtitle,'</span>_<span class="string">','</span>\\_<span class="string">'),'</span>fontsize<span class="string">',10)

<span class="comment">% plot number of Hertz projection along x vs. time</span>
hertzfigure = figure;
formatfig(hertzfigure,'</span>figname<span class="string">',['</span>KineticEnergy<span class="string">' datafile],'</span>PaperPosition<span class="string">',[1.5000    9.2937   18.0000   11.1125])
plot(timesteps,KEnergy,'</span>linewidth<span class="string">',0.5,'</span>Color<span class="string">',rgb('</span>Teal<span class="string">'))
formatax(gca,'</span>fontsize<span class="string">',14)
xlabel('</span>Frame (-)<span class="string">','</span>fontsize<span class="string">',16)
ylabel('</span>Kinetic energy (J)<span class="string">','</span>fontsize<span class="string">',16)
wtitle = textwrap({'</span>\bfdump file:\rm<span class="string">';datafile},40);
title(regexprep(wtitle,'</span>_<span class="string">','</span>\\_<span class="string">'),'</span>fontsize<span class="string">',10)

<span class="comment">% save images in all valid formats (including Matlab one, the data can be extracted with this format)</span>
<span class="comment">% filenames are identical to the dump file with the proper extension: fig, pdf, png</span>
<span class="keyword">for</span> myfig = [contactfigure,hertzfigure] <span class="comment">% loop over all figures to print</span>
    figure(myfig)
    saveas(gcf,fullfile(local,[get(gcf,'</span>filename<span class="string">') '</span>.fig<span class="string">']),'</span>fig<span class="string">') <span class="comment">% fig can be open without restarting the code</span>
    print_pdf(600,[get(gcf,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],local,'</span>nocheck<span class="string">') <span class="comment">% PDF 600 dpi</span>
    print_png(600,[get(gcf,'</span>filename<span class="string">') '</span>.png<span class="string">'],local,'</span>',0,0,0)  <span class="comment">% PNG 600 dpi</span>
<span class="keyword">end</span>

</code></pre></div>
</div>
<div id='MDunidrnd' class='doc-content' style='display: none;'>
<h1>MDUNIDRND generates m uniform random numbers (one appearance) ranged between 1 and n (n&gt;m)</h1>
<p>Syntax:  x = MDunidrnd(n,m)</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> x = MDunidrnd(n,m)
<span class="comment">%  MDUNIDRND generates m uniform random numbers (one appearance) ranged between 1 and n (n>m)</span>
<span class="comment">%</span>
<span class="comment">% 	Syntax:  x = MDunidrnd(n,m)</span>
       
<span class="comment">% MDsimple 2.0 - 21/07/03 - Olivier Vitrac - rev.</span>

<span class="comment">% argument check</span>
<span class="keyword">if</span> n<m, error(<span class="string">'n<m'</span>), <span class="keyword">end</span>

<span class="comment">% random generator</span>
x = []; lx = 0;
<span class="keyword">while</span> lx<m
	x(<span class="keyword">end</span>+1:m) = unidrnd(n,m-lx,1);
	[xu,j] = unique(x);
	x = x(sort(j));
	lx = length(x);
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='PBCgrid' class='doc-content' style='display: none;'>
<h1>PBCgrid add periodic boundary conditions to meshgrid/ndgrid meshed values</h1>
<p>USAGE in 3D<br/>[Vp,Xp,Yp,Zp] = PBCgrid(X,Y,Z,V,PBC [,cutoff])<br/>USAGE in 2D<br/>[Vp,Xp,Yp] = PBCgrid(X,Y,V,PBC [,cutoff])<br/>USAGE in 1D<br/>[Vp,Xp] = PBCgrid(X,V,PBC [,cutoff])</p>
<p>INPUTS (3D):<br/>X: a x b x c array created by meshgrid, ndgrid coding for X coordinates<br/>Y: a x b x c array created by meshgrid, ndgrid coding for Y coordinates<br/>Z: a x b x c array created by meshgrid, ndgrid coding for Z coordinates<br/>V: a x b x c array where V(i,j,k) is the value at X(i,j,k), Y(i,j,k) and Z(i,j,k)<br/>PBC: 3 x 1 boolean array (true if the dimension is periodic)<br/>cutoff: cutoff value either scalar or vector<br/>[cutoff;cutoff;cutoff] or [cutoffx;cutoffy;cutoffz]</p>
<p>INPUTS (2D):<br/>X: a x b array created by meshgrid, ndgrid coding for X coordinates<br/>Y: a x b array created by meshgrid, ndgrid coding for Y coordinates<br/>V: a x b array where V(i,j) is the value at X(i,j) and Y(i,j)<br/>PBC: 2 x 1 boolean array (true if the dimension is periodic)<br/>cutoff: cutoff value either scalar or vector<br/>[cutoff;cutoff] or [cutoffx;cutoffy]</p>
<p>INPUTS (1D):<br/>X: a x 1 array created by linspace or equivalent<br/>V: a x 1 array where V(i) is the value at X(i)<br/>PBC: boolean (true if the dimension is periodic)<br/>cutoff: cutoff value</p>
<p>OUTPUTS (1-3D)<br/>Vp: array with ndims(Vp) = ndims(V) augmented with perodic values<br/>Xp,Yp,Zp corresponding coordinates</p>
<h2>See also</h2>
<p><a href="#PBCgridshift">PBCgridshift</a>, <a href="#PBCimages">PBCimages</a>, PBCimageschift, <a href="#PBCincell">PBCincell</a></p>
<h2>See also</h2>
<p></p>
<h2>See also</h2>
<p></p>
<h2>See also</h2>
<p></p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>[X,Y,V] = peaks(100);
[Vp,Xp,Yp] = PBCgrid(X,Y,V,[true,true],[1.5 3]);
figure, mesh(Xp,Yp,Vp)</code></pre>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [Vp,Xout,Yout,Zout] = PBCgrid(varargin)
<span class="comment">%PBCgrid add periodic boundary conditions to meshgrid/ndgrid meshed values</span>
<span class="comment">%</span>
<span class="comment">%   USAGE in 3D</span>
<span class="comment">%       [Vp,Xp,Yp,Zp] = PBCgrid(X,Y,Z,V,PBC [,cutoff])</span>
<span class="comment">%   USAGE in 2D</span>
<span class="comment">%       [Vp,Xp,Yp] = PBCgrid(X,Y,V,PBC [,cutoff])</span>
<span class="comment">%   USAGE in 1D</span>
<span class="comment">%       [Vp,Xp] = PBCgrid(X,V,PBC [,cutoff])</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS (3D):</span>
<span class="comment">%            X: a x b x c array created by meshgrid, ndgrid coding <span class="keyword">for</span> X coordinates</span>
<span class="comment">%            Y: a x b x c array created by meshgrid, ndgrid coding <span class="keyword">for</span> Y coordinates</span>
<span class="comment">%            Z: a x b x c array created by meshgrid, ndgrid coding <span class="keyword">for</span> Z coordinates</span>
<span class="comment">%            V: a x b x c array where V(i,j,k) is the value at X(i,j,k), Y(i,j,k) and Z(i,j,k)</span>
<span class="comment">%          PBC: 3 x 1 boolean array (true <span class="keyword">if</span> the dimension is periodic)</span>
<span class="comment">%       cutoff: cutoff value either scalar or vector</span>
<span class="comment">%               [cutoff;cutoff;cutoff] or [cutoffx;cutoffy;cutoffz]</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS (2D):</span>
<span class="comment">%            X: a x b array created by meshgrid, ndgrid coding <span class="keyword">for</span> X coordinates</span>
<span class="comment">%            Y: a x b array created by meshgrid, ndgrid coding <span class="keyword">for</span> Y coordinates</span>
<span class="comment">%            V: a x b array where V(i,j) is the value at X(i,j) and Y(i,j)</span>
<span class="comment">%          PBC: 2 x 1 boolean array (true <span class="keyword">if</span> the dimension is periodic)</span>
<span class="comment">%       cutoff: cutoff value either scalar or vector</span>
<span class="comment">%               [cutoff;cutoff] or [cutoffx;cutoffy]</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS (1D):</span>
<span class="comment">%            X: a x 1 array created by linspace or equivalent</span>
<span class="comment">%            V: a x 1 array where V(i) is the value at X(i)</span>
<span class="comment">%          PBC: boolean (true <span class="keyword">if</span> the dimension is periodic)</span>
<span class="comment">%       cutoff: cutoff value</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS (1-3D)</span>
<span class="comment">%           Vp: array with ndims(Vp) = ndims(V) augmented with perodic values</span>
<span class="comment">%           Xp,Yp,Zp corresponding coordinates</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: PBCgridshift, PBCimages, PBCimageschift, PBCincell</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% Example:</span>
<span class="comment">%      [X,Y,V] = peaks(100);</span>
<span class="comment">%      [Vp,Xp,Yp] = PBCgrid(X,Y,V,[true,true],[1.5 3]);</span>
<span class="comment">%      figure, mesh(Xp,Yp,Vp)</span>


<span class="comment">% MS 3.0 | 2024-03-15 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev. 2024-03-16</span>


<span class="comment">% Revision history</span>
<span class="comment">% 2024-03-15 release candidate with example</span>
<span class="comment">% 2024-03-16 fix nmirror when more than available points are required</span>


<span class="comment">%% check arguments</span>
<span class="keyword">if</span> nargin<3, error(<span class="string">'Syntax: [Vp,Xp,Yp,Zp] = PBCgrid(X,Y,Z,V,PBC [,cutoff]) in 3D (other syntaxes available)'</span>), <span class="keyword">end</span>
X = varargin{1};
d = ndims(X); <span class="comment">%<<- the number of dimensions in X sets 1D, 2D or 3D syntax</span>
<span class="keyword">if</span> d==3 && nargin<5, error(<span class="string">'five arguments are at least required in 3D:  [Vp,Xp,Yp,Zp] = PBCgrid(X,Y,Z,V,PBC [,cutoff])'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> d==2 && nargin<4, error(<span class="string">'four arguments are at least required in 2D:  [Vp,Xp,Yp] = PBCgrid(X,Y,V,PBC [,cutoff])'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> d>1
    Y = varargin{2};
    <span class="keyword">if</span> ~isequal(size(X),size(Y)), error(<span class="string">'X and Y are not compatible'</span>), <span class="keyword">end</span>
    <span class="keyword">if</span> d>2 <span class="comment">% 3D</span>
        Z = varargin{3};
        <span class="keyword">if</span> ~isequal(size(X),size(Z)), error(<span class="string">'X, Y and Z are not compatible'</span>), <span class="keyword">end</span>
        V = varargin{4};
        <span class="keyword">if</span> ~isequal(size(X),size(V)), error(<span class="string">'V is not compatible with supplied X, Y and Z'</span>), <span class="keyword">end</span>
        PBC = varargin{5};
        <span class="keyword">if</span> nargin>5, cutoff = varargin{6}; <span class="keyword">else</span> cutoff = []; <span class="keyword">end</span> <span class="comment">%#ok<*SEPEX></span>
    <span class="keyword">else</span> <span class="comment">% 2D</span>
        V = varargin{3};
        <span class="keyword">if</span> ~isequal(size(X),size(V)), error(<span class="string">'V is not compatible with supplied X and Y'</span>), <span class="keyword">end</span>
        PBC = varargin{4};
        <span class="keyword">if</span> nargin>4, cutoff = varargin{5}; <span class="keyword">else</span> cutoff = []; <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">else</span> <span class="comment">% 1D</span>
    V = varargin{2};
    <span class="keyword">if</span> ~isequal(size(X),size(V)), error(<span class="string">'V is not compatible with supplied X'</span>), <span class="keyword">end</span>
    PBC = varargin{3};
    <span class="keyword">if</span> nargin>3, cutoff = varargin{4}; <span class="keyword">else</span> cutoff = []; <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% fix PBC</span>
<span class="keyword">if</span> length(PBC)~=d, error(<span class="string">'PBC should be a <span class="comment">%dx1 boolean array'</span>,d), <span class="keyword">end</span></span>
PBC = PBC>0; <span class="comment">% convert to boolean</span>
<span class="comment">% fix cutoff (heuristic <span class="keyword">for</span> the default value)</span>
<span class="keyword">if</span> isempty(cutoff), cutoff = max(abs(X(1:2,1:2,1)-X(1,1,1)),[],<span class="string">'all'</span>)*(numel(X).^(1/d))/4; <span class="keyword">end</span>
<span class="keyword">if</span> length(cutoff)==1, cutoff = cutoff(ones(d,1)); <span class="keyword">end</span>
cutoff(~PBC) = 0;
<span class="comment">% discriminat between meshgrid or ndgrid generation</span>
<span class="keyword">if</span> d>1
    ismeshgrid =  all(diff(X(1:2,:,:),1,1)==0); <span class="comment">% true <span class="keyword">if</span> X,Y,Z generated with meshgrid</span>
<span class="keyword">else</span>
    ismeshgrid = false; <span class="comment">% by convention</span>
    X = X(:); <span class="comment">% force column-wise</span>
    V = V(:); <span class="comment">% force column-wise</span>
<span class="keyword">end</span>
<span class="comment">% Found bounds along X and Y (dependent on meshgrid or ndgrid generation)</span>
nmirror = zeros(d,1); <span class="comment">% number of values to mirror along each dimension</span>
<span class="keyword">if</span> ismeshgrid <span class="comment">% 2D or 3D</span>
    <span class="comment">% bounds</span>
    xmin = min(X(1,:,1));
    xmax = max(X(1,:,1));
    ymin = min(Y(:,1,1));
    ymax = max(Y(:,1,1));
    <span class="keyword">if</span> cutoff(1)>0
        ntmp = find(abs(X(1,:,1)-X(1,1,1))>cutoff(1),1,<span class="string">'first'</span>)-1;
        <span class="keyword">if</span> isempty(ntmp), nmirror(1) = size(X,2); <span class="keyword">else</span>, nmirror(1) = ntmp; <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> cutoff(2)>0
        ntmp = find(abs(Y(:,1,1)-Y(1,1,1))>cutoff(2),1,<span class="string">'first'</span>)-1;
        <span class="keyword">if</span> isempty(ntmp), nmirror(2) = size(X,1); <span class="keyword">else</span>, nmirror(2) = ntmp; <span class="keyword">end</span>
    <span class="keyword">end</span>
    dx = diff(X(1,:,1),1,2);
    dy = diff(Y(:,1,1),1,1);
<span class="keyword">else</span> <span class="comment">% ndgrid: 1D, 2D or 3D</span>
    xmin = min(X(:,1,:));
    xmax = max(X(:,1,:));
    <span class="keyword">if</span> cutoff(1)>0
        ntmp = find(abs(X(:,1,1)-X(1,1,1))>cutoff(1),1,<span class="string">'first'</span>)-1;
        <span class="keyword">if</span> isempty(ntmp), nmirror(1) = size(X,1); <span class="keyword">else</span>, nmirror(1) = ntmp; <span class="keyword">end</span>
    <span class="keyword">end</span>
    dx = diff(X(:,1,1),1,1);
    <span class="keyword">if</span> d>1
        ymin = min(Y(1,:,1));
        ymax = max(Y(1,:,1));
        <span class="keyword">if</span> cutoff(2)>0
            ntmp = find(abs(Y(1,:,1)-Y(1,1,1))>cutoff(2),1,<span class="string">'first'</span>)-1;
            <span class="keyword">if</span> isempty(ntmp), nmirror(2) = size(X,2); <span class="keyword">else</span>, nmirror(2) = ntmp; <span class="keyword">end</span>
        <span class="keyword">end</span>
        dy = diff(X(1,:,1),1,2);
    <span class="keyword">else</span>
        [ymin,ymax] = deal(NaN);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Found bounds along Z. Note that it is managed independently of ndgrid, meshgrid</span>
<span class="keyword">if</span> d>2 <span class="comment">%3D</span>
    zmin = min(Z(:,:,1));
    zmax = max(Z(:,:,1));
    <span class="keyword">if</span> cutoff(3)>0
        ntmp = find(abs(Z(:,:,1)-Z(1,1,1))>cutoff(3),1,<span class="string">'first'</span>)-1;
        <span class="keyword">if</span> isempty(ntmp), nmirror(3) = size(X,3); <span class="keyword">else</span>, nmirror(3) = ntmp; <span class="keyword">end</span>
    <span class="keyword">end</span>
    dz = diff(X(1,1,:),1,3);
<span class="keyword">else</span>
    [zmin,zmax] = deal(NaN);
<span class="keyword">end</span>
<span class="comment">% full bounds</span>
bounds = [xmin xmax; ymin ymax; zmin zmax]; <span class="comment">% NaN values <span class="keyword">for</span> non-defined dimensions</span>
dimensions = diff(bounds,1,2);

<span class="comment">%% apply PBC to V</span>
<span class="comment">% nmirror(1) -> number of points to translate along X (regardless the value of ismeshgrid)</span>
<span class="comment">% nmirror(2) -> number of points to translate along Y (idem)</span>
<span class="comment">% nmirror(3) -> number of points to translate along Z (idem)</span>
<span class="comment">% dimensions</span>
<span class="comment">% a = length of grid along Y (<span class="keyword">if</span> ismeshgrid), along X instead (ndgrid)</span>
<span class="comment">% b = length of grid along X (<span class="keyword">if</span> ismeshgrid), along Y instead (ndgrid)</span>
<span class="comment">% c = length of grid along Z</span>
[a,b,c] = size(X);
<span class="keyword">if</span> ismeshgrid <span class="comment">% 2D, 3D</span>
    left = (b-nmirror(1)+1):b;
    right = 1:nmirror(1);
    indx = [left, 1:b, right];
    top = (a-nmirror(2)+1):a;
    bottom = 1:nmirror(2);
    indy = [top, 1:a, bottom];
<span class="keyword">else</span> <span class="comment">% 1D, 2D, 3D</span>
    left = (a-nmirror(1)+1):a;
    right = 1:nmirror(1);
    indx = [left, 1:a, right];
    <span class="keyword">if</span> d>1
        top = (b-nmirror(2)+1):b;
        bottom = 1:nmirror(2);
        indy = [top, 1:b, bottom];
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> d>2
    front = (c-nmirror(3)+1):c;
    back = 1:nmirror(3);
    indz = [front, 1:c, back];
<span class="keyword">end</span>


<span class="comment">%% duplication and translation</span>
<span class="comment">% (note that dimensions and nmirror obey to the same convention independently of ismeshgrid)</span>
<span class="comment">% nmirror(1) and dimensions(1) are always along X, 2 <span class="keyword">for</span> Y and 3 <span class="keyword">for</span> Z</span>
<span class="keyword">if</span> ismeshgrid <span class="comment">% 2D and 3D</span>
    <span class="keyword">if</span> d==2
        Vp = V(indy,indx);
        Xp = X(indy,indx);
        Yp = Y(indy,indx);
    <span class="keyword">else</span>
        Vp = V(indy,indx,indz);
        Xp = X(indy,indx,indz);
        Yp = Y(indy,indx,indz);
        Zp = Y(indy,indx,indz);
    <span class="keyword">end</span>
    <span class="comment">% translation X and Y (Z common with ndgrid)</span>
    Xp(:,1:nmirror(1),:) = Xp(:,1:nmirror(1),:)-dimensions(1)-dx(<span class="keyword">end</span>); <span class="comment">% left translation</span>
    Xp(:,(<span class="keyword">end</span>-nmirror(1)+1):<span class="keyword">end</span>,:) = Xp(:,(<span class="keyword">end</span>-nmirror(1)+1):<span class="keyword">end</span>,:)+dimensions(1)+dx(1); <span class="comment">% right translation</span>
    Yp(1:nmirror(2),:,:) = Yp(1:nmirror(2),:)-dimensions(2)-dy(<span class="keyword">end</span>); <span class="comment">% top translation</span>
    Yp((<span class="keyword">end</span>-nmirror(2)+1):<span class="keyword">end</span>,:,:) = Yp((<span class="keyword">end</span>-nmirror(2)+1):<span class="keyword">end</span>,:,:)+dimensions(2)+dy(1); <span class="comment">% bottom translation   </span>
<span class="keyword">else</span> <span class="comment">% ndgrid in 1D, 2D and 3D</span>
    <span class="keyword">if</span> d==1
        Vp = V(indx);
        Xp = X(indx);
    <span class="keyword">elseif</span> d==2
        Vp = V(indx,indy);
        Xp = X(indx,indy);
        Yp = Y(indx,indy);
    <span class="keyword">else</span>
        Vp = V(indx,indy,indz);
        Xp = X(indx,indy,indz);
        Yp = Y(indx,indy,indz);
    <span class="keyword">end</span>
    Xp(1:nmirror(1),:,:) = Xp(1:nmirror(1),:,:)-dimensions(1)-dx(<span class="keyword">end</span>); <span class="comment">% left translation</span>
    Xp((<span class="keyword">end</span>-nmirror(1)+1):<span class="keyword">end</span>,:,:) = Xp((<span class="keyword">end</span>-nmirror(1)+1):<span class="keyword">end</span>,:,:)+dimensions(1)+dx(1); <span class="comment">% top translation</span>
    <span class="keyword">if</span> d>1
        Yp(:,1:nmirror(2),:) = Yp(:,1:nmirror(2),:)-dimensions(2)-dy(<span class="keyword">end</span>); <span class="comment">% top translation</span>
        Yp(:,(<span class="keyword">end</span>-nmirror(2)+1):<span class="keyword">end</span>,:) = Yp(:,(<span class="keyword">end</span>-nmirror(2)+1):<span class="keyword">end</span>,:)+dimensions(2)+dy(1); <span class="comment">% bottom translation</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> d>2
    Zp(:,:,1:nmirror(3)) = Zp(:,:,1:nmirror(3))-dimensions(3)-dz(<span class="keyword">end</span>); <span class="comment">% front translation</span>
    Zp(:,:,(<span class="keyword">end</span>-nmirror(3)+1):<span class="keyword">end</span>) = Zp(:,:,(<span class="keyword">end</span>-nmirror(3)+1):<span class="keyword">end</span>)+dimensions(3)+dz(1); <span class="comment">% back translation</span>
<span class="keyword">end</span>

<span class="comment">%% outputs</span>
<span class="keyword">if</span> nargout>1, Xout = Xp; <span class="keyword">end</span>
<span class="keyword">if</span> nargout>2 && d>1, Yout = Yp; <span class="keyword">end</span>
<span class="keyword">if</span> nargout>3 && d>2, Zout = Zp; <span class="keyword">end</span></code></pre></div>
</div>
<div id='PBCgridshift' class='doc-content' style='display: none;'>
<h1>PBCGRIDSHIFT shift meshgrid/ndgrid meshed values to a vector P assuming periodic boundary conditions</h1>
<p>and considering the grid created by either meshgrid or ndgrid.</p>
<p>USAGE in 3D<br/>[Vp,Xp,Yp,Zp] = PBCgrid(X,Y,Z,V,P)<br/>USAGE in 2D<br/>[Vp,Xp,Yp] = PBCgrid(X,Y,V,P)<br/>USAGE in 1D<br/>[Vp,Xp] = PBCgrid(X,V,P)</p>
<p>INPUTS (3D):<br/>X: a x b x c array created by meshgrid, ndgrid coding for X coordinates<br/>Y: a x b x c array created by meshgrid, ndgrid coding for Y coordinates<br/>Z: a x b x c array created by meshgrid, ndgrid coding for Z coordinates<br/>V: a x b x c array where V(i,j,k) is the value at X(i,j,k), Y(i,j,k) and Z(i,j,k)<br/>P: 3 x 1 shift vector (units in grid step)<br/>P(1) is the shift along x, P(2) along y, P(3) along z</p>
<p>INPUTS (2D):<br/>X: a x b array created by meshgrid, ndgrid coding for X coordinates<br/>Y: a x b array created by meshgrid, ndgrid coding for Y coordinates<br/>V: a x b array where V(i,j) is the value at X(i,j) and Y(i,j)<br/>P: 2 x 1 shift vector (units in grid step)<br/>P(1) is the shift along x, P(2) along y</p>
<p>INPUTS (1D):<br/>X: a x 1 array created by linspace or equivalent<br/>V: a x 1 array where V(i) is the value at X(i)<br/>P: scalar shift (units in grid step)</p>
<p>OUTPUTS (1-3D)<br/>Vp: array of the same size as V<br/>Xp,Yp,Zp corresponding coordinates (with proper translation)<br/>preserving the nature of the grid (ndgrid or meshgrid)</p>
<p>Note1: an error is returned if X,Y,Z are not generated by meshgrid or ndgrid<br/>Note2: This function assumes a uniform grid</p>
<h2>See also</h2>
<p><a href="#PBCgrid">PBCgrid</a>, <a href="#PBCimages">PBCimages</a>, PBCimageschift, <a href="#PBCincell">PBCincell</a></p>
<h2>See also</h2>
<p></p>
<h2>See also</h2>
<p></p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>[X,Y,V] = peaks(100);
[Vp,Xp,Yp] = PBCgridshift(X,Y,V,[10 20]);
figure, mesh(Xp,Yp,Vp)</code></pre>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [Vp,varargout] = PBCgridshift(varargin)
<span class="comment">%PBCGRIDSHIFT shift meshgrid/ndgrid meshed values to a vector P assuming periodic boundary conditions</span>
<span class="comment">%             and considering the grid created by either meshgrid or ndgrid.</span>
<span class="comment">%</span>
<span class="comment">%   USAGE in 3D</span>
<span class="comment">%       [Vp,Xp,Yp,Zp] = PBCgrid(X,Y,Z,V,P)</span>
<span class="comment">%   USAGE in 2D</span>
<span class="comment">%       [Vp,Xp,Yp] = PBCgrid(X,Y,V,P)</span>
<span class="comment">%   USAGE in 1D</span>
<span class="comment">%       [Vp,Xp] = PBCgrid(X,V,P)</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS (3D):</span>
<span class="comment">%            X: a x b x c array created by meshgrid, ndgrid coding <span class="keyword">for</span> X coordinates</span>
<span class="comment">%            Y: a x b x c array created by meshgrid, ndgrid coding <span class="keyword">for</span> Y coordinates</span>
<span class="comment">%            Z: a x b x c array created by meshgrid, ndgrid coding <span class="keyword">for</span> Z coordinates</span>
<span class="comment">%            V: a x b x c array where V(i,j,k) is the value at X(i,j,k), Y(i,j,k) and Z(i,j,k)</span>
<span class="comment">%            P: 3 x 1 shift vector (units in grid step)</span>
<span class="comment">%               P(1) is the shift along x, P(2) along y, P(3) along z</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS (2D):</span>
<span class="comment">%            X: a x b array created by meshgrid, ndgrid coding <span class="keyword">for</span> X coordinates</span>
<span class="comment">%            Y: a x b array created by meshgrid, ndgrid coding <span class="keyword">for</span> Y coordinates</span>
<span class="comment">%            V: a x b array where V(i,j) is the value at X(i,j) and Y(i,j)</span>
<span class="comment">%            P: 2 x 1 shift vector (units in grid step)</span>
<span class="comment">%               P(1) is the shift along x, P(2) along y</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS (1D):</span>
<span class="comment">%            X: a x 1 array created by linspace or equivalent</span>
<span class="comment">%            V: a x 1 array where V(i) is the value at X(i)</span>
<span class="comment">%            P: scalar shift (units in grid step)</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS (1-3D)</span>
<span class="comment">%           Vp: array of the same size as V</span>
<span class="comment">%           Xp,Yp,Zp corresponding coordinates (with proper translation)</span>
<span class="comment">%           preserving the nature of the grid (ndgrid or meshgrid)</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   Note1: an error is returned <span class="keyword">if</span> X,Y,Z are not generated by meshgrid or ndgrid</span>
<span class="comment">%   Note2: This <span class="keyword">function</span> assumes a uniform grid</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: PBCgrid, PBCimages, PBCimageschift, PBCincell</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% Example:</span>
<span class="comment">%      [X,Y,V] = peaks(100);</span>
<span class="comment">%      [Vp,Xp,Yp] = PBCgridshift(X,Y,V,[10 20]);</span>
<span class="comment">%      figure, mesh(Xp,Yp,Vp)</span>



<span class="comment">% MS 3.0 | 2024-03-24 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev.</span>


<span class="comment">% Revision history</span>



<span class="comment">% Determine the number of dimensions and validate input</span>
X = varargin{1};
d = ndims(X); <span class="comment">%<<- the number of dimensions in X sets 1D, 2D or 3D syntax</span>
<span class="keyword">if</span> d>3, error(<span class="string">'the number of dimensions should be 1,2,3'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> d==3 && nargin<5, error(<span class="string">'five arguments are at least required in 3D:  [Vp,Xp,Yp,Zp] = PBCgridshift(X,Y,Z,V,P)'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> d==2 && nargin<4, error(<span class="string">'four arguments are at least required in 2D:  [Vp,Xp,Yp] = PBCgridshift(X,Y,V,P)'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> d>1
    Y = varargin{2};
    <span class="keyword">if</span> ~isequal(size(X),size(Y)), error(<span class="string">'X and Y are not compatible'</span>), <span class="keyword">end</span>
    <span class="keyword">if</span> d>2 <span class="comment">% 3D</span>
        Z = varargin{3};
        <span class="keyword">if</span> ~isequal(size(X),size(Z)), error(<span class="string">'X, Y and Z are not compatible'</span>), <span class="keyword">end</span>
        V = varargin{4};
        <span class="keyword">if</span> ~isequal(size(X),size(V)), error(<span class="string">'V is not compatible with supplied X, Y and Z'</span>), <span class="keyword">end</span>
        P = varargin{5};
        <span class="keyword">if</span> nargin>5, error(<span class="string">'4 arguments in 3D'</span>), <span class="keyword">end</span>
        deltaZ = Z(1,1,2) - Z(1,1,1);
    <span class="keyword">else</span> <span class="comment">% 2D</span>
        V = varargin{3};
        <span class="keyword">if</span> ~isequal(size(X),size(V)), error(<span class="string">'V is not compatible with supplied X and Y'</span>), <span class="keyword">end</span>
        P = varargin{4};
        <span class="keyword">if</span> nargin>4, error(<span class="string">'4 arguments in 2D'</span>), <span class="keyword">end</span>
    <span class="keyword">end</span>
    isMesh = X(1,1,:) == X(2,1,:);
    <span class="keyword">if</span> isMesh
        deltaX = X(1,2,1) - X(1,1,1);
        deltaY = Y(2,1,1) - Y(1,1,1);
    <span class="keyword">else</span> <span class="comment">% ndgrid</span>
        deltaX = X(2,1,1) - X(1,1,1);
        deltaY = Y(1,2,1) - Y(1,1,1);
    <span class="keyword">end</span>
<span class="keyword">else</span> <span class="comment">% 1D</span>
    V = varargin{2};
    <span class="keyword">if</span> ~isequal(size(X),size(V)), error(<span class="string">'V is not compatible with supplied X'</span>), <span class="keyword">end</span>
    P = varargin{3};
    <span class="keyword">if</span> nargin>3, error(<span class="string">'3 arguments in 2D'</span>), <span class="keyword">end</span>
    isMesh = false; <span class="comment">% 1D grid doesn<span class="string">'t require meshgrid/ndgrid distinction</span>
    deltaX = X(2)-X(1);
<span class="keyword">end</span>


<span class="comment">% Translate Xp,Yp,Zp</span>
varargout{1} = X + P(1) * deltaX;
<span class="keyword">if</span> d>1,  varargout{2} = Y + P(2) * deltaY; <span class="keyword">end</span>
<span class="keyword">if</span> d==3, varargout{3} = Z + P(3) * deltaZ; <span class="keyword">end</span>

<span class="comment">% Apply periodic boundary condition shift based on the dimensionality</span>
<span class="keyword">switch</span> d
    <span class="keyword">case</span> 1
        shift = mod((0:numel(X)-1) + P(1), numel(X)) + 1;
        Vp = V(shift);

    <span class="keyword">case</span> 2
        [rows, cols] = size(X);
        <span class="keyword">if</span> isMesh
            rShift = mod((0:rows-1)'</span> + P(2), rows) + 1;
            cShift = mod((0:cols-1) + P(1), cols) + 1;
            Vp = V(rShift, cShift);
        <span class="keyword">else</span>
            rShift = mod((0:rows-1)<span class="string">' + P(1), rows) + 1;
            cShift = mod((0:cols-1) + P(2), cols) + 1;
            Vp = V(cShift, rShift);
        <span class="keyword">end</span>

    <span class="keyword">case</span> 3
        [rows, cols, pages] = size(X);
        zShift = mod((0:pages-1) + P(3), pages) + 1;

        <span class="keyword">if</span> isMesh
            rShift = mod((0:rows-1)'</span> + P(2), rows) + 1;
            cShift = mod((0:cols-1) + P(1), cols) + 1;
            Vp = V(rShift, cShift, zShift);
        <span class="keyword">else</span>
            rShift = mod((0:rows-1)' + P(1), rows) + 1;
            cShift = mod((0:cols-1) + P(2), cols) + 1;
            Vp = V(cShift, rShift, zShift);
        <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='PBCimages' class='doc-content' style='display: none;'>
<h1>PBCIMAGES return the coordinates of fictive particle images outside box limits along periodic boundary dimensions</h1>
<p>USAGE: Ximages = PBCimages(X,box,PBC [,cutoff])<br/>[Ximages,indX,copyIdx] = PBCimages(...)</p>
<p>INPUTS:<br/>X: nx2 or nx3 array coding for the coordinates of the n particles in 2D and 3D, respectively<br/>box: 2x2 or 3x2 array coding for box dimensions<br/>the box spans along dimension i between box(i,1) and box(i,2)<br/>all X values should lie within box limits, if not an error is generated<br/>PBC: 1x2 or 1x3 boolean array<br/>PBC(i) is true if the dimension i is periodic<br/>cutoff: scalar or 1xd array with d the number of dimensions (2 or 3)<br/>setting the cutoff distance beyond bounds to include fictive images<br/>if cutoff is a scalar, it is redefined as cutoff(ones(1,d))<br/>cutoff(i) is applied along dimension i</p>
<p>OUTPUTS:<br/>Ximages: mx2 or mx3 array coding for the coordinates of the m particle images in 2D and 3D, respectively<br/>indX: corresponding indices of images in X<br/>copyIdx: indices of the copies of each atom created (starting from 1)</p>
<h2>See also</h2>
<p><a href="#PBCgrid">PBCgrid</a>, <a href="#PBCgridshift">PBCgridshift</a>, PBCimageschift, <a href="#PBCincell">PBCincell</a></p>
<h2>See also</h2>
<p></p>
<h2>See also</h2>
<p>NOTE, about, copyIdx, and, its, values, (2D:, maximum, value, =, 5, 3D:, maximum, value, =, 26)</p>
<h2>See also</h2>
<p>In, 2D., Each, dimension, can, generate, two, types, of, images:, lower, and, upper, images., If, both, dimensions, are, periodic:, there, are, additional, corner, images., Lower, images, for, dimension, 1:, copyIdx, =, 1, Upper, images, for, dimension, 1:, copyIdx, =, 2, Lower, images, for, dimension, 2:, copyIdx, =, 3, Upper, images, for, dimension, 2:, copyIdx, =, 4, Corner, images, (4, possible, combinations):, copyIdx, =, 5, In, 3D., If, all, three, dimensions, are, periodic:, there, are, additional, corner, images., If, at, least, two, dimensions, are, periodic:, there, are, additional, edge, images., Lower, images, for, dimension, 1:, copyIdx, =, 1, Upper, images, for, dimension, 1:, copyIdx, =, 2, Lower, images, for, dimension, 2:, copyIdx, =, 3, Upper, images, for, dimension, 2:, copyIdx, =, 4, Lower, images, for, dimension, 3:, copyIdx, =, 5, Upper, images, for, dimension, 3:, copyIdx, =, 6, Edge, images, (12, possible, combinations):, copyIdx, =, 7, 8, ..., 18, Corner, images, (8, possible, combinations):, copyIdx, =, 19, 20, ..., 26</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [Ximages,indXout,copyIdx] = PBCimages(X,box,PBC,cutoff)
<span class="comment">%PBCIMAGES <span class="keyword">return</span> the coordinates of fictive particle images outside box limits along periodic boundary dimensions</span>
<span class="comment">%</span>
<span class="comment">%   USAGE: Ximages = PBCimages(X,box,PBC [,cutoff])</span>
<span class="comment">%          [Ximages,indX,copyIdx] = PBCimages(...)</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%          X: nx2 or nx3 array coding <span class="keyword">for</span> the coordinates of the n particles in 2D and 3D, respectively</span>
<span class="comment">%        box: 2x2 or 3x2 array coding <span class="keyword">for</span> box dimensions</span>
<span class="comment">%             the box spans along dimension i between box(i,1) and box(i,2)</span>
<span class="comment">%             all X values should lie within box limits, <span class="keyword">if</span> not an error is generated</span>
<span class="comment">%        PBC: 1x2 or 1x3 boolean array</span>
<span class="comment">%             PBC(i) is true <span class="keyword">if</span> the dimension i is periodic</span>
<span class="comment">%     cutoff: scalar or 1xd array with d the number of dimensions (2 or 3)</span>
<span class="comment">%             setting the cutoff distance beyond bounds to include fictive images</span>
<span class="comment">%             <span class="keyword">if</span> cutoff is a scalar, it is redefined as cutoff(ones(1,d))</span>
<span class="comment">%             cutoff(i) is applied along dimension i</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%    Ximages: mx2 or mx3 array coding <span class="keyword">for</span> the coordinates of the m particle images in 2D and 3D, respectively</span>
<span class="comment">%       indX: corresponding indices of images in X</span>
<span class="comment">%    copyIdx: indices of the copies of each atom created (starting from 1)</span>
<span class="comment">%</span>
<span class="comment">%   See also: PBCgrid, PBCgridshift, PBCimageschift, PBCincell</span>
<span class="comment">%</span>
<span class="comment">% </span>
<span class="comment">%  NOTE about copyIdx and its values (2D: maximum value = 5, 3D: maximum value = 26)</span>
<span class="comment">% </span>
<span class="comment">% In 2D.   Each dimension can generate two types of images: lower and upper images.</span>
<span class="comment">%          If both dimensions are periodic: there are additional corner images.</span>
<span class="comment">%               Lower images <span class="keyword">for</span> dimension 1: copyIdx = 1</span>
<span class="comment">%               Upper images <span class="keyword">for</span> dimension 1: copyIdx = 2</span>
<span class="comment">%               Lower images <span class="keyword">for</span> dimension 2: copyIdx = 3</span>
<span class="comment">%               Upper images <span class="keyword">for</span> dimension 2: copyIdx = 4</span>
<span class="comment">%               Corner images (4 possible combinations): copyIdx = 5</span>
<span class="comment">% In 3D.   If all three dimensions are periodic: there are additional corner images.</span>
<span class="comment">%          If at least two dimensions are periodic: there are additional edge images.</span>
<span class="comment">%               Lower images <span class="keyword">for</span> dimension 1: copyIdx = 1</span>
<span class="comment">%               Upper images <span class="keyword">for</span> dimension 1: copyIdx = 2</span>
<span class="comment">%               Lower images <span class="keyword">for</span> dimension 2: copyIdx = 3</span>
<span class="comment">%               Upper images <span class="keyword">for</span> dimension 2: copyIdx = 4</span>
<span class="comment">%               Lower images <span class="keyword">for</span> dimension 3: copyIdx = 5</span>
<span class="comment">%               Upper images <span class="keyword">for</span> dimension 3: copyIdx = 6</span>
<span class="comment">%               Edge images (12 possible combinations): copyIdx = 7, 8, ..., 18</span>
<span class="comment">%               Corner images (8 possible combinations): copyIdx = 19, 20, ..., 26</span>


<span class="comment">% Full example in 2D</span>
<span class="comment">%{</span>
    <span class="comment">% Parameters</span>
    n_particles = 10000;
    box = [0 10; 0 10]; <span class="comment">% Box limits <span class="keyword">for</span> 2D</span>
    PBC = [true, true]; <span class="comment">% Periodic boundary conditions in both dimensions</span>
    cutoff = 3.0; <span class="comment">% Cutoff distance</span>
    
    <span class="comment">% Generate random particles within the box</span>
    X = rand(n_particles, 2) .* (box(:,2) - box(:,1))<span class="string">' + box(:,1)'</span>;
    
    <span class="comment">% Calculate fictive images</span>
    [Ximages, indX, copyIdx] = PBCimages(X, box, PBC, cutoff);
    
    <span class="comment">% Plotting</span>
    figure, hold on
    plot(X(:,1), X(:,2), <span class="string">'k.'</span>, <span class="string">'MarkerSize'</span>, 15); <span class="comment">% Original particles in black</span>
    
    <span class="comment">% Define a colormap <span class="keyword">for</span> different copyIdx values</span>
    colormap = lines(max(copyIdx));
    <span class="keyword">for</span> i = 1:max(copyIdx)
        idx = (copyIdx == i);
        plot(Ximages(idx,1), Ximages(idx,2), <span class="string">'.'</span>, <span class="string">'MarkerSize'</span>, 15, <span class="string">'Color'</span>, colormap(i, :)); <span class="comment">% Images with different colors</span>
    <span class="keyword">end</span>
    
    xlim([box(1,1) - 2*cutoff, box(1,2) + 2*cutoff]);
    ylim([box(2,1) - 2*cutoff, box(2,2) + 2*cutoff]);
    xlabel(<span class="string">'X'</span>);
    ylabel(<span class="string">'Y'</span>);
    title(<span class="string">'Original Particles and Their Fictive Images'</span>);
    
    <span class="comment">% Create legend</span>
    legendEntries = arrayfun(@(i) sprintf(<span class="string">'Copy <span class="comment">%d'</span>, i), 1:max(copyIdx), <span class="string">'UniformOutput'</span>, false);</span>
    legend([<span class="string">'Original Particles'</span>, legendEntries]);
    
    grid on, axis equal

<span class="comment">%}</span>

<span class="comment">% Full example in 3D</span>
<span class="comment">%{</span>
    <span class="comment">% Parameters</span>
    n_particles = 10000;
    box = [0 10; 0 10; 0 10]; <span class="comment">% Box limits <span class="keyword">for</span> 3D</span>
    PBC = [true, true, true]; <span class="comment">% Periodic boundary conditions in all dimensions</span>
    cutoff = 3.0; <span class="comment">% Cutoff distance</span>
    
    <span class="comment">% Generate random particles within the box</span>
    X = rand(n_particles, 3) .* (box(:,2) - box(:,1))<span class="string">' + box(:,1)'</span>;
    
    <span class="comment">% Calculate fictive images</span>
    [Ximages, indX, copyIdx] = PBCimages(X, box, PBC, cutoff);
    
    <span class="comment">% Plotting</span>
    figure, hold on
    plot3(X(:,1), X(:,2), X(:,3), <span class="string">'k.'</span>, <span class="string">'MarkerSize'</span>, 15); <span class="comment">% Original particles in black</span>
    
    <span class="comment">% Define a colormap <span class="keyword">for</span> different copyIdx values</span>
    <span class="comment">%colormap = lines(max(copyIdx));</span>
    <span class="comment">% Define a more diverse set of colors (compact definition)</span>
    colormap = [0, 0, 1; 0, 1, 0; 1, 0, 0; 0, 1, 1; 1, 0, 1; 1, 1, 0;
            0.5, 0, 0; 0, 0.5, 0; 0, 0, 0.5; 0.5, 0.5, 0; 0.5, 0, 0.5;
            0, 0.5, 0.5; 0.75, 0.25, 0.25; 0.25, 0.75, 0.25; 0.25, 0.25, 0.75;
            0.75, 0.75, 0.25; 0.75, 0.25, 0.75; 0.25, 0.75, 0.75; 0.5, 0.5, 0.5;
            0.75, 0.75, 0.75; 0.25, 0.25, 0.25; 1, 0.5, 0; 0, 1, 0.5;
            0.5, 0, 1; 0, 0.5, 1; 1, 0, 0.5];
    <span class="keyword">for</span> i = 1:max(copyIdx)
        idx = (copyIdx == i);
        plot3(Ximages(idx,1), Ximages(idx,2), Ximages(idx,3), <span class="string">'.'</span>, <span class="string">'MarkerSize'</span>, 15, <span class="string">'Color'</span>, colormap(i, :)); <span class="comment">% Images with different colors</span>
    <span class="keyword">end</span>
    
    xlim([box(1,1) - 2*cutoff, box(1,2) + 2*cutoff]);
    ylim([box(2,1) - 2*cutoff, box(2,2) + 2*cutoff]);
    zlim([box(3,1) - 2*cutoff, box(3,2) + 2*cutoff]);
    xlabel(<span class="string">'X'</span>); ylabel(<span class="string">'Y'</span>); zlabel(<span class="string">'Z'</span>);
    title(<span class="string">'Original Particles and Their Fictive Images'</span>);
    
    <span class="comment">% Create legend</span>
    legendEntries = arrayfun(@(i) sprintf(<span class="string">'Copy <span class="comment">%d'</span>, i), 1:max(copyIdx), <span class="string">'UniformOutput'</span>, false);</span>
    legend([<span class="string">'Original Particles'</span>, legendEntries]);
    
    grid on;
    hold off;
    axis equal;
    view(3);

<span class="comment">%}</span>


<span class="comment">% MS 3.0 | 2024-03-15 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev. 2024-07-16</span>


<span class="comment">% Revision history</span>
<span class="comment">% 2024-03-15 release candidate with examples in 2D and 3D</span>
<span class="comment">% 2024-03-16 <span class="keyword">return</span> indX, advise using PBCincell <span class="keyword">if</span> particles outside are detected</span>
<span class="comment">% 2024-07-16 add copyIdx and extend 2D and 3D examples to exemplify all copy possibilities</span>

<span class="comment">%% Check arguments</span>
<span class="keyword">if</span> nargin<3, error(<span class="string">'Not enough input arguments. Syntax: Ximages = PBCimages(X,box,PBC [,cutoff])'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, cutoff = []; <span class="keyword">end</span>
[n,d] = size(X); <span class="comment">% Number of particles and dimensions</span>
<span class="keyword">if</span> d>3, error(<span class="string">'the number of dimensions should be 1,2,3'</span>), <span class="keyword">end</span>
Xmin = min(X);
Xmax = max(X);
<span class="keyword">if</span> isempty(cutoff), cutoff = 0.1*(Xmax-Xmin); <span class="keyword">end</span> <span class="comment">% heuristic default value</span>
<span class="keyword">if</span> length(cutoff)==1, cutoff = cutoff(ones(1,d)); <span class="keyword">end</span>
<span class="keyword">if</span> length(cutoff)~=d, error(<span class="string">'cutoff must be a scalar or 1x<span class="comment">%d vector'</span>,d); <span class="keyword">end</span></span>
<span class="keyword">if</span> size(box,2)~=2 || size(box,1)~=d, error(<span class="string">'Box dimensions must be a <span class="comment">%dx2 vector'</span>,d); <span class="keyword">end</span></span>
boxlength = diff(box, 1, 2);
<span class="keyword">if</span> length(PBC)~=d; error(<span class="string">'PBC must be a 1x<span class="comment">%d logical vector'</span>,d), <span class="keyword">end</span></span>
PBC = PBC>0;

<span class="comment">%% Check that all points lie within the box</span>
incellok = true;
<span class="keyword">for</span> i=1:d
    <span class="keyword">if</span> box(i,1)>Xmin(i)
        dispf(<span class="string">'some particles are outside the lower bound <span class="comment">%0.3g along dimension %d'</span>,box(i,1),i)</span>
        incellok = false;
    <span class="keyword">end</span>
    <span class="keyword">if</span> box(i,2)<Xmax(i)
        dispf(<span class="string">'some particles are outside the upper bound <span class="comment">%0.3g along dimension %d'</span>,box(i,2),i),</span>
        incellok = false;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~incellok
    disp(<span class="string">'use: X = PBCincell(X,box,PBC) to wrap particles around coordinates'</span>)
    error(<span class="string">'PBCimages: some particles outside the box...'</span>)
<span class="keyword">end</span>

<span class="comment">%% Initialize empty array <span class="keyword">for</span> images</span>
[Ximages,indX,copyIdx] = deal([]);
copyCounter = 0; <span class="comment">% Counter to track the number of copies</span>

<span class="comment">%% Generate images <span class="keyword">for</span> each dimension independently</span>
<span class="keyword">for</span> i = 1:d
    <span class="keyword">if</span> PBC(i)
        lowerBound = box(i,1);
        upperBound = box(i,2);

        <span class="comment">% Lower and upper images</span>
        islowerImages = X(:, i) < (lowerBound + cutoff(i));
        lowerImages = X(islowerImages, :);
        lowerImages(:, i) = lowerImages(:, i) + (upperBound - lowerBound);

        isupperimages = X(:, i) > (upperBound - cutoff(i));
        upperImages = X(isupperimages, :);
        upperImages(:, i) = upperImages(:, i) - (upperBound - lowerBound);

        Ximages = [Ximages; lowerImages; upperImages]; <span class="comment">%#ok<AGROW></span>
        indX = [indX; find(islowerImages); find(isupperimages)]; <span class="comment">%#ok<AGROW></span>
        copyIdx = [copyIdx; repmat(copyCounter+1, sum(islowerImages), 1); repmat(copyCounter+2, sum(isupperimages), 1)]; <span class="comment">%#ok<AGROW></span>
        copyCounter = copyCounter + 2; <span class="comment">% Update the copy counter</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% Generate corner images <span class="keyword">if</span> all dimensions are periodic</span>
<span class="keyword">if</span> all(PBC)
    <span class="comment">% Find all combinations <span class="keyword">for</span> corners</span>
    <span class="keyword">if</span> d==2
        [x,y]=meshgrid([0 1],[0 1]);
        corners = [x(:) y(:)];
    <span class="keyword">elseif</span> d==3
        [x,y,z]=meshgrid([0 1],[0 1],[0 1]);
        corners = [x(:) y(:) z(:)];
    <span class="keyword">end</span>    
    <span class="keyword">for</span> i = 1:size(corners, 1) <span class="comment">% 4 (in 2D), 8 (in 3D)</span>
        cornerCond = true(n, 1);
        cornerImages = X;
        <span class="keyword">for</span> j = 1:d
            <span class="keyword">if</span> corners(i,j) == 0
                <span class="comment">% Lower corner images</span>
                thisCorner = X(:,j) < (box(j,1) + cutoff(j));
                cornerImages(thisCorner,j) = cornerImages(thisCorner,j) + boxlength(j);
            <span class="keyword">else</span>
                <span class="comment">% Upper corner images</span>
                thisCorner = X(:,j) > (box(j,2) - cutoff(j));
                cornerImages(thisCorner,j) = cornerImages(thisCorner,j) - boxlength(j);
            <span class="keyword">end</span>
            cornerCond = cornerCond & thisCorner;
        <span class="keyword">end</span>
        <span class="comment">% Add corner images <span class="keyword">if</span> any particles satisfy the corner condition</span>
        <span class="keyword">if</span> any(cornerCond)
            Ximages = [Ximages; cornerImages(cornerCond, :)]; <span class="comment">%#ok<AGROW></span>
            indX = [indX; find(cornerCond)]; <span class="comment">%#ok<AGROW></span>
            copyIdx = [copyIdx; repmat(copyCounter+1, sum(cornerCond), 1)]; <span class="comment">%#ok<AGROW></span>
            copyCounter = copyCounter + 1; <span class="comment">% Update the copy counter</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% Generate edge images <span class="keyword">if</span> two dimensions are at least periodic in 3D</span>
<span class="keyword">if</span> (d==3) && (sum(PBC)>1)
    dvalid = find(PBC);
    [x,y] = meshgrid(dvalid,dvalid); ok = (x<y);
    dimforedges = [x(ok) y(ok)]; <span class="comment">% dimension pairs (with x<y)</span>
    [x,y]=meshgrid([0 1],[0 1]);
    edges = [x(:) y(:)]; <span class="comment">% edge pairs</span>
    
    <span class="keyword">for</span> k = 1:size(dimforedges,1) <span class="comment">% number of dimension pairs (max 3)</span>
        <span class="keyword">for</span> i = 1:size(edges, 1)  <span class="comment">% number of lower/upper edges (4) ==> 3x4 = 12 edges at maximum</span>
            edgeCond = true(n, 1);
            edgeImages = X;
            <span class="keyword">for</span> j = 1:2 <span class="comment">% <span class="keyword">for</span> edges in 3D (2 dimensions only)</span>
                jdim = dimforedges(k,j);
                <span class="keyword">if</span> edges(i,j) == 0
                    <span class="comment">% Lower edge images</span>
                    thisEdge = X(:,jdim) < (box(jdim,1) + cutoff(jdim));
                    edgeImages(thisEdge,jdim) = edgeImages(thisEdge,jdim) + boxlength(jdim);
                <span class="keyword">else</span>
                    <span class="comment">% Upper edge images</span>
                    thisEdge = X(:,jdim) > (box(jdim,2) - cutoff(jdim));
                    edgeImages(thisEdge,jdim) = edgeImages(thisEdge,jdim) - boxlength(jdim);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            edgeCond = edgeCond & thisEdge;
            <span class="comment">% Add edge images <span class="keyword">if</span> any particles satisfy the edge condition</span>
            <span class="keyword">if</span> any(edgeCond)
                Ximages = [Ximages; edgeImages(edgeCond, :)]; <span class="comment">%#ok<AGROW></span>
                indX = [indX; find(edgeCond)]; <span class="comment">%#ok<AGROW></span>
                copyIdx = [copyIdx; repmat(copyCounter+1, sum(edgeCond), 1)]; <span class="comment">%#ok<AGROW></span>
                copyCounter = copyCounter + 1; <span class="comment">% Update the copy counter</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% Removing duplicates <span class="keyword">if</span> any</span>
[Ximages,iXuniq] = unique(Ximages, <span class="string">'rows'</span>);
indX = indX(iXuniq);
copyIdx = copyIdx(iXuniq);

<span class="comment">% output</span>
<span class="keyword">if</span> nargout>1, indXout = indX; <span class="keyword">end</span>
<span class="keyword">if</span> nargout>2, copyIdx = copyIdx; <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">%% --- version before 2024-08-16</span>
<span class="comment">% <span class="keyword">function</span> [Ximages,indXout] = PBCimages(X,box,PBC,cutoff)</span>
<span class="comment">% %PBCIMAGES <span class="keyword">return</span> the coordinates of fictive particle images outside box limits along periodic boundary dimensions</span>
<span class="comment">% %</span>
<span class="comment">% %   USAGE: Ximages = PBCimages(X,box,PBC [,cutoff])</span>
<span class="comment">% %          [Ximages,indX] = PBCimages(...)</span>
<span class="comment">% %</span>
<span class="comment">% %   INPUTS:</span>
<span class="comment">% %          X: nx2 or nx3 array coding <span class="keyword">for</span> the coordinates of the n particles in 2D and 3D, respectively</span>
<span class="comment">% %        box: 2x2 or 3x2 array coding <span class="keyword">for</span> box dimensions</span>
<span class="comment">% %             the box spans along dimension i between box(i,1) and box(i,2)</span>
<span class="comment">% %             all X values should lie within box limits, <span class="keyword">if</span> not an error ois generated</span>
<span class="comment">% %        PBC: 1x2 or 1x3 boolean array</span>
<span class="comment">% %             PBC(i) is true <span class="keyword">if</span> the dimension i is periodic</span>
<span class="comment">% %     cutoff: scalar or 1xd array with d the number of dimensions (2 or 3)</span>
<span class="comment">% %             setting the cutoff distance beyond bounds to include fictive images</span>
<span class="comment">% %             <span class="keyword">if</span> cutoff is a scalar, it is refedined as cutoff(ones(1,d))</span>
<span class="comment">% %             cutoff(i) is applied along dimension i</span>
<span class="comment">% %</span>
<span class="comment">% %   OUTPUTS:</span>
<span class="comment">% %    Ximages: mx2 or mx3 array coding <span class="keyword">for</span> the coordinates of the m particle images in 2D and 3D, respectively</span>
<span class="comment">% %       indX: corresponding indices of images in X</span>
<span class="comment">% %</span>
<span class="comment">% %</span>
<span class="comment">% %   See also: PBCgrid, PBCgridshift, PBCimageschift, PBCincell</span>
<span class="comment">% %</span>
<span class="comment">% </span>
<span class="comment">% % Full example in 2D</span>
<span class="comment">% %{</span>
<span class="comment">%     % Parameters</span>
<span class="comment">%     n_particles = 10000;</span>
<span class="comment">%     box = [0 10; 0 10]; % Box limits <span class="keyword">for</span> 2D</span>
<span class="comment">%     PBC = [true, true]; % Periodic boundary conditions in both dimensions</span>
<span class="comment">%     cutoff = 3.0; % Cutoff distance</span>
<span class="comment">% </span>
<span class="comment">%     % Generate random particles within the box</span>
<span class="comment">%     X = rand(n_particles, 2) .* (box(:,2) - box(:,1))<span class="string">' + box(:,1)'</span>;</span>
<span class="comment">% </span>
<span class="comment">%     % Calculate fictive images</span>
<span class="comment">%     Ximages = PBCimages(X, box, PBC, cutoff);</span>
<span class="comment">% </span>
<span class="comment">%     % Plotting</span>
<span class="comment">%     figure, hold on</span>
<span class="comment">%     plot(X(:,1), X(:,2), <span class="string">'g.'</span>, <span class="string">'MarkerSize'</span>, 15); % Original particles in green</span>
<span class="comment">%     <span class="keyword">if</span> ~isempty(Ximages)</span>
<span class="comment">%         plot(Ximages(:,1), Ximages(:,2), <span class="string">'b.'</span>, <span class="string">'MarkerSize'</span>, 15); % Images in blue</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">%     xlim([box(1,1) - 2*cutoff, box(1,2) + 2*cutoff]);</span>
<span class="comment">%     ylim([box(2,1) - 2*cutoff, box(2,2) + 2*cutoff]);</span>
<span class="comment">%     xlabel(<span class="string">'X'</span>);</span>
<span class="comment">%     ylabel(<span class="string">'Y'</span>);</span>
<span class="comment">%     title(<span class="string">'Original Particles and Their Fictive Images'</span>);</span>
<span class="comment">%     legend(<span class="string">'Original Particles'</span>, <span class="string">'Fictive Images'</span>);</span>
<span class="comment">%     grid on;</span>
<span class="comment">%     hold off;</span>
<span class="comment">%     axis equal</span>
<span class="comment">% %}</span>
<span class="comment">% </span>
<span class="comment">% % Full example in 3D</span>
<span class="comment">% %{</span>
<span class="comment">%     % Parameters</span>
<span class="comment">%     n_particles = 10000;</span>
<span class="comment">%     box = [0 10; 0 10; 0 10]; % Box limits <span class="keyword">for</span> 3D</span>
<span class="comment">%     PBC = [true, true, true]; % Periodic boundary conditions in both dimensions</span>
<span class="comment">%     cutoff = 3.0; % Cutoff distance</span>
<span class="comment">% </span>
<span class="comment">%     % Generate random particles within the box</span>
<span class="comment">%     X = rand(n_particles, 3) .* (box(:,2) - box(:,1))<span class="string">' + box(:,1)'</span>;</span>
<span class="comment">% </span>
<span class="comment">%     % Calculate fictive images</span>
<span class="comment">%     Ximages = PBCimages(X, box, PBC, cutoff);</span>
<span class="comment">% </span>
<span class="comment">%     % Plotting</span>
<span class="comment">%     figure, hold on</span>
<span class="comment">%     plot3(X(:,1), X(:,2), X(:,3), <span class="string">'g.'</span>, <span class="string">'MarkerSize'</span>, 15); % Original particles in green</span>
<span class="comment">%     plot3(Ximages(:,1), Ximages(:,2),Ximages(:,3), <span class="string">'b.'</span>, <span class="string">'MarkerSize'</span>, 15); % Images in blue</span>
<span class="comment">%     xlim([box(1,1) - 2*cutoff, box(1,2) + 2*cutoff]);</span>
<span class="comment">%     ylim([box(2,1) - 2*cutoff, box(2,2) + 2*cutoff]);</span>
<span class="comment">%     zlim([box(3,1) - 2*cutoff, box(3,2) + 2*cutoff]);</span>
<span class="comment">%     xlabel(<span class="string">'X'</span>); ylabel(<span class="string">'Y'</span>); ylabel(<span class="string">'Z'</span>); title(<span class="string">'Original Particles and Their Fictive Images'</span>);</span>
<span class="comment">%     legend(<span class="string">'Original Particles'</span>, <span class="string">'Fictive Images'</span>);</span>
<span class="comment">%     grid on, hold off, axis equal, view(3)</span>
<span class="comment">% %}</span>
<span class="comment">% </span>
<span class="comment">% </span>
<span class="comment">% % MS 3.0 | 2024-03-15 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev. 2024-03-16</span>
<span class="comment">% </span>
<span class="comment">% </span>
<span class="comment">% % Revision history</span>
<span class="comment">% % 2024-03-15 release canidate with examples in 2D and 3D</span>
<span class="comment">% % 2024-03-16 <span class="keyword">return</span> indX, advise using PBCincell <span class="keyword">if</span> particles outside are detected</span>
<span class="comment">% </span>
<span class="comment">% %% Check arguments</span>
<span class="comment">% <span class="keyword">if</span> nargin<3, error(<span class="string">'Not enough input arguments. Syntax: Ximages = PBCimages(X,box,PBC [,cutoff])'</span>), <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> nargin<4, cutoff = []; <span class="keyword">end</span></span>
<span class="comment">% [n,d] = size(X); % Number of particles and dimensions</span>
<span class="comment">% <span class="keyword">if</span> d>3, error(<span class="string">'the number of dimensions should be 1,2,3'</span>), <span class="keyword">end</span></span>
<span class="comment">% Xmin = min(X);</span>
<span class="comment">% Xmax = max(X);</span>
<span class="comment">% <span class="keyword">if</span> isempty(cutoff), cutoff = 0.1*(Xmax-Xmin); <span class="keyword">end</span> % heuristic default value</span>
<span class="comment">% <span class="keyword">if</span> length(cutoff)==1, cutoff = cutoff(ones(1,d)); <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> length(cutoff)~=d, error(<span class="string">'cutoff must be a scalar or 1x%d vector'</span>,d); <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> size(box,2)~=2 || size(box,1)~=d, error(<span class="string">'Box dimensions must be a %dx2 vector'</span>,d); <span class="keyword">end</span></span>
<span class="comment">% boxlength = diff(box, 1, 2);</span>
<span class="comment">% <span class="keyword">if</span> length(PBC)~=d; error(<span class="string">'PBC must be a 1x%d logical vector'</span>,d), <span class="keyword">end</span></span>
<span class="comment">% PBC = PBC>0;</span>
<span class="comment">% </span>
<span class="comment">% %% Check that all points lie within the box</span>
<span class="comment">% incellok = true;</span>
<span class="comment">% <span class="keyword">for</span> i=1:d</span>
<span class="comment">%     <span class="keyword">if</span> box(i,1)>Xmin(i)</span>
<span class="comment">%         dispf(<span class="string">'some particles are outside the lower bound %0.3g along dimension %d'</span>,box(i,1),i)</span>
<span class="comment">%         incellok = false;</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">if</span> box(i,2)<Xmax(i)</span>
<span class="comment">%         dispf(<span class="string">'some particles are outside the upper bound %0.3g along dimension %d'</span>,box(i,2),i),</span>
<span class="comment">%         incellok = false;</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> ~incellok</span>
<span class="comment">%     disp(<span class="string">'use: X = PBCincell(X,box,PBC) to wrap particles around coordinates'</span>)</span>
<span class="comment">%     error(<span class="string">'PBCimages: some particles outside the box...'</span>)</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% %% Initialize empty array <span class="keyword">for</span> images</span>
<span class="comment">% [Ximages,indX] = deal([]);</span>
<span class="comment">% </span>
<span class="comment">% %% Generate images <span class="keyword">for</span> each dimension independently</span>
<span class="comment">% <span class="keyword">for</span> i = 1:d</span>
<span class="comment">%     <span class="keyword">if</span> PBC(i)</span>
<span class="comment">%         lowerBound = box(i,1);</span>
<span class="comment">%         upperBound = box(i,2);</span>
<span class="comment">% </span>
<span class="comment">%         % Lower and upper images</span>
<span class="comment">%         islowerImages = X(:, i) < (lowerBound + cutoff(i));</span>
<span class="comment">%         lowerImages = X(islowerImages, :);</span>
<span class="comment">%         lowerImages(:, i) = lowerImages(:, i) + (upperBound - lowerBound);</span>
<span class="comment">% </span>
<span class="comment">%         isupperimages = X(:, i) > (upperBound - cutoff(i));</span>
<span class="comment">%         upperImages = X(isupperimages, :);</span>
<span class="comment">%         upperImages(:, i) = upperImages(:, i) - (upperBound - lowerBound);</span>
<span class="comment">% </span>
<span class="comment">%         Ximages = [Ximages; lowerImages; upperImages]; %#ok<AGROW></span>
<span class="comment">%         indX = [indX;find(islowerImages);find(isupperimages)]; %#ok<AGROW></span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% %% Generate corner images <span class="keyword">if</span> all dimensions are periodic</span>
<span class="comment">% <span class="keyword">if</span> all(PBC)</span>
<span class="comment">%     % Find all combinations <span class="keyword">for</span> corners</span>
<span class="comment">%     % corners = dec2bin(1:(2^d)-1) - <span class="string">'0'</span>;</span>
<span class="comment">%     <span class="keyword">if</span> d==2</span>
<span class="comment">%         [x,y]=meshgrid([0 1],[0 1]);</span>
<span class="comment">%         corners = [x(:) y(:)];</span>
<span class="comment">%     <span class="keyword">elseif</span> d==3</span>
<span class="comment">%         [x,y,z]=meshgrid([0 1],[0 1],[0 1]);</span>
<span class="comment">%         corners = [x(:) y(:) z(:)];</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">%     <span class="keyword">for</span> i = 1:size(corners, 1) % 4 (in 2D), 8 (in 3D)</span>
<span class="comment">%         cornerCond = true(n, 1);</span>
<span class="comment">%         cornerImages = X;</span>
<span class="comment">%         <span class="keyword">for</span> j = 1:d</span>
<span class="comment">%             <span class="keyword">if</span> corners(i,j) == 0</span>
<span class="comment">%                 % Lower corner images</span>
<span class="comment">%                 thisCorner = X(:,j) < (box(j,1) + cutoff(j));</span>
<span class="comment">%                 cornerImages(thisCorner,j) = cornerImages(thisCorner,j) + boxlength(j);</span>
<span class="comment">%             <span class="keyword">else</span></span>
<span class="comment">%                 % Upper corner images</span>
<span class="comment">%                 thisCorner = X(:,j) > (box(j,2) - cutoff(j));</span>
<span class="comment">%                 cornerImages(thisCorner,j) = cornerImages(thisCorner,j) - boxlength(j);</span>
<span class="comment">%             <span class="keyword">end</span></span>
<span class="comment">%             cornerCond = cornerCond & thisCorner;</span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%         % Add corner images <span class="keyword">if</span> any particles satisfy the corner condition</span>
<span class="comment">%         <span class="keyword">if</span> any(cornerCond)</span>
<span class="comment">%             Ximages = [Ximages; cornerImages(cornerCond, :)]; %#ok<AGROW></span>
<span class="comment">%             indX = [indX;find(cornerCond)]; %#ok<AGROW></span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% %% Generate edge images <span class="keyword">if</span> two dimensions are at least periodic in 3D</span>
<span class="comment">% <span class="keyword">if</span> (d==3) && (sum(PBC)>1)</span>
<span class="comment">%     dvalid = find(PBC);</span>
<span class="comment">%     [x,y] = meshgrid(dvalid,dvalid); ok = (x<y);</span>
<span class="comment">%     dimforedges = [x(ok) y(ok)]; % dimension pairs (with x<y)</span>
<span class="comment">%     [x,y]=meshgrid([0 1],[0 1]);</span>
<span class="comment">%     edges = [x(:) y(:)]; % edge pairs</span>
<span class="comment">% </span>
<span class="comment">%     <span class="keyword">for</span> k = 1:size(dimforedges,1) % number of dimension pairs (max 3)</span>
<span class="comment">%         <span class="keyword">for</span> i = 1:size(edges, 1)  % number of lower/upper edges (4) ==> 3x4 = 12 edges at maximum</span>
<span class="comment">%             edgeCond = true(n, 1);</span>
<span class="comment">%             edgeImages = X;</span>
<span class="comment">%             <span class="keyword">for</span> j = 1:2 % <span class="keyword">for</span> edges in 3D (2 dimensions only)</span>
<span class="comment">%                 jdim = dimforedges(k,j);</span>
<span class="comment">%                 <span class="keyword">if</span> edges(i,j) == 0</span>
<span class="comment">%                     % Lower edge images</span>
<span class="comment">%                     thisEdge = X(:,jdim) < (box(jdim,1) + cutoff(jdim));</span>
<span class="comment">%                     edgeImages(thisEdge,jdim) = edgeImages(thisEdge,jdim) + boxlength(jdim);</span>
<span class="comment">%                 <span class="keyword">else</span></span>
<span class="comment">%                     % Upper edge images</span>
<span class="comment">%                     thisEdge = X(:,jdim) > (box(jdim,2) - cutoff(jdim));</span>
<span class="comment">%                     edgeImages(thisEdge,jdim) = edgeImages(thisEdge,jdim) - boxlength(jdim);</span>
<span class="comment">%                 <span class="keyword">end</span></span>
<span class="comment">%             <span class="keyword">end</span></span>
<span class="comment">%             edgeCond = edgeCond & thisEdge;</span>
<span class="comment">%             % Add corner images <span class="keyword">if</span> any particles satisfy the edge condition</span>
<span class="comment">%             <span class="keyword">if</span> any(edgeCond)</span>
<span class="comment">%                 Ximages = [Ximages; edgeImages(edgeCond, :)]; %#ok<AGROW></span>
<span class="comment">%                 indX = [indX;find(edgeCond)]; %#ok<AGROW></span>
<span class="comment">%             <span class="keyword">end</span></span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% </span>
<span class="comment">% %% Removing duplicates <span class="keyword">if</span> any</span>
<span class="comment">% [Ximages,iXuniq] = unique(Ximages, <span class="string">'rows'</span>);</span>
<span class="comment">% indX = indX(iXuniq);</span>
<span class="comment">% </span>
<span class="comment">% % output</span>
<span class="comment">% <span class="keyword">if</span> nargout>1, indXout = indX; <span class="keyword">end</span></span></code></pre></div>
</div>
<div id='PBCimages0' class='doc-content' style='display: none;'>
<h1>PBCIMAGES return the coordinates of fictive particle images outside box limits along periodic boundary dimensions</h1>
<p>USAGE: Ximages = PBCimages(X,box,PBC [,cutoff])<br/>[Ximages,indX] = PBCimages(...)</p>
<p>INPUTS:<br/>X: nx2 or nx3 array coding for the coordinates of the n particles in 2D and 3D, respectively<br/>box: 2x2 or 3x2 array coding for box dimensions<br/>the box spans along dimension i between box(i,1) and box(i,2)<br/>all X values should lie within box limits, if not an error ois generated<br/>PBC: 1x2 or 1x3 boolean array<br/>PBC(i) is true if the dimension i is periodic<br/>cutoff: scalar or 1xd array with d the number of dimensions (2 or 3)<br/>setting the cutoff distance beyond bounds to include fictive images<br/>if cutoff is a scalar, it is refedined as cutoff(ones(1,d))<br/>cutoff(i) is applied along dimension i</p>
<p>OUTPUTS:<br/>Ximages: mx2 or mx3 array coding for the coordinates of the m particle images in 2D and 3D, respectively<br/>indX: corresponding indices of images in X</p>
<h2>See also</h2>
<p><a href="#PBCgrid">PBCgrid</a>, <a href="#PBCgridshift">PBCgridshift</a>, PBCimageschift, <a href="#PBCincell">PBCincell</a></p>
<h2>See also</h2>
<p></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [Ximages,indXout] = PBCimages0(X,box,PBC,cutoff)
<span class="comment">%PBCIMAGES <span class="keyword">return</span> the coordinates of fictive particle images outside box limits along periodic boundary dimensions</span>
<span class="comment">%</span>
<span class="comment">%   USAGE: Ximages = PBCimages(X,box,PBC [,cutoff])</span>
<span class="comment">%          [Ximages,indX] = PBCimages(...)</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%          X: nx2 or nx3 array coding <span class="keyword">for</span> the coordinates of the n particles in 2D and 3D, respectively</span>
<span class="comment">%        box: 2x2 or 3x2 array coding <span class="keyword">for</span> box dimensions</span>
<span class="comment">%             the box spans along dimension i between box(i,1) and box(i,2)</span>
<span class="comment">%             all X values should lie within box limits, <span class="keyword">if</span> not an error ois generated</span>
<span class="comment">%        PBC: 1x2 or 1x3 boolean array</span>
<span class="comment">%             PBC(i) is true <span class="keyword">if</span> the dimension i is periodic</span>
<span class="comment">%     cutoff: scalar or 1xd array with d the number of dimensions (2 or 3)</span>
<span class="comment">%             setting the cutoff distance beyond bounds to include fictive images</span>
<span class="comment">%             <span class="keyword">if</span> cutoff is a scalar, it is refedined as cutoff(ones(1,d))</span>
<span class="comment">%             cutoff(i) is applied along dimension i</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%    Ximages: mx2 or mx3 array coding <span class="keyword">for</span> the coordinates of the m particle images in 2D and 3D, respectively</span>
<span class="comment">%       indX: corresponding indices of images in X</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: PBCgrid, PBCgridshift, PBCimageschift, PBCincell</span>
<span class="comment">%</span>

<span class="comment">% Full example in 2D</span>
<span class="comment">%{</span>
    <span class="comment">% Parameters</span>
    n_particles = 10000;
    box = [0 10; 0 10]; <span class="comment">% Box limits <span class="keyword">for</span> 2D</span>
    PBC = [true, true]; <span class="comment">% Periodic boundary conditions in both dimensions</span>
    cutoff = 3.0; <span class="comment">% Cutoff distance</span>

    <span class="comment">% Generate random particles within the box</span>
    X = rand(n_particles, 2) .* (box(:,2) - box(:,1))<span class="string">' + box(:,1)'</span>;

    <span class="comment">% Calculate fictive images</span>
    Ximages = PBCimages(X, box, PBC, cutoff);

    <span class="comment">% Plotting</span>
    figure, hold on
    plot(X(:,1), X(:,2), <span class="string">'g.'</span>, <span class="string">'MarkerSize'</span>, 15); <span class="comment">% Original particles in green</span>
    <span class="keyword">if</span> ~isempty(Ximages)
        plot(Ximages(:,1), Ximages(:,2), <span class="string">'b.'</span>, <span class="string">'MarkerSize'</span>, 15); <span class="comment">% Images in blue</span>
    <span class="keyword">end</span>
    xlim([box(1,1) - 2*cutoff, box(1,2) + 2*cutoff]);
    ylim([box(2,1) - 2*cutoff, box(2,2) + 2*cutoff]);
    xlabel(<span class="string">'X'</span>);
    ylabel(<span class="string">'Y'</span>);
    title(<span class="string">'Original Particles and Their Fictive Images'</span>);
    legend(<span class="string">'Original Particles'</span>, <span class="string">'Fictive Images'</span>);
    grid on;
    hold off;
    axis equal
<span class="comment">%}</span>

<span class="comment">% Full example in 3D</span>
<span class="comment">%{</span>
    <span class="comment">% Parameters</span>
    n_particles = 10000;
    box = [0 10; 0 10; 0 10]; <span class="comment">% Box limits <span class="keyword">for</span> 3D</span>
    PBC = [true, true, true]; <span class="comment">% Periodic boundary conditions in both dimensions</span>
    cutoff = 3.0; <span class="comment">% Cutoff distance</span>

    <span class="comment">% Generate random particles within the box</span>
    X = rand(n_particles, 3) .* (box(:,2) - box(:,1))<span class="string">' + box(:,1)'</span>;

    <span class="comment">% Calculate fictive images</span>
    Ximages = PBCimages(X, box, PBC, cutoff);

    <span class="comment">% Plotting</span>
    figure, hold on
    plot3(X(:,1), X(:,2), X(:,3), <span class="string">'g.'</span>, <span class="string">'MarkerSize'</span>, 15); <span class="comment">% Original particles in green</span>
    plot3(Ximages(:,1), Ximages(:,2),Ximages(:,3), <span class="string">'b.'</span>, <span class="string">'MarkerSize'</span>, 15); <span class="comment">% Images in blue</span>
    xlim([box(1,1) - 2*cutoff, box(1,2) + 2*cutoff]);
    ylim([box(2,1) - 2*cutoff, box(2,2) + 2*cutoff]);
    zlim([box(3,1) - 2*cutoff, box(3,2) + 2*cutoff]);
    xlabel(<span class="string">'X'</span>); ylabel(<span class="string">'Y'</span>); ylabel(<span class="string">'Z'</span>); title(<span class="string">'Original Particles and Their Fictive Images'</span>);
    legend(<span class="string">'Original Particles'</span>, <span class="string">'Fictive Images'</span>);
    grid on, hold off, axis equal, view(3)
<span class="comment">%}</span>


<span class="comment">% MS 3.0 | 2024-03-15 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev. 2024-03-16</span>


<span class="comment">% Revision history</span>
<span class="comment">% 2024-03-15 release canidate with examples in 2D and 3D</span>
<span class="comment">% 2024-03-16 <span class="keyword">return</span> indX, advise using PBCincell <span class="keyword">if</span> particles outside are detected</span>

<span class="comment">%% Check arguments</span>
<span class="keyword">if</span> nargin<3, error(<span class="string">'Not enough input arguments. Syntax: Ximages = PBCimages(X,box,PBC [,cutoff])'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, cutoff = []; <span class="keyword">end</span>
[n,d] = size(X); <span class="comment">% Number of particles and dimensions</span>
<span class="keyword">if</span> d>3, error(<span class="string">'the number of dimensions should be 1,2,3'</span>), <span class="keyword">end</span>
Xmin = min(X);
Xmax = max(X);
<span class="keyword">if</span> isempty(cutoff), cutoff = 0.1*(Xmax-Xmin); <span class="keyword">end</span> <span class="comment">% heuristic default value</span>
<span class="keyword">if</span> length(cutoff)==1, cutoff = cutoff(ones(1,d)); <span class="keyword">end</span>
<span class="keyword">if</span> length(cutoff)~=d, error(<span class="string">'cutoff must be a scalar or 1x<span class="comment">%d vector'</span>,d); <span class="keyword">end</span></span>
<span class="keyword">if</span> size(box,2)~=2 || size(box,1)~=d, error(<span class="string">'Box dimensions must be a <span class="comment">%dx2 vector'</span>,d); <span class="keyword">end</span></span>
boxlength = diff(box, 1, 2);
<span class="keyword">if</span> length(PBC)~=d; error(<span class="string">'PBC must be a 1x<span class="comment">%d logical vector'</span>,d), <span class="keyword">end</span></span>
PBC = PBC>0;

<span class="comment">%% Check that all points lie within the box</span>
incellok = true;
<span class="keyword">for</span> i=1:d
    <span class="keyword">if</span> box(i,1)>Xmin(i)
        dispf(<span class="string">'some particles are outside the lower bound <span class="comment">%0.3g along dimension %d'</span>,box(i,1),i)</span>
        incellok = false;
    <span class="keyword">end</span>
    <span class="keyword">if</span> box(i,2)<Xmax(i)
        dispf(<span class="string">'some particles are outside the upper bound <span class="comment">%0.3g along dimension %d'</span>,box(i,2),i),</span>
        incellok = false;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~incellok
    disp(<span class="string">'use: X = PBCincell(X,box,PBC) to wrap particles around coordinates'</span>)
    error(<span class="string">'PBCimages: some particles outside the box...'</span>)
<span class="keyword">end</span>

<span class="comment">%% Initialize empty array <span class="keyword">for</span> images</span>
[Ximages,indX] = deal([]);

<span class="comment">%% Generate images <span class="keyword">for</span> each dimension independently</span>
<span class="keyword">for</span> i = 1:d
    <span class="keyword">if</span> PBC(i)
        lowerBound = box(i,1);
        upperBound = box(i,2);

        <span class="comment">% Lower and upper images</span>
        islowerImages = X(:, i) < (lowerBound + cutoff(i));
        lowerImages = X(islowerImages, :);
        lowerImages(:, i) = lowerImages(:, i) + (upperBound - lowerBound);

        isupperimages = X(:, i) > (upperBound - cutoff(i));
        upperImages = X(isupperimages, :);
        upperImages(:, i) = upperImages(:, i) - (upperBound - lowerBound);

        Ximages = [Ximages; lowerImages; upperImages]; <span class="comment">%#ok<AGROW></span>
        indX = [indX;find(islowerImages);find(isupperimages)]; <span class="comment">%#ok<AGROW></span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% Generate corner images <span class="keyword">if</span> all dimensions are periodic</span>
<span class="keyword">if</span> all(PBC)
    <span class="comment">% Find all combinations <span class="keyword">for</span> corners</span>
    <span class="comment">% corners = dec2bin(1:(2^d)-1) - <span class="string">'0'</span>;</span>
    <span class="keyword">if</span> d==2
        [x,y]=meshgrid([0 1],[0 1]);
        corners = [x(:) y(:)];
    <span class="keyword">elseif</span> d==3
        [x,y,z]=meshgrid([0 1],[0 1],[0 1]);
        corners = [x(:) y(:) z(:)];
    <span class="keyword">end</span>

    <span class="keyword">for</span> i = 1:size(corners, 1) <span class="comment">% 4 (in 2D), 8 (in 3D)</span>
        cornerCond = true(n, 1);
        cornerImages = X;
        <span class="keyword">for</span> j = 1:d
            <span class="keyword">if</span> corners(i,j) == 0
                <span class="comment">% Lower corner images</span>
                thisCorner = X(:,j) < (box(j,1) + cutoff(j));
                cornerImages(thisCorner,j) = cornerImages(thisCorner,j) + boxlength(j);
            <span class="keyword">else</span>
                <span class="comment">% Upper corner images</span>
                thisCorner = X(:,j) > (box(j,2) - cutoff(j));
                cornerImages(thisCorner,j) = cornerImages(thisCorner,j) - boxlength(j);
            <span class="keyword">end</span>
            cornerCond = cornerCond & thisCorner;
        <span class="keyword">end</span>
        <span class="comment">% Add corner images <span class="keyword">if</span> any particles satisfy the corner condition</span>
        <span class="keyword">if</span> any(cornerCond)
            Ximages = [Ximages; cornerImages(cornerCond, :)]; <span class="comment">%#ok<AGROW></span>
            indX = [indX;find(cornerCond)]; <span class="comment">%#ok<AGROW></span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% Generate edge images <span class="keyword">if</span> two dimensions are at least periodic in 3D</span>
<span class="keyword">if</span> (d==3) && (sum(PBC)>1)
    dvalid = find(PBC);
    [x,y] = meshgrid(dvalid,dvalid); ok = (x<y);
    dimforedges = [x(ok) y(ok)]; <span class="comment">% dimension pairs (with x<y)</span>
    [x,y]=meshgrid([0 1],[0 1]);
    edges = [x(:) y(:)]; <span class="comment">% edge pairs</span>

    <span class="keyword">for</span> k = 1:size(dimforedges,1) <span class="comment">% number of dimension pairs (max 3)</span>
        <span class="keyword">for</span> i = 1:size(edges, 1)  <span class="comment">% number of lower/upper edges (4) ==> 3x4 = 12 edges at maximum</span>
            edgeCond = true(n, 1);
            edgeImages = X;
            <span class="keyword">for</span> j = 1:2 <span class="comment">% <span class="keyword">for</span> edges in 3D (2 dimensions only)</span>
                jdim = dimforedges(k,j);
                <span class="keyword">if</span> edges(i,j) == 0
                    <span class="comment">% Lower edge images</span>
                    thisEdge = X(:,jdim) < (box(jdim,1) + cutoff(jdim));
                    edgeImages(thisEdge,jdim) = edgeImages(thisEdge,jdim) + boxlength(jdim);
                <span class="keyword">else</span>
                    <span class="comment">% Upper edge images</span>
                    thisEdge = X(:,jdim) > (box(jdim,2) - cutoff(jdim));
                    edgeImages(thisEdge,jdim) = edgeImages(thisEdge,jdim) - boxlength(jdim);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            edgeCond = edgeCond & thisEdge;
            <span class="comment">% Add corner images <span class="keyword">if</span> any particles satisfy the edge condition</span>
            <span class="keyword">if</span> any(edgeCond)
                Ximages = [Ximages; edgeImages(edgeCond, :)]; <span class="comment">%#ok<AGROW></span>
                indX = [indX;find(edgeCond)]; <span class="comment">%#ok<AGROW></span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">%% Removing duplicates <span class="keyword">if</span> any</span>
[Ximages,iXuniq] = unique(Ximages, <span class="string">'rows'</span>);
indX = indX(iXuniq);

<span class="comment">% output</span>
<span class="keyword">if</span> nargout>1, indXout = indX; <span class="keyword">end</span></code></pre></div>
</div>
<div id='PBCimagesshift' class='doc-content' style='display: none;'>
<h1>PBCIMAGESSHIFT shift X coordinates assuming periodic conditions</h1>
<p>USAGE: Ximages = PBCimages(X,box,Pshift)<br/>[Ximages,updtbox] = PBCimages(...)</p>
<p>INPUTS:<br/>X: nx2 or nx3 array coding for the coordinates of the n particles in 2D and 3D, respectively<br/>Pshift: 1x2 or 1x3 array coding for the translation to apply<br/>box: 2x2 or 3x2 array coding for current box dimensions (before translation)<br/>the box spans along dimension i between box(i,1) and box(i,2)<br/>all X values should lie within box limits, if not an error is generated</p>
<p>OUTPUTS:<br/>Ximages: nx2 or nx3 array coding for the translated coordinates wrapped around periodic boundaries<br/>updtbox: 2x2 or 3x3 updated box coordinates</p>
<h2>See also</h2>
<p><a href="#PBCgrid">PBCgrid</a>, <a href="#PBCgridshift">PBCgridshift</a>, <a href="#PBCimages">PBCimages</a>, <a href="#PBCincell">PBCincell</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [Ximages,updtbox] = PBCimagesshift(X,Pshift,box)
<span class="comment">%PBCIMAGESSHIFT shift X coordinates assuming periodic conditions</span>
<span class="comment">%</span>
<span class="comment">%   USAGE: Ximages = PBCimages(X,box,Pshift)</span>
<span class="comment">%          [Ximages,updtbox] = PBCimages(...)</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%          X: nx2 or nx3 array coding <span class="keyword">for</span> the coordinates of the n particles in 2D and 3D, respectively</span>
<span class="comment">%     Pshift: 1x2 or 1x3 array coding <span class="keyword">for</span> the translation to apply</span>
<span class="comment">%        box: 2x2 or 3x2 array coding <span class="keyword">for</span> current box dimensions (before translation)</span>
<span class="comment">%             the box spans along dimension i between box(i,1) and box(i,2)</span>
<span class="comment">%             all X values should lie within box limits, <span class="keyword">if</span> not an error is generated</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%    Ximages: nx2 or nx3 array coding <span class="keyword">for</span> the translated coordinates wrapped around periodic boundaries</span>
<span class="comment">%    updtbox: 2x2 or 3x3 updated box coordinates</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: PBCgrid, PBCgridshift, PBCimages, PBCincell</span>



<span class="comment">% MS 3.0 | 2024-03-24 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev. 2024-03-16</span>


<span class="comment">% Revision history</span>


<span class="comment">%% Check arguments</span>
<span class="keyword">if</span> nargin<3, error(<span class="string">'Not enough input arguments. Syntax: Ximages = PBCimagesshift(X,Pshift,box)'</span>), <span class="keyword">end</span>
[n,d] = size(X); <span class="comment">% Number of particles and dimensions</span>
<span class="keyword">if</span> d>3, error(<span class="string">'the number of dimensions should be 1,2,3'</span>), <span class="keyword">end</span>
Xmin = min(X);
Xmax = max(X);
<span class="keyword">if</span> size(box,2)~=2 || size(box,1)~=d, error(<span class="string">'Box dimensions must be a <span class="comment">%dx2 vector'</span>,d); <span class="keyword">end</span></span>
boxlength = diff(box, 1, 2);

<span class="comment">%% Check that all points lie within the box</span>
incellok = true;
<span class="keyword">for</span> i=1:d
    <span class="keyword">if</span> box(i,1)>Xmin(i)
        dispf(<span class="string">'some particles are outside the lower bound <span class="comment">%0.3g along dimension %d'</span>,box(i,1),i)</span>
        incellok = false;
    <span class="keyword">end</span>
    <span class="keyword">if</span> box(i,2)<Xmax(i)
        dispf(<span class="string">'some particles are outside the upper bound <span class="comment">%0.3g along dimension %d'</span>,box(i,2),i),</span>
        incellok = false;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~incellok
    disp(<span class="string">'use: X = PBCincell(X,box,PBC) to wrap particles around coordinates'</span>)
    error(<span class="string">'PBCimages: some particles outside the box...'</span>)
<span class="keyword">end</span>


<span class="comment">%% Apply shift and wrap around using periodic boundary conditions</span>
boxtranslated = zeros(size(box));
Ximages = zeros(size(X),class(X));
<span class="keyword">for</span> i = 1:d
    boxtranslated(i,:) = box(i,:) - Pshift(i);
    Ximages(:, i) = mod(X(:, i) - box(i, 1) + Pshift(i), boxlength(i)) + boxtranslated(i, 1);
<span class="keyword">end</span>

<span class="comment">%% Output</span>
<span class="keyword">if</span> nargout>1
    updtbox = boxtranslated;
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='PBCincell' class='doc-content' style='display: none;'>
<h1>PBCINCELL force incell coordinates (without X coordinates outside the box along perodic coordinates)</h1>
<p>USAGE: Xincell = PBCincell(X,box,PBC)</p>
<p>INPUTS:<br/>X: nx2 or nx3 array coding for the coordinates of the n particles in 2D and 3D, respectively<br/>box: 2x2 or 3x2 array coding for box dimensions<br/>the box spans along dimension i between box(i,1) and box(i,2)<br/>PBC: 1x2 or 1x3 boolean array<br/>PBC(i) is true if the dimension i is periodic</p>
<p>OUTPUTS:<br/>Xincell: nx2 or nx3 array coding for the coordinates incell</p>
<h2>See also</h2>
<p><a href="#PBCgrid">PBCgrid</a>, <a href="#PBCgridshift">PBCgridshift</a>, <a href="#PBCimages">PBCimages</a>, PBCimageschift, <a href="#PBCincell">PBCincell</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> Xincell = PBCincell(X,box,PBC)
<span class="comment">%PBCINCELL force incell coordinates (without X coordinates outside the box along perodic coordinates)</span>
<span class="comment">%</span>
<span class="comment">%   USAGE: Xincell = PBCincell(X,box,PBC)</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%          X: nx2 or nx3 array coding <span class="keyword">for</span> the coordinates of the n particles in 2D and 3D, respectively</span>
<span class="comment">%        box: 2x2 or 3x2 array coding <span class="keyword">for</span> box dimensions</span>
<span class="comment">%             the box spans along dimension i between box(i,1) and box(i,2)</span>
<span class="comment">%        PBC: 1x2 or 1x3 boolean array</span>
<span class="comment">%             PBC(i) is true <span class="keyword">if</span> the dimension i is periodic</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%    Xincell: nx2 or nx3 array coding <span class="keyword">for</span> the coordinates incell</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: PBCgrid, PBCgridshift, PBCimages, PBCimageschift, PBCincell</span>



<span class="comment">% MS 3.0 | 2024-03-16 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr |</span>


<span class="comment">% Revision history</span>


<span class="comment">% Initialize the output array with the same size as input coordinates</span>
Xincell = X;

<span class="comment">% Number of dimensions (2D or 3D)</span>
dims = size(X, 2);

<span class="comment">% Loop over each dimension to apply periodic boundary conditions</span>
<span class="keyword">for</span> i = 1:dims
    <span class="keyword">if</span> PBC(i)
        <span class="comment">% Get the box size <span class="keyword">for</span> the current dimension</span>
        boxSize = box(i, 2) - box(i, 1);
        <span class="comment">% Adjust positions <span class="keyword">for</span> periodic boundary conditions</span>
        <span class="comment">% Use mod to wrap coordinates within the box dimensions</span>
        Xincell(:, i) = mod(X(:, i) - box(i, 1), boxSize) + box(i, 1);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='PBCoutcell' class='doc-content' style='display: none;'>
<h1>PBCOUTCELL reunite atoms crossing PBC boundaries on one side based on the centroid&#x27;s location</h1>
<p>USAGE: XYZout = PBCoutcell(XYZ, box, PBC)<br/>[XYZout, isReunited] = PBCoutcell(...)</p>
<p>INPUTS:<br/>XYZ: nx2 or nx3 array coding for the coordinates of the n atoms in 2D or 3D<br/>box: 2x2 or 3x2 array coding for box dimensions<br/>the box spans along dimension i between box(i,1) and box(i,2)<br/>PBC: 1x2 or 1x3 boolean array<br/>PBC(i) is true if the dimension i is periodic</p>
<p>OUTPUT:<br/>XYZout: nx2 or nx3 array with coordinates adjusted to reunite atoms on one side of the boundaries<br/>isReunited: true if reunion has been applied</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [XYZout, isReunitedout] = PBCoutcell(XYZ, box, PBC)
<span class="comment">%PBCOUTCELL reunite atoms crossing PBC boundaries on one side based on the centroid<span class="string">'s location</span>
<span class="comment">%</span>
<span class="comment">%   USAGE: XYZout = PBCoutcell(XYZ, box, PBC)</span>
<span class="comment">%          [XYZout, isReunited] = PBCoutcell(...)</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%          XYZ: nx2 or nx3 array coding <span class="keyword">for</span> the coordinates of the n atoms in 2D or 3D</span>
<span class="comment">%          box: 2x2 or 3x2 array coding <span class="keyword">for</span> box dimensions</span>
<span class="comment">%               the box spans along dimension i between box(i,1) and box(i,2)</span>
<span class="comment">%          PBC: 1x2 or 1x3 boolean array</span>
<span class="comment">%               PBC(i) is true <span class="keyword">if</span> the dimension i is periodic</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUT:</span>
<span class="comment">%       XYZout: nx2 or nx3 array with coordinates adjusted to reunite atoms on one side of the boundaries</span>
<span class="comment">%   isReunited: true <span class="keyword">if</span> reunion has been applied</span>

<span class="comment">% Example in 2D:</span>
<span class="comment">%{</span>
    <span class="comment">% Box limits</span>
    box = [0 10; 0 10];
    <span class="comment">% PBC in both dimensions</span>
    PBC = [true, true];
    <span class="comment">% Generate random points in a disk</span>
    n_particles = 10000;
    radius = 0.55 * min(box(:,2) - box(:,1)) / 2;
    theta = 2 * pi * rand(n_particles, 1);
    r = radius * sqrt(rand(n_particles, 1));
    center = (box(:,2) - box(:,1))'</span> .* rand(1, 2) + box(:,1)<span class="string">';
    XYZ0 = [center(1) + r .* cos(theta), center(2) + r .* sin(theta)];
    <span class="comment">% Apply PBC to bring coordinates within the box</span>
    XYZ = PBCincell(XYZ0,box,PBC);
    XYZout = PBCoutcell(XYZ, box, PBC);
    <span class="comment">% Plotting</span>
    figure, hold on
    plot(XYZ0(:,1), XYZ0(:,2), '</span>g.<span class="string">', '</span>MarkerSize<span class="string">', 10); <span class="comment">% OUTCELL Original points in green</span>
    plot(XYZ(:,1), XYZ(:,2), '</span>r.<span class="string">', '</span>MarkerSize<span class="string">', 10); <span class="comment">% Original INCELL points in red</span>
    plot(XYZout(:,1), XYZout(:,2), '</span>b.<span class="string">', '</span>MarkerSize<span class="string">', 10); <span class="comment">% Adjusted points in blue</span>
    xlabel('</span>X<span class="string">'); ylabel('</span>Y<span class="string">'); title('</span>Reunited Atoms in 2D<span class="string">');
    legend('</span>True<span class="string">', '</span>Original<span class="string">', '</span>Adjusted<span class="string">');
    grid on; axis equal; hold off;
<span class="comment">%}</span>
<span class="comment">%</span>
<span class="comment">% Example in 3D:</span>
<span class="comment">%{</span>
    <span class="comment">% Box limits</span>
    box = [0 10; 0 10; 0 10];
    <span class="comment">% PBC in all dimensions</span>
    PBC = [true, true, true];
    <span class="comment">% Generate random points in a sphere</span>
    n_particles = 10000;
    radius = 4.4*0.25 * min(box(:,2) - box(:,1)) / 2;
    phi = 2 * pi * rand(n_particles, 1);
    costheta = 2 * rand(n_particles, 1) - 1;
    u = rand(n_particles, 1);
    theta = acos(costheta);
    r = radius * u.^(1/3);
    center = (box(:,2) - box(:,1))'</span> .* rand(1, 3) + box(:,1)<span class="string">';
    XYZ0 = [center(1) + r .* sin(theta) .* cos(phi), ...
           center(2) + r .* sin(theta) .* sin(phi), ...
           center(3) + r .* cos(theta)];
    <span class="comment">% Apply PBC to bring coordinates within the box</span>
    XYZ = PBCincell(XYZ0,box,PBC)
    XYZout = PBCoutcell(XYZ, box, PBC);
    figure, hold on
    plot3(XYZ0(:,1), XYZ0(:,2), XYZ0(:,3), '</span>g.<span class="string">', '</span>MarkerSize<span class="string">', 10); <span class="comment">% OUTCELL Original points in green</span>
    plot3(XYZ(:,1), XYZ(:,2), XYZ(:,3), '</span>r.<span class="string">', '</span>MarkerSize<span class="string">', 10); <span class="comment">% Original INCELL points in red</span>
    plot3(XYZout(:,1), XYZout(:,2), XYZout(:,3), '</span>b.<span class="string">', '</span>MarkerSize<span class="string">', 10); <span class="comment">% Adjusted points in blue</span>
    xlabel('</span>X<span class="string">'); ylabel('</span>Y<span class="string">'); zlabel('</span>Z<span class="string">'); title('</span>Reunited Atoms in 3D<span class="string">');
    legend('</span>True<span class="string">','</span>Original<span class="string">', '</span>Adjusted<span class="string">');
    grid on; axis equal; view(3); hold off;
<span class="comment">%}</span>


[n, d] = size(XYZ);

<span class="comment">% Validate inputs</span>
<span class="keyword">if</span> size(box, 2) ~= 2 || size(box, 1) ~= d
    error('</span>Box dimensions must be a <span class="comment">%dx2 vector<span class="string">', d);</span>
<span class="keyword">end</span>

<span class="keyword">if</span> length(PBC) ~= d
    error('</span>PBC must be a 1x<span class="comment">%d logical vector<span class="string">', d);</span>
<span class="keyword">end</span>

<span class="comment">% Calculate the center of the box</span>
box_center = mean(box, 2)'</span>;

<span class="comment">% Initialize output</span>
XYZout = XYZ;
isReunited = false;

<span class="comment">% Maximum iterations to avoid infinite loops</span>
max_iters = 10;
iter = 0;

<span class="keyword">while</span> iter < max_iters
    iter = iter + 1;
    XYZout_prev = XYZout;

    <span class="comment">% Calculate the centroid of the points</span>
    centroid = mean(XYZout, 1);

    <span class="comment">% Adjust coordinates based on the centroid<span class="string">'s location</span>
    <span class="keyword">for</span> i = 1:d
        <span class="keyword">if</span> PBC(i)
            box_length = box(i, 2) - box(i, 1);
            <span class="keyword">for</span> j = 1:n
                <span class="keyword">if</span> abs(XYZout(j, i) - centroid(i)) > box_length / 2
                    <span class="keyword">if</span> XYZout(j, i) > centroid(i)
                        XYZout(j, i) = XYZout(j, i) - box_length;
                    <span class="keyword">else</span>
                        XYZout(j, i) = XYZout(j, i) + box_length;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Recalculate the centroid</span>
    new_centroid = mean(XYZout, 1);

    <span class="comment">% If the output is stable, break the loop</span>
    <span class="keyword">if</span> isequal(XYZout, XYZout_prev)
        break;
    <span class="keyword">end</span>

    <span class="comment">% Update the centroid</span>
    centroid = new_centroid;
<span class="keyword">end</span>

<span class="comment">% Calculate the inertia before and after adjustment</span>
initial_inertia = sum(sum((XYZ - mean(XYZ, 1)).^2));
adjusted_inertia = sum(sum((XYZout - mean(XYZout, 1)).^2));

<span class="comment">% If the adjusted inertia is larger, revert to the original coordinates</span>
<span class="keyword">if</span> adjusted_inertia >= initial_inertia
    XYZout = XYZ;
    isReunited = false;
<span class="keyword">else</span>
    isReunited = true;
<span class="keyword">end</span>

<span class="keyword">if</span> nargout > 1
    isReunitedout = isReunited;
<span class="keyword">end</span>

<span class="keyword">end</span>


<span class="comment">% <span class="keyword">function</span> [XYZout,isReunitedout] = PBCoutcell(XYZ, box, PBC)</span>
<span class="comment">% %PBCOUTCELL reunite atoms crossing PBC boundaries on one side based on the centroid'</span>s location</span>
<span class="comment">% %</span>
<span class="comment">% %   USAGE: XYZout = PBCoutcell(XYZ, box, PBC)</span>
<span class="comment">% %          [XYZout,isreunited] = PBCoutcell(...)</span>
<span class="comment">% %</span>
<span class="comment">% %   INPUTS:</span>
<span class="comment">% %          XYZ: nx2 or nx3 array coding <span class="keyword">for</span> the coordinates of the n atoms in 2D or 3D</span>
<span class="comment">% %          box: 2x2 or 3x2 array coding <span class="keyword">for</span> box dimensions</span>
<span class="comment">% %               the box spans along dimension i between box(i,1) and box(i,2)</span>
<span class="comment">% %          PBC: 1x2 or 1x3 boolean array</span>
<span class="comment">% %               PBC(i) is true <span class="keyword">if</span> the dimension i is periodic</span>
<span class="comment">% %</span>
<span class="comment">% %   OUTPUT:</span>
<span class="comment">% %       XYZout: nx2 or nx3 array with coordinates adjusted to reunite atoms on one side of the boundaries</span>
<span class="comment">% %   isreunited: true <span class="keyword">if</span> reunion has been applied</span>
<span class="comment">% </span>
<span class="comment">% %   Example in 2D:</span>
<span class="comment">% %{</span>
<span class="comment">%     % Box limits</span>
<span class="comment">%     box = [0 10; 0 10];</span>
<span class="comment">%     % PBC in both dimensions</span>
<span class="comment">%     PBC = [true, true];</span>
<span class="comment">%     % Generate random points in a disk</span>
<span class="comment">%     n_particles = 10000;</span>
<span class="comment">%     radius = 0.35 * min(box(:,2) - box(:,1)) / 2;</span>
<span class="comment">%     theta = 2 * pi * rand(n_particles, 1);</span>
<span class="comment">%     r = radius * sqrt(rand(n_particles, 1));</span>
<span class="comment">%     center = (box(:,2) - box(:,1))<span class="string">' .* rand(1, 2) + box(:,1)'</span>;</span>
<span class="comment">%     XYZ0 = [center(1) + r .* cos(theta), center(2) + r .* sin(theta)];</span>
<span class="comment">%     % Adjust coordinates</span>
<span class="comment">%     XYZ = PBCincell(XYZ0,box,PBC);</span>
<span class="comment">%     XYZout = PBCoutcell(XYZ, box, PBC);</span>
<span class="comment">%     % Plotting</span>
<span class="comment">%     figure, hold on</span>
<span class="comment">%     plot(XYZ(:,1), XYZ(:,2), <span class="string">'r.'</span>, <span class="string">'MarkerSize'</span>, 10); % Original points in red</span>
<span class="comment">%     plot(XYZout(:,1), XYZout(:,2), <span class="string">'b.'</span>, <span class="string">'MarkerSize'</span>, 10); % Adjusted points in blue</span>
<span class="comment">%     xlabel(<span class="string">'X'</span>); ylabel(<span class="string">'Y'</span>); title(<span class="string">'Reunited Atoms in 2D'</span>);</span>
<span class="comment">%     legend(<span class="string">'Original'</span>, <span class="string">'Adjusted'</span>);</span>
<span class="comment">%     grid on; axis equal; hold off;</span>
<span class="comment">% %}</span>
<span class="comment">% %</span>
<span class="comment">% %   Example in 3D:</span>
<span class="comment">% %{</span>
<span class="comment">%     % Box limits</span>
<span class="comment">%     box = [0 10; 0 10; 0 10];</span>
<span class="comment">%     % PBC in all dimensions</span>
<span class="comment">%     PBC = [true, true, true];</span>
<span class="comment">%     % Generate random points in a sphere</span>
<span class="comment">%     n_particles = 10000;</span>
<span class="comment">%     radius = 0.25 * min(box(:,2) - box(:,1)) / 2;</span>
<span class="comment">%     phi = 2 * pi * rand(n_particles, 1);</span>
<span class="comment">%     costheta = 2 * rand(n_particles, 1) - 1;</span>
<span class="comment">%     u = rand(n_particles, 1);</span>
<span class="comment">%     theta = acos(costheta);</span>
<span class="comment">%     r = radius * u.^(1/3);</span>
<span class="comment">%     center = (box(:,2) - box(:,1))<span class="string">' .* rand(1, 3) + box(:,1)'</span>;</span>
<span class="comment">%     XYZ0 = [center(1) + r .* sin(theta) .* cos(phi), ...</span>
<span class="comment">%            center(2) + r .* sin(theta) .* sin(phi), ...</span>
<span class="comment">%            center(3) + r .* cos(theta)];</span>
<span class="comment">%     % Adjust coordinates</span>
<span class="comment">%     XYZ = PBCincell(XYZ0,box,PBC)</span>
<span class="comment">%     XYZout = PBCoutcell(XYZ, box, PBC);</span>
<span class="comment">%     figure, hold on</span>
<span class="comment">%     plot3(XYZ0(:,1), XYZ0(:,2), XYZ0(:,3), <span class="string">'g.'</span>, <span class="string">'MarkerSize'</span>, 10); % OUTCELL Original points in green</span>
<span class="comment">%     plot3(XYZ(:,1), XYZ(:,2), XYZ(:,3), <span class="string">'r.'</span>, <span class="string">'MarkerSize'</span>, 10); % Original INCELL points in red</span>
<span class="comment">%     plot3(XYZout(:,1), XYZout(:,2), XYZout(:,3), <span class="string">'b.'</span>, <span class="string">'MarkerSize'</span>, 10); % Adjusted points in blue</span>
<span class="comment">%     xlabel(<span class="string">'X'</span>); ylabel(<span class="string">'Y'</span>); zlabel(<span class="string">'Z'</span>); title(<span class="string">'Reunited Atoms in 3D'</span>);</span>
<span class="comment">%     legend(<span class="string">'True'</span>,<span class="string">'Original'</span>, <span class="string">'Adjusted'</span>);</span>
<span class="comment">%     grid on; axis equal; view(3); hold off;</span>
<span class="comment">% %}</span>
<span class="comment">% </span>
<span class="comment">% </span>
<span class="comment">% % MS 3.0 | 2024-07-16 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev. </span>
<span class="comment">% </span>
<span class="comment">% </span>
<span class="comment">% % Revision history</span>
<span class="comment">% </span>
<span class="comment">% </span>
<span class="comment">% % Number of atoms and dimensions</span>
<span class="comment">% [n, d] = size(XYZ);</span>
<span class="comment">% </span>
<span class="comment">% % Validate inputs</span>
<span class="comment">% <span class="keyword">if</span> size(box,2) ~= 2 || size(box,1) ~= d</span>
<span class="comment">%     error(<span class="string">'Box dimensions must be a %dx2 vector'</span>, d);</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% <span class="keyword">if</span> length(PBC) ~= d</span>
<span class="comment">%     error(<span class="string">'PBC must be a 1x%d logical vector'</span>, d);</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% % Calculate the centroid of the object</span>
<span class="comment">% centroid = mean(XYZ, 1);</span>
<span class="comment">% </span>
<span class="comment">% % Calculate the initial inertia</span>
<span class="comment">% initial_inertia = sum(sum((XYZ - centroid).^2));</span>
<span class="comment">% </span>
<span class="comment">% % Initialize output</span>
<span class="comment">% XYZout = XYZ;</span>
<span class="comment">% </span>
<span class="comment">% % Adjust coordinates based on the centroid<span class="string">'s half-space</span>
<span class="comment">% <span class="keyword">for</span> i = 1:d</span>
<span class="comment">%     <span class="keyword">if</span> PBC(i)</span>
<span class="comment">%         box_length = box(i,2) - box(i,1);</span>
<span class="comment">%         half_box_length = box_length / 2;</span>
<span class="comment">%         centroid_half_space = (centroid(i) > (box(i,1) + half_box_length));</span>
<span class="comment">% </span>
<span class="comment">%         % Check and adjust atoms'</span> coordinates</span>
<span class="comment">%         <span class="keyword">for</span> j = 1:n</span>
<span class="comment">%             <span class="keyword">if</span> centroid_half_space</span>
<span class="comment">%                 % If centroid is in the upper half-space, move atoms in the lower half-space up</span>
<span class="comment">%                 <span class="keyword">if</span> XYZ(j,i) < (box(i,1) + half_box_length)</span>
<span class="comment">%                     XYZout(j,i) = XYZout(j,i) + box_length;</span>
<span class="comment">%                 <span class="keyword">end</span></span>
<span class="comment">%             <span class="keyword">else</span></span>
<span class="comment">%                 % If centroid is in the lower half-space, move atoms in the upper half-space down</span>
<span class="comment">%                 <span class="keyword">if</span> XYZ(j,i) > (box(i,1) + half_box_length)</span>
<span class="comment">%                     XYZout(j,i) = XYZout(j,i) - box_length;</span>
<span class="comment">%                 <span class="keyword">end</span></span>
<span class="comment">%             <span class="keyword">end</span></span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% % Calculate the adjusted inertia</span>
<span class="comment">% adjusted_inertia = sum(sum((XYZout - mean(XYZout, 1)).^2));</span>
<span class="comment">% </span>
<span class="comment">% % If the adjusted inertia is larger, revert to the original coordinates</span>
<span class="comment">% <span class="keyword">if</span> adjusted_inertia >= initial_inertia</span>
<span class="comment">%     XYZout = XYZ;</span>
<span class="comment">%     isReunited = false;</span>
<span class="comment">% <span class="keyword">else</span></span>
<span class="comment">%     isReunited = true;</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% <span class="keyword">if</span> nargout>1, isReunitedout = isReunited; <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% <span class="keyword">end</span></span></code></pre></div>
</div>
<div id='SetQuiverColor' class='doc-content' style='display: none;'>
<h1>--------------------------------------------------</h1>
<p>function SetQuiverColor(q,currentColormap)</p>
<p>INPUT:<br/>q = handle to quiver plot<br/>currentColormap = e.g. jet;<br/>OPTIONAL INPUT (&#x27;Field&#x27;,value):<br/>&#x27;range&#x27; = [min,max]; % Range of the magnitude in the colorbar<br/>(used to possibly saturate or expand the color used compared to the vectors)<br/>&#x27;mags&#x27; = magnitude; % Actual magnitude of the vectors</p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>[x,y] = meshgrid(-2:.2:2,-1:.15:1);
z = x .* exp(-x.^2 - y.^2);
[u,v,w] = surfnorm(x,y,z);
q = quiver3(x,y,z,u,v,w);
mag = 1+3.*rand(size(u));   % Creates number between 1 and 4
colormap(jet);
colorbar;
SetQuiverColor(q,jet,&#x27;mags&#x27;,mag,&#x27;range&#x27;,[-2 8]);  % Color range between -2 8 =&gt; all colors are not used
caxis([-2 8]);
set(gca,&#x27;Color&#x27;,&#x27;k&#x27;);</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>--------------------------------------------------
Authorship:
This code is heavily based from the answer by the user Suever on Stackoverflow forum
at: https://stackoverflow.com/questions/29632430/quiver3-arrow-color-corresponding-to-magnitude</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>I, Alexandre De Spiegeleer, only added minor changes to the original answer to have a bit more flexibility.
--------------------------------------------------
// Set default values</code></pre>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> SetQuiverColor(q,currentColormap,varargin)
<span class="comment">%--------------------------------------------------</span>
<span class="comment">% <span class="keyword">function</span> SetQuiverColor(q,currentColormap)</span>
<span class="comment">%</span>
<span class="comment">% INPUT:</span>
<span class="comment">%   q = handle to quiver plot</span>
<span class="comment">%   currentColormap = e.g. jet;</span>
<span class="comment">% OPTIONAL INPUT (<span class="string">'Field'</span>,value):</span>
<span class="comment">%   <span class="string">'range'</span> = [min,max]; % Range of the magnitude in the colorbar</span>
<span class="comment">%                          (used to possibly saturate or expand the color used compared to the vectors)</span>
<span class="comment">%   <span class="string">'mags'</span> = magnitude; % Actual magnitude of the vectors</span>
<span class="comment">%</span>
<span class="comment">% Example:</span>
<span class="comment">%   [x,y] = meshgrid(-2:.2:2,-1:.15:1);</span>
<span class="comment">%   z = x .* exp(-x.^2 - y.^2);</span>
<span class="comment">%   [u,v,w] = surfnorm(x,y,z);</span>
<span class="comment">%   q = quiver3(x,y,z,u,v,w);</span>
<span class="comment">%   mag = 1+3.*rand(size(u));   % Creates number between 1 and 4</span>
<span class="comment">%   colormap(jet);</span>
<span class="comment">%   colorbar;</span>
<span class="comment">%   SetQuiverColor(q,jet,<span class="string">'mags'</span>,mag,<span class="string">'range'</span>,[-2 8]);  % Color range between -2 8 => all colors are not used</span>
<span class="comment">%   caxis([-2 8]);</span>
<span class="comment">%   set(gca,<span class="string">'Color'</span>,<span class="string">'k'</span>);</span>
<span class="comment">%</span>
<span class="comment">%--------------------------------------------------</span>
<span class="comment">%   Authorship:</span>
<span class="comment">%     This code is heavily based from the answer by the user Suever on Stackoverflow forum</span>
<span class="comment">%     at: https://stackoverflow.com/questions/29632430/quiver3-arrow-color-corresponding-to-magnitude</span>
<span class="comment">%</span>
<span class="comment">%     I, Alexandre De Spiegeleer, only added minor changes to the original answer to have a bit more flexibility.</span>
<span class="comment">%--------------------------------------------------</span>
<span class="comment">%// Set default values</span>
range = [];
mags = [];
<span class="comment">%// Read the optional range value</span>
<span class="keyword">if</span> find(strcmp(<span class="string">'range'</span>,varargin))
  range = varargin{ find(strcmp(<span class="string">'range'</span>,varargin))+1 };
<span class="keyword">end</span>
qU = q.UData(~isnan(q.UData));
qV = q.VData(~isnan(q.VData));
qW = q.WData(~isnan(q.WData));
<span class="comment">%// Compute/read the magnitude of the vectors</span>
<span class="keyword">if</span> find(strcmp(<span class="string">'mags'</span>,varargin))
  mags = varargin{ find(strcmp(<span class="string">'mags'</span>,varargin))+1 };
  mags = mags(~isnan(mags)&~isnan(q.UData));  <span class="comment">% This reshapes automatically</span>
<span class="keyword">else</span>
  mags = sqrt(sum(cat(2, qU, qV, ...
             reshape(qW, numel(qU), [])).^2, 2));
<span class="keyword">end</span>
<span class="comment">%// If range is auto, take range as the min and max of mags</span>
<span class="keyword">if</span> isstr(range) & strcmp(range,<span class="string">'auto'</span>)
  range = [min(mags) max(mags)];
<span class="keyword">end</span>
<span class="comment">%// Change value depending on the desired range</span>
<span class="keyword">if</span> ~isempty(range) & isnumeric(range) & numel(range)==2
  range = sort(range);
  mags(mags>range(2)) = range(2);
  mags(mags<range(1)) = range(1);
<span class="keyword">end</span>
<span class="comment">%// Now determine the color to make each arrow using a colormap</span>
<span class="keyword">if</span> ~isempty(range) & isnumeric(range) & numel(range)==2
  Edges = linspace(range(1),range(2),size(currentColormap, 1)+1);
  [~, ~, ind] = histcounts(mags, Edges);
<span class="keyword">else</span>
  [~, ~, ind] = histcounts(mags, size(currentColormap, 1));
<span class="keyword">end</span>
<span class="comment">%// Now map this to a colormap to get RGB</span>
cmap = uint8(ind2rgb(ind(:), currentColormap) * 255);
cmap(:,:,4) = 255;
cmap = permute(repmat(cmap, [1 3 1]), [2 1 3]);
<span class="comment">%// Color data</span>
cd_head = reshape(cmap(1:3,:,:), [], 4).<span class="string">';
cd_tail = reshape(cmap(1:2,:,:), [], 4).'</span>;
<span class="comment">%// We repeat each color 3 times (using 1:3 below) because each arrow has 3 vertices</span>
set(q.Head, <span class="string">'ColorBinding'</span>, <span class="string">'interpolated'</span>, <span class="string">'ColorData'</span>, cd_head);
<span class="comment">%// We repeat each color 2 times (using 1:2 below) because each tail has 2 vertices</span>
set(q.Tail, <span class="string">'ColorBinding'</span>, <span class="string">'interpolated'</span>, <span class="string">'ColorData'</span>, cd_tail);
</code></pre></div>
</div>
<div id='SetQuiverLength' class='doc-content' style='display: none;'>
<h1>--------------------------------------------------</h1>
<p>function SetQuiverLength(q,mags)</p>
<p>Function that sets the length of the quiver<br/>You can give a list of length (in x,y axis units), the function will rescale the vectors to the right length</p>
<p>Input: q    = handle to quiver plot, can be quiver or quiver3<br/>mags = Desired length of each vector in units of the x,y axis<br/>If mags is a scalar, all the vector will have that length<br/>Optional inputs: given as (&#x27;variable&#x27;,value)<br/>&#x27;HeadLength&#x27; = single value for the length of the head in units of the xyz axis.<br/>It is applied to all the vectors<br/>&#x27;HeadAngle&#x27; = angle between the two lines forming the head<br/>default=28.0724^\circ<br/>&#x27;RotHead&#x27;   = Angle [deg] by which the head will be rotated around the vector axis.<br/>This allows to set the head in different planes</p>
<h2>Note</h2>
<p>For some unknown reason, MATLAB does not always simply change the length of the vectors and requires a<br/>pause statement towards the end.<br/>Would your vectors not be the right size, increase the duration of the pause<br/>(or even better, suggest a solution that does not require a pause)</p>
<h2>Note</h2>
<p></p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>[x,y] = meshgrid(-2:.2:2,-1:.15:1);
z = x .* exp(-x.^2 - y.^2);
[u,v,w] = surfnorm(x,y,z);
q = quiver3(x,y,z,u,v,w); hold on; surf(x,y,z); hold off;
drawnow;                  % This is needed as, if the plot is not plotted, the VertexData for the quiver are not existent.
view(180,0);
mag = 0.1*ones(size(u));  % Length of the vectors : 0.1
SetQuiverLength(q,mag,&#x27;HeadLength&#x27;,0.05,&#x27;HeadAngle&#x27;,90);</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>--------------------------------------------------
Authorship:
Function made by Alexandre De Spiegeleer. Feel free to use it.
--------------------------------------------------
// Set default values of varargin</code></pre>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> SetQuiverLength(q,mags,varargin)
<span class="comment">%--------------------------------------------------</span>
<span class="comment">% <span class="keyword">function</span> SetQuiverLength(q,mags)</span>
<span class="comment">%</span>
<span class="comment">%   Function that sets the length of the quiver</span>
<span class="comment">%   You can give a list of length (in x,y axis units), the <span class="keyword">function</span> will rescale the vectors to the right length</span>
<span class="comment">%</span>
<span class="comment">% Input: q    = handle to quiver plot, can be quiver or quiver3</span>
<span class="comment">%        mags = Desired length of each vector in units of the x,y axis</span>
<span class="comment">%               If mags is a scalar, all the vector will have that length</span>
<span class="comment">% Optional inputs: given as (<span class="string">'variable'</span>,value)</span>
<span class="comment">%        <span class="string">'HeadLength'</span> = single value <span class="keyword">for</span> the length of the head in units of the xyz axis.</span>
<span class="comment">%                       It is applied to all the vectors</span>
<span class="comment">%        <span class="string">'HeadAngle'</span> = angle between the two lines forming the head</span>
<span class="comment">%                      default=28.0724^\circ</span>
<span class="comment">%        <span class="string">'RotHead'</span>   = Angle [deg] by which the head will be rotated around the vector axis.</span>
<span class="comment">%                      This allows to set the head in different planes</span>
<span class="comment">%</span>
<span class="comment">% NOTE: For some unknown reason, MATLAB does not always simply change the length of the vectors and requires a</span>
<span class="comment">%       pause statement towards the <span class="keyword">end</span>.</span>
<span class="comment">%       Would your vectors not be the right size, increase the duration of the pause</span>
<span class="comment">%       (or even better, suggest a solution that does not require a pause)</span>
<span class="comment">%</span>
<span class="comment">% Example:</span>
<span class="comment">%     [x,y] = meshgrid(-2:.2:2,-1:.15:1);</span>
<span class="comment">%     z = x .* exp(-x.^2 - y.^2);</span>
<span class="comment">%     [u,v,w] = surfnorm(x,y,z);</span>
<span class="comment">%     q = quiver3(x,y,z,u,v,w); hold on; surf(x,y,z); hold off;</span>
<span class="comment">%     drawnow;                  % This is needed as, <span class="keyword">if</span> the plot is not plotted, the VertexData <span class="keyword">for</span> the quiver are not existent.</span>
<span class="comment">%     view(180,0);</span>
<span class="comment">%     mag = 0.1*ones(size(u));  % Length of the vectors : 0.1</span>
<span class="comment">%     SetQuiverLength(q,mag,<span class="string">'HeadLength'</span>,0.05,<span class="string">'HeadAngle'</span>,90);</span>
<span class="comment">%</span>
<span class="comment">%--------------------------------------------------</span>
<span class="comment">%   Authorship:</span>
<span class="comment">%     Function made by Alexandre De Spiegeleer. Feel free to use it.</span>
<span class="comment">%--------------------------------------------------</span>
<span class="comment">%// Set default values of varargin</span>
HeadLength = [];
HeadAngle = [];
RotHead = [];
<span class="comment">%// Read the optional inputs</span>
<span class="keyword">if</span> find(strcmp(<span class="string">'HeadLength'</span>,varargin))
  HeadLength = varargin{ find(strcmp(<span class="string">'HeadLength'</span>,varargin))+1 };
<span class="keyword">end</span>
<span class="keyword">if</span> find(strcmp(<span class="string">'HeadAngle'</span>,varargin))
  HeadAngle = varargin{ find(strcmp(<span class="string">'HeadAngle'</span>,varargin))+1 };
<span class="keyword">end</span>
<span class="keyword">if</span> find(strcmp(<span class="string">'RotHead'</span>,varargin))
  RotHead = varargin{ find(strcmp(<span class="string">'RotHead'</span>,varargin))+1 };
<span class="keyword">end</span>
<span class="comment">%// Start by removing the autoscale option</span>
set(q,<span class="string">'AutoScale'</span>,<span class="string">'Off'</span>);
<span class="comment">%// Get the Head and Tail options</span>
H = get(q.Head);
T = get(q.Tail);
<span class="comment">%// Handle mags input</span>
<span class="keyword">if</span> isempty(mags)
  warning(<span class="string">'No input was given <span class="keyword">for</span> the length of the vectors. They are now all of length 1.'</span>);
  mags = ones(size(T.VertexData,2)/2,1);
<span class="keyword">elseif</span> numel(mags) == 1
  mags = repmat(mags,size(T.VertexData,2)/2,1);
<span class="keyword">elseif</span> size(mags) == size(q.XData)
  mags = reshape(mags,[],1);
<span class="keyword">elseif</span> isrow(mags)
  mags = mags<span class="string">';
<span class="keyword">elseif</span> numel(mags)~=size(T.VertexData,2)/2
  warning('</span>Different number of magnitudes and quiver vectors!<span class="string">');
  <span class="keyword">return</span>;
<span class="keyword">else</span>
  warning('</span>Bug when calling SetQuiverLength <span class="keyword">function</span>!<span class="string">');
  <span class="keyword">return</span>;
<span class="keyword">end</span>
<span class="keyword">if</span> find(mags<0)
  warning(['</span>At least one of the length is requested to be negative. <span class="string">' ...
          '</span>This will swap the direction of the vector(s)!<span class="string">']);
<span class="keyword">end</span>
<span class="comment">%// The data <span class="keyword">for</span> which there is no vector should be removed</span>
<span class="comment">%// as there is no Head or Tail data <span class="keyword">for</span> those.</span>
<span class="keyword">if</span> numel(mags) == numel(q.UData)
  mags(isnan(q.UData)) = [];
<span class="keyword">end</span>
<span class="comment">%// Reshape the head and the tail (It is easier to think about it then but requires some repmat and permute)</span>
<span class="comment">%// The head has 3 vertices and the tail has 2.</span>
Tail_ori = reshape(T.VertexData,size(T.VertexData,1),2,[]);
Head_ori = reshape(H.VertexData,size(H.VertexData,1),3,[]);
<span class="comment">%// Measure original length of Head and Tail</span>
Tail_length = squeeze(sqrt(sum(diff(Tail_ori,1,2).^2,1)));
Head_length = squeeze(sqrt(sum(diff(Head_ori(:,[1,2],:),1,2).^2,1)));
<span class="comment">%// Head-Tail original ratio</span>
Length_ratio = Head_length./Tail_length;
<span class="comment">%// New length of head</span>
<span class="keyword">if</span> isempty(HeadLength)
  Head_mag = mags.*Length_ratio;
  Head_mag = permute(Head_mag(:,:,ones(size(H.VertexData,1),1)),[3 2 1]);
<span class="keyword">elseif</span> ~isempty(HeadLength)
  Head_mag = repmat(HeadLength,[size(H.VertexData,1) 1 size(Head_ori,3)]);
<span class="keyword">end</span>
<span class="comment">%// Direction tail</span>
Tail_dir = diff(Tail_ori,1,2)./permute(Tail_length(:,:,ones(size(T.VertexData,1),1)),[3 2 1]);
<span class="comment">%// Directions of head</span>
Head_dir_a = diff(Head_ori(:,[2,1],:),1,2)./permute(Head_length(:,:,ones(size(H.VertexData,1),1)),[3 2 1]);
Head_dir_b = diff(Head_ori(:,[2,3],:),1,2)./permute(Head_length(:,:,ones(size(H.VertexData,1),1)),[3 2 1]);
<span class="comment">%// Set new HeadAngle by use of Rodrigues'</span> rotation formula</span>
<span class="keyword">if</span> ~isempty(HeadAngle)
  <span class="comment">% rotation axis:</span>
  k = cross(Head_dir_b,Head_dir_a,1)./sqrt(sum(cross(Head_dir_b,Head_dir_a,1).^2,1));
  <span class="comment">% Original angle:</span>
  alpha = acosd( dot(Head_dir_a,Head_dir_b,1) );
  <span class="comment">% Angle of rotation:</span>
  theta = (HeadAngle-alpha)/2;
  <span class="comment">% Rotation</span>
  ct = repmat(cosd(theta),size(H.VertexData,1),1,1);
  st = repmat(sind(theta),size(H.VertexData,1),1,1);
  Head_dir_a_r = Head_dir_a .* ct + ...
                cross(k,Head_dir_a,1) .* st + ...
                k .* repmat(dot(k,Head_dir_a,1),size(H.VertexData,1),1,1) .* (1-ct);
  ct = repmat(cosd(-theta),size(H.VertexData,1),1,1);
  st = repmat(sind(-theta),size(H.VertexData,1),1,1);
  Head_dir_b_r = Head_dir_b .* ct + ...
                cross(k,Head_dir_b,1) .* st + ...
                k .* repmat(dot(k,Head_dir_b,1),size(H.VertexData,1),1,1) .* (1-ct);
  Head_dir_a = Head_dir_a_r;
  Head_dir_b = Head_dir_b_r;
<span class="keyword">end</span>
<span class="comment">%// Set new RotHead by use of Rodrigues<span class="string">' rotation formula</span>
<span class="keyword">if</span> ~isempty(RotHead)
  <span class="comment">% rotation axis:</span>
  k = Tail_dir;
  <span class="comment">% Angle of rotation:</span>
  theta = RotHead;
  <span class="comment">% Rotation</span>
  ct = repmat(cosd(theta),size(H.VertexData,1),1,1);
  st = repmat(sind(theta),size(H.VertexData,1),1,1);
  Head_dir_a_r = Head_dir_a .* ct + ...
                cross(k,Head_dir_a,1) .* st + ...
                k .* repmat(dot(k,Head_dir_a,1),size(H.VertexData,1),1,1) .* (1-ct);
  Head_dir_b_r = Head_dir_b .* ct + ...
                cross(k,Head_dir_b,1) .* st + ...
                k .* repmat(dot(k,Head_dir_b,1),size(H.VertexData,1),1,1) .* (1-ct);
  Head_dir_a = Head_dir_a_r;
  Head_dir_b = Head_dir_b_r;
<span class="keyword">end</span>
<span class="comment">%// New Tail End = start of tail + magnitude*normalized direction</span>
TailVertex = Tail_ori;
TailVertex(:,2,:) = TailVertex(:,1,:) +  ...
            permute(mags(:,:,ones(size(T.VertexData,1),1)),[3 2 1]) .*  Tail_dir;
<span class="comment">%// Middle point of Head is same as <span class="keyword">end</span> of Tail</span>
HeadVertex = Head_ori;
HeadVertex(:,2,:) = TailVertex(:,2,:);
<span class="comment">%// Head vector a</span>
HeadVertex(:,1,:) = HeadVertex(:,2,:) + Head_mag .* Head_dir_a;
<span class="comment">%// Head vector b</span>
HeadVertex(:,3,:) = HeadVertex(:,2,:) + Head_mag .* Head_dir_b;
<span class="comment">%// If the vector is originally of size 0, the vectors are now NaN.</span>
<span class="comment">%// Change those back to have just a simple "single point"</span>
Idx_NaN = find(isnan(squeeze(TailVertex(1,<span class="keyword">end</span>,:))));
TailVertex(:,<span class="keyword">end</span>,Idx_NaN) = TailVertex(:,1,Idx_NaN);
HeadVertex(:,:,Idx_NaN) = repmat(TailVertex(:,1,Idx_NaN),1,3,1);
<span class="comment">%// Reshape the data</span>
HeadVertex = reshape(HeadVertex,size(H.VertexData,1),[]);
TailVertex = reshape(TailVertex,size(T.VertexData,1),[]);
<span class="comment">%// Don'</span>t ask me about this line ...</span>
<span class="comment">%// Matlab sucks and does not do the change graphically <span class="keyword">if</span> I don<span class="string">'t have a pause or a keyboard ...</span>
pause(0.0102)
<span class="comment">%// Set the data to the quiver properties</span>
set(q.Head,'</span>VertexData<span class="string">',HeadVertex);
set(q.Tail,'</span>VertexData',TailVertex);
</code></pre></div>
</div>
<div id='Yao_template' class='doc-content' style='display: none;'>
<h1>Second template to retrieve Billy&#x27;s paper 2 simulation data</h1>
<p>rev. 2024/04/29</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% Second template to retrieve Billy<span class="string">'s paper 2 simulation data </span>
<span class="comment">% rev. 2024/04/29</span>

<span class="comment">% 2024/04/29 retrive 3D data around the top of the pillar</span>

<span class="comment">% SUMMARY</span>

<span class="comment">% This MATLAB script is a comprehensive framework <span class="keyword">for</span> analyzing fluid dynamics simulations, specifically focusing on the distribution and movement of particles or beads in a fluid environment. Key functionalities include:</span>
<span class="comment">% </span>
<span class="comment">% 1. Environment Setup:</span>
<span class="comment">%   Initializes the simulation environment by clearing variables, setting up output folders, and defining file paths to simulation data, with adjustments <span class="keyword">for</span> periodic boundary conditions (PBC).</span>
<span class="comment">% 2. Data Retrieval:</span>
<span class="comment">%   Loads simulation data from specified file paths, handling different configurations and viscosity models.</span>

<span class="comment">%% Definitions (it is a script accepting ONE variable and FLAGS)</span>
<span class="comment">%</span>
<span class="comment">%   List of of variables</span>
<span class="comment">%           tframe <-- use this variable a in <span class="keyword">for</span>-loop or choose a particular frame before calling this script</span>
<span class="comment">%       tframelist (not used)</span>
<span class="comment">%</span>
<span class="comment">%   List of available FLAGS</span>
<span class="comment">%       RESETPREFETCH forces all prefetch files to be regenerated in true (default=false)</span>
<span class="comment">%              PLOTON enables to plot results (default=true)</span>
<span class="comment">%             PRINTON prints figures as PNG images <span class="keyword">for</span> control (in outputfolder) (default=false)</span>
<span class="comment">%              SAVEON saves the results R0 (original), R1 (informed) (default=true)</span>
<span class="comment">%           OVERWRITE enables already saved results to overwritte (default=false)</span>

<span class="comment">% close, delete everything except variables and FLAGS</span>
clc
close all
clearvars -except tframe tframelist RESETPREFETCH PLOTON PRINTON SAVEON OVERWRITE
t0_ = clock;

<span class="comment">% check folders</span>
outputfolder = fullfile(pwd,'</span>preproduction<span class="string">');
savefolder = fullfile(pwd,'</span>results<span class="string">');
prefetchfolder = fullfile(pwd,'</span>prefetch<span class="string">');
<span class="keyword">if</span> ~exist(outputfolder,'</span>dir<span class="string">'), mkdir(outputfolder); <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(prefetchfolder,'</span>dir<span class="string">'), mkdir(prefetchfolder); <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(savefolder,'</span>dir<span class="string">'), mkdir(savefolder); <span class="keyword">end</span>

<span class="comment">% Assign default values <span class="keyword">if</span> needed</span>
<span class="keyword">if</span> ~exist('</span>RESETPREFETCH<span class="string">','</span>var<span class="string">'), RESETPREFETCH = false; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist('</span>PLOTON<span class="string">','</span>var<span class="string">'), PLOTON = true; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist('</span>PRINTON<span class="string">','</span>var<span class="string">'), PRINTON = false; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist('</span>SAVEON<span class="string">','</span>var<span class="string">'), SAVEON = true; <span class="keyword">end</span>
<span class="keyword">if</span> ~exist('</span>OVERWRITE<span class="string">','</span>var<span class="string">'), OVERWRITE = false; <span class="keyword">end</span>

<span class="comment">% Anonymous functions</span>
prefetchvar = @(varargin) fullfile(prefetchfolder,sprintf('</span>t<span class="comment">%0.4f_%s.mat<span class="string">',tframe,varargin{1}));</span>
isprefetch = @(varargin) exist(prefetchvar(varargin{1}),'</span>file<span class="string">') && ~RESETPREFETCH;
dispsection = @(s) dispf('</span>\n<span class="comment">%s\ntframe=%0.4g s \t[  %s  ]   elapsed time: %4g s\n%s<span class="string">',repmat('</span>*<span class="string">',1,120),tframe,regexprep(upper(s),'</span>.<span class="string">','</span>$0 <span class="string">'),etime(clock,t0_),repmat('</span>*<span class="string">',1,120)); %#ok<DETIM></span>
fighandle = @(id) formatfig(figure,'</span>figname<span class="string">',sprintf('</span>t<span class="comment">%0.3g_%s<span class="string">',tframe,id));</span>
printhandle = @(hfig) print_png(300,fullfile(outputfolder,[get(hfig,'</span>filename<span class="string">') '</span>.png<span class="string">']),'</span><span class="string">','</span><span class="string">',0,0,0);

<span class="comment">% results saved in two variables to avoid any confusion</span>
R0 = struct([]); <span class="comment">% reference data</span>
R1 = struct([]);  <span class="comment">% informed ones</span>

<span class="comment">%% path and metadata</span>
dispsection('</span>INITIALIZATION<span class="string">')
originalroot = '</span>/media/olivi/T7 Shield/Thomazo_V2<span class="string">';
<span class="keyword">if</span> exist(originalroot,'</span>dir<span class="string">')
    root = originalroot;
    rootlocal = fullfile(pwd,'</span>smalldumps<span class="string">');
    copymode = true;
<span class="keyword">else</span>
    root = fullfile(pwd,'</span>smalldumps<span class="string">');
    copymode = false;
<span class="keyword">end</span>

simfolder = ...
    struct(...
    '</span>A1<span class="string">',struct('</span>artificial<span class="string">',...
'</span>Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz<span class="string">',...
    '</span>Morris<span class="string">',...
'</span>Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz<span class="string">' ...
                ),...
    '</span>A2<span class="string">',struct('</span>artificial<span class="string">',...
'</span>./Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_2.tar.gz<span class="string">' ...
    ),...
    '</span>B1<span class="string">',struct('</span>Morris<span class="string">',...
'</span>./Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft.tar.gz<span class="string">' ...
    ),...
    '</span>B2<span class="string">',struct('</span>Morris<span class="string">',...
'</span>Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_1.tar.gz<span class="string">' ...
    ),...
    '</span>B3<span class="string">',struct('</span>Morris<span class="string">',...
'</span>/Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_2_3.tar.gz<span class="string">' ...
    ) ...
    );

<span class="comment">% selection (not change it <span class="keyword">if</span> you do not have the full dataset/hard disk attached to your system)</span>
config = '</span>A1<span class="string">';
viscosity = '</span>Morris<span class="string">';
sourcefolder= fullfile(root,rootdir(simfolder.(config).(viscosity)));
sourcefile = regexprep(lastdir(simfolder.(config).(viscosity)),'</span>.tar.gz$<span class="string">','</span><span class="string">');
dumpfile = fullfile(sourcefolder,sourcefile);
dispf('</span>config: <span class="comment">%s | viscosity: %s | source: %s<span class="string">',config,viscosity,dumpfile)</span>

<span class="comment">%% extract information</span>
dispsection('</span>OVERVIEW<span class="string">')
X0 = lamdumpread2(dumpfile); <span class="comment">% first frame</span>
natoms = X0.NUMBER;
timesteps = X0.TIMESTEPS;
X1 = lamdumpread2(dumpfile,'</span>usesplit<span class="string">',[],timesteps(2));
dt = (X1.TIME-X0.TIME)/(timesteps(2)-timesteps(1)); <span class="comment">% integration time step</span>
times = double(timesteps * dt); <span class="comment">% in seconds </span>
atomtypes = unique(X0.ATOMS.type);
ntimesteps = length(timesteps);
T = X0.ATOMS.type;
natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
[~,ind] = sort(natomspertype,'</span>descend<span class="string">');
<span class="comment">% Thomazo simulation details</span>
fluidtype  = ind(1);
pillartype = ind(2);
walltype   = ind(3);
spheretype = ind(4);
coords = {'</span>z<span class="string">','</span>x<span class="string">','</span>y<span class="string">'}; <span class="comment">% to match Thomazo'</span>s movies</span>
vcoords = cellfun(@(c) sprintf(<span class="string">'v<span class="comment">%s'</span>,c),coords,<span class="string">'UniformOutput'</span>,false);</span>
icoords = cellfun(@(c) find(ismember({<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>},c)),coords); <span class="comment">%<- use this index <span class="keyword">for</span> BOX</span>
<span class="comment">% Simulation parameters</span>
<span class="comment">% Billy choose a reference density of 900 kg/m3 <span class="keyword">for</span> a physical density of 1000 kg/m3</span>
<span class="comment">% Viscosity: 0.13 Pa.s</span>
mbead = 4.38e-12; <span class="comment">% kg</span>
rho = 1000; <span class="comment">% kg / m3 (density of the fluid)</span>
Vbead = mbead/rho;
dispf(<span class="string">'SUMMARY: natoms: <span class="comment">%d | dt: %0.3g s | rho: %0.4g'</span>,natoms,dt,rho)</span>

<span class="comment">%% selective copy of PREFETCH files (<span class="keyword">if</span> possible)</span>
<span class="keyword">if</span> copymode
    dispsection(<span class="string">'COPY'</span>)
    myprefetchfile = @(itime) sprintf(<span class="string">'<span class="comment">%s%09d.mat'</span>,<span class="string">'TIMESTEP_'</span>,itime);</span>
    myprefetchfolder = @(d) fullfile(d,sprintf(<span class="string">'PREFETCH_<span class="comment">%s'</span>,lastdir(dumpfile)));</span>
    destinationfolder = fullfile(rootlocal,rootdir(simfolder.(config).(viscosity)));
    sourcefolderPREFETCH = myprefetchfolder(sourcefolder);
    destinationfolderPREFETCH = myprefetchfolder(destinationfolder);
    <span class="comment">% Choose the frames needed here</span>
    tcopy = 0.0:0.01:1.2;
    <span class="comment">% files to copy</span>
    tfile = arrayfun(@(t) myprefetchfile(t), timesteps(unique(nearestpoint(tcopy,times))),<span class="string">'UniformOutput'</span>,false);
    oksource = all(cellfun(@(f) exist(fullfile(sourcefolderPREFETCH,f),<span class="string">'file'</span>),tfile));
    <span class="keyword">if</span> ~oksource, error(<span class="string">'the source folder is corrupted, please check'</span>), <span class="keyword">end</span>
    existingfiles = cellfun(@(f) exist(fullfile(destinationfolderPREFETCH,f),<span class="string">'file'</span>),tfile);
    dispf(<span class="string">'Number of files to copy: <span class="comment">%d (%d already available)'</span>,length(find(~existingfiles)),length(find(existingfiles)))</span>
    copysuccess = cellfun(@(f) copyfile(fullfile(sourcefolderPREFETCH,f),fullfile(destinationfolderPREFETCH,f)),tfile(~existingfiles));
    dispf(<span class="string">'<span class="comment">%d of %d files have been copied'</span>,length(find(copysuccess)),length(copysuccess));</span>
<span class="keyword">end</span>

<span class="comment">%% Estimate bead size from the first frame</span>
<span class="comment">% first estimate assuming that the bead is a cube</span>
dispsection(<span class="string">'BEAD SIZE'</span>)
fluidxyz0 = X0.ATOMS{T==fluidtype,coords};
boxdims = X0.BOX(:,2) - X0.BOX(:,1);
Vbead_guess = prod(boxdims)/natoms;
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
<span class="keyword">if</span> isprefetch(<span class="string">'verletList'</span>)
    load(prefetchvar(<span class="string">'verletList'</span>))
<span class="keyword">else</span>
    [verletList,cutoff,dmin,config,dist] = buildVerletList(fluidxyz0,cutoff);
    save(prefetchvar(<span class="string">'verletList'</span>),<span class="string">'verletList'</span>,<span class="string">'cutoff'</span>,<span class="string">'dmin'</span>,<span class="string">'config'</span>,<span class="string">'dist'</span>)
<span class="keyword">end</span>
rbead = dmin/2;
s = 2*rbead; <span class="comment">% separation distance</span>
h = 2*s;     <span class="comment">% smoothing length</span>
dispf(<span class="string">'SUMMARY: s: <span class="comment">%0.4g m | h: %0.4g m'</span>,s,h)</span>
<span class="comment">%% load the frame closest to simulation time: tframe</span>
<span class="comment">% with the mini dataset, are available:</span>
<span class="comment">% 0.30s 0.40s 0.45s 0.50s 0.55s 0.60s 0.65s 0.70s 0.75s 0.80s 0.85s 0.90s 0.95s 1.00s 1.05s 1.10s </span>
<span class="comment">% tframelist = [0.3 0.4 0.45:0.05:1.10]; % verysmalldumps</span>
tframelist = 0.0:0.01:1.2; <span class="comment">% updated time frames</span>
<span class="keyword">if</span> ~exist(<span class="string">'tframe'</span>,<span class="string">'var'</span>)
    tframe = 0.85; <span class="comment">%0.55; % s <-------------------- select time here</span>
<span class="keyword">else</span>
    tframe = tframelist(nearestpoint(tframe,tframelist)); <span class="comment">% restrict to existing tframes</span>
<span class="keyword">end</span>
iframe = nearestpoint(tframe,times); <span class="comment">% closest index</span>
Xframe = lamdumpread2(dumpfile,<span class="string">'usesplit'</span>,[],timesteps(iframe));
Xframe.ATOMS.isfluid = Xframe.ATOMS.type==fluidtype;
Xframe.ATOMS.ispillar = Xframe.ATOMS.type==pillartype;
Xframe.ATOMS.issphere = Xframe.ATOMS.type==spheretype;
Xframe.ATOMS.issolid = Xframe.ATOMS.type==spheretype | Xframe.ATOMS.type==pillartype;
fluidxyz = Xframe.ATOMS{Xframe.ATOMS.isfluid,coords};
fluidid = X0.ATOMS{Xframe.ATOMS.isfluid,<span class="string">'id'</span>};
pillarxyz = Xframe.ATOMS{Xframe.ATOMS.ispillar,coords};
pillarid = X0.ATOMS{Xframe.ATOMS.ispillar,<span class="string">'id'</span>};
spherexyz = Xframe.ATOMS{Xframe.ATOMS.issphere,coords};
sphereid = X0.ATOMS{Xframe.ATOMS.issphere,<span class="string">'id'</span>};
solidxyz = Xframe.ATOMS{Xframe.ATOMS.issolid,coords};
solidid = X0.ATOMS{Xframe.ATOMS.issolid,<span class="string">'id'</span>};
ztop = max(pillarxyz(:,3)); <span class="comment">% pillar top</span>

<span class="comment">% Definitions based on actual tframe</span>
dispsection = @(s) dispf(<span class="string">'\n<span class="comment">%s\ntframe=%0.4g s \t[  %s  ]   elapsed time: %4g s\n%s'</span>,repmat(<span class="string">'*'</span>,1,120),tframe,regexprep(upper(s),<span class="string">'.'</span>,<span class="string">'$0 '</span>),etime(clock,t0_),repmat(<span class="string">'*'</span>,1,120)); %#ok<DETIM></span>
prefetchvar = @(varargin) fullfile(prefetchfolder,sprintf(<span class="string">'t<span class="comment">%0.4f_%s.mat'</span>,tframe,varargin{1}));</span>
isprefetch = @(varargin) exist(prefetchvar(varargin{1}),<span class="string">'file'</span>) && ~RESETPREFETCH;
savefile = @() fullfile(savefolder,sprintf(<span class="string">'Rt.<span class="comment">%0.4f.mat'</span>,tframe));</span>


<span class="comment">%% Interpolate velocity field at z = ztop</span>
dispsection(<span class="string">'REFERENCE VELOCITY FIELD'</span>)
<span class="comment">% full box (note that atoms may be outside of this box)</span>
box = Xframe.BOX(icoords,:); <span class="comment">% note that the order is given by coords, here {<span class="string">'z'</span>}    {<span class="string">'x'</span>}    {<span class="string">'y'</span>}</span>
boxsize = diff(box,1,2);
<span class="comment">% fluidbox (box <span class="keyword">for</span> atoms to consider)</span>
xmin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{1}});
xmax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{1}});
ymin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{2}});
ymax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{2}});
zmin = min(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{3}});
zmax = max(Xframe.ATOMS{Xframe.ATOMS.isfluid,coords{3}});
fluidbox = [xmin xmax;ymin ymax;zmin zmax];
<span class="comment">% restrict interpolation to the viewbox</span>
viewbox = viewbox3d; <span class="comment">%fluidbox; viewbox(3,:) = [ztop-2*h ztop+2*h];</span>
viewboxsize = diff(viewbox,1,2);
insideviewbox = true(height(Xframe.ATOMS),1);
<span class="keyword">for</span> icoord = 1:3
    insideviewbox = insideviewbox ...
        & Xframe.ATOMS{:,coords{icoord}}>=viewbox(icoord,1) ...
        & Xframe.ATOMS{:,coords{icoord}}<=viewbox(icoord,2);
<span class="keyword">end</span>
XYZall  = Xframe.ATOMS{Xframe.ATOMS.isfluid,coords};  <span class="comment">% fluid kernel centers</span>
vXYZall = Xframe.ATOMS{Xframe.ATOMS.isfluid,vcoords}; <span class="comment">% velocity of fluid kernel centers</span>
XYZ  = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,coords};  <span class="comment">% fluid kernel centers</span>
vXYZ = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.isfluid,vcoords}; <span class="comment">% velocity of fluid kernel centers</span>
XYZp = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.ispillar,coords};  <span class="comment">% solid kernel centers</span>
XYZs = Xframe.ATOMS{insideviewbox & Xframe.ATOMS.issphere,coords}; 
rhobeadXYZall = Xframe.ATOMS.c_rho_smd(Xframe.ATOMS.isfluid); <span class="comment">% volume of the bead</span>
rhobeadXYZ = Xframe.ATOMS.c_rho_smd(insideviewbox & Xframe.ATOMS.isfluid); <span class="comment">% volume of the bead</span>
VbeadXYZall = mbead./rhobeadXYZall;
VbeadXYZ = mbead./rhobeadXYZ;


<span class="comment">% Plot</span>
<span class="keyword">if</span> PLOTON
    figure, hold on
    plot3D(XYZ,<span class="string">'bo'</span>)
    plot3D(XYZs,<span class="string">'ro'</span>)
    plot3D(XYZp,<span class="string">'go'</span>)
    view(3)
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='add_bead' class='doc-content' style='display: none;'>
<h1>Add bead along streamlines (considering quasi steady state)</h1>
<p>rev. 2024/03/12<br/>2024/03/12</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% Add bead along streamlines (considering quasi steady state)</span>
<span class="comment">% rev. 2024/03/12</span>
<span class="comment">% 2024/03/12</span>
<span class="comment">%%</span>
<span class="keyword">function</span> [x,y,Vl,l] = add_bead(s,rbead,dt)
nmax = ceil(s.l(<span class="keyword">end</span>)/(2*rbead));  <span class="comment">% maximum number of bead along the streamline</span>
[x,y,l,Vl] = deal(nan(nmax,1));   <span class="comment">% creat container</span>
l(1) = rbead; <span class="comment">% put first bead</span>
cn = 1; <span class="comment">% current number of bead</span>
<span class="keyword">while</span> l(1)<(s.l(<span class="keyword">end</span>)-rbead)
    x = interp1(s.l,s.x,l);
    y = interp1(s.l,s.y,l);
    Vl = interp1(s.l,s.Vl,l);
    l = l + Vl*dt; <span class="comment">% update the positions of beads</span>
    <span class="keyword">if</span> l(cn)>3*rbead
        l(cn+1) = rbead;
        cn = cn+1;
    <span class="keyword">end</span>
<span class="keyword">end</span>
x = interp1(s.l,s.x,l);
y = interp1(s.l,s.y,l);
Vl = interp1(s.l,s.Vl,l);
<span class="keyword">end</span></code></pre></div>
</div>
<div id='arrow' class='doc-content' style='display: none;'>
<h1>ARROW  Draw a line with an arrowhead.</h1>
<p>ARROW(Start,Stop) draws a line with an arrow from Start to Stop (points<br/>should be vectors of length 2 or 3, or matrices with 2 or 3<br/>columns), and returns the graphics handle of the arrow(s).</p>
<p>ARROW uses the mouse (click-drag) to create an arrow.</p>
<p>ARROW DEMO &amp; ARROW DEMO2 show 3-D &amp; 2-D demos of the capabilities of ARROW.</p>
<p>ARROW may be called with a normal argument list or a property-based list.<br/>ARROW(Start,Stop,Length,BaseAngle,TipAngle,Width,Page,CrossDir) is<br/>the full normal argument list, where all but the Start and Stop<br/>points are optional.  If you need to specify a later argument (e.g.,<br/>Page) but want default values of earlier ones (e.g., TipAngle),<br/>pass an empty matrix for the earlier ones (e.g., TipAngle=[]).</p>
<p>ARROW(&#x27;Property1&#x27;,PropVal1,&#x27;Property2&#x27;,PropVal2,...) creates arrows with the<br/>given properties, using default values for any unspecified or given as<br/>&#x27;default&#x27; or NaN.  Some properties used for line and patch objects are<br/>used in a modified fashion, others are passed directly to LINE, PATCH,<br/>or SET.  For a detailed properties explanation, call ARROW PROPERTIES.</p>
<p>Start         The starting points.                     B<br/>Stop          The end points.                         /|\           ^<br/>Length        Length of the arrowhead in pixels.     /|||\          |<br/>BaseAngle     Base angle in degrees (ADE).          //|||\\        L|<br/>TipAngle      Tip angle in degrees (ABC).          ///|||\\\       e|<br/>Width         Width of the base in pixels.        ////|||\\\\      n|<br/>Page          Use hardcopy proportions.          /////|D|\\\\\     g|<br/>CrossDir      Vector || to arrowhead plane.     ////  |||  \\\\    t|<br/>NormalDir     Vector out of arrowhead plane.   ///    |||    \\\   h|<br/>Ends          Which end has an arrowhead.     //&lt;-----&gt;||      \\   |<br/>ObjectHandles Vector of handles to update.   /   base |||        \  V<br/>E    angle||&lt;--------&gt;C<br/>ARROW(H,&#x27;Prop1&#x27;,PropVal1,...), where H is a                 |||tipangle<br/>vector of handles to previously-created arrows        |||<br/>and/or line objects, will update the previously-      |||<br/>created arrows according to the current view       --&gt;|A|&lt;-- width<br/>and any specified properties, and will convert<br/>two-point line objects to corresponding arrows.  ARROW(H) will update<br/>the arrows if the current view has changed.  Root, figure, or axes<br/>handles included in H are replaced by all descendant Arrow objects.</p>
<p>A property list can follow any specified normal argument list, e.g.,<br/>ARROW([1 2 3],[0 0 0],36,&#x27;BaseAngle&#x27;,60) creates an arrow from (1,2,3) to<br/>the origin, with an arrowhead of length 36 pixels and 60-degree base angle.</p>
<p>Normally, an ARROW is a PATCH object, so any valid PATCH property/value pairs<br/>can be passed, e.g., ARROW(Start,Stop,&#x27;EdgeColor&#x27;,&#x27;r&#x27;,&#x27;FaceColor&#x27;,&#x27;g&#x27;).<br/>ARROW will use LINE objects when requested by ARROW(...,&#x27;Type&#x27;,&#x27;line&#x27;) or,<br/>using LINE property/value pairs, ARROW(Start,Stop,&#x27;Type&#x27;,&#x27;line&#x27;,&#x27;Color&#x27;,&#x27;b&#x27;).</p>
<p>The basic arguments or properties can generally be vectorized to create<br/>multiple arrows with the same call.  This is done by passing a property<br/>with one row per arrow, or, if all arrows are to have the same property<br/>value, just one row may be specified.</p>
<p>You may want to execute AXIS(AXIS) before calling ARROW so it doesn&#x27;t change<br/>the axes on you; ARROW determines the sizes of arrow components BEFORE the<br/>arrow is plotted, so if ARROW changes axis limits, arrows may be malformed.</p>
<p>This version of ARROW uses features of MATLAB 6.x and is incompatible with<br/>earlier MATLAB versions (ARROW for MATLAB 4.2c is available separately);<br/>some problems with perspective plots still exist.</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [h,yy,zz] = arrow(varargin)
<span class="comment">% ARROW  Draw a line with an arrowhead.</span>
<span class="comment">%</span>
<span class="comment">%  ARROW(Start,Stop) draws a line with an arrow from Start to Stop (points</span>
<span class="comment">%        should be vectors of length 2 or 3, or matrices with 2 or 3</span>
<span class="comment">%        columns), and returns the graphics handle of the arrow(s).</span>
<span class="comment">%</span>
<span class="comment">%  ARROW uses the mouse (click-drag) to create an arrow.</span>
<span class="comment">%</span>
<span class="comment">%  ARROW DEMO & ARROW DEMO2 show 3-D & 2-D demos of the capabilities of ARROW.</span>
<span class="comment">%</span>
<span class="comment">%  ARROW may be called with a normal argument list or a property-based list.</span>
<span class="comment">%        ARROW(Start,Stop,Length,BaseAngle,TipAngle,Width,Page,CrossDir) is</span>
<span class="comment">%        the full normal argument list, where all but the Start and Stop</span>
<span class="comment">%        points are optional.  If you need to specify a later argument (e.g.,</span>
<span class="comment">%        Page) but want default values of earlier ones (e.g., TipAngle),</span>
<span class="comment">%        pass an empty matrix <span class="keyword">for</span> the earlier ones (e.g., TipAngle=[]).</span>
<span class="comment">%</span>
<span class="comment">%  ARROW(<span class="string">'Property1'</span>,PropVal1,<span class="string">'Property2'</span>,PropVal2,...) creates arrows with the</span>
<span class="comment">%        given properties, using default values <span class="keyword">for</span> any unspecified or given as</span>
<span class="comment">%        <span class="string">'default'</span> or NaN.  Some properties used <span class="keyword">for</span> line and patch objects are</span>
<span class="comment">%        used in a modified fashion, others are passed directly to LINE, PATCH,</span>
<span class="comment">%        or SET.  For a detailed properties explanation, call ARROW PROPERTIES.</span>
<span class="comment">%</span>
<span class="comment">%        Start         The starting points.                     B</span>
<span class="comment">%        Stop          The <span class="keyword">end</span> points.                         /|\           ^</span>
<span class="comment">%        Length        Length of the arrowhead in pixels.     /|||\          |</span>
<span class="comment">%        BaseAngle     Base angle in degrees (ADE).          //|||\\        L|</span>
<span class="comment">%        TipAngle      Tip angle in degrees (ABC).          ///|||\\\       e|</span>
<span class="comment">%        Width         Width of the base in pixels.        ////|||\\\\      n|</span>
<span class="comment">%        Page          Use hardcopy proportions.          /////|D|\\\\\     g|</span>
<span class="comment">%        CrossDir      Vector || to arrowhead plane.     ////  |||  \\\\    t|</span>
<span class="comment">%        NormalDir     Vector out of arrowhead plane.   ///    |||    \\\   h|</span>
<span class="comment">%        Ends          Which <span class="keyword">end</span> has an arrowhead.     //<----->||      \\   |</span>
<span class="comment">%        ObjectHandles Vector of handles to update.   /   base |||        \  V</span>
<span class="comment">%                                                    E    angle||<-------->C</span>
<span class="comment">%  ARROW(H,<span class="string">'Prop1'</span>,PropVal1,...), where H is a                 |||tipangle</span>
<span class="comment">%        vector of handles to previously-created arrows        |||</span>
<span class="comment">%        and/or line objects, will update the previously-      |||</span>
<span class="comment">%        created arrows according to the current view       -->|A|<-- width</span>
<span class="comment">%        and any specified properties, and will convert</span>
<span class="comment">%        two-point line objects to corresponding arrows.  ARROW(H) will update</span>
<span class="comment">%        the arrows <span class="keyword">if</span> the current view has changed.  Root, figure, or axes</span>
<span class="comment">%        handles included in H are replaced by all descendant Arrow objects.</span>
<span class="comment">%</span>
<span class="comment">%  A property list can follow any specified normal argument list, e.g.,</span>
<span class="comment">%  ARROW([1 2 3],[0 0 0],36,<span class="string">'BaseAngle'</span>,60) creates an arrow from (1,2,3) to</span>
<span class="comment">%  the origin, with an arrowhead of length 36 pixels and 60-degree base angle.</span>
<span class="comment">%</span>
<span class="comment">%  Normally, an ARROW is a PATCH object, so any valid PATCH property/value pairs</span>
<span class="comment">%  can be passed, e.g., ARROW(Start,Stop,<span class="string">'EdgeColor'</span>,<span class="string">'r'</span>,<span class="string">'FaceColor'</span>,<span class="string">'g'</span>).</span>
<span class="comment">%  ARROW will use LINE objects when requested by ARROW(...,<span class="string">'Type'</span>,<span class="string">'line'</span>) or,</span>
<span class="comment">%  using LINE property/value pairs, ARROW(Start,Stop,<span class="string">'Type'</span>,<span class="string">'line'</span>,<span class="string">'Color'</span>,<span class="string">'b'</span>).</span>
<span class="comment">%</span>
<span class="comment">%  The basic arguments or properties can generally be vectorized to create</span>
<span class="comment">%  multiple arrows with the same call.  This is done by passing a property</span>
<span class="comment">%  with one row per arrow, or, <span class="keyword">if</span> all arrows are to have the same property</span>
<span class="comment">%  value, just one row may be specified.</span>
<span class="comment">%</span>
<span class="comment">%  You may want to execute AXIS(AXIS) before calling ARROW so it doesn<span class="string">'t change</span>
<span class="comment">%  the axes on you; ARROW determines the sizes of arrow components BEFORE the</span>
<span class="comment">%  arrow is plotted, so <span class="keyword">if</span> ARROW changes axis limits, arrows may be malformed.</span>
<span class="comment">%</span>
<span class="comment">%  This version of ARROW uses features of MATLAB 6.x and is incompatible with</span>
<span class="comment">%  earlier MATLAB versions (ARROW <span class="keyword">for</span> MATLAB 4.2c is available separately);</span>
<span class="comment">%  some problems with perspective plots still exist.</span>

<span class="comment">% Copyright (c)1995-2016, Dr. Erik A. Johnson <JohnsonE@usc.edu>, 5/25/2016</span>
<span class="comment">% http://www.usc.edu/civil_eng/johnsone/</span>

<span class="comment">% Revision history:</span>
<span class="comment">%    5/25/16  EAJ  Add documentation of '</span>Type<span class="string">','</span>line<span class="string">'</span>
<span class="comment">%                  Add documentation of how to set color</span>
<span class="comment">%                  Add '</span>Color<span class="string">' property (which sets both '</span>EdgeColor<span class="string">' and '</span>FaceColor<span class="string">' <span class="keyword">for</span> patch objects)</span>
<span class="comment">%    5/24/16  EAJ  Remove '</span>EraseMode<span class="string">' in HG2</span>
<span class="comment">%    7/16/14  EAJ  R2014b HandleGraphics2 compatibility</span>
<span class="comment">%    7/14/14  EAJ  5/20/13 patch extension didn'</span>t work right in HG2</span>
<span class="comment">%                    so break the arrow along its length instead</span>
<span class="comment">%    5/20/13  EAJ  Extend patch line one more segment so EPS/PDF printed versions</span>
<span class="comment">%                    have nice rounded tips when the LineWidth is wider</span>
<span class="comment">%    2/06/13  EAJ  Add ShortenLength property to shorten length <span class="keyword">if</span> arrow is short</span>
<span class="comment">%    1/24/13  EAJ  Remove some old comments.</span>
<span class="comment">%    5/20/09  EAJ  Fix view direction in (3D) demo.</span>
<span class="comment">%    6/26/08  EAJ  Replace eval(<span class="string">'trycmd'</span>,<span class="string">'catchcmd'</span>) with try, trycmd; catch,</span>
<span class="comment">%                    catchcmd; <span class="keyword">end</span>; -- break<span class="string">'s MATLAB 5 compatibility.</span>
<span class="comment">%    8/26/03  EAJ  Eliminate OpenGL attempted fix since it didn'</span>t fix anyway.</span>
<span class="comment">%   11/15/02  EAJ  Accomodate how MATLAB 6.5 handles NaN and logicals</span>
<span class="comment">%    7/28/02  EAJ  Tried (but failed) work-around <span class="keyword">for</span> MATLAB 6.x / OpenGL bug</span>
<span class="comment">%                    <span class="keyword">if</span> zero <span class="string">'Width'</span> or not double-ended</span>
<span class="comment">%   11/10/99  EAJ  Add logical() to eliminate zero index problem in MATLAB 5.3.</span>
<span class="comment">%   11/10/99  EAJ  Corrected warning <span class="keyword">if</span> axis limits changed on multiple axes.</span>
<span class="comment">%   11/10/99  EAJ  Update e-mail address.</span>
<span class="comment">%    2/10/99  EAJ  Some documentation updating.</span>
<span class="comment">%    2/24/98  EAJ  Fixed bug <span class="keyword">if</span> Start~=Stop but both colinear with viewpoint.</span>
<span class="comment">%    8/14/97  EAJ  Added workaround <span class="keyword">for</span> MATLAB 5.1 scalar logical transpose bug.</span>
<span class="comment">%    7/21/97  EAJ  Fixed a few misc bugs.</span>
<span class="comment">%    7/14/97  EAJ  Make arrow([],<span class="string">'Prop'</span>,...) do nothing (no old handles)</span>
<span class="comment">%    6/23/97  EAJ  MATLAB 5 compatible version, release.</span>
<span class="comment">%    5/27/97  EAJ  Added Line Arrows back in.  Corrected a few bugs.</span>
<span class="comment">%    5/26/97  EAJ  Changed missing Start/Stop to mouse-selected arrows.</span>
<span class="comment">%    5/19/97  EAJ  MATLAB 5 compatible version, beta.</span>
<span class="comment">%    4/13/97  EAJ  MATLAB 5 compatible version, alpha.</span>
<span class="comment">%    1/31/97  EAJ  Fixed bug with multiple arrows and unspecified Z coords.</span>
<span class="comment">%   12/05/96  EAJ  Fixed one more bug with log plots and NormalDir specified</span>
<span class="comment">%   10/24/96  EAJ  Fixed bug with log plots and NormalDir specified</span>
<span class="comment">%   11/13/95  EAJ  Corrected handling <span class="keyword">for</span> <span class="string">'reverse'</span> axis directions</span>
<span class="comment">%   10/06/95  EAJ  Corrected occasional conflict with SUBPLOT</span>
<span class="comment">%    4/24/95  EAJ  A major rewrite.</span>
<span class="comment">%    Fall 94  EAJ  Original code.</span>

<span class="comment">% Things to be done:</span>
<span class="comment">%  - in the arrow_clicks section, prompt by printing to the screen so that</span>
<span class="comment">%    the user knows what<span class="string">'s going on; also make sure the figure is brought</span>
<span class="comment">%    to the front.</span>
<span class="comment">%  - segment parsing, computing, and plotting into separate subfunctions</span>
<span class="comment">%  - change computing from Xform to Camera paradigms</span>
<span class="comment">%     + this will help especially with 3-D perspective plots</span>
<span class="comment">%     + <span class="keyword">if</span> the WarpToFill section works right, remove warning code</span>
<span class="comment">%     + when perpsective works properly, remove perspective warning code</span>
<span class="comment">%  - add cell property values and struct property name/values (like get/set)</span>
<span class="comment">%  - get rid of NaN as the "default" data label</span>
<span class="comment">%     + perhaps change userdata to a struct and don'</span>t include (or leave</span>
<span class="comment">%       empty) the values specified as default; or use a cell containing</span>
<span class="comment">%       an empty matrix <span class="keyword">for</span> a default value</span>
<span class="comment">%  - add functionality of GET to retrieve current values of ARROW properties</span>
<span class="comment">% </span>
<span class="comment">% New list of things to be done:</span>
<span class="comment">%  - rewrite as a graphics or class object that updates itself in real time</span>
<span class="comment">%    (but have a <span class="string">'Static'</span> or <span class="string">'DoNotUpdate'</span> property to avoid updating)</span>

<span class="comment">% Permission is granted to distribute ARROW with the toolboxes <span class="keyword">for</span> the book</span>
<span class="comment">% "Solving Solid Mechanics Problems with MATLAB 5", by F. Golnaraghi et al.</span>
<span class="comment">% (Prentice Hall, 1999).</span>

<span class="comment">% Permission is granted to Dr. Josef Bigun to distribute ARROW with his</span>
<span class="comment">% software to reproduce the figures in his image analysis text.</span>

<span class="comment">% global variable initialization</span>
persistent ARROW_PERSP_WARN ARROW_STRETCH_WARN ARROW_AXLIMITS ARROW_AX
<span class="keyword">if</span> isempty(ARROW_PERSP_WARN  ), ARROW_PERSP_WARN  =1; <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(ARROW_STRETCH_WARN), ARROW_STRETCH_WARN=1; <span class="keyword">end</span>;

<span class="comment">% Handle callbacks</span>
<span class="keyword">if</span> (nargin>0 & isstr(varargin{1}) & strcmp(lower(varargin{1}),<span class="string">'callback'</span>)),
	arrow_callback(varargin{2:<span class="keyword">end</span>}); <span class="keyword">return</span>;
<span class="keyword">end</span>;

<span class="comment">% Are we doing the demo?</span>
c = sprintf(<span class="string">'\n'</span>);
<span class="keyword">if</span> (nargin==1 & isstr(varargin{1})),
	arg1 = lower(varargin{1});
	<span class="keyword">if</span> strncmp(arg1,<span class="string">'prop'</span>,4), arrow_props;
	<span class="keyword">elseif</span> strncmp(arg1,<span class="string">'demo'</span>,4)
		clf reset
		demo_info = arrow_demo;
		<span class="keyword">if</span> ~strncmp(arg1,<span class="string">'demo2'</span>,5),
			hh=arrow_demo3(demo_info);
		<span class="keyword">else</span>,
			hh=arrow_demo2(demo_info);
		<span class="keyword">end</span>;
		<span class="keyword">if</span> (nargout>=1), h=hh; <span class="keyword">end</span>;
	<span class="keyword">elseif</span> strncmp(arg1,<span class="string">'fixlimits'</span>,3),
		arrow_fixlimits(ARROW_AX,ARROW_AXLIMITS);
		ARROW_AXLIMITS=[]; ARROW_AX=[];
	<span class="keyword">elseif</span> strncmp(arg1,<span class="string">'help'</span>,4),
		disp(help(mfilename));
	<span class="keyword">else</span>,
		error([upper(mfilename) <span class="string">' got an unknown single-argument string '</span><span class="string">''</span> deblank(arg1) <span class="string">''</span><span class="string">'.'</span>]);
	<span class="keyword">end</span>;
	<span class="keyword">return</span>;
<span class="keyword">end</span>;

<span class="comment">% Check # of arguments</span>
<span class="keyword">if</span> (nargout>3), error([upper(mfilename) <span class="string">' produces at most 3 output arguments.'</span>]); <span class="keyword">end</span>;

<span class="comment">% find first property number</span>
firstprop = nargin+1;
<span class="keyword">for</span> k=1:length(varargin), <span class="keyword">if</span> ~isnumeric(varargin{k}) && ~all(ishandle(varargin{k})), firstprop=k; break; <span class="keyword">end</span>; <span class="keyword">end</span>; <span class="comment">%eaj 5/24/16   <span class="keyword">for</span> k=1:length(varargin), <span class="keyword">if</span> ~isnumeric(varargin{k}), firstprop=k; break; <span class="keyword">end</span>; <span class="keyword">end</span>;</span>
lastnumeric = firstprop-1;

<span class="comment">% check property list</span>
<span class="keyword">if</span> (firstprop<=nargin),
	<span class="keyword">for</span> k=firstprop:2:nargin,
		curarg = varargin{k};
		<span class="keyword">if</span> ~isstr(curarg) | sum(size(curarg)>1)>1,
			error([upper(mfilename) <span class="string">' requires that a property name be a single string.'</span>]);
		<span class="keyword">end</span>;
	<span class="keyword">end</span>;
	<span class="keyword">if</span> (rem(nargin-firstprop,2)~=1),
		error([upper(mfilename) <span class="string">' requires that the property '</span><span class="string">''</span> ...
		       varargin{nargin} <span class="string">''</span><span class="string">' be paired with a property value.'</span>]);
	<span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="comment">% default output</span>
<span class="keyword">if</span> (nargout>0), h=[]; <span class="keyword">end</span>;
<span class="keyword">if</span> (nargout>1), yy=[]; <span class="keyword">end</span>;
<span class="keyword">if</span> (nargout>2), zz=[]; <span class="keyword">end</span>;

<span class="comment">% set values to empty matrices</span>
start      = [];
stop       = [];
len        = [];
baseangle  = [];
tipangle   = [];
wid        = [];
page       = [];
crossdir   = [];
ends       = [];
shorten    = [];
ax         = [];
oldh       = [];
ispatch    = [];
defstart      = [NaN NaN NaN];
defstop       = [NaN NaN NaN];
deflen        = 16;
defbaseangle  = 90;
deftipangle   = 16;
defwid        = 0;
defpage       = 0;
defcrossdir   = [NaN NaN NaN];
defends       = 1;
defshorten    = 0;
defoldh       = [];
defispatch    = 1;

<span class="comment">% The <span class="string">'Tag'</span> we<span class="string">'ll put on our arrows</span>
ArrowTag = '</span>Arrow<span class="string">';

<span class="comment">% check <span class="keyword">for</span> oldstyle arguments</span>
<span class="keyword">if</span> (firstprop==2),
	<span class="comment">% assume arg1 is a set of handles</span>
	oldh = varargin{1}(:);
	<span class="keyword">if</span> isempty(oldh), <span class="keyword">return</span>; <span class="keyword">end</span>;
<span class="keyword">elseif</span> (firstprop>9),
	error([upper(mfilename) '</span> takes at most 8 non-property arguments.<span class="string">']);
<span class="keyword">elseif</span> (firstprop>2),
	{start,stop,len,baseangle,tipangle,wid,page,crossdir};
	args = [varargin(1:firstprop-1) cell(1,length(ans)-(firstprop-1))];
	[start,stop,len,baseangle,tipangle,wid,page,crossdir] = deal(args{:});
<span class="keyword">end</span>;

<span class="comment">% parse property pairs</span>
extraprops={};
<span class="keyword">for</span> k=firstprop:2:nargin,
	prop = varargin{k};
	val  = varargin{k+1};
	prop = [lower(prop(:)'</span>) <span class="string">'      '</span>];
	<span class="keyword">if</span>     strncmp(prop,<span class="string">'start'</span>  ,5),   start      = val;
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'stop'</span>   ,4),   stop       = val;
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'len'</span>    ,3),   len        = val(:);
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'base'</span>   ,4),   baseangle  = val(:);
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'tip'</span>    ,3),   tipangle   = val(:);
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'wid'</span>    ,3),   wid        = val(:);
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'page'</span>   ,4),   page       = val;
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'cross'</span>  ,5),   crossdir   = val;
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'norm'</span>   ,4),   <span class="keyword">if</span> (isstr(val)), crossdir=val; <span class="keyword">else</span>, crossdir=val*sqrt(-1); <span class="keyword">end</span>;
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'<span class="keyword">end</span>'</span>    ,3),   ends       = val;
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'shorten'</span>,5),   shorten    = val;
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'object'</span> ,6),   oldh       = val(:);
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'handle'</span> ,6),   oldh       = val(:);
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'type'</span>   ,4),   ispatch    = val;
	<span class="keyword">elseif</span> strncmp(prop,<span class="string">'userd'</span>  ,5),   <span class="comment">%ignore it</span>
	<span class="keyword">else</span>,
		<span class="comment">% make sure it is a valid patch or line property</span>
		try
			get(0,[<span class="string">'DefaultPatch'</span> varargin{k}]);
		catch
			errstr = lasterr;
			try
				get(0,[<span class="string">'DefaultLine'</span> varargin{k}]);
			catch
				errstr(1:max(find(errstr==char(13)|errstr==char(10)))) = <span class="string">''</span>;
				error([upper(mfilename) <span class="string">' got '</span> errstr]);
			<span class="keyword">end</span>
		<span class="keyword">end</span>;
		extraprops={extraprops{:},varargin{k},val};
	<span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="comment">% Check <span class="keyword">if</span> we got <span class="string">'default'</span> values</span>
start     = arrow_defcheck(start    ,defstart    ,<span class="string">'Start'</span>        );
stop      = arrow_defcheck(stop     ,defstop     ,<span class="string">'Stop'</span>         );
len       = arrow_defcheck(len      ,deflen      ,<span class="string">'Length'</span>       );
baseangle = arrow_defcheck(baseangle,defbaseangle,<span class="string">'BaseAngle'</span>    );
tipangle  = arrow_defcheck(tipangle ,deftipangle ,<span class="string">'TipAngle'</span>     );
wid       = arrow_defcheck(wid      ,defwid      ,<span class="string">'Width'</span>        );
crossdir  = arrow_defcheck(crossdir ,defcrossdir ,<span class="string">'CrossDir'</span>     );
page      = arrow_defcheck(page     ,defpage     ,<span class="string">'Page'</span>         );
ends      = arrow_defcheck(ends     ,defends     ,<span class="string">''</span>             );
shorten   = arrow_defcheck(shorten  ,defshorten  ,<span class="string">''</span>             );
oldh      = arrow_defcheck(oldh     ,[]          ,<span class="string">'ObjectHandles'</span>);
ispatch   = arrow_defcheck(ispatch  ,defispatch  ,<span class="string">''</span>             );

<span class="comment">% check transpose on arguments</span>
[m,n]=size(start   );   <span class="keyword">if</span> any(m==[2 3])&(n==1|n>3),   start    = start<span class="string">';      <span class="keyword">end</span>;
[m,n]=size(stop    );   <span class="keyword">if</span> any(m==[2 3])&(n==1|n>3),   stop     = stop'</span>;       <span class="keyword">end</span>;
[m,n]=size(crossdir);   <span class="keyword">if</span> any(m==[2 3])&(n==1|n>3),   crossdir = crossdir<span class="string">';   <span class="keyword">end</span>;

<span class="comment">% convert strings to numbers</span>
<span class="keyword">if</span> ~isempty(ends) & isstr(ends),
	endsorig = ends;
	[m,n] = size(ends);
	col = lower([ends(:,1:min(3,n)) ones(m,max(0,3-n))*'</span> <span class="string">']);
	ends = NaN*ones(m,1);
	oo = ones(1,m);
	ii=find(all(col'</span>==[<span class="string">'non'</span>]<span class="string">'*oo)'</span>); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*0; <span class="keyword">end</span>;
	ii=find(all(col<span class="string">'==['</span>sto<span class="string">']'</span>*oo)<span class="string">'); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*1; <span class="keyword">end</span>;
	ii=find(all(col'</span>==[<span class="string">'sta'</span>]<span class="string">'*oo)'</span>); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*2; <span class="keyword">end</span>;
	ii=find(all(col<span class="string">'==['</span>bot<span class="string">']'</span>*oo)<span class="string">'); <span class="keyword">if</span> ~isempty(ii), ends(ii)=ones(length(ii),1)*3; <span class="keyword">end</span>;
	<span class="keyword">if</span> any(isnan(ends)),
		ii = min(find(isnan(ends)));
		error([upper(mfilename) '</span> does not recognize <span class="string">''</span><span class="string">' deblank(endsorig(ii,:)) '</span><span class="string">''</span> as a valid <span class="string">''</span>Ends<span class="string">''</span> value.<span class="string">']);
	<span class="keyword">end</span>;
<span class="keyword">else</span>,
	ends = ends(:);
<span class="keyword">end</span>;
<span class="keyword">if</span> ~isempty(ispatch) & isstr(ispatch),
	col = lower(ispatch(:,1));
	patchchar='</span>p<span class="string">'; linechar='</span>l<span class="string">'; defchar='</span> <span class="string">';
	mask = col~=patchchar & col~=linechar & col~=defchar;
	<span class="keyword">if</span> any(mask),
		error([upper(mfilename) '</span> does not recognize <span class="string">''</span><span class="string">' deblank(ispatch(min(find(mask)),:)) '</span><span class="string">''</span> as a valid <span class="string">''</span>Type<span class="string">''</span> value.<span class="string">']);
	<span class="keyword">end</span>;
	ispatch = (col==patchchar)*1 + (col==linechar)*0 + (col==defchar)*defispatch;
<span class="keyword">else</span>,
	ispatch = ispatch(:);
<span class="keyword">end</span>;
oldh = oldh(:);

<span class="comment">% check object handles</span>
<span class="keyword">if</span> ~all(ishandle(oldh)), error([upper(mfilename) '</span> got invalid object handles.<span class="string">']); <span class="keyword">end</span>;

<span class="comment">% expand root, figure, and axes handles</span>
<span class="keyword">if</span> ~isempty(oldh),
	ohtype = get(oldh,'</span>Type<span class="string">');
	mask = strcmp(ohtype,'</span>root<span class="string">') | strcmp(ohtype,'</span>figure<span class="string">') | strcmp(ohtype,'</span>axes<span class="string">');
	<span class="keyword">if</span> any(mask),
		oldh = num2cell(oldh);
		<span class="keyword">for</span> ii=find(mask)'</span>,
			oldh(ii) = {findobj(oldh{ii},<span class="string">'Tag'</span>,ArrowTag)};
		<span class="keyword">end</span>;
		oldh = cat(1,oldh{:});
		<span class="keyword">if</span> isempty(oldh), <span class="keyword">return</span>; <span class="keyword">end</span>; <span class="comment">% no arrows to modify, so just leave</span>
	<span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="comment">% largest argument length</span>
[mstart,junk]=size(start); [mstop,junk]=size(stop); [mcrossdir,junk]=size(crossdir);
argsizes = [length(oldh) mstart mstop                              ...
            length(len) length(baseangle) length(tipangle)         ...
			length(wid) length(page) mcrossdir length(ends) length(shorten)];
args=[<span class="string">'length(ObjectHandle)  '</span>; ...
      <span class="string">'#rows(Start)          '</span>; ...
      <span class="string">'#rows(Stop)           '</span>; ...
      <span class="string">'length(Length)        '</span>; ...
      <span class="string">'length(BaseAngle)     '</span>; ...
      <span class="string">'length(TipAngle)      '</span>; ...
      <span class="string">'length(Width)         '</span>; ...
      <span class="string">'length(Page)          '</span>; ...
      <span class="string">'#rows(CrossDir)       '</span>; ...
      <span class="string">'#rows(Ends)           '</span>; ...
      <span class="string">'length(ShortenLength) '</span>];
<span class="keyword">if</span> (any(imag(crossdir(:))~=0)),
	args(9,:) = <span class="string">'#rows(NormalDir)      '</span>;
<span class="keyword">end</span>;
<span class="keyword">if</span> isempty(oldh),
	narrows = max(argsizes);
<span class="keyword">else</span>,
	narrows = length(oldh);
<span class="keyword">end</span>;
<span class="keyword">if</span> (narrows<=0), narrows=1; <span class="keyword">end</span>;

<span class="comment">% Check size of arguments</span>
ii = find((argsizes~=0)&(argsizes~=1)&(argsizes~=narrows));
<span class="keyword">if</span> ~isempty(ii),
	s = args(ii<span class="string">',:);
	<span class="keyword">while</span> ((size(s,2)>1)&((abs(s(:,size(s,2)))==0)|(abs(s(:,size(s,2)))==abs('</span> <span class="string">')))),
		s = s(:,1:size(s,2)-1);
	<span class="keyword">end</span>;
	s = [ones(length(ii),1)*[upper(mfilename) '</span> requires that  <span class="string">'] s ...
	     ones(length(ii),1)*['</span>  equal the # of arrows (<span class="string">' num2str(narrows) '</span>).<span class="string">' c]];
	s = s'</span>;
	s = s(:)<span class="string">';
	s = s(1:length(s)-1);
	error(setstr(s));
<span class="keyword">end</span>;

<span class="comment">% check element length in Start, Stop, and CrossDir</span>
<span class="keyword">if</span> ~isempty(start),
	[m,n] = size(start);
	<span class="keyword">if</span> (n==2),
		start = [start NaN*ones(m,1)];
	<span class="keyword">elseif</span> (n~=3),
		error([upper(mfilename) '</span> requires 2- or 3-element Start points.<span class="string">']);
	<span class="keyword">end</span>;
<span class="keyword">end</span>;
<span class="keyword">if</span> ~isempty(stop),
	[m,n] = size(stop);
	<span class="keyword">if</span> (n==2),
		stop = [stop NaN*ones(m,1)];
	<span class="keyword">elseif</span> (n~=3),
		error([upper(mfilename) '</span> requires 2- or 3-element Stop points.<span class="string">']);
	<span class="keyword">end</span>;
<span class="keyword">end</span>;
<span class="keyword">if</span> ~isempty(crossdir),
	[m,n] = size(crossdir);
	<span class="keyword">if</span> (n<3),
		crossdir = [crossdir NaN*ones(m,3-n)];
	<span class="keyword">elseif</span> (n~=3),
		<span class="keyword">if</span> (all(imag(crossdir(:))==0)),
			error([upper(mfilename) '</span> requires 2- or 3-element CrossDir vectors.<span class="string">']);
		<span class="keyword">else</span>,
			error([upper(mfilename) '</span> requires 2- or 3-element NormalDir vectors.<span class="string">']);
		<span class="keyword">end</span>;
	<span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="comment">% fill empty arguments</span>
<span class="keyword">if</span> isempty(start     ),   start      = [Inf Inf Inf];      <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(stop      ),   stop       = [Inf Inf Inf];      <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(len       ),   len        = Inf;                <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(baseangle ),   baseangle  = Inf;                <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(tipangle  ),   tipangle   = Inf;                <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(wid       ),   wid        = Inf;                <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(page      ),   page       = Inf;                <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(crossdir  ),   crossdir   = [Inf Inf Inf];      <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(ends      ),   ends       = Inf;                <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(shorten   ),   shorten    = Inf;                <span class="keyword">end</span>;
<span class="keyword">if</span> isempty(ispatch   ),   ispatch    = Inf;                <span class="keyword">end</span>;

<span class="comment">% expand single-column arguments</span>
o = ones(narrows,1);
<span class="keyword">if</span> (size(start     ,1)==1),   start      = o * start     ;   <span class="keyword">end</span>;
<span class="keyword">if</span> (size(stop      ,1)==1),   stop       = o * stop      ;   <span class="keyword">end</span>;
<span class="keyword">if</span> (length(len       )==1),   len        = o * len       ;   <span class="keyword">end</span>;
<span class="keyword">if</span> (length(baseangle )==1),   baseangle  = o * baseangle ;   <span class="keyword">end</span>;
<span class="keyword">if</span> (length(tipangle  )==1),   tipangle   = o * tipangle  ;   <span class="keyword">end</span>;
<span class="keyword">if</span> (length(wid       )==1),   wid        = o * wid       ;   <span class="keyword">end</span>;
<span class="keyword">if</span> (length(page      )==1),   page       = o * page      ;   <span class="keyword">end</span>;
<span class="keyword">if</span> (size(crossdir  ,1)==1),   crossdir   = o * crossdir  ;   <span class="keyword">end</span>;
<span class="keyword">if</span> (length(ends      )==1),   ends       = o * ends      ;   <span class="keyword">end</span>;
<span class="keyword">if</span> (length(shorten   )==1),   shorten    = o * shorten   ;   <span class="keyword">end</span>;
<span class="keyword">if</span> (length(ispatch   )==1),   ispatch    = o * ispatch   ;   <span class="keyword">end</span>;
ax = repmat(gca,narrows,1);   <span class="comment">%eaj 7/16/14  ax=gca; <span class="keyword">if</span> ~isnumeric(ax), ax=double(ax); <span class="keyword">end</span>; ax=o*ax;</span>

<span class="comment">% <span class="keyword">if</span> we'</span>ve got handles, get the defaults from the handles</span>
<span class="keyword">if</span> ~isempty(oldh),
	<span class="keyword">for</span> k=1:narrows,
		oh = oldh(k);
		ud = get(oh,<span class="string">'UserData'</span>);
		ax(k) = get(oh,<span class="string">'Parent'</span>);   <span class="comment">%eaj 7/16/14  get(oh,<span class="string">'Parent'</span>); <span class="keyword">if</span> ~isnumeric(ans), double(ans); <span class="keyword">end</span>; ax(k)=ans;</span>
		ohtype = get(oh,<span class="string">'Type'</span>);
		<span class="keyword">if</span> strcmp(get(oh,<span class="string">'Tag'</span>),ArrowTag), <span class="comment">% <span class="keyword">if</span> it<span class="string">'s an arrow already</span>
			<span class="keyword">if</span> isinf(ispatch(k)), ispatch(k)=strcmp(ohtype,'</span>patch<span class="string">'); <span class="keyword">end</span>;
			<span class="comment">% arrow UserData format: [start'</span> stop<span class="string">' len base tip wid page crossdir'</span> ends shorten]</span>
			start0 = ud(1:3);
			stop0  = ud(4:6);
			<span class="keyword">if</span> (isinf(len(k))),           len(k)        = ud( 7);   <span class="keyword">end</span>;
			<span class="keyword">if</span> (isinf(baseangle(k))),     baseangle(k)  = ud( 8);   <span class="keyword">end</span>;
			<span class="keyword">if</span> (isinf(tipangle(k))),      tipangle(k)   = ud( 9);   <span class="keyword">end</span>;
			<span class="keyword">if</span> (isinf(wid(k))),           wid(k)        = ud(10);   <span class="keyword">end</span>;
			<span class="keyword">if</span> (isinf(page(k))),          page(k)       = ud(11);   <span class="keyword">end</span>;
			<span class="keyword">if</span> (isinf(crossdir(k,1))),    crossdir(k,1) = ud(12);   <span class="keyword">end</span>;
			<span class="keyword">if</span> (isinf(crossdir(k,2))),    crossdir(k,2) = ud(13);   <span class="keyword">end</span>;
			<span class="keyword">if</span> (isinf(crossdir(k,3))),    crossdir(k,3) = ud(14);   <span class="keyword">end</span>;
			<span class="keyword">if</span> (isinf(ends(k))),          ends(k)       = ud(15);   <span class="keyword">end</span>;
			<span class="keyword">if</span> (isinf(shorten(k))),       shorten(k)    = ud(16);   <span class="keyword">end</span>;
		<span class="keyword">elseif</span> strcmp(ohtype,<span class="string">'line'</span>)|strcmp(ohtype,<span class="string">'patch'</span>), <span class="comment">% it<span class="string">'s a non-arrow line or patch</span>
			convLineToPatch = 1; <span class="comment">%set to make arrow patches when converting from lines.</span>
			<span class="keyword">if</span> isinf(ispatch(k)), ispatch(k)=convLineToPatch|strcmp(ohtype,'</span>patch<span class="string">'); <span class="keyword">end</span>;
			x=get(oh,'</span>XData<span class="string">');  x=x(~isnan(x(:)));  <span class="keyword">if</span> isempty(x), x=NaN; <span class="keyword">end</span>;
			y=get(oh,'</span>YData<span class="string">');  y=y(~isnan(y(:)));  <span class="keyword">if</span> isempty(y), y=NaN; <span class="keyword">end</span>;
			z=get(oh,'</span>ZData<span class="string">');  z=z(~isnan(z(:)));  <span class="keyword">if</span> isempty(z), z=NaN; <span class="keyword">end</span>;
			start0 = [x(1)   y(1)   z(1)  ];
			stop0  = [x(<span class="keyword">end</span>) y(<span class="keyword">end</span>) z(<span class="keyword">end</span>)];
		<span class="keyword">else</span>,
			error([upper(mfilename) '</span> cannot convert <span class="string">' ohtype '</span> objects.<span class="string">']);
		<span class="keyword">end</span>;
		ii=find(isinf(start(k,:)));  <span class="keyword">if</span> ~isempty(ii),  start(k,ii)=start0(ii);  <span class="keyword">end</span>;
		ii=find(isinf(stop( k,:)));  <span class="keyword">if</span> ~isempty(ii),  stop( k,ii)=stop0( ii);  <span class="keyword">end</span>;
	<span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="comment">% convert Inf'</span>s to NaN<span class="string">'s</span>
start(     isinf(start    )) = NaN;
stop(      isinf(stop     )) = NaN;
len(       isinf(len      )) = NaN;
baseangle( isinf(baseangle)) = NaN;
tipangle(  isinf(tipangle )) = NaN;
wid(       isinf(wid      )) = NaN;
page(      isinf(page     )) = NaN;
crossdir(  isinf(crossdir )) = NaN;
ends(      isinf(ends     )) = NaN;
shorten(   isinf(shorten  )) = NaN;
ispatch(   isinf(ispatch  )) = NaN;

<span class="comment">% set up the UserData data (here so not corrupted by log10'</span>s and such)</span>
ud = [start stop len baseangle tipangle wid page crossdir ends shorten];

<span class="comment">% Set Page defaults</span>
page = ~isnan(page) & trueornan(page);

<span class="comment">% Get axes limits, range, min; correct <span class="keyword">for</span> aspect ratio and log scale</span>
axm       = zeros(3,narrows);
axr       = zeros(3,narrows);
axrev     = zeros(3,narrows);
ap        = zeros(2,narrows);
xyzlog    = zeros(3,narrows);
limmin    = zeros(2,narrows);
limrange  = zeros(2,narrows);
oldaxlims = zeros(6,narrows);
oneax = all(ax==ax(1));
<span class="keyword">if</span> (oneax),
	T    = zeros(4,4);
	invT = zeros(4,4);
<span class="keyword">else</span>,
	T    = zeros(16,narrows);
	invT = zeros(16,narrows);
<span class="keyword">end</span>;
axnotdone = true(size(ax));
<span class="keyword">while</span> (any(axnotdone)),
	ii = find(axnotdone,1);
	curax = ax(ii);
	curpage = page(ii);
	<span class="comment">% get axes limits and aspect ratio</span>
	axl = [get(curax,<span class="string">'XLim'</span>); get(curax,<span class="string">'YLim'</span>); get(curax,<span class="string">'ZLim'</span>)];
	ax==curax; oldaxlims(:,ans)=repmat(reshape(axl<span class="string">',[],1),1,sum(ans));
	<span class="comment">% get axes size in pixels (points)</span>
	u = get(curax,'</span>Units<span class="string">');
	axposoldunits = get(curax,'</span>Position<span class="string">');
	really_curpage = curpage & strcmp(u,'</span>normalized<span class="string">');
	<span class="keyword">if</span> (really_curpage),
		curfig = get(curax,'</span>Parent<span class="string">');
		pu = get(curfig,'</span>PaperUnits<span class="string">');
		set(curfig,'</span>PaperUnits<span class="string">','</span>points<span class="string">');
		pp = get(curfig,'</span>PaperPosition<span class="string">');
		set(curfig,'</span>PaperUnits<span class="string">',pu);
		set(curax,'</span>Units<span class="string">','</span>pixels<span class="string">');
		curapscreen = get(curax,'</span>Position<span class="string">');
		set(curax,'</span>Units<span class="string">','</span>normalized<span class="string">');
		curap = pp.*get(curax,'</span>Position<span class="string">');
	<span class="keyword">else</span>,
		set(curax,'</span>Units<span class="string">','</span>pixels<span class="string">');
		curapscreen = get(curax,'</span>Position<span class="string">');
		curap = curapscreen;
	<span class="keyword">end</span>;
	set(curax,'</span>Units<span class="string">',u);
	set(curax,'</span>Position<span class="string">',axposoldunits);
	<span class="comment">% handle non-stretched axes position</span>
	str_stretch = { '</span>DataAspectRatioMode<span class="string">'    ; ...
	                '</span>PlotBoxAspectRatioMode<span class="string">' ; ...
	                '</span>CameraViewAngleMode<span class="string">'      };
	str_camera  = { '</span>CameraPositionMode<span class="string">'  ; ...
	                '</span>CameraTargetMode<span class="string">'    ; ...
	                '</span>CameraViewAngleMode<span class="string">' ; ...
	                '</span>CameraUpVectorMode<span class="string">'    };
	notstretched = strcmp(get(curax,str_stretch),'</span>manual<span class="string">');
	manualcamera = strcmp(get(curax,str_camera),'</span>manual<span class="string">');
	<span class="keyword">if</span> ~arrow_WarpToFill(notstretched,manualcamera,curax),
		<span class="comment">% give a warning that this has not been thoroughly tested</span>
		<span class="keyword">if</span> 0 & ARROW_STRETCH_WARN,
			ARROW_STRETCH_WARN = 0;
			strs = {str_stretch{1:2},str_camera{:}};
			strs = [char(ones(length(strs),1)*sprintf('</span>\n    <span class="string">')) char(strs)]'</span>;
			warning([upper(mfilename) <span class="string">' may not yet work quite right '</span> ...
			         <span class="string">'<span class="keyword">if</span> any of the following are '</span><span class="string">'manual'</span><span class="string">':'</span> strs(:).<span class="string">']);
		<span class="keyword">end</span>;
		<span class="comment">% find the true pixel size of the actual axes</span>
		texttmp = text(axl(1,[1 2 2 1 1 2 2 1]), ...
		               axl(2,[1 1 2 2 1 1 2 2]), ...
		               axl(3,[1 1 1 1 2 2 2 2]),'</span><span class="string">');
		set(texttmp,'</span>Units<span class="string">','</span>points<span class="string">');
		textpos = get(texttmp,'</span>Position<span class="string">');
		delete(texttmp);
		textpos = cat(1,textpos{:});
		textpos = max(textpos(:,1:2)) - min(textpos(:,1:2));
		<span class="comment">% adjust the axes position</span>
		<span class="keyword">if</span> (really_curpage),
			<span class="comment">% adjust to printed size</span>
			textpos = textpos * min(curap(3:4)./textpos);
			curap = [curap(1:2)+(curap(3:4)-textpos)/2 textpos];
		<span class="keyword">else</span>,
			<span class="comment">% adjust <span class="keyword">for</span> pixel roundoff</span>
			textpos = textpos * min(curapscreen(3:4)./textpos);
			curap = [curap(1:2)+(curap(3:4)-textpos)/2 textpos];
		<span class="keyword">end</span>;
	<span class="keyword">end</span>;
	<span class="keyword">if</span> ARROW_PERSP_WARN & ~strcmp(get(curax,'</span>Projection<span class="string">'),'</span>orthographic<span class="string">'),
		ARROW_PERSP_WARN = 0;
		warning([upper(mfilename) '</span> does not yet work right <span class="keyword">for</span> 3-D perspective projection.<span class="string">']);
	<span class="keyword">end</span>;
	<span class="comment">% adjust limits <span class="keyword">for</span> log scale on axes</span>
	curxyzlog = strcmp(get(curax,{'</span>XScale<span class="string">' '</span>YScale<span class="string">' '</span>ZScale<span class="string">'})'</span>,<span class="string">'log'</span>);
	<span class="keyword">if</span> (any(curxyzlog)),
		ii = find([curxyzlog;curxyzlog]);
		<span class="keyword">if</span> (any(axl(ii)<=0)),
			error([upper(mfilename) <span class="string">' does not support non-positive limits on log-scaled axes.'</span>]);
		<span class="keyword">else</span>,
			axl(ii) = log10(axl(ii));
		<span class="keyword">end</span>;
	<span class="keyword">end</span>;
	<span class="comment">% correct <span class="keyword">for</span> <span class="string">'reverse'</span> direction on axes;</span>
	curreverse = strcmp(get(curax,{<span class="string">'XDir'</span> <span class="string">'YDir'</span> <span class="string">'ZDir'</span>})<span class="string">','</span>reverse<span class="string">');
	ii = find(curreverse);
	<span class="keyword">if</span> ~isempty(ii),
		axl(ii,[1 2])=-axl(ii,[2 1]);
	<span class="keyword">end</span>;
	<span class="comment">% compute the range of 2-D values</span>
	try, curT=get(curax,'</span>Xform<span class="string">'); catch, num2cell(get(curax,'</span>View<span class="string">')); curT=viewmtx(ans{:}); <span class="keyword">end</span>;
	lim = curT*[0 1 0 1 0 1 0 1;0 0 1 1 0 0 1 1;0 0 0 0 1 1 1 1;1 1 1 1 1 1 1 1];
	lim = lim(1:2,:)./([1;1]*lim(4,:));
	curlimmin = min(lim'</span>)<span class="string">';
	curlimrange = max(lim'</span>)<span class="string">' - curlimmin;
	curinvT = inv(curT);
	<span class="keyword">if</span> (~oneax),
		curT = curT.'</span>;
		curinvT = curinvT.<span class="string">';
		curT = curT(:);
		curinvT = curinvT(:);
	<span class="keyword">end</span>;
	<span class="comment">% check which arrows to which cur corresponds</span>
	ii = find((ax==curax)&(page==curpage));
	oo = ones(1,length(ii));
	axr(:,ii)      = diff(axl'</span>)<span class="string">' * oo;
	axm(:,ii)      = axl(:,1)    * oo;
	axrev(:,ii)    = curreverse  * oo;
	ap(:,ii)       = curap(3:4)'</span> * oo;
	xyzlog(:,ii)   = curxyzlog   * oo;
	limmin(:,ii)   = curlimmin   * oo;
	limrange(:,ii) = curlimrange * oo;
	<span class="keyword">if</span> (oneax),
		T    = curT;
		invT = curinvT;
	<span class="keyword">else</span>,
		T(:,ii)    = curT    * oo;
		invT(:,ii) = curinvT * oo;
	<span class="keyword">end</span>;
	axnotdone(ii) = zeros(1,length(ii));
<span class="keyword">end</span>;

<span class="comment">% correct <span class="keyword">for</span> log scales</span>
curxyzlog = xyzlog.<span class="string">';
ii = find(curxyzlog(:));
<span class="keyword">if</span> ~isempty(ii),
	start(   ii) = real(log10(start(   ii)));
	stop(    ii) = real(log10(stop(    ii)));
	<span class="keyword">if</span> (all(imag(crossdir)==0)), <span class="comment">% pulled (ii) subscript on crossdir, 12/5/96 eaj</span>
		crossdir(ii) = real(log10(crossdir(ii)));
	<span class="keyword">end</span>;
<span class="keyword">end</span>;

<span class="comment">% correct <span class="keyword">for</span> reverse directions</span>
ii = find(axrev.'</span>);
<span class="keyword">if</span> ~isempty(ii),
	start(   ii) = -start(   ii);
	stop(    ii) = -stop(    ii);
	crossdir(ii) = -crossdir(ii);
<span class="keyword">end</span>;

<span class="comment">% transpose start/stop values</span>
start     = start.<span class="string">';
stop      = stop.'</span>;

<span class="comment">% take care of defaults, page was done above</span>
ii=find(isnan(start(:)       ));  <span class="keyword">if</span> ~isempty(ii),  start(ii)       = axm(ii)+axr(ii)/2;                <span class="keyword">end</span>;
ii=find(isnan(stop(:)        ));  <span class="keyword">if</span> ~isempty(ii),  stop(ii)        = axm(ii)+axr(ii)/2;                <span class="keyword">end</span>;
ii=find(isnan(crossdir(:)    ));  <span class="keyword">if</span> ~isempty(ii),  crossdir(ii)    = zeros(length(ii),1);              <span class="keyword">end</span>;
ii=find(isnan(len            ));  <span class="keyword">if</span> ~isempty(ii),  len(ii)         = ones(length(ii),1)*deflen;        <span class="keyword">end</span>;
ii=find(isnan(baseangle      ));  <span class="keyword">if</span> ~isempty(ii),  baseangle(ii)   = ones(length(ii),1)*defbaseangle;  <span class="keyword">end</span>;
ii=find(isnan(tipangle       ));  <span class="keyword">if</span> ~isempty(ii),  tipangle(ii)    = ones(length(ii),1)*deftipangle;   <span class="keyword">end</span>;
ii=find(isnan(wid            ));  <span class="keyword">if</span> ~isempty(ii),  wid(ii)         = ones(length(ii),1)*defwid;        <span class="keyword">end</span>;
ii=find(isnan(ends           ));  <span class="keyword">if</span> ~isempty(ii),  ends(ii)        = ones(length(ii),1)*defends;       <span class="keyword">end</span>;
ii=find(isnan(shorten        ));  <span class="keyword">if</span> ~isempty(ii),  shorten(ii)     = ones(length(ii),1)*defshorten;    <span class="keyword">end</span>;

<span class="comment">% transpose rest of values</span>
len       = len.<span class="string">';
baseangle = baseangle.'</span>;
tipangle  = tipangle.<span class="string">';
wid       = wid.'</span>;
page      = page.<span class="string">';
crossdir  = crossdir.'</span>;
ends      = ends.<span class="string">';
shorten   = shorten.'</span>;
ax        = ax.<span class="string">';

<span class="comment">% given x, a 3xN matrix of points in 3-space;</span>
<span class="comment">% want to convert to X, the corresponding 4xN 2-space matrix</span>
<span class="comment">%</span>
<span class="comment">%   tmp1=[(x-axm)./axr; ones(1,size(x,1))];</span>
<span class="comment">%   <span class="keyword">if</span> (oneax), X=T*tmp1;</span>
<span class="comment">%   <span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T.*tmp1;</span>
<span class="comment">%         tmp2=zeros(4,4*N); tmp2(:)=tmp1(:);</span>
<span class="comment">%         X=zeros(4,N); X(:)=sum(tmp2)'</span>; <span class="keyword">end</span>;</span>
<span class="comment">%   X = X ./ (ones(4,1)*X(4,:));</span>

<span class="comment">% <span class="keyword">for</span> all points with start==stop, start=stop-(verysmallvalue)*(up-direction);</span>
ii = find(all(start==stop));
<span class="keyword">if</span> ~isempty(ii),
	<span class="comment">% find an arrowdir vertical on screen and perpendicular to viewer</span>
	<span class="comment">%	transform to 2-D</span>
		tmp1 = [(stop(:,ii)-axm(:,ii))./axr(:,ii);ones(1,length(ii))];
		<span class="keyword">if</span> (oneax), twoD=T*tmp1;
		<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T(:,ii).*tmp1;
		      tmp2=zeros(4,4*length(ii)); tmp2(:)=tmp1(:);
		      twoD=zeros(4,length(ii)); twoD(:)=sum(tmp2)<span class="string">'; <span class="keyword">end</span>;
		twoD=twoD./(ones(4,1)*twoD(4,:));
	<span class="comment">%	move the start point down just slightly</span>
		tmp1 = twoD + [0;-1/1000;0;0]*(limrange(2,ii)./ap(2,ii));
	<span class="comment">%	transform back to 3-D</span>
		<span class="keyword">if</span> (oneax), threeD=invT*tmp1;
		<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT(:,ii).*tmp1;
		      tmp2=zeros(4,4*length(ii)); tmp2(:)=tmp1(:);
		      threeD=zeros(4,length(ii)); threeD(:)=sum(tmp2)'</span>; <span class="keyword">end</span>;
		start(:,ii) = (threeD(1:3,:)./(ones(3,1)*threeD(4,:))).*axr(:,ii)+axm(:,ii);
<span class="keyword">end</span>;

<span class="comment">% compute along-arrow points</span>
<span class="comment">%	transform Start points</span>
	tmp1=[(start-axm)./axr;ones(1,narrows)];
	<span class="keyword">if</span> (oneax), X0=T*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T.*tmp1;
	      tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
	      X0=zeros(4,narrows); X0(:)=sum(tmp2)<span class="string">'; <span class="keyword">end</span>;
	X0=X0./(ones(4,1)*X0(4,:));
<span class="comment">%	transform Stop points</span>
	tmp1=[(stop-axm)./axr;ones(1,narrows)];
	<span class="keyword">if</span> (oneax), Xf=T*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T.*tmp1;
	      tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
	      Xf=zeros(4,narrows); Xf(:)=sum(tmp2)'</span>; <span class="keyword">end</span>;
	Xf=Xf./(ones(4,1)*Xf(4,:));
<span class="comment">%	compute pixel distance between points</span>
	D = sqrt(sum(((Xf(1:2,:)-X0(1:2,:)).*(ap./limrange)).^2));
	D = D + (D==0);  <span class="comment">%eaj new 2/24/98</span>
<span class="comment">%       shorten the length <span class="keyword">if</span> requested % added 2/6/2013</span>
	numends = (ends==1) + (ends==2) + 2*(ends==3);
	mask = shorten & D<len.*numends;
	len(mask) = D(mask) ./ numends(mask);
<span class="comment">%	compute and modify along-arrow distances</span>
	len1 = len;
	len2 = len - (len.*tan(tipangle/180*pi)-wid/2).*tan((90-baseangle)/180*pi);
	slen0 = zeros(1,narrows);
	slen1 = len1 .* ((ends==2)|(ends==3));
	slen2 = len2 .* ((ends==2)|(ends==3));
	len0 = zeros(1,narrows);
	len1  = len1 .* ((ends==1)|(ends==3));
	len2  = len2 .* ((ends==1)|(ends==3));
	<span class="comment">%	<span class="keyword">for</span> no start arrowhead</span>
		ii=find((ends==1)&(D<len2));
		<span class="keyword">if</span> ~isempty(ii),
			slen0(ii) = D(ii)-len2(ii);
		<span class="keyword">end</span>;
	<span class="comment">%	<span class="keyword">for</span> no <span class="keyword">end</span> arrowhead</span>
		ii=find((ends==2)&(D<slen2));
		<span class="keyword">if</span> ~isempty(ii),
			len0(ii) = D(ii)-slen2(ii);
		<span class="keyword">end</span>;
	len1  = len1  + len0;
	len2  = len2  + len0;
	slen1 = slen1 + slen0;
	slen2 = slen2 + slen0;
 	<span class="comment">% note:  the division by D below will probably not be accurate <span class="keyword">if</span> both</span>
 	<span class="comment">%        of the following are true:</span>
 	<span class="comment">%           1. the ratio of the line length to the arrowhead</span>
 	<span class="comment">%              length is large</span>
 	<span class="comment">%           2. the view is highly perspective.</span>
<span class="comment">%	compute stoppoints</span>
	tmp1=X0.*(ones(4,1)*(len0./D))+Xf.*(ones(4,1)*(1-len0./D));
	<span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
	      tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
	      tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)<span class="string">'; <span class="keyword">end</span>;
	stoppoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
<span class="comment">%	compute tippoints</span>
	tmp1=X0.*(ones(4,1)*(len1./D))+Xf.*(ones(4,1)*(1-len1./D));
	<span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
	      tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
	      tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'</span>; <span class="keyword">end</span>;
	tippoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
<span class="comment">%	compute basepoints</span>
	tmp1=X0.*(ones(4,1)*(len2./D))+Xf.*(ones(4,1)*(1-len2./D));
	<span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
	      tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
	      tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)<span class="string">'; <span class="keyword">end</span>;
	basepoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
<span class="comment">%	compute startpoints</span>
	tmp1=X0.*(ones(4,1)*(1-slen0./D))+Xf.*(ones(4,1)*(slen0./D));
	<span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
	      tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
	      tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'</span>; <span class="keyword">end</span>;
	startpoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
<span class="comment">%	compute stippoints</span>
	tmp1=X0.*(ones(4,1)*(1-slen1./D))+Xf.*(ones(4,1)*(slen1./D));
	<span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
	      tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
	      tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)<span class="string">'; <span class="keyword">end</span>;
	stippoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;
<span class="comment">%	compute sbasepoints</span>
	tmp1=X0.*(ones(4,1)*(1-slen2./D))+Xf.*(ones(4,1)*(slen2./D));
	<span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=invT.*tmp1;
	      tmp2=zeros(4,4*narrows); tmp2(:)=tmp1(:);
	      tmp3=zeros(4,narrows); tmp3(:)=sum(tmp2)'</span>; <span class="keyword">end</span>;
	sbasepoint = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)).*axr+axm;

<span class="comment">% compute cross-arrow directions <span class="keyword">for</span> arrows with NormalDir specified</span>
<span class="keyword">if</span> (any(imag(crossdir(:))~=0)),
	ii = find(any(imag(crossdir)~=0));
	crossdir(:,ii) = cross((stop(:,ii)-start(:,ii))./axr(:,ii), ...
	                       imag(crossdir(:,ii))).*axr(:,ii);
<span class="keyword">end</span>;

<span class="comment">% compute cross-arrow directions</span>
basecross  = crossdir + basepoint;
tipcross   = crossdir + tippoint;
sbasecross = crossdir + sbasepoint;
stipcross  = crossdir + stippoint;
ii = find(all(crossdir==0)|any(isnan(crossdir)));
<span class="keyword">if</span> ~isempty(ii),
	numii = length(ii);
	<span class="comment">%	transform start points</span>
		tmp1 = [basepoint(:,ii) tippoint(:,ii) sbasepoint(:,ii) stippoint(:,ii)];
		tmp1 = (tmp1-axm(:,[ii ii ii ii])) ./ axr(:,[ii ii ii ii]);
		tmp1 = [tmp1; ones(1,4*numii)];
		<span class="keyword">if</span> (oneax), X0=T*tmp1;
		<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T(:,[ii ii ii ii]).*tmp1;
		      tmp2=zeros(4,16*numii); tmp2(:)=tmp1(:);
		      X0=zeros(4,4*numii); X0(:)=sum(tmp2)<span class="string">'; <span class="keyword">end</span>;
		X0=X0./(ones(4,1)*X0(4,:));
	<span class="comment">%	transform stop points</span>
		tmp1 = [(2*stop(:,ii)-start(:,ii)-axm(:,ii))./axr(:,ii);ones(1,numii)];
		tmp1 = [tmp1 tmp1 tmp1 tmp1];
		<span class="keyword">if</span> (oneax), Xf=T*tmp1;
		<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=T(:,[ii ii ii ii]).*tmp1;
		      tmp2=zeros(4,16*numii); tmp2(:)=tmp1(:);
		      Xf=zeros(4,4*numii); Xf(:)=sum(tmp2)'</span>; <span class="keyword">end</span>;
		Xf=Xf./(ones(4,1)*Xf(4,:));
	<span class="comment">%	compute perpendicular directions</span>
		pixfact = ((limrange(1,ii)./limrange(2,ii)).*(ap(2,ii)./ap(1,ii))).^2;
		pixfact = [pixfact pixfact pixfact pixfact];
		pixfact = [pixfact;1./pixfact];
		[dummyval,jj] = max(abs(Xf(1:2,:)-X0(1:2,:)));
		jj1 = ((1:4)<span class="string">'*ones(1,length(jj))==ones(4,1)*jj);
		jj2 = ((1:4)'</span>*ones(1,length(jj))==ones(4,1)*(3-jj));
		jj3 = jj1(1:2,:);
		Xf(jj1)=Xf(jj1)+(Xf(jj1)-X0(jj1)==0); <span class="comment">%eaj new 2/24/98</span>
		Xp = X0;
		Xp(jj2) = X0(jj2) + ones(sum(jj2(:)),1);
		Xp(jj1) = X0(jj1) - (Xf(jj2)-X0(jj2))./(Xf(jj1)-X0(jj1)) .* pixfact(jj3);
	<span class="comment">%	inverse transform the cross points</span>
		<span class="keyword">if</span> (oneax), Xp=invT*Xp;
		<span class="keyword">else</span>, tmp1=[Xp;Xp;Xp;Xp]; tmp1=invT(:,[ii ii ii ii]).*tmp1;
		      tmp2=zeros(4,16*numii); tmp2(:)=tmp1(:);
		      Xp=zeros(4,4*numii); Xp(:)=sum(tmp2)<span class="string">'; <span class="keyword">end</span>;
		Xp=(Xp(1:3,:)./(ones(3,1)*Xp(4,:))).*axr(:,[ii ii ii ii])+axm(:,[ii ii ii ii]);
		basecross(:,ii)  = Xp(:,0*numii+(1:numii));
		tipcross(:,ii)   = Xp(:,1*numii+(1:numii));
		sbasecross(:,ii) = Xp(:,2*numii+(1:numii));
		stipcross(:,ii)  = Xp(:,3*numii+(1:numii));
<span class="keyword">end</span>;

<span class="comment">% compute all points</span>
<span class="comment">%	compute start points</span>
	axm11 = [axm axm axm axm axm axm axm axm axm axm axm];
	axr11 = [axr axr axr axr axr axr axr axr axr axr axr];
	st = [stoppoint tippoint basepoint sbasepoint stippoint startpoint stippoint sbasepoint basepoint tippoint stoppoint];
	tmp1 = (st - axm11) ./ axr11;
	tmp1 = [tmp1; ones(1,size(tmp1,2))];
	<span class="keyword">if</span> (oneax), X0=T*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=[T T T T T T T T T T T].*tmp1;
	      tmp2=zeros(4,44*narrows); tmp2(:)=tmp1(:);
	      X0=zeros(4,11*narrows); X0(:)=sum(tmp2)'</span>; <span class="keyword">end</span>;
	X0=X0./(ones(4,1)*X0(4,:));
<span class="comment">%	compute stop points</span>
	tmp1 = ([start tipcross basecross sbasecross stipcross stop stipcross sbasecross basecross tipcross start] ...
	     - axm11) ./ axr11;
	tmp1 = [tmp1; ones(1,size(tmp1,2))];
	<span class="keyword">if</span> (oneax), Xf=T*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=[T T T T T T T T T T T].*tmp1;
	      tmp2=zeros(4,44*narrows); tmp2(:)=tmp1(:);
	      Xf=zeros(4,11*narrows); Xf(:)=sum(tmp2)<span class="string">'; <span class="keyword">end</span>;
	Xf=Xf./(ones(4,1)*Xf(4,:));
<span class="comment">%	compute lengths</span>
	len0  = len.*((ends==1)|(ends==3)).*tan(tipangle/180*pi);
	slen0 = len.*((ends==2)|(ends==3)).*tan(tipangle/180*pi);
	le = [zeros(1,narrows) len0 wid/2 wid/2 slen0 zeros(1,narrows) -slen0 -wid/2 -wid/2 -len0 zeros(1,narrows)];
	aprange = ap./limrange;
	aprange = [aprange aprange aprange aprange aprange aprange aprange aprange aprange aprange aprange];
	D = sqrt(sum(((Xf(1:2,:)-X0(1:2,:)).*aprange).^2));
	Dii=find(D==0); <span class="keyword">if</span> ~isempty(Dii), D=D+(D==0); le(Dii)=zeros(1,length(Dii)); <span class="keyword">end</span>; <span class="comment">%should fix DivideByZero warnings</span>
	tmp1 = X0.*(ones(4,1)*(1-le./D)) + Xf.*(ones(4,1)*(le./D));
<span class="comment">%	inverse transform</span>
	<span class="keyword">if</span> (oneax), tmp3=invT*tmp1;
	<span class="keyword">else</span>, tmp1=[tmp1;tmp1;tmp1;tmp1]; tmp1=[invT invT invT invT invT invT invT invT invT invT invT].*tmp1;
	      tmp2=zeros(4,44*narrows); tmp2(:)=tmp1(:);
	      tmp3=zeros(4,11*narrows); tmp3(:)=sum(tmp2)'</span>; <span class="keyword">end</span>;
	pts = tmp3(1:3,:)./(ones(3,1)*tmp3(4,:)) .* axr11 + axm11;

<span class="comment">% correct <span class="keyword">for</span> ones where the crossdir was specified</span>
ii = find(~(all(crossdir==0)|any(isnan(crossdir))));
<span class="keyword">if</span> ~isempty(ii),
	D1 = [pts(:,1*narrows+ii)-pts(:,9*narrows+ii) ...
	      pts(:,2*narrows+ii)-pts(:,8*narrows+ii) ...
	      pts(:,3*narrows+ii)-pts(:,7*narrows+ii) ...
	      pts(:,4*narrows+ii)-pts(:,6*narrows+ii) ...
	      pts(:,6*narrows+ii)-pts(:,4*narrows+ii) ...
	      pts(:,7*narrows+ii)-pts(:,3*narrows+ii) ...
	      pts(:,8*narrows+ii)-pts(:,2*narrows+ii) ...
	      pts(:,9*narrows+ii)-pts(:,1*narrows+ii)]/2;
	ii = ii<span class="string">'*ones(1,8) + ones(length(ii),1)*[1:4 6:9]*narrows;
	ii = ii(:)'</span>;
	pts(:,ii) = st(:,ii) + D1;
<span class="keyword">end</span>;


<span class="comment">% readjust <span class="keyword">for</span> reverse directions</span>
iicols=(1:narrows)<span class="string">'; iicols=iicols(:,ones(1,11)); iicols=iicols(:).'</span>;
tmp1=axrev(:,iicols);
ii = find(tmp1(:)); <span class="keyword">if</span> ~isempty(ii), pts(ii)=-pts(ii); <span class="keyword">end</span>;

<span class="comment">% change from starting/ending at the stop point to doing it at the midpoint %eaj 7/14/2014</span>
(pts(:,2*narrows+1:3*narrows)+pts(:,3*narrows+1:4*narrows))/2;              <span class="comment">%eaj 7/14/2014</span>
pts = [ans pts(:,[3*narrows+1:<span class="keyword">end</span> narrows+1:3*narrows]) ans];               <span class="comment">%eaj 7/14/2014</span>

<span class="comment">% readjust <span class="keyword">for</span> log scale on axes</span>
tmp1=xyzlog(:,iicols);
ii = find(tmp1(:)); <span class="keyword">if</span> ~isempty(ii), pts(ii)=10.^pts(ii); <span class="keyword">end</span>;

<span class="comment">% compute the x,y,z coordinates of the patches;</span>
ii = narrows*(0:size(pts,2)/narrows-1)<span class="string">'*ones(1,narrows) + ones(size(pts,2)/narrows,1)*(1:narrows);
ii = ii(:)'</span>;
x = zeros(size(pts,2)/narrows,narrows);
y = zeros(size(pts,2)/narrows,narrows);
z = zeros(size(pts,2)/narrows,narrows);
x(:) = pts(1,ii)<span class="string">';
y(:) = pts(2,ii)'</span>;
z(:) = pts(3,ii)<span class="string">';

<span class="comment">% do the output</span>
<span class="keyword">if</span> (nargout<=1),
<span class="comment">%	% create or modify the patches</span>
	newpatch = trueornan(ispatch) & (isempty(oldh)|~strcmp(get(oldh,'</span>Type<span class="string">'),'</span>patch<span class="string">'));
	newline = ~trueornan(ispatch) & (isempty(oldh)|~strcmp(get(oldh,'</span>Type<span class="string">'),'</span>line<span class="string">'));
	<span class="keyword">if</span> isempty(oldh), H=zeros(narrows,1); <span class="keyword">else</span>, H=oldh; <span class="keyword">end</span>;
<span class="comment">%	% make or modify the arrows</span>
	<span class="keyword">for</span> k=1:narrows,
		<span class="keyword">if</span> all(isnan(ud(k,[3 6])))&arrow_is2DXY(ax(k)), zz=[]; <span class="keyword">else</span>, zz=z(:,k); <span class="keyword">end</span>;
		xx=x(:,k); yy=y(:,k);
		<span class="keyword">if</span> (0), <span class="comment">% this fix didn'</span>t work, so let<span class="string">'s not use it -- 8/26/03</span>
			<span class="comment">% try to work around a MATLAB 6.x OpenGL bug -- 7/28/02</span>
			  mask=any([ones(1,2+size(zz,2));diff([xx yy zz],[],1)],2);
			  xx=xx(mask); yy=yy(mask); <span class="keyword">if</span> ~isempty(zz), zz=zz(mask); <span class="keyword">end</span>;
		<span class="keyword">end</span>;
		<span class="comment">% plot the patch or line</span>
		<span class="keyword">if</span> newpatch(k) || trueornan(ispatch(k)) <span class="comment">%eaj 7/14/2014, 5/25/2016</span>
			<span class="comment">% patch is closed so don'</span>t need endpoints %eaj 7/14/2014</span>
			<span class="keyword">if</span> ~isempty(xx), xx(<span class="keyword">end</span>)=[]; <span class="keyword">end</span>; <span class="comment">%eaj 7/14/2014</span>
			<span class="keyword">if</span> ~isempty(yy), yy(<span class="keyword">end</span>)=[]; <span class="keyword">end</span>; <span class="comment">%eaj 7/14/2014</span>
			<span class="keyword">if</span> ~isempty(zz), zz(<span class="keyword">end</span>)=[]; <span class="keyword">end</span>; <span class="comment">%eaj 7/14/2014</span>
		<span class="keyword">end</span> <span class="comment">%eaj 7/14/2014</span>
		xyz = {<span class="string">'XData'</span>,xx,<span class="string">'YData'</span>,yy,<span class="string">'ZData'</span>,zz,<span class="string">'Tag'</span>,ArrowTag};
		<span class="keyword">if</span> newpatch(k)|newline(k),
			<span class="keyword">if</span> newpatch(k),
				H(k) = patch(xyz{:});
			<span class="keyword">else</span>,
				H(k) = line(xyz{:});
			<span class="keyword">end</span>;
			<span class="keyword">if</span> ~isempty(oldh), arrow_copyprops(oldh(k),H(k)); <span class="keyword">end</span>;
		<span class="keyword">else</span>,
			<span class="keyword">if</span> strcmp(get(H(k),<span class="string">'Type'</span>),<span class="string">'patch'</span>) <span class="comment">%eaj 5/25/16  <span class="keyword">if</span> ispatch(k)</span>
				xyz = {xyz{:},<span class="string">'CData'</span>,[]};
			<span class="keyword">end</span>;
			set(H(k),xyz{:});
		<span class="keyword">end</span>;
	<span class="keyword">end</span>;
	<span class="keyword">if</span> ~isempty(oldh), delete(oldh(oldh~=H)); <span class="keyword">end</span>;
<span class="comment">%	% additional properties</span>
	set(H,<span class="string">'Clipping'</span>,<span class="string">'off'</span>);
	set(H,{<span class="string">'UserData'</span>},num2cell(ud,2));
	<span class="keyword">if</span> length(extraprops)>0
		ii = find(strcmpi(extraprops(1:2:<span class="keyword">end</span>),<span class="string">'color'</span>)); <span class="comment">%eaj 5/25/16</span>
		ispatch = strcmp(get(H,<span class="string">'Type'</span>),<span class="string">'patch'</span>);
		<span class="comment">%eaj start 5/25/16</span>
			<span class="keyword">while</span> ~isempty(ii) && any(ispatch)
				<span class="keyword">if</span> ii>1, set(H,extraprops{1:2*ii-2}); <span class="keyword">end</span>;
				c = extraprops{2*ii};
				extraprops(1:2*ii) = [];
				ii(1) = [];
				<span class="keyword">if</span> all(ispatch) || ischar(c)&&size(c,1)==1 || isnumeric(c)&&isequal(size(c),[1 3])
					set(H,<span class="string">'EdgeColor'</span>,c,<span class="string">'FaceColor'</span>,c)
				<span class="keyword">elseif</span> iscell(c) && numel(c)~=numel(H)
					set(H(ispatch),<span class="string">'EdgeColor'</span>,c(ispatch),<span class="string">'FaceColor'</span>,c(ispatch));
					set(H(~ispatch),<span class="string">'Color'</span>,c(~ispatch));
				<span class="keyword">elseif</span> isnumeric(c) && isequal(size(c),[numel(H) 3])
					set(H(ispatch),<span class="string">'EdgeColor'</span>,num2cell(c(ispatch,:),2),<span class="string">'FaceColor'</span>,num2cell(c(ispatch,:),2));
					set(H(~ispatch),<span class="string">'Color'</span>,num2cell(c(~ispatch,:),2));
				<span class="keyword">else</span>
					warning(<span class="string">'ignoring unknown or invalid '</span><span class="string">'Color'</span><span class="string">' specification'</span>);
				<span class="keyword">end</span>
			<span class="keyword">end</span>
		<span class="keyword">if</span> ~isempty(extraprops)
		<span class="comment">%eaj <span class="keyword">end</span>   5/25/16</span>
			set(H,extraprops{:});
		<span class="keyword">end</span> <span class="comment">%eaj   5/25/16</span>
	<span class="keyword">end</span>
	<span class="comment">% handle choosing arrow Start and/or Stop locations <span class="keyword">if</span> unspecified</span>
	[H,oldaxlims,errstr] = arrow_clicks(H,ud,x,y,z,ax,oldaxlims);
	<span class="keyword">if</span> ~isempty(errstr), error([upper(mfilename) <span class="string">' got '</span> errstr]); <span class="keyword">end</span>;
	<span class="comment">% set the output</span>
	<span class="keyword">if</span> (nargout>0), h=H; <span class="keyword">end</span>;
	<span class="comment">% make sure the axis limits did not change</span>
	<span class="keyword">if</span> isempty(oldaxlims),
		ARROW_AXLIMITS = [];
		ARROW_AX = [];
	<span class="keyword">else</span>,
		lims = get(ax(:),{<span class="string">'XLim'</span>,<span class="string">'YLim'</span>,<span class="string">'ZLim'</span>})<span class="string">';
		lims = reshape(cat(2,lims{:}),6,size(lims,2));
		mask = arrow_is2DXY(ax(:));
		oldaxlims(5:6,mask) = lims(5:6,mask);
		<span class="comment">% store them <span class="keyword">for</span> possible restoring</span>
		mask = any(oldaxlims~=lims,1); ARROW_AX=ax(mask); ARROW_AXLIMITS=oldaxlims(:,mask);
		<span class="keyword">if</span> any(mask),
			warning(arrow_warnlimits(ARROW_AX,narrows));
		<span class="keyword">end</span>;
	<span class="keyword">end</span>;
<span class="keyword">else</span>,
	<span class="comment">% don'</span>t create the patch, just <span class="keyword">return</span> the data</span>
	h=x;
	yy=y;
	zz=z;
<span class="keyword">end</span>;



<span class="keyword">function</span> out = arrow_defcheck(in,def,prop)
<span class="comment">% check <span class="keyword">if</span> we got <span class="string">'default'</span> values</span>
	out = in;
	<span class="keyword">if</span> ~isstr(in), <span class="keyword">return</span>; <span class="keyword">end</span>;
	<span class="keyword">if</span> size(in,1)==1 & strncmp(lower(in),<span class="string">'def'</span>,3),
		out = def;
	<span class="keyword">elseif</span> ~isempty(prop),
		error([upper(mfilename) <span class="string">' does not recognize '</span><span class="string">''</span> in(:)<span class="string">' '</span><span class="string">''</span> as a valid <span class="string">''</span><span class="string">' prop '</span><span class="string">''</span> string.<span class="string">']);
	<span class="keyword">end</span>;



<span class="keyword">function</span> [H,oldaxlims,errstr] = arrow_clicks(H,ud,x,y,z,ax,oldaxlims)
<span class="comment">% handle choosing arrow Start and/or Stop locations <span class="keyword">if</span> necessary</span>
	errstr = '</span><span class="string">';
	<span class="keyword">if</span> isempty(H)|isempty(ud)|isempty(x), <span class="keyword">return</span>; <span class="keyword">end</span>;
	<span class="comment">% determine which (<span class="keyword">if</span> any) need Start and/or Stop</span>
	needStart = all(isnan(ud(:,1:3)'</span>))<span class="string">';
	needStop  = all(isnan(ud(:,4:6)'</span>))<span class="string">';
	mask = any(needStart|needStop);
	<span class="keyword">if</span> ~any(mask), <span class="keyword">return</span>; <span class="keyword">end</span>;
	ud(~mask,:)=[]; ax(:,~mask)=[];
	x(:,~mask)=[]; y(:,~mask)=[]; z(:,~mask)=[];
	<span class="comment">% make them invisible <span class="keyword">for</span> the time being</span>
	set(H,'</span>Visible<span class="string">','</span>off<span class="string">');
	<span class="comment">% save the current axes and limits modes; set to manual <span class="keyword">for</span> the time being</span>
	oldAx  = gca;
	limModes=get(ax(:),{'</span>XLimMode<span class="string">','</span>YLimMode<span class="string">','</span>ZLimMode<span class="string">'});
	set(ax(:),{'</span>XLimMode<span class="string">','</span>YLimMode<span class="string">','</span>ZLimMode<span class="string">'},{'</span>manual<span class="string">','</span>manual<span class="string">','</span>manual<span class="string">'});
	<span class="comment">% loop over each arrow that requires attention</span>
	jj = find(mask);
	<span class="keyword">for</span> ii=1:length(jj),
		h = H(jj(ii));
		axes(ax(ii));
		<span class="comment">% figure out correct call</span>
		<span class="keyword">if</span> needStart(ii), prop='</span>Start<span class="string">'; <span class="keyword">else</span>, prop='</span>Stop<span class="string">'; <span class="keyword">end</span>;
		[wasInterrupted,errstr] = arrow_click(needStart(ii)&needStop(ii),h,prop,ax(ii));
		<span class="comment">% handle errors and control-C</span>
		<span class="keyword">if</span> wasInterrupted,
			delete(H(jj(ii:<span class="keyword">end</span>)));
			H(jj(ii:<span class="keyword">end</span>))=[];
			oldaxlims(jj(ii:<span class="keyword">end</span>),:)=[];
			break;
		<span class="keyword">end</span>;
	<span class="keyword">end</span>;
	<span class="comment">% restore the axes and limit modes</span>
	axes(oldAx);
	set(ax(:),{'</span>XLimMode<span class="string">','</span>YLimMode<span class="string">','</span>ZLimMode<span class="string">'},limModes);

<span class="keyword">function</span> [wasInterrupted,errstr] = arrow_click(lockStart,H,prop,ax)
<span class="comment">% handle the clicks <span class="keyword">for</span> one arrow</span>
	fig = get(ax,'</span>Parent<span class="string">');
	<span class="comment">% save some things</span>
	oldFigProps = {'</span>Pointer<span class="string">','</span>WindowButtonMotionFcn<span class="string">','</span>WindowButtonUpFcn<span class="string">'};
	oldFigValue = get(fig,oldFigProps);
	oldArrowProps = {'</span>EraseMode<span class="string">'};
	<span class="keyword">if</span> ~isnumeric(fig), oldArrowProps={}; <span class="keyword">end</span> <span class="comment">%eaj 5/24/16 % only use in HG2</span>
	oldArrowValue = get(H,oldArrowProps);
	<span class="keyword">if</span> isnumeric(fig), <span class="comment">%eaj 5/24/16</span>
		set(H,'</span>EraseMode<span class="string">','</span>background<span class="string">'); <span class="comment">%because '</span>xor<span class="string">' makes shaft invisible unless Width>1 -- only use in HG2</span>
	<span class="keyword">end</span> <span class="comment">%eaj 5/24/16</span>
	global ARROW_CLICK_H ARROW_CLICK_PROP ARROW_CLICK_AX ARROW_CLICK_USE_Z
	ARROW_CLICK_H=H; ARROW_CLICK_PROP=prop; ARROW_CLICK_AX=ax;
	ARROW_CLICK_USE_Z=~arrow_is2DXY(ax)|~arrow_planarkids(ax);
	set(fig,'</span>Pointer<span class="string">','</span>crosshair<span class="string">');
	<span class="comment">% set up the WindowButtonMotion so we can see the arrow <span class="keyword">while</span> moving around</span>
	set(fig,'</span>WindowButtonUpFcn<span class="string">','</span>set(gcf,<span class="string">''</span>WindowButtonUpFcn<span class="string">''</span>,<span class="string">''</span><span class="string">''</span>)<span class="string">', ...
	        '</span>WindowButtonMotionFcn<span class="string">','</span><span class="string">');
	<span class="keyword">if</span> ~lockStart,
		set(H,'</span>Visible<span class="string">','</span>on<span class="string">');
		set(fig,'</span>WindowButtonMotionFcn<span class="string">',[mfilename '</span>(<span class="string">''</span>callback<span class="string">''</span>,<span class="string">''</span>motion<span class="string">''</span>);<span class="string">']);
	<span class="keyword">end</span>;
	<span class="comment">% wait <span class="keyword">for</span> the button to be pressed</span>
	[wasKeyPress,wasInterrupted,errstr] = arrow_wfbdown(fig);
	<span class="comment">% <span class="keyword">if</span> we wanted to click-drag, set the Start point</span>
	<span class="keyword">if</span> lockStart & ~wasInterrupted,
		pt = arrow_point(ARROW_CLICK_AX,ARROW_CLICK_USE_Z);
		feval(mfilename,H,'</span>Start<span class="string">',pt,'</span>Stop<span class="string">',pt);
		set(H,'</span>Visible<span class="string">','</span>on<span class="string">');
		ARROW_CLICK_PROP='</span>Stop<span class="string">';
		set(fig,'</span>WindowButtonMotionFcn<span class="string">',[mfilename '</span>(<span class="string">''</span>callback<span class="string">''</span>,<span class="string">''</span>motion<span class="string">''</span>);<span class="string">']);
		<span class="comment">% wait <span class="keyword">for</span> the mouse button to be released</span>
		try
			waitfor(fig,'</span>WindowButtonUpFcn<span class="string">','</span><span class="string">');
		catch
			errstr = lasterr;
			wasInterrupted = 1;
		<span class="keyword">end</span>;
	<span class="keyword">end</span>;
	<span class="keyword">if</span> ~wasInterrupted, feval(mfilename,'</span>callback<span class="string">','</span>motion<span class="string">'); <span class="keyword">end</span>;
	<span class="comment">% restore some things</span>
	set(gcf,oldFigProps,oldFigValue);
	set(H,oldArrowProps,oldArrowValue);

<span class="keyword">function</span> arrow_callback(varargin)
<span class="comment">% handle redrawing callbacks</span>
	<span class="keyword">if</span> nargin==0, <span class="keyword">return</span>; <span class="keyword">end</span>;
	str = varargin{1};
	<span class="keyword">if</span> ~isstr(str), error([upper(mfilename) '</span> got an invalid Callback command.<span class="string">']); <span class="keyword">end</span>;
	s = lower(str);
	<span class="keyword">if</span> strcmp(s,'</span>motion<span class="string">'),
		<span class="comment">% motion callback</span>
		global ARROW_CLICK_H ARROW_CLICK_PROP ARROW_CLICK_AX ARROW_CLICK_USE_Z
		feval(mfilename,ARROW_CLICK_H,ARROW_CLICK_PROP,arrow_point(ARROW_CLICK_AX,ARROW_CLICK_USE_Z));
		drawnow;
	<span class="keyword">else</span>,
		error([upper(mfilename) '</span> does not recognize <span class="string">''</span><span class="string">' str(:).'</span> <span class="string">''</span><span class="string">' as a valid Callback option.'</span>]);
	<span class="keyword">end</span>;

<span class="keyword">function</span> out = arrow_point(ax,use_z)
<span class="comment">% <span class="keyword">return</span> the point on the given axes</span>
	<span class="keyword">if</span> nargin==0, ax=gca; <span class="keyword">end</span>;
	<span class="keyword">if</span> nargin<2, use_z=~arrow_is2DXY(ax)|~arrow_planarkids(ax); <span class="keyword">end</span>;
	out = get(ax,<span class="string">'CurrentPoint'</span>);
	out = out(1,:);
	<span class="keyword">if</span> ~use_z, out=out(1:2); <span class="keyword">end</span>;

<span class="keyword">function</span> [wasKeyPress,wasInterrupted,errstr] = arrow_wfbdown(fig)
<span class="comment">% wait <span class="keyword">for</span> button down ignoring object ButtonDownFcn<span class="string">'s</span>
	<span class="keyword">if</span> nargin==0, fig=gcf; <span class="keyword">end</span>;
	errstr = '</span><span class="string">';
	<span class="comment">% save ButtonDownFcn values</span>
	objs = findobj(fig);
	buttonDownFcns = get(objs,'</span>ButtonDownFcn<span class="string">');
	mask=~strcmp(buttonDownFcns,'</span><span class="string">'); objs=objs(mask); buttonDownFcns=buttonDownFcns(mask);
	set(objs,'</span>ButtonDownFcn<span class="string">','</span><span class="string">');
	<span class="comment">% save other figure values</span>
	figProps = {'</span>KeyPressFcn<span class="string">','</span>WindowButtonDownFcn<span class="string">'};
	figValue = get(fig,figProps);
	<span class="comment">% do the real work</span>
	set(fig,'</span>KeyPressFcn<span class="string">','</span>set(gcf,<span class="string">''</span>KeyPressFcn<span class="string">''</span>,<span class="string">''</span><span class="string">''</span>,<span class="string">''</span>WindowButtonDownFcn<span class="string">''</span>,<span class="string">''</span><span class="string">''</span>);<span class="string">', ...
	        '</span>WindowButtonDownFcn<span class="string">','</span>set(gcf,<span class="string">''</span>WindowButtonDownFcn<span class="string">''</span>,<span class="string">''</span><span class="string">''</span>)<span class="string">');
	lasterr('</span><span class="string">');
	try
		waitfor(fig,'</span>WindowButtonDownFcn<span class="string">','</span><span class="string">');
		wasInterrupted = 0;
	catch
		wasInterrupted = 1;
	<span class="keyword">end</span>
	wasKeyPress = ~wasInterrupted & strcmp(get(fig,'</span>KeyPressFcn<span class="string">'),'</span><span class="string">');
	<span class="keyword">if</span> wasInterrupted, errstr=lasterr; <span class="keyword">end</span>;
	<span class="comment">% restore ButtonDownFcn and other figure values</span>
	set(objs,'</span>ButtonDownFcn<span class="string">',buttonDownFcns);
	set(fig,figProps,figValue);



<span class="keyword">function</span> [out,is2D] = arrow_is2DXY(ax)
<span class="comment">% check <span class="keyword">if</span> axes are 2-D X-Y plots</span>
	<span class="comment">% may not work <span class="keyword">for</span> modified camera angles, etc.</span>
	out = false(size(ax)); <span class="comment">% 2-D X-Y plots</span>
	is2D = out;                     <span class="comment">% any 2-D plots</span>
	views = get(ax(:),{'</span>View<span class="string">'});
	views = cat(1,views{:});
	out(:) = abs(views(:,2))==90;
	is2D(:) = out(:) | all(rem(views'</span>,90)==0)<span class="string">';

<span class="keyword">function</span> out = arrow_planarkids(ax)
<span class="comment">% check <span class="keyword">if</span> axes descendents all have empty ZData (lines,patches,surfaces)</span>
	out = true(size(ax));
	allkids = get(ax(:),{'</span>Children<span class="string">'});
	<span class="keyword">for</span> k=1:length(allkids),
		kids = get([findobj(allkids{k},'</span>flat<span class="string">','</span>Type<span class="string">','</span>line<span class="string">')
		            findobj(allkids{k},'</span>flat<span class="string">','</span>Type<span class="string">','</span>patch<span class="string">')
		            findobj(allkids{k},'</span>flat<span class="string">','</span>Type<span class="string">','</span>surface<span class="string">')],{'</span>ZData<span class="string">'});
		<span class="keyword">for</span> j=1:length(kids),
			<span class="keyword">if</span> ~isempty(kids{j}), out(k)=logical(0); break; <span class="keyword">end</span>;
		<span class="keyword">end</span>;
	<span class="keyword">end</span>;



<span class="keyword">function</span> arrow_fixlimits(ax,lims)
<span class="comment">% reset the axis limits as necessary</span>
	<span class="keyword">if</span> isempty(ax) || isempty(lims), disp([upper(mfilename) '</span> does not remember any axis limits to reset.<span class="string">']); <span class="keyword">end</span>;
	<span class="keyword">for</span> k=1:numel(ax),
		<span class="keyword">if</span> any(get(ax(k),'</span>XLim<span class="string">')~=lims(1:2,k)'</span>), set(ax(k),<span class="string">'XLim'</span>,lims(1:2,k)<span class="string">'); <span class="keyword">end</span>;
		<span class="keyword">if</span> any(get(ax(k),'</span>YLim<span class="string">')~=lims(3:4,k)'</span>), set(ax(k),<span class="string">'YLim'</span>,lims(3:4,k)<span class="string">'); <span class="keyword">end</span>;
		<span class="keyword">if</span> any(get(ax(k),'</span>ZLim<span class="string">')~=lims(5:6,k)'</span>), set(ax(k),<span class="string">'ZLim'</span>,lims(5:6,k)<span class="string">'); <span class="keyword">end</span>;
	<span class="keyword">end</span>;



<span class="keyword">function</span> out = arrow_WarpToFill(notstretched,manualcamera,curax)
<span class="comment">% check <span class="keyword">if</span> we are in "WarpToFill" mode.</span>
	out = strcmp(get(curax,'</span>WarpToFill<span class="string">'),'</span>on<span class="string">');
	<span class="comment">% '</span>WarpToFill<span class="string">' is undocumented, so may need to replace this by</span>
	<span class="comment">% out = ~( any(notstretched) & any(manualcamera) );</span>



<span class="keyword">function</span> out = arrow_warnlimits(ax,narrows)
<span class="comment">% create a warning message <span class="keyword">if</span> we'</span>ve changed the axis limits</span>
	msg = <span class="string">''</span>;
	<span class="keyword">switch</span> (numel(ax))
		<span class="keyword">case</span> 1, msg=<span class="string">''</span>;
		<span class="keyword">case</span> 2, msg=<span class="string">'on two axes '</span>;
		<span class="keyword">otherwise</span>, msg=<span class="string">'on several axes '</span>;
	<span class="keyword">end</span>;
	msg = [upper(mfilename) <span class="string">' changed the axis limits '</span> msg ...
	       <span class="string">'when adding the arrow'</span>];
	<span class="keyword">if</span> (narrows>1), msg=[msg <span class="string">'s'</span>]; <span class="keyword">end</span>;
	out = [msg <span class="string">'.'</span> sprintf(<span class="string">'\n'</span>) <span class="string">'         Call '</span> upper(mfilename) ...
	       <span class="string">' FIXLIMITS to reset them now.'</span>];



<span class="keyword">function</span> arrow_copyprops(fm,to)
<span class="comment">% copy line properties to patches</span>
	props  = {<span class="string">'EraseMode'</span>,<span class="string">'LineStyle'</span>,<span class="string">'LineWidth'</span>,<span class="string">'Marker'</span>,<span class="string">'MarkerSize'</span>,...
	          <span class="string">'MarkerEdgeColor'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'ButtonDownFcn'</span>,      ...
	          <span class="string">'Clipping'</span>,<span class="string">'DeleteFcn'</span>,<span class="string">'BusyAction'</span>,<span class="string">'HandleVisibility'</span>,   ...
	          <span class="string">'Selected'</span>,<span class="string">'SelectionHighlight'</span>,<span class="string">'Visible'</span>};
	<span class="keyword">if</span> ~isnumeric(findobj(<span class="string">'Type'</span>,<span class="string">'root'</span>)), props(strcmp(props,<span class="string">'EraseMode'</span>))=[]; <span class="keyword">end</span>; <span class="comment">%eaj 5/24/16</span>
	lineprops  = {<span class="string">'Color'</span>,    props{:}};
	patchprops = {<span class="string">'EdgeColor'</span>,props{:}};
	patch2props = {<span class="string">'FaceColor'</span>,patchprops{:}};
	fmpatch = strcmp(get(fm,<span class="string">'Type'</span>),<span class="string">'patch'</span>);
	topatch = strcmp(get(to,<span class="string">'Type'</span>),<span class="string">'patch'</span>);
	set(to( fmpatch& topatch),patch2props,get(fm( fmpatch& topatch),patch2props)); <span class="comment">%p->p</span>
	set(to(~fmpatch&~topatch),lineprops,  get(fm(~fmpatch&~topatch),lineprops  )); <span class="comment">%l->l</span>
	set(to( fmpatch&~topatch),lineprops,  get(fm( fmpatch&~topatch),patchprops )); <span class="comment">%p->l</span>
	set(to(~fmpatch& topatch),patchprops, get(fm(~fmpatch& topatch),lineprops)  ,<span class="string">'FaceColor'</span>,<span class="string">'none'</span>); <span class="comment">%l->p</span>



<span class="keyword">function</span> arrow_props
<span class="comment">% display further help info about ARROW properties</span>
	c = sprintf(<span class="string">'\n'</span>);
	disp([c ...
	<span class="string">'ARROW Properties:  Default values are given in [square brackets], and other'</span> c ...
	<span class="string">'                   acceptable equivalent property names are in (parenthesis).'</span> c c ...
	<span class="string">'  Start           The starting points. For N arrows,            B'</span> c ...
	<span class="string">'                  this should be a Nx2 or Nx3 matrix.          /|\           ^'</span> c ...
	<span class="string">'  Stop            The <span class="keyword">end</span> points. For N arrows, this          /|||\          |'</span> c ...
	<span class="string">'                  should be a Nx2 or Nx3 matrix.             //|||\\        L|'</span> c ...
	<span class="string">'  Length          Length of the arrowhead (in pixels on     ///|||\\\       e|'</span> c ...
	<span class="string">'                  screen, points on a page). [16] (Len)    ////|||\\\\      n|'</span> c ...
	<span class="string">'  BaseAngle       Angle (degrees) of the base angle       /////|D|\\\\\     g|'</span> c ...
	<span class="string">'                  ADE.  For a simple stick arrow, use    ////  |||  \\\\    t|'</span> c ...
	<span class="string">'                  BaseAngle=TipAngle. [90] (Base)       ///    |||    \\\   h|'</span> c ...
	<span class="string">'  TipAngle        Angle (degrees) of tip angle ABC.    //<----->||      \\   |'</span> c ...
	<span class="string">'                  [16] (Tip)                          /   base |||        \  V'</span> c ...
	<span class="string">'  Width           Width of the base in pixels.  Not  E   angle ||<-------->C'</span> c ...
	<span class="string">'                  the '</span><span class="string">'LineWidth'</span><span class="string">' prop. [0] (Wid)            |||tipangle'</span> c ...
	<span class="string">'  Page            If provided, non-empty, and not NaN,         |||'</span> c ...
	<span class="string">'                  this causes ARROW to use hardcopy            |||'</span> c ...
	<span class="string">'                  rather than onscreen proportions.             A'</span> c ...
	<span class="string">'                  This is important <span class="keyword">if</span> screen aspect        -->   <-- width'</span> c ...
	<span class="string">'                  ratio and hardcopy aspect ratio are    ----CrossDir---->'</span> c ...
	<span class="string">'                  vastly different. []'</span> c...
	<span class="string">'  CrossDir        A vector giving the direction towards which the fletches'</span> c ...
	<span class="string">'                  on the arrow should go.  [computed such that it is perpen-'</span> c ...
	<span class="string">'                  dicular to both the arrow direction and the view direction'</span> c ...
	<span class="string">'                  (i.e., as <span class="keyword">if</span> it was pasted on a normal 2-D graph)]  (Note'</span> c ...
	<span class="string">'                  that CrossDir is a vector.  Also note that <span class="keyword">if</span> an axis is'</span> c ...
	<span class="string">'                  plotted on a log scale, then the corresponding component'</span> c ...
	<span class="string">'                  of CrossDir must also be set appropriately, i.e., to 1 <span class="keyword">for</span>'</span> c ...
	<span class="string">'                  no change in that direction, >1 <span class="keyword">for</span> a positive change, >0'</span> c ...
	<span class="string">'                  and <1 <span class="keyword">for</span> negative change.)'</span> c ...
	<span class="string">'  NormalDir       A vector normal to the fletch direction (CrossDir is then'</span> c ...
	<span class="string">'                  computed by the vector cross product [Line]x[NormalDir]). []'</span> c ...
	<span class="string">'                  (Note that NormalDir is a vector.  Unlike CrossDir,'</span> c ...
	<span class="string">'                  NormalDir is used as is regardless of log-scaled axes.)'</span> c ...
	<span class="string">'  Ends            Set which <span class="keyword">end</span> has an arrowhead.  Valid values are '</span><span class="string">'none'</span><span class="string">','</span> c ...
	<span class="string">'                  '</span><span class="string">'stop'</span><span class="string">', '</span><span class="string">'start'</span><span class="string">', and '</span><span class="string">'both'</span><span class="string">'. ['</span><span class="string">'stop'</span><span class="string">'] (End)'</span> c...
	<span class="string">'  ShortenLength   Shorten length of arrowhead(s) <span class="keyword">if</span> line is too short'</span> c ...
	<span class="string">'  ObjectHandles   Vector of handles to previously-created arrows to be'</span> c ...
	<span class="string">'                  updated or line objects to be converted to arrows.'</span> c ...
	<span class="string">'                  [] (Object,Handle)'</span> c ...
	<span class="string">'  Type            '</span><span class="string">'patch'</span><span class="string">' creates the arrow with a PATCH object (the default)'</span> c ...
	<span class="string">'                  and '</span><span class="string">'line'</span><span class="string">' creates it with a LINE object ['</span><span class="string">'patch'</span><span class="string">'].'</span> c ...
	<span class="string">'  Color           For patch arrows (the default), set both '</span><span class="string">'FaceColor'</span><span class="string">' and'</span> c ...
	<span class="string">'                  '</span><span class="string">'EdgeColor'</span><span class="string">' to the given value.  For line arrows, set'</span> c ...
	<span class="string">'                  the '</span><span class="string">'Color'</span><span class="string">' property to the given value.'</span> c ...
	]);



<span class="keyword">function</span> out = arrow_demo
 	<span class="comment">% demo</span>
	<span class="comment">% create the data</span>
	[x,y,z] = peaks;
	[ddd,out.iii]=max(z(:));
	out.axlim = [min(x(:)) max(x(:)) min(y(:)) max(y(:)) min(z(:)) max(z(:))];
	
	<span class="comment">% modify it by inserting some NaN<span class="string">'s</span>
	[m,n] = size(z);
	m = floor(m/2);
	n = floor(n/2);
	z(1:m,1:n) = NaN*ones(m,n);
	
	<span class="comment">% graph it</span>
	clf('</span>reset<span class="string">');
	out.hs=surf(x,y,z);
	out.x=x; out.y=y; out.z=z;
	xlabel('</span>x<span class="string">'); ylabel('</span>y<span class="string">');
			
<span class="keyword">function</span> h = arrow_demo3(in)
	<span class="comment">% set the view</span>
	axlim = in.axlim;
	axis(axlim);
	zlabel('</span>z<span class="string">');
	<span class="comment">%set(in.hs,'</span>FaceColor<span class="string">','</span>interp<span class="string">');</span>
	view(3); <span class="comment">% view(viewmtx(-37.5,30,20));</span>
	title(['</span>Demo of the capabilities of the ARROW <span class="keyword">function</span> in 3-D<span class="string">']);
	
	<span class="comment">% Normal blue arrow</span>
	h1 = feval(mfilename,[axlim(1) axlim(4) 4],[-.8 1.2 4], ...
	           '</span>EdgeColor<span class="string">','</span>b<span class="string">','</span>FaceColor<span class="string">','</span>b<span class="string">');
	
	<span class="comment">% Normal white arrow, clipped by the surface</span>
	h2 = feval(mfilename,axlim([1 4 6]),[0 2 4]);
	t=text(-2.4,2.7,7.7,'</span>arrow clipped by surf<span class="string">');
	
	<span class="comment">% Baseangle<90</span>
	h3 = feval(mfilename,[3 .125 3.5],[1.375 0.125 3.5],30,50);
	t2=text(3.1,.125,3.5,'</span>local maximum<span class="string">');
	
	<span class="comment">% Baseangle<90, fill and edge colors different</span>
	h4 = feval(mfilename,axlim(1:2:5)*.5,[0 0 0],36,60,25, ...
	           '</span>EdgeColor<span class="string">','</span>b<span class="string">','</span>FaceColor<span class="string">','</span>c<span class="string">');
	t3=text(axlim(1)*.5,axlim(3)*.5,axlim(5)*.5-.75,'</span>origin<span class="string">');
	set(t3,'</span>HorizontalAlignment<span class="string">','</span>center<span class="string">');
	
	<span class="comment">% Baseangle>90, black fill</span>
	h5 = feval(mfilename,[-2.9 2.9 3],[-1.3 .4 3.2],30,120,[],6, ...
	           '</span>EdgeColor<span class="string">','</span>r<span class="string">','</span>FaceColor<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',2);
	
	<span class="comment">% Baseangle>90, no fill</span>
	h6 = feval(mfilename,[-2.9 2.9 1.3],[-1.3 .4 1.5],30,120,[],6, ...
	           '</span>EdgeColor<span class="string">','</span>r<span class="string">','</span>FaceColor<span class="string">','</span>none<span class="string">','</span>LineWidth<span class="string">',2);
	
	<span class="comment">% Stick arrow</span>
	h7 = feval(mfilename,[-1.6 -1.65 -6.5],[0 -1.65 -6.5],[],16,16);
	t4=text(-1.5,-1.65,-7.25,'</span>global mininum<span class="string">');
	set(t4,'</span>HorizontalAlignment<span class="string">','</span>center<span class="string">');
	
	<span class="comment">% Normal, black fill</span>
	h8 = feval(mfilename,[-1.4 0 -7.2],[-1.4 0 -3],'</span>FaceColor<span class="string">','</span>k<span class="string">');
	t5=text(-1.5,0,-7.75,'</span>local minimum<span class="string">');
	set(t5,'</span>HorizontalAlignment<span class="string">','</span>center<span class="string">');
	
	<span class="comment">% Gray fill, crossdir specified, '</span>LineStyle<span class="string">' --</span>
	h9 = feval(mfilename,[-3 2.2 -6],[-3 2.2 -.05],36,[],27,6,[],[0 -1 0], ...
	           '</span>EdgeColor<span class="string">','</span>k<span class="string">','</span>FaceColor<span class="string">',.75*[1 1 1],'</span>LineStyle<span class="string">','</span>--<span class="string">');
	
	<span class="comment">% a series of normal arrows, linearly spaced, crossdir specified</span>
	h10y=(0:4)'</span>/3;
	h10 = feval(mfilename,[-3*ones(size(h10y)) h10y -6.5*ones(size(h10y))], ...
	            [-3*ones(size(h10y)) h10y -.05*ones(size(h10y))], ...
	            12,[],[],[],[],[0 -1 0]);
	
	<span class="comment">% a series of normal arrows, linearly spaced</span>
	h11x=(1:.33:2.8)<span class="string">';
	h11 = feval(mfilename,[h11x -3*ones(size(h11x)) 6.5*ones(size(h11x))], ...
	            [h11x -3*ones(size(h11x)) -.05*ones(size(h11x))]);
	
	<span class="comment">% series of magenta arrows, radially oriented, crossdir specified</span>
	h12x=2; h12y=-3; h12z=axlim(5)/2; h12xr=1; h12zr=h12z; ir=.15;or=.81;
	h12t=(0:11)'</span>/6*pi;
	h12 = feval(mfilename,                                           ...
	            [h12x+h12xr*cos(h12t)*ir h12y*ones(size(h12t))       ...
	             h12z+h12zr*sin(h12t)*ir],[h12x+h12xr*cos(h12t)*or   ...
	             h12y*ones(size(h12t)) h12z+h12zr*sin(h12t)*or],     ...
	            10,[],[],[],[],                                      ...
	            [-h12xr*sin(h12t) zeros(size(h12t)) h12zr*cos(h12t)],...
	            <span class="string">'FaceColor'</span>,<span class="string">'none'</span>,<span class="string">'EdgeColor'</span>,<span class="string">'m'</span>);
	
	<span class="comment">% series of normal arrows, tangentially oriented, crossdir specified</span>
	or13=.91; h13t=(0:.5:12)<span class="string">'/6*pi;
	locs = [h12x+h12xr*cos(h13t)*or13 h12y*ones(size(h13t)) h12z+h12zr*sin(h13t)*or13];
	h13 = feval(mfilename,locs(1:<span class="keyword">end</span>-1,:),locs(2:<span class="keyword">end</span>,:),6);
	
	<span class="comment">% arrow with no line ==> oriented downwards</span>
	h14 = feval(mfilename,[3 3 .100001],[3 3 .1],30);
	t6=text(3,3,3.6,'</span>no line<span class="string">'); set(t6,'</span>HorizontalAlignment<span class="string">','</span>center<span class="string">');
	
	<span class="comment">% arrow with arrowheads at both ends</span>
	h15 = feval(mfilename,[-.5 -3 -3],[1 -3 -3],'</span>Ends<span class="string">','</span>both<span class="string">','</span>FaceColor<span class="string">','</span>g<span class="string">', ...
	            '</span>Length<span class="string">',20,'</span>Width<span class="string">',3,'</span>CrossDir<span class="string">',[0 0 1],'</span>TipAngle<span class="string">',25);
	
	h=[h1;h2;h3;h4;h5;h6;h7;h8;h9;h10;h11;h12;h13;h14;h15];

<span class="keyword">function</span> h = arrow_demo2(in)
	axlim = in.axlim;
	dolog = 1;
	<span class="keyword">if</span> (dolog), set(in.hs,'</span>YData<span class="string">',10.^get(in.hs,'</span>YData<span class="string">')); <span class="keyword">end</span>;
	shading('</span>interp<span class="string">');
	view(2);
	title(['</span>Demo of the capabilities of the ARROW <span class="keyword">function</span> in 2-D<span class="string">']);
	hold on; [C,H]=contour(in.x,in.y,in.z,20,'</span>-<span class="string">'); hold off;
	<span class="keyword">for</span> k=H'</span>,
		set(k,<span class="string">'ZData'</span>,(axlim(6)+1)*ones(size(get(k,<span class="string">'XData'</span>))),<span class="string">'Color'</span>,<span class="string">'k'</span>);
		<span class="keyword">if</span> (dolog), set(k,<span class="string">'YData'</span>,10.^get(k,<span class="string">'YData'</span>)); <span class="keyword">end</span>;
	<span class="keyword">end</span>;
	<span class="keyword">if</span> (dolog), axis([axlim(1:2) 10.^axlim(3:4)]); set(gca,<span class="string">'YScale'</span>,<span class="string">'log'</span>);
	<span class="keyword">else</span>,       axis(axlim(1:4)); <span class="keyword">end</span>;
	
	<span class="comment">% Normal blue arrow</span>
	start = [axlim(1) axlim(4) axlim(6)+2];
	stop  = [in.x(in.iii) in.y(in.iii) axlim(6)+2];
	<span class="keyword">if</span> (dolog), start(:,2)=10.^start(:,2); stop(:,2)=10.^stop(:,2); <span class="keyword">end</span>;
	h1 = feval(mfilename,start,stop,<span class="string">'EdgeColor'</span>,<span class="string">'b'</span>,<span class="string">'FaceColor'</span>,<span class="string">'b'</span>);
	
	<span class="comment">% three arrows with varying fill, width, and baseangle</span>
	start = [-3   -3   10; -3   -1.5 10; -1.5 -3   10];
	stop  = [-.03 -.03 10; -.03 -1.5 10; -1.5 -.03 10];
	<span class="keyword">if</span> (dolog), start(:,2)=10.^start(:,2); stop(:,2)=10.^stop(:,2); <span class="keyword">end</span>;
	h2 = feval(mfilename,start,stop,24,[90;60;120],[],[0;0;4],<span class="string">'Ends'</span>,str2mat(<span class="string">'both'</span>,<span class="string">'stop'</span>,<span class="string">'stop'</span>));
	set(h2(2),<span class="string">'EdgeColor'</span>,[0 .35 0],<span class="string">'FaceColor'</span>,[0 .85 .85]);
	set(h2(3),<span class="string">'EdgeColor'</span>,<span class="string">'r'</span>,<span class="string">'FaceColor'</span>,[1 .5 1]);
	h=[h1;h2];

<span class="keyword">function</span> out = trueornan(x)
<span class="keyword">if</span> isempty(x),
	out=x;
<span class="keyword">else</span>,
	out = isnan(x);
	out(~out) = x(~out);
<span class="keyword">end</span>;
</code></pre></div>
</div>
<div id='buildVerletList' class='doc-content' style='display: none;'>
<h1>BUILDVERLETLIST build the Verlet list of X</h1>
<p>USAGE: verletList = buildVerletList(X [, cutoff, sorton, nblocks, verbose, excludedfromsearch, excludedneighbors])<br/>[verletList,cutoff,dmin,config,distances] = buildVerletList(...)<br/>verletList =  buildVerletList(X,config)</p>
<p>WARNING use selfVerletList to add self in the list<br/>verletList =  selfVerletlist(buildVerletList(...))</p>
<p>Inputs:<br/>X: n x 3 or n x 2  matrix containing the coordinates of particles<br/>a table with columns &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27;<br/>a table with columns &#x27;x&#x27; &#x27;y&#x27;<br/>a cell {Xgrid X} to search the neighbors X around Xgrid<br/>cutoff: the cutoff distance for building the Verlet list<br/>by default: cutoff = distribution mode (1000 classes)<br/>sorton: flag to force the VerletList to be sorted in the increasing order<br/>by default: sorton = true<br/>nblocks: number of blocks to reduce the amount memory required (typically max 8 GB)<br/>verbose: set it to false to remove messages<br/>excludedfromsearch: nx1 logical array (true if the coordinate does not need to be included in the search).<br/>excludedneighbors: nx1 logical array (true if the coordinate is not a possible neihgbor)</p>
<p>Additional inputs (internal use)<br/>entity: &#x27;atom&#x27; (default) or &#x27;grid point&#x27;</p>
<p>Outputs:<br/>verletList: n x 1 cell coding for the Verlet list<br/>verletList{i} list all indices j wihtin the cutoff distance<br/>if sorton is used, verletList{i}(1) is the closest neighbor<br/>cutoff: cutoff distance as provided or estimated<br/>dmin: minimum distance (off-diagonal term)<br/>config: configuration structure to be used with updateVerletList()<br/>distances: pair distance matrix (=NaN if nblocks&gt;1)</p>
<h2>See also</h2>
<p><a href="#updateVerletList">updateVerletList</a>, <a href="#partitionVerletList">partitionVerletList</a>, <a href="#selfVerletList">selfVerletList</a>, <a href="#interp3SPHVerlet">interp3SPHVerlet</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [verletList,cutoffout,dminout,config,distout] = buildVerletList(X, cutoff, sorton, nblocks, verbose, excludedfromsearch, excludedneighbors,entity)
<span class="comment">%BUILDVERLETLIST build the Verlet list of X</span>
<span class="comment">%</span>
<span class="comment">%   USAGE: verletList = buildVerletList(X [, cutoff, sorton, nblocks, verbose, excludedfromsearch, excludedneighbors])</span>
<span class="comment">%           [verletList,cutoff,dmin,config,distances] = buildVerletList(...)</span>
<span class="comment">%           verletList =  buildVerletList(X,config)</span>
<span class="comment">%</span>
<span class="comment">%   WARNING use selfVerletList to add self in the list</span>
<span class="comment">%           verletList =  selfVerletlist(buildVerletList(...))</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%    Inputs:</span>
<span class="comment">%                    X: n x 3 or n x 2  matrix containing the coordinates of particles</span>
<span class="comment">%                       a table with columns <span class="string">'x'</span> <span class="string">'y'</span> <span class="string">'z'</span></span>
<span class="comment">%                       a table with columns <span class="string">'x'</span> <span class="string">'y'</span></span>
<span class="comment">%                       a cell {Xgrid X} to search the neighbors X around Xgrid</span>
<span class="comment">%               cutoff: the cutoff distance <span class="keyword">for</span> building the Verlet list</span>
<span class="comment">%                       by default: cutoff = distribution mode (1000 classes)</span>
<span class="comment">%               sorton: flag to force the VerletList to be sorted in the increasing order</span>
<span class="comment">%                        by default: sorton = true</span>
<span class="comment">%              nblocks: number of blocks to reduce the amount memory required (typically max 8 GB)</span>
<span class="comment">%              verbose: set it to false to remove messages</span>
<span class="comment">%   excludedfromsearch: nx1 logical array (true <span class="keyword">if</span> the coordinate does not need to be included in the search).</span>
<span class="comment">%    excludedneighbors: nx1 logical array (true <span class="keyword">if</span> the coordinate is not a possible neihgbor)</span>
<span class="comment">%</span>
<span class="comment">%   Additional inputs (internal use)</span>
<span class="comment">%               entity: <span class="string">'atom'</span> (default) or <span class="string">'grid point'</span></span>
<span class="comment">%</span>
<span class="comment">%   Outputs:</span>
<span class="comment">%           verletList: n x 1 cell coding <span class="keyword">for</span> the Verlet list</span>
<span class="comment">%                       verletList{i} list all indices j wihtin the cutoff distance</span>
<span class="comment">%                       <span class="keyword">if</span> sorton is used, verletList{i}(1) is the closest neighbor</span>
<span class="comment">%               cutoff: cutoff distance as provided or estimated</span>
<span class="comment">%                 dmin: minimum distance (off-diagonal term)</span>
<span class="comment">%               config: configuration structure to be used with updateVerletList()</span>
<span class="comment">%            distances: pair distance matrix (=NaN <span class="keyword">if</span> nblocks>1)</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: updateVerletList, partitionVerletList, selfVerletList, interp3SPHVerlet</span>

<span class="comment">% Example</span>
<span class="comment">%{ </span>
    n = 3e4; <span class="comment">%number of particles</span>
    <span class="comment">% 3D example</span>
    X = rand(n, 3)*100;
    cutoff = 10;
    <span class="comment">% 3D neighbors within cutoff distance</span>
    v = buildVerletList(X,cutoff);
    figure, hold on
    nsamples = 10;
    samples = round(rand(nsamples,1)*n);
    colors = parula(nsamples);
    <span class="keyword">for</span> i = 1:nsamples
        plot3D(X(samples(i),:),<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,colors(i,:),<span class="string">'MarkerEdgeColor'</span>,colors(i,:))
        plot3D(X(v{samples(i)},:),<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'none'</span>,<span class="string">'MarkerEdgeColor'</span>,colors(i,:))
    <span class="keyword">end</span>
    <span class="comment">% 2D neighbors within cutoff distance</span>
    v2 = buildVerletList(X(:,1:2),cutoff);
    <span class="keyword">for</span> i = 1:nsamples
        plot(X(samples(i),1),X(samples(i),2),<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,colors(i,:),<span class="string">'MarkerEdgeColor'</span>,colors(i,:))
        plot(X(v2{samples(i)},1),X(v2{samples(i)},2),<span class="string">'o'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'none'</span>,<span class="string">'MarkerEdgeColor'</span>,colors(i,:))
    <span class="keyword">end</span>
    view(3), axis equal
<span class="comment">%}</span>

<span class="comment">% MS 3.0 | 2023-03-25 | INRAE\Olivier.vitrac@agroparistech.fr | rev. 2024-03-04</span>


<span class="comment">% Revision history</span>
<span class="comment">% 2023-03-29 add nblocks and verbose</span>
<span class="comment">% 2023-03-31 improved code with validation</span>
<span class="comment">% 2023-04-01 <span class="keyword">return</span> and accept config, accept X as a table</span>
<span class="comment">% 2023-05-16 accept {Xgrid X} as input #1 to list neigbors X around a grid (Xgrid)</span>
<span class="comment">% 2023-05-17 updated help</span>
<span class="comment">% 2023-08-31 fix time counter</span>
<span class="comment">% 2023-09-09 add entity</span>
<span class="comment">% 2024-02-22 manage 2D data and tables also with blocks</span>
<span class="comment">% 2024-02-23 reduce memoryloadGB in 2D</span>
<span class="comment">% 2024-03-04 update the block decomposition to fit a perfect square <span class="keyword">if</span> needed in 2D (nB)</span>

<span class="comment">%% Constants</span>
targetedNumberOfNeighbors = 100; <span class="comment">% number of maximum neighbors expected (it is a maximum guess to be used to estimate a cutoff)</span>
bytes = struct(<span class="string">'single'</span>,4,<span class="string">'double'</span>,8);
DEBUGON = false; <span class="comment">% set it to true to activate the debugging mode</span>
tolerance = 0.1; <span class="comment">% to be used by updateVerletList</span>

<span class="comment">%% Default</span>
sorton_default = true;     <span class="comment">% default sorton value</span>
verbose_default = true;    <span class="comment">% default verbosity</span>
maxmemoryloadGB = 8;       <span class="comment">% maximum load memeory <span class="keyword">for</span> pair distance (8 GB)</span>
memoryloadGB = [NaN 1/(2*3)^2 1] * maxmemoryloadGB;  <span class="comment">% maximum GB to be used (memoryloadGB(3) <span class="keyword">for</span> 3D and memoryloadGB(2) <span class="keyword">for</span> 2D)</span>

<span class="comment">%% Check arguments</span>
<span class="keyword">if</span> nargin<1, error(<span class="string">'one argument is required'</span>); <span class="keyword">end</span>
<span class="keyword">if</span> istable(X)
    coords = {<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}; <span class="comment">% the coordinates are selected in this order based on their availability (e.g. <span class="string">'x'</span> and <span class="string">'y'</span> in 2D)</span>
    availablecoords = coords(ismember(coords,X.Properties.VariableNames));
    X = table2array(X(:,availablecoords));
<span class="keyword">end</span> <span class="comment">% table2array used <span class="keyword">for</span> safety</span>
<span class="keyword">if</span> iscell(X)
    <span class="keyword">if</span> length(X)~=2, error(<span class="string">'the first argument should be {Xgrid Xpart}'</span>), <span class="keyword">end</span>
    Xgrid = X{1};
    X = X{2};
    hasgrid = true;
<span class="keyword">else</span>
    Xgrid = [];
    hasgrid = false;
<span class="keyword">end</span>
[n,d] = size(X); <span class="comment">% number of particless</span>
typ = class(X);  <span class="comment">% class of coordinates</span>
<span class="keyword">if</span> nargin<2, cutoff   = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, sorton   = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, nblocks  = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, verbose  = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<6, excludedfromsearch = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<7, excludedneighbors = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<8, entity = <span class="string">''</span>; <span class="keyword">end</span>
<span class="comment">% reuse a previous configuration</span>
<span class="keyword">if</span> isstruct(cutoff)
    config = cutoff;
    <span class="keyword">if</span> isfield(config,<span class="string">'engine'</span>) && strcmp(config.engine,<span class="string">'buildVerletList'</span>)
        <span class="keyword">if</span> (config.natoms ~= n) || (config.dimensions~=d)
            error(<span class="string">'the number of atoms (<span class="comment">%d) or/and dimensions (%d) have changed, expected %d x %d'</span>,...</span>
                n,d,config.natoms,confif.dimensions)
        <span class="keyword">end</span>
        cutoff = config.cutoff;
        sorton = config.sorton;
        nblocks = config.nblocks;
        verbose = config.verbose;
      tolerance = config.tolerance;
    <span class="keyword">else</span>
        error(<span class="string">'unrecognized configuration structure'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% assign default values <span class="keyword">if</span> needed</span>
<span class="keyword">if</span> isempty(cutoff) || cutoff<=0, cutoff = NaN; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(sorton), sorton = sorton_default; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(verbose), verbose = verbose_default; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(nblocks)
    nblocks = ceil((bytes.(typ) * d * n).^2 / (memoryloadGB(d)*1e9));
    <span class="keyword">if</span> d==2, nblocks = max(nblocks,nextpow2(n)); <span class="keyword">end</span> <span class="comment">% implement 2^nblocks rule <span class="keyword">for</span> the number of classes</span>
<span class="keyword">end</span>
<span class="keyword">if</span> isempty(entity), entity = "atom"; <span class="keyword">end</span>

<span class="comment">%% Grid management (look <span class="keyword">for</span> neighbors around grid points)</span>
<span class="keyword">if</span> hasgrid
    ngrid = size(Xgrid,1);
    [excludedfromsearch,excludedneighbors] = deal(false(n+ngrid,1));
    excludedfromsearch(1:n) = true;
    excludedneighbors(n+1:<span class="keyword">end</span>) = true;
    [verletList,cutoffout_,dminout_,config_,distout_] = ...
        buildVerletList([X;Xgrid], cutoff, sorton, nblocks, verbose, excludedfromsearch, excludedneighbors,<span class="string">'grid point'</span>);
    verletList = verletList(n+1:<span class="keyword">end</span>);
    distout_ = distout_(n+1:<span class="keyword">end</span>);
    <span class="keyword">if</span> nargout>1, cutoffout = cutoffout_; <span class="keyword">end</span>
    <span class="keyword">if</span> nargout>2, dminout = dminout_; <span class="keyword">end</span>
    <span class="keyword">if</span> nargout>3, config = config_; <span class="keyword">end</span>
    <span class="keyword">if</span> nargout>4, distout = distout_; <span class="keyword">end</span>
    <span class="keyword">return</span>
<span class="keyword">else</span>
    ngrid = 1;
    <span class="keyword">if</span> isempty(excludedfromsearch), excludedfromsearch = false(n,1); <span class="keyword">end</span>
    <span class="keyword">if</span> isempty(excludedneighbors), excludedneighbors = false(n,1); <span class="keyword">end</span>
    hasexclusions = any(excludedfromsearch) || any(excludedneighbors);
<span class="keyword">end</span>
<span class="keyword">if</span> hasexclusions
    ivalid = find(~excludedfromsearch);
    jvalid = find(~excludedneighbors);
    jvalidreverse(jvalid) = 1:length(jvalid); <span class="comment">% reverse operator</span>
<span class="keyword">else</span>
    [ivalid,jvalid] = deal([]); <span class="comment">% not used</span>
<span class="keyword">end</span>

<span class="comment">%% main()</span>
<span class="comment">% Allocate</span>
verletList = cell(n, 1); <span class="comment">% pre-allocate the Verlet list</span>
t__ = clock; t_ = t__;

<span class="comment">% Pseudo recursion <span class="keyword">if</span> nblocks > 1</span>
<span class="keyword">if</span> (nblocks > 1) && ismember(d,[2,3]) <span class="comment">% block splitting limited to 3D and 2D</span>

    range = [min(X,[],1); max(X,[],1)]; <span class="comment">% [mins;maxs]</span>
    drange = diff(range, 1, 1);
    nBmax = max(2, floor(drange / (2 * cutoff)));
    [~, is] = sort(drange, <span class="string">'ascend'</span>);
    nB = zeros(1, 3); <span class="comment">%zeros(1, d) (NB(3) is a singleton <span class="keyword">if</span> d == 2)</span>
    nB(is(1)) = max(1,min(nBmax(is(1)), floor(nblocks^(1/d))));               <span class="comment">% number of blocks along the smallest dimension</span>
    nB(is(2)) = max(1,min(nBmax(is(2)), floor((nblocks / nB(is(1))^(d-1))))); <span class="comment">% idem along the intermediate dimension</span>
    <span class="keyword">if</span> d==3
        nB(is(3)) = max(1,min(nBmax(is(3)), ceil(nblocks / (nB(is(1)) * nB(is(2)))))); <span class="comment">% along the longest one</span>
    <span class="keyword">else</span>
        nB(3) = 1; <span class="comment">% singleton in 2D but 2 limits to define one box</span>
    <span class="keyword">end</span>
    nB = nB + 1; <span class="comment">% conversion into the number of separators</span>
    xB = linspace(range(1, 1) - drange(1) / 20, range(2, 1) + drange(1) / 20, nB(1));
    yB = linspace(range(1, 2) - drange(2) / 20, range(2, 2) + drange(2) / 20, nB(2));
    <span class="keyword">if</span> d==3
        zB = linspace(range(1, 3) - drange(3) / 20, range(2, 3) + drange(3) / 20, nB(3));
    <span class="keyword">else</span>
        zB = 0; <span class="comment">% singleton in 2D (default value 0)</span>
    <span class="keyword">end</span>
    
    <span class="comment">% create meshgrid <span class="keyword">for</span> block indices</span>
    [ix, iy, iz] = meshgrid(1:nB(1)-1, 1:nB(2)-1, 1:nB(3)-1);
    ix = ix(:); iy = iy(:); iz = iz(:);
    nBall = numel(ix); dist = cell(n, 1); dmin = NaN; cutoffsafe = 1.1 * cutoff; screen = <span class="string">''</span>;
    <span class="keyword">if</span> d==3
        dispf(<span class="string">'buildVerletList splits <span class="comment">%d particles into a %d x %d x %d'</span>,n, nB(1)-1, nB(2)-1, nB(3)-1)</span>
    <span class="keyword">elseif</span> d==2
        dispf(<span class="string">'buildVerletList splits <span class="comment">%d particles into a %d x %d'</span>,n, nB(1)-1, nB(2)-1)</span>
    <span class="keyword">end</span>

    <span class="comment">% <span class="keyword">for</span> each block</span>
    wasempty = true;
    <span class="keyword">if</span> verbose, dispf(<span class="string">'Build Verlet list by searching in blocks...'</span>), <span class="keyword">end</span>
    <span class="keyword">for</span> iBall = 1:nBall
        <span class="comment">% points mask of considered entities/particles/beads</span>
        okxyz = (X(:, 1) > (xB(ix(iBall)) - cutoffsafe)) & (X(:, 1) < (xB(ix(iBall)+1) + cutoffsafe)) & ...
                (X(:, 2) > (yB(iy(iBall)) - cutoffsafe)) & (X(:, 2) < (yB(iy(iBall)+1) + cutoffsafe)); <span class="comment">% box + margins</span>
        <span class="keyword">if</span> d==3
            okxyz = okxyz & (X(:, 3) > (zB(iz(iBall)) - cutoffsafe)) & (X(:, 3) < (zB(iz(iBall)+1) + cutoffsafe)); <span class="comment">% box + margins</span>
        <span class="keyword">end</span>
        ind = find(okxyz)<span class="string">';       <span class="comment">% their indices (to be used <span class="keyword">for</span> conversion)</span>
        nind = numel(ind);        <span class="comment">% number of entities</span>
        narein = 0;               <span class="comment">% default value (to be updated)</span>
        nneighborsforthosein = 0; <span class="comment">% counter <span class="keyword">for</span> their neighbors</span>
        <span class="keyword">if</span> nind               <span class="comment">% some neighbors found</span>
            okinxyz =   (X(ind, 1) >= xB(ix(iBall))) & (X(ind, 1) <= xB(ix(iBall)+1)) & ...
                        (X(ind, 2) >= yB(iy(iBall))) & (X(ind, 2) <= yB(iy(iBall)+1));
            <span class="keyword">if</span> d==3
                okinxyz = okinxyz & (X(ind, 3) >= zB(iz(iBall))) & (X(ind, 3) <= zB(iz(iBall)+1));
            <span class="keyword">end</span>
            arein = find(okinxyz); <span class="comment">% relative indices of those inside the box</span>
            narein = length(arein);   <span class="comment">% number of entities in the box</span>
            [verletListtmp, cutoff, dmintmp, ~, disttmp] = buildVerletList(X(ind, :), cutoff, false, 0, false, excludedfromsearch(ind), excludedneighbors(ind));
            dmin = min(dmin,dmintmp);
            <span class="keyword">for</span> eachin = 1:narein     <span class="comment">% <span class="keyword">for</span> all elements in the temporary Verlet list</span>
                ind_current   = ind(arein(eachin));                <span class="comment">% scalar index <span class="keyword">if</span> the current entity</span>
                ind_neighbors = ind(verletListtmp{arein(eachin)}); <span class="comment">% vector of neighbor indices</span>
                nneighborsforthosein = nneighborsforthosein + length(ind_neighbors); <span class="comment">% counter of neighbors</span>
                verletList{ind_current} = ind_neighbors;           <span class="comment">% update the verlet list</span>
                dist{ind_current} = disttmp{arein(eachin)};        <span class="comment">% update the distance matrix</span>
            <span class="keyword">end</span> <span class="comment">% next eachin</span>
        <span class="keyword">else</span>
            dmintmp = NaN; 
        <span class="keyword">end</span> <span class="comment">% <span class="keyword">if</span> nind</span>
        <span class="keyword">if</span> verbose
            done = iBall/nBall; currenttime = clock; dt = etime(currenttime,t_);
            <span class="keyword">if</span> (dt>0.5) || wasempty
                dt_ = etime(currenttime,t__);
                screen = dispb(screen,'</span>[BLOCK <span class="comment">%d/%d] %d particles with %d neighbors/part. (%0.1f %% total) | min dist loc:%0.3g glob:%0.3g | elapsed %0.1f of %0.1f s | done %0.1f %% | remaining %0.1f s<span class="string">',...</span>
                    iBall,nBall,narein,round(nneighborsforthosein/narein),nind/n*100,dmintmp,dmin,dt,dt_,100*done,(1/done-1)*dt_);
                wasempty = (nneighborsforthosein==0); t_ = currenttime;
            <span class="keyword">end</span>
        <span class="keyword">end</span>


    <span class="keyword">end</span> <span class="comment">% next iBall</span>
    <span class="keyword">if</span> verbose, dispb(screen,'</span>... done in <span class="comment">%0.4g s with %d search blocks | minimum distance %0.4g<span class="string">',dt,nBall,dmin); <span class="keyword">end</span></span>

    <span class="comment">% DEBUG MODE (comparison without blocks, <span class="keyword">for</span> internal validation)</span>
    <span class="keyword">if</span> DEBUGON
        V = verletList; <span class="comment">%#ok<UNRCH> </span>
        V0 = buildVerletList(X, cutoff, sorton, 0, true);
        figure, hold on
        [YB,ZB] = meshgrid(yB,zB); <span class="keyword">for</span> x=xB, mesh(YB*0+x,YB,ZB,'</span>facecolor<span class="string">','</span>none<span class="string">','</span>edgecolor<span class="string">','</span>r<span class="string">'); <span class="keyword">end</span>
        [XB,ZB] = meshgrid(xB,zB); <span class="keyword">for</span> y=yB, mesh(XB,ZB*0+y,ZB,'</span>facecolor<span class="string">','</span>none<span class="string">','</span>edgecolor<span class="string">','</span>r<span class="string">'); <span class="keyword">end</span>
        [XB,YB] = meshgrid(xB,yB); <span class="keyword">for</span> z=zB, mesh(XB,YB,XB*0+z,'</span>facecolor<span class="string">','</span>none<span class="string">','</span>edgecolor<span class="string">','</span>r<span class="string">'); <span class="keyword">end</span>
        plot3D(X((cellfun(@length,V0)-cellfun(@length,V))>0,:),'</span>bs<span class="string">')
        xlabel('</span>x<span class="string">'), ylabel('</span>y<span class="string">'),zlabel('</span>z<span class="string">')
        view(3), axis equal, axis tight
        dispf('</span><span class="keyword">if</span> you do not see any bs, it is OK: <span class="comment">%d<span class="string">',max(cellfun(@length,V0)-cellfun(@length,V)))</span>
        disp('</span>make a break point here<span class="string">')
    <span class="keyword">end</span>


<span class="keyword">else</span> <span class="comment">% --------- vectorized code</span>

    <span class="comment">% Compute pairwise distances using the built-in pdist2 <span class="keyword">function</span></span>
    <span class="keyword">if</span> hasexclusions
        <span class="keyword">if</span> verbose, dispf('</span>Calculate the <span class="comment">%d x %d pair distances...<span class="string">',ngrid,n), t_ = clock; <span class="keyword">end</span> %#ok<*CLOCK></span>
        distances = pdist2(X(ivalid,:), X(jvalid,:));
    <span class="keyword">else</span>
        <span class="keyword">if</span> verbose, dispf('</span>Calculate the <span class="comment">%d x %d pair distances...<span class="string">',n,n), t_ = clock; <span class="keyword">end</span> %#ok<*CLOCK></span>
        distances = pdist2(X, X);
    <span class="keyword">end</span>
    <span class="keyword">if</span> verbose, dispf('</span>\t ... done in <span class="comment">%0.3g s<span class="string">',etime(clock,t_)), <span class="keyword">end</span> %#ok<*DETIM> </span>
    
    <span class="comment">% Estimate cutoff <span class="keyword">if</span> not provided (heuristic method)</span>
    <span class="comment">% cutoff is set to match targetedNumberOfNeighbors</span>
    <span class="comment">% without exceeding the mode of the distribution based on 1000 classes</span>
    <span class="comment">% note: <span class="keyword">if</span> the number of pair distances is very large, subsampling is applied</span>
    <span class="keyword">if</span> isnan(cutoff)
        <span class="keyword">if</span> verbose, dispf('</span>Estimate cutoff...<span class="string">'), t_ = clock; <span class="keyword">end</span>
        d = triu(distances,1); <span class="comment">% all pair distances (can be very large)</span>
        d = d(d>0); dmin = min(d);
        d = d(1:max(1,round(sqrt(length(d))/1000)):<span class="keyword">end</span>); <span class="comment">% subsampling</span>
        [c,d] = hist(d,1000); <span class="comment">%#ok<*HIST> </span>
        <span class="comment">% Identify the mode (maximum)</span>
        <span class="comment">% counts are smoothed with a moving average over 10 classes</span>
        <span class="comment">% figure, plot(d(1:<span class="keyword">end</span>-1),diff(filtzero(cumsum(c),10)))</span>
        cfit = 1000 * diff(filtzero(cumsum(c),10)) / n;
        d = d(1:<span class="keyword">end</span>-1) - d(1) + dmin;
        cfit = cfit-cfit(1); <span class="comment">% first value (no, meaning)</span>
        [~,imax] = max(cfit);
        <span class="comment">% cutoff range</span>
        cutoff_min = 2 * dmin;
        cutoff_max = d(imax);
        <span class="comment">% estimate the number of neighbors between cutoff_min and cutoff_max</span>
        <span class="comment">% use nearest and cumulated cfit, discard the first 10 data (poorly estimated)</span>
        cutoff = max(cutoff_min,min(cutoff_max,...
            d(nearestpoint(targetedNumberOfNeighbors,cumsum(cfit))+10)));
        <span class="keyword">if</span> verbose, dispf('</span>\t ... done in <span class="comment">%0.3g s (cutoff = %0.6g)<span class="string">',etime(clock,t_),cutoff), <span class="keyword">end</span></span>
    <span class="keyword">end</span>
    
    <span class="comment">% Find particle pairs within the cutoff distance</span>
    <span class="keyword">if</span> verbose, dispf('</span>Find atoms within cuttoff...<span class="string">'), t_ = clock; <span class="keyword">end</span>
    <span class="keyword">if</span> hasexclusions
        [rowIndices, colIndices] = find(distances <= cutoff);
        rowIndices = ivalid(rowIndices);
        colIndices = jvalid(colIndices);
    <span class="keyword">else</span>
        [rowIndices, colIndices] = find(triu(distances <= cutoff, 1));
    <span class="keyword">end</span>
    <span class="keyword">if</span> verbose, dispf('</span>\t ... done in <span class="comment">%0.3g s<span class="string">',etime(clock,t_)); <span class="keyword">end</span></span>
    
    
    <span class="comment">% Add the particle indices to the Verlet list</span>
    <span class="keyword">if</span> verbose ,dispf('</span>Build the Verlet list...<span class="string">'), t_ = clock; <span class="keyword">end</span>
    [t0,t1] = deal(clock);
    npairs = numel(rowIndices);
    screen = '</span><span class="string">';
    <span class="keyword">for</span> idx = 1:npairs
        <span class="keyword">if</span> mod(idx,100) == 0
            <span class="keyword">if</span> (etime(clock,t1) > 2) && verbose <span class="comment">% every two seconds</span>
                dt = etime(clock,t0);
                done = idx/npairs*100;
                screen = dispb(screen,...
                    '</span>Building the Verlet list [completed: <span class="comment">%0.3g%% | elapsed: %0.3g s | remaining: %0.3g s]<span class="string">',...</span>
                    done,dt,dt*(100/done-1));
                t1 = clock;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        i = rowIndices(idx);
        j = colIndices(idx);
        verletList{i}(<span class="keyword">end</span>+1) = j;
        <span class="keyword">if</span> ~hasexclusions
            verletList{j}(<span class="keyword">end</span>+1) = i;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> verbose
        verletCounts = cellfun(@length,verletList);
        dispf('</span>\t ... done in <span class="comment">%0.3g s [min=%d, median=%d, max=%d]<span class="string">',etime(clock,t_),min(verletCounts),round(median(verletCounts)),max(verletCounts))</span>
    <span class="keyword">end</span>

    <span class="comment">% short distances list (efficient), compute the dmin here (faster) // revised 2023-03-29</span>
    dmin = Inf;
    dist = cell(n,1);
    <span class="keyword">if</span> hasexclusions
        <span class="keyword">if</span> ~isempty(distances)
            <span class="keyword">for</span> i_=1:length(ivalid)
                i = ivalid(i_);
                dist{i} = distances(i_,jvalidreverse(verletList{i}));
                dmin = min(dmin,min(dist{i}));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="keyword">for</span> i=1:n
            dist{i} = distances(i,verletList{i});
            dmin = min(dmin,min(dist{i}));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

<span class="keyword">end</span> <span class="comment">% <span class="keyword">if</span> nblocks > 2</span>


<span class="comment">%% finalization</span>

<span class="comment">% Sort the Verlet list <span class="keyword">if</span> requested</span>
<span class="keyword">if</span> sorton
    <span class="keyword">if</span> verbose, dispf('</span>\t Sort the Verlet list...<span class="string">'), t_ = clock; <span class="keyword">end</span>
    <span class="keyword">for</span> i=1:n
        [~,u] = sort(dist{i},'</span>ascend<span class="string">');
        j = verletList{i};
        verletList{i} = j(u);
    <span class="keyword">end</span>
    <span class="keyword">if</span> verbose, dispf('</span>\t ... done in <span class="comment">%0.3g s<span class="string">',etime(clock,t_)), <span class="keyword">end</span></span>
<span class="keyword">end</span>

<span class="comment">% Final elapsed time</span>
timerq = etime(clock,t__);

<span class="comment">% Return cuttoff <span class="keyword">if</span> requested</span>
<span class="keyword">if</span> nargout>1, cutoffout = cutoff; <span class="keyword">end</span>

<span class="comment">% Return dmin <span class="keyword">if</span> requested</span>
<span class="keyword">if</span> nargout>2
    <span class="keyword">if</span> isempty(dmin)
        dminout = NaN;
    <span class="keyword">else</span>
        dminout = dmin;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Return config</span>
<span class="keyword">if</span> nargout>3
    config = struct( ...
            '</span>engine<span class="string">','</span>buildVerletList<span class="string">', ...
            '</span>elaspedtime<span class="string">',timerq,...
            '</span>natoms<span class="string">',n,...
            '</span>dimensions<span class="string">',d,...
            '</span>nblocks<span class="string">',nblocks,...
            '</span>cutoff<span class="string">',cutoff,...
            '</span>dmin<span class="string">',dmin,...
            '</span>sorton<span class="string">',sorton, ...
            '</span>verbose<span class="string">',verbose,...
            '</span>tolerance<span class="string">',tolerance,...
            '</span>nsamples<span class="string">',ceil(min(200,n*tolerance)) );
<span class="keyword">end</span>

<span class="comment">% Return distances <span class="keyword">if</span> required</span>
<span class="keyword">if</span> nargout>4, distout = dist; <span class="keyword">end</span>

<span class="comment">% final display</span>
<span class="keyword">if</span> verbose
    dispf('</span>buildVerletList: all done in <span class="comment">%0.3g s <span class="keyword">for</span> %d %ss',timerq,n,entity)</span>
<span class="keyword">end</span></code></pre></div>
</div>
<div id='buildVerletList3' class='doc-content' style='display: none;'>
<h1>BUILDVERLETLIST3 build the Verlet list of X when X is a nx3 vector, for arbitrary 2D or 3D X, use BUILDVERLIST for 2D datasets</h1>
<p>USAGE: verletList = buildVerletList3(X [, cutoff, sorton, nblocks, verbose, excludedfromsearch, excludedneighbors])<br/>[verletList,cutoff,dmin,config,distances] = buildVerletList3(...)<br/>verletList =  buildVerletList3(X,config)</p>
<p>WARNING use selfVerletList to add self in the list<br/>verletList =  selfVerletlist(buildVerletList3(...))</p>
<p>Inputs:<br/>X: n x 3 matrix containing the coordinates of particles<br/>a table with columns &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27;<br/>a cell {Xgrid X} to search the neighbors X around Xgrid<br/>cutoff: the cutoff distance for building the Verlet list<br/>by default: cutoff = distribution mode (1000 classes)<br/>sorton: flag to force the VerletList to be sorted in the increasing order<br/>by default: sorton = true<br/>nblocks: number of blocks to reduce the amount memory required (typically max 8 GB)<br/>verbose: set it to false to remove messages<br/>excludedfromsearch: nx1 logical array (true if the coordinate does not need to be included in the search).<br/>excludedneighbors: nx1 logical array (true if the coordinate is not a possible neihgbor)</p>
<p>Additional inputs (internal use)<br/>entity: &#x27;atom&#x27; (default) or &#x27;grid point&#x27;</p>
<p>Outputs:<br/>verletList: n x 1 cell coding for the Verlet list<br/>verletList{i} list all indices j wihtin the cutoff distance<br/>if sorton is used, verletList{i}(1) is the closest neighbor<br/>cutoff: cutoff distance as provided or estimated<br/>dmin: minimum distance (off-diagonal term)<br/>config: configuration structure to be used with updateVerletList()<br/>distances: pair distance matrix (=NaN if nblocks&gt;1)</p>
<h2>See also</h2>
<p><a href="#updateVerletList">updateVerletList</a>, <a href="#partitionVerletList">partitionVerletList</a>, <a href="#selfVerletList">selfVerletList</a>, <a href="#interp3SPHVerlet">interp3SPHVerlet</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [verletList,cutoffout,dminout,config,distout] = buildVerletList3(X, cutoff, sorton, nblocks, verbose, excludedfromsearch, excludedneighbors,entity)
<span class="comment">%BUILDVERLETLIST3 build the Verlet list of X when X is a nx3 vector, <span class="keyword">for</span> arbitrary 2D or 3D X, use BUILDVERLIST <span class="keyword">for</span> 2D datasets</span>
<span class="comment">%</span>
<span class="comment">%   USAGE: verletList = buildVerletList3(X [, cutoff, sorton, nblocks, verbose, excludedfromsearch, excludedneighbors])</span>
<span class="comment">%           [verletList,cutoff,dmin,config,distances] = buildVerletList3(...)</span>
<span class="comment">%           verletList =  buildVerletList3(X,config)</span>
<span class="comment">%</span>
<span class="comment">%   WARNING use selfVerletList to add self in the list</span>
<span class="comment">%           verletList =  selfVerletlist(buildVerletList3(...))</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%    Inputs:</span>
<span class="comment">%                    X: n x 3 matrix containing the coordinates of particles</span>
<span class="comment">%                       a table with columns <span class="string">'x'</span> <span class="string">'y'</span> <span class="string">'z'</span></span>
<span class="comment">%                       a cell {Xgrid X} to search the neighbors X around Xgrid</span>
<span class="comment">%               cutoff: the cutoff distance <span class="keyword">for</span> building the Verlet list</span>
<span class="comment">%                       by default: cutoff = distribution mode (1000 classes)</span>
<span class="comment">%               sorton: flag to force the VerletList to be sorted in the increasing order</span>
<span class="comment">%                        by default: sorton = true</span>
<span class="comment">%              nblocks: number of blocks to reduce the amount memory required (typically max 8 GB)</span>
<span class="comment">%              verbose: set it to false to remove messages</span>
<span class="comment">%   excludedfromsearch: nx1 logical array (true <span class="keyword">if</span> the coordinate does not need to be included in the search).</span>
<span class="comment">%    excludedneighbors: nx1 logical array (true <span class="keyword">if</span> the coordinate is not a possible neihgbor)</span>
<span class="comment">%</span>
<span class="comment">%   Additional inputs (internal use)</span>
<span class="comment">%               entity: <span class="string">'atom'</span> (default) or <span class="string">'grid point'</span></span>
<span class="comment">%</span>
<span class="comment">%   Outputs:</span>
<span class="comment">%           verletList: n x 1 cell coding <span class="keyword">for</span> the Verlet list</span>
<span class="comment">%                       verletList{i} list all indices j wihtin the cutoff distance</span>
<span class="comment">%                       <span class="keyword">if</span> sorton is used, verletList{i}(1) is the closest neighbor</span>
<span class="comment">%               cutoff: cutoff distance as provided or estimated</span>
<span class="comment">%                 dmin: minimum distance (off-diagonal term)</span>
<span class="comment">%               config: configuration structure to be used with updateVerletList()</span>
<span class="comment">%            distances: pair distance matrix (=NaN <span class="keyword">if</span> nblocks>1)</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: updateVerletList, partitionVerletList, selfVerletList, interp3SPHVerlet</span>


<span class="comment">% MS 3.0 | 2023-03-25 | INRAE\Olivier.vitrac@agroparistech.fr | rev. 2023-09-09</span>


<span class="comment">% Revision history</span>
<span class="comment">% 2023-03-29 add nblocks and verbose</span>
<span class="comment">% 2023-03-31 improved code with validation</span>
<span class="comment">% 2023-04-01 <span class="keyword">return</span> and accept config, accept X as a table</span>
<span class="comment">% 2023-05-16 accept {Xgrid X} as input #1 to list neigbors X around a grid (Xgrid)</span>
<span class="comment">% 2023-05-17 updated help</span>
<span class="comment">% 2023-08-31 fix time counter</span>
<span class="comment">% 2023-09-09 add entity</span>
<span class="comment">% 2024-02-22 original preserved 3D version, intended to be replaced by buildverletlist()</span>

<span class="comment">%% Constants</span>
targetedNumberOfNeighbors = 100; <span class="comment">% number of maximum neighbors expected (it is a maximum guess to be used to estimate a cutoff)</span>
bytes = struct(<span class="string">'single'</span>,4,<span class="string">'double'</span>,8);
DEBUGON = false; <span class="comment">% set it to true to activate the debugging mode</span>
tolerance = 0.1; <span class="comment">% to be used by updateVerletList</span>

<span class="comment">%% Default</span>
sorton_default = true; <span class="comment">% default sorton value</span>
verbose_default = true; <span class="comment">% default verbosity</span>
memoryloadGB = 8;      <span class="comment">% maximum GB to be used</span>

<span class="comment">%% Check arguments</span>
<span class="keyword">if</span> nargin<1, error(<span class="string">'one argument is required'</span>); <span class="keyword">end</span>
<span class="keyword">if</span> istable(X), X = table2array(X(:,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>})); <span class="keyword">end</span> <span class="comment">% table2array used <span class="keyword">for</span> safety</span>
<span class="keyword">if</span> iscell(X)
    <span class="keyword">if</span> length(X)~=2, error(<span class="string">'the first argument should be {Xgrid Xpart}'</span>), <span class="keyword">end</span>
    Xgrid = X{1};
    X = X{2};
    hasgrid = true;
<span class="keyword">else</span>
    Xgrid = [];
    hasgrid = false;
<span class="keyword">end</span>
[n,d] = size(X); <span class="comment">% number of particless</span>
typ = class(X);  <span class="comment">% class of coordinates</span>
<span class="keyword">if</span> nargin<2, cutoff   = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, sorton   = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, nblocks  = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, verbose  = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<6, excludedfromsearch = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<7, excludedneighbors = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<8, entity = <span class="string">''</span>; <span class="keyword">end</span>
<span class="comment">% reuse a previous configuration</span>
<span class="keyword">if</span> isstruct(cutoff)
    config = cutoff;
    <span class="keyword">if</span> isfield(config,<span class="string">'engine'</span>) && strcmp(config.engine,<span class="string">'buildVerletList'</span>)
        <span class="keyword">if</span> (config.natoms ~= n) || (config.dimensions~=d)
            error(<span class="string">'the number of atoms (<span class="comment">%d) or/and dimensions (%d) have changed, expected %d x %d'</span>,...</span>
                n,d,config.natoms,confif.dimensions)
        <span class="keyword">end</span>
        cutoff = config.cutoff;
        sorton = config.sorton;
        nblocks = config.nblocks;
        verbose = config.verbose;
      tolerance = config.tolerance;
    <span class="keyword">else</span>
        error(<span class="string">'unrecognized configuration structure'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% assign default values <span class="keyword">if</span> needed</span>
<span class="keyword">if</span> isempty(cutoff) || cutoff<=0, cutoff = NaN; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(sorton), sorton = sorton_default; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(verbose), verbose = verbose_default; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(nblocks), nblocks = ceil((bytes.(typ) * d * n).^2 / (memoryloadGB*1e9)); <span class="keyword">end</span>
<span class="keyword">if</span> isempty(entity), entity = "atom"; <span class="keyword">end</span>

<span class="comment">%% Grid management (look <span class="keyword">for</span> neighbors around grid points)</span>
<span class="keyword">if</span> hasgrid
    ngrid = size(Xgrid,1);
    [excludedfromsearch,excludedneighbors] = deal(false(n+ngrid,1));
    excludedfromsearch(1:n) = true;
    excludedneighbors(n+1:<span class="keyword">end</span>) = true;
    [verletList,cutoffout_,dminout_,config_,distout_] = ...
        buildVerletList3([X;Xgrid], cutoff, sorton, nblocks, verbose, excludedfromsearch, excludedneighbors,<span class="string">'grid point'</span>);
    verletList = verletList(n+1:<span class="keyword">end</span>);
    distout_ = distout_(n+1:<span class="keyword">end</span>);
    <span class="keyword">if</span> nargout>1, cutoffout = cutoffout_; <span class="keyword">end</span>
    <span class="keyword">if</span> nargout>2, dminout = dminout_; <span class="keyword">end</span>
    <span class="keyword">if</span> nargout>3, config = config_; <span class="keyword">end</span>
    <span class="keyword">if</span> nargout>4, distout = distout_; <span class="keyword">end</span>
    <span class="keyword">return</span>
<span class="keyword">else</span>
    ngrid = 1;
    <span class="keyword">if</span> isempty(excludedfromsearch), excludedfromsearch = false(n,1); <span class="keyword">end</span>
    <span class="keyword">if</span> isempty(excludedneighbors), excludedneighbors = false(n,1); <span class="keyword">end</span>
    hasexclusions = any(excludedfromsearch) || any(excludedneighbors);
<span class="keyword">end</span>
<span class="keyword">if</span> hasexclusions
    ivalid = find(~excludedfromsearch);
    jvalid = find(~excludedneighbors);
    jvalidreverse(jvalid) = 1:length(jvalid); <span class="comment">% reverse operator</span>
<span class="keyword">else</span>
    [ivalid,jvalid] = deal([]); <span class="comment">% not used</span>
<span class="keyword">end</span>

<span class="comment">%% main()</span>
<span class="comment">% Allocate</span>
verletList = cell(n, 1); <span class="comment">% pre-allocate the Verlet list</span>
t__ = clock; t_ = t__;

<span class="comment">% Pseudo recursion <span class="keyword">if</span> nblocks > 1</span>
<span class="keyword">if</span> (nblocks > 1) && (d == 3) <span class="comment">% block splitting limited to 3D</span>

    range = [min(X,[],1); max(X,[],1)]; <span class="comment">% [mins;maxs]</span>
    drange = diff(range, 1, 1);
    nBmax = max(2, floor(drange / (2 * cutoff)));
    [~, is] = sort(drange, <span class="string">'ascend'</span>);
    nB = zeros(1, d);
    nB(is(1)) = 1 + min(nBmax(is(1)), floor(nblocks^(1/3))); <span class="comment">% number of blocks along the smallest dimension</span>
    nB(is(2)) = 1 + min(nBmax(is(2)), floor(sqrt(nblocks / nB(is(1))))); <span class="comment">% idem along the intermediate dimension</span>
    nB(is(3)) = 1 + min(nBmax(is(3)), ceil(nblocks / (nB(is(1)) * nB(is(2))))); <span class="comment">% along the longest one</span>
    xB = linspace(range(1, 1) - drange(1) / 20, range(2, 1) + drange(1) / 20, nB(1));
    yB = linspace(range(1, 2) - drange(2) / 20, range(2, 2) + drange(2) / 20, nB(2));
    zB = linspace(range(1, 3) - drange(3) / 20, range(2, 3) + drange(3) / 20, nB(3));
    
    <span class="comment">% create meshgrid <span class="keyword">for</span> block indices</span>
    [ix, iy, iz] = meshgrid(1:nB(1)-1, 1:nB(2)-1, 1:nB(3)-1);
    ix = ix(:); iy = iy(:); iz = iz(:);
    nBall = numel(ix); dist = cell(n, 1); dmin = NaN; cutoffsafe = 1.1 * cutoff; screen = <span class="string">''</span>;

    <span class="comment">% <span class="keyword">for</span> each block</span>
    wasempty = true;
    <span class="keyword">if</span> verbose, dispf(<span class="string">'Build Verlet list by searching in blocks...'</span>), <span class="keyword">end</span>
    <span class="keyword">for</span> iBall = 1:nBall
        <span class="comment">% points mask of considered entities/particles/beads</span>
        okxyz = (X(:, 1) > (xB(ix(iBall)) - cutoffsafe)) & (X(:, 1) < (xB(ix(iBall)+1) + cutoffsafe)) & ...
                (X(:, 2) > (yB(iy(iBall)) - cutoffsafe)) & (X(:, 2) < (yB(iy(iBall)+1) + cutoffsafe)) & ...
                (X(:, 3) > (zB(iz(iBall)) - cutoffsafe)) & (X(:, 3) < (zB(iz(iBall)+1) + cutoffsafe)); <span class="comment">% box + margins</span>
        ind = find(okxyz)<span class="string">';       <span class="comment">% their indices (to be used <span class="keyword">for</span> conversion)</span>
        nind = numel(ind);        <span class="comment">% number of entities</span>
        narein = 0;               <span class="comment">% default value (to be updated)</span>
        nneighborsforthosein = 0; <span class="comment">% counter <span class="keyword">for</span> their neighbors</span>
        <span class="keyword">if</span> nind               <span class="comment">% some neighbors found</span>
            arein = find(...  <span class="comment">% relative indices of those inside the box</span>
                        (X(ind, 1) >= xB(ix(iBall))) & (X(ind, 1) <= xB(ix(iBall)+1)) & ...
                        (X(ind, 2) >= yB(iy(iBall))) & (X(ind, 2) <= yB(iy(iBall)+1)) & ...
                        (X(ind, 3) >= zB(iz(iBall))) & (X(ind, 3) <= zB(iz(iBall)+1)) ...
                    );
            narein = length(arein);   <span class="comment">% number of entities in the box</span>
            [verletListtmp, cutoff, dmintmp, ~, disttmp] = buildVerletList3(X(ind, :), cutoff, false, 0, false, excludedfromsearch(ind), excludedneighbors(ind));
            dmin = min(dmin,dmintmp);
            <span class="keyword">for</span> eachin = 1:narein     <span class="comment">% <span class="keyword">for</span> all elements in the temporary Verlet list</span>
                ind_current   = ind(arein(eachin));                <span class="comment">% scalar index <span class="keyword">if</span> the current entity</span>
                ind_neighbors = ind(verletListtmp{arein(eachin)}); <span class="comment">% vector of neighbor indices</span>
                nneighborsforthosein = nneighborsforthosein + length(ind_neighbors); <span class="comment">% counter of neighbors</span>
                verletList{ind_current} = ind_neighbors;           <span class="comment">% update the verlet list</span>
                dist{ind_current} = disttmp{arein(eachin)};        <span class="comment">% update the distance matrix</span>
            <span class="keyword">end</span> <span class="comment">% next eachin</span>
        <span class="keyword">end</span> <span class="comment">% <span class="keyword">if</span> nind</span>
        <span class="keyword">if</span> verbose
            done = iBall/nBall; currenttime = clock; dt = etime(currenttime,t_);
            <span class="keyword">if</span> (dt>0.5) || wasempty
                dt_ = etime(currenttime,t__);
                screen = dispb(screen,'</span>[BLOCK <span class="comment">%d/%d] %d particles with %d neighbors (%0.1f %% total) | min dist loc:%0.3g glob:%0.3g | elapsed %0.1f of %0.1f s | done %0.1f %% | remaining %0.1f s<span class="string">',...</span>
                    iBall,nBall,narein,nneighborsforthosein,nind/n*100,dmintmp,dmin,dt,dt_,100*done,(1/done-1)*dt_);
                wasempty = (nneighborsforthosein==0); t_ = currenttime;
            <span class="keyword">end</span>
        <span class="keyword">end</span>


    <span class="keyword">end</span> <span class="comment">% next iBall</span>
    <span class="keyword">if</span> verbose, dispb(screen,'</span>... done in <span class="comment">%0.4g s with %d search blocks | minimum distance %0.4g<span class="string">',dt,nBall,dmin); <span class="keyword">end</span></span>

    <span class="comment">% DEBUG MODE (comparison without blocks, <span class="keyword">for</span> internal validation)</span>
    <span class="keyword">if</span> DEBUGON
        V = verletList; <span class="comment">%#ok<UNRCH> </span>
        V0 = buildVerletList3(X, cutoff, sorton, 0, true);
        figure, hold on
        [YB,ZB] = meshgrid(yB,zB); <span class="keyword">for</span> x=xB, mesh(YB*0+x,YB,ZB,'</span>facecolor<span class="string">','</span>none<span class="string">','</span>edgecolor<span class="string">','</span>r<span class="string">'); <span class="keyword">end</span>
        [XB,ZB] = meshgrid(xB,zB); <span class="keyword">for</span> y=yB, mesh(XB,ZB*0+y,ZB,'</span>facecolor<span class="string">','</span>none<span class="string">','</span>edgecolor<span class="string">','</span>r<span class="string">'); <span class="keyword">end</span>
        [XB,YB] = meshgrid(xB,yB); <span class="keyword">for</span> z=zB, mesh(XB,YB,XB*0+z,'</span>facecolor<span class="string">','</span>none<span class="string">','</span>edgecolor<span class="string">','</span>r<span class="string">'); <span class="keyword">end</span>
        plot3D(X((cellfun(@length,V0)-cellfun(@length,V))>0,:),'</span>bs<span class="string">')
        xlabel('</span>x<span class="string">'), ylabel('</span>y<span class="string">'),zlabel('</span>z<span class="string">')
        view(3), axis equal, axis tight
        dispf('</span><span class="keyword">if</span> you do not see any bs, it is OK: <span class="comment">%d<span class="string">',max(cellfun(@length,V0)-cellfun(@length,V)))</span>
        disp('</span>make a break point here<span class="string">')
    <span class="keyword">end</span>


<span class="keyword">else</span> <span class="comment">% --------- vectorized code</span>

    <span class="comment">% Compute pairwise distances using the built-in pdist2 <span class="keyword">function</span></span>
    <span class="keyword">if</span> hasexclusions
        <span class="keyword">if</span> verbose, dispf('</span>Calculate the <span class="comment">%d x %d pair distances...<span class="string">',ngrid,n), t_ = clock; <span class="keyword">end</span> %#ok<*CLOCK></span>
        distances = pdist2(X(ivalid,:), X(jvalid,:));
    <span class="keyword">else</span>
        <span class="keyword">if</span> verbose, dispf('</span>Calculate the <span class="comment">%d x %d pair distances...<span class="string">',n,n), t_ = clock; <span class="keyword">end</span> %#ok<*CLOCK></span>
        distances = pdist2(X, X);
    <span class="keyword">end</span>
    <span class="keyword">if</span> verbose, dispf('</span>\t ... done in <span class="comment">%0.3g s<span class="string">',etime(clock,t_)), <span class="keyword">end</span> %#ok<*DETIM> </span>
    
    <span class="comment">% Estimate cutoff <span class="keyword">if</span> not provided (heuristic method)</span>
    <span class="comment">% cutoff is set to match targetedNumberOfNeighbors</span>
    <span class="comment">% without exceeding the mode of the distribution based on 1000 classes</span>
    <span class="comment">% note: <span class="keyword">if</span> the number of pair distances is very large, subsampling is applied</span>
    <span class="keyword">if</span> isnan(cutoff)
        <span class="keyword">if</span> verbose, dispf('</span>Estimate cutoff...<span class="string">'), t_ = clock; <span class="keyword">end</span>
        d = triu(distances,1); <span class="comment">% all pair distances (can be very large)</span>
        d = d(d>0); dmin = min(d);
        d = d(1:max(1,round(sqrt(length(d))/1000)):<span class="keyword">end</span>); <span class="comment">% subsampling</span>
        [c,d] = hist(d,1000); <span class="comment">%#ok<*HIST> </span>
        <span class="comment">% Identify the mode (maximum)</span>
        <span class="comment">% counts are smoothed with a moving average over 10 classes</span>
        <span class="comment">% figure, plot(d(1:<span class="keyword">end</span>-1),diff(filtzero(cumsum(c),10)))</span>
        cfit = 1000 * diff(filtzero(cumsum(c),10)) / n;
        d = d(1:<span class="keyword">end</span>-1) - d(1) + dmin;
        cfit = cfit-cfit(1); <span class="comment">% first value (no, meaning)</span>
        [~,imax] = max(cfit);
        <span class="comment">% cutoff range</span>
        cutoff_min = 2 * dmin;
        cutoff_max = d(imax);
        <span class="comment">% estimate the number of neighbors between cutoff_min and cutoff_max</span>
        <span class="comment">% use nearest and cumulated cfit, discard the first 10 data (poorly estimated)</span>
        cutoff = max(cutoff_min,min(cutoff_max,...
            d(nearestpoint(targetedNumberOfNeighbors,cumsum(cfit))+10)));
        <span class="keyword">if</span> verbose, dispf('</span>\t ... done in <span class="comment">%0.3g s (cutoff = %0.6g)<span class="string">',etime(clock,t_),cutoff), <span class="keyword">end</span></span>
    <span class="keyword">end</span>
    
    <span class="comment">% Find particle pairs within the cutoff distance</span>
    <span class="keyword">if</span> verbose, dispf('</span>Find atoms within cuttoff...<span class="string">'), t_ = clock; <span class="keyword">end</span>
    <span class="keyword">if</span> hasexclusions
        [rowIndices, colIndices] = find(distances <= cutoff);
        rowIndices = ivalid(rowIndices);
        colIndices = jvalid(colIndices);
    <span class="keyword">else</span>
        [rowIndices, colIndices] = find(triu(distances <= cutoff, 1));
    <span class="keyword">end</span>
    <span class="keyword">if</span> verbose, dispf('</span>\t ... done in <span class="comment">%0.3g s<span class="string">',etime(clock,t_)); <span class="keyword">end</span></span>
    
    
    <span class="comment">% Add the particle indices to the Verlet list</span>
    <span class="keyword">if</span> verbose ,dispf('</span>Build the Verlet list...<span class="string">'), t_ = clock; <span class="keyword">end</span>
    [t0,t1] = deal(clock);
    npairs = numel(rowIndices);
    screen = '</span><span class="string">';
    <span class="keyword">for</span> idx = 1:npairs
        <span class="keyword">if</span> mod(idx,100) == 0
            <span class="keyword">if</span> (etime(clock,t1) > 2) && verbose <span class="comment">% every two seconds</span>
                dt = etime(clock,t0);
                done = idx/npairs*100;
                screen = dispb(screen,...
                    '</span>Building the Verlet list [completed: <span class="comment">%0.3g%% | elapsed: %0.3g s | remaining: %0.3g s]<span class="string">',...</span>
                    done,dt,dt*(100/done-1));
                t1 = clock;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        i = rowIndices(idx);
        j = colIndices(idx);
        verletList{i}(<span class="keyword">end</span>+1) = j;
        <span class="keyword">if</span> ~hasexclusions
            verletList{j}(<span class="keyword">end</span>+1) = i;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> verbose
        verletCounts = cellfun(@length,verletList);
        dispf('</span>\t ... done in <span class="comment">%0.3g s [min=%d, median=%d, max=%d]<span class="string">',etime(clock,t_),min(verletCounts),round(median(verletCounts)),max(verletCounts))</span>
    <span class="keyword">end</span>

    <span class="comment">% short distances list (efficient), compute the dmin here (faster) // revised 2023-03-29</span>
    dmin = Inf;
    dist = cell(n,1);
    <span class="keyword">if</span> hasexclusions
        <span class="keyword">if</span> ~isempty(distances)
            <span class="keyword">for</span> i_=1:length(ivalid)
                i = ivalid(i_);
                dist{i} = distances(i_,jvalidreverse(verletList{i}));
                dmin = min(dmin,min(dist{i}));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="keyword">for</span> i=1:n
            dist{i} = distances(i,verletList{i});
            dmin = min(dmin,min(dist{i}));
        <span class="keyword">end</span>
    <span class="keyword">end</span>

<span class="keyword">end</span> <span class="comment">% <span class="keyword">if</span> nblocks > 2</span>


<span class="comment">%% finalization</span>

<span class="comment">% Sort the Verlet list <span class="keyword">if</span> requested</span>
<span class="keyword">if</span> sorton
    <span class="keyword">if</span> verbose, dispf('</span>\t Sort the Verlet list...<span class="string">'), t_ = clock; <span class="keyword">end</span>
    <span class="keyword">for</span> i=1:n
        [~,u] = sort(dist{i},'</span>ascend<span class="string">');
        j = verletList{i};
        verletList{i} = j(u);
    <span class="keyword">end</span>
    <span class="keyword">if</span> verbose, dispf('</span>\t ... done in <span class="comment">%0.3g s<span class="string">',etime(clock,t_)), <span class="keyword">end</span></span>
<span class="keyword">end</span>

<span class="comment">% Final elapsed time</span>
timerq = etime(clock,t__);

<span class="comment">% Return cuttoff <span class="keyword">if</span> requested</span>
<span class="keyword">if</span> nargout>1, cutoffout = cutoff; <span class="keyword">end</span>

<span class="comment">% Return dmin <span class="keyword">if</span> requested</span>
<span class="keyword">if</span> nargout>2, <span class="keyword">if</span> isempty(dmin), dminout = NaN; <span class="keyword">else</span> dminout = dmin; <span class="keyword">end</span>, <span class="keyword">end</span>

<span class="keyword">if</span> nargout>3
    config = struct( ...
            '</span>engine<span class="string">','</span>buildVerletList<span class="string">', ...
            '</span>elaspedtime<span class="string">',timerq,...
            '</span>natoms<span class="string">',n,...
            '</span>dimensions<span class="string">',d,...
            '</span>nblocks<span class="string">',nblocks,...
            '</span>cutoff<span class="string">',cutoff,...
            '</span>dmin<span class="string">',dmin,...
            '</span>sorton<span class="string">',sorton, ...
            '</span>verbose<span class="string">',verbose,...
            '</span>tolerance<span class="string">',tolerance,...
            '</span>nsamples<span class="string">',ceil(min(200,n*tolerance)) );
<span class="keyword">end</span>

<span class="comment">% Return distances <span class="keyword">if</span> required</span>
<span class="keyword">if</span> nargout>4, distout = dist; <span class="keyword">end</span>

<span class="comment">% final display</span>
<span class="keyword">if</span> verbose
    dispf('</span>buildVerletList: all done in <span class="comment">%0.3g s <span class="keyword">for</span> %d %ss',timerq,n,entity)</span>
<span class="keyword">end</span></code></pre></div>
</div>
<div id='checkfiles' class='doc-content' style='display: none;'>
<h1>checkfiles</h1>
<p>2023-04-23 checkfiles: generic script to check lamdumpread prefetch and split (frame) files<br/>outputs in Markdown for Mermaid and Markmap</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">%checkfiles</span>
<span class="comment">% 2023-04-23 checkfiles: generic script to check lamdumpread prefetch and split (frame) files</span>
<span class="comment">% outputs in Markdown <span class="keyword">for</span> Mermaid and Markmap</span>


<span class="comment">%% look <span class="keyword">for</span> gz files</span>
<span class="keyword">switch</span> localname
    <span class="keyword">case</span> <span class="string">'LX-Olivier2021'</span>
        local = <span class="string">'/media/olivi/MODIC4TB_WSJ2/'</span>; <span class="comment">%#ok<*NASGU> </span>
        local = <span class="string">'/media/olivi/MODIC4TB_WSJ1/'</span>;
    <span class="keyword">case</span> <span class="string">'LP-OLIVIER2022'</span>
        local = <span class="string">'E:\'</span>;
    <span class="keyword">otherwise</span>
        dispf(<span class="string">'implement you machine by adding\n\n\tCASE '</span><span class="string">'<span class="comment">%s'</span><span class="string">'\n\t\tlocal = '</span><span class="string">'this is my path'</span><span class="string">'\n'</span>,localname)</span>
        error(<span class="string">'unknown machine and local path'</span>)
<span class="keyword">end</span>

target = <span class="string">'*.tar.gz'</span>;
fgz = explore(target,local,100,<span class="string">'abbreviate'</span>);
ngz = length(fgz);

<span class="comment">%% look <span class="keyword">for</span> dump files without the extension tar.gz</span>
<span class="comment">% templates</span>
makeprefetch = @(fn) char(fullfile(rootdir(fn),[<span class="string">'PREFETCH_'</span> lastdir(fn) <span class="string">'.mat'</span>])); <span class="comment">% added 2023/03/23</span>
makesplitdir = @(fn) char(fullfile(rootdir(fn),[<span class="string">'PREFETCH_'</span> lastdir(fn)])); <span class="comment">% added 2023/03/23</span>
statenfo = @(done,dt) sprintf(<span class="string">'| elapsed <span class="comment">%0.3g s | done %0.3g %% | remaining %0.3g s |'</span>,dt,done*100,(1/done-1)*dt);</span>
SPLITPREFIX = <span class="string">'TIMESTEP_'</span>;
MB = 1024^2;
GB = 1024^3;
screen = <span class="string">''</span>; t0 = clock;
<span class="keyword">for</span> i=1:ngz
    done = (i-1)/ngz; dt = etime(clock,t0); <span class="comment">%#ok<*DETIM> </span>
    screen = dispb(screen,<span class="string">'[<span class="comment">%d/%d] search <span class="keyword">for</span> dump files and frames ... %s'</span>,i,ngz,statenfo(done,dt));</span>
    dfi = explore(<span class="string">'dump.*'</span>,fgz(i).path,10,<span class="string">'abbreviate'</span>);
    dfi=dfi(cellfun(@(e) ~any(strcmpi(e,{<span class="string">'gz'</span>,<span class="string">'mat'</span>})),{dfi.ext})); <span class="comment">% remove gz extensions</span>
    ndfi = length(dfi);
    <span class="comment">% <span class="keyword">for</span> each</span>
    <span class="keyword">for</span> j = 1:ndfi
        f = fullfile(dfi(j).path,dfi(j).file);
        dfi(j).hasprefetch = exist(makeprefetch(f),<span class="string">'file'</span>)==2;
        dfi(j).hassplitdir =  exist(makesplitdir(f),<span class="string">'dir'</span>)==7;
        <span class="comment">% counts frames</span>
        <span class="keyword">if</span> dfi(j).hassplitdir
            dfi(j).frames = explore(sprintf(<span class="string">'<span class="comment">%s*.mat'</span>,SPLITPREFIX),makesplitdir(f),0,<span class="string">'abbreviate'</span>);</span>
            dfi(j).nframes = length(dfi(j).frames);
            t1 = clock;
            done = (i-1+(j-1)/ndfi)/ngz; dt = etime(clock,t0);
            screen = dispb(screen,<span class="string">'[<span class="comment">%d/%d] %d of %d dump files with %d frames ... %s'</span>,i,ngz,j,ndfi,dfi(j).nframes,statenfo(done,dt));</span>
            <span class="keyword">for</span> iframe = 1:dfi(j).nframes
                dfi(j).frames(iframe).timestep = str2double(regexprep(dfi(j).frames(iframe).name,SPLITPREFIX,<span class="string">''</span>));
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            dfi(j).nframes = 0;
            ispb(screen,<span class="string">'[<span class="comment">%d/%d: %d] no frame found !'</span>,i,ngz,j); screen = <span class="string">''</span>;</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% save</span>
    fgz(i).ndump = ndfi;
    <span class="keyword">if</span> ndfi
        fgz(i).dump = dfi;
        fgz(i).nprefetch = length(find([dfi.hasprefetch]));
        fgz(i).nsplitdir = length(find([dfi.hassplitdir]));
    <span class="keyword">else</span>
        fgz(i).dump = struct([]);
        fgz(i).nprefetch = 0;
        fgz(i).nsplitdir = 0;
        dispb(screen,<span class="string">'[<span class="comment">%d/%d] no dump found !'</span>,i,ngz); screen = <span class="string">''</span>;</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">%% Files not untar and ungzipped</span>
untar = fgz([fgz.ndump]<1);
dispf(<span class="string">'<span class="comment">%d files are not untarred and ungzipped'</span>,length(untar))</span>

<span class="comment">%% create a database</span>
ndumps = sum([fgz.ndump]);
dispf(<span class="string">'<span class="comment">%d dump filmes have been found'</span>,ndumps)</span>
<span class="comment">% review the tags (based on ext)</span>
nmaxtags = 0;
idump = 0;
<span class="keyword">for</span> i=1:length(fgz)
    <span class="keyword">for</span> j=1:length(fgz(i).dump)
        idump = idump + 1;
        name = fgz(i).dump(j).ext;
        nmaxtags = max(nmaxtags,length(strsplit(name,<span class="string">'_'</span>)));
    <span class="keyword">end</span>
<span class="keyword">end</span>
tagfields = arrayfun(@(t) sprintf(<span class="string">'tag<span class="comment">%d'</span>,t),1:nmaxtags,<span class="string">'UniformOutput'</span>,false);</span>
tagtypes = repmat({<span class="string">'categorical'</span>},1,nmaxtags);
<span class="comment">% preallocate the table</span>
T = table( ...
    <span class="string">'Size'</span>,[ndumps,22+length(tagfields)], ...
    <span class="string">'VariableTypes'</span>,[{<span class="string">'string'</span>,<span class="string">'datetime'</span>} tagtypes {<span class="string">'logical'</span>,<span class="string">'logical'</span>    ,<span class="string">'string'</span>      ,<span class="string">'double'</span>    ,<span class="string">'double'</span> ,<span class="string">'cell'</span>  , <span class="string">'double'</span>,<span class="string">'double'</span>,<span class="string">'string'</span>    ,<span class="string">'string'</span>    ,<span class="string">'cell'</span>   ,<span class="string">'double'</span> ,<span class="string">'double'</span>  ,<span class="string">'string'</span>    ,<span class="string">'string'</span>  ,<span class="string">'string'</span>  ,<span class="string">'double'</span>,<span class="string">'string'</span>,<span class="string">'string'</span>,<span class="string">'double'</span>}],...
    <span class="string">'VariableNames'</span>,[{<span class="string">'name'</span>,<span class="string">'date'</span>} tagfields {<span class="string">'hasprefetch'</span> ,<span class="string">'hassplitdir'</span>,<span class="string">'prefetchfile'</span>,<span class="string">'prefetchMB'</span>,<span class="string">'nframes'</span>,<span class="string">'tframe'</span>,<span class="string">'tfirst'</span> ,<span class="string">'tlast'</span> ,<span class="string">'firstframe'</span>,<span class="string">'lastframe'</span> ,<span class="string">'frames'</span> ,<span class="string">'frameMB'</span>,<span class="string">'framesGB'</span>,<span class="string">'framespath'</span>,<span class="string">'dumpfile'</span>,<span class="string">'dumppath'</span>,<span class="string">'dumpGB'</span>,<span class="string">'gzfile'</span>,<span class="string">'gzpath'</span>,<span class="string">'gzGB'</span>}]);
<span class="comment">% fill the table</span>
idump = 0;
<span class="keyword">for</span> i=1:length(fgz)
    <span class="keyword">for</span> j=1:length(fgz(i).dump)
        idump = idump + 1;
        <span class="comment">% name</span>
        name = fgz(i).dump(j).ext;
        T.name(idump) = name;
        <span class="comment">% date</span>
        T.date(idump) = datetime(fgz(i).dump(j).datenum,<span class="string">'ConvertFrom'</span>,<span class="string">'datenum'</span>,<span class="string">'format'</span>,<span class="string">'yyyy-MM-dd'</span>);
        <span class="comment">% add tags</span>
        tags = strsplit(name,<span class="string">'_'</span>); ntags = length(tags);
        <span class="keyword">for</span> itag = 1:ntags
            T.(tagfields{itag})(idump) = tags(itag);
        <span class="keyword">end</span>
        <span class="comment">% prefetch/split flags</span>
        T.hasprefetch(idump) = fgz(i).dump(j).hasprefetch;
        T.hassplitdir(idump) = fgz(i).dump(j).hassplitdir;
        <span class="comment">% dump file</span>
        T.dumppath(idump) = fgz(i).dump(j).path;
        T.dumpfile(idump) = fgz(i).dump(j).file;
        T.dumpGB(idump) = fgz(i).dump(j).bytes/GB;
        <span class="comment">% prefetch file</span>
        <span class="keyword">if</span> T.hasprefetch(idump)
            T.prefetchfile(idump) = makeprefetch(char(fullfile(T.dumppath(idump),T.dumpfile(idump))));
            tmp = dir(T.prefetchfile(idump));
            T.prefetchMB(idump) = tmp.bytes/MB;
        <span class="keyword">else</span>
            dispf(<span class="string">'dump #<span class="comment">%d: missing prefetch !'</span>,idump)</span>
        <span class="keyword">end</span>
        <span class="comment">% frames</span>
        timesteps = [fgz(i).dump(j).frames.timestep];
        frames = string({fgz(i).dump(j).frames.file});
        [tfirst,kfirst] = min(timesteps);
        [tlast,klast] = max(timesteps);
        T.nframes(idump) = fgz(i).dump(j).nframes;
        T.tframe{idump} = timesteps;
        T.tfirst(idump) = tfirst;
        T.tlast(idump)  = tlast;
        T.firstframe(idump) = frames(kfirst); 
        T.lastframe(idump) = frames(klast);
        T.frames{idump} = frames;
        T.framespath(idump) = fgz(i).dump(j).frames(1).path;
        T.framesGB(idump) = sum([fgz(i).dump(j).frames.bytes])/GB;
        T.frameMB(idump) = (T.framesGB(idump)/T.nframes(idump)) * (GB/MB);
        <span class="comment">% gz info</span>
        T.gzpath(idump) = fgz(i).path;
        T.gzfile(idump) = fgz(i).file;
        T.gzGB(idump) = fgz(i).bytes/GB;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% remove any duplicate</span>
idT = cellfun(@(p,f) fullfile(p,f) ,T.dumppath,T.dumpfile,<span class="string">'uniformoutput'</span>,false);
[~,kept] = unique(idT,<span class="string">'stable'</span>);
T = T(kept,:);
nT = size(T,1);

<span class="comment">%% TAGs</span>
ntags = length(tagfields);
<span class="keyword">for</span> i=1:ntags
    T.(tagfields{i})(ismissing(T.(tagfields{i}))) = sprintf(<span class="string">'UndefTag<span class="comment">%02d'</span>,i);</span>
<span class="keyword">end</span>
Ttagsafe = T(:,tagfields);
tagvalues = cellfun(@(t) categories(T.(t)),tagfields,<span class="string">'UniformOutput'</span>,false);
tagvaluessafe = tagvalues;
taginternal = tagvalues;
repeatedtags = [];
knowntags = {};
<span class="keyword">for</span> i=1:ntags
    <span class="keyword">for</span> j=1:length(tagvalues{i})
        <span class="keyword">if</span> ismember(tagvalues{i}{j},knowntags)
            k = find(ismember(knowntags,tagvalues{i}{j}));
            repeatedtags(k) = repeatedtags(k) + 1; <span class="comment">%#ok<*SAGROW> </span>
            tagvaluessafe{i}{j} = sprintf(<span class="string">'<span class="comment">%s_%0d'</span>,tagvaluessafe{i}{j},repeatedtags(k));</span>
            tobereplaced = T.(tagfields{i})==tagvalues{i}{j};
            Ttagsafe.(tagfields{i})(tobereplaced)=tagvaluessafe{i}{j};
        <span class="keyword">end</span>
        knowntags{<span class="keyword">end</span>+1} = tagvaluessafe{i}{j};
        repeatedtags(<span class="keyword">end</span>+1) = 1;
        taginternal{i}{j} = sprintf(<span class="string">'TAG<span class="comment">%02d%02d'</span>,i,j);</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%% Generate the diGraph</span>
rootnode = <span class="string">'root'</span>;
nodes = arrayfun(@(n) sprintf(<span class="string">'dump<span class="comment">%03d'</span>,n),(1:nT)<span class="string">','</span>UniformOutput<span class="string">',false);</span>
tagnodes = cat(1,taginternal{:});
tagrealnodes= cat(1,tagvaluessafe{:});

<span class="comment">% defintions (should match mermaidones)</span>
definitions = [
    {rootnode}
    tagrealnodes
    nodes
    ];
ndefintions = length(definitions);
<span class="comment">% mermaid defintions</span>
mermaiddefinitions = [
    {sprintf('</span><span class="comment">%s[%s]<span class="string">',rootnode,strrep(local,'</span>\<span class="string">','</span>_<span class="string">'))}</span>
    cellfun(@(n,d) sprintf('</span><span class="comment">%s[%s]<span class="string">',n,d),tagnodes,cat(1,tagvalues{:}),'</span>UniformOutput<span class="string">',false);</span>
    arrayfun(@(i) sprintf('</span><span class="comment">%s[%d: <kbd>%s</kbd>]<span class="string">',nodes{i},i,T.dumpfile(i)),(1:nT)'</span>,<span class="string">'UniformOutput'</span>,false)</span>
    ];
mermaidnodes = [
    {rootnode}
    tagnodes
    nodes
    ];
<span class="comment">% ID</span>
ID = zeros(nT,ntags+1);
[~,ID(:,<span class="keyword">end</span>)] = intersect(definitions,nodes,<span class="string">'stable'</span>);
<span class="keyword">for</span> i=1:ntags
    [usetags,iusetags] = intersect(definitions,Ttagsafe.(tagfields{i}),<span class="string">'stable'</span>);
    <span class="keyword">for</span> j = 1:length(usetags)
        ID(ismember(T.(tagfields{i}),usetags(j)),i) = iusetags(j);
    <span class="keyword">end</span>
<span class="keyword">end</span>
ID = [ones(nT,1) ID];
C = false(ndefintions,ndefintions);
<span class="keyword">for</span> i = 1:nT
    ind = ID(i,ID(i,:)>0);
    <span class="keyword">for</span> j=2:length(ind)
        C(ind(j-1),ind(j)) = true;
    <span class="keyword">end</span>
<span class="keyword">end</span>
 g = digraph(C,definitions); figure, plot(g,<span class="string">'nodelabel'</span>,definitions,<span class="string">'layout'</span>,<span class="string">'force3'</span>);

<span class="comment">%% Generate the Mermaid document</span>
mermaidheader = {
<span class="string">'```mermaid'</span>
<span class="string">'graph LR;'</span>
<span class="string">'linkStyle default interpolate basis'</span>
<span class="string">''</span>
};
mermaidfooter = {<span class="string">'```'</span>};
[i,j] = ind2sub(size(C),find(C));
mermaidlinks = arrayfun(@(a,b) sprintf(<span class="string">'<span class="comment">%s --> %s'</span>,mermaidnodes{a},mermaidnodes{b}),i,j,<span class="string">'UniformOutput'</span>,false);</span>
mermaid = [mermaidheader;mermaiddefinitions;mermaidlinks;mermaidfooter];
clipboard(<span class="string">'copy'</span>,sprintf(<span class="string">'<span class="comment">%s\n'</span>,mermaid{:}))</span>


<span class="comment">%% Generate the Markdown document</span>
markdown = {
<span class="string">'---'</span>
<span class="string">'markmap:'</span>
<span class="string">'  colorFreezeLevel: 5'</span>
<span class="string">'  initialExpandLevel: 3'</span>
<span class="string">'  maxWidth: 400'</span>
<span class="string">'---'</span>
    };
level = @(position,txt) sprintf(<span class="string">'<span class="comment">%s [tag%0d] %s'</span>,repmat(<span class="string">'#'</span>,position,1),position,txt);</span>
vec = zeros(1,ntags); vec(1)=1;
lengthvec = cellfun(@length,tagvalues);
position = 1;
ok = false(nT,ntags);
finished = false;
newlevel = true;
nfound = 0;
founditems = [];
action = <span class="string">'init'</span>;
DEBUGON = true; DEBUGCOMB = NaN(prod(lengthvec),ntags); DEBUGITER = 0;
isprintedT = false(nT,1);
<span class="keyword">if</span> DEBUGON, clc, <span class="keyword">end</span>
<span class="keyword">while</span> (position>0) && any(vec)
    terminal = (position==ntags);
    <span class="comment">% refresh flags</span>
    currenttag = tagvalues{position}{vec(position)};
    ok(:,position) = (T.(tagfields{position}) == currenttag);
    currentfound = find(all(ok(:,1:position),2));
    completed = false;
    <span class="keyword">if</span> position>1 && isempty(currentfound)
        previousfound = find(all(ok(:,1:position-1),2));
        <span class="keyword">if</span> ~isempty(previousfound)
            completed = all(ismissing(T.(tagfields{position})(previousfound)));
            <span class="keyword">if</span> completed
                currentfound = previousfound;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    ncurrentfound = length(currentfound);
    
    <span class="comment">% display (debugging purposes)</span>
        <span class="comment">% check duplicates with this line</span>
        <span class="comment">%[~,ia]=unique(DEBUGCOMB,<span class="string">'rows'</span>,<span class="string">'first'</span>); [~,ib]=unique(DEBUGCOMB,<span class="string">'rows'</span>,<span class="string">'last'</span>); [ia(find(ia-ib,1,<span class="string">'first'</span>)) ib(find(ia-ib,1,<span class="string">'first'</span>))]</span>
        <span class="comment">% check missing</span>
        <span class="comment">%{</span>
            arrays = arrayfun(@(i) 1:lengthvec(i), 1:ntags,<span class="string">'UniformOutput'</span>,false);
            [grid{1:ntags}] = ndgrid(arrays{:});
            grid_arrays = cellfun(@(x) x(:), grid, <span class="string">'UniformOutput'</span>, false);
            combinations = [grid_arrays{:}]; disp(size(combinations));
            missing  = combinations(~ismember(combinations,DEBUGCOMB,<span class="string">'rows'</span>),:);
            findfirst = find(sum(missing(:,1:3)-[1 1 2],2)==0)
        <span class="comment">%}</span>
    <span class="keyword">if</span> DEBUGON <span class="comment">%&& ismember(action,{<span class="string">'init'</span>,<span class="string">'keep'</span>,<span class="string">'keep+reset'</span>})</span>
        <span class="keyword">if</span> terminal, DEBUGITER = DEBUGITER+1; DEBUGCOMB(DEBUGITER,:) = vec; <span class="keyword">end</span>
        vecstr = arrayfun(@(v) num2str(v),vec,<span class="string">'UniformOutput'</span>,false);
        vecstr{position} = sprintf(<span class="string">'[<span class="comment">%s]%'</span>,vecstr{position});</span>
        <span class="keyword">if</span> newlevel, newstr = <span class="string">'*'</span>; <span class="keyword">else</span> newstr = <span class="string">'-'</span>; <span class="keyword">end</span> <span class="comment">%#ok<*SEPEX> </span>
        <span class="keyword">if</span> terminal, newstr = [newstr newstr]; <span class="keyword">end</span> <span class="comment">%#ok<*AGROW> </span>
        dispf(<span class="string">'<span class="comment">%d> %s%s <-- %s (%d found [%s], total = %d)'</span>,DEBUGITER,sprintf(<span class="string">'%s '</span>,vecstr{:}),newstr,action,ncurrentfound,currenttag,nfound)</span>
    <span class="keyword">end</span>
    

    <span class="comment">% do</span>
    <span class="keyword">if</span> ncurrentfound>0
        <span class="keyword">if</span> newlevel <span class="comment">%(newlevel || terminal || (ncurrentfound == 1)) && ~completed</span>
            markdown{<span class="keyword">end</span>+1} = level(position,tagvalues{position}{vec(position)});
        <span class="keyword">end</span>
        <span class="keyword">if</span> terminal <span class="comment">%(ncurrentfound < 2) %|| (ncurrentfound>1 && (terminal || completed))</span>
            founditems = union(founditems,currentfound);
            <span class="keyword">for</span> ifound = 1:ncurrentfound
                nfound = nfound + 1;
                mycurentnode = currentfound(ifound);
                <span class="keyword">if</span> ~isprintedT(mycurentnode)
                    markdown{<span class="keyword">end</span>+1} = sprintf(<span class="string">'> **`<span class="comment">%s`**'</span>,T.dumpfile(mycurentnode));</span>
                    markdown{<span class="keyword">end</span>+1} = sprintf(<span class="string">'> ORIGINAL file size: <span class="comment">%0.2f GB'</span>,T.dumpGB(mycurentnode));</span>
                    <span class="keyword">if</span> ~ismissing(T.prefetchfile(mycurentnode))
                        markdown{<span class="keyword">end</span>+1} = sprintf(<span class="string">'> PREFETCH file (<span class="comment">%0.2f MB): %s'</span>,T.prefetchMB(mycurentnode),strrep(T.prefetchfile(mycurentnode),<span class="string">'\'</span>,<span class="string">'/'</span>));</span>
                    <span class="keyword">else</span>
                        markdown{<span class="keyword">end</span>+1} = <span class="string">'> ==missing PREFETCH file=='</span>;
                    <span class="keyword">end</span>
                    <span class="keyword">if</span> ~ismissing(T.framespath(mycurentnode))
                        markdown{<span class="keyword">end</span>+1} = sprintf(<span class="string">'> FRAMES folder (<span class="comment">%0.2f GB): %s'</span>,T.framesGB(mycurentnode),strrep(T.framespath(mycurentnode),<span class="string">'\'</span>,<span class="string">'/'</span>));</span>
                        markdown{<span class="keyword">end</span>+1} = sprintf(<span class="string">'> NUMBER of frames: *<span class="comment">%d* (%0.2f MB/frame)'</span>,T.nframes(mycurentnode),T.frameMB(mycurentnode));</span>
                        markdown{<span class="keyword">end</span>+1} = sprintf(<span class="string">'> FIRST TIMESTEP: *<span class="comment">%d*'</span>,T.tfirst(mycurentnode));</span>
                        markdown{<span class="keyword">end</span>+1} = sprintf(<span class="string">'> LAST TIMESTEP: *<span class="comment">%d*'</span>,T.tlast(mycurentnode));</span>
                        markdown{<span class="keyword">end</span>+1} = sprintf(<span class="string">'> FIRST FRAME: <span class="comment">%s'</span>,strrep(T.firstframe(mycurentnode),<span class="string">'\'</span>,<span class="string">'//'</span>));</span>
                        markdown{<span class="keyword">end</span>+1} = sprintf(<span class="string">'> FIRST LAST: <span class="comment">%s'</span>,strrep(T.lastframe(mycurentnode),<span class="string">'\'</span>,<span class="string">'//'</span>));</span>
                    <span class="keyword">else</span>
                        markdown{<span class="keyword">end</span>+1} = <span class="string">'> ==missing  FRAMES folder=='</span>;
                    <span class="keyword">end</span>
                    markdown{<span class="keyword">end</span>+1} = newline;
                    isprintedT(mycurentnode)=true;
                <span class="keyword">end</span> <span class="comment">% already printed</span>
            <span class="keyword">end</span> <span class="comment">% next found</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% shift operations</span>
    <span class="keyword">if</span> (position<ntags) && vec(position+1)<lengthvec(position+1)
        position = position +1; <span class="comment">% descent into the next level</span>
        vec(position) = 1;
        <span class="keyword">if</span> position<ntags, vec(position+1) = 1; <span class="keyword">end</span>
        newlevel = true;
        action = <span class="string">'descent'</span>;
    <span class="keyword">else</span>
        <span class="keyword">if</span> vec(position)<lengthvec(position)
            vec(position) = vec(position)+1; <span class="comment">% keep the same level</span>
            <span class="keyword">if</span> (position<ntags)
                vec(position+1) = 1;
                newlevel = true;
                action =<span class="string">'keep+reset'</span>;
            <span class="keyword">else</span>
                newlevel = false;
                action = <span class="string">'keep'</span>;
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            position = position - 1; <span class="comment">% raise the level (nothing done)</span>
            newlevel = false;
            action = <span class="string">'raise'</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
DEBUGCOMB(any(isnan(DEBUGCOMB),2),:) = [];
clipboard(<span class="string">'copy'</span>,sprintf(<span class="string">'<span class="comment">%s\n'</span>,markdown{:}))</span>
</code></pre></div>
</div>
<div id='color_line3' class='doc-content' style='display: none;'>
<h1>color_line3 plots a 3-D &quot;line&quot; with c-data as color</h1>
<p>h = color_line(x, y, z, c)<br/>by default: &#x27;LineStyle&#x27;,&#x27;-&#x27; and &#x27;Marker&#x27;,&#x27;none&#x27;</p>
<p>or<br/>h = color_line(x, y, z, c, mark)<br/>or<br/>h = color_line(x, y, z, c, &#x27;Property&#x27;,&#x27;value&#x27;...)<br/>with valid &#x27;Property&#x27;,&#x27;value&#x27; pairs for a surface object</p>
<p>in:  x      x-data<br/>y      y-data<br/>z      z-data<br/>c      4th dimension for colouring<br/>mark   for scatter plots with no connecting line</p>
<p>out:  h   handle of the surface object</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> h = color_line3(x, y, z, c, varargin)
<span class="comment">% color_line3 plots a 3-D "line" with c-data as color</span>
<span class="comment">%</span>
<span class="comment">%       h = color_line(x, y, z, c)</span>
<span class="comment">%       by default: <span class="string">'LineStyle'</span>,<span class="string">'-'</span> and <span class="string">'Marker'</span>,<span class="string">'none'</span></span>
<span class="comment">%</span>
<span class="comment">%          or</span>
<span class="comment">%       h = color_line(x, y, z, c, mark) </span>
<span class="comment">%          or</span>
<span class="comment">%       h = color_line(x, y, z, c, <span class="string">'Property'</span>,<span class="string">'value'</span>...) </span>
<span class="comment">%             with valid <span class="string">'Property'</span>,<span class="string">'value'</span> pairs <span class="keyword">for</span> a surface object</span>
<span class="comment">%</span>
<span class="comment">%  in:  x      x-data</span>
<span class="comment">%       y      y-data</span>
<span class="comment">%       z      z-data</span>
<span class="comment">%       c      4th dimension <span class="keyword">for</span> colouring</span>
<span class="comment">%       mark   <span class="keyword">for</span> scatter plots with no connecting line</span>
<span class="comment">%</span>
<span class="comment">% out:  h   handle of the surface object</span>
h = surface(...
  <span class="string">'XData'</span>,[x(:) x(:)],...
  <span class="string">'YData'</span>,[y(:) y(:)],...
  <span class="string">'ZData'</span>,[z(:) z(:)],...
  <span class="string">'CData'</span>,[c(:) c(:)],...
  <span class="string">'FaceColor'</span>,<span class="string">'none'</span>,...
  <span class="string">'EdgeColor'</span>,<span class="string">'flat'</span>,...
  <span class="string">'Marker'</span>,<span class="string">'none'</span>);
  
<span class="keyword">if</span> nargin ==5
    <span class="keyword">switch</span> varargin{1}
        <span class="keyword">case</span> {<span class="string">'+'</span> <span class="string">'o'</span> <span class="string">'*'</span> <span class="string">'.'</span> <span class="string">'x'</span> <span class="string">'square'</span> <span class="string">'diamond'</span> <span class="string">'v'</span> <span class="string">'^'</span> <span class="string">'>'</span> <span class="string">'<'</span> <span class="string">'pentagram'</span> <span class="string">'p'</span> <span class="string">'hexagram'</span> <span class="string">'h'</span>}
            set(h,<span class="string">'LineStyle'</span>,<span class="string">'none'</span>,<span class="string">'Marker'</span>,varargin{1})
        <span class="keyword">otherwise</span>
            error([<span class="string">'Invalid marker: '</span> varargin{1}])
    <span class="keyword">end</span>
<span class="keyword">elseif</span> nargin > 5
    set(h,varargin{:})
<span class="keyword">end</span></code></pre></div>
</div>
<div id='curve2tangent' class='doc-content' style='display: none;'>
<h1>CURVE2TANGENT Calculate the tangent of a curve XY using a second-order and centered approximation scheme</h1>
<p>Syntax: XYt = curve2tagent(XY)<br/>XY is a Nx2 or Nx3 matrix where N is the number of points<br/>XYt is a Nx2 or Nx3 matrix containing the coordinates of the tangent vector at each point</p>
<p>The tangent vector is computed using a centered difference method for interior points.<br/>For the endpoints, forward and backward differences are used.</p>
<p>MS 3.0 | 2024-03-27 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev.</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> XYt = curve2tangent(XY)
<span class="comment">%CURVE2TANGENT Calculate the tangent of a curve XY using a second-order and centered approximation scheme</span>
<span class="comment">%</span>
<span class="comment">% Syntax: XYt = curve2tagent(XY)</span>
<span class="comment">%   XY is a Nx2 or Nx3 matrix where N is the number of points</span>
<span class="comment">%   XYt is a Nx2 or Nx3 matrix containing the coordinates of the tangent vector at each point</span>
<span class="comment">%</span>
<span class="comment">% The tangent vector is computed using a centered difference method <span class="keyword">for</span> interior points.</span>
<span class="comment">% For the endpoints, forward and backward differences are used.</span>
<span class="comment">%</span>
<span class="comment">% MS 3.0 | 2024-03-27 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev.</span>


<span class="comment">% Determine the number of points and dimensionality</span>
[N, dim] = size(XY);

<span class="comment">% Initialize the output matrix</span>
XYt = zeros(N, dim);

<span class="comment">% Calculate tangents <span class="keyword">for</span> interior points using centered differences</span>
<span class="keyword">for</span> i = 2:N-1
    XYt(i, :) = (XY(i+1, :) - XY(i-1, :)) / 2;
<span class="keyword">end</span>

<span class="comment">% Calculate tangent <span class="keyword">for</span> the first point using forward difference</span>
XYt(1, :) = (XY(2, :) - XY(1, :));

<span class="comment">% Calculate tangent <span class="keyword">for</span> the last point using backward difference</span>
XYt(N, :) = (XY(N, :) - XY(N-1, :));

<span class="comment">% Normalize the tangent vectors</span>
<span class="keyword">for</span> i = 1:N
    XYt(i, :) = XYt(i, :) / norm(XYt(i, :));
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='defgradSPH' class='doc-content' style='display: none;'>
<h1>DEFGRAD calculates the solid deformation gradient using the displacement field u according to Eq. 17-24 of Comput. Methods Appl. Mech. Engrg. 286 (2015) 87–106</h1>
<p>Syntax:<br/>out = defgradSPH(u,shapeSPHout)  &lt;--- syntax 1 (preferred)<br/>out = defgradSPH(u,correctedgradW [,V, config, silent])  &lt;--- syntax 2</p>
<p>Inputs: (syntax 1)<br/>u : kxd displacement field of the kernel centers<br/>shapeSPHout : ouput (structure) of shapeSPH</p>
<p>Inputs: (syntax 2)<br/>u : kxd displacement field of the kernel centers<br/>correctedgradW : 3xkxk corrected kernel gradient (reference frame), calculated with shapeSPH (3rd output)<br/>V : kx1 volume of the kernels (default=1)<br/>[] (empty matrix) or scalar value forces uniform volumes (default =1)<br/>forcesilent: flag to force silence mode (default = false)<br/>config: structure with fields coding for Lamé parameters<br/>lambda (default = 30 000 Pa)<br/>mu (default = 3000 Pa)</p>
<p>Output: out a structure with fields:<br/>F : k x d^2 deformation gradient<br/>C : k x d^2 Cauchy-Green deformation tensor<br/>E : k x d^2 Green-Lagrange strain tensor<br/>S : k x d^2 Second Piola-Kirchoff stress tensor replacing Cauchy stress (Elastic stress = config.lambda*trace(E) + 2*config.mu*E)<br/>P : k x d^2 First Piola-Kirchoff stress<br/>f : k x d pairwise forces<br/>G : k * d von Mises stress<br/>description : tensor description<br/>k,d,V,correctedgradW,config are also included<br/>engine : &#x27;defragSPH&#x27;</p>
<p>Refer to Ganzenmuller (2015) for details: https://doi.org/10.1016/j.cma.2014.12.005<br/>~/han/biblio/Ganzenmuller2015-Hourglass_control_algorithm.pdf</p>
<h2>See also</h2>
<p><a href="#shapeSPH">shapeSPH</a>, <a href="#interp2SPH">interp2SPH</a>, <a href="#interp3SPH">interp3SPH</a>, <a href="#kernelSPH">kernelSPH</a>, <a href="#packSPH">packSPH</a></p>
<h2>See also</h2>
<p></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> out = defgradSPH(u,correctedgradW,V,config,forcesilent)
<span class="comment">%DEFGRAD calculates the solid deformation gradient using the displacement field u according to Eq. 17-24 of Comput. Methods Appl. Mech. Engrg. 286 (2015) 87–106</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       out = defgradSPH(u,shapeSPHout)  <--- syntax 1 (preferred)</span>
<span class="comment">%       out = defgradSPH(u,correctedgradW [,V, config, silent])  <--- syntax 2</span>
<span class="comment">%</span>
<span class="comment">%   Inputs: (syntax 1)</span>
<span class="comment">%               u : kxd displacement field of the kernel centers</span>
<span class="comment">%     shapeSPHout : ouput (structure) of shapeSPH</span>
<span class="comment">%</span>
<span class="comment">%   Inputs: (syntax 2)</span>
<span class="comment">%               u : kxd displacement field of the kernel centers</span>
<span class="comment">%  correctedgradW : 3xkxk corrected kernel gradient (reference frame), calculated with shapeSPH (3rd output)</span>
<span class="comment">%               V : kx1 volume of the kernels (default=1)</span>
<span class="comment">%                   [] (empty matrix) or scalar value forces uniform volumes (default =1)</span>
<span class="comment">%      forcesilent: flag to force silence mode (default = false)</span>
<span class="comment">%           config: structure with fields coding <span class="keyword">for</span> Lamé parameters</span>
<span class="comment">%                   lambda (default = 30 000 Pa)</span>
<span class="comment">%                   mu (default = 3000 Pa)</span>
<span class="comment">%</span>
<span class="comment">%   Output: out a structure with fields:</span>
<span class="comment">%               F : k x d^2 deformation gradient</span>
<span class="comment">%               C : k x d^2 Cauchy-Green deformation tensor</span>
<span class="comment">%               E : k x d^2 Green-Lagrange strain tensor</span>
<span class="comment">%               S : k x d^2 Second Piola-Kirchoff stress tensor replacing Cauchy stress (Elastic stress = config.lambda*trace(E) + 2*config.mu*E)</span>
<span class="comment">%               P : k x d^2 First Piola-Kirchoff stress</span>
<span class="comment">%               f : k x d pairwise forces</span>
<span class="comment">%               G : k * d von Mises stress</span>
<span class="comment">%     description : tensor description</span>
<span class="comment">%           k,d,V,correctedgradW,config are also included</span>
<span class="comment">%          engine : <span class="string">'defragSPH'</span></span>
<span class="comment">%</span>
<span class="comment">%   Refer to Ganzenmuller (2015) <span class="keyword">for</span> details: https://doi.org/10.1016/j.cma.2014.12.005</span>
<span class="comment">%   ~/han/biblio/Ganzenmuller2015-Hourglass_control_algorithm.pdf</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: shapeSPH, interp2SPH, interp3SPH, kernelSPH, packSPH</span>
<span class="comment">%</span>

<span class="comment">% 2023-10-31 | INRAE\Olivier Vitrac | rev. 2023-11-01</span>


<span class="comment">%{</span>
<span class="comment">% Example:</span>
r = 0.5;
X0 = packSPH(10,r);
X0(sqrt(sum((X0-mean(X0,1)).^2,2))>10*r,:) = [];
<span class="comment">% deformation (vertical compression + shearing)</span>
Xc = mean(X0,1); Xmin = min(X0,[],1); Xmax = max(X0,[],1)
<span class="comment">% compression along z, with support at zmin, compression rate = 20%</span>
X = X0; X(:,3) = 0.8*(X(:,3)-Xmin(1,3)) + Xmin(1,3);
<span class="comment">% shearing 20% along y</span>
X(:,2) = X(:,2) + 0.2 * (Xmax(1,2)-Xmin(1,2)) * (X(:,3)-Xmin(1,3))/(Xmax(1,3)-Xmin(1,3));
<span class="comment">% displacement</span>
u = X-X0;
<span class="comment">% shape matrix</span>
gradW = kernelSPH(2*r,<span class="string">'lucyder'</span>,3);
shapeout = shapeSPH(X0,gradW)
<span class="comment">% calculates stresses and forces</span>
defgradout = defgradSPH(u,shapeout)
<span class="comment">% visualization</span>
figure, hold on
scatter3(X(:,1),X(:,2),X(:,3),40,defgradout.G)
f= defgradout.f; fn=sqrt(sum(f.^2,2)); f = f./fn;
f90 = prctile(fn,90); fn(fn>f90) = f90; f = f .* f90;
quiver3(X(:,1),X(:,2),X(:,3),f(:,1),f(:,2),f(:,3))
<span class="comment">%}</span>

<span class="comment">%Revision history</span>
<span class="comment">% 2023-10-31 alpha version</span>
<span class="comment">% 2023-11-01 collect all outputs and inputs into out, add f and G</span>
<span class="comment">% 2023-11-13 fixes, RC, full example</span>

<span class="comment">% Default Lamé parameters</span>
config_default = struct(...
    <span class="string">'lambda'</span>,3e4, ...first Lamé  parameter
    <span class="string">'mu'</span>,3e3 ... shear modulus (second Lamé parameterà
);

<span class="comment">%% arg check</span>
<span class="keyword">if</span> nargin<2, error(<span class="string">'2 arguments are required at least'</span>), <span class="keyword">end</span>
[k,d] = size(u); <span class="keyword">if</span> k==0, error(<span class="string">'please supply some displacements centers'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> isstruct(correctedgradW) && strcmpi(correctedgradW.engine,<span class="string">'shapeSPH'</span>) <span class="comment">% -- syntax 1: we reuse the arguments of shapeSPH</span>
    args = correctedgradW;
    <span class="keyword">if</span> (args.d~=d) || (args.k~=k), error(<span class="string">'<span class="comment">%dx%d u is not compatible with previous %dx%d centers'</span>,k,d,args.k,args.d), <span class="keyword">end</span></span>
    correctedgradW = args.correctedgradW;
    V = args.V;
    config = args.config;
    forcesilent = args.forcesilent;
    <span class="keyword">if</span> nargin>2, warning(<span class="string">'extra arguments are ignored with syntax 1 (defragSPH)'</span>); <span class="keyword">end</span>
<span class="keyword">else</span> <span class="comment">% -- syntax 2</span>
    <span class="keyword">if</span> nargin<3, V = []; <span class="keyword">end</span>
    <span class="keyword">if</span> nargin<4, config = []; <span class="keyword">end</span>
    <span class="keyword">if</span> nargin<5, forcesilent = []; <span class="keyword">end</span>
    <span class="keyword">if</span> ~isnumeric(correctedgradW) || ndims(correctedgradW)~=3, error(<span class="string">'correctedgradW should be evaluated with shape SPH (3rd output)'</span>), <span class="keyword">end</span>
    <span class="keyword">if</span> d>3, error(<span class="string">'3 dimensions maximum'</span>), <span class="keyword">end</span>
    [dW,k1W,k2W] = size(correctedgradW);
    <span class="keyword">if</span> k1W~=k2W, error(<span class="string">'<span class="comment">%dx%dx%d correctedgradW is not consistent, dim 2 and dim 3 should be equal'</span>,k1W,k2W); <span class="keyword">end</span></span>
    <span class="keyword">if</span> dW~=d, error(<span class="string">'<span class="comment">%dx%dx%d correctedgradW has not the same number of dimensions (%d) than u (%d)'</span>,dW,k1W,k2W,dW,d); <span class="keyword">end</span></span>
    kv = length(V);
    <span class="keyword">if</span> kv==0, V=1;  kv=1; <span class="keyword">end</span>
    <span class="keyword">if</span> kv==1, V = ones(k,1)*V; kv=k; <span class="keyword">end</span>
    <span class="keyword">if</span> kv~=k, error(<span class="string">'the number of V values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,kv,k); <span class="keyword">end</span></span>
    <span class="keyword">if</span> isempty(forcesilent), forcesilent = false; <span class="keyword">end</span>
    <span class="keyword">if</span> isempty(config), config = config_default; <span class="keyword">end</span>
    <span class="keyword">for</span> f = fieldnames(config_default)<span class="string">'
        <span class="keyword">if</span> ~isfield(config,f{1}) || isempty(config.(f{1}))
            config.(f{1}) = config_default.(f{1});
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% initialization</span>
verbosity = (k>1e3) & ~forcesilent;
largek = k>200;
t0_ = clock; t1_=t0_; screen='</span><span class="string">'; 

<span class="comment">% coding linearized outer product (https://en.wikipedia.org/wiki/Outer_product)</span>
[left,right] = ndgrid(1:d,1:d);
outerproductindex = struct('</span>u<span class="string">',left(:),'</span>v<span class="string">',right(:)); <span class="comment">% u and n are notations of wiki, not related to displacements</span>

<span class="comment">% vec2tensor: indices to convert a vector to a 2D tensor (faster than many reshapes)</span>
vec2tensor_reshape = reshape(1:d^2,d,d);
vec2tensor = @(x) x(vec2tensor_reshape);

<span class="comment">%% output F (deformation gradient)</span>
<span class="comment">% loop over all j <span class="keyword">for</span> summation</span>
I = eye(d,class(u));
F = repmat(I(:)'</span>,k,1); <span class="comment">% we initialize to identity (see Eqs. 17 and 6 F = I + du/dX)</span>
<span class="keyword">if</span> verbosity, dispf(<span class="string">'DEFRAGSPH calculates the deformation gradient <span class="keyword">for</span> all <span class="comment">%d kernels (K) in %d dimensions...'</span>,k,d), <span class="keyword">end</span></span>
<span class="keyword">for</span> j=1:k
    <span class="comment">% verbosity</span>
    <span class="keyword">if</span> verbosity
        <span class="keyword">if</span> largek
            t_ = clock; <span class="comment">%#ok<*CLOCK></span>
            <span class="keyword">if</span> mod(j,10)==0 || (etime(t_,t1_)>0.5) <span class="comment">%#ok<*DETIM> </span>
                t1_=t_;
                dt_ = etime(t_,t0_); done_ = j/k;
                screen = dispb(screen,<span class="string">'[K<span class="comment">%d:%d] DEFRAGSPH | elapsed %0.1f s | done %0.1f %% | remaining %0.1f s'</span>, ...</span>
                               j,k,dt_,100*done_,(1/done_-1)*dt_);
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            dispf(<span class="string">'... DEFRAGSPH - deformation gradient - respectively to kernel <span class="comment">%d of %d'</span>,j,k);</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% Deformation gradient <span class="keyword">for</span> atom i due to j</span>
    uij = u(j,:)-u; <span class="comment">% j - all i</span>
    <span class="keyword">for</span> i=1:k
        <span class="comment">% Eq. 17, noticing that I is the initial value (no need to add it)</span>
        <span class="comment">% u and v are left and right indices with repetitions</span>
        F(i,:) = F(i,:) + V(j) * uij(i,outerproductindex.u).*correctedgradW(outerproductindex.v,i,j)<span class="string">';
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">%% output C (Cauchy-Green deformation tensor)</span>
C = zeros(size(F),class(u));
<span class="keyword">for</span> i = 1:k
    <span class="keyword">if</span> verbosity, screen = dispb(screen,'</span>[K<span class="comment">%d:%d] DEFRAGSPH, Cauchy-Green tensor...<span class="string">',i,k); <span class="keyword">end</span></span>
    Fi = vec2tensor(F(i,:));
    tmp = Fi'</span>*Fi;
    C(i,:) = tmp(:)<span class="string">';
<span class="keyword">end</span>

<span class="comment">%% output E (Green-Lagrange strain)</span>
E = 0.5 * (C - repmat(I(:)'</span>,k,1)); <span class="comment">% Eq. 18</span>

<span class="comment">%% output S (Cauchy stress tensor)</span>
<span class="comment">% trace operator is replaced by a sum along dim 2 <span class="keyword">for</span> indices 1, d+2, 2*d+3</span>
S = config.lambda * sum(E(:,1:d+1:<span class="keyword">end</span>),2) + 2 * config.mu * E; <span class="comment">%Eq. 19 config.lambda*tr(E)+2*config.mu*E</span>

<span class="comment">%% output P (first Piola-Kirchoff stress)</span>
P = zeros(size(F),class(u));
<span class="keyword">for</span> i = 1:k
    <span class="keyword">if</span> verbosity, screen = dispb(screen,<span class="string">'[K<span class="comment">%d:%d] DEFRAGSPH, first Piola-Kirchoff stress tensor...'</span>,i,k); <span class="keyword">end</span></span>
    tmp = vec2tensor(F(i,:))*vec2tensor(S(i,:));
    P(i,:) = tmp(:)<span class="string">';
<span class="keyword">end</span>

<span class="comment">%% output f (pairwise forces) - Eq. 24</span>
<span class="comment">% initialization</span>
f = zeros(k,d,class(u));
<span class="comment">% summation loop</span>
<span class="keyword">for</span> j=1:k
    <span class="keyword">if</span> verbosity, screen = dispb(screen,'</span>[K<span class="comment">%d:%d] DEFRAGSPH, summation pairwise forces...<span class="string">',i,k); <span class="keyword">end</span></span>
    Pj = vec2tensor(P(j,:));
    <span class="comment">% kernel loop</span>
    <span class="keyword">for</span> i=1:k
        Pi = vec2tensor(P(i,:));
        f(i,:) = f(i,:) +  ...: means x,y,z
            ( V(i)*V(j)*(Pi*correctedgradW(:,i,j)-Pj*correctedgradW(:,j,i)) )'</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% output G (von Mises stress)</span>
<span class="keyword">if</span> d==3
    <span class="comment">% https://en.wikipedia.org/wiki/Von_Mises_yield_criterion</span>
    <span class="comment">% https://www.continuummechanics.org/vonmisesstress.html</span>
    [ij11,ij22,ij33,ij23,ij31,ij12] = deal(1,5,9,8,3,2); <span class="comment">% indices 11,22,33,12,31,12 as (i,j)</span>
    G = sqrt(0.5*( ...
        (S(:,ij11)-S(:,ij22)).^2+...
        (S(:,ij22)-S(:,ij33)).^2+...
        (S(:,ij33)-S(:,ij11)).^2+...
        6 * (S(:,ij23).^2+S(:,ij31).^2+S(:,ij12).^2) ...
        ));
<span class="keyword">elseif</span> d==2
    <span class="comment">% https://www.omnicalculator.com/physics/von-mises-stress</span>
    [ij11,ij22,ij12] = deal(1,4,2); <span class="comment">% indices 11,22,12 as (i,j)</span>
    G = sqrt(...
        S(:,ij11).^2 -...
        S(:,ij11).*S(:,ij22) + ...
        S(:,ij22).^2 +...
        6 * S(:,ij12).^2 ...
        );
<span class="keyword">end</span>

<span class="comment">%% verbosity</span>
<span class="keyword">if</span> verbosity
    dispb(screen,<span class="string">'DEFRAGSPH <span class="comment">%d L matrix calculated in %0.4g s'</span>,k,etime(clock,t0_));</span>
<span class="keyword">end</span>

<span class="comment">% collect all outputs</span>
description = struct(...
        <span class="string">'F'</span>,<span class="string">'deformation gradient'</span>,...
        <span class="string">'C'</span>,<span class="string">'Cauchy-Green deformation tensor'</span>,...
        <span class="string">'E'</span>,<span class="string">'Green-Lagrange strain'</span>,...
        <span class="string">'S'</span>,<span class="string">'Cauchy stress tensor'</span>,...
        <span class="string">'P'</span>,<span class="string">'first Piola-Kirchoff stress'</span>, ...
        <span class="string">'f'</span>,<span class="string">'pairwise forces, so-called nodal forces'</span>, ...
        <span class="string">'G'</span>,<span class="string">'von Mises stress'</span> ...
         );
out = struct( ...
    <span class="string">'k'</span>,k,<span class="string">'d'</span>,d,<span class="string">'V'</span>,V,<span class="string">'correctedgradW'</span>,correctedgradW,<span class="string">'config'</span>,config,...
    <span class="string">'F'</span>,F,<span class="string">'C'</span>,C,<span class="string">'E'</span>,E,<span class="string">'S'</span>,S,<span class="string">'P'</span>,P,<span class="string">'f'</span>,f,<span class="string">'G'</span>,G, ...
    <span class="string">'description'</span>,description,<span class="string">'engine'</span>,<span class="string">'defragSPH'</span>,<span class="string">'forcesilent'</span>,forcesilent);</code></pre></div>
</div>
<div id='dispb' class='doc-content' style='display: none;'>
<h1>DISPB wrapper of disp with linefeed</h1>
<p>syntax: screenline=dispb(screenline,&#x27;string with codes %s %d&#x27;,value1,value2,...)<br/>see help on SPRINTF</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> update=dispb(old,varargin)
<span class="comment">%DISPB wrapper of disp with linefeed </span>
<span class="comment">% syntax: screenline=dispb(screenline,<span class="string">'string with codes %s %d'</span>,value1,value2,...)</span>
<span class="comment">% see help on SPRINTF</span>

<span class="comment">% MS 2.1 - 22/03/09 - INRA\Olivier Vitrac rev.</span>

<span class="comment">% Revision history</span>
update = sprintf(varargin{:});
<span class="keyword">if</span> any(old)
    varargin{1} = [repmat(<span class="string">'\b'</span>,1,length(old)+1) varargin{1}];
<span class="keyword">end</span>
dispf(varargin{:})
</code></pre></div>
</div>
<div id='dispf' class='doc-content' style='display: none;'>
<h1>DISPF fast wrapper of disp(sprintf(...))</h1>
<p>see help on SPRINTF<br/>see also FPRINTF (the main difference is that LF is used after disp)</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> out = dispf(varargin)
<span class="comment">%DISPF fast wrapper of disp(sprintf(...))</span>
<span class="comment">% see help on SPRINTF</span>
<span class="comment">% see also FPRINTF (the main difference is that LF is used after disp)</span>

<span class="comment">% MS 2.1 - 16/03/08 - INRA\Olivier Vitrac rev. 14/09/19</span>

<span class="comment">% Revision history</span>
<span class="comment">% 29/12/12 updated help</span>
<span class="comment">% 19/08/18 implement varargin{1} as a cell</span>
<span class="comment">% 14/09/19 add output <span class="keyword">for</span> vectorization</span>

<span class="keyword">if</span> iscell(varargin{1})
    n = 0;
    <span class="keyword">for</span> i=1:numel(varargin{1})
        n = n+dispf(varargin{1}{i});
    <span class="keyword">end</span>
<span class="keyword">else</span>
    txt = sprintf(varargin{:});
    n = length(txt);
    disp(txt)
<span class="keyword">end</span>
<span class="keyword">if</span> nargout, out = n; <span class="keyword">end</span></code></pre></div>
</div>
<div id='example1' class='doc-content' style='display: none;'>
<h1>WORKSHOP built on Billy production file (suspended particle in a fluid)</h1>
<p>This example takes the benefit of a Lagrangian description</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% WORKSHOP built on Billy production file (suspended particle in a fluid)</span>
<span class="comment">% This example takes the benefit of a Lagrangian description</span>

<span class="comment">% INRAE\Olivier Vitrac, Han Chen - rev. 2023-08-25</span>

<span class="comment">% MATLAB FILES included in this distribution (either from INRAE/MS or Pizza3 project)</span>

<span class="comment">% Main file</span>
<span class="comment">% ├── example1.m</span>

<span class="comment">% Main features demonstrated</span>
<span class="comment">% ├── lamdumpread2.m     ==> the Swiss knife <span class="keyword">for</span> the manipulating HUGE dump files (version 2 as it is the fork <span class="keyword">for</span> Pizza3)</span>
<span class="comment">% ├── buildVerletList.m  --> the basic tool <span class="keyword">for</span> statistical physics, it implement an efficient grid search method</span>

<span class="comment">% Other dependencies and future workshop extensions (from Pizza3)</span>
<span class="comment">% ├── checkfiles.m</span>
<span class="comment">% ├── forceHertzAB.m</span>
<span class="comment">% ├── forceHertz.m</span>
<span class="comment">% ├── forceLandshoff.m</span>
<span class="comment">% ├── interp2SPH.m</span>
<span class="comment">% ├── interp3SPH.m</span>
<span class="comment">% ├── interp3SPHVerlet.m</span>
<span class="comment">% ├── kernelSPH.m</span>
<span class="comment">% ├── packing.m</span>
<span class="comment">% ├── packing_WJbranch.m</span>
<span class="comment">% ├── packSPH.m</span>
<span class="comment">% ├── partitionVerletList.m</span>
<span class="comment">% ├── selfVerletList.m</span>
<span class="comment">% ├── updateVerletList.m</span>

<span class="comment">% Advanced scripts written <span class="keyword">for</span> INRAE\William Jenkinson</span>
<span class="comment">% ├── KE_t.m</span>
<span class="comment">% ├── particle_flux.m</span>
<span class="comment">% └── wallstress.m</span>

<span class="comment">% Dependencies from MS (INRAE/Molecular Studio) </span>
<span class="comment">% ├── color_line3.m</span>
<span class="comment">% ├── dispb.m</span>
<span class="comment">% ├── dispf.m</span>
<span class="comment">% ├── explore.m</span>
<span class="comment">% ├── fileinfo.m</span>
<span class="comment">% ├── lastdir.m</span>
<span class="comment">% ├── MDunidrnd.m</span>
<span class="comment">% ├── plot3D.m</span>
<span class="comment">% ├── rootdir.m</span>

<span class="comment">% DUMP FILES included in this workshop</span>
<span class="comment">% ├── dumps</span>
<span class="comment">% │   └── hertz</span>
<span class="comment">% │       ├── dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle             <== it is the original dump file</span>
<span class="comment">% │       └── PREFETCH_dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle    <-- the split folder</span>
<span class="comment">% │           ├── TIMESTEP_000000000.mat                                                                   <-- a split file</span>
<span class="comment">% │           ├── TIMESTEP_000050000.mat                                                                   <-- 158 splits (frames)</span>
<span class="comment">% │           ├── TIMESTEP_000100000.mat                                                                   <-- the value represent time</span>
<span class="comment">%             ... </span>

<span class="comment">%% STEP 1 - PREPROCESSING</span>
<span class="comment">% preprocess all the dumps (no need to precise the filenames, only the pattern)</span>
<span class="comment">% lamdumpread2 include two PREPROCESSORS <span class="string">'prefetch'</span> and <span class="string">'split'</span></span>
<span class="comment">%   prefetch should be preferred <span class="keyword">for</span> 2D files (relatively smaller number of particles and many time frames)</span>
<span class="comment">%       Usage: lamdumpread2(<span class="string">'dump.*'</span>,<span class="string">'prefetch'</span>);</span>
<span class="comment">%   split should be preferred <span class="keyword">for</span> large 3D files (large number of particles and a relatively smaller number of time frames)</span>
<span class="comment">%       Usage: lamdumpread2(<span class="string">'dump.*'</span>,<span class="string">'split'</span>);</span>
<span class="comment">%</span>
<span class="comment">% note: this step should be used ONLY once, applying again will overwrite the previous splits (frames)</span>

PREPROCESS_FLAG = false; <span class="comment">% set it to true to preprocess your data</span>
<span class="keyword">if</span> PREPROCESS_FLAG
    datafolder = <span class="string">'./dumps/'</span>;
    lamdumpread2(fullfile(datafolder,<span class="string">'dump.*'</span>),<span class="string">'split'</span>); <span class="comment">% <span class="keyword">for</span> large 3D</span>
<span class="keyword">end</span>


<span class="comment">%% STEP 2 - PROCESS SPECIFICALLY ONE FILE</span>
<span class="comment">% we do work with one dump file</span>
datafolder = <span class="string">'./dumps/'</span>;
dumpfile = <span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle'</span>;
datafolder = lamdumpread2(fullfile(datafolder,dumpfile),<span class="string">'search'</span>); <span class="comment">% fix datafolder based on initial guess</span>
defaultfiles = lamdumpread2(fullfile(datafolder,dumpfile),<span class="string">'default'</span>); <span class="comment">% default folder (just <span class="keyword">for</span> check)</span>


<span class="comment">%% Extract the types of atoms and the list of available frames</span>
X0 = lamdumpread2(fullfile(datafolder,dumpfile)); <span class="comment">% default frame</span>
natoms = X0.NUMBER;
timesteps = X0.TIMESTEPS;
atomtypes = unique(X0.ATOMS.type);
ntimesteps = length(timesteps);

<span class="comment">%% Extract the middle frame (i.e. in the middle of the simulation duration)</span>
<span class="comment">% X0 is too far from steady state <span class="keyword">for</span> advanced analysis</span>
Xmiddle = lamdumpread2(fullfile(datafolder,dumpfile),<span class="string">'usesplit'</span>,[],timesteps(ceil(ntimesteps/2))); <span class="comment">% middle frame</span>

<span class="comment">%% Extract the number of beads <span class="keyword">for</span> each type</span>
<span class="comment">% guess the bead type <span class="keyword">for</span> the fluid (the most populated)</span>
<span class="comment">% same guess <span class="keyword">for</span> the particle (the less populated)</span>
T = X0.ATOMS.type;
natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
[~,fluidtype] = max(natomspertype);
[~,solidtype] = min(natomspertype);
walltypes = setdiff(atomtypes,[fluidtype,solidtype]);

<span class="comment">%% Estimate the fluid bead size</span>
<span class="comment">% This step uses <span class="keyword">for</span> more accuracy the buildVerletList()</span>
fluidxyz = X0.ATOMS{T==fluidtype,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}};
fluidid = X0.ATOMS{T==fluidtype,<span class="string">'id'</span>};
nfluidatoms = length(fluidid);
nsolidatoms = natomspertype(solidtype);
<span class="comment">% first estimate assuming that the bead is a cube</span>
boxdims = X0.BOX(:,2) - X0.BOX(:,1);
Vbead_guess = prod(boxdims)/natoms;
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
[verletList,cutoff,dmin,config,dist] = buildVerletList(fluidxyz,cutoff);
rbead = dmin/2;

<span class="comment">%% find the direction of the flow (largest dimension)</span>
[~,iflow] = max(boxdims);
iothers = setdiff(1:size(X0.BOX,1),iflow);

<span class="comment">%% separate top and bottom walls</span>
vel = {<span class="string">'vx'</span>,<span class="string">'vy'</span>,<span class="string">'vz'</span>};
wall1vel = Xmiddle.ATOMS{Xmiddle.ATOMS.type==walltypes(1),vel{iflow}}; wall1vel = wall1vel(1);
wall2vel = Xmiddle.ATOMS{Xmiddle.ATOMS.type==walltypes(2),vel{iflow}}; wall2vel = wall2vel(1);
[wallvel,iwall] = sort([wall1vel,wall2vel],<span class="string">'descend'</span>); <span class="comment">% 1 is top (>0), 2 is bottom;</span>
walltypes = walltypes(iwall);

<span class="comment">%% find the position of the particle (i.e., obstacle) placed in the flow (from the middle frame)</span>
solidxyz = Xmiddle.ATOMS{T==solidtype,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}};
solidid = Xmiddle.ATOMS{T==solidtype,<span class="string">'id'</span>};
solidbox = [min(solidxyz);max(solidxyz)]<span class="string">';

<span class="comment">%% Pick n particles randomly from the left inlet and included in the mask of the solid (initial frame)</span>
n = 300;
tol = 0.5; <span class="comment">% add 40% particles around</span>
selectionbox = NaN(3,2);
selectionbox(iflow,:) = [X0.BOX(iflow,1), X0.BOX(iflow,1)+2*rbead];
selectionbox(iothers,:) =  (1+tol)*(solidbox(iothers,2)-solidbox(iothers,1))*[-1 1]/2 ...
    + (solidbox(iothers,1)+solidbox(iothers,2)) * [1 1]/2;
ok = true(nfluidatoms,1);
<span class="keyword">for</span> c = 1:3
    ok = ok & (fluidxyz(:,c)>=selectionbox(c,1)) & (fluidxyz(:,c)<=selectionbox(c,2));
<span class="keyword">end</span>
icandidates = find(ok);
iselected = icandidates(MDunidrnd(length(icandidates),n));
selectedid = fluidid(iselected); <span class="comment">% ID to be used</span>
<span class="comment">% plot selected particles and other ones</span>
figure, hold on
plot3D(fluidxyz,'</span>b.<span class="string">')
plot3D(fluidxyz(iselected,:),'</span>ro<span class="string">','</span>markerfacecolor<span class="string">','</span>r<span class="string">')
plot3D(solidxyz,'</span>ks<span class="string">','</span>markerfacecolor<span class="string">','</span>k<span class="string">')
view(3), axis equal

<span class="comment">%% Generate the trajectory <span class="keyword">for</span> the selected particles (<span class="keyword">for</span> all frames)</span>
<span class="comment">% All data are loaded with Lamdumpread2() with a single call using '</span>usesplit<span class="string">'</span>
<span class="comment">% each split is loaded individually and only atoms matching selectedid are stored</span>
<span class="comment">% all atoms are sorted as selectedid (no need to sort them)</span>
Xselection = lamdumpread2(fullfile(datafolder,dumpfile),'</span>usesplit<span class="string">',[],timesteps,selectedid);

<span class="comment">%% Collect the trajectory of the solid particle <span class="keyword">for</span> all frames</span>
Xsolid = lamdumpread2(fullfile(datafolder,dumpfile),'</span>usesplit<span class="string">',[],timesteps,solidid);

<span class="comment">%% Store the trajectories stored in a ntimesteps x 3 x n matrix</span>
<span class="comment">% missing data will</span>
[seltraj,selveloc] = deal(NaN(ntimesteps,3,n,'</span>single<span class="string">'));
solidtraj = NaN(ntimesteps,3,nsolidatoms,'</span>double<span class="string">');
goodframes = true(ntimesteps,1);
<span class="keyword">for</span> it = 1:ntimesteps
    <span class="comment">% read fluid atoms</span>
    selframe = Xselection.ATOMS(Xselection.ATOMS{:,'</span>TIMESTEP<span class="string">'} == timesteps(it),:);
    nfoundatoms = size(selframe,1);
    <span class="keyword">if</span> nfoundatoms<n <span class="comment">% incomplete dumped frame (it may happen in LAMMPS)</span>
        dispf('</span>incomplete frame <span class="comment">%d/%d (t=%0.4g): %d of %d fluid atoms missing<span class="string">',it,ntimesteps,timesteps(it),n-nfoundatoms,n)</span>
        [~,iatoms,jatoms] = intersect(selectedid,selframe.id,'</span>stable<span class="string">');
        seltraj(it,:,iatoms) = permute(selframe{jatoms,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}},[3 2 1]);
        goodframes(it) = false;
    <span class="keyword">else</span>
        seltraj(it,:,:) = permute(selframe{:,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}},[3 2 1]);
        selveloc(it,:,:) = permute(selframe{:,{'</span>vx<span class="string">','</span>vy<span class="string">','</span>vz<span class="string">'}},[3 2 1]);
    <span class="keyword">end</span>
    <span class="comment">% read solid atoms</span>
    solidframe = Xsolid.ATOMS(Xsolid.ATOMS{:,'</span>TIMESTEP<span class="string">'} == timesteps(it),:);
    nfoundatoms = size(solidframe,1);
    <span class="keyword">if</span> nfoundatoms<nsolidatoms <span class="comment">% incomplete dumped frame (it may happen in LAMMPS)</span>
        dispf('</span>incomplete frame <span class="comment">%d/%d (t=%0.4g): %d of %d solid atoms missing<span class="string">',it,ntimesteps,timesteps(it),nsolidatoms-nfoundatoms,nsolidatoms)</span>
        [~,iatoms,jatoms] = intersect(solidid,solidframe.id,'</span>stable<span class="string">');
        solidtraj(it,:,iatoms) = permute(solidframe{jatoms,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}},[3 2 1]);
        goodframes(it) = false;
    <span class="keyword">else</span>
        solidtraj(it,:,:) = permute(solidframe{:,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}},[3 2 1]);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% velocity magnitude <span class="keyword">for</span> the fluid particles</span>
selveloc_magnitude = squeeze(sqrt(sum(selveloc.^2, 2)));

<span class="comment">% Interpertation of the solid deformation via Ixx, Iyy, Izz and D</span>
centeredsolidtraj = solidtraj - repmat(nanmean(solidtraj,3),1,1,nsolidatoms);


<span class="comment">%% Calculate the approximate major and minor axes (assuming an ellipsoidal shape)</span>

<span class="comment">% Building the inertia tensor</span>

<span class="comment">% Initialize moments of inertia</span>
Ixx = zeros(ntimesteps, 1);
Iyy = zeros(ntimesteps, 1);
Izz = zeros(ntimesteps, 1);

<span class="keyword">for</span> it = 1:ntimesteps
    <span class="comment">% Extract the 3 x natoms matrix <span class="keyword">for</span> the current timestep</span>
    coordinates = squeeze(centeredsolidtraj(it, :, :))'</span>;
    
    <span class="comment">% Compute the covariance matrix</span>
    C = coordinates<span class="string">' * coordinates / nsolidatoms;
    
    <span class="comment">% Perform Singular Value Decomposition</span>
    [U, S, ~] = svd(C);
    
    <span class="comment">% The principal moments of inertia are on the diagonal of S</span>
    Ixx(it) = S(1, 1);
    Iyy(it) = S(2, 2);
    Izz(it) = S(3, 3);
<span class="keyword">end</span>
<span class="comment">% Calculate the approximate major and minor axes (assuming an ellipsoidal shape)</span>
L = sqrt(5 * (Ixx + Iyy - Izz) / 2); <span class="comment">% Major axis (approximation)</span>
B = sqrt(5 * (Ixx - Iyy + Izz) / 2); <span class="comment">% Minor axis (approximation)</span>
<span class="comment">% Calculate the Taylor deformation </span>
D = (L - B) ./ (L + B);

figure;
plot(timesteps, D,'</span>-<span class="string">','</span>linewidth<span class="string">',2);
xlabel('</span>Time<span class="string">'); ylabel('</span>D: Taylor deformation<span class="string">');
title({'</span>\rm{<span class="string">' strrep(dumpfile, '</span>_<span class="string">', '</span>\_<span class="string">') '</span>}:<span class="string">' '</span>\bf{Taylor Deformation Over Times}<span class="string">'}, '</span>Interpreter<span class="string">', '</span>tex<span class="string">')


<span class="comment">%% Plot the trajectories <span class="keyword">for</span> the selected particles</span>
<span class="comment">% streamlines with color representing velocity magnitude</span>
figure, hold on
col = parula(n);
<span class="keyword">for</span> i=1:n
    jumps = [1;ntimesteps+1];
    <span class="keyword">for</span> d=1:3
        jumps = unique([jumps;find(abs(diff(seltraj(:,d,i)))>boxdims(d)/2)+1]);
    <span class="keyword">end</span>
    <span class="keyword">for</span> j=1:length(jumps)-1
        u = jumps(j):jumps(j+1)-1;
        streamline = seltraj(u, :, i);
        color_line3(streamline(:, 1), streamline(:, 2), streamline(:, 3), selveloc_magnitude(u, i), '</span>linewidth<span class="string">', 3);
        <span class="comment">% faster method but without streamline</span>
        <span class="comment">%plot3(traj(u,1,i),traj(u,2,i),traj(u,3,i),'</span>-<span class="string">','</span>linewidth<span class="string">',3,'</span>color<span class="string">',col(i,:))</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
plot3D(solidxyz,'</span>ko<span class="string">','</span>markerfacecolor<span class="string">','</span>k<span class="string">','</span>markersize<span class="string">',5)
view(3), axis equal
title({'</span>\rm{<span class="string">' strrep(dumpfile, '</span>_<span class="string">', '</span>\_<span class="string">') '</span>}:<span class="string">' '</span>\bf{Velocity of Selected Particles Along Streamlines}<span class="string">'}, '</span>Interpreter<span class="string">', '</span>tex<span class="string">')
xlabel('</span>x (m)<span class="string">'), ylabel('</span>Y (m)<span class="string">'), zlabel('</span>z (m)<span class="string">')
hc = colorbar; hc.Label.String = '</span>velocity (m/s)';

</code></pre></div>
</div>
<div id='example2' class='doc-content' style='display: none;'>
<h1>Workshop Main File - Part 2</h1>
<p>This script demonstrates the data preprocessing, analysis, and visualization techniques<br/>using &#x27;lamdumpread2&#x27;, a custom function for reading LAMMPS dump files.</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">%% Workshop Main File - Part 2</span>
<span class="comment">% This script demonstrates the data preprocessing, analysis, and visualization techniques </span>
<span class="comment">% using <span class="string">'lamdumpread2'</span>, a custom <span class="keyword">function</span> <span class="keyword">for</span> reading LAMMPS dump files.</span>

<span class="comment">% File Structure (change your local path to reflect the content)</span>
<span class="comment">% ├── example2.m</span>
<span class="comment">% └── ...</span>
<span class="comment">% └── data folder (dumps/pub1/)</span>

<span class="comment">%INRAE\Olivier Vitrac, Han Chen (rev. 2023-08-30,2023-08-31)</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-09-04,05 implements grid interpolation</span>

<span class="comment">%% Initialization and Preprocessing </span>
<span class="comment">% -------------------------------------------------</span>
<span class="comment">% Turn preprocessing on or off based on `PREPROCESS_FLAG`. </span>
<span class="comment">% <span class="string">'lamdumpread2'</span> splits large 3D dump files <span class="keyword">if</span> the flag is true.</span>

statvec = @(f,before,after) dispf(<span class="string">'<span class="comment">%s: %s%d values | average = %0.5g %s'</span>, before, ...</span>
    cell2mat(cellfun(@(x) sprintf(<span class="string">' <span class="comment">%0.1f%%> %10.4g | '</span>, x, prctile(f, x)), {2.5, 25, 50, 75, 97.5}, <span class="string">'UniformOutput'</span>, false)), ...</span>
    length(f), mean(f),after); <span class="comment">% user <span class="keyword">function</span> to display statistics on vectors (usage:  statvec(f,<span class="string">'myvar'</span>,<span class="string">'ok'</span>))</span>

PREPROCESS_FLAG = false;
<span class="keyword">if</span> PREPROCESS_FLAG
    datafolder = <span class="string">'./dumps/pub1/'</span>;
    lamdumpread2(fullfile(datafolder,<span class="string">'dump.*'</span>),<span class="string">'split'</span>); <span class="comment">% <span class="keyword">for</span> large 3D</span>
<span class="keyword">end</span>

<span class="comment">%% File-specific Processing (same file as in Example1.m but larger)</span>
<span class="comment">% -----------------------------------------------------------------</span>
<span class="comment">% A specific dump file is selected and pre-processed to extract data and </span>
<span class="comment">% save to default folders <span class="keyword">for</span> further operations.</span>
datafolder = <span class="string">'./dumps/pub1/'</span>;
dumpfile = <span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle'</span>;
datafolder = lamdumpread2(fullfile(datafolder,dumpfile),<span class="string">'search'</span>); <span class="comment">% fix datafolder based on initial guess</span>
defaultfiles = lamdumpread2(fullfile(datafolder,dumpfile),<span class="string">'default'</span>); <span class="comment">% default folder (just <span class="keyword">for</span> check)</span>

<span class="comment">%% Data Extraction</span>
<span class="comment">% -------------------------------------------------</span>
<span class="comment">% Extract the types of atoms and the list of available frames</span>
X0 = lamdumpread2(fullfile(datafolder,dumpfile)); <span class="comment">% default frame</span>
natoms = X0.NUMBER;
timesteps = X0.TIMESTEPS;
atomtypes = unique(X0.ATOMS.type);
ntimesteps = length(timesteps);

<span class="comment">% Extract the middle frame (i.e. in the middle of the simulation duration)</span>
<span class="comment">% X0 is too far from steady state <span class="keyword">for</span> advanced analysis</span>
Xmiddle = lamdumpread2(fullfile(datafolder,dumpfile),<span class="string">'usesplit'</span>,[],timesteps(ceil(ntimesteps/2))); <span class="comment">% middle frame</span>

<span class="comment">% Extract the number of beads <span class="keyword">for</span> each type</span>
<span class="comment">% guess the bead type <span class="keyword">for</span> the fluid (the most populated)</span>
<span class="comment">% same guess <span class="keyword">for</span> the particle (the less populated)</span>
T = X0.ATOMS.type;
natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
[~,fluidtype] = max(natomspertype);
[~,solidtype] = min(natomspertype);
walltypes = setdiff(atomtypes,[fluidtype,solidtype]);

<span class="comment">% Estimate the fluid bead size</span>
<span class="comment">% This step uses <span class="keyword">for</span> more accuracy the buildVerletList()</span>
fluidxyz = X0.ATOMS{T==fluidtype,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}};
fluidid = X0.ATOMS{T==fluidtype,<span class="string">'id'</span>};
nfluidatoms = length(fluidid);
nsolidatoms = natomspertype(solidtype);
<span class="comment">% first estimate assuming that the bead is a cube</span>
boxdims = X0.BOX(:,2) - X0.BOX(:,1);
Vbead_guess = prod(boxdims)/natoms;
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
[verletList,cutoff,dmin,config,dist] = buildVerletList(fluidxyz,cutoff);
rbead = dmin/2;

<span class="comment">% find the direction of the flow (largest dimension)</span>
[~,iflow] = max(boxdims);
iothers = setdiff(1:size(X0.BOX,1),iflow);

<span class="comment">% separate top and bottom walls</span>
vel = {<span class="string">'vx'</span>,<span class="string">'vy'</span>,<span class="string">'vz'</span>};
wall1vel = Xmiddle.ATOMS{Xmiddle.ATOMS.type==walltypes(1),vel{iflow}}; wall1vel = wall1vel(1);
wall2vel = Xmiddle.ATOMS{Xmiddle.ATOMS.type==walltypes(2),vel{iflow}}; wall2vel = wall2vel(1);
[wallvel,iwall] = sort([wall1vel,wall2vel],<span class="string">'descend'</span>); <span class="comment">% 1 is top (>0), 2 is bottom;</span>
walltypes = walltypes(iwall);

<span class="comment">% find the position of the particle (i.e., obstacle) placed in the flow (from the middle frame)</span>
solidxyz = Xmiddle.ATOMS{T==solidtype,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}};
solidid = Xmiddle.ATOMS{T==solidtype,<span class="string">'id'</span>};
solidbox = [min(solidxyz);max(solidxyz)]<span class="string">';

<span class="comment">%% Data Preprocessing <span class="keyword">for</span> Selected Particles</span>
<span class="comment">% -------------------------------------------------</span>
<span class="comment">% This part is a repetition of the content of example1. It generate the streamlines <span class="keyword">for</span> particles </span>
<span class="comment">% at the left. It requires 5 min and it can be skipped as it not used <span class="keyword">for</span> stresses.</span>
<span class="comment">% note: the duration of the simulation enables the particles in the center (slowest part) to</span>
<span class="comment">% cross only half of the cell.</span>

PlotTrajectory = false; <span class="comment">% set it to true to execute this section</span>

<span class="keyword">if</span> PlotTrajectory
    <span class="comment">% Pick n particles randomly from the left inlet and included in the mask of the solid (initial frame)</span>
    n = 300;
    tol = 0.5; <span class="comment">% add 40% particles around</span>
    selectionbox = NaN(3,2);
    selectionbox(iflow,:) = [X0.BOX(iflow,1), X0.BOX(iflow,1)+2*rbead];
    selectionbox(iothers,:) =  (1+tol)*(solidbox(iothers,2)-solidbox(iothers,1))*[-1 1]/2 ...
        + (solidbox(iothers,1)+solidbox(iothers,2)) * [1 1]/2;
    ok = true(nfluidatoms,1);
    <span class="keyword">for</span> c = 1:3
        ok = ok & (fluidxyz(:,c)>=selectionbox(c,1)) & (fluidxyz(:,c)<=selectionbox(c,2));
    <span class="keyword">end</span>
    icandidates = find(ok);
    iselected = icandidates(MDunidrnd(length(icandidates),n));
    selectedid = fluidid(iselected); <span class="comment">% ID to be used</span>
    <span class="comment">% plot selected particles and other ones</span>
    figure, hold on
    plot3D(fluidxyz,'</span>b.<span class="string">')
    plot3D(fluidxyz(iselected,:),'</span>ro<span class="string">','</span>markerfacecolor<span class="string">','</span>r<span class="string">')
    plot3D(solidxyz,'</span>ks<span class="string">','</span>markerfacecolor<span class="string">','</span>k<span class="string">')
    view(3), axis equal

    <span class="comment">% Generate the trajectory <span class="keyword">for</span> the selected particles (<span class="keyword">for</span> all frames)</span>
    <span class="comment">% All data are loaded with Lamdumpread2() with a single call using '</span>usesplit<span class="string">'</span>
    <span class="comment">% each split is loaded individually and only atoms matching selectedid are stored</span>
    <span class="comment">% all atoms are sorted as selectedid (no need to sort them)</span>
    Xselection = lamdumpread2(fullfile(datafolder,dumpfile),'</span>usesplit<span class="string">',[],timesteps,selectedid);

    <span class="comment">% Collect the trajectory of the solid particle <span class="keyword">for</span> all frames</span>
    Xsolid = lamdumpread2(fullfile(datafolder,dumpfile),'</span>usesplit<span class="string">',[],timesteps,solidid);

    <span class="comment">% Store the trajectories stored in a ntimesteps x 3 x n matrix</span>
    <span class="comment">% missing data will</span>
    [seltraj,selveloc] = deal(NaN(ntimesteps,3,n,'</span>single<span class="string">'));
    solidtraj = NaN(ntimesteps,3,nsolidatoms,'</span>double<span class="string">');
    goodframes = true(ntimesteps,1);
    <span class="keyword">for</span> it = 1:ntimesteps
        <span class="comment">% read fluid atoms</span>
        selframe = Xselection.ATOMS(Xselection.ATOMS{:,'</span>TIMESTEP<span class="string">'} == timesteps(it),:);
        nfoundatoms = size(selframe,1);
        <span class="keyword">if</span> nfoundatoms<n <span class="comment">% incomplete dumped frame (it may happen in LAMMPS)</span>
            dispf('</span>incomplete frame <span class="comment">%d/%d (t=%0.4g): %d of %d fluid atoms missing<span class="string">',it,ntimesteps,timesteps(it),n-nfoundatoms,n)</span>
            [~,iatoms,jatoms] = intersect(selectedid,selframe.id,'</span>stable<span class="string">');
            seltraj(it,:,iatoms) = permute(selframe{jatoms,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}},[3 2 1]);
            goodframes(it) = false;
        <span class="keyword">else</span>
            seltraj(it,:,:) = permute(selframe{:,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}},[3 2 1]);
            selveloc(it,:,:) = permute(selframe{:,{'</span>vx<span class="string">','</span>vy<span class="string">','</span>vz<span class="string">'}},[3 2 1]);
        <span class="keyword">end</span>
        <span class="comment">% read solid atoms</span>
        solidframe = Xsolid.ATOMS(Xsolid.ATOMS{:,'</span>TIMESTEP<span class="string">'} == timesteps(it),:);
        nfoundatoms = size(solidframe,1);
        <span class="keyword">if</span> nfoundatoms<nsolidatoms <span class="comment">% incomplete dumped frame (it may happen in LAMMPS)</span>
            dispf('</span>incomplete frame <span class="comment">%d/%d (t=%0.4g): %d of %d solid atoms missing<span class="string">',it,ntimesteps,timesteps(it),nsolidatoms-nfoundatoms,nsolidatoms)</span>
            [~,iatoms,jatoms] = intersect(solidid,solidframe.id,'</span>stable<span class="string">');
            solidtraj(it,:,iatoms) = permute(solidframe{jatoms,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}},[3 2 1]);
            goodframes(it) = false;
        <span class="keyword">else</span>
            solidtraj(it,:,:) = permute(solidframe{:,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}},[3 2 1]);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% velocity magnitude <span class="keyword">for</span> the fluid particles</span>
    selveloc_magnitude = squeeze(sqrt(sum(selveloc.^2, 2)));

    <span class="comment">% Trajectory Visualization</span>
    <span class="comment">% -------------------------------------------------</span>
    <span class="comment">% streamlines with color representing velocity magnitude</span>
    figure, hold on
    col = parula(n);
    <span class="keyword">for</span> i=1:n
        jumps = [1;ntimesteps+1];
        <span class="keyword">for</span> d=1:3
            jumps = unique([jumps;find(abs(diff(seltraj(:,d,i)))>boxdims(d)/2)+1]);
        <span class="keyword">end</span>
        <span class="keyword">for</span> j=1:length(jumps)-1
            u = jumps(j):jumps(j+1)-1;
            streamline = seltraj(u, :, i);
            color_line3(streamline(:, 1), streamline(:, 2), streamline(:, 3), selveloc_magnitude(u, i), '</span>linewidth<span class="string">', 3);
            <span class="comment">% faster method but without streamline</span>
            <span class="comment">%plot3(traj(u,1,i),traj(u,2,i),traj(u,3,i),'</span>-<span class="string">','</span>linewidth<span class="string">',3,'</span>color<span class="string">',col(i,:))</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    plot3D(solidxyz,'</span>ko<span class="string">','</span>markerfacecolor<span class="string">','</span>k<span class="string">','</span>markersize<span class="string">',5)
    view(3), axis equal
    title({'</span>\rm{<span class="string">' strrep(dumpfile, '</span>_<span class="string">', '</span>\_<span class="string">') '</span>}:<span class="string">' '</span>\bf{Velocity of Selected Particles Along Streamlines}<span class="string">'}, '</span>Interpreter<span class="string">', '</span>tex<span class="string">')
    xlabel('</span>x (m)<span class="string">'), ylabel('</span>Y (m)<span class="string">'), zlabel('</span>z (m)<span class="string">')
    hc = colorbar; hc.Label.String = '</span>velocity (m/s)<span class="string">';
<span class="keyword">end</span> <span class="comment">% <span class="keyword">if</span> PlotTrajectory</span>

<span class="comment">%% Stress Analysis in Reference Frame (PART 2)</span>
<span class="comment">% -------------------------------------------------</span>
<span class="comment">% This part focuses on evaluating the mechanical interactions and stress in a particular </span>
<span class="comment">% frame. Specifically, we employ a late-stage frame (closer to steady-state conditions) to </span>
<span class="comment">% derive insights into the types of contacts between fluid and solid atoms.</span>
<span class="comment">% </span>
<span class="comment">% * `timestepforstress`: Time step selected <span class="keyword">for</span> stress analysis.</span>
<span class="comment">% * `Xstress`: Data structure containing all relevant atomic information at the chosen time step.</span>
<span class="comment">% * `verletListCross`: A specialized Verlet list that segregates contacts based on atom types.</span>
<span class="comment">% * `isincontact`, `isincontactwithsolid`, `isincontactwithfluid`: Boolean fields that signify </span>
<span class="comment">% whether an atom is in contact, and with which type of atom.</span>
<span class="comment">%</span>
<span class="comment">% Here we rely heavily on a short-cut-off Verlet list <span class="keyword">for</span> efficiency, separating cross-terms</span>
<span class="comment">% and characterizing specific types of atomic interactions.</span>

<span class="comment">% General container <span class="keyword">for</span> storing data <span class="keyword">for</span> different timesteps</span>
postdata = repmat(struct('</span>type<span class="string">','</span>Landshoff|Hertz<span class="string">','</span>timestep<span class="string">',NaN,'</span>Xfluid<span class="string">',[],'</span>Xsolid<span class="string">',[],'</span>force<span class="string">',[]),0,0);


<span class="comment">% Extract the Specific Frame <span class="keyword">for</span> Stress Interpretation</span>
<span class="comment">% Selects a time step that is presumably closer to the steady-state to perform stress analysis.</span>
list_timestepforstess = unique(timesteps(ceil((0.1:0.1:0.9)*ntimesteps)));
nlist_timestepforstess = length(list_timestepforstess);
consideredtimesteps = 1:nlist_timestepforstess;
consideredtimesteps = nlist_timestepforstess;


<span class="comment">% === Loop on all selected time steps ===</span>
altxt = {'</span>no plot<span class="string">','</span>plot<span class="string">'};
DOINTENSIVECALC = true; <span class="comment">% set it to false, to prevent intensive calculations</span>

<span class="keyword">for</span> i_timestepforstess = consideredtimesteps


    <span class="comment">% Current Frame</span>
    timestepforstress = list_timestepforstess(i_timestepforstess);
    Xstress = lamdumpread2(fullfile(datafolder,dumpfile),'</span>usesplit<span class="string">',[],timestepforstress); <span class="comment">% middle frame</span>
    doplot = ismember(timestepforstress,list_timestepforstess([1 <span class="keyword">end</span>]));
    dispf('</span>\n<span class="comment">%s-\n[%d/%d] TIMESTEP = %d (%s)<span class="string">',repmat('</span>-*<span class="string">',1,40),i_timestepforstess,nlist_timestepforstess,timestepforstress,altxt{doplot+1})</span>


    <span class="comment">% Categorization of Atom Types</span>
    <span class="comment">% Identifies the most and least populous atom types to discern between fluid and solid types.</span>
    T = Xstress.ATOMS.type;
    natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
    [~,fluidtype] = max(natomspertype);
    [~,solidtype] = min(natomspertype);
    walltypes = setdiff(atomtypes,[fluidtype,solidtype]);

    <span class="comment">% Boolean Classification of Atom Types</span>
    Xstress.ATOMS.isfluid = Xstress.ATOMS.type==fluidtype;
    Xstress.ATOMS.issolid = Xstress.ATOMS.type==solidtype;

    <span class="comment">% Verlet List Construction with Short Cutoff</span>
    <span class="comment">% Builds a Verlet list with a short cutoff distance, designed to identify only the closest neighbors.</span>
    [verletList,cutoff,dmin,config,dist] = buildVerletList(Xstress.ATOMS,3*rbead);

    <span class="comment">% Partition Verlet List Based on Atom Types</span>
    <span class="comment">% This Verlet list is partitioned based on atom types, distinguishing between interactions</span>
    <span class="comment">% that are exclusively fluid-fluid, solid-fluid, or solid-solid.</span>
    verletListCross = partitionVerletList(verletList,Xstress.ATOMS);

    <span class="comment">% Identify Contacting Atoms</span>
    <span class="comment">% The atoms that are in contact with each other are identified.</span>
    Xstress.ATOMS.isincontact = ~cellfun(@isempty,verletListCross);
    Xstress.ATOMS.contacttypes = cellfun(@(v) Xstress.ATOMS.type(v)'</span>,verletListCross,<span class="string">'UniformOutput'</span>,false);

    <span class="comment">% Identify Atoms in Contact with Solids and Fluids</span>
    <span class="comment">% Further filters the atoms in contact to identify which are in contact with solids and which with fluids.</span>
    Xstress.ATOMS.isincontactwithsolid = cellfun(@(c) ismember(solidtype,c), Xstress.ATOMS.contacttypes);
    Xstress.ATOMS.isincontactwithfluid = cellfun(@(c) ismember(fluidtype,c), Xstress.ATOMS.contacttypes);

    <span class="comment">% Flag Fluid Atoms in Contact with Solid and Vice Versa</span>
    <span class="comment">% Identifies fluid atoms that are in contact with solid atoms and solid atoms in contact with fluid atoms.</span>
    Xstress.ATOMS.fluidincontactwithsolid = Xstress.ATOMS.isfluid & Xstress.ATOMS.isincontactwithsolid;
    Xstress.ATOMS.solidincontactwithfluid = Xstress.ATOMS.issolid & Xstress.ATOMS.isincontactwithfluid;

    <span class="comment">% Identify Indices <span class="keyword">for</span> Analysis</span>
    <span class="comment">% Indices of fluid and solid atoms that are in contact with each other.</span>
    ifluidcontact = find(Xstress.ATOMS.fluidincontactwithsolid);
    isolidcontact = find(Xstress.ATOMS.solidincontactwithfluid);

    <span class="comment">% Extend Fluid Atoms Set with Neighbors (Not Directly in Contact)</span>
    <span class="comment">% Extends the set of fluid atoms under consideration to include their closest neighbors.</span>
    ifluidcontact_withneighbors = unique(union(ifluidcontact,cat(2,verletList{ifluidcontact}))); <span class="comment">% include neighbors</span>
    ifluidcontact_withneighbors = ifluidcontact_withneighbors(T(ifluidcontact_withneighbors)==fluidtype); <span class="comment">% filter, keep only fluids</span>
    [~,~,ind_withoutneighbors] = intersect(ifluidcontact,ifluidcontact_withneighbors,<span class="string">'stable'</span>);
    notneighboringcontacts = setdiff(ifluidcontact_withneighbors,ifluidcontact_withneighbors(ind_withoutneighbors));

    <span class="comment">% Control Visualization <span class="keyword">for</span> some Frames (default behavior: first and last)</span>
    <span class="comment">% filled red: solid "atoms" in contact with the fluid</span>
    <span class="comment">% filled blue: fluid "atoms" in contact with the solid (crown/shell)</span>
    <span class="comment">% empty blue: fluid "atoms" neighbor of previous ones but not contact</span>
    <span class="comment">% empty blue are used to calculate Landshoff forces at the position of filled ones</span>
    <span class="keyword">if</span> doplot
        figure, hold on
        plot3D(Xstress.ATOMS{ifluidcontact,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}},<span class="string">'bo'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'b'</span>)
        plot3D(Xstress.ATOMS{notneighboringcontacts,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}},<span class="string">'bo'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'w'</span>)
        plot3D(Xstress.ATOMS{isolidcontact,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}},<span class="string">'ro'</span>,<span class="string">'markersize'</span>,12,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
        axis equal, view(3), drawnow
        dispf(<span class="string">'\tnumber of fluid atoms in contact with solid <span class="comment">%d'</span>, length(ifluidcontact))</span>
        dispf(<span class="string">'\tnumber of solid atoms in contact with fluid <span class="comment">%d (neighbors %d)'</span>, length(isolidcontact),length(notneighboringcontacts))</span>
    <span class="keyword">end</span>

    <span class="comment">%% === 3D view of the fluid velocity around the solid ===</span>

    <span class="comment">% Definition of the Viewbox (<span class="keyword">for</span> all grid-based visualizations)</span>
    coords = {<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}; <span class="comment">% Cartesian coordinates</span>
    vcoords = cellfun(@(c) [<span class="string">'v'</span>,c],coords,<span class="string">'UniformOutput'</span>,false); <span class="comment">% vx, vy, vz</span>
    <span class="comment">% Extract the box around solid atoms and include fluid ones</span>
    fluidbox = [ min(Xstress.ATOMS{Xstress.ATOMS.isfluid,coords})
        max(Xstress.ATOMS{Xstress.ATOMS.isfluid,coords}) ]<span class="string">';
    solidbox = [ min(Xstress.ATOMS{Xstress.ATOMS.issolid,coords})
        max(Xstress.ATOMS{Xstress.ATOMS.issolid,coords}) ]'</span>;
    [~,iflow] = max(max(Xstress.ATOMS{Xstress.ATOMS.isfluid,vcoords})); <span class="comment">% direction of the flow</span>
    viewbox = fluidbox; viewbox(iflow,:) = solidbox(iflow,:);
    
    <span class="keyword">if</span> DOINTENSIVECALC <span class="comment">% THIS SECTION IS VERY INTENSIVE (more than 5 mins)</span>
        <span class="comment">% 3D Cartesian Grid from the widow xw, yw, zw</span>
        nresolution = [300 300 30]; resolutionmax = max(nresolution);
        <span class="keyword">for</span> icoord = 1:3
            viewbox(icoord,:) = mean(viewbox(icoord,:)) + [-1.2 1.2]*diff(viewbox(icoord,:))/2*nresolution(icoord)/resolutionmax;
            viewbox(icoord,1) = max(viewbox(icoord,1),fluidbox(icoord,1));
            viewbox(icoord,2) = min(viewbox(icoord,2),fluidbox(icoord,2));
        <span class="keyword">end</span>
        hLandshoff = 5*rbead; <span class="comment">%1.25e-5; % m</span>
        xw = linspace(viewbox(1,1),viewbox(1,2),nresolution(1));
        yw = linspace(viewbox(2,1),viewbox(2,2),nresolution(2));
        zw = linspace(viewbox(3,1),viewbox(3,2),nresolution(3));
        insidewindow = Xstress.ATOMS.isfluid;
        <span class="keyword">for</span> icoord = 1:3
            insidewindow = insidewindow ...
                & Xstress.ATOMS{:,coords{icoord}}>=viewbox(icoord,1) ...
                & Xstress.ATOMS{:,coords{icoord}}<=viewbox(icoord,2);
        <span class="keyword">end</span>
        dispf(<span class="string">'<span class="comment">%d fluid atoms have be found in the cross section around the solid'</span>,length(find(insidewindow)));</span>
        [Xw,Yw,Zw] = meshgrid(xw,yw,zw);
        XYZgrid = [Xw(:),Yw(:),Zw(:)];

        <span class="comment">% Verlet Grid List: lists the beads close to a grid node/vertex</span>
        XYZ = Xstress.ATOMS{insidewindow,coords}; <span class="comment">% kernel centers</span>
        VXYZ = buildVerletList({XYZgrid XYZ},1.2*hLandshoff); <span class="comment">% special grid syntax</span>
        
        <span class="comment">% Interpolation of all velocity components (vx, vy, vz)</span>
        <span class="comment">% v3XYZgrid is the interpolated vectorial field</span>
        <span class="comment">% vxXYZgrid, vyXYZgrid, vzXYZgrid are the components</span>
        <span class="comment">% vXYZgrid is the magnitude</span>
        <span class="comment">% note: For interpolating the density only: interpolates ones(size(XYZ,1),1,<span class="string">'single'</span>)</span>
        W = kernelSPH(hLandshoff,<span class="string">'lucy'</span>,3); <span class="comment">% kernel expression</span>
        vXYZ = Xstress.ATOMS{insidewindow,vcoords}; <span class="comment">% kernel centers</span>
        vXYZmag = sqrt(sum(vXYZ.^2,2)); <span class="comment">% velocity magnitude</span>
        mbead = 9.04e-12;
        Vbead = mbead/1000;
        v3XYZgrid = interp3SPHVerlet(XYZ,vXYZ,XYZgrid,VXYZ,W,Vbead);
        vxXYZgrid = reshape(v3XYZgrid(:,1),size(Xw)); vxXYZgrid(isnan(vxXYZgrid)) = 0;
        vyXYZgrid = reshape(v3XYZgrid(:,2),size(Xw)); vyXYZgrid(isnan(vyXYZgrid)) = 0;
        vzXYZgrid = reshape(v3XYZgrid(:,3),size(Xw)); vzXYZgrid(isnan(vzXYZgrid)) = 0;
        vXYZgrid  = reshape(sqrt(sum(v3XYZgrid.^2,2)),size(Xw));

        <span class="comment">% 3D Figure (<span class="keyword">for</span> control only, we plot one iso-velocity surface)</span>
        <span class="comment">% we add the solid phase as a meshed solid</span>
        figure, hold on
        visocontour = max(vXYZmag)/10;
        isosurface(Xw,Yw,Zw,vXYZgrid,visocontour)
        DT = delaunayTriangulation(double(Xstress.ATOMS{isolidcontact,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}}));
        K = convexHull(DT);
        trisurf(K, DT.Points(:,1), DT.Points(:,2), DT.Points(:,3), <span class="string">'FaceColor'</span>, <span class="string">'w'</span>,<span class="string">'Edgecolor'</span>,<span class="string">'k'</span>,<span class="string">'FaceAlpha'</span>,0.6);
        lighting gouraud, camlight left, axis equal, view(3) <span class="comment">% shading interp</span>

        <span class="comment">%% cuts and slices (caps are put on the smallest contour)</span>
        figure, hold on
        vXYZcut = vXYZgrid;
        boxcenter = (fluidbox(:,1)+fluidbox(:,2))/2; <span class="comment">% boxcenter = (solidbox(:,1)+solidbox(:,2))/2;</span>
        [Xwcut,Ywcut,Zwcut] = deal(Xw,Yw,Zw);
        vXYZcut(:,yw>boxcenter(2),:) = [];
        Xwcut(:,yw>boxcenter(2),:) = [];
        Ywcut(:,yw>boxcenter(2),:) = [];
        Zwcut(:,yw>boxcenter(2),:) = [];
        <span class="comment">% vXYZcut(:,:,zw>boxcenter(3),:) = [];</span>
        <span class="comment">% Xwcut(:,:,zw>boxcenter(3),:) = [];</span>
        <span class="comment">% Ywcut(:,:,zw>boxcenter(3),:) = [];</span>
        <span class="comment">% Zwcut(:,:,zw>boxcenter(3),:) = [];</span>
        <span class="comment">% iso-surface val</span>
        colors = parula(256);
        visomax = max(vXYZmag);
        visocontour = visomax * [1/20,1/10,1/5, 1/4, 1/3, 1/2];
        visocolors = interp1(linspace(0,visomax,size(colors,1)),colors,visocontour);
        <span class="keyword">for</span> icontour = 1:length(visocontour)
            patch(isosurface(Xwcut,Ywcut,Zwcut,vXYZcut, visocontour(icontour)),...
                <span class="string">'FaceColor'</span>,visocolors(icontour,:),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>,<span class="string">'FaceAlpha'</span>,0.6);
        <span class="keyword">end</span>
        p2 = patch(isocaps(Xwcut,Ywcut,Zwcut,vXYZcut, visocontour(1)),<span class="string">'FaceColor'</span>,<span class="string">'interp'</span>,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>,<span class="string">'FaceAlpha'</span>,0.6);
        colormap(colors), camlight(<span class="string">'right'</span>), lighting gouraud, view(3), axis equal
        trisurf(K, DT.Points(:,1), DT.Points(:,2), DT.Points(:,3), <span class="string">'FaceColor'</span>, <span class="string">'w'</span>,<span class="string">'Edgecolor'</span>,<span class="string">'k'</span>,<span class="string">'FaceAlpha'</span>,0.6);
        hs= slice(Xw,Yw,Zw,vXYZgrid,boxcenter(1), ...
            [solidbox(2,1) boxcenter(2) solidbox(2,2)], ...
            [viewbox(3,1) boxcenter(3)]); 
        set(hs,<span class="string">'edgecolor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.5)
        view(115,34)
        <span class="comment">% add quiver plot</span>
        quiver3(Xw(1:20:<span class="keyword">end</span>,1:20:<span class="keyword">end</span>,1:3:<span class="keyword">end</span>),Yw(1:20:<span class="keyword">end</span>,1:20:<span class="keyword">end</span>,1:3:<span class="keyword">end</span>),Zw(1:20:<span class="keyword">end</span>,1:20:<span class="keyword">end</span>,1:3:<span class="keyword">end</span>), ...
            vxXYZgrid(1:20:<span class="keyword">end</span>,1:20:<span class="keyword">end</span>,1:3:<span class="keyword">end</span>),vyXYZgrid(1:20:<span class="keyword">end</span>,1:20:<span class="keyword">end</span>,1:3:<span class="keyword">end</span>),vzXYZgrid(1:20:<span class="keyword">end</span>,1:20:<span class="keyword">end</span>,1:3:<span class="keyword">end</span>), ...
            <span class="string">'color'</span>,<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,1)
        <span class="comment">% add streamlines (note that all arguments required to be double)</span>
        [startX,startY,startZ] = meshgrid(double(xw(1)),double(yw(10:10:<span class="keyword">end</span>-10)),double(zw(1:2:<span class="keyword">end</span>)));
        vstart = interp3(Xw,Yw,Zw,vxXYZgrid,startX,startY,startZ); startX(vstart<0) = double(xw(<span class="keyword">end</span>));
        hsl = streamline(double(Xw),double(Yw),double(Zw),vxXYZgrid,vyXYZgrid,vzXYZgrid,startX,startY,startZ);
        set(hsl,<span class="string">'linewidth'</span>,2,<span class="string">'color'</span>,[0.4375    0.5000    0.5625])
        plot3(startX(:),startY(:),startZ(:),<span class="string">'ro'</span>,<span class="string">'markerfacecolor'</span>,[0.4375    0.5000    0.5625])
    <span class="keyword">end</span>

    <span class="comment">%% Landshoff forces in the fluid</span>
    <span class="comment">%</span>
    <span class="comment">% This section is dedicated to the calculation of Landshoff forces in the fluid medium.</span>
    <span class="comment">% The computation is confined to a shell or "crown" around the solid particles.</span>
    <span class="comment">% Here, we build a new Verlet list specific to the fluid particles around solid structures.</span>
    <span class="comment">%</span>
    <span class="comment">% * `Xfluidcontact_withneighbors`: Atomic information specifically <span class="keyword">for</span> the fluid atoms in the vicinity of the solid.</span>
    <span class="comment">% * `Vfluidcontact_withneighbors`: Verlet list constructed <span class="keyword">for</span> these neighboring fluid atoms.</span>
    <span class="comment">% * `Flandshoff`: Landshoff forces calculated based on the new Verlet list.</span>
    <span class="comment">% * `f`: Magnitude of the Landshoff forces.</span>
    <span class="comment">%</span>
    <span class="comment">% Finally, visualization aids are employed to graphically represent these forces and their directions.</span>


    <span class="comment">% Extract Information <span class="keyword">for</span> Fluid Atoms in Contact with Neighbors</span>
    <span class="comment">% Obtains the atomic information <span class="keyword">for</span> fluid atoms in the vicinity of solid atoms, as identified earlier.</span>
    Xfluidcontact_withneighbors = Xstress.ATOMS(ifluidcontact_withneighbors,:);

    <span class="comment">% Verlet List Construction <span class="keyword">for</span> Fluid Atoms</span>
    <span class="comment">% Constructs a Verlet list <span class="keyword">for</span> these neighboring fluid atoms with a larger cutoff (4*rbead).</span>
    Vfluidcontact_withneighbors = buildVerletList(Xfluidcontact_withneighbors,4*rbead);

    <span class="comment">%%% Compute Landshoff Forces</span>
    <span class="comment">% Computes Landshoff forces based on the new Verlet list.</span>
    <span class="comment">% The config structure (configLandshoff) should match the input values of the simulation or equivalent</span>
    hLandshoff = 5*rbead; <span class="comment">%1.25e-5; % m</span>
    configLandshoff = struct( ...
        <span class="string">'gradkernel'</span>, kernelSPH(hLandshoff,<span class="string">'lucyder'</span>,3),...kernel gradient
        <span class="string">'h'</span>, hLandshoff,...smoothing length (m)
        <span class="string">'c0'</span>,0.32,...speed of the sound (m/s)
        <span class="string">'q1'</span>,30,... viscosity coefficient (-)
        <span class="string">'rho'</span>, 1000, ...density
        <span class="string">'m'</span>, 9.04e-12 ...
        );
    Flandshoff = forceLandshoff(Xfluidcontact_withneighbors,[],Vfluidcontact_withneighbors,configLandshoff);
    Flandshoff_all = Flandshoff;

    <span class="comment">% Restrict to the Crown/Shell Around the Solid</span>
    <span class="comment">% Filters out the Landshoff forces, focusing only on the "crown" or shell around the solid atoms.</span>
    Flandshoff = double(Flandshoff(ind_withoutneighbors,:)); <span class="comment">% we restrict only to the crown/shell</span>
    flandshoff = sqrt(sum(Flandshoff.^2,2));
    statvec(flandshoff,<span class="string">'Landshoff'</span>,sprintf(<span class="string">'<-- TIMESTEP: <span class="comment">%d'</span>,timestepforstress))</span>

    <span class="comment">%%% Store the current result</span>
    postdata(<span class="keyword">end</span>+1).type = <span class="string">'Landshoff'</span>; <span class="comment">% <span class="keyword">end</span>+1 triggers a new object</span>
    postdata(<span class="keyword">end</span>).timestep = timestepforstress; <span class="comment">% we fill it with <span class="keyword">end</span></span>
    postdata(<span class="keyword">end</span>).Xfluid = Xstress.ATOMS(ifluidcontact,:);
    postdata(<span class="keyword">end</span>).Xsolid = Xstress.ATOMS(isolidcontact,:);
    postdata(<span class="keyword">end</span>).force = Flandshoff;

    <span class="comment">%%% Compute Hertz contacts</span>
    <span class="comment">% Extract Information <span class="keyword">for</span> Fluid Atoms in Contact</span>
    Xcontactregion = Xstress.ATOMS(union(ifluidcontact,isolidcontact),:);
    <span class="comment">% Verlet List Construction <span class="keyword">for</span> Solid Atoms (only) and considering only Fluid Atoms as neighbors</span>
    [Vcontactregion,~,dmincontact] = buildVerletList(Xcontactregion,3*rbead,[],[],[],Xcontactregion.isfluid,Xcontactregion.issolid);
    <span class="comment">% Compute Hertz Forces</span>
    Rfluid = 1.04e-5; <span class="comment">% m</span>
    Rsolid = 1.56e-5; <span class="comment">% m</span>
    Rfluid = Rsolid;
    configHertz = struct(<span class="string">'R'</span>,{Rsolid Rfluid},<span class="string">'E'</span>,2000);
    FHertz = forceHertz(Xcontactregion,Vcontactregion,configHertz);
    fhertz = sqrt(sum(FHertz.^2,2));
    fhertzcontacts = fhertz(fhertz>0);
    statvec(fhertzcontacts,<span class="string">'Hertz'</span>,sprintf(<span class="string">'<-- TIMESTEP: <span class="comment">%d\n\tsubjected to Rsolid=[%0.4g %0.4g] dmin/2=%0.4g'</span>,timestepforstress,configHertz(1).R,configHertz(2).R,dmincontact/2))</span>

    <span class="comment">%%% Store current results</span>
    <span class="comment">% Store the current result</span>
    postdata(<span class="keyword">end</span>+1).type = <span class="string">'Hertz'</span>; <span class="comment">% <span class="keyword">end</span>+1 triggers a new object</span>
    postdata(<span class="keyword">end</span>).timestep = timestepforstress; <span class="comment">% we fill it with <span class="keyword">end</span></span>
    postdata(<span class="keyword">end</span>).Xfluid = [];
    postdata(<span class="keyword">end</span>).Xsolid = Xcontactregion(fhertz>0,:);
    postdata(<span class="keyword">end</span>).force = FHertz(fhertz>0);

<span class="keyword">end</span> <span class="comment">% next i_timestepforstess</span>

<span class="comment">%% Visualization (bead-based) of Landshoff forces</span>
<span class="comment">% Creates a 3D visualization featuring both the solid structure and the fluid atoms under consideration.</span>
<span class="comment">% The Landshoff forces are represented as arrows originating from the fluid atoms.</span>
<span class="comment">%</span>
<span class="comment">%   Two approaches are proposed:</span>
<span class="comment">%       a rough one based on the forces acting on the beads, which will be subsequently projected on the particle</span>
<span class="comment">%       a more accurate one based on an interpolation of the forces on a regular grid</span>


<span class="comment">% Tesselated Solid Visualization</span>
<span class="comment">% Utilizes Delaunay triangulation to represent the solid structure.</span>
DT = delaunayTriangulation(double(Xstress.ATOMS{isolidcontact,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}}));
K = convexHull(DT);
figure, hold on
trisurf(K, DT.Points(:,1), DT.Points(:,2), DT.Points(:,3), <span class="string">'FaceColor'</span>, <span class="string">'w'</span>,<span class="string">'Edgecolor'</span>,<span class="string">'k'</span>,<span class="string">'FaceAlpha'</span>,0.6);
axis equal; view(3)

<span class="comment">%% Basic Visualization of Fluid Atoms and Landshoff Forces</span>
<span class="comment">% Landshoff forces are scaled and then visualized as arrows.</span>
<span class="comment">% fluid around</span>
<span class="comment">% scatter3D(Xfluidcontact_withneighbors{ind_withoutneighbors,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}},f);</span>
fmedian = median(flandshoff);
fmin = fmedian/50;
fscale = 4*rbead/fmedian;
start = Xfluidcontact_withneighbors{ind_withoutneighbors,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}};
stop = start + Flandshoff * fscale;
start(flandshoff<fmin,:) = []; <span class="comment">% non-significant forces are removed</span>
stop(flandshoff<fmin,:) = [];
<span class="comment">%ha = arrow(start,stop,<span class="string">'length'</span>,4,<span class="string">'BaseAngle'</span>,60,<span class="string">'color'</span>,<span class="string">'r'</span>);</span>
axis equal, view(3)
title(<span class="string">'Landshoff Forces around the Tessellated Surface'</span>);
xlabel(<span class="string">'X'</span>); ylabel(<span class="string">'Y'</span>); zlabel(<span class="string">'Z'</span>)

<span class="comment">%% Advanced LandShoff Visualization based on Grid Interpolation</span>
coords = {<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>};
landshofbox = [ min(Xfluidcontact_withneighbors{:,coords})
                max(Xfluidcontact_withneighbors{:,coords}) ]<span class="string">';
xlw = linspace(viewbox(1,1),viewbox(1,2),50);
ylw = linspace(viewbox(2,1),viewbox(2,2),50);
zlw = linspace(viewbox(3,1),viewbox(3,2),50);
[Xlw,Ylw,Zlw] = meshgrid(xlw,ylw,zlw);
XYZlgrid = [Xlw(:),Ylw(:),Zlw(:)];
XYZl = Xfluidcontact_withneighbors{:,coords}; <span class="comment">% kernel centers</span>
<span class="comment">% Interpolation at Grid Points of Flandshoff_all</span>
VXYZl = buildVerletList({XYZlgrid XYZl},1.2*hLandshoff); <span class="comment">% special grid syntax</span>
W = kernelSPH(hLandshoff,'</span>lucy<span class="string">',3); <span class="comment">% kernel expression</span>
mbead = 9.04e-12;
Vbead = mbead/1000;
FXYZgrid = interp3SPHVerlet(XYZl,Flandshoff_all,XYZlgrid,VXYZl,W,Vbead);
FXYZgridx = reshape(FXYZgrid(:,1),size(Xlw));
FXYZgridy = reshape(FXYZgrid(:,2),size(Ylw));
FXYZgridz = reshape(FXYZgrid(:,3),size(Zlw));
<span class="comment">% Quiver plot to show the forces with an adjusted step</span>
quiver3(...
    Xlw(1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>), ...
    Ylw(1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>), ...
    Zlw(1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>), ...
    FXYZgridx(1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>), ...
    FXYZgridy(1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>), ...
    FXYZgridz(1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>,1:2:<span class="keyword">end</span>), ...
    '</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',1)

<span class="comment">%% Similar Visualization <span class="keyword">for</span> Hertz Contacts</span>
warning off
figure, hold on
fmedian = median(fhertzcontacts);
fmin = fmedian/50;
fscale = 4*rbead/fmedian;
start = Xcontactregion{fhertz>0,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}};
stop = start - FHertz(fhertz>0,:) * fscale; <span class="comment">% outwards forces (preferred)</span>
start(fhertzcontacts<fmin,:) = []; <span class="comment">% non-significant forces are removed</span>
stop(fhertzcontacts<fmin,:) = [];
D = pdist2(DT.Points, start); <span class="comment">% Compute pairwise distance</span>
[~, idx] = min(D, [], 2); <span class="comment">% Find closest particles on the mesh</span>
trisurf(K, DT.Points(:,1), DT.Points(:,2), DT.Points(:,3), fhertzcontacts(idx),'</span>Edgecolor<span class="string">','</span>k<span class="string">','</span>FaceAlpha<span class="string">',0.6);
axis equal; view(3), camlight('</span>headlight<span class="string">'); camlight('</span>left<span class="string">'); lighting phong; colorbar;
shading interp
ha = arrow(start,stop,'</span>length<span class="string">',4,'</span>BaseAngle<span class="string">',60,'</span>color<span class="string">','</span>r<span class="string">');
axis equal, view(3)
title('</span>Hertz Forces onto the Tessellated Surface<span class="string">');
xlabel('</span>X<span class="string">'); ylabel('</span>Y<span class="string">'); zlabel('</span>Z<span class="string">')

<span class="comment">%% Grid Visualization of Hertz Contacts</span>
<span class="comment">% === STEP 1/5 === Original Delaunay triangulation and the convex hull</span>
DT = delaunayTriangulation(double(Xstress.ATOMS{isolidcontact, {'</span>x<span class="string">', '</span>y<span class="string">', '</span>z<span class="string">'}}));
K = convexHull(DT);
<span class="comment">% === STEP 2/5 === refine the initial mesh by adding midpoints</span>
<span class="comment">% Extract the convex hull points and faces</span>
hullPoints = DT.Points;
hullFaces = DT.ConnectivityList(K, :);
<span class="comment">% Initialize a set to keep track of midpoints to ensure they are unique</span>
midpointSet = zeros(0, 3);
<span class="comment">% Calculate midpoints <span class="keyword">for</span> each edge in each triangle and add to the point list</span>
<span class="keyword">for</span> faceIdx = 1:size(hullFaces, 1)
    face = hullFaces(faceIdx, :);
    <span class="keyword">for</span> i = 1:3
        <span class="keyword">for</span> j = i+1:3
            p1 = hullPoints(face(i), :);
            p2 = hullPoints(face(j), :);
            midpoint = (p1 + p2) / 2;        
            <span class="comment">% Store the midpoint <span class="keyword">if</span> unique</span>
            <span class="keyword">if</span> isempty(midpointSet) || ~ismember(midpoint, midpointSet, '</span>rows<span class="string">')
                midpointSet = [midpointSet; midpoint]; <span class="comment">%#ok<AGROW></span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Merge the original points and the new midpoints</span>
newPoints = [hullPoints; midpointSet];
<span class="comment">% Re-calculate the Delaunay triangulation and convex hull)</span>
newDT = delaunayTriangulation(newPoints);
newK = convexHull(newDT);
<span class="comment">% === STEP 3/5 ===  Laplacian Smoothing</span>
points = newDT.Points;         <span class="comment">% === Extract points and faces</span>
faces = newDT.ConnectivityList(newK, :);
n = size(points, 1);           <span class="comment">% === Initialize new points</span>
newPoints = zeros(size(points)); 
neighbors = cell(n, 1);        <span class="comment">% List of neighbors</span>
<span class="keyword">for</span> faceIdx = 1:size(faces, 1) <span class="comment">% === Find the neighbors of each vertex</span>
    face = faces(faceIdx, :);
    <span class="keyword">for</span> i = 1:3
        vertex = face(i);
        vertex_neighbors = face(face ~= vertex);
        neighbors{vertex} = unique([neighbors{vertex}; vertex_neighbors(:)]);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">for</span> i = 1:n                   <span class="comment">% === Laplacian smoothing</span>
    neighbor_indices = neighbors{i};
    <span class="keyword">if</span> isempty(neighbor_indices) <span class="comment">% Keep the point as is <span class="keyword">if</span> it has no neighbors</span>
        newPoints(i, :) = points(i, :); 
    <span class="keyword">else</span> <span class="comment">% Move the point to the centroid of its neighbors</span>
        newPoints(i, :) = mean(points(neighbor_indices, :), 1);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Update the Delaunay triangulation with the smoothed points</span>
newDT = delaunayTriangulation(newPoints);
newK = convexHull(newDT);
<span class="comment">% === STEP 4/5 === Interpolate the Hertz forces on the triangular mesh</span>
coords = {'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'};
XYZhtri = newDT.Points;
XYZh = Xcontactregion{:,coords}; <span class="comment">% kernel centers</span>
VXYZh = buildVerletList({XYZhtri XYZh},1.2*hLandshoff); <span class="comment">% special grid syntax</span>
W = kernelSPH(hLandshoff,'</span>lucy<span class="string">',3); <span class="comment">% kernel expression</span>
mbead = 9.04e-12;
Vbead = mbead/1000;
FXYZtri = interp3SPHVerlet(XYZh,FHertz,XYZhtri,VXYZh,W,Vbead);
<span class="comment">% FXYZtrix = reshape(FXYZgrid(:,1),size(Xlw)); not used OV 2023-09-09</span>
<span class="comment">% FXYZtriy = reshape(FXYZgrid(:,2),size(Ylw));</span>
<span class="comment">% FXYZtriz = reshape(FXYZgrid(:,3),size(Zlw));</span>
<span class="comment">% === STEP 5/5 === Extract tagential forces</span>
<span class="comment">% Calculate face normals and centroids</span>
points = newDT.Points;
faces = newK;
v1 = points(faces(:, 1), :) - points(faces(:, 2), :);
v2 = points(faces(:, 1), :) - points(faces(:, 3), :);
faceNormals = cross(v1, v2, 2);
faceNormals = faceNormals ./ sqrt(sum(faceNormals.^2, 2));
centroids = mean(reshape(points(faces, :), size(faces, 1), 3, 3), 3);
<span class="comment">% Interpolate force at each centroid using scatteredInterpolant <span class="keyword">for</span> each component</span>
FInterp_x = scatteredInterpolant(XYZhtri, double(FXYZtri(:,1)), '</span>linear<span class="string">', '</span>nearest<span class="string">');
FInterp_y = scatteredInterpolant(XYZhtri, double(FXYZtri(:,2)), '</span>linear<span class="string">', '</span>nearest<span class="string">');
FInterp_z = scatteredInterpolant(XYZhtri, double(FXYZtri(:,3)), '</span>linear<span class="string">', '</span>nearest<span class="string">');
FXYZtri_at_centroids = [FInterp_x(centroids), FInterp_y(centroids), FInterp_z(centroids)];
<span class="comment">% Calculate normal and tangential components of the force at each face centroid</span>
normalComponent = dot(FXYZtri_at_centroids, faceNormals, 2);
normalForce = repmat(normalComponent, 1, 3) .* faceNormals;
tangentialForce = FXYZtri_at_centroids - normalForce;
<span class="comment">% Calculate the magnitude of the tangential force</span>
tangentialMagnitude = sqrt(sum(tangentialForce.^2, 2));


<span class="comment">% === FINAL PLOTS ===</span>
figure, hold on
trisurfHandle = trisurf(newK, newDT.Points(:, 1), newDT.Points(:, 2), newDT.Points(:, 3), '</span>Edgecolor<span class="string">', '</span>k<span class="string">', '</span>FaceAlpha<span class="string">', 0.6);
set(trisurfHandle, '</span>FaceVertexCData<span class="string">', tangentialMagnitude, '</span>FaceColor<span class="string">', '</span>flat<span class="string">');
colorbar;
<span class="comment">% Quiver plot to show the forces with an adjusted step</span>
quiver3(...
    XYZhtri(:,1), ...
    XYZhtri(:,2), ...
    XYZhtri(:,3), ...
    -FXYZtri(:,1), ...
    -FXYZtri(:,2), ...
    -FXYZtri(:,3), ...
    2, ...scale
    '</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',3)
axis equal; view(3), camlight('</span>headlight<span class="string">'); camlight('</span>left<span class="string">'); lighting phong; colorbar;
title('</span>Hertz Forces onto the Tessellated Surface<span class="string">');
xlabel('</span>X<span class="string">'); ylabel('</span>Y<span class="string">'); zlabel('</span>Z<span class="string">')





<span class="comment">%% Project Landshoff Forces onto the Tessellated Surface</span>
<span class="comment">% Allocate space <span class="keyword">for</span> the projected forces.</span>
FprojectedN = zeros(size(Flandshoff));
FprojectedT = zeros(size(Flandshoff));
<span class="comment">% Extract vertex coordinates from Delaunay Triangulation object.</span>
vertices = DT.Points;
<span class="comment">% Loop through all fluid atoms in contact with the solid.</span>
<span class="keyword">for</span> i = 1:length(ind_withoutneighbors)
    <span class="comment">% Get the position of the current fluid atom.</span>
    fluidPos = Xfluidcontact_withneighbors{ind_withoutneighbors(i),{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}};
    <span class="comment">% Find the closest vertex on the tessellated surface.</span>
    dists = sum((vertices - fluidPos).^2, 2);
    [~, closestVertexIdx] = min(dists);
    closestVertex = vertices(closestVertexIdx, :);
    <span class="comment">% Calculate the vector from the fluid atom to the closest surface vertex.</span>
    surfaceToFluidVec = fluidPos - closestVertex;
    <span class="comment">% Normalize the vector.</span>
    surfaceToFluidVec = surfaceToFluidVec / norm(surfaceToFluidVec);
    <span class="comment">% Get the Landshoff force acting on the fluid atom.</span>
    landshoffForce = Flandshoff(i, :);
    <span class="comment">% Project the Landshoff force onto the normal.</span>
    <span class="comment">% Here, surfaceToFluidVec serves as the approximation of the outward normal at the closest vertex.</span>
    projectedForceN = dot(landshoffForce, surfaceToFluidVec) * surfaceToFluidVec;
    <span class="comment">% Store the projected force.</span>
    FprojectedN(i, :) = projectedForceN;
    FprojectedT(i, :) = landshoffForce-projectedForceN;
<span class="keyword">end</span>

<span class="comment">% At this point, Fprojected contains the Landshoff forces projected onto the surface normal.</span>
<span class="comment">% Interpolation and Stress Magnitude Visualization</span>
<span class="comment">% Get faces and vertices from the tessellation.</span>
faces = K; <span class="comment">% Faces are given by the convex hull indices</span>
vertices = DT.Points; <span class="comment">% Vertex coordinates</span>

<span class="comment">% Loop over all faces to interpolate force and stress.</span>
<span class="comment">% Compute Barycentric Interpolation of Forces</span>
<span class="comment">% Initialize an array to store the interpolated forces and stresses</span>
FNinterp_face = zeros(size(faces, 1), 3);
FTinterp_face = zeros(size(faces, 1), 3);
SNinterp_face = zeros(size(faces, 1), 3); <span class="comment">% Normal stress per unit area</span>
STinterp_face = zeros(size(faces, 1), 3); <span class="comment">% Tangential stress per unit area</span>

<span class="comment">% Loop over all faces.</span>
<span class="keyword">for</span> i = 1:size(faces, 1)
    <span class="comment">% Vertices of the triangle.</span>
    vertex_indices = faces(i, :);
    A = vertices(vertex_indices(1), :);
    B = vertices(vertex_indices(2), :);
    C = vertices(vertex_indices(3), :);
    <span class="comment">% Surface area of the triangle using Heron'</span>s formula.</span>
    AB = norm(A - B);
    AC = norm(A - C);
    BC = norm(B - C);
    s = (AB + AC + BC) / 2;
    area_triangle = sqrt(s * (s - AB) * (s - AC) * (s - BC));
    <span class="comment">% Normal to faces</span>
    N = cross(B - A, C - A);
    N = N / norm(N); <span class="comment">% Normalizing the normal vector</span>
    <span class="comment">% Forces at the vertices.</span>
    F_A = FprojectedN(vertex_indices(1), :) + FprojectedT(vertex_indices(1), :);
    F_B = FprojectedN(vertex_indices(2), :) + FprojectedT(vertex_indices(2), :);
    F_C = FprojectedN(vertex_indices(3), :) + FprojectedT(vertex_indices(3), :);
    <span class="comment">% The centroid (P) of the triangle <span class="keyword">for</span> interpolation.</span>
    P = (A + B + C) / 3;
    <span class="comment">% Barycentric weights.</span>
    ABC_inv = inv([A; B; C]);
    w = ABC_inv * P<span class="string">';
    <span class="comment">% Interpolate the force at the centroid.</span>
    Finterp = w(1) * F_A + w(2) * F_B + w(3) * F_C; 
    <span class="comment">% Decompose the force into normal and tangential components</span>
    F_N = dot(Finterp, N) * N; <span class="comment">% only the normal force is trivial to compute</span>
    F_T = Finterp - F_N; <span class="comment">% by subtraction we get the tangential</span>
    <span class="comment">% Store interpolated force.</span>
    Finterp_face(i, :) = Finterp;
    <span class="comment">% Compute normal and tangential stress per unit area (Force/Area)</span>
    SNinterp_face(i, :) = F_N / area_triangle;
    STinterp_face(i, :) = F_T / area_triangle;
<span class="keyword">end</span>
<span class="comment">% Compute the magnitude of interpolated stress.</span>
face_force_magnitude = sqrt(sum(Finterp_face.^2, 2));
face_stressN_magnitude = sqrt(sum(SNinterp_face.^2, 2));
face_stressT_magnitude = sqrt(sum(STinterp_face.^2, 2));


<span class="comment">% Add the smoothed force at vertices</span>
<span class="comment">% In computational geometry, the "valence" of a vertex refers to the number of edges</span>
<span class="comment">% (or equivalently, faces <span class="keyword">for</span> a triangular mesh) incident to it. Valence can serve as</span>
<span class="comment">% an important metric in mesh quality and adaptivity considerations. </span>
<span class="comment">% In our <span class="keyword">case</span>, the valence is expected high (up to 11,12 faces per vertex), then poor mesh</span>
uniq_vertex_indices = unique(faces(:)); <span class="comment">% Find unique vertices used in faces</span>
uniq_vertices = vertices(uniq_vertex_indices, :); <span class="comment">% Create a new vertices array based on these unique indices</span>
mapping = NaN(size(vertices, 1), 1); <span class="comment">% Create a mapping from old vertex indices to new ones</span>
mapping(uniq_vertex_indices) = 1:length(uniq_vertex_indices);
uniq_faces = mapping(faces); <span class="comment">% Update the faces array to reflect new vertex indices</span>
<span class="comment">% Initialize interpolated forces at vertices</span>
Finterp_vertex = zeros(size(uniq_vertices, 1), 3);
SNinterp_vertex = zeros(size(uniq_vertices, 1), 3);
STinterp_vertex = zeros(size(uniq_vertices, 1), 3);
<span class="comment">% Create a mapping from vertices to faces</span>
vertex_to_faces = cell(size(uniq_vertices, 1), 1);
<span class="keyword">for</span> i = 1:size(uniq_faces, 1)
    <span class="keyword">for</span> j = 1:3 <span class="comment">% <span class="keyword">for</span> each Vertex</span>
        vertex_to_faces{uniq_faces(i, j)} = [vertex_to_faces{uniq_faces(i, j)}; i]; <span class="comment">% we add the ith face</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Interpolate forces at each vertex</span>
<span class="keyword">for</span> i = 1:size(uniq_vertices, 1)
    adjacent_faces = vertex_to_faces{i};
    <span class="keyword">if</span> ~isempty(adjacent_faces)
        Finterp_vertex(i, :) = mean(Finterp_face(adjacent_faces, :), 1);
        SNinterp_vertex(i, :) = mean(SNinterp_face(adjacent_faces, :), 1);
        STinterp_vertex(i, :) = mean(STinterp_face(adjacent_faces, :), 1);
    <span class="keyword">end</span>
<span class="keyword">end</span>
vertex_force_magnitude = sqrt(sum(Finterp_vertex.^2, 2));
vertex_stressN_magnitude = sqrt(sum(SNinterp_vertex.^2, 2));
vertex_stressT_magnitude = sqrt(sum(STinterp_vertex.^2, 2));

<span class="comment">% Visualization (face-based, less smooth)</span>
figure;
trisurf(faces, vertices(:, 1), vertices(:, 2), vertices(:, 3), face_force_magnitude, '</span>EdgeColor<span class="string">', '</span>none<span class="string">');
axis equal; view(3);
colorbar;
title('</span>Interpolated Force Magnitude on Tessellated Surface (face-based)<span class="string">');
xlabel('</span>X<span class="string">'); ylabel('</span>Y<span class="string">'); zlabel('</span>Z<span class="string">')

<span class="comment">% Visualization (vertex-based, more smooth)</span>
figure;
trisurf(uniq_faces, uniq_vertices(:, 1), uniq_vertices(:, 2), uniq_vertices(:, 3), vertex_force_magnitude, '</span>EdgeColor<span class="string">', '</span>none<span class="string">');
axis equal; view(3);
colorbar;
title('</span>Interpolated Force Magnitude on Tessellated Surface  (vertex-based)<span class="string">');
xlabel('</span>X<span class="string">'); ylabel('</span>Y<span class="string">'); zlabel('</span>Z<span class="string">')

<span class="comment">% Optimized visualization using '</span>patch<span class="string">' <span class="keyword">for</span> stresses</span>
<span class="comment">% only vertex_stressT_magnitude is meaningful</span>
figure;
patch_data.Vertices = uniq_vertices; <span class="comment">% Prepare data <span class="keyword">for</span> '</span>patch<span class="string">' <span class="keyword">function</span></span>
patch_data.Faces = uniq_faces;
patch_data.FaceVertexCData = vertex_stressT_magnitude;
patch_data.FaceColor = '</span>interp<span class="string">';
patch_data.EdgeColor = '</span>none<span class="string">';
<span class="comment">% Calculate vertex normals <span class="keyword">for</span> smooth shading</span>
patch_data.VertexNormals = -vertexNormal(triangulation(uniq_faces, uniq_vertices));
<span class="comment">% Create the surface plot</span>
p = patch(patch_data);
<span class="comment">% Set view and lighting</span>
axis equal;
view(3); camlight('</span>headlight<span class="string">'); camlight('</span>left<span class="string">'); lighting phong; colorbar;
xlabel('</span>X<span class="string">'); ylabel('</span>Y<span class="string">'); zlabel('</span>Z<span class="string">');
title('</span>Tangential Landshoff Stress Magnitude onto Solid Surface');
<span class="comment">% Option to remove grid <span class="keyword">for</span> a cleaner look</span>
<span class="comment">% grid off;</span>
</code></pre></div>
</div>
<div id='example2bis' class='doc-content' style='display: none;'>
<h1>Workshop Main File - Part 2bis</h1>
<p>This script discusses advanced shear details beyond those shown in Part2<br/>Only advanced features are kept</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">%% Workshop Main File - Part 2bis</span>
<span class="comment">% This script discusses advanced shear details beyond those shown in Part2</span>
<span class="comment">% Only advanced features are kept</span>

<span class="comment">% File Structure (change your local path to reflect the content)</span>
<span class="comment">% ├── example2bis.m</span>
<span class="comment">% └── ...</span>
<span class="comment">% └── data folder (dumps/pub1/)</span>

<span class="comment">%INRAE\Olivier Vitrac, Han Chen 2023-09-07</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-09-09 major increment</span>
<span class="comment">% 2023-09-10 finalization and copy to notebook/</span>
<span class="comment">% 2023-09-13 update <span class="keyword">for</span> new Landshoff and Hertz virial calculations (fixes)</span>
<span class="comment">% 2023-09-20 add vorticity</span>

<span class="comment">%% Definitions</span>
<span class="comment">% We assume that the dump file has been preprocessed (see example1.m and example2.m)</span>
statvec = @(f,before,after) dispf(<span class="string">'<span class="comment">%s: %s%d values | average = %0.5g %s'</span>, before, ...</span>
    cell2mat(cellfun(@(x) sprintf(<span class="string">' <span class="comment">%0.1f%%> %10.4g | '</span>, x, prctile(f, x)), {2.5, 25, 50, 75, 97.5}, <span class="string">'UniformOutput'</span>, false)), ...</span>
    length(f), mean(f),after); <span class="comment">% user <span class="keyword">function</span> to display statistics on vectors (usage:  statvec(f,<span class="string">'myvar'</span>,<span class="string">'ok'</span>))</span>
coords = {<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>};
vcoords = cellfun(@(c) [<span class="string">'v'</span>,c],coords,<span class="string">'UniformOutput'</span>,false); <span class="comment">% vx, vy, vz</span>
<span class="comment">% dump file and its parameterization</span>
datafolder = <span class="string">'./dumps/pub1/'</span>;
dumpfile = <span class="string">'dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle'</span>;
datafolder = lamdumpread2(fullfile(datafolder,dumpfile),<span class="string">'search'</span>); <span class="comment">% fix datafolder based on initial guess</span>
X0 = lamdumpread2(fullfile(datafolder,dumpfile)); <span class="comment">% default frame</span>
boxdims = X0.BOX(:,2) - X0.BOX(:,1);              <span class="comment">% box dims</span>
natoms = X0.NUMBER;                               <span class="comment">% number of atoms</span>
timesteps = X0.TIMESTEPS;                         <span class="comment">% time steps</span>
ntimesteps = length(timesteps);                   <span class="comment">% number of time steps</span>
T = X0.ATOMS.type;                                <span class="comment">% atom types</span>
<span class="comment">% === IDENTIFICATION OF ATOMS ===</span>
atomtypes = unique(T);                            <span class="comment">% list of atom types</span>
natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
[~,fluidtype] = max(natomspertype); <span class="comment">% fluid type</span>
[~,solidtype] = min(natomspertype); <span class="comment">% solid type</span>
walltypes = setdiff(atomtypes,[fluidtype,solidtype]); <span class="comment">% wall types</span>
nfluidatoms = natomspertype(fluidtype);
nsolidatoms = natomspertype(solidtype);
<span class="comment">% === FLOW DIRECTION ===</span>
[~,iflow] = max(boxdims);
iothers = setdiff(1:size(X0.BOX,1),iflow);
<span class="comment">% === GUESS BEAD SIZE ===</span>
<span class="comment">% not needed anymore since the mass, vol and rho are taken from the dump file</span>
Vbead_guess = prod(boxdims)/natoms;
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
[verletList,cutoff,dmin,config,dist] = buildVerletList(X0.ATOMS(T==fluidtype,coords),cutoff);
rbead = dmin/2;  <span class="comment">% based on separation distance</span>

<span class="comment">%% Frame and Corresponding ROI <span class="keyword">for</span> Stress Analysis</span>
list_timestepforstess = unique(timesteps(ceil((0.1:0.1:0.9)*ntimesteps)));
timestepforstress = list_timestepforstess(<span class="keyword">end</span>);
<span class="comment">% stress frame</span>
Xstress = lamdumpread2(fullfile(datafolder,dumpfile),<span class="string">'usesplit'</span>,[],timestepforstress); <span class="comment">% middle frame</span>
Xstress.ATOMS.isfluid = Xstress.ATOMS.type==fluidtype;
Xstress.ATOMS.issolid = Xstress.ATOMS.type==solidtype;
Xstress.ATOMS.iswall  = ismember(Xstress.ATOMS.type,walltypes);
<span class="comment">% == control (not used) ==</span>
<span class="comment">% average bead volume and bead radius (control, min separation distance was used in the previous section)</span>
fluidbox = [min(Xstress.ATOMS{Xstress.ATOMS.isfluid,coords});max(Xstress.ATOMS{Xstress.ATOMS.isfluid,coords})]<span class="string">';
vbead_est = prod(diff(fluidbox,1,2))/(length(find(Xstress.ATOMS.isfluid))+length(Xstress.ATOMS.issolid));
rbead_est = (3*vbead_est/(4*pi))^(1/3);
mbead_est = vbead_est*1000;
<span class="comment">% Verlet List Construction with Short Cutoff</span>
<span class="comment">% Builds a Verlet list with a short cutoff distance, designed to identify only the closest neighbors.</span>
[verletList,cutoff,dmin,config,dist] = buildVerletList(Xstress.ATOMS,3*rbead);
<span class="comment">% Partition Verlet List Based on Atom Types</span>
<span class="comment">% This Verlet list is partitioned based on atom types, distinguishing between interactions</span>
<span class="comment">% that are exclusively fluid-fluid, solid-fluid, or solid-solid.</span>
verletListCross = partitionVerletList(verletList,Xstress.ATOMS);
<span class="comment">% Identify Contacting Atoms</span>
Xstress.ATOMS.isincontact = ~cellfun(@isempty,verletListCross);
Xstress.ATOMS.contacttypes = cellfun(@(v) Xstress.ATOMS.type(v)'</span>,verletListCross,<span class="string">'UniformOutput'</span>,false);
<span class="comment">% Identify Atoms in Contact with Solids and Fluids</span>
Xstress.ATOMS.isincontactwithsolid = cellfun(@(c) ismember(solidtype,c), Xstress.ATOMS.contacttypes);
Xstress.ATOMS.isincontactwithfluid = cellfun(@(c) ismember(fluidtype,c), Xstress.ATOMS.contacttypes);
Xstress.ATOMS.isincontactwithwalls = cellfun(@(c) ~isempty(intersect(walltypes,c)), Xstress.ATOMS.contacttypes);
<span class="comment">% Flag Fluid Atoms in Contact with Solid and Vice Versa</span>
Xstress.ATOMS.fluidincontactwithsolid = Xstress.ATOMS.isfluid & Xstress.ATOMS.isincontactwithsolid;
Xstress.ATOMS.solidincontactwithfluid = Xstress.ATOMS.issolid & Xstress.ATOMS.isincontactwithfluid;
Xstress.ATOMS.fluidincontactwithwalls = Xstress.ATOMS.isfluid & Xstress.ATOMS.isincontactwithwalls;
Xstress.ATOMS.wallsincontactwithfluid = Xstress.ATOMS.iswall & Xstress.ATOMS.isincontactwithfluid;
<span class="comment">% Identify Indices <span class="keyword">for</span> Analysis</span>
ROI = [
    min(Xstress.ATOMS{Xstress.ATOMS.fluidincontactwithsolid,coords})
    max(Xstress.ATOMS{Xstress.ATOMS.fluidincontactwithsolid,coords})
    ]<span class="string">';
ROI(iflow,:) = mean(ROI(iflow,:)) + [-1 1] * diff(ROI(iflow,:));
<span class="keyword">for</span> j = iothers
    ROI(j,:) = Xstress.BOX(j,:) ;
<span class="keyword">end</span>
inROI = true(size(Xstress,1),1);
<span class="keyword">for</span> c=1:length(coords)
    inROI = inROI & (Xstress.ATOMS{:,coords{c}}>=ROI(c,1)) & (Xstress.ATOMS{:,coords{c}}<=ROI(c,2));
<span class="keyword">end</span>
ifluid = find(inROI & (Xstress.ATOMS.isfluid));
isolid = find(inROI & (Xstress.ATOMS.issolid));
iwall = find(inROI & (Xstress.ATOMS.iswall));
isolidcontact = find(Xstress.ATOMS.solidincontactwithfluid);
iwallcontact = find(inROI & Xstress.ATOMS.wallsincontactwithfluid);
<span class="comment">% control</span>
figure, hold on
plot3D(Xstress.ATOMS{ifluid,coords},'</span>bo<span class="string">','</span>markersize<span class="string">',3,'</span>markerfacecolor<span class="string">','</span>b<span class="string">')
plot3D(Xstress.ATOMS{iwallcontact,coords},'</span>ko<span class="string">','</span>markersize<span class="string">',12,'</span>markerfacecolor<span class="string">','</span>k<span class="string">')
plot3D(Xstress.ATOMS{isolidcontact,coords},'</span>ro<span class="string">','</span>markersize<span class="string">',16,'</span>markerfacecolor<span class="string">','</span>r<span class="string">')
axis equal, view(3), drawnow

<span class="comment">% triangulation of the solid</span>
DT = delaunayTriangulation(double(Xstress.ATOMS{isolidcontact,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}}));
K = convexHull(DT);
plotsolid = @()trisurf(K, DT.Points(:,1), DT.Points(:,2), DT.Points(:,3), '</span>FaceColor<span class="string">', '</span>w<span class="string">','</span>Edgecolor<span class="string">','</span>k<span class="string">','</span>FaceAlpha<span class="string">',0.6);

<span class="comment">%% Landshoff forces and stresses in the fluid</span>
<span class="comment">% these forces are the viscous forces in the fluid</span>
<span class="comment">% we calculate:</span>
<span class="comment">%   Flandshoff(i,:) the local Landshoff force (1x3 vector) <span class="keyword">for</span> the atom i</span>
<span class="comment">%   Wlandshoff(i,:) is the local virial stress tensor (3x3 matrix stored as 1x9 vector with Matlab conventions)</span>
<span class="comment">%       row-wise: force component index</span>
<span class="comment">%       columm-wise: coord component index</span>
<span class="comment">%   The virial tensor reads:</span>
<span class="comment">%        \[</span>
<span class="comment">%        \sigma =</span>
<span class="comment">%        \begin{pmatrix}</span>
<span class="comment">%        \sigma_{11} & \sigma_{12} & \sigma_{13} \\</span>
<span class="comment">%        \sigma_{21} & \sigma_{22} & \sigma_{23} \\</span>
<span class="comment">%        \sigma_{31} & \sigma_{32} & \sigma_{33}</span>
<span class="comment">%        \<span class="keyword">end</span>{pmatrix}</span>
<span class="comment">%        \]</span>
<span class="comment">%</span>
<span class="comment">%   The viscous tensor component is associated to the flow (x)</span>
<span class="comment">%      $ \tau_{xy} = \mu \left( \frac{\partial u}{\partial y} \right) $</span>
<span class="comment">%   it is derived from the virial stress tensor:</span>
<span class="comment">%       $ \sigma_{\alpha\beta} = \frac{1}{V} \sum_{i<j} r_{ij,\alpha} f_{ij,\beta} $</span>
<span class="comment">%   where  $ V $ is the volume, $ r_{ij,\alpha} $ is the $ \alpha $-component of the distance vector between particles $ i $ and $ j $, and $ f_{ij,\beta} $ is the $ \beta $-component of the force between particles $ i $ and $ j $.</span>
<span class="comment">%</span>
<span class="comment">% For this specific problem, the most relevant components would be those relating to shear and normal forces, specifically $ \sigma_{xy} $ and $ \sigma_{yy} $. </span>
<span class="comment">% 1. $ \sigma_{xy} $ corresponds to the shear effects and should be closely related to the SPH-based shear stress $ \tau_{xy} $ in the fluid. This component would be a primary point of comparison.% </span>
<span class="comment">% 2. $ \sigma_{yy} $ will capture the effects of the Hertzian contacts along the $ y $-direction (i.e., the direction opposite to which the wall is moving). In your Hertz contact model, the normal force is acting along the $ y $-direction, which contributes to this component.</span>
<span class="comment">% </span>
<span class="comment">% Therefore, based on the equality of mechanical states between the fluid and the wall, we should expect:</span>
<span class="comment">% $\sigma_{xy}^{\text{SPH}} = \sigma_{xy}^{\text{Hertz}}$  (shear)</span>
<span class="comment">% $\sigma_{yy}^{\text{SPH}} = \sigma_{yy}^{\text{Hertz}}$  (normal)</span>
<span class="comment">% which reads (first index: direction, second index: vcomponent)</span>
<span class="comment">% $ \sigma_{21}^{\text{SPH}} = \sigma_{21}^{\text{Hertz}} $</span>
<span class="comment">% $ \sigma_{22}^{\text{SPH}} = \sigma_{22}^{\text{Hertz}} $</span>

<span class="comment">% === Build the Verlet list consistently with the local Virial Stress Tensor ===</span>
<span class="comment">% Changing h can affect the value of viscosity <span class="keyword">for</span> Landshoff foces and shear stress.</span>
<span class="comment">% While keeping the same hLandshoff, the results can be rescaled to the value of h</span>
<span class="comment">% applied in the simulations.</span>
Xfluid  = Xstress.ATOMS(ifluid,:);
hLandshoff = 4*rbead; <span class="comment">%1.25e-5; % m</span>
Vfluid = buildVerletList(Xfluid,hLandshoff);
configLandshoff = struct( ...
    '</span>gradkernel<span class="string">', kernelSPH(hLandshoff,'</span>lucyder<span class="string">',3),...kernel gradient
    '</span>h<span class="string">', hLandshoff,...smoothing length (m)
    '</span>c0<span class="string">',0.32,...speed of the sound (m/s)
    '</span>q1<span class="string">',30 ... viscosity coefficient (-)
    );
rhofluid = mean(Xfluid.c_rho_smd);
mbead = mean(Xfluid.mass);
Vbead = mean(Xfluid.c_vol);
mu = rhofluid*configLandshoff.q1*configLandshoff.c0*configLandshoff.h/10; <span class="comment">% viscosity estimate</span>
dispf('</span>Atificial viscosity: <span class="comment">%0.4g Pa.s<span class="string">',mu)</span>

<span class="comment">% Landshoff forces and local virial stress</span>
[Flandshoff,Wlandshoff] = forceLandshoff(Xfluid,[],Vfluid,configLandshoff);
flandshoff = sqrt(sum(Flandshoff.^2,2));
statvec(flandshoff,'</span> Force Landshoff<span class="string">',sprintf('</span><-- TIMESTEP: <span class="comment">%d<span class="string">',timestepforstress))</span>
statvec(Wlandshoff(:,2),'</span>Virial Landshoff<span class="string">',sprintf('</span><-- TIMESTEP: <span class="comment">%d<span class="string">',timestepforstress))</span>

<span class="comment">% number of grid points along the largest dimension</span>
fluidbox = [ min(Xfluid{:,coords}); max(Xfluid{:,coords}) ]'</span>;
boxcenter = mean(fluidbox,2);
resolution = ceil(50 * diff(fluidbox,[],2)<span class="string">'./max(diff(fluidbox,[],2)));
xw = linspace(fluidbox(1,1),fluidbox(1,2),resolution(1));
yw = linspace(fluidbox(2,1),fluidbox(2,2),resolution(2));
zw = linspace(fluidbox(3,1),fluidbox(3,2),resolution(3));
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];
hLandshoff = 5*rbead; <span class="comment">%1.25e-5; % m</span>

<span class="comment">% Build the Grid Verlet list</span>
VXYZ = buildVerletList({XYZgrid Xfluid{:,coords}},1.001*hLandshoff); <span class="comment">% special grid syntax</span>
<span class="comment">% Interpolate Landshoff forces, extract components <span class="keyword">for</span> plotting</span>
W = kernelSPH(hLandshoff,'</span>lucy<span class="string">',3); <span class="comment">% kernel <span class="keyword">for</span> interpolation (not gradkernel!)</span>
FXYZgrid = interp3SPHVerlet(Xfluid{:,coords},Flandshoff,XYZgrid,VXYZ,W,Vbead);
FXYZgridx = reshape(FXYZgrid(:,1),size(Xw));
FXYZgridy = reshape(FXYZgrid(:,2),size(Yw));
FXYZgridz = reshape(FXYZgrid(:,3),size(Zw));
<span class="comment">% Interpolate local virial stress tensor, extract s12 which is stored as s(2,1)</span>
WXYZgrid = interp3SPHVerlet(Xfluid{:,coords},Wlandshoff,XYZgrid,VXYZ,W,Vbead);
s12grid = reshape(WXYZgrid(:,2),size(Xw)); <span class="comment">% extract \sigma_{xy} i.e. forces along x across y</span>
<span class="comment">% Alternative estimation of the virial from the Cauchy stress tensor</span>
WXYZgrid2 = interp3cauchy(Xw,Yw,Zw,FXYZgridx,FXYZgridy,FXYZgridz);
s12grid2 = reshape(WXYZgrid2(:,:,:,2),size(Xw));
<span class="comment">% Interpolate the velocities, extract components <span class="keyword">for</span> plotting</span>
vXYZgrid = interp3SPHVerlet(Xfluid{:,coords},Xfluid{:,vcoords},XYZgrid,VXYZ,W,Vbead);
vXYZgridx = reshape(vXYZgrid(:,1),size(Xw));
vXYZgridy = reshape(vXYZgrid(:,2),size(Yw));
vXYZgridz = reshape(vXYZgrid(:,3),size(Zw));
vdXYZgridxdy = gradient(vXYZgridx,xw(2)-xw(1),yw(2)-yw(1),zw(2)-zw(1));
s12grid_est = mu * vdXYZgridxdy;

<span class="comment">% === Plot Estimated shear stress (it should be the theoretical value)</span>
figure, hold on
hs = slice(Xw,Yw,Zw,s12grid_est,[boxcenter(1) xw(<span class="keyword">end</span>)],...
    [boxcenter(2) yw(<span class="keyword">end</span>)],...
    [fluidbox(3,1) boxcenter(3)]);
set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha<span class="string">',0.6)
plotsolid()
lighting gouraud, camlight('</span>left<span class="string">'), axis equal, view(3) <span class="comment">% shading interp</span>
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14); hc.Label.String = '</span>\sigma_{XY}<span class="string">';
title('</span>Stress from velocity field: \sigma_{XY}=\eta\cdot\partial v_x/\partial y<span class="string">','</span>fontsize<span class="string">',20)
xlabel('</span>X<span class="string">'), ylabel('</span>Y<span class="string">'), zlabel('</span>Z<span class="string">')
step = [3 10 5];
quiver3( ...
    Xw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Yw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Zw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    vXYZgridx(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    vXYZgridy(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    vXYZgridz(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>) ...
    ,1,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',2)
npart = 30;
[startX,startY,startZ] = meshgrid( ...
    double(xw(1)), ...
    double(yw(unique(round(1+(1+(linspace(-1,1,npart).*linspace(-1,1,npart).^2))*floor(length(yw)/2))))),...
    double(yw(unique(round(1+(1+(linspace(-1,1,npart).*linspace(-1,1,npart).^2))*floor(length(yw)/2))))) ...
  );
vstart = interp3(Xw,Yw,Zw,vXYZgridx,startX,startY,startZ); startX(vstart<0) = double(xw(<span class="keyword">end</span>));
hsl = streamline(double(Xw),double(Yw),double(Zw),vXYZgridx,vXYZgridy,vXYZgridz,startX,startY,startZ);
set(hsl,'</span>linewidth<span class="string">',2,'</span>color<span class="string">',[0.4375    0.5000    0.5625])
plot3(startX(:),startY(:),startZ(:),'</span>ro<span class="string">','</span>markerfacecolor<span class="string">',[0.4375    0.5000    0.5625])
<span class="comment">% fix the view</span>
view(-90,90), clim([-1e-1 1e-1])

<span class="comment">% === Plot the vorticity</span>
<span class="comment">% Calculate the gradients of the velocity components</span>
[dvxdx, dvxdy, dvxdz] = gradient(vXYZgridx,xw(2)-xw(1),yw(2)-yw(1),zw(2)-zw(1));
[dvydx, dvydy, dvydz] = gradient(vXYZgridy,xw(2)-xw(1),yw(2)-yw(1),zw(2)-zw(1));
[dvzdx, dvzdy, dvzdz] = gradient(vXYZgridz,xw(2)-xw(1),yw(2)-yw(1),zw(2)-zw(1));
<span class="comment">% Calculate vorticity components</span>
w_x = dvzdy - dvydz;
w_y = dvxdz - dvzdx;
w_z = dvydx - dvxdy;
w_mag = sqrt(w_x.^2+w_y.^2+w_z.^2);
<span class="comment">% Plot the vorticity</span>
[stepx,stepy,stepz] = deal(3,3,3);
[plotsx,plotsy,plotsz] = deal(stepx*(xw(2)-xw(1)),stepy*(yw(2)-yw(1)),stepz*(zw(2)-zw(1)));
figure, hold on
hs = slice(Xw,Yw,Zw,w_mag,[boxcenter(1) xw(<span class="keyword">end</span>)-plotsx],...
    [boxcenter(2) yw(<span class="keyword">end</span>)-plotsy],...
    [fluidbox(3,1)+plotsz boxcenter(3)]);
set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha<span class="string">',0.6)
quiver3( ...
    Xw(stepy:stepy:<span class="keyword">end</span>-stepy,stepx:stepx:<span class="keyword">end</span>-stepy,stepz:stepz:<span class="keyword">end</span>-stepz),...
    Yw(stepy:stepy:<span class="keyword">end</span>-stepy,stepx:stepx:<span class="keyword">end</span>-stepy,stepz:stepz:<span class="keyword">end</span>-stepz),...
    Zw(stepy:stepy:<span class="keyword">end</span>-stepy,stepx:stepx:<span class="keyword">end</span>-stepy,stepz:stepz:<span class="keyword">end</span>-stepz),...
    w_x(stepy:stepy:<span class="keyword">end</span>-stepy,stepx:stepx:<span class="keyword">end</span>-stepy,stepz:stepz:<span class="keyword">end</span>-stepz),...
    w_y(stepy:stepy:<span class="keyword">end</span>-stepy,stepx:stepx:<span class="keyword">end</span>-stepy,stepz:stepz:<span class="keyword">end</span>-stepz),...
    w_z(stepy:stepy:<span class="keyword">end</span>-stepy,stepx:stepx:<span class="keyword">end</span>-stepy,stepz:stepz:<span class="keyword">end</span>-stepz),...
    1,'</span>color<span class="string">','</span>r<span class="string">','</span>LineWidth<span class="string">',2);
title('</span>Vorticity Field<span class="string">','</span>fontsize<span class="string">',20)
xlabel('</span>X<span class="string">'), ylabel('</span>Y<span class="string">'), zlabel('</span>Z<span class="string">')
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14);
hc.Label.String = '</span>Vorticity Magnitude<span class="string">';
lighting gouraud; camlight('</span>left<span class="string">');  axis equal;  view(-112,82); clim([0 20])


<span class="comment">% === Plot Estimated shear stress from Cauchy Tensor</span>
figure, hold on
s1299 = prctile(abs(s12grid2(~isnan(s12grid2))),99);
isosurface(Xw,Yw,Zw,s12grid2,s1299)
isosurface(Xw,Yw,Zw,s12grid2,-s1299)
hs = slice(Xw,Yw,Zw,s12grid2,[boxcenter(1) xw(<span class="keyword">end</span>)],...
    [boxcenter(2) yw(<span class="keyword">end</span>)],...
    [fluidbox(3,1) boxcenter(3)]);
set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha<span class="string">',0.6)
plotsolid()
lighting gouraud, camlight('</span>left<span class="string">'), axis equal, view(3) <span class="comment">% shading interp</span>
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14); hc.Label.String = '</span>\sigma_{XY}<span class="string">';
title('</span>Local Cauchy stress: \sigma_{XY}<span class="string">','</span>fontsize<span class="string">',20)
xlabel('</span>X<span class="string">'), ylabel('</span>Y<span class="string">'), zlabel('</span>Z<span class="string">')
npart = 20;
[startX,startY,startZ] = meshgrid( ...
    double(xw(1)), ...
    double(yw(unique(round(1+(1+(linspace(-1,1,npart).*linspace(-1,1,npart).^2))*floor(length(yw)/2))))),...
    double(yw(unique(round(1+(1+(linspace(-1,1,npart).*linspace(-1,1,npart).^2))*floor(length(yw)/2))))) ...
  );
vstart = interp3(Xw,Yw,Zw,vXYZgridx,startX,startY,startZ); startX(vstart<0) = double(xw(<span class="keyword">end</span>));
hsl = streamline(double(Xw),double(Yw),double(Zw),vXYZgridx,vXYZgridy,vXYZgridz,startX,startY,startZ);
set(hsl,'</span>linewidth<span class="string">',2,'</span>color<span class="string">','</span>k<span class="string">')
plot3(startX(:),startY(:),startZ(:),'</span>ro<span class="string">','</span>markerfacecolor<span class="string">',[0.4375    0.5000    0.5625])


<span class="comment">% === Plot local virial stess: s12 (s12 is stored as s(2,1))</span>
figure, hold on
s1299 = prctile(abs(s12grid(~isnan(s12grid))),99);
isosurface(Xw,Yw,Zw,s12grid,s1299)
isosurface(Xw,Yw,Zw,s12grid,-s1299)
hs = slice(Xw,Yw,Zw,s12grid,[boxcenter(1) xw(<span class="keyword">end</span>)],...
    [boxcenter(2) yw(<span class="keyword">end</span>)],...
    [fluidbox(3,1) boxcenter(3)]);
set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha<span class="string">',0.6)
plotsolid()
lighting gouraud, camlight('</span>left<span class="string">'), axis equal, view(3) <span class="comment">% shading interp</span>
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14); hc.Label.String = '</span>\sigma_{XY}<span class="string">';
title('</span>Local virial stress: \sigma_{XY}<span class="string">','</span>fontsize<span class="string">',20)
xlabel('</span>X<span class="string">'), ylabel('</span>Y<span class="string">'), zlabel('</span>Z<span class="string">')
npart = 20;
[startX,startY,startZ] = meshgrid( ...
    double(xw(1)), ...
    double(yw(unique(round(1+(1+(linspace(-1,1,npart).*linspace(-1,1,npart).^2))*floor(length(yw)/2))))),...
    double(yw(unique(round(1+(1+(linspace(-1,1,npart).*linspace(-1,1,npart).^2))*floor(length(yw)/2))))) ...
  );
vstart = interp3(Xw,Yw,Zw,vXYZgridx,startX,startY,startZ); startX(vstart<0) = double(xw(<span class="keyword">end</span>));
hsl = streamline(double(Xw),double(Yw),double(Zw),vXYZgridx,vXYZgridy,vXYZgridz,startX,startY,startZ);
set(hsl,'</span>linewidth<span class="string">',2,'</span>color<span class="string">','</span>k<span class="string">')
plot3(startX(:),startY(:),startZ(:),'</span>ro<span class="string">','</span>markerfacecolor<span class="string">',[0.4375    0.5000    0.5625])


<span class="comment">% === PLot Landshoff forces only </span>
figure, hold on
hs = slice(Xw,Yw,Zw,FXYZgridx,[xw(1) boxcenter(1)],...
    [yw(2) boxcenter(2) yw(<span class="keyword">end</span>)],...
    [fluidbox(3,1) boxcenter(3)]);
set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha<span class="string">',0.9)
axis equal, view(3),
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14); hc.Label.String = '</span>Landshoff along X<span class="string">';
xlabel('</span>X<span class="string">'), ylabel('</span>Y<span class="string">'), zlabel('</span>Z<span class="string">')
title('</span>Landshoff forces along X<span class="string">','</span>fontsize<span class="string">',20)
step = [3 5 5];
quiver3( ...
    Xw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Yw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Zw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridx(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridy(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridz(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>) ...
    ,1,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',2)


<span class="comment">%% Hertz contact solid-fluid</span>
<span class="comment">% ===========================</span>
XFluidSolid = Xstress.ATOMS(union(ifluid,isolid),:);
figure, hold on
plot3D(XFluidSolid{XFluidSolid.isfluid,coords},'</span>bo<span class="string">','</span>markersize<span class="string">',3,'</span>markerfacecolor<span class="string">','</span>b<span class="string">')
plot3D(XFluidSolid{XFluidSolid.issolid,coords},'</span>ro<span class="string">','</span>markersize<span class="string">',16,'</span>markerfacecolor<span class="string">','</span>r<span class="string">')
Rfluid = 1.04e-5; <span class="comment">% m</span>
Rsolid = 1.56e-5; <span class="comment">% m</span>
Rfluid = Rsolid;
hhertz = 2*Rsolid;
[Vcontactsolid,~,dmincontact] = buildVerletList(XFluidSolid,hhertz,[],[],[],XFluidSolid.isfluid,XFluidSolid.issolid);
configHertz = struct('</span>R<span class="string">',{Rsolid Rfluid},'</span>E<span class="string">',2000);
[FHertzSolid,WHertzSolid] = forceHertz(XFluidSolid,Vcontactsolid,configHertz);
fhertz = sqrt(sum(FHertzSolid.^2,2));
statvec(fhertz(fhertz>0),'</span>Hertz<span class="string">',sprintf('</span><-- TIMESTEP: <span class="comment">%d\n\tsubjected to Rsolid=[%0.4g %0.4g] dmin/2=%0.4g<span class="string">',timestepforstress,configHertz(1).R,configHertz(2).R,dmincontact/2))</span>

<span class="comment">% project Hertz contact on accurate grid (Cartesian)</span>
soliddbox = [ min(Xstress.ATOMS{isolid,coords})-4*rbead
              max(Xstress.ATOMS{isolid,coords})+4*rbead ]'</span>;
boxcenter = mean(soliddbox,2);
resolution = ceil(50 * diff(soliddbox,[],2)<span class="string">'./max(diff(soliddbox,[],2)));
xw = linspace(soliddbox(1,1),soliddbox(1,2),resolution(1));
yw = linspace(soliddbox(2,1),soliddbox(2,2),resolution(2));
zw = linspace(soliddbox(3,1),soliddbox(3,2),resolution(3));
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];
VXYZ = buildVerletList({XYZgrid XFluidSolid{:,coords}},1.1*hhertz);
W = kernelSPH(hhertz,'</span>lucy<span class="string">',3); <span class="comment">% kernel <span class="keyword">for</span> interpolation (not gradkernel!)</span>
FXYZgrid = interp3SPHVerlet(XFluidSolid{:,coords},FHertzSolid,XYZgrid,VXYZ,W,Vbead);
FXYZgridx = reshape(FXYZgrid(:,1),size(Xw));
FXYZgridy = reshape(FXYZgrid(:,2),size(Yw));
FXYZgridz = reshape(FXYZgrid(:,3),size(Zw));
WXYZgrid2 = interp3cauchy(Xw,Yw,Zw,FXYZgridx,FXYZgridy,FXYZgridz);
s12grid2 = reshape(WXYZgrid2(:,:,:,2),size(Xw));

<span class="comment">%% Rough plot of Hertz Contact Tensor (component xy) - SOLID-FLUID</span>
figure, hold on
hs = slice(Xw,Yw,Zw,s12grid2, ...
    boxcenter(1),...
    boxcenter(2),...
    boxcenter(3));
set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha<span class="string">',0.9)
axis equal, view(3),
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14); hc.Label.String = '</span>Hertz Tensor xy<span class="string">';
xlabel('</span>X<span class="string">'), ylabel('</span>Y<span class="string">'), zlabel('</span>Z<span class="string">')
title('</span>Hertz tensor<span class="string">','</span>fontsize<span class="string">',20)
step = [2 2 2];
quiver3( ...
    Xw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Yw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Zw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridx(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridy(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridz(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>) ...
    ,1.5,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',2)


<span class="comment">%% Advanced plot <span class="keyword">for</span> Hertz Contacts</span>
<span class="comment">% almost same code as example2: </span>

<span class="comment">% === STEP 1/5 === Original Delaunay triangulation and the convex hull</span>
<span class="comment">% this step has been already done as the begining of example2bis.m</span>
<span class="comment">% DT = delaunayTriangulation(double(Xstress.ATOMS{isolidcontact, coords}));</span>
<span class="comment">% K = convexHull(DT);</span>
<span class="comment">% === STEP 2/5 === refine the initial mesh by adding midpoints</span>
<span class="comment">% Extract the convex hull points and faces</span>
hullPoints = DT.Points;
hullFaces = DT.ConnectivityList(K, :);
<span class="comment">% Initialize a set to keep track of midpoints to ensure they are unique</span>
midpointSet = zeros(0, 3);
<span class="comment">% Calculate midpoints <span class="keyword">for</span> each edge in each triangle and add to the point list</span>
<span class="keyword">for</span> faceIdx = 1:size(hullFaces, 1)
    face = hullFaces(faceIdx, :);
    <span class="keyword">for</span> i = 1:3
        <span class="keyword">for</span> j = i+1:3
            midpoint = (hullPoints(face(i), :) + hullPoints(face(j), :)) / 2;        
            <span class="keyword">if</span> isempty(midpointSet) || ~ismember(midpoint, midpointSet, '</span>rows<span class="string">')
                midpointSet = [midpointSet; midpoint]; <span class="comment">%#ok<AGROW></span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Merge the original points and the new midpoints, update the the Delaunay triangulation</span>
newDT = delaunayTriangulation([hullPoints; midpointSet]);
newK = convexHull(newDT);
<span class="comment">% === STEP 3/5 ===  Laplacian Smoothing</span>
points = newDT.Points;         <span class="comment">% === Extract points and faces</span>
faces = newDT.ConnectivityList(newK, :);
n = size(points, 1);           <span class="comment">% === Initialize new points</span>
newPoints = zeros(size(points)); 
neighbors = cell(n, 1);        <span class="comment">% List of neighbors</span>
<span class="keyword">for</span> faceIdx = 1:size(faces, 1) <span class="comment">% === Find the neighbors of each vertex</span>
    face = faces(faceIdx, :);
    <span class="keyword">for</span> i = 1:3
        vertex = face(i);
        vertex_neighbors = face(face ~= vertex);
        neighbors{vertex} = unique([neighbors{vertex}; vertex_neighbors(:)]);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">for</span> i = 1:n                   <span class="comment">% === Laplacian smoothing</span>
    neighbor_indices = neighbors{i};
    <span class="keyword">if</span> isempty(neighbor_indices) <span class="comment">% Keep the point as is <span class="keyword">if</span> it has no neighbors</span>
        newPoints(i, :) = points(i, :); 
    <span class="keyword">else</span> <span class="comment">% Move the point to the centroid of its neighbors</span>
        newPoints(i, :) = mean(points(neighbor_indices, :), 1);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% Update the Delaunay triangulation with the smoothed points</span>
newDT = delaunayTriangulation(newPoints);
newK = convexHull(newDT);
<span class="comment">% === STEP 4/5 === Interpolate the Hertz forces on the triangular mesh</span>
XYZhtri = newDT.Points;
XYZh = XFluidSolid{:,coords}; <span class="comment">% kernel centers</span>
VXYZh = buildVerletList({XYZhtri XFluidSolid{:,coords}},1.1*hhertz); <span class="comment">% special grid syntax</span>
W = kernelSPH(hhertz,'</span>lucy<span class="string">',3); <span class="comment">% kernel expression</span>
FXYZtri = interp3SPHVerlet(XFluidSolid{:,coords},FHertzSolid,XYZhtri,VXYZh,W,Vbead);
<span class="comment">% === STEP 5/5 === Extract tagential forces</span>
<span class="comment">% Calculate face normals and centroids</span>
points = newDT.Points;
faces = newK;
v1 = points(faces(:, 1), :) - points(faces(:, 2), :);
v2 = points(faces(:, 1), :) - points(faces(:, 3), :);
faceNormals = cross(v1, v2, 2);
faceNormals = faceNormals ./ sqrt(sum(faceNormals.^2, 2));
centroids = mean(reshape(points(faces, :), size(faces, 1), 3, 3), 3);
<span class="comment">% Interpolate force at each centroid using scatteredInterpolant <span class="keyword">for</span> each component</span>
FInterp_x = scatteredInterpolant(XYZhtri, double(FXYZtri(:,1)), '</span>linear<span class="string">', '</span>nearest<span class="string">');
FInterp_y = scatteredInterpolant(XYZhtri, double(FXYZtri(:,2)), '</span>linear<span class="string">', '</span>nearest<span class="string">');
FInterp_z = scatteredInterpolant(XYZhtri, double(FXYZtri(:,3)), '</span>linear<span class="string">', '</span>nearest<span class="string">');
FXYZtri_at_centroids = [FInterp_x(centroids), FInterp_y(centroids), FInterp_z(centroids)];
<span class="comment">% Calculate normal and tangential components of the force at each face centroid</span>
normalComponent = dot(FXYZtri_at_centroids, faceNormals, 2);
normalForce = repmat(normalComponent, 1, 3) .* faceNormals;
tangentialForce = FXYZtri_at_centroids - normalForce;
tangentialMagnitude = sqrt(sum(tangentialForce.^2, 2));
<span class="comment">% Do the figure</span>
figure, hold on
trisurfHandle = trisurf(newK, newDT.Points(:, 1), newDT.Points(:, 2), newDT.Points(:, 3), '</span>Edgecolor<span class="string">', '</span>k<span class="string">', '</span>FaceAlpha<span class="string">', 0.6);
set(trisurfHandle, '</span>FaceVertexCData<span class="string">', tangentialMagnitude, '</span>FaceColor<span class="string">', '</span>flat<span class="string">');
colorbar;
<span class="comment">% Quiver plot to show the forces with an adjusted step</span>
step = [2 2 2]*2;
quiver3( ...
    Xw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Yw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Zw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridx(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridy(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridz(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>) ...
    ,1.5,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',2)
axis equal; view(3), camlight('</span>headlight<span class="string">'); camlight('</span>left<span class="string">'); lighting phong; colorbar;
title('</span>Hertz Forces onto the Tessellated Surface<span class="string">','</span>fontsize<span class="string">',20);
xlabel('</span>X<span class="string">'); ylabel('</span>Y<span class="string">'); zlabel('</span>Z<span class="string">')
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14); 


<span class="comment">%% Hertz contact wall-fluid</span>
<span class="comment">% ==========================</span>
XFluidWall = Xstress.ATOMS(union(ifluid,iwall),:);
figure, hold on
plot3D(XFluidWall{XFluidWall.isfluid,coords},'</span>bo<span class="string">','</span>markersize<span class="string">',3,'</span>markerfacecolor<span class="string">','</span>b<span class="string">')
plot3D(XFluidWall{XFluidWall.iswall,coords},'</span>ko<span class="string">','</span>markersize<span class="string">',16,'</span>markerfacecolor<span class="string">','</span>k<span class="string">')
Rfluid = 1.04e-5; <span class="comment">% m</span>
Rsolid = 1.56e-5; <span class="comment">% m</span>
Rfluid = Rsolid;
hhertz = 2*Rsolid;
[Vcontactwall,~,dmincontact] = buildVerletList(XFluidWall,hhertz,[],[],[],XFluidWall.isfluid,XFluidWall.iswall);
configHertz = struct('</span>R<span class="string">',{Rsolid Rfluid},'</span>E<span class="string">',2000,'</span>rho<span class="string">',1000,'</span>m<span class="string">',9.04e-12,'</span>h<span class="string">',hhertz);
[FHertzWall,WHertzWall] = forceHertz(XFluidWall,Vcontactwall,configHertz);
fhertz = sqrt(sum(FHertzWall.^2,2));
statvec(fhertz(fhertz>0),'</span>Hertz<span class="string">',sprintf('</span><-- TIMESTEP: <span class="comment">%d\n\tsubjected to Rsolid=[%0.4g %0.4g] dmin/2=%0.4g<span class="string">',timestepforstress,configHertz(1).R,configHertz(2).R,dmincontact/2))</span>
figure, stem3(XFluidWall.x,XFluidWall.y,FHertzWall(:,1),'</span>k.<span class="string">')

<span class="comment">% project Hertz contact on accurate grid (Cartesian)</span>
[wallbox1,wallbox2] = deal(fluidbox);
wallbox1(2,1) = fluidbox(2,1) - 1.5*hhertz;
wallbox1(2,2) = fluidbox(2,1) + 1.5*hhertz;
wallbox2(2,1) = fluidbox(2,2) - 1.5*hhertz;
wallbox2(2,2) = fluidbox(2,2) + 1.5*hhertz;
boxcenter = mean(fluidbox,2);
boxcenter1 = mean(wallbox1,2);
boxcenter2 = mean(wallbox2,2);
resolution1 = ceil(120 * diff(wallbox1,[],2)'</span>./max(diff(wallbox1,[],2)));
resolution2 = ceil(120 * diff(wallbox2,[],2)<span class="string">'./max(diff(wallbox2,[],2)));
xw = linspace(wallbox1(1,1),wallbox1(1,2),resolution1(1));
yw1 = linspace(wallbox1(2,1),wallbox1(2,2),resolution1(2));
yw2 = linspace(wallbox2(2,1),wallbox2(2,2),resolution2(2));
zw = linspace(wallbox1(3,1),wallbox1(3,2),resolution1(3));
[Xw,Yw,Zw] = meshgrid(xw,[yw1 boxcenter(2) yw2],zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];
VXYZ = buildVerletList({XYZgrid XFluidWall{:,coords}},1.1*hhertz);
W = kernelSPH(hhertz,'</span>lucy<span class="string">',3); <span class="comment">% kernel <span class="keyword">for</span> interpolation (not gradkernel!)</span>
FXYZgrid = interp3SPHVerlet(XFluidWall{:,coords},FHertzWall,XYZgrid,VXYZ,W,Vbead);
FXYZgridx = reshape(FXYZgrid(:,1),size(Xw));
FXYZgridy = reshape(FXYZgrid(:,2),size(Yw));
FXYZgridz = reshape(FXYZgrid(:,3),size(Zw));
WXYZgrid2 = interp3cauchy(Xw,Yw,Zw,FXYZgridx,FXYZgridy,FXYZgridz);
s12grid2 = reshape(WXYZgrid2(:,:,:,2),size(Xw));

<span class="comment">%% Rough plot of Hertz Contact Tensor (component xy)</span>
figure, hold on
hs = slice(Xw,Yw,Zw,s12grid2, ...
    single([]),...
    [fluidbox(2,1)-[-.1 0 .1 0.5 1]*rbead/2 ,fluidbox(2,2)+[-.1 0 .1 0.5 1]*rbead/2],...
    single([]));
set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha<span class="string">',0.9)
axis equal, view(3),
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14); hc.Label.String = '</span>Hertz Tensor xy<span class="string">';
xlabel('</span>X<span class="string">'), ylabel('</span>Y<span class="string">'), zlabel('</span>Z<span class="string">')
title('</span>Hertz tensor<span class="string">','</span>fontsize<span class="string">',20)
step = [4 1 4];
quiver3( ...
    Xw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Yw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Zw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridx(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridy(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridz(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>) ...
    ,.5,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth<span class="string">',.1)
caxis([-.1 .1]), view([-50,42])

<span class="comment">%% Internal Solid stress</span>
Xsolid = Xstress.ATOMS(isolid,:);
hcauchystress = 3*rbead; <span class="comment">%1.25e-5; % m</span>
Vsolid = buildVerletList(Xsolid,hcauchystress);
solidbox = [ min(Xsolid{:,coords}); max(Xsolid{:,coords}) ]'</span>;
boxcenter = mean(solidbox,2);
Vbead = mean(Xsolid.c_vol);
<span class="comment">% interpolate the tensor stress</span>
W = kernelSPH(hcauchystress,<span class="string">'lucy'</span>,3); <span class="comment">% kernel <span class="keyword">for</span> interpolation (not gradkernel!)</span>
stresscomponents = arrayfun(@(i) sprintf(<span class="string">'c_S[<span class="comment">%d]'</span>,i),1:7,<span class="string">'UniformOutput'</span>,false);</span>
boxcenter = mean(solidbox,2);
resolution = ceil(50 * diff(solidbox,[],2)<span class="string">'./max(diff(solidbox,[],2)));
xw = linspace(solidbox(1,1)-hcauchystress,solidbox(1,2)+hcauchystress,resolution(1));
yw = linspace(solidbox(2,1)-hcauchystress,solidbox(2,2)+hcauchystress,resolution(2));
zw = linspace(solidbox(3,1)-hcauchystress,solidbox(3,2)+hcauchystress,resolution(3));
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];
VXYZ = buildVerletList({XYZgrid Xsolid{:,coords}},1.001*hcauchystress); <span class="comment">% special grid syntax</span>
SXYZgrid = interp3SPHVerlet(Xsolid{:,coords},Xsolid{:,stresscomponents},XYZgrid,VXYZ,W,Vbead);

<span class="comment">%% Pressure, von Mises equivalent stress</span>
P = 1/3*reshape(sum(SXYZgrid(:,1:3),2),size(Xw));
vMS = reshape(SXYZgrid(:,7),size(Xw));
figure, hold on
hs = slice(Xw,Yw,Zw,vMS,[boxcenter(1) xw(<span class="keyword">end</span>)],...
    [boxcenter(2) yw(<span class="keyword">end</span>)],...
    [solidbox(3,1) boxcenter(3)]);
set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha<span class="string">',0.6)
lighting gouraud, camlight('</span>left<span class="string">'), axis equal, view(3) <span class="comment">% shading interp</span>
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14); hc.Label.String = '</span>von Mises<span class="string">';
title('</span>von Mises Stress<span class="string">','</span>fontsize<span class="string">',20)
xlabel('</span>X<span class="string">'), ylabel('</span>Y<span class="string">'), zlabel('</span>Z<span class="string">')

figure, hold on
hs = slice(Xw,Yw,Zw,P,[boxcenter(1) xw(<span class="keyword">end</span>)],...
    [boxcenter(2) yw(<span class="keyword">end</span>)],...
    [solidbox(3,1) boxcenter(3)]);
set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha<span class="string">',0.6)
lighting gouraud, camlight('</span>left<span class="string">'), axis equal, view(3) <span class="comment">% shading interp</span>
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14); hc.Label.String = '</span>P<span class="string">';
title('</span>Pressure<span class="string">','</span>fontsize<span class="string">',20)
xlabel('</span>X<span class="string">'), ylabel('</span>Y<span class="string">'), zlabel('</span>Z')</code></pre></div>
</div>
<div id='example3' class='doc-content' style='display: none;'>
<h1>EXAMPLE 3</h1>
<p>This theoretical example shows how the Landshoff forces and stresses develop in &quot;ideal&quot; shear flows<br/>several packing effects are analyzed:  HCP, FCC, SC, SC2, SC3</p>
<p>INRAE\Olivier Vitrac, Han Chen</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% EXAMPLE 3</span>
<span class="comment">% This theoretical example shows how the Landshoff forces and stresses develop in "ideal" shear flows</span>
<span class="comment">%   several packing effects are analyzed:  HCP, FCC, SC, SC2, SC3</span>
<span class="comment">%</span>
<span class="comment">% INRAE\Olivier Vitrac, Han Chen</span>

<span class="comment">% 2023-09-13 release candidate - scarce comments (agree), read example2bis.m <span class="keyword">for</span> justifications</span>

<span class="comment">%% Input variables</span>
rbead = 1.0414980e-05;
hLandshoff = 1.5*2*rbead; <span class="comment">%1.25e-5; % m</span>
configLandshoff = struct( ...
    <span class="string">'gradkernel'</span>, kernelSPH(hLandshoff,<span class="string">'lucyder'</span>,3),...kernel gradient
    <span class="string">'h'</span>, hLandshoff,...smoothing length (m)
    <span class="string">'c0'</span>,0.32,...speed of the sound (m/s)
    <span class="string">'q1'</span>,30,... viscosity coefficient (-)
    <span class="string">'rho'</span>, 987.3691, ...density
    <span class="string">'mass'</span>, 9.0418e-12,...bead mass
    <span class="string">'vol'</span>, 9.1580e-15...bead volume
    );
shearrate = 1; <span class="comment">% Hz;</span>
mu = configLandshoff.rho*configLandshoff.q1*configLandshoff.c0*configLandshoff.h/10; 

<span class="comment">% Dynamic simulation</span>
packingmode = <span class="string">'HCP'</span>;
<span class="comment">% packingmode = <span class="string">'FCC'</span>;</span>
<span class="comment">% packingmode = <span class="string">'SC'</span>;</span>
<span class="comment">% packingmode = <span class="string">'SC2'</span>;</span>
<span class="comment">% packingmode = <span class="string">'SC3'</span>;</span>
XYZ0 = packSPH(15,rbead,packingmode); nbeads = size(XYZ0,1);
fluidbox = [min(XYZ0);max(XYZ0)]<span class="string">';
XYZ0 = XYZ0 + [0 rbead 0];
fluidbox(2,2) = fluidbox(2,2) + 2*rbead;
fluidboxdim = diff(fluidbox,1,2);
boxcenter = mean(fluidbox,2)'</span>;
vmax = shearrate * fluidbox(2,2);
vx = vmax * XYZ0(:,2)/fluidbox(2,2);
[vy,vz] = deal(zeros(size(vx)));
vXYZ = [vx,vy,vz];
[~,i]=min(sum((XYZ0-boxcenter).^2,2));
insearch0 = false(nbeads,1); insearch0(i) = true;
V0 = buildVerletList(XYZ0,hLandshoff,[],[],[],~insearch0,insearch0);
j0 = V0{i}; j = j0; insearch = insearch0; insearch(j) = true; nj = length(j);
V  = buildVerletList(XYZ0,hLandshoff,[],[],[],~insearch);


figure, hold on
XYZ = XYZ0;
others = ~insearch; others(j) = false;
hothers = plot3D(XYZ(others,:),<span class="string">'bo'</span>,<span class="string">'markersize'</span>,8);
hj = plot3D(XYZ(j,:),<span class="string">'go'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'g'</span>,<span class="string">'markersize'</span>,16);
hi = plot3D(XYZ(i,:),<span class="string">'ro'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>,<span class="string">'markersize'</span>,24);
xlabel(<span class="string">'X'</span>), ylabel(<span class="string">'Y'</span>),zlabel(<span class="string">'Z'</span>), title(sprintf(<span class="string">'\\bf<span class="comment">%s\\rm configuration'</span>,packingmode),<span class="string">'FontSize'</span>,18)</span>
view(3), drawnow
tmax = 10*hLandshoff/vXYZ(i,1);
nt = 500; dt = tmax/(nt-1); t = (0:dt:(nt-1)*dt)<span class="string">';
Flandshoff = forceLandshoff(XYZ,vXYZ,V,configLandshoff);
[Fi,Fsum] = deal(zeros(nt,3)); Fj = zeros(nt,nj,3);
Fi(1,:) = Flandshoff(i,:);
Fj(1,:,:) = permute(Flandshoff(j,:),[1 3 2]);
ax = axis;
<span class="keyword">for</span> it=2:nt
    dispf('</span>[<span class="comment">%d/%d] iteration t=%0.3g s<span class="string">',it,nt,(it+1)*dt)</span>
    XYZ = XYZ + vXYZ*dt;
    XYZ = XYZ-(XYZ(i,:)-XYZ0(i,:)); <span class="comment">% i is not moving</span>
    <span class="comment">% noise = (rand(nbeads,1)-0.5).*vXYZ*dt/2;</span>
    reflect = (XYZ(:,1)>fluidbox(1,2)); XYZ(reflect) = XYZ(reflect) - fluidbox(1,2) + fluidbox(1,1);
    reflect = (XYZ(:,1)<fluidbox(1,1)); XYZ(reflect) = XYZ(reflect) + fluidbox(1,2) - fluidbox(1,1);
    V = buildVerletList(XYZ,hLandshoff,[],[],[],~insearch);
    j = V{i}; others = ~insearch; others(j) = false;
    set(hothers,'</span>XData<span class="string">',XYZ(others,1),'</span>YData<span class="string">',XYZ(others,2),'</span>ZData<span class="string">',XYZ(others,3))
    set(hj,'</span>XData<span class="string">',XYZ(j,1),'</span>YData<span class="string">',XYZ(j,2),'</span>ZData<span class="string">',XYZ(j,3))
    set(hi,'</span>XData<span class="string">',XYZ(i,1),'</span>YData<span class="string">',XYZ(i,2),'</span>ZData<span class="string">',XYZ(i,3))
    axis(ax), drawnow
    Flandshoff = forceLandshoff(XYZ,vXYZ,V,configLandshoff);
    Fi(it,:) = Flandshoff(i,:);
    Fj(it,:,:) = permute(Flandshoff(j0,:),[1 3 2]);
    Fsum(it,:) = sum(Flandshoff,1);
<span class="keyword">end</span>

<span class="comment">% plot</span>
col = [0    0.4470    0.7410; 0.8500    0.3250    0.0980; 0.9290    0.6940    0.1250];
hfig=figure; set(hfig,'</span>defaultAxesColorOrder<span class="string">',col), hold on
hp = [
    plot(t,Fi,'</span>-<span class="string">','</span>linewidth<span class="string">',6);
    plot(t,Fsum,'</span>--<span class="string">','</span>linewidth<span class="string">',4);
];
legend(hp,{'</span>F_x<span class="string">','</span>F_y<span class="string">','</span>F_z<span class="string">','</span>sum F_x<span class="string">','</span>sum F_y<span class="string">','</span>sum F_z<span class="string">'},'</span>fontsize<span class="string">',20,'</span>Location<span class="string">','</span>best<span class="string">','</span>AutoUpdate<span class="string">','</span>off<span class="string">')
plot(t,Fj(:,:,1),'</span>:<span class="string">','</span>color<span class="string">',col(1,:),'</span>linewidth<span class="string">',2);
plot(t,Fj(:,:,2),'</span>:<span class="string">','</span>color<span class="string">',col(2,:),'</span>linewidth<span class="string">',2);
plot(t,Fj(:,:,3),'</span>:<span class="string">','</span>color<span class="string">',col(3,:),'</span>linewidth<span class="string">',2);
xlabel('</span>time (s)<span class="string">','</span>fontsize<span class="string">',20)
ylabel('</span>Landshoff force<span class="string">','</span>fontsize<span class="string">',20)
title(sprintf('</span>\\bf<span class="comment">%s\\rm<span class="string">',packingmode),'</span>FontSize<span class="string">',18)</span>

<span class="comment">%% Static configuration</span>
XYZ = packSPH(10,rbead,'</span>FCC<span class="string">'); nbeads = size(XYZ,1);
fluidbox = [min(XYZ);max(XYZ)]'</span>;
XYZ = XYZ + [0 rbead 0];
fluidbox(2,2) = fluidbox(2,2) + 2*rbead;
fluidboxdim = diff(fluidbox,1,2);
boxcenter = mean(fluidbox,2);
vmax = shearrate * fluidbox(2,2);
vx = vmax * XYZ(:,2)/fluidbox(2,2);
[vy,vz] = deal(zeros(size(vx)));
vXYZ = [vx,vy,vz];
in = true(nbeads,1);
<span class="keyword">for</span> i=1:3
    in = in & (XYZ(:,i)>=(hLandshoff+fluidbox(i,1))) & (XYZ(:,i)<=(fluidbox(i,2)-hLandshoff));
<span class="keyword">end</span>
<span class="comment">% control</span>
close all
figure, plot3D(XYZ,<span class="string">'ro'</span>), view(3)
quiver3(XYZ(:,1),XYZ(:,2),XYZ(:,3),vXYZ(:,1),vXYZ(:,2),vXYZ(:,3),2,<span class="string">'linewidth'</span>,2,<span class="string">'color'</span>,<span class="string">'k'</span>)
xlabel(<span class="string">'X'</span>), ylabel(<span class="string">'Y'</span>),zlabel(<span class="string">'Z'</span>), title(<span class="string">'initial configuration'</span>)

<span class="comment">% Landshoff forces</span>
V = buildVerletList(XYZ,hLandshoff); <span class="comment">% figure, hist(cellfun(@length,V))</span>
[Flandshoff,Wlandshoff] = forceLandshoff(XYZ,vXYZ,V,configLandshoff);
flandshoff = sqrt(sum(Flandshoff.^2,2));
figure, plot3D(XYZ,<span class="string">'k.'</span>), view(3)
quiver3(XYZ(in,1),XYZ(in,2),XYZ(in,3),Flandshoff(in,1),Flandshoff(in,2),Flandshoff(in,3),1,<span class="string">'linewidth'</span>,2,<span class="string">'color'</span>,<span class="string">'r'</span>)
xlabel(<span class="string">'X'</span>), ylabel(<span class="string">'Y'</span>),zlabel(<span class="string">'Z'</span>), title(<span class="string">'Landshoff forces'</span>), view(-25,90);
figure, hist(Flandshoff(in,1)), xlabel(<span class="string">'component X - Forcefield'</span>)

<span class="comment">%% Grid interpolation of Landshoff forces</span>
<span class="comment">% number of grid points along the largest dimension</span>
resolution = ceil(50 * diff(fluidbox,[],2)<span class="string">'./max(diff(fluidbox,[],2)));
xw = linspace(fluidbox(1,1),fluidbox(1,2),resolution(1));
yw = linspace(fluidbox(2,1),fluidbox(2,2),resolution(2));
zw = linspace(fluidbox(3,1),fluidbox(3,2),resolution(3));
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];
VXYZ = buildVerletList({XYZgrid XYZ},hLandshoff); <span class="comment">% special grid syntax</span>
<span class="comment">% Interpolate Landshoff forces, extract components <span class="keyword">for</span> plotting</span>
W = kernelSPH(hLandshoff,'</span>lucy<span class="string">',3); <span class="comment">% kernel <span class="keyword">for</span> interpolation (not gradkernel!)</span>
FXYZgrid = interp3SPHVerlet(XYZ,Flandshoff,XYZgrid,VXYZ,W,configLandshoff.vol);
FXYZgridx = reshape(FXYZgrid(:,1),size(Xw));
FXYZgridy = reshape(FXYZgrid(:,2),size(Yw));
FXYZgridz = reshape(FXYZgrid(:,3),size(Zw));
<span class="comment">% Interpolate the tensor xy</span>
WXYZgrid = interp3SPHVerlet(XYZ,Wlandshoff(:,2),XYZgrid,VXYZ,W,configLandshoff.vol);
WXYZgrid = reshape(WXYZgrid,size(Xw));

<span class="comment">%% === PLot WLandshoff - Landshoff forces only </span>
figure, hold on
hs = slice(Xw,Yw,Zw,WXYZgrid, ...
    [xw(1)+2*hLandshoff boxcenter(1)],...
    [yw(2)+2*hLandshoff boxcenter(2) yw(<span class="keyword">end</span>)-2*hLandshoff],...
    [fluidbox(3,1)+2*hLandshoff boxcenter(3)]);
set(hs,'</span>edgecolor<span class="string">','</span>none<span class="string">','</span>facealpha<span class="string">',0.9)
axis equal, view(3),
hc = colorbar('</span>AxisLocation<span class="string">','</span>in<span class="string">','</span>fontsize<span class="string">',14); hc.Label.String = '</span>Landshoff along X<span class="string">';
xlabel('</span>X<span class="string">'), ylabel('</span>Y<span class="string">'), zlabel('</span>Z<span class="string">')
title('</span>Landshoff forces along X<span class="string">','</span>fontsize<span class="string">',20)
step = [3 5 5];
quiver3( ...
    Xw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Yw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    Zw(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridx(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridy(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>), ...
    FXYZgridz(1:step(1):<span class="keyword">end</span>,1:step(2):<span class="keyword">end</span>,1:step(3):<span class="keyword">end</span>) ...
    ,1,'</span>color<span class="string">','</span>k<span class="string">','</span>LineWidth',2)</code></pre></div>
</div>
<div id='explore' class='doc-content' style='display: none;'>
<h1>EXPLORE look for files matching a given or a list of formats</h1>
<p>SYNTAX<br/>filelist = explore(format, [path],[depth],[&#x27;abbreviate&#x27; or &#x27;fullabbreviate&#x27;])<br/>INPUTS<br/>format =  string ou cells of string (see isformat for details, very powerfull)<br/>format are not case sensitive (required on WIN machines)<br/>Main metacharacters based on the old syntax of isformat<br/>?  = any character<br/>#  = any digit<br/>#* = any number (list of digits)<br/>~  = not a digit<br/>@  = not a word character ~([a-z_A-Z0-9])<br/>*  = any list of characters<br/>==&gt; any combinations and occurences are possible<br/>path = any valid path (local or remote) or current directory<br/>several paths can be used as {&#x27;path1&#x27; &#x27;path2&#x27; ....}<br/>maxdepth = maximum of examined levels (par d�faut = 10)<br/>FLAG abbreviate can be<br/>&#x27;abbreviate&#x27; generate a simplified structure of filenames<br/>&#x27;fullabbreviate&#x27; generate only a cell string of filenames<br/>CONVERSION<br/>Conversion between formats is possible with:<br/>filelist = explore(filelist) which is equivalent to filelist = explore(filelist,&#x27;fullabbreviate&#x27;)<br/>filelist = explore(filelist,&#x27;abbreviate&#x27;);</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> list = explore(format,pathstr,depth,abbreviate,recursionprefix)
<span class="comment">% EXPLORE look <span class="keyword">for</span> files matching a given or a list of formats</span>
<span class="comment">% 	 SYNTAX</span>
<span class="comment">%       filelist = explore(format, [path],[depth],[<span class="string">'abbreviate'</span> or <span class="string">'fullabbreviate'</span>])</span>
<span class="comment">%     INPUTS</span>
<span class="comment">%		format =  string ou cells of string (see isformat <span class="keyword">for</span> details, very powerfull)</span>
<span class="comment">%                 format are not <span class="keyword">case</span> sensitive (required on WIN machines)</span>
<span class="comment">%                 Main metacharacters based on the old syntax of isformat</span>
<span class="comment">%                       ?  = any character</span>
<span class="comment">%                       #  = any digit</span>
<span class="comment">%                       #* = any number (list of digits)</span>
<span class="comment">%                       ~  = not a digit</span>
<span class="comment">%                       @  = not a word character ~([a-z_A-Z0-9])              </span>
<span class="comment">%                       *  = any list of characters</span>
<span class="comment">%                       ==> any combinations and occurences are possible</span>
<span class="comment">%       path = any valid path (local or remote) or current directory</span>
<span class="comment">%              several paths can be used as {<span class="string">'path1'</span> <span class="string">'path2'</span> ....}    </span>
<span class="comment">%		maxdepth = maximum of examined levels (par d�faut = 10)</span>
<span class="comment">%      FLAG abbreviate can be</span>
<span class="comment">%       <span class="string">'abbreviate'</span> generate a simplified structure of filenames</span>
<span class="comment">%       <span class="string">'fullabbreviate'</span> generate only a cell string of filenames</span>
<span class="comment">%    CONVERSION</span>
<span class="comment">%       Conversion between formats is possible with:</span>
<span class="comment">%           filelist = explore(filelist) which is equivalent to filelist = explore(filelist,<span class="string">'fullabbreviate'</span>)</span>
<span class="comment">%           filelist = explore(filelist,<span class="string">'abbreviate'</span>);</span>

<span class="comment">% TCPIP v. 1.0 - 26/02/01 - INRA\Olivier Vitrac rev. 2023-04-27</span>

<span class="comment">% Revision history</span>
<span class="comment">%   25/02/04 abbreviate format</span>
<span class="comment">%   01/03/04 subpath</span>
<span class="comment">%   14/05/04 fix bug when an empty list occures with abbreviate format</span>
<span class="comment">%   25/01/05 fix <span class="keyword">case</span> profondeur <= 1</span>
<span class="comment">%   10/02/05 fix fieldnames ~pathstr -> ~path</span>
<span class="comment">%   06/03/05 add fields bytes and date</span>
<span class="comment">%   04/12/05 update to new formats (see isformat), add <span class="string">'full abbreviate'</span></span>
<span class="comment">%   20/01/08 add post conversions</span>
<span class="comment">%   24/01/08 improve compatibility with Matlab 7.5</span>
<span class="comment">%   04/01/11 fix versn in FILEPARTS <span class="keyword">for</span> Matlab later than 7.11 (not supported any more)</span>
<span class="comment">%   04/01/11 add datenum</span>
<span class="comment">%   21/07/17 fix subpath (change sizeofroot+2:<span class="keyword">end</span> to sizeofroot+1:<span class="keyword">end</span>)</span>
<span class="comment">%   30/11/17 remove the use of cd as it fails with onedrive</span>
<span class="comment">%   29/12/17 add recursion when pathstr is a cell array of string</span>
<span class="comment">%   20/07/18 add recursionprefix to include lastdir in subpath</span>
<span class="comment">%   22/07/18 initialize recursionprefix to <span class="string">''</span> instead of false</span>
<span class="comment">%   2023-04-27 accepts a comparison with a pattern without using literals <span class="string">'*'</span>,<span class="string">'+'</span></span>

<span class="comment">% default</span>
profondeur_default = 19;
found = false;
oldmatlab = verLessThan(<span class="string">'matlab'</span>,<span class="string">'7.11'</span>);

<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<2, pathstr = []; <span class="keyword">end</span>
<span class="keyword">if</span> isstruct(format), list = abbreviateform(format,pathstr,oldmatlab); <span class="keyword">return</span>, <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, depth = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, abbreviate = <span class="string">'none'</span>; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, recursionprefix = <span class="string">''</span>; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(pathstr), pathstr = pwd; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(depth), depth = profondeur_default; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(recursionprefix), recursionprefix = <span class="string">''</span>; <span class="keyword">end</span>
recursionflagprefix = ~isempty(recursionprefix);

<span class="comment">% recursion <span class="keyword">if</span> multiple paths</span>
<span class="keyword">if</span> iscell(pathstr)
    list = explore(format,pathstr{1},depth,abbreviate,lastdir(pathstr{1}));
    <span class="keyword">for</span> i=2:length(pathstr)
        list = [list, explore(format,pathstr{i},depth,abbreviate,lastdir(pathstr{i}))];
    <span class="keyword">end</span>
    <span class="keyword">return</span>
<span class="keyword">end</span>

sizeofroot = length(pathstr);
currentfilesep = filesep;

<span class="comment">% exploration</span>
<span class="keyword">if</span> depth <=1
    rawlist = dir(fullfile(pathstr,format));
    j = 0;
    list = repmat(struct(<span class="string">'path'</span>,<span class="string">''</span>,<span class="string">'file'</span>,<span class="string">''</span>,<span class="string">'subpath'</span>,<span class="string">''</span>,<span class="string">'name'</span>,<span class="string">''</span>,<span class="string">'ext'</span>,<span class="string">''</span>,<span class="string">'ver'</span>,<span class="string">''</span>,<span class="string">'date'</span>,<span class="string">''</span>,<span class="string">'datenum'</span>,[],<span class="string">'bytes'</span>,[]),0,0);
    <span class="keyword">for</span> i = 1:length(rawlist)
        <span class="keyword">if</span> ~rawlist(i).isdir
            j = j + 1;
            <span class="keyword">if</span> oldmatlab
                [p,n,e,v] = fileparts(rawlist(i).name); <span class="comment">%#ok<*FPART,ASGLU></span>
                date_num = datenum(rawlist(i).date);
            <span class="keyword">else</span>
                [p,n,e] = fileparts(rawlist(i).name); <span class="comment">%#ok<ASGLU></span>
                v = NaN;
                date_num = rawlist(i).datenum;
            <span class="keyword">end</span>
            list(j) = struct(   <span class="string">'path'</span>, pathstr, ...
                                <span class="string">'file'</span>, rawlist(i).name, ...
                                <span class="string">'subpath'</span>,<span class="string">''</span>, ...
                                <span class="string">'name'</span>,n, ...
                                <span class="string">'ext'</span>,e, ...
                                <span class="string">'ver'</span>,v,...
                                <span class="string">'date'</span>,rawlist(i).date,...
                                <span class="string">'datenum'</span>,date_num,...
                                <span class="string">'bytes'</span>,rawlist(i).bytes);
            found = true;
        <span class="keyword">end</span>                     
    <span class="keyword">end</span>
    list = abbreviateform(list,abbreviate,oldmatlab);
<span class="keyword">else</span>
    <span class="comment">%origine = pwd;  % fix 30/11/2017</span>
    mycd = pathstr; <span class="comment">%cd(pathstr) %#ok<*MCCD> % fix 30/11/2017</span>
    i_prof = 1 ;
    fich = cell(depth,1);
    fich{i_prof} = dir(mycd);
    i_fich = zeros(depth,1);
    i_fich(i_prof) = 1;
    i_list = 1;
    list = [];
    <span class="keyword">while</span> (i_prof <= depth) && (i_prof > 0)
        <span class="keyword">if</span> i_fich(i_prof) > length(fich{i_prof})
            mycd = rootdir(mycd); <span class="comment">%cd(<span class="string">'..'</span>) % fix 30/11/2017</span>
            i_prof = i_prof - 1;
        <span class="keyword">else</span>
            format_match = isformat(fich{i_prof}(i_fich(i_prof)).name,format);
            <span class="keyword">if</span> ischar(format) && isempty(format_match)
                <span class="keyword">if</span> strcmp(fich{i_prof}(i_fich(i_prof)).name,format) <span class="comment">% enable the comparison without literals</span>
                    format_match = 1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> fich{i_prof}(i_fich(i_prof)).isdir && fich{i_prof}(i_fich(i_prof)).name(1) ~= <span class="string">'.'</span>
                mycd = fullfile(mycd,fich{i_prof}(i_fich(i_prof)).name); <span class="comment">%cd(fich{i_prof}(i_fich(i_prof)).name) % fix 30/11/2017</span>
                i_prof = i_prof + 1;
                i_fich(i_prof) = 0;
                fich{i_prof} = dir(mycd); <span class="comment">% fix 30/11/2017</span>
            <span class="keyword">elseif</span> any(format_match) && fich{i_prof}(i_fich(i_prof)).bytes > 0
                found = true;
                list(i_list).format_match = format_match; <span class="comment">%#ok<*AGROW></span>
                list(i_list).info.path = mycd; <span class="comment">% fix 30/11/2017</span>
                list(i_list).info.file = fich{i_prof}(i_fich(i_prof)).name;
                <span class="keyword">if</span> length(list(i_list).info.path)>sizeofroot+1
                    list(i_list).info.subpath = list(i_list).info.path(sizeofroot+1:<span class="keyword">end</span>); <span class="comment">% before 21/07/2017 : (sizeofroot+1:<span class="keyword">end</span>)</span>
                <span class="keyword">else</span>
                    list(i_list).info.subpath = currentfilesep;
                <span class="keyword">end</span>
                <span class="keyword">if</span> recursionflagprefix <span class="comment">% added 20/07/2018</span>
                    list(i_list).info.subpath = fullfile(recursionprefix,list(i_list).info.subpath);
                <span class="keyword">end</span>
                list(i_list).info.date = fich{i_prof}(i_fich(i_prof)).date;
                <span class="keyword">if</span> oldmatlab
                    list(i_list).info.datenum = datenum(list(i_list).info.date);
                <span class="keyword">else</span>
                    list(i_list).info.datenum = fich{i_prof}(i_fich(i_prof)).datenum;
                <span class="keyword">end</span>
                list(i_list).info.bytes = fich{i_prof}(i_fich(i_prof)).bytes;
                i_list = i_list + 1;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> i_prof>0, i_fich(i_prof) = i_fich(i_prof) + 1; <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">%cd(origine); % fix 30/11/2017</span>

    <span class="comment">% abbreviate</span>
    <span class="keyword">if</span> any(abbreviate), list = abbreviateform(list,abbreviate,oldmatlab); <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> ~found, list = []; <span class="keyword">end</span>

<span class="keyword">function</span> listout = abbreviateform(list,abbreviate,oldmatlab)
<span class="comment">% ABBREVIATE FORM</span>
<span class="keyword">if</span> isempty(abbreviate), abbreviate  = <span class="string">'fullabbreviate'</span>; <span class="keyword">end</span>
<span class="keyword">switch</span> lower(abbreviate)
    <span class="keyword">case</span> <span class="string">'abbreviate'</span>
        <span class="keyword">if</span> isempty(list) || ~isfield(list,<span class="string">'info'</span>)
            listout=list;
        <span class="keyword">else</span>
            listout = struct2cell(list);
            listout = [listout{2,:,:}];
            <span class="keyword">for</span> i=1:length(listout)
                <span class="keyword">if</span> oldmatlab
                    [p,n,e,v] = fileparts(listout(i).file); <span class="comment">%#ok<ASGLU></span>
                <span class="keyword">else</span>
                    [p,n,e] = fileparts(listout(i).file); <span class="comment">%#ok<ASGLU></span>
                    v = NaN;
                <span class="keyword">end</span>
                listout(i).name = n;
                listout(i).ext = e(2:<span class="keyword">end</span>);
                listout(i).ver = v;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">case</span> <span class="string">'fullabbreviate'</span>
        nlist = length(list);
        listout = cell(nlist,1);
        <span class="keyword">if</span> isfield(list,<span class="string">'info'</span>)
            <span class="keyword">for</span> i=1:nlist, listout{i} = fullfile(list(i).info.path,list(i).info.file); <span class="keyword">end</span>
        <span class="keyword">elseif</span> isfield(list,<span class="string">'file'</span>)
            <span class="keyword">for</span> i=1:nlist, listout{i} = fullfile(list(i).path,list(i).file); <span class="keyword">end</span>
        <span class="keyword">else</span>
            listout = list;
        <span class="keyword">end</span>
    <span class="keyword">otherwise</span>
        listout=list;
<span class="keyword">end</span>
<span class="comment">% <span class="keyword">function</span> list = explore(format,pathstr,profondeur,abbreviate)</span>
<span class="comment">% % EXPLORE look <span class="keyword">for</span> files matching a given or a list of formats</span>
<span class="comment">% % 		Syntax: filelist = explore(format, [path],[depth],[<span class="string">'abbreviate'</span> or <span class="string">'fullabbreviate'</span>])</span>
<span class="comment">% %		format =  string ou cells of string (see isformat <span class="keyword">for</span> details, very powerfull)</span>
<span class="comment">% %                 format are not <span class="keyword">case</span> sensitive (required on WIN machines)</span>
<span class="comment">% %                 Main metacharacters based on the old syntax of isformat</span>
<span class="comment">% %                       ?  = any character</span>
<span class="comment">% %                       #  = any digit</span>
<span class="comment">% %                       #* = any number (list of digits)</span>
<span class="comment">% %                       ~  = not a digit</span>
<span class="comment">% %                       @  = not a word character ~([a-z_A-Z0-9])              </span>
<span class="comment">% %                       *  = any list of characters</span>
<span class="comment">% %                       ==> any combinations and occurences are possible</span>
<span class="comment">% %       path = any valid path (local or remote) or current directory</span>
<span class="comment">% %		maxdepth = maximum of examined levels (par d�faut = 10)</span>
<span class="comment">% %       <span class="string">'abbreviate'</span> generate a simplified structure of filenames</span>
<span class="comment">% %       <span class="string">'fullabbreviate'</span> generate only a cell string of filenames</span>
<span class="comment">% %</span>
<span class="comment">% %       Conversion between formats is possible with:</span>
<span class="comment">% %           filelist = explore(filelist) which is equivalent to filelist = explore(filelist,<span class="string">'fullabbreviate'</span>)</span>
<span class="comment">% %           filelist = explore(filelist,<span class="string">'abbreviate'</span>);</span>
<span class="comment">% </span>
<span class="comment">% % TCPIP v. 1.0 - 26/02/01 - INRA\Olivier Vitrac rev. 06/05/05</span>
<span class="comment">% </span>
<span class="comment">% % Revision history</span>
<span class="comment">% %   25/02/04 abbreviate format</span>
<span class="comment">% %   01/03/04 subpath</span>
<span class="comment">% %   14/05/04 fix bug when an empty list occures with abbreviate format</span>
<span class="comment">% %   25/01/05 fix <span class="keyword">case</span> profondeur <= 1</span>
<span class="comment">% %   10/02/05 fix fieldnames ~pathstr -> ~path</span>
<span class="comment">% %   06/03/05 add fields bytes and date</span>
<span class="comment">% %   04/12/05 update to new formats (see isformat), add <span class="string">'full abbreviate'</span></span>
<span class="comment">% %   20/01/08 add post conversions     </span>
<span class="comment">% </span>
<span class="comment">% % default</span>
<span class="comment">% profondeur_default = 19;</span>
<span class="comment">% extsep = <span class="string">'.'</span>;</span>
<span class="comment">% found = false;</span>
<span class="comment">% </span>
<span class="comment">% % arg check</span>
<span class="comment">% <span class="keyword">if</span> nargin<2, pathstr = []; <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> isstruct(format), list = abbreviateform(format,pathstr); <span class="keyword">return</span>, <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> nargin<3, profondeur = []; <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> nargin<4, abbreviate = <span class="string">'none'</span>; <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> isempty(pathstr), pathstr = cd; <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> isempty(profondeur), profondeur = profondeur_default; <span class="keyword">end</span></span>
<span class="comment">% sizeofroot = length(pathstr);</span>
<span class="comment">% currentfilesep = filesep;</span>
<span class="comment">% </span>
<span class="comment">% % exploration</span>
<span class="comment">% <span class="keyword">if</span> profondeur <=1</span>
<span class="comment">%     rawlist = dir(fullfile(pathstr,format));</span>
<span class="comment">%     j = 0;</span>
<span class="comment">%     <span class="keyword">for</span> i = 1:length(rawlist)</span>
<span class="comment">%         <span class="keyword">if</span> ~rawlist(i).isdir</span>
<span class="comment">%             j = j + 1;</span>
<span class="comment">%             [p,n,e,v] = fileparts(rawlist(i).name);</span>
<span class="comment">%             list(j) = struct(   <span class="string">'path'</span>, pathstr, ...</span>
<span class="comment">%                                 <span class="string">'file'</span>, rawlist(i).name, ...</span>
<span class="comment">%                                 <span class="string">'subpath'</span>,<span class="string">''</span>, ...</span>
<span class="comment">%                                 <span class="string">'name'</span>,n, ...</span>
<span class="comment">%                                 <span class="string">'ext'</span>,e, ...</span>
<span class="comment">%                                 <span class="string">'ver'</span>,v,...</span>
<span class="comment">%                                 <span class="string">'date'</span>,rawlist(i).date,...</span>
<span class="comment">%                                 <span class="string">'bytes'</span>,rawlist(i).bytes);</span>
<span class="comment">%             found = true;</span>
<span class="comment">%         <span class="keyword">end</span>                     </span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">%     list = abbreviateform(list,abbreviate);</span>
<span class="comment">% <span class="keyword">else</span></span>
<span class="comment">%     origine = cd; cd(pathstr)</span>
<span class="comment">%     i_prof = 1 ; pos = zeros(0,1);</span>
<span class="comment">%     fich = cell(profondeur,1);</span>
<span class="comment">%     fich{i_prof} = dir;</span>
<span class="comment">%     i_fich = zeros(profondeur,1);</span>
<span class="comment">%     i_fich(i_prof) = 1;</span>
<span class="comment">%     i_list = 1;</span>
<span class="comment">%     list = [];</span>
<span class="comment">%     <span class="keyword">while</span> (i_prof <= profondeur) & (i_prof > 0)</span>
<span class="comment">%         <span class="keyword">if</span> i_fich(i_prof) > length(fich{i_prof})</span>
<span class="comment">%             cd(<span class="string">'..'</span>)</span>
<span class="comment">%             i_prof = i_prof - 1;</span>
<span class="comment">%         <span class="keyword">else</span></span>
<span class="comment">%             format_match = isformat(fich{i_prof}(i_fich(i_prof)).name,format);</span>
<span class="comment">%             <span class="keyword">if</span> fich{i_prof}(i_fich(i_prof)).isdir & fich{i_prof}(i_fich(i_prof)).name(1) ~= <span class="string">'.'</span></span>
<span class="comment">%                 cd(fich{i_prof}(i_fich(i_prof)).name)</span>
<span class="comment">%                 i_prof = i_prof + 1;</span>
<span class="comment">%                 i_fich(i_prof) = 0;</span>
<span class="comment">%                 fich{i_prof} = dir;</span>
<span class="comment">%             <span class="keyword">elseif</span> any(format_match) & fich{i_prof}(i_fich(i_prof)).bytes > 0</span>
<span class="comment">%                 found = true;</span>
<span class="comment">%                 list(i_list).format_match = format_match;</span>
<span class="comment">%                 list(i_list).info.path = cd;</span>
<span class="comment">%                 list(i_list).info.file = fich{i_prof}(i_fich(i_prof)).name;</span>
<span class="comment">%                 <span class="keyword">if</span> length(list(i_list).info.path)>sizeofroot+1</span>
<span class="comment">%                     list(i_list).info.subpath = list(i_list).info.path(sizeofroot+2:<span class="keyword">end</span>);</span>
<span class="comment">%                 <span class="keyword">else</span></span>
<span class="comment">%                     list(i_list).info.subpath = currentfilesep;</span>
<span class="comment">%                 <span class="keyword">end</span></span>
<span class="comment">%                 list(i_list).info.date = fich{i_prof}(i_fich(i_prof)).date;</span>
<span class="comment">%                 list(i_list).info.bytes = fich{i_prof}(i_fich(i_prof)).bytes;</span>
<span class="comment">%                 i_list = i_list + 1;</span>
<span class="comment">%             <span class="keyword">end</span></span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%         <span class="keyword">if</span> i_prof>0, i_fich(i_prof) = i_fich(i_prof) + 1; <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">%     cd(origine);</span>
<span class="comment">% </span>
<span class="comment">%     % abbreviate</span>
<span class="comment">%     <span class="keyword">if</span> any(abbreviate), list = abbreviateform(list,abbreviate); <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% <span class="keyword">if</span> ~found, list = []; <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% <span class="keyword">function</span> listout = abbreviateform(list,abbreviate)</span>
<span class="comment">% % ABBREVIATE FORM</span>
<span class="comment">% <span class="keyword">if</span> isempty(abbreviate), abbreviate  = <span class="string">'fullabbreviate'</span>; <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">switch</span> lower(abbreviate)</span>
<span class="comment">%     <span class="keyword">case</span> <span class="string">'abbreviate'</span></span>
<span class="comment">%         <span class="keyword">if</span> isempty(list) || ~isfield(list,<span class="string">'info'</span>)</span>
<span class="comment">%             listout=list;</span>
<span class="comment">%         <span class="keyword">else</span></span>
<span class="comment">%             listout = struct2cell(list);</span>
<span class="comment">%             listout = [listout{2,:,:}];</span>
<span class="comment">%             <span class="keyword">for</span> i=1:length(listout)</span>
<span class="comment">%                 [p,n,e,v] = fileparts(listout(i).file);</span>
<span class="comment">%                 listout(i).name = n;</span>
<span class="comment">%                 listout(i).ext = e(2:<span class="keyword">end</span>);</span>
<span class="comment">%                 listout(i).ver = v;</span>
<span class="comment">%             <span class="keyword">end</span></span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">case</span> <span class="string">'fullabbreviate'</span></span>
<span class="comment">%         nlist = length(list);</span>
<span class="comment">%         listout = cell(nlist,1);</span>
<span class="comment">%         <span class="keyword">if</span> isfield(list,<span class="string">'info'</span>)</span>
<span class="comment">%             <span class="keyword">for</span> i=1:nlist, listout{i} = fullfile(list(i).info.path,list(i).info.file); <span class="keyword">end</span></span>
<span class="comment">%         <span class="keyword">elseif</span> isfield(list,<span class="string">'file'</span>)</span>
<span class="comment">%             <span class="keyword">for</span> i=1:nlist, listout{i} = fullfile(list(i).path,list(i).file); <span class="keyword">end</span></span>
<span class="comment">%         <span class="keyword">else</span></span>
<span class="comment">%             listout = list;</span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">otherwise</span></span>
<span class="comment">%         listout=list;</span>
<span class="comment">% <span class="keyword">end</span></span></code></pre></div>
</div>
<div id='fileinfo' class='doc-content' style='display: none;'>
<h1>FILEINFO returns a structure that contains the main information of a given file</h1>
<p>Syntax: info = fileinfo(filename,[path])<br/>Options: [info,str] = fileinfo(filename,[path,dispon,stringonly,noerror])</p>
<p>INPUTS<br/>filename can include a full path or not<br/>path is used if filename does not include it (the current path is used otherwise)<br/>dispon (flag, default=true) prints on screen if true<br/>stringonly (flag, default=false) returns a formated single string instead of a structure if true<br/>noerror (flag, default=false) no error message if true, corresponding files appear with sizes 0</p>
<p>OUTPUTS<br/>info = structure matching dir/ls properties (string if stringonly is true)<br/>str = formated string</p>
<h2>See also</h2>
<p><a href="#explore">explore</a>, isformat, isformat_multiple, ls, dir</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [rout,strout] = fileinfo(filename,ppath,dispon,stringonly,noerror)
<span class="comment">%FILEINFO returns a structure that contains the main information of a given file</span>
<span class="comment">%  Syntax: info = fileinfo(filename,[path])</span>
<span class="comment">%  Options: [info,str] = fileinfo(filename,[path,dispon,stringonly,noerror])</span>
<span class="comment">%</span>
<span class="comment">% INPUTS</span>
<span class="comment">%   filename can include a full path or not</span>
<span class="comment">%   path is used <span class="keyword">if</span> filename does not include it (the current path is used <span class="keyword">otherwise</span>)</span>
<span class="comment">%   dispon (flag, default=true) prints on screen <span class="keyword">if</span> true</span>
<span class="comment">%   stringonly (flag, default=false) returns a formated single string instead of a structure <span class="keyword">if</span> true </span>
<span class="comment">%   noerror (flag, default=false) no error message <span class="keyword">if</span> true, corresponding files appear with sizes 0</span>
<span class="comment">%   </span>
<span class="comment">% OUTPUTS</span>
<span class="comment">%   info = structure matching dir/ls properties (string <span class="keyword">if</span> stringonly is true)</span>
<span class="comment">%   str = formated string</span>
<span class="comment">%</span>
<span class="comment">%   See also: explore, isformat, isformat_multiple, ls, dir</span>

<span class="comment">% MS-MATLAB 1.0 - 20/04/04 - INRA\Olivier Vitrac - rev. 03/06/19</span>

<span class="comment">% revision history</span>
<span class="comment">% 19/08/04: display <span class="keyword">if</span> no ouput, added str</span>
<span class="comment">% 11/09/07 fix filename as cell array</span>
<span class="comment">% 12/01/11 fix versn in FILEPARTS <span class="keyword">for</span> Matlab later than 7.11 (not supported any more)</span>
<span class="comment">% 30/12/12 cosmetic modifications</span>
<span class="comment">% 09/02/16 improved help, add noerror</span>
<span class="comment">% 03/06/19 fix date format on French computers</span>

<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<2, ppath = <span class="string">''</span>; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, dispon = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, stringonly = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, noerror = []; <span class="keyword">end</span>
<span class="keyword">if</span> ~nargout || isempty(dispon), dispon = true; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(stringonly), stringonly = false; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(noerror), noerror = false; <span class="keyword">end</span>
oldmatlab = verLessThan(<span class="string">'matlab'</span>,<span class="string">'7.11'</span>);
issomethingmissing = false;

<span class="keyword">if</span> iscell(filename)
    m = length(filename);
    str = cell(m,1);
    [r,str{1}] = fileinfo(filename{1},ppath,dispon);
    <span class="keyword">for</span> i=2:m, [r(i),str{i}] = fileinfo(filename{i},ppath,dispon); <span class="keyword">end</span>
    dispon = false;
<span class="keyword">else</span>
    <span class="comment">% other checks</span>
    <span class="keyword">if</span> oldmatlab
        [pathstr,name,ext,versn] = fileparts(filename);
    <span class="keyword">else</span>
        [pathstr,name,ext] = fileparts(filename);
        versn = [];
    <span class="keyword">end</span>
    <span class="keyword">if</span> isempty(pathstr)
        <span class="keyword">if</span> isempty(ppath)
            pathstr = cd;
        <span class="keyword">else</span>
            pathstr = ppath;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> ~exist(pathstr,<span class="string">'dir'</span>)
        <span class="keyword">if</span> noerror
            issomethingmissing = true;
        <span class="keyword">else</span>
            error(<span class="string">'the directory '</span><span class="string">'<span class="comment">%s'</span><span class="string">' does not exist'</span>,pathstr)</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    fullfilename = fullfile(pathstr,[name ext versn]);
    <span class="keyword">if</span> ~exist(fullfilename,<span class="string">'file'</span>)
        <span class="keyword">if</span> noerror
            issomethingmissing = true;
        <span class="keyword">else</span>
            error(<span class="string">'the file '</span><span class="string">'<span class="comment">%s'</span><span class="string">' does not exist in '</span><span class="string">'%s'</span><span class="string">''</span>,[name ext versn],pathstr)</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> issomethingmissing <span class="comment">% faked info</span>
        f = struct(<span class="string">'date'</span>,datestr(now),<span class="string">'bytes'</span>,0);
    <span class="keyword">else</span> <span class="comment">% true info</span>
        f = dir(fullfilename);
        <span class="keyword">if</span> isfield(f,<span class="string">'datenum'</span>), f.date = datestr(f.datenum); <span class="keyword">end</span>
    <span class="keyword">end</span>
    r =struct(   <span class="string">'filename'</span>, [name ext versn], ...
        <span class="string">'name'</span>,     name, ...
        <span class="string">'ext'</span>,      ext, ...
        <span class="string">'ver'</span>,      versn, ...
        <span class="string">'date'</span>,     f.date, ...
        <span class="string">'bytes'</span>,    f.bytes, ...
        <span class="string">'path'</span>,     pathstr...
        );

    <span class="keyword">if</span> f.bytes>1024*1024
        str = sprintf(<span class="string">'\t<span class="comment">%s%s\t\t%s\t\t%0.1f MBytes\t\t%s'</span>,name,ext,f.date,f.bytes/(1024*1024),pathstr);</span>
    <span class="keyword">elseif</span> f.bytes>1024
        str = sprintf(<span class="string">'\t<span class="comment">%s%s\t\t%s\t\t%0.1f kBytes\t\t%s'</span>,name,ext,f.date,f.bytes/1024,pathstr);</span>
    <span class="keyword">else</span>
        str = sprintf(<span class="string">'\t<span class="comment">%s%s\t\t%s\t\t%d Bytes\t\t%s'</span>,name,ext,f.date,f.bytes,pathstr);</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% output</span>
<span class="keyword">if</span> nargout>0, rout = r; <span class="keyword">end</span>
<span class="keyword">if</span> stringonly, rout = str; <span class="keyword">return</span>, <span class="keyword">end</span> 
<span class="keyword">if</span> nargout>1, strout = str; <span class="keyword">end</span>
<span class="keyword">if</span> dispon, disp(str), <span class="keyword">end</span></code></pre></div>
</div>
<div id='fillstreamline2' class='doc-content' style='display: none;'>
<h1>FILLSTREAMLINE2 fills streamline with distibuted and non-overlapping objects (beads)</h1>
<p>USAGE: traj = fillstreamline2(s,Xgrid,Ygrid,Vxgrid,Vygrid [,dmax,l0,verbosity])<br/>[traj,errout] = fillstreamline2(...)</p>
<p>Inputs:<br/>s: n x 2 array coding for one single 2D streamline<br/>1 x m cell array (output of streamline)<br/>Xgrid: 2D (axb) array coding for X coordinates (output of meshgrid)<br/>Ygrid: 2D (axb) array coding for Y coordinates (output of meshgrid)<br/>Vxgrid: 2D (axb) array coding for x-component of velocity<br/>Vygrid: 2D (axb) array coding for y-component of velocity<br/>rbead: bead radius (default value = 1)<br/>l0: initial position of first bead (curvilinear) (default value = 0)<br/>verbose: flag to control verbosity (default = true)</p>
<p>Outputs:<br/>traj: structure with fields (nb = number of objects/beads distributed along the streamline)</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [traj,errout] = fillstreamline2(s,Xgrid,Ygrid,Vxgrid,Vygrid,rbead,l0,verbose)
<span class="comment">%FILLSTREAMLINE2 fills streamline with distibuted and non-overlapping objects (beads)</span>
<span class="comment">%</span>
<span class="comment">%   USAGE: traj = fillstreamline2(s,Xgrid,Ygrid,Vxgrid,Vygrid [,dmax,l0,verbosity])</span>
<span class="comment">%          [traj,errout] = fillstreamline2(...)</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%           s: n x 2 array coding <span class="keyword">for</span> one single 2D streamline</span>
<span class="comment">%              1 x m cell array (output of streamline)</span>
<span class="comment">%       Xgrid: 2D (axb) array coding <span class="keyword">for</span> X coordinates (output of meshgrid)</span>
<span class="comment">%       Ygrid: 2D (axb) array coding <span class="keyword">for</span> Y coordinates (output of meshgrid)</span>
<span class="comment">%      Vxgrid: 2D (axb) array coding <span class="keyword">for</span> x-component of velocity</span>
<span class="comment">%      Vygrid: 2D (axb) array coding <span class="keyword">for</span> y-component of velocity</span>
<span class="comment">%       rbead: bead radius (default value = 1)</span>
<span class="comment">%          l0: initial position of first bead (curvilinear) (default value = 0)</span>
<span class="comment">%     verbose: flag to control verbosity (default = true)</span>
<span class="comment">%</span>
<span class="comment">%   Outputs:</span>
<span class="comment">%        traj: structure with fields (nb = number of objects/beads distributed along the streamline)</span>

<span class="comment">%            streamline: n×2 original streamline</span>
<span class="comment">%           curvilinear: n×1 curvilinear coordinate along the streamline</span>
<span class="comment">%            pseudotime: n×1 pseudotime to travel along the streamline</span>
<span class="comment">%         curv_velocity: n×1 velocity along the curvilinear coordinate</span>
<span class="comment">%         cart_velocity: n×2 cartesian velocity</span>
<span class="comment">%     curv_distribution: nb×1 distribution of beads along the curvilinear coordinate</span>
<span class="comment">%     cart_distribution: nb×2 corresponding cartesian coordinates</span>
<span class="comment">%        t_distribution: nb×1 corresponding time</span>
<span class="comment">%   curv_v_distribution: nb×1 corresponding velocity along the streamline</span>
<span class="comment">%   cart_v_distribution: nb×2 corresponding cartesian velocity </span>
<span class="comment">%</span>
<span class="comment">%     errout: error messages</span>


<span class="comment">% MS 3.0 | 2024-03-13 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev. 2024-03-31</span>


<span class="comment">% Revision history</span>
<span class="comment">% 2024-03-17 fix help</span>
<span class="comment">% 2024-03-27 force nbmax to be at least one</span>
<span class="comment">% 2024-03-31 add verbose, errout, fix isempty(s)</span>


<span class="comment">%% default values</span>
rbead_default = 1;
l0_default = 0;
verbose_default = true;

<span class="comment">%% check arguments</span>
<span class="keyword">if</span> nargin<5, error(<span class="string">'USAGE: traj = fillstreamline2(s,Xgrid,Ygrid,Vxgrid,Vygrid [,rbead,l0])'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> nargin<6, rbead = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<7, l0 = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<8, verbose = []; <span class="keyword">end</span>
Xgridsiz = size(Xgrid);
<span class="keyword">if</span> ~isequal(size(Ygrid),Xgridsiz),  error(<span class="string">'Ygrid should be of the same size (<span class="comment">%d x %d) as Xgrid'</span>,Xgridsiz(1),Xgridsiz(2)), <span class="keyword">end</span></span>
<span class="keyword">if</span> ~isequal(size(Vxgrid),Xgridsiz), error(<span class="string">'Vxgrid should be of the same size (<span class="comment">%d x %d) as Xgrid'</span>,Xgridsiz(1),Xgridsiz(2)), <span class="keyword">end</span></span>
<span class="keyword">if</span> ~isequal(size(Vygrid),Xgridsiz), error(<span class="string">'Vygrid should be of the same size (<span class="comment">%d x %d) as Xgrid'</span>,Xgridsiz(1),Xgridsiz(2)), <span class="keyword">end</span></span>
<span class="keyword">if</span> isempty(rbead), rbead = rbead_default; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(l0), l0 = l0_default; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(verbose), verbose = verbose_default; <span class="keyword">end</span>
errmsg = {};
<span class="keyword">if</span> isempty(s), error(<span class="string">'no streamline to fill (uniform velocity field?)'</span>), <span class="keyword">end</span>

<span class="comment">%% pseudo recursion</span>
<span class="keyword">if</span> iscell(s)
    ns = length(s);
    <span class="keyword">if</span> ns<2 <span class="comment">% only one streamline (no recursion)</span>
        s = s{1};
    <span class="keyword">else</span> <span class="comment">% more than one streamline</span>
        listerrmsg = [];
        screen = <span class="string">''</span>; t0_ = clock;
        <span class="keyword">for</span> i=1:ns
            [tmp,errmsg] = fillstreamline2(s{i},Xgrid,Ygrid,Vxgrid,Vygrid,rbead,l0,false);
            dt = etime(clock,t0_); <span class="comment">%#ok<DETIM></span>
            <span class="keyword">if</span> dt>0.5
                done = 100 * i/ns;
                screen = dispb(screen,<span class="string">'FILLSTREAMLINE2 [<span class="comment">%d/%d] fill 2D streamline with %d beads (resolution: %d segments) | done %0.3g %% | elapsed %0.4g s | remaining %0.4g s'</span>,...</span>
                    i,ns,length(tmp.t_distribution),size(tmp.streamline,1),done,dt,(100/done-1)*dt);
            <span class="keyword">end</span>
            <span class="keyword">if</span> i==1, traj = repmat(tmp,ns,1); <span class="keyword">else</span>, traj(i) = tmp; <span class="keyword">end</span>
            <span class="keyword">for</span> j = 1:length(errmsg)
                <span class="keyword">if</span> ~ismember(errmsg{j},listerrmsg)
                    screen = <span class="string">''</span>; dispf(<span class="string">'<span class="comment">%s\n\t(future occurrences of the same message will not be repeated)'</span>,errmsg{j})</span>
                    listerrmsg{<span class="keyword">end</span>+1} = errmsg{j}; <span class="comment">%#ok<AGROW></span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span> <span class="comment">% next i</span>
        <span class="keyword">return</span>
    <span class="keyword">end</span> <span class="comment">% ns>1</span>
<span class="keyword">end</span>

<span class="comment">%% check argument (continued)</span>
[n0,d] = size(s);
<span class="keyword">if</span> d~=2, error(<span class="string">'The streamline should be n*2 array'</span>), <span class="keyword">end</span>
valid = all(~isnan(s),2);
s = s(valid,:);
n = size(s,1);
<span class="keyword">if</span> n<n0, dispf(<span class="string">'FILTSTREAMLINE2: <span class="comment">%d points on %d were removed from the streamline'</span>,n0-n,n0); <span class="keyword">end</span></span>
<span class="keyword">if</span> n==0, error(<span class="string">'the streamline is empty'</span>), <span class="keyword">end</span>

<span class="comment">%% curvilinear coordinate</span>
dl = sqrt(sum(diff(s,1,1).^2,2));
l = cumsum([0;dl],1);
nbmax = max(1,l(<span class="keyword">end</span>)/(2*rbead)); <span class="comment">% total number of beads</span>
<span class="comment">%dmean = nbmax/l(<span class="keyword">end</span>); % mean-density</span>

<span class="comment">%% calculate the Tangent </span>
T = zeros(n,d);
<span class="comment">% first point (forward difference)</span>
T(1,:) = s(2,:) - s(1,:);
<span class="comment">% middle points (central differences)</span>
T(2:<span class="keyword">end</span>-1,:) = s(3:<span class="keyword">end</span>,:) - s(1:<span class="keyword">end</span>-2,:);
<span class="comment">% <span class="keyword">end</span> point (backward difference)</span>
T(<span class="keyword">end</span>,:) = s(<span class="keyword">end</span>,:) - s(<span class="keyword">end</span>-1,:);
<span class="comment">%normalize the tangent</span>
T = T./sqrt(sum(T.^2,2));

<span class="comment">%% interpolate the velocity along the streamline</span>
Vxy = [
  interp2(Xgrid,Ygrid,Vxgrid,s(:,1),s(:,2)),...
  interp2(Xgrid,Ygrid,Vygrid,s(:,1),s(:,2))
  ];
v = dot(Vxy,T,2);

<span class="comment">%% reverse the streamline <span class="keyword">if</span> the flow is in the other direction</span>
<span class="keyword">if</span> mean(v,1,<span class="string">'omitmissing'</span>)<0
    errmsg{<span class="keyword">end</span>+1} = <span class="string">'FILTSTREAMLINE2: streamline upsidedown detected'</span>;
    <span class="keyword">if</span> verbose, dispf(errmsg{<span class="keyword">end</span>}), <span class="keyword">end</span>
    traj = fillstreamline2(flipud(s),Xgrid,Ygrid,Vxgrid,Vygrid,rbead,l0,verbose);
    <span class="keyword">return</span>
<span class="keyword">end</span>

<span class="comment">%% fix bad v value</span>
ibadv = find(isnan(v));
<span class="keyword">if</span> ~isempty(ibadv)
    errmsg{<span class="keyword">end</span>+1} = <span class="string">'FILTSTREAMLINE2: bad velocity detected (fixed with extrapolation)'</span>;
    <span class="keyword">if</span> verbose, dispf(errmsg{<span class="keyword">end</span>}), <span class="keyword">end</span>
    igoodv = setdiff((1:n)<span class="string">',ibadv);
    v(ibadv) = interp1(igoodv,v(igoodv),ibadv,'</span>linear<span class="string">','</span>extrap<span class="string">');
<span class="keyword">end</span>


<span class="comment">%% traveling time (backward: (li+1-li)/Vi) and total time</span>
dt = diff(l)./v(1:<span class="keyword">end</span>-1);
t = cumsum([0;dt]);

<span class="comment">%% condition of steady-state: rate = minimum rate (e.g., # cars/beads per time unit)</span>
<span class="comment">% The rate is the same between all li and li+1 and it'</span>s determined by the lowest rate.</span>
ratemin = min(1./dt);  <span class="comment">%condition of steady state: </span>

<span class="comment">%% condition of uniform density along each segment</span>
density = ratemin*dt./dl; <span class="comment">% # cars/beads per length</span>
dnb = density .* dl; <span class="comment">% # beads (not scaled)</span>
dnb = [0;dnb/sum(dnb)] * nbmax;  <span class="comment">% variation of the number of beads between segment</span>
nb = cumsum(dnb);
nb = nb-interp1(l,nb,l0)+1; <span class="comment">% first bead at l0</span>
nb(nb<0) = 0;

<span class="comment">%% evaluation positions</span>
ok = nb>=1;
nbok = nb(ok);
lok = l(ok);
<span class="keyword">if</span> any(nbok==0), error(<span class="string">'error at least two positions are identical in the streamline'</span>), <span class="keyword">end</span>
pos = interp1(nbok,lok,(1:nbmax)<span class="string">');
pos = pos(~isnan(pos));

<span class="comment">%% build the trajectory (fake trajectory)</span>
traj = struct( ...
    '</span>streamline<span class="string">',s,...
    '</span>curvilinear<span class="string">',l,...
    '</span>pseudotime<span class="string">',t,...
    '</span>curv_velocity<span class="string">',v,...
    '</span>cart_velocity<span class="string">',Vxy,...
    '</span>curv_distribution<span class="string">',pos,...
    '</span>cart_distribution<span class="string">',interp1(l,s,pos),...
    '</span>t_distribution<span class="string">',interp1(l,t,pos),...
    '</span>curv_v_distribution<span class="string">',interp1(l,v,pos), ...
    '</span>cart_v_distribution',interp1(l,Vxy,pos) ...
    );

<span class="keyword">if</span> nargout>1
    errout = errmsg;
<span class="keyword">end</span></code></pre></div>
</div>
<div id='fitCircleFromPoints' class='doc-content' style='display: none;'>
<h1>FITCIRCLEFROMPOINTS fit a circle from a set of points and calculate the missing information such as the radius, centroid, and angles</h1>
<p>Syntax: circleFit = fitCircleFromPoints(XY)<br/>XY is a Nx2 matrix where N is the number of points<br/>circleFit is a structure with fields<br/>center: [xcenter y center]<br/>radius: radius<br/>minAngle: minimum angle<br/>maxAngle: maximum angle<br/>angles: corresponding angles<br/>XYgenerator: returns the position XY from an angles<br/>angleGenerator: returns the angles from positions XY</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> circleFit = fitCircleFromPoints(XY)
<span class="comment">%FITCIRCLEFROMPOINTS fit a circle from a set of points and calculate the missing information such as the radius, centroid, and angles</span>
<span class="comment">%</span>
<span class="comment">%   Syntax: circleFit = fitCircleFromPoints(XY)</span>
<span class="comment">%       XY is a Nx2 matrix where N is the number of points</span>
<span class="comment">%       circleFit is a structure with fields</span>
<span class="comment">%           center: [xcenter y center]</span>
<span class="comment">%           radius: radius</span>
<span class="comment">%         minAngle: minimum angle</span>
<span class="comment">%         maxAngle: maximum angle</span>
<span class="comment">%           angles: corresponding angles</span>
<span class="comment">%      XYgenerator: returns the position XY from an angles</span>
<span class="comment">%   angleGenerator: returns the angles from positions XY</span>

<span class="comment">% MS 3.0 | 2024-03-23 | INRAE\han.chen@inrae.fr, INRAE\Olivier.vitrac@agroparistech.fr | rev. </span>


<span class="comment">% Revision history</span>



<span class="comment">% Initial estimate of the center using the centroid of the points</span>
initialCenter = mean(XY, 1);

<span class="comment">% Define the objective <span class="keyword">function</span> <span class="keyword">for</span> the least squares problem</span>
objectiveFunction = @(params) sum(((XY(:,1) - params(1)).^2 + (XY(:,2) - params(2)).^2 - params(3)^2).^2);

<span class="comment">% Initial guess <span class="keyword">for</span> [center_x, center_y, radius]</span>
initialGuess = [initialCenter, sqrt(var(XY(:,1)) + var(XY(:,2)))];

<span class="comment">% Optimize using fminsearch or another optimization <span class="keyword">function</span></span>
optimizedParams = fminsearch(objectiveFunction, initialGuess);

<span class="comment">% Extract the optimized center and radius</span>
center = optimizedParams(1:2);
radius = optimizedParams(3);

<span class="comment">% Calculate shifted points and angles</span>
XY_shifted = XY - center;
angles = atan2(XY_shifted(:,2), XY_shifted(:,1));

<span class="comment">% Calculate the full angle range of the given points</span>
minAngle = min(angles);
maxAngle = max(angles);

<span class="comment">% Return results in a structure</span>
circleFit.center = center;
circleFit.radius = radius;
circleFit.minAngle = minAngle;
circleFit.maxAngle = maxAngle;
circleFit.angles = angles;
circleFit.XYgenerator = @(a) [cos(a(:)) sin(a(:))]*radius + center;
circleFit.angleGenerator = @(xy) atan2(xy(:,2)-center(2), xy(:,1)-center(1));</code></pre></div>
</div>
<div id='forceHertz' class='doc-content' style='display: none;'>
<h1>FORCEHERTZ calculates Hertz contact forces for all atoms assuming that the Verlist list V has been partitioned (coord X)</h1>
<p>Syntax: F = forceHertz(X,[,V,config,verbose])<br/>[F,W,n] = forceHertz()</p>
<p>Inputs<br/>X: nX x 3 coordinates of atoms<br/>V: nX x 1 cell array (output of partitionVerletList)<br/>a partition is required<br/>V{i} should include all atoms which are not of the same type of i<br/>config: 2x1 structure array with fields<br/>R: radius<br/>E: elasticity modulus<br/>rho: density<br/>m: mass of the bead</p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>config = struct(&#x27;R&#x27;,{1 1},&#x27;E&#x27;,{1e6 1e6})</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>Output (single output provided):
F: nX x 3 vector of Hertz forces
with F{i} = mi x 3 forces</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>Outputs (two outputs provided):
F: nX x 1 Hertz force magnitudes
W: nX x 9 virial stress tensor (use reshape(W(i),3,3) to recover the matrix)
n: nX x 3 normal vectors</code></pre>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [F,Wout,nout] = forceHertz(X,V,config,verbose)
<span class="comment">%FORCEHERTZ calculates Hertz contact forces <span class="keyword">for</span> all atoms assuming that the Verlist list V has been partitioned (coord X)</span>
<span class="comment">%</span>
<span class="comment">%   Syntax: F = forceHertz(X,[,V,config,verbose])</span>
<span class="comment">%           [F,W,n] = forceHertz()</span>
<span class="comment">%</span>
<span class="comment">%   Inputs</span>
<span class="comment">%        X: nX x 3 coordinates of atoms</span>
<span class="comment">%        V: nX x 1 cell array (output of partitionVerletList)</span>
<span class="comment">%           a partition is required</span>
<span class="comment">%           V{i} should include all atoms which are not of the same type of i</span>
<span class="comment">%   config: 2x1 structure array with fields</span>
<span class="comment">%           R: radius</span>
<span class="comment">%           E: elasticity modulus</span>
<span class="comment">%         rho: density</span>
<span class="comment">%           m: mass of the bead</span>
<span class="comment">%</span>
<span class="comment">%           example: config = struct(<span class="string">'R'</span>,{1 1},<span class="string">'E'</span>,{1e6 1e6})</span>
<span class="comment">%</span>
<span class="comment">%   Output (single output provided):</span>
<span class="comment">%       F: nX x 3 vector of Hertz forces</span>
<span class="comment">%            with F{i} = mi x 3 forces</span>
<span class="comment">%</span>
<span class="comment">%   Outputs (two outputs provided):</span>
<span class="comment">%       F: nX x 1 Hertz force magnitudes</span>
<span class="comment">%       W: nX x 9 virial stress tensor (use reshape(W(i),3,3) to recover the matrix)</span>
<span class="comment">%       n: nX x 3 normal vectors</span>

<span class="comment">% MS 3.0 | 2023-04-02 | INRAE\Olivier.vitrac@agroparistech.fr | rev. 2023-09-13</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-04-02 rename forceHertz into forceHertzAB, to avoid the confusion with the new forceHertz</span>
<span class="comment">% 2023-04-03 WJ. update the force Hertz equation to that as set in the SMD source code of LAMMPS:</span>
<span class="comment">%            lammps-2022-10-04/src/MACHDYN/pair_smd_hertz.cpp ln. 169</span>
<span class="comment">% 2023-04-03 WJ. add an additional delta calculation step</span>
<span class="comment">% 2023-09-07 add W (virial stress)</span>
<span class="comment">% 2023-09-09 local virial stress fixed to match https://doi.org/10.1016/j.cplett.2019.07.008</span>
<span class="comment">% 2023-09-13 update to match new rules and fixes from forceLandshoff </span>


<span class="comment">%% Check arguments</span>
<span class="keyword">if</span> nargin<1, X = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, V = []; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(X), error(<span class="string">'one table is at least required with '</span><span class="string">'x'</span><span class="string">','</span><span class="string">'y'</span><span class="string">','</span><span class="string">'z'</span><span class="string">','</span><span class="string">'type'</span><span class="string">' columns'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> istable(X)
    typ = X.type;
    <span class="keyword">if</span> isempty(V)
        V =  partitionVerletList(buildVerletList(X),typ);
    <span class="keyword">end</span>
    vol = X.c_vol;
    X = table2array(X(:,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>}));
<span class="keyword">else</span>
    vol = [];
<span class="keyword">end</span>
classX = class(X);
<span class="keyword">if</span> nargin<3, config = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, verbose = []; <span class="keyword">end</span>
<span class="keyword">if</span> isnumeric(V) && ~isnan(V) && length(V)==1
    error(<span class="string">'a partioned Verletlist is required'</span>);
<span class="keyword">end</span>
<span class="keyword">if</span> ~isstruct(config), error(<span class="string">'config must be a structure'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> ~isfield(config,<span class="string">'R'</span>), error(<span class="string">'the field R is missing'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> ~isfield(config,<span class="string">'E'</span>), error(<span class="string">'the field E is missing'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> length(config)==1, config = repmat(config,[2,1]); <span class="keyword">end</span>
<span class="keyword">if</span> length(config)~=2, error(<span class="string">'config must be a 2x1 structure array'</span>), <span class="keyword">end</span>
[nX,dX] = size(X);
<span class="keyword">if</span> length(V)~=nX, error(<span class="string">'V must be a <span class="comment">%d cell array created with buildVerletList()'</span>,nX), <span class="keyword">end</span></span>
verbosedefault = nX > 1e7;
<span class="keyword">if</span> isempty(verbose), verbose = verbosedefault; <span class="keyword">end</span>
askvirialstress = (nargout==2);

<span class="keyword">if</span> askvirialstress
    <span class="comment">%<span class="keyword">if</span> ~isfield(config,<span class="string">'rho'</span>), error(<span class="string">'the field rho is missing'</span>), <span class="keyword">end</span></span>
    <span class="comment">%<span class="keyword">if</span> ~isfield(config,<span class="string">'m'</span>), error(<span class="string">'the field m is missing'</span>), <span class="keyword">end</span></span>
    <span class="comment">%<span class="keyword">if</span> ~isfield(config,<span class="string">'h'</span>), error(<span class="string">'the field h is missing'</span>), <span class="keyword">end</span></span>
    <span class="comment">%volmin = mean([config.m],<span class="string">'omitnan'</span>)/mean([config.rho],<span class="string">'omitnan'</span>);</span>
    <span class="comment">%hmean = mean([config.h],<span class="string">'omitnan'</span>);</span>
    <span class="comment">%vol = 4/3 * pi * hmean^3;</span>
    <span class="comment">%<span class="keyword">if</span> vol<volmin, error(<span class="string">'the value of h (%0.4g) leads to a volume smaller than atoms (%0.4g)'</span>,hmean,volmin), <span class="keyword">end</span></span>
    <span class="keyword">if</span> isempty(vol)
        <span class="keyword">if</span> ~isfield(config,<span class="string">'vol'</span>), error(<span class="string">'the field vol is missing'</span>), <span class="keyword">end</span>
        vol = mean([config.vol],<span class="string">'omitnan'</span>);
    <span class="keyword">end</span>
    <span class="keyword">if</span> numel(vol)==1, vol = vol * ones(nX,1,classX); <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% verbosity</span>
<span class="keyword">if</span> verbose
    t0_ = clock; <span class="comment">%#ok<CLOCK> </span>
    t1_ = t0_;
    screen = <span class="string">''</span>;
    <span class="keyword">if</span> askvirialstress
        dispf(<span class="string">'Calculate Hertz contact forces + virial stress between [<span class="comment">%d x %d] ATOMS...'</span>,nX,dX)</span>
    <span class="keyword">else</span>
        dispf(<span class="string">'Calculate Hertz contact forces between [<span class="comment">%d x %d] ATOMS...'</span>,nX,dX)</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% Evaluate forces</span>

<span class="comment">% parameters</span>
E = sqrt(config(1).E*config(2).E); <span class="comment">% Bertholet formula</span>
rcut = config(1).R + config(2).R; 

<span class="comment">% allocate</span>
F = zeros(nX,1,classX);
n = zeros(nX,dX,classX);

<span class="comment">% <span class="keyword">for</span> virial stress calculation;</span>

<span class="keyword">if</span> askvirialstress
    W = zeros(nX,dX*dX,classX);
<span class="keyword">else</span>
    W = [];
<span class="keyword">end</span>
stresstensor = zeros(dX,dX,classX);

<span class="comment">% <span class="keyword">for</span> all atoms</span>
<span class="keyword">for</span> i=1:nX
    
    j = V{i}; <span class="comment">% neighbors of i</span>
    <span class="keyword">if</span> any(j) <span class="comment">% <span class="keyword">if</span> any neighbor of other type</span>
        rij = X(i,:) - X(j,:);    <span class="comment">% position vector j->i</span>
        rij2 = dot(rij,rij,2);    <span class="comment">% dot(rij,rij,2)</span>
        rij_d = sqrt(rij2);       <span class="comment">% norm</span>
        rij_n = rij ./ rij_d;     <span class="comment">% normalized vector</span>
        iscontact = rij_d < rcut;
        stresstensor(:) = 0;
        <span class="keyword">if</span> any(iscontact) <span class="comment">% <span class="keyword">if</span> they are contact</span>
            <span class="comment">%Fij = E * sqrt((rcut-rij_d(iscontact))*config(1).R*config(2).R/rcut) .* rij_n(iscontact,:);</span>
            <span class="comment">% formula as set in the SMD source code of LAMMPS: lammps-2022-10-04/src/MACHDYN/pair_smd_hertz.cpp ln. 169</span>
            delta = rcut-rij_d(iscontact);
            r_geom = config(1).R*config(2).R/rcut;
            bulkmodulus = E/(3*(1-2*0.25));
            Fij = 1.066666667 * bulkmodulus * delta .* sqrt(delta * r_geom).* rij_n(iscontact,:); <span class="comment">% units N</span>
            Fbalance = sum(Fij,1);
            F(i) = norm(Fbalance);
            n(i,:) = Fbalance/F(i);
            <span class="keyword">if</span> askvirialstress
                stresstensor(:) = 0;
                <span class="keyword">for</span> ineigh = 1:length(find(iscontact))
                    <span class="comment">% -rij<span class="string">' * Fij is the outerproduct (source: doi:10.1016/j.ijsolstr.2008.03.016)</span>
                    stresstensor = stresstensor -rij(ineigh,:)'</span> * Fij(ineigh,:);
                <span class="keyword">end</span>
                W(i,:) = stresstensor(:)<span class="string">'/ (2*vol(i)); <span class="comment">% origin of 2 ?? in this <span class="keyword">case</span> (since j-->i not considered);</span>
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            n(i,:) = sum(rij_n,1);
        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">% <span class="keyword">if</span> any neighbor of other type</span>

    <span class="comment">% verbosity</span>
    t_ = clock; <span class="comment">%#ok<CLOCK></span>
    <span class="keyword">if</span> verbose && (mod(i,1000)==0 || (etime(t_,t1_)>0.5))  <span class="comment">%#ok<*DETIM></span>
        t1_=t_; dt_ = etime(t_,t0_); done_ = i/nX;
        screen = dispb(screen,'</span>[atom <span class="comment">%d:%d] FORCE Hertz Contacts | elapsed %0.1f s | done %0.1f %% | remaining %0.1f s<span class="string">', ...</span>
            i,nX,dt_,100*done_,(1/done_-1)*dt_);
    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">%% outputs</span>
<span class="keyword">if</span> nargout>1, Wout = W; <span class="keyword">end</span>
<span class="keyword">if</span> nargout>2
    nout = n;
<span class="keyword">else</span>
    F = F .* n;
<span class="keyword">end</span>


<span class="comment">%% verbosity</span>
<span class="keyword">if</span> verbose
    <span class="keyword">if</span> askvirialstress
         dispb('</span>\t ... done with virial stress in <span class="comment">%0.3g s <span class="keyword">for</span> %d ATOMS<span class="string">',etime(clock,t0_),nX); %#ok<CLOCK></span>
    <span class="keyword">else</span>
        dispb('</span>\t ... done in <span class="comment">%0.3g s <span class="keyword">for</span> %d ATOMS',etime(clock,t0_),nX); %#ok<CLOCK></span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='forceHertzAB' class='doc-content' style='display: none;'>
<h1>FORCEHERTZAB calculates Hertz contact forces between atoms A (coord XA) and B (coord B)</h1>
<p>Syntax: FAB = forceHertzAB(XA,XB,config)<br/>[FAB,nAB] = forceHertzAB(...)</p>
<p>Inputs:<br/>XA: nA x 3 coordinates of atoms A<br/>XB: nB x 3 coordinates of atoms B<br/>config: 2x1 structure array with fields<br/>R: radius<br/>E: elasticity modulus</p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>config = struct(&#x27;R&#x27;,{1 1},&#x27;E&#x27;,{1e6 1e6})</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>Outputs (single output provided):
FAB: (nA*nB) x 3 Hertz forces</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>Outputs (two outputs provided):
FAB: (nA*nB) x 1 vector of force magnitudes
nAB: (nA*nB) x 3 coordinates of unitary direction vectors AB</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>TODO list
The code is vectorized and may generate an Overflow/OutOfMemory error
an iterative version with automatic switch must be implemented</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>See also</h2>
<p><a href="#forceHertz">forceHertz</a>, <a href="#forceLandshoff">forceLandshoff</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [FAB,nAB] = forceHertzAB(XA,XB,config,verbose)
<span class="comment">%FORCEHERTZAB calculates Hertz contact forces between atoms A (coord XA) and B (coord B)</span>
<span class="comment">%</span>
<span class="comment">%   Syntax: FAB = forceHertzAB(XA,XB,config)</span>
<span class="comment">%           [FAB,nAB] = forceHertzAB(...)</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%       XA: nA x 3 coordinates of atoms A</span>
<span class="comment">%       XB: nB x 3 coordinates of atoms B</span>
<span class="comment">%   config: 2x1 structure array with fields</span>
<span class="comment">%           R: radius</span>
<span class="comment">%           E: elasticity modulus</span>
<span class="comment">%           example: config = struct(<span class="string">'R'</span>,{1 1},<span class="string">'E'</span>,{1e6 1e6})</span>
<span class="comment">%</span>
<span class="comment">%   Outputs (single output provided):</span>
<span class="comment">%       FAB: (nA*nB) x 3 Hertz forces</span>
<span class="comment">%</span>
<span class="comment">%   Outputs (two outputs provided):</span>
<span class="comment">%       FAB: (nA*nB) x 1 vector of force magnitudes</span>
<span class="comment">%       nAB: (nA*nB) x 3 coordinates of unitary direction vectors AB</span>
<span class="comment">%</span>
<span class="comment">%   TODO list</span>
<span class="comment">%       The code is vectorized and may generate an Overflow/OutOfMemory error</span>
<span class="comment">%       an iterative version with automatic <span class="keyword">switch</span> must be implemented</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: forceHertz, forceLandshoff</span>


<span class="comment">% MS 3.0 | 2023-03-25 | INRAE\Olivier.vitrac@agroparistech.fr | rev.</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-04-02 rename forceHertz into forceHertzAB, to avoid the confusion with the new forceHertz</span>
<span class="comment">% 2023-04-03 WJ. update the force Hertz equation to that as set in the SMD source code of LAMMPS:</span>
<span class="comment">%            lammps-2022-10-04/src/MACHDYN/pair_smd_hertz.cpp ln. 169</span>
<span class="comment">% 2023-04-03 WJ. add an additional delta calculation step</span>
<span class="comment">% 2023-04-03 WJ. wrap particles along the x direction</span>



<span class="comment">%% Check arguments</span>
<span class="keyword">if</span> nargin<3, error(<span class="string">'3 inputs are required: [FAB,nAB] = forceHertz(XA,XB,config)'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, verbose = []; <span class="keyword">end</span>
<span class="keyword">if</span> ~isstruct(config), error(<span class="string">'config must be a structure'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> ~isfield(config,<span class="string">'R'</span>), error(<span class="string">'the field R is missing'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> ~isfield(config,<span class="string">'E'</span>), error(<span class="string">'the field E is missing'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> length(config)==1, config = repmat(config,[2,1]); <span class="keyword">end</span>
<span class="keyword">if</span> length(config)~=2, error(<span class="string">'config must be a 2x1 structure array'</span>), <span class="keyword">end</span>
[nA,dA] = size(XA);
[nB,dB] = size(XB);
<span class="keyword">if</span> dA ~= dB, error(<span class="string">'the number of dimensions of XA (<span class="comment">%d) and XB (%d) are not compatible'</span>,dA,dB), <span class="keyword">end</span></span>
<span class="keyword">if</span> dA~=3 || dB~=3, warning(<span class="string">'the number of dimensions (<span class="comment">%d) are not standard'</span>,dA), <span class="keyword">end</span></span>
verbosedefault = nA * nB>1e7;
<span class="keyword">if</span> isempty(verbose), verbose = verbosedefault; <span class="keyword">end</span>

<span class="comment">%% Evaluate all AB vectors (full vectorized code)</span>
<span class="comment">% all B-A combinations are calculated</span>
<span class="comment">% note that the classes are preserved (single is recommended)</span>
<span class="keyword">if</span> verbose
    t0 = clock; <span class="comment">%#ok<CLOCK> </span>
    dispf(<span class="string">'Calculate Hertz contact forces between [<span class="comment">%d x %d] and [%d x %d] atoms...'</span>,nA,dA,nB,dB)</span>
<span class="keyword">end</span>
AB = reshape(   bsxfun(@minus,... the operation B-A is done within the builtin bsxfun
                reshape(XB,1,nB,dB),...  B values are placed column-wise
                reshape(XA,nA,1,dA)),... A values are placed row-wise
                nA*nB,3); <span class="comment">% note that bsxfun will expand implicitely dimensions 1 and 2</span>
<span class="comment">% wrap coordinates at the edges of the 2 mm box</span>
iswrapcontactpositive = AB(:,1)>0.002-(config(1).R + config(2).R);
iswrapcontactnegative = AB(:,1)<-0.002+(config(1).R + config(2).R);
ABwrappositive = AB(iswrapcontactpositive,:);
ABwrappositive(:,1) = ABwrappositive(:,1) - 0.002;
ABwrapnegative = AB(iswrapcontactnegative,:);
ABwrapnegative(:,1) = ABwrapnegative(:,1) + 0.002;
AB = vertcat(AB, ABwrappositive);
AB = vertcat(AB, ABwrapnegative);
rAB = sqrt(sum(AB.^2,2)); <span class="comment">% distances AB</span>
AB = AB./rAB; <span class="comment">% normalized vectors</span>
<span class="comment">% n.b. data <span class="keyword">for</span> the simulation box needed <span class="keyword">for</span> a more generic wrap implementation</span>

<span class="comment">%% Evaluated forces</span>
E = sqrt(config(1).E*config(2).E); <span class="comment">% Bertholet formula</span>
rcut = config(1).R + config(2).R;  <span class="comment">% cut distance</span>
FAB = zeros(length(AB),1,class(AB));    <span class="comment">% preallocate</span>
iscontact = rAB<rcut;               <span class="comment">% true <span class="keyword">if</span> contact, false <span class="keyword">otherwise</span></span>
<span class="comment">% formula as set in the slide of Billy</span>
<span class="comment">% FAB(iscontact) = E * sqrt((rcut-rAB(iscontact))*config(1).R*config(2).R/rcut);</span>
<span class="comment">% formula as set in the SMD source code of LAMMPS: lammps-2022-10-04/src/MACHDYN/pair_smd_hertz.cpp ln. 169</span>
delta = rcut-rAB(iscontact);
r_geom = config(1).R*config(2).R/rcut;
bulkmodulus = E/(3*(1-2*0.25));
FAB(iscontact) = 1.066666667 * bulkmodulus * delta .* sqrt(delta * r_geom); <span class="comment">% units N</span>

<span class="comment">%% Output management</span>
<span class="keyword">if</span> nargout>1
    nAB = AB;
<span class="keyword">else</span>
    FAB = FAB .* AB;
<span class="keyword">end</span>
<span class="keyword">if</span> verbose
    dispf(<span class="string">'\t ... done in <span class="comment">%0.3g s'</span>,etime(clock,t0)) %#ok<DETIM,CLOCK></span>
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='forceLandshoff' class='doc-content' style='display: none;'>
<h1>FORCELANDSHOFF calculates Landshoff forces between fluid atoms (coord X, Verlist list V)</h1>
<p>Syntax: F = forceLandshoff(X,vX [,V,config,verbose])<br/>[F,W,n] = forceLandshoff()</p>
<p>Inputs<br/>X: nX x 3 coordinates of atoms<br/>vX: nX x 3 velocity components<br/>V: nX x 1 cell array (output of buildVerletList)<br/>with V{i} = 1 x mi index of neighbors (mi = number of neighbors within the cutoff distance)<br/>config: structure with fields<br/>gradkernel: gradient kernel (default value = kernelSPH(h,&#x27;lucyder&#x27;,3))<br/>it anonymous function depending only the radial distance r @(r)...., not on h<br/>h: smoothing length<br/>c0: speed of the sound<br/>q1: q1 coefficient<br/>rho: density (default value based on X.c_rho_smd if X is a table, 1000 otherwise)<br/>mass: mass of the bead (default value based on X.mass if X is a table, 1 otherwise)<br/>vol: volume of the bead (default value based on X.c_vol if X is a table, 1 otherwise)</p>
<p>Output (single output provided):<br/>F: nX x 3 vector of Landshoff forces<br/>with F{i} = mi x 3 forces</p>
<p>Outputs (two outputs provided):<br/>F: nX x 1 Landshoff force magnitudes<br/>W: nX x 9 virial stress tensor (use reshape(W(i),3,3) to recover the matrix)<br/>n: nX x 3 normal vectors</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [F,Wout,nout] = forceLandshoff(X,vX,V,config,verbose)
<span class="comment">%FORCELANDSHOFF calculates Landshoff forces between fluid atoms (coord X, Verlist list V)</span>
<span class="comment">%</span>
<span class="comment">%   Syntax: F = forceLandshoff(X,vX [,V,config,verbose])</span>
<span class="comment">%           [F,W,n] = forceLandshoff()</span>
<span class="comment">%</span>
<span class="comment">%   Inputs</span>
<span class="comment">%        X: nX x 3 coordinates of atoms</span>
<span class="comment">%       vX: nX x 3 velocity components</span>
<span class="comment">%        V: nX x 1 cell array (output of buildVerletList)</span>
<span class="comment">%           with V{i} = 1 x mi index of neighbors (mi = number of neighbors within the cutoff distance)</span>
<span class="comment">%   config: structure with fields</span>
<span class="comment">%   gradkernel: gradient kernel (default value = kernelSPH(h,<span class="string">'lucyder'</span>,3))</span>
<span class="comment">%               it anonymous <span class="keyword">function</span> depending only the radial distance r @(r)...., not on h</span>
<span class="comment">%            h: smoothing length</span>
<span class="comment">%           c0: speed of the sound</span>
<span class="comment">%           q1: q1 coefficient</span>
<span class="comment">%          rho: density (default value based on X.c_rho_smd <span class="keyword">if</span> X is a table, 1000 <span class="keyword">otherwise</span>)</span>
<span class="comment">%         mass: mass of the bead (default value based on X.mass <span class="keyword">if</span> X is a table, 1 <span class="keyword">otherwise</span>)</span>
<span class="comment">%          vol: volume of the bead (default value based on X.c_vol <span class="keyword">if</span> X is a table, 1 <span class="keyword">otherwise</span>)</span>
<span class="comment">%</span>
<span class="comment">%   Output (single output provided):</span>
<span class="comment">%       F: nX x 3 vector of Landshoff forces</span>
<span class="comment">%            with F{i} = mi x 3 forces</span>
<span class="comment">%</span>
<span class="comment">%   Outputs (two outputs provided):</span>
<span class="comment">%       F: nX x 1 Landshoff force magnitudes</span>
<span class="comment">%       W: nX x 9 virial stress tensor (use reshape(W(i),3,3) to recover the matrix)</span>
<span class="comment">%       n: nX x 3 normal vectors</span>

<span class="comment">% MS 3.0 | 2023-03-31 | INRAE\Olivier.vitrac@agroparistech.fr | rev. 2024-03-30</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-04-01 sum forces instead of individual ones,accept X as a table</span>
<span class="comment">% 2023-04-02 fix summation bug </span>
<span class="comment">% 2023-09-04 add m, fix config fields check</span>
<span class="comment">% 2023-09-07 add W (virial stress)</span>
<span class="comment">% 2023-09-09 local virial stress fixed to match https://doi.org/10.1016/j.cplett.2019.07.008</span>
<span class="comment">% 2023-09-09 code acceleration</span>
<span class="comment">% 2023-09-11 prevent NaN <span class="keyword">if</span> the norm is 0 </span>
<span class="comment">% 2023-09-12 fix m^2 (ma*mb) instead of mb</span>
<span class="comment">% 2023-09-13 upgrade rho, mass, vol from X as a table, adhere to scheme from SPH_virial_stress in Billy<span class="string">'s thesis</span>
<span class="comment">% 2024-03-30 small control comments by OV</span>

<span class="comment">%% Default</span>
h_default = 60e-6; <span class="comment">% rough guess (to be adjusted with common value)</span>
config_default = struct( ...real dynamic viscosity: q1 * h * c0 * rho / 8 (2D) or 10 (3D) see Eq. 8.8 Monaghan, J. J. (2005). Smoothed particle hydrodynamics. Reports on Progress in Physics, 68(8), 1703–1759. doi:10.1088/0034-4885/68/8/r01 
   '</span>gradkernel<span class="string">', kernelSPH(h_default,'</span>lucyder<span class="string">',3),...<span class="comment">% kernel gradient (note that h is bound with the kernel)</span>
            '</span>h<span class="string">', h_default,...smoothing length
           '</span>c0<span class="string">',10,...        speed of the sound
           '</span>q1<span class="string">',1,...         constant
          '</span>rho<span class="string">', 1000, ...    fluid density
         '</span>mass<span class="string">', 1,...        bead weight
          '</span>vol<span class="string">', 1, ...       bead volume (uniquely <span class="keyword">for</span> virial stress)
'</span>repulsiononly<span class="string">', false ...    <span class="keyword">if</span> true, only Landshoff forces when dot(rij,vij)<0
    );
askvirialstress = (nargout==2);

<span class="comment">%% Check arguments</span>
<span class="keyword">if</span> nargin<1, X = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, vX = []; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(X), error('</span>one table is at least required with <span class="string">''</span>x<span class="string">''</span>,<span class="string">''</span>y<span class="string">''</span>,<span class="string">''</span>z<span class="string">''</span>,<span class="string">''</span>vx<span class="string">''</span>,<span class="string">''</span>vy<span class="string">''</span>,vz<span class="string">''</span> columns<span class="string">'), <span class="keyword">end</span>
<span class="keyword">if</span> istable(X)
    <span class="keyword">if</span> isempty(vX), vX = X{:,{'</span>vx<span class="string">','</span>vy<span class="string">','</span>vz<span class="string">'}}; <span class="keyword">end</span>
    config_default.mass = X.mass;
    config_default.vol = X.c_vol;
    config_default.rho = X.c_rho_smd;
    X = X{:,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}};
<span class="keyword">end</span>
classX = class(X);
<span class="keyword">if</span> isempty(vX), error('</span>2 inputs are required: [F,n] = forceHertz(X,vX)<span class="string">'), <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, V = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, config = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, verbose = []; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(V), V =  buildVerletList(X); <span class="keyword">end</span>
<span class="keyword">if</span> isnumeric(V) && ~isnan(V) && length(V)==1, V = buildVerletList(frame,V); <span class="keyword">end</span>
<span class="keyword">if</span> isempty(config), config = config_default; <span class="keyword">end</span>
<span class="keyword">for</span> f = fieldnames(config_default)'</span>
    <span class="keyword">if</span> ~isfield(config,f{1}) || isempty(config.(f{1}))
        config.(f{1}) = config_default.(f{1});
    <span class="keyword">end</span>
<span class="keyword">end</span>
[nX,dX] = size(X);
<span class="keyword">if</span> (size(vX,1)~=nX) || (size(vX,2)~=dX), error(<span class="string">'vX should be a <span class="comment">%d x %d array'</span>,nX,dX), <span class="keyword">end</span></span>
<span class="keyword">for</span> f = {<span class="string">'mass'</span>,<span class="string">'rho'</span>,<span class="string">'vol'</span>}
    <span class="keyword">if</span> numel(config.(f{1}))==1, config.(f{1})= config.(f{1})* ones(nX,1,classX); <span class="keyword">end</span>
    <span class="keyword">if</span> ~isa(config.(f{1}),classX), config.(f{1})= cast(config.(f{1}),classX); <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> length(V)~=nX, error(<span class="string">'V must be a <span class="comment">%d cell array created with buildVerletList()'</span>,nX), <span class="keyword">end</span></span>
verbosedefault = nX > 1e2;
<span class="keyword">if</span> isempty(verbose), verbose = verbosedefault; <span class="keyword">end</span>


<span class="comment">%% verbosity</span>
<span class="keyword">if</span> verbose
    t0_ = clock; <span class="comment">%#ok<CLOCK> </span>
    t1_ = t0_;
    screen = <span class="string">''</span>;
    <span class="keyword">if</span> askvirialstress
        dispf(<span class="string">'Calculate Landshoff forces + virial stress between [<span class="comment">%d x %d] ATOMS...'</span>,nX,dX)</span>
    <span class="keyword">else</span>
        dispf(<span class="string">'Calculate Landshoff forces between [<span class="comment">%d x %d] ATOMS...'</span>,nX,dX)</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% Evaluate forces (and stresses)</span>
<span class="comment">% the code is highly vectorized and use only one <span class="keyword">for</span> loop on primary atoms</span>
<span class="comment">% In the <span class="keyword">case</span> of shock tube problems, it is usual to turn the viscosity </span>
<span class="comment">% on <span class="keyword">for</span> approaching particles and turn it off <span class="keyword">for</span> receding particles. </span>
<span class="comment">% In this way, the viscosity is used <span class="keyword">for</span> shocks and not rarefactions.</span>
<span class="comment">% after Monaghan (2005), p 1741</span>
<span class="comment">% Source: https://cg.informatik.uni-freiburg.de/intern/seminar/animation%20-%20SPH%20survey%20-%202005.pdf</span>

<span class="comment">% allocate</span>
F = zeros(nX,1,classX);
n = zeros(nX,dX,classX);

<span class="comment">% <span class="keyword">for</span> virial stress calculation</span>
<span class="comment">% volmin = config.m/config.rho; % depreciated</span>
<span class="comment">% vol = 4/3 * pi * config.h^3;  % depreciated</span>
<span class="keyword">if</span> askvirialstress
    W = zeros(nX,dX*dX,classX);
    <span class="comment">%<span class="keyword">if</span> vol<volmin, error(<span class="string">'the value of h (%0.4g) leads to a volume smaller than atoms (%0.4g)'</span>,config.h,volmin), <span class="keyword">end</span></span>
<span class="keyword">else</span>
    W = [];
<span class="keyword">end</span>
stresstensor = zeros(dX,dX,classX);

<span class="comment">% <span class="keyword">for</span> all atoms</span>
<span class="comment">% reference formula https://docs.lammps.org/PDF/SPH_LAMMPS_userguide.pdf (page 7, Eqs 18, 19)</span>
q1c0h = config.q1 * config.c0 * config.h; <span class="comment">% q1 * c0 * h</span>
epsh = 0.01*config.h^2;   <span class="comment">% tolreance</span>
dmin = 0.1 * config.h;    <span class="comment">% minimim distance <span class="keyword">for</span> Landshoff</span>

<span class="keyword">for</span> i=1:nX

    j = V{i}; <span class="comment">% neighbors of i</span>
    mi = config.mass(i);
    rhoi = config.rho(i);
    rij = X(i,:) - X(j,:);    <span class="comment">% position vector j->i</span>
    rij2 = dot(rij,rij,2);    <span class="comment">% dot(rij,rij,2)</span>
    rij_d = sqrt(rij2);       <span class="comment">% norm</span>
    rij_n = rij ./ rij_d;     <span class="comment">% normalized vector</span>
    vij = vX(i,:) - vX(j,:);  <span class="comment">% relative velocity of i respectively to j</span>
    rvij = dot( rij, vij, 2); <span class="comment">% projected velocity</span>
    ok = rij_d>dmin;          <span class="comment">% added on 2023-09-13</span>
    <span class="keyword">if</span> config.repulsiononly, ok = ok & (rvij<0); <span class="keyword">end</span>
    <span class="keyword">if</span> any(ok)
        <span class="comment">% Reference Formulation - p1740 of Rep. Prog. Phys. 68 (2005) 1703–1759 (attention acceleration, not force)</span>
        <span class="comment">% http://dx.doi.org/10.1088/0034-4885/68/8/R01</span>
        <span class="comment">% before 2023-09-09</span>
        <span class="comment">%muij = config.h * rvij(ok) ./ ( rij2(ok) + 0.01*config.h^2 );</span>
        <span class="comment">%nuij = (1/config.rho) * (-config.q1 * config.c0 * muij);</span>
        <span class="comment">%Fij = - config.m^2 * nuij .* config.gradkernel(rij_d(ok)) .* rij_n(ok,:);</span>
        <span class="comment">% after 2023-09-09</span>
        mj = config.mass(j(ok));
        rhoj = config.rho(j(ok));
        rhoij = 0.5 * (rhoi+rhoj);
        muij = rvij(ok) ./ ( rij2(ok) + epsh );
        Fij = q1c0h * mi * mj./rhoij .* muij .* config.gradkernel(rij_d(ok)) .* rij_n(ok,:);
        Fbalance = sum(Fij,1);
        F(i) = norm(Fbalance);
        <span class="keyword">if</span> F(i)>0, n(i,:) = Fbalance/F(i); <span class="keyword">end</span>
        <span class="keyword">if</span> askvirialstress
            stresstensor(:) = 0;
            <span class="keyword">for</span> ineigh = 1:length(find(ok))
                <span class="comment">% -rij<span class="string">' * Fij is the outerproduct (source: doi:10.1016/j.ijsolstr.2008.03.016)</span>
                stresstensor = stresstensor -rij(ineigh,:)'</span> * Fij(ineigh,:);
            <span class="keyword">end</span>
            W(i,:) = stresstensor(:)<span class="string">' / (2*config.vol(i)); <span class="comment">% origin of 2 ?? in this <span class="keyword">case</span> (since j-->i not considered)</span>
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        n(i,:) = sum(rij_n,1);
    <span class="keyword">end</span> <span class="comment">% <span class="keyword">if</span> any(ok)</span>

    <span class="comment">% verbosity</span>
    t_ = clock; <span class="comment">%#ok<CLOCK></span>
    <span class="keyword">if</span> verbose && (mod(i,1000)==0 || (etime(t_,t1_)>0.5))  <span class="comment">%#ok<*DETIM></span>
        t1_=t_; dt_ = etime(t_,t0_); done_ = i/nX;
        screen = dispb(screen,'</span>[atom <span class="comment">%d:%d] FORCE Landshoff | elapsed %0.1f s | done %0.1f %% | remaining %0.1f s<span class="string">', ...</span>
                               i,nX,dt_,100*done_,(1/done_-1)*dt_);
    <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">% next i</span>


<span class="comment">%% outputs</span>
<span class="keyword">if</span> nargout>1, Wout = W; <span class="keyword">end</span>
<span class="keyword">if</span> nargout>2
    nout = n;
<span class="keyword">else</span>
    F = F .* n;
<span class="keyword">end</span>


<span class="comment">%% verbosity</span>
<span class="keyword">if</span> verbose
    <span class="keyword">if</span> askvirialstress
        dispb(screen,'</span>\t ... done with virial stress in <span class="comment">%0.3g s <span class="keyword">for</span> %d atoms<span class="string">',etime(clock,t0_),nX); %#ok<CLOCK></span>
    <span class="keyword">else</span>
        dispf(screen,'</span>\t ... done in <span class="comment">%0.3g s <span class="keyword">for</span> %d ATOMS',etime(clock,t0_),nX); %#ok<CLOCK></span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='hourglassSPH' class='doc-content' style='display: none;'>
<h1>HOURGLASS calculates the total hourglss correction force according to Eq. 17-24 of Comput. Methods Appl. Mech. Engrg. 286 (2015) 87–106</h1>
<p>Syntax:<br/>out = hourglassSPH(X0,X,defgradSPHout)  &lt;--- syntax 1 (preferred)<br/>out = hourglassSPH(X0,X,F [,V, config, silent])  &lt;--- syntax 2</p>
<p>Inputs: (syntax 1)<br/>X0 : kxd coordinates of the kernel centers of reference configuration<br/>X : kxd coordinates of the kernel centers of deformed configuration<br/>defgradSPHout : ouput (structure) of defgradSPH</p>
<p>Inputs: (syntax 2)<br/>X0 : kxd coordinates of the kernel centers of reference configuration<br/>X : kxd coordinates of the kernel centers of deformed configuration<br/>F : k x d^2 deformation gradient<br/>f : k x d pairwise forces<br/>V : kx1 volume of the kernels (default=1)<br/>[] (empty matrix) or scalar value forces uniform volumes (default =1)<br/>forcesilent: flag to force silence mode (default = false)<br/>config: structure with fields coding for Lamé parameters<br/>lambda (default = 30 000 Pa)<br/>mu (default = 3000 Pa)</p>
<p>Output: out a structure with fields:<br/>F : k x d^2 deformation gradient<br/>C : k x d^2 Cauchy-Green deformation tensor<br/>E : k x d^2 Green-Lagrange strain tensor<br/>S : k x d^2 Second Piola-Kirchoff stress tensor replacing Cauchy stress (Elastic stress = config.lambda*trace(E) + 2*config.mu*E)<br/>P : k x d^2 First Piola-Kirchoff stress<br/>f : k x d pairwise forces<br/>G : k * d von Mises stress<br/>description : tensor description<br/>k,d,V,correctedgradW,config are also included<br/>engine : &#x27;hourglassSPH&#x27;</p>
<p>Refer to Ganzenmuller (2015) for details: https://doi.org/10.1016/j.cma.2014.12.005<br/>~/han/biblio/Ganzenmuller2015-Hourglass_control_algorithm.pdf</p>
<h2>See also</h2>
<p><a href="#defgradSPH">defgradSPH</a>, <a href="#shapeSPH">shapeSPH</a>, <a href="#interp2SPH">interp2SPH</a>, <a href="#interp3SPH">interp3SPH</a>, <a href="#kernelSPH">kernelSPH</a>, <a href="#packSPH">packSPH</a></p>
<h2>See also</h2>
<p></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> out = hourglassSPH(X0,X,W,defgradout,V,config,forcesilent)
<span class="comment">%HOURGLASS calculates the total hourglss correction force according to Eq. 17-24 of Comput. Methods Appl. Mech. Engrg. 286 (2015) 87–106</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       out = hourglassSPH(X0,X,defgradSPHout)  <--- syntax 1 (preferred)</span>
<span class="comment">%       out = hourglassSPH(X0,X,F [,V, config, silent])  <--- syntax 2</span>
<span class="comment">%</span>
<span class="comment">%   Inputs: (syntax 1)</span>
<span class="comment">%              X0 : kxd coordinates of the kernel centers of reference configuration</span>
<span class="comment">%               X : kxd coordinates of the kernel centers of deformed configuration</span>
<span class="comment">%   defgradSPHout : ouput (structure) of defgradSPH</span>
<span class="comment">%</span>
<span class="comment">%   Inputs: (syntax 2)</span>
<span class="comment">%              X0 : kxd coordinates of the kernel centers of reference configuration</span>
<span class="comment">%               X : kxd coordinates of the kernel centers of deformed configuration</span>
<span class="comment">%               F : k x d^2 deformation gradient</span>
<span class="comment">%               f : k x d pairwise forces</span>
<span class="comment">%               V : kx1 volume of the kernels (default=1)</span>
<span class="comment">%                   [] (empty matrix) or scalar value forces uniform volumes (default =1)</span>
<span class="comment">%      forcesilent: flag to force silence mode (default = false)</span>
<span class="comment">%           config: structure with fields coding <span class="keyword">for</span> Lamé parameters</span>
<span class="comment">%                   lambda (default = 30 000 Pa)</span>
<span class="comment">%                   mu (default = 3000 Pa)</span>
<span class="comment">%</span>
<span class="comment">%   Output: out a structure with fields:</span>
<span class="comment">%               F : k x d^2 deformation gradient</span>
<span class="comment">%               C : k x d^2 Cauchy-Green deformation tensor</span>
<span class="comment">%               E : k x d^2 Green-Lagrange strain tensor</span>
<span class="comment">%               S : k x d^2 Second Piola-Kirchoff stress tensor replacing Cauchy stress (Elastic stress = config.lambda*trace(E) + 2*config.mu*E)</span>
<span class="comment">%               P : k x d^2 First Piola-Kirchoff stress</span>
<span class="comment">%               f : k x d pairwise forces</span>
<span class="comment">%               G : k * d von Mises stress</span>
<span class="comment">%     description : tensor description</span>
<span class="comment">%           k,d,V,correctedgradW,config are also included</span>
<span class="comment">%          engine : <span class="string">'hourglassSPH'</span></span>
<span class="comment">%</span>
<span class="comment">%   Refer to Ganzenmuller (2015) <span class="keyword">for</span> details: https://doi.org/10.1016/j.cma.2014.12.005</span>
<span class="comment">%   ~/han/biblio/Ganzenmuller2015-Hourglass_control_algorithm.pdf</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: defgradSPH, shapeSPH, interp2SPH, interp3SPH, kernelSPH, packSPH</span>
<span class="comment">%</span>

<span class="comment">% 2023-10-31 | INRAE\Han CHEN | rev. 2023-11-15</span>

<span class="comment">%{</span>
<span class="comment">% Example:</span>
r = 0.5;
X0 = packSPH(5,r);
X0(sqrt(sum((X0-mean(X0,1)).^2,2))>4*r,:) = [];
[xs,ys,zs] = sphere(100);

<span class="comment">% Translate spheres to close-packed positions</span>
figure, hold on
<span class="keyword">for</span> i = 1:size(X0, 1), surf(xs*r + X0(i,1), ys*r + X0(i,2), zs*r + X0(i,3),<span class="string">'FaceColor'</span>,rgb(<span class="string">'deepskyblue'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>); <span class="keyword">end</span>
lighting gouraud, camlight left, shading interp, axis equal, view(3)

<span class="comment">% deformation (vertical compression + shearing)</span>
Xc = mean(X0,1); Xmin = min(X0,[],1); Xmax = max(X0,[],1)

<span class="comment">% compression along z, with support at zmin, compression rate = 20%</span>
X = X0; X(:,3) = 0.8*(X(:,3)-Xmin(1,3)) + Xmin(1,3);
<span class="comment">% shearing 20% along y</span>
X(:,2) = X(:,2) + 0.2 * (Xmax(1,2)-Xmin(1,2)) * (X(:,3)-Xmin(1,3))/(Xmax(1,3)-Xmin(1,3));

<span class="comment">% plot</span>
figure, hold on
<span class="keyword">for</span> i = 1:size(X, 1), surf(xs*r + X(i,1), ys*r + X(i,2), zs*r + X(i,3),<span class="string">'FaceColor'</span>,rgb(<span class="string">'deepskyblue'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>); <span class="keyword">end</span>
lighting gouraud, camlight left, shading interp, axis equal, view(3)

<span class="comment">% displacement</span>
u = X-X0;
<span class="comment">% shape matrix</span>
gradW = kernelSPH(2*r,<span class="string">'lucyder'</span>,3);
shapeout = shapeSPH(X0,gradW)
defgradout = defgradSPH(u,shapeout)

<span class="comment">% visualization</span>
figure, hold on
scatter3(X(:,1),X(:,2),X(:,3),40,defgradout.G)
f = defgradout.f; fn=sqrt(sum(f.^2,2)); f = f./fn;
f90 = prctile(fn,90); fn(fn>f90) = f90; f = f .* fn;
quiver3(X(:,1),X(:,2),X(:,3),f(:,1),f(:,2),f(:,3))
view(3)

<span class="comment">%hourglass force</span>
W = kernelSPH(2*r,<span class="string">'lucy'</span>,3);
fhgout = hourglassSPH(X0,X,W,defgradout);
figure, hold on
scatter3(X(:,1),X(:,2),X(:,3),40)
fhg= fhgout.fHG; fn=sqrt(sum(fhg.^2,2)); fhg = fhg./fn;
f90 = prctile(fn,90); fn(fn>f90) = f90; fhg = fhg .* fn;
quiver3(X(:,1),X(:,2),X(:,3),fhg(:,1),fhg(:,2),fhg(:,3))
view(3)
<span class="comment">%}</span>

<span class="comment">%Revision history</span>
<span class="comment">% 2023-11-15 alpha version</span>

<span class="comment">% Default Lamé parameters</span>
config_default = struct(...
    <span class="string">'lambda'</span>,3e4, ...first Lamé  parameter
    <span class="string">'mu'</span>,3e3, ... shear modulus (second Lamé parameter)
    <span class="string">'E'</span>,9e3, ... young<span class="string">'s modulus
    '</span>alpha<span class="string">',1 ... a dimensionless coefficient that controls the amplitude of hourglass correction
);

<span class="comment">%% arg check</span>
<span class="keyword">if</span> nargin<4, error('</span>4 arguments are required at least<span class="string">'), <span class="keyword">end</span>
[k,d] = size(X0); <span class="keyword">if</span> k==0, error('</span>please supply some displacements centers<span class="string">'), <span class="keyword">end</span>
<span class="keyword">if</span> isstruct(defgradout) && strcmpi(defgradout.engine,'</span>defragSPH<span class="string">') <span class="comment">% -- syntax 1: we reuse the arguments of shapeSPH</span>
    args = defgradout;
    <span class="keyword">if</span> (args.d~=d) || (args.k~=k), error('</span><span class="comment">%dx%d u is not compatible with previous %dx%d centers<span class="string">',k,d,args.k,args.d), <span class="keyword">end</span></span>
    F = args.F;
    f = args.f;
    V = args.V;
    config = args.config;
    <span class="keyword">for</span> fig = fieldnames(config_default)'</span>
        <span class="keyword">if</span> ~isfield(config,fig{1}) || isempty(config.(fig{1}))
            config.(fig{1}) = config_default.(fig{1});
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    forcesilent = args.forcesilent;
<span class="keyword">else</span> <span class="comment">% -- syntax 2</span>
    <span class="keyword">if</span> nargin<5, V = []; <span class="keyword">end</span>
    <span class="keyword">if</span> nargin<6, config = []; <span class="keyword">end</span>
    <span class="keyword">if</span> nargin<7, forcesilent = []; <span class="keyword">end</span>
    <span class="keyword">if</span> d>3, error(<span class="string">'3 dimensions maximum'</span>), <span class="keyword">end</span>
    kv = length(V);
    <span class="keyword">if</span> kv==0, V=1;  kv=1; <span class="keyword">end</span>
    <span class="keyword">if</span> kv==1, V = ones(k,1)*V; kv=k; <span class="keyword">end</span>
    <span class="keyword">if</span> kv~=k, error(<span class="string">'the number of V values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,kv,k); <span class="keyword">end</span></span>
    <span class="keyword">if</span> isempty(forcesilent), forcesilent = false; <span class="keyword">end</span>
    <span class="keyword">if</span> isempty(config), config = config_default; <span class="keyword">end</span>
    <span class="keyword">for</span> fig = fieldnames(config_default)<span class="string">'
        <span class="keyword">if</span> ~isfield(config,fig{1}) || isempty(config.(fig{1}))
            config.(fig{1}) = config_default.(fig{1});
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% initialization</span>
verbosity = (k>1e3) & ~forcesilent;
largek = k>200;
t0_ = clock; t1_=t0_; screen='</span><span class="string">'; 

<span class="comment">% vec2tensor: indices to convert a vector to a 2D tensor (faster than many reshapes)</span>
vec2tensor_reshape = reshape(1:d^2,d,d);
vec2tensor = @(x) x(vec2tensor_reshape);

<span class="comment">%% Output total hourglass correction force fHG</span>
fHG = zeros(k,d,class(f));
Xij = zeros(k,k,d);
xij = zeros(k,k,d);
Xij_d = zeros(k,k);
xij_d = zeros(k,k);
deltaij = zeros(k,k);
<span class="keyword">if</span> verbosity, dispf('</span>SHAPESPH calculate L correction matrix <span class="keyword">for</span> all <span class="comment">%d kernels (K) in %d dimensions...<span class="string">',k,d), <span class="keyword">end</span></span>
<span class="comment">% loop over all j <span class="keyword">for</span> summation</span>
<span class="keyword">for</span> j=1:k
    <span class="comment">% verbosity</span>
    <span class="keyword">if</span> verbosity
        <span class="keyword">if</span> largek
            t_ = clock; <span class="comment">%#ok<*CLOCK></span>
            <span class="keyword">if</span> mod(j,10)==0 || (etime(t_,t1_)>0.5) <span class="comment">%#ok<*DETIM> </span>
                t1_=t_;
                dt_ = etime(t_,t0_); done_ = j/k;
                screen = dispb(screen,'</span>[K<span class="comment">%d:%d] SHAPESPH | elapsed %0.1f s | done %0.1f %% | remaining %0.1f s<span class="string">', ...</span>
                               j,k,dt_,100*done_,(1/done_-1)*dt_);
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            dispf('</span>... SHAPESPH respectively to kernel <span class="comment">%d of %d<span class="string">',j,k);</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">for</span> i=1:k
        <span class="keyword">if</span> i~=j
            Fi = vec2tensor(F(i,:));
            Xij(i,j,:) = X0(j,:) - X0(i,:);
            Xij_d(i,j) = sqrt(dot(Xij(i,j,:),Xij(i,j,:)));
            xij(i,j,:) = X(j,:) - X(i,:);
            xij_d(i,j) = sqrt(dot(xij(i,j,:),xij(i,j,:)));
            xij_i = Fi*(X0(j,:) - X0(i,:))'</span>;
            deltaij(i,j) = (xij_i<span class="string">' - (X(j,:) - X(i,:))) * xij_i / xij_d(i,j);
        <span class="keyword">end</span> 
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">for</span> i = 1:k
    <span class="keyword">for</span> j = 1:k
        <span class="keyword">if</span> j~=i
            coef = - 0.5*config.alpha*V(i)*V(j)*W(Xij(i,j));
            fHG(i,:) = fHG(i,:) + squeeze(coef*config.E*(deltaij(i,j)+deltaij(j,i))*xij(i,j,:)/(Xij_d(i,j)^2*xij_d(i,j)))'</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% verbosity</span>
<span class="keyword">if</span> verbosity
    dispb(screen,<span class="string">'DEFRAGSPH <span class="comment">%d L matrix calculated in %0.4g s'</span>,k,etime(clock,t0_));</span>
<span class="keyword">end</span>

<span class="comment">% collect all outputs</span>
description = struct(...
        <span class="string">'fHG'</span>,<span class="string">'hourglass correction force'</span>...
         );
out = struct( ...
    <span class="string">'k'</span>,k,<span class="string">'d'</span>,d,<span class="string">'V'</span>,V,<span class="string">'fHG'</span>,fHG,...
    <span class="string">'description'</span>,description,<span class="string">'engine'</span>,<span class="string">'hourglassSPH'</span>,<span class="string">'forcesilent'</span>,forcesilent);



</code></pre></div>
</div>
<div id='interp2SPH' class='doc-content' style='display: none;'>
<h1>INTERP2SPH interpolates y at Xq,Yq using the 2D kernel W centered on centers</h1>
<p>Syntax:<br/>Vq = interp2SPH(X,y,Xq,Yq [,W,V])</p>
<p>Inputs:<br/>centers : kx2 coordinates of the kernel centers<br/>y : kxny values at X (m is the number of values associated with the same center)<br/>[] (empty matrix) forces a uniform density calculatoin<br/>Xq : array or matrix coordinates along X<br/>Yq : array or matrix coordinates along Y<br/>W : kernel function @(r) &lt;-- use kernelSPH() to supply a vectorized kernel<br/>V : kx1 volume of the kernels (default=1)<br/>[] (empty matrix) or scalar value forces uniform volumes (default =1)<br/>forcesilent: flag to force silence mode (default = false)</p>
<p>Output:<br/>Vq : same size as Xq, with an additional dimension if y was an array</p>
<h2>See also</h2>
<p><a href="#interp3SPH">interp3SPH</a>, <a href="#kernelSPH">kernelSPH</a>, <a href="#packSPH">packSPH</a></p>
<h2>See also</h2>
<p></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> Vq = interp2SPH(centers,y,Xq,Yq,W,V,forcesilent)
<span class="comment">% INTERP2SPH interpolates y at Xq,Yq using the 2D kernel W centered on centers</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       Vq = interp2SPH(X,y,Xq,Yq [,W,V])</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%     centers : kx2 coordinates of the kernel centers</span>
<span class="comment">%           y : kxny values at X (m is the number of values associated with the same center)</span>
<span class="comment">%               [] (empty matrix) forces a uniform density calculatoin</span>
<span class="comment">%          Xq : array or matrix coordinates along X</span>
<span class="comment">%          Yq : array or matrix coordinates along Y</span>
<span class="comment">%           W : kernel <span class="keyword">function</span> @(r) <-- use kernelSPH() to supply a vectorized kernel</span>
<span class="comment">%           V : kx1 volume of the kernels (default=1)</span>
<span class="comment">%               [] (empty matrix) or scalar value forces uniform volumes (default =1)</span>
<span class="comment">%  forcesilent: flag to force silence mode (default = false)</span>
<span class="comment">%</span>
<span class="comment">%   Output:</span>
<span class="comment">%           Vq : same size as Xq, with an additional dimension <span class="keyword">if</span> y was an array</span>
<span class="comment">%</span>
<span class="comment">%   See also: interp3SPH, kernelSPH, packSPH</span>
<span class="comment">%</span>

<span class="comment">% 2023-02-20 | INRAE\Olivier Vitrac | rev. 2024-03-18</span>

<span class="comment">%Revision history</span>
<span class="comment">% 2023-10-30 remove Zq from the input variables</span>
<span class="comment">% 2024-03-18 fixes <span class="keyword">for</span> production</span>

<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<1, centers = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, y = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, Xq = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, Yq = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, W = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<6, V = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<7, forcesilent = []; <span class="keyword">end</span>
[k,d] = size(centers);
[ky,ny] = size(y);
kv = length(V);
<span class="keyword">if</span> k==0, error(<span class="string">'please supply some centers'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> d~=2, error(<span class="string">'2 dimensions (columns) are required'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> ky*ny==0, y = ones(k,1); ky=k; ny=1; <span class="keyword">end</span>
<span class="keyword">if</span> ky~=k, error(<span class="string">'the number of y values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,ky,k), <span class="keyword">end</span></span>
<span class="keyword">if</span> ~isequal(size(Xq),size(Yq)), error(<span class="string">'Xq,Yq and Zq do not have compatible sizes'</span>), <span class="keyword">end</span> 
<span class="keyword">if</span> kv==0, V=1;  kv=1; <span class="keyword">end</span>
<span class="keyword">if</span> kv==1, V = ones(k,1)*V; kv=k; <span class="keyword">end</span>
<span class="keyword">if</span> kv~=k, error(<span class="string">'the number of V values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,kv,k); <span class="keyword">end</span></span>
<span class="keyword">if</span> isempty(forcesilent), forcesilent=false; <span class="keyword">end</span>
fmtsize = @(array) sprintf([repmat(<span class="string">'<span class="comment">%d x '</span>, 1, ndims(array)-1), <span class="string">'%d'</span>], size(array));</span>

<span class="comment">% main</span>
sumW = cell(1,ny);
verbosity = numel(Xq)>1e4;
largek = k>200;
t0_ = clock; t1_=t0_; screen=<span class="string">''</span>; <span class="comment">%#ok<CLOCK,NASGU></span>

<span class="keyword">if</span> verbosity, dispf(<span class="string">'INTPER2SPH is summing <span class="comment">%s grid values over %d kernels (K)...'</span>,fmtsize(Xq),k), <span class="keyword">end</span></span>
<span class="keyword">for</span> i=1:k
    <span class="comment">% initialization <span class="keyword">if</span> needed</span>
    <span class="keyword">if</span> i==1
        <span class="keyword">for</span> iy=1:ny
            sumW{iy} = zeros(size(Xq),class(Xq));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
        <span class="comment">% verbosity</span>
    <span class="keyword">if</span> verbosity
        <span class="keyword">if</span> largek
            t_ = clock;
            <span class="keyword">if</span> mod(i,500)==0 || (etime(t_,t1_)>0.5) <span class="comment">%#ok<*DETIM> </span>
                t1_=t_;
                dt_ = etime(t_,t0_); done_ = i/k;
                screen = dispb(screen,<span class="string">'[K<span class="comment">%d:%d] INTERP2SPH | elapsed %0.1f s | done %0.1f %% | remaining %0.1f s'</span>, ...</span>
                               i,k,dt_,100*done_,(1/done_-1)*dt_);
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            dispf(<span class="string">'... interpolate respectively to kernel <span class="comment">%d of %d'</span>,i,k);</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% interpolation</span>
    R = sqrt( (Xq-centers(i,1)).^2 + (Yq-centers(i,2)).^2  );
    <span class="keyword">for</span> iy = 1:ny
        sumW{iy} = sumW{iy} + y(i,iy) * V(i) * W(R);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% output</span>
<span class="keyword">if</span> ny==1
    Vq = sumW{1};
<span class="keyword">else</span>
    Vq = cat(ndims(Xq)+1,sumW{:});
<span class="keyword">end</span>

<span class="comment">% verbosity</span>
<span class="keyword">if</span> verbosity
    dispb(screen,<span class="string">'done in . INTERP2SPH interpolated <span class="comment">%s grid points with %d kernels in %0.4g s'</span>, ...</span>
                               etime(clock,t0_),fmtsize(Xq),k);
<span class="keyword">end</span></code></pre></div>
</div>
<div id='interp2SPHVerlet' class='doc-content' style='display: none;'>
<h1>INTERP2SPHVerlet interpolates y at XYgrid using the GridVerletList and the 2D kernel W centered on XY</h1>
<p>Vgrid = interp2SPHVerlet(XY,y,XYgrid,GridVerletList [,W,V])</p>
<p>Inputs:<br/>XY : kx2 coordinates of the kernel centers<br/>y : kxny values at XY (m is the number of values associated with the same center)<br/>[] (empty matrix) forces a uniform density calculatoin<br/>XYgrid : gx2 grid coordinates<br/>GridVerletList : VerletList of the grid<br/>W : kernel function @(r) &lt;-- use kernelSPH() to supply a vectorized kernel<br/>V : kx1 volume of the kernels (default=1)<br/>[] (empty matrix) or scalar value forces uniform volumes (default =1)</p>
<p>Output:<br/>Vgrid : gxny array</p>
<h2>See also</h2>
<p><a href="#buildVerletList">buildVerletList</a>, <a href="#interp3SPH">interp3SPH</a>, <a href="#interp3SPHVerlet">interp3SPHVerlet</a>, <a href="#interp2SPH">interp2SPH</a>, <a href="#kernelSPH">kernelSPH</a>, <a href="#packSPH">packSPH</a>, virialStress</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> Vq = interp2SPHVerlet(XY,y,XYgrid,GridVerletList,W,V)
<span class="comment">% INTERP2SPHVerlet interpolates y at XYgrid using the GridVerletList and the 2D kernel W centered on XY</span>
<span class="comment">%</span>
<span class="comment">%       Vgrid = interp2SPHVerlet(XY,y,XYgrid,GridVerletList [,W,V])</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%             XY : kx2 coordinates of the kernel centers</span>
<span class="comment">%              y : kxny values at XY (m is the number of values associated with the same center)</span>
<span class="comment">%                  [] (empty matrix) forces a uniform density calculatoin</span>
<span class="comment">%         XYgrid : gx2 grid coordinates</span>
<span class="comment">% GridVerletList : VerletList of the grid</span>
<span class="comment">%              W : kernel <span class="keyword">function</span> @(r) <-- use kernelSPH() to supply a vectorized kernel</span>
<span class="comment">%              V : kx1 volume of the kernels (default=1)</span>
<span class="comment">%                  [] (empty matrix) or scalar value forces uniform volumes (default =1)</span>
<span class="comment">%</span>
<span class="comment">%   Output:</span>
<span class="comment">%       Vgrid : gxny array</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: buildVerletList, interp3SPH, interp3SPHVerlet, interp2SPH, kernelSPH, packSPH, virialStress</span>

<span class="comment">% 2023-10-30 | INRAE\Han CHEN | rev. </span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-10-30 alpha version</span>



<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<1, XY = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, y = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, XYgrid = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, GridVerletList= []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, W = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<6, V = []; <span class="keyword">end</span>
[k,d] = size(XY);
<span class="keyword">if</span> d~=2, error(<span class="string">'2 dimensions (columns) are required <span class="keyword">for</span> XY'</span>), <span class="keyword">end</span>
[ky,ny] = size(y);
<span class="keyword">if</span> ky*ny==0, y = ones(k,1); ky=k; ny=1; <span class="keyword">end</span>
<span class="keyword">if</span> ky~=k, error(<span class="string">'the number of y values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,ky,k), <span class="keyword">end</span></span>
<span class="keyword">if</span> k==0, error(<span class="string">'please supply some centers XY'</span>), <span class="keyword">end</span>
[kg,dg] = size(XYgrid);
<span class="keyword">if</span> dg~=2, error(<span class="string">'2 dimensions (columns) are required <span class="keyword">for</span> XYgrid'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> ~iscell(GridVerletList) || length(GridVerletList)~=kg
    error(<span class="string">'the supplied VerletList (<span class="comment">%d atoms) does not match the number of grid points (%d)'</span>,length(GridVerletList),kg)</span>
<span class="keyword">end</span>
kv = length(V);
<span class="keyword">if</span> kv==0, V=1;  kv=1; <span class="keyword">end</span>
<span class="keyword">if</span> kv==1, V = ones(k,1)*V; kv=k; <span class="keyword">end</span>
<span class="keyword">if</span> kv~=k, error(<span class="string">'the number of V values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,kv,k); <span class="keyword">end</span></span>
fmtsize = @(array) sprintf([repmat(<span class="string">'<span class="comment">%d x '</span>, 1, ndims(array)-1), <span class="string">'%d'</span>], size(array));</span>

<span class="comment">% main</span>
t0_ = clock; t1_=t0_; screen=<span class="string">''</span>; <span class="comment">%#ok<CLOCK></span>
Vq = NaN(kg,ny,class(y));
sizVerlet = cellfun(@length,GridVerletList);
dispf(<span class="string">'INTERP2SPHVERLET interpolates <span class="comment">%s grid points with a Verlet list including from %d to %d neighbors...'</span>,...</span>
    fmtsize(XYgrid),min(sizVerlet),max(sizVerlet))
<span class="keyword">for</span> i=1:kg
    t_ = clock; <span class="comment">%#ok<CLOCK></span>
    <span class="keyword">if</span> mod(i,200)==0 || (etime(t_,t1_)>0.5) <span class="comment">%#ok<*DETIM> </span>
        t1_=t_; dt_ = etime(t_,t0_); done_ = i/kg;
        screen = dispb(screen,<span class="string">'[GridPoint <span class="comment">%d:%d] INTERP2SPHVerlet | elapsed %0.1f s | done %0.1f %% | remaining %0.1f s'</span>, ...</span>
                               i,kg,dt_,100*done_,(1/done_-1)*dt_);
    <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(GridVerletList{i})
        Vq(i,:) = interp2SPH( ...
            XY(GridVerletList{i},:),...
            y(GridVerletList{i},:),...
            XYgrid(i,1),...
            XYgrid(i,2),...
            W,...
            V(GridVerletList{i}),...volume of the kernel
            true ...silent
            );
    <span class="keyword">end</span>
<span class="keyword">end</span>
dispb(screen,<span class="string">'...done in <span class="comment">%0.4g s. INTERP2SPHVerlet completed the interpolation of %d points with %d kernels'</span>, ...</span>
                               etime(clock,t0_),kg,k); <span class="comment">%#ok<CLOCK></span>
</code></pre></div>
</div>
<div id='interp3SPH' class='doc-content' style='display: none;'>
<h1>INTERP3SPH interpolates y at Xq,Yq,Zq using the 3D kernel W centered on centers</h1>
<p>Syntax:<br/>Vq = interp3SPH(X,y,Xq,Yq,Zq [,W,v])</p>
<p>Inputs:<br/>centers : kx3 coordinates of the kernel centers<br/>y : kxny values at X (m is the number of values associated with the same center)<br/>[] (empty matrix) forces a uniform density calculation<br/>Xq : array or matrix coordinates along X<br/>Yq : array or matrix coordinates along Y<br/>Zq : array or matrix coordinates along Z<br/>W : kernel function @(r) &lt;-- use kernelSPH() to supply a vectorized kernel<br/>v : kx1 volume of the kernels (default=1)<br/>[] (empty matrix) or scalar value forces uniform volumes (default =1)<br/>forcesilent: flag to force silence mode (default = false)</p>
<p>Output:<br/>Vq : same size as Xq, with an additional dimension if y was an array</p>
<h2>See also</h2>
<p><a href="#interp3SPHVerlet">interp3SPHVerlet</a>, <a href="#interp2SPH">interp2SPH</a>, <a href="#kernelSPH">kernelSPH</a>, <a href="#packSPH">packSPH</a>, virialStress</p>
<h2>See also</h2>
<p>Example, :, interpolate, the, field, x+2*y-3*z, {</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> Vq = interp3SPH(centers,y,Xq,Yq,Zq,W,V,forcesilent)
<span class="comment">% INTERP3SPH interpolates y at Xq,Yq,Zq using the 3D kernel W centered on centers</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       Vq = interp3SPH(X,y,Xq,Yq,Zq [,W,v])</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%     centers : kx3 coordinates of the kernel centers</span>
<span class="comment">%           y : kxny values at X (m is the number of values associated with the same center)</span>
<span class="comment">%               [] (empty matrix) forces a uniform density calculation</span>
<span class="comment">%          Xq : array or matrix coordinates along X</span>
<span class="comment">%          Yq : array or matrix coordinates along Y</span>
<span class="comment">%          Zq : array or matrix coordinates along Z</span>
<span class="comment">%           W : kernel <span class="keyword">function</span> @(r) <-- use kernelSPH() to supply a vectorized kernel</span>
<span class="comment">%           v : kx1 volume of the kernels (default=1)</span>
<span class="comment">%               [] (empty matrix) or scalar value forces uniform volumes (default =1)</span>
<span class="comment">%  forcesilent: flag to force silence mode (default = false)</span>
<span class="comment">%</span>
<span class="comment">%   Output:</span>
<span class="comment">%          Vq : same size as Xq, with an additional dimension <span class="keyword">if</span> y was an array</span>
<span class="comment">%</span>
<span class="comment">%   See also: interp3SPHVerlet, interp2SPH, kernelSPH, packSPH, virialStress</span>
<span class="comment">%</span>
<span class="comment">%   Example : interpolate the field x+2*y-3*z</span>
<span class="comment">%{</span>
    r = 0.5;
    h = 2*r;
    XYZ = packSPH(5,r);
    W = kernelSPH(h,<span class="string">'lucy'</span>,3);
    y = XYZ*[1;2;-3]; <span class="comment">% arbitrary field to be interpolated x+2*y-3*z</span>
    nresolution = 50;
    xg = linspace(min(XYZ(:,1))-h,max(XYZ(:,1))+h,nresolution);
    yg = linspace(min(XYZ(:,2))-h,max(XYZ(:,2))+h,nresolution);
    zg = linspace(min(XYZ(:,3))-h,max(XYZ(:,3))+h,nresolution);
    [Xg,Yg,Zg] = meshgrid(xg,yg,zg);
    Vg = interp3SPH(XYZ,y,Xg,Yg,Zg,W);
    figure, hs= slice(Xg,Yg,Zg,Vg,1:3,1:3,[]); set(hs,<span class="string">'edgecolor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.5), axis equal
    <span class="comment">% comparison with standard scattered interpolation</span>
    F = scatteredInterpolant(XYZ(:,1),XYZ(:,2),XYZ(:,3),y);
    Vg = F(Xg,Yg,Zg);
    figure, hs= slice(Xg,Yg,Zg,Vg,1:3,1:3,[]); set(hs,<span class="string">'edgecolor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.5), axis equal
<span class="comment">%}</span>
<span class="comment">%</span>
<span class="comment">% Example : calculate the density between the central bead and its closest neighbor</span>
<span class="comment">%{</span>
    r = 0.5;
    h = 2*r;
    XYZ = packSPH(5,r);
    W = kernelSPH(h,<span class="string">'lucy'</span>,3);
    [~,icentral] = min(sum((XYZ-mean(XYZ)).^2,2));
    dcentral = sqrt(sum((XYZ-XYZ(icentral,:)).^2,2));
    icontact = find( (dcentral>=2*r-0.0001) & (dcentral<=2*r+0.0001) );
    [~,closest] = min(dcentral(icontact));
    icontact = icontact(closest);
    reducedcurvilinear = linspace(-2.5,2.5,100)<span class="string">';
    curvilinear = reducedcurvilinear*norm(XYZ(icontact,:)-XYZ(icentral,:));
    XYZg = XYZ(icentral,:) + reducedcurvilinear*(XYZ(icontact,:)-XYZ(icentral,:));
    Vg = interp3SPH(XYZ,[],XYZg(:,1),XYZg(:,2),XYZg(:,3),W);
    figure, plot(curvilinear,Vg), xlabel('</span>distance to the central bead<span class="string">'), ylabel('</span>density<span class="string">')
<span class="comment">%}</span>

<span class="comment">% 2023-02-20 | INRAE\Olivier Vitrac | rev. 2023-10-26</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-05-16 - improve verbosity</span>
<span class="comment">% 2023-05-17 - add forcesilent </span>
<span class="comment">% 2023-05-18 - improve verbosity (fmtsize)</span>
<span class="comment">% 2023-10-26 - improve help</span>



<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<1, centers = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, y = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, Xq = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, Yq = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, Zq = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<6, W = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<7, V = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<8, forcesilent = []; <span class="keyword">end</span>
[k,d] = size(centers);
[ky,ny] = size(y);
kv = length(V);
<span class="keyword">if</span> k==0, error('</span>please supply some centers<span class="string">'), <span class="keyword">end</span>
<span class="keyword">if</span> d~=3, error('</span>3 dimensions (columns) are required<span class="string">'), <span class="keyword">end</span>
<span class="keyword">if</span> ky*ny==0, y = ones(k,1); ky=k; ny=1; <span class="keyword">end</span>
<span class="keyword">if</span> ky~=k, error('</span>the number of y values (<span class="comment">%d) does not match the number of kernels (%d)<span class="string">',ky,k), <span class="keyword">end</span></span>
<span class="keyword">if</span> ~isequal(size(Xq),size(Yq)) || ~isequal(size(Yq),size(Zq)), error('</span>Xq,Yq and Zq do not have compatible sizes<span class="string">'), <span class="keyword">end</span> 
<span class="keyword">if</span> kv==0, V=1;  kv=1; <span class="keyword">end</span>
<span class="keyword">if</span> kv==1, V = ones(k,1)*V; kv=k; <span class="keyword">end</span>
<span class="keyword">if</span> kv~=k, error('</span>the number of V values (<span class="comment">%d) does not match the number of kernels (%d)<span class="string">',kv,k); <span class="keyword">end</span></span>
<span class="keyword">if</span> isempty(forcesilent), forcesilent=false; <span class="keyword">end</span>
fmtsize = @(array) sprintf([repmat('</span><span class="comment">%d x <span class="string">', 1, ndims(array)-1), '</span>%d<span class="string">'], size(array));</span>

<span class="comment">% main</span>
sumW = cell(1,ny);
verbosity = (numel(Xq)>1e4) && ~forcesilent;
largek = k>200;
t0_ = clock; t1_=t0_; screen='</span><span class="string">'; <span class="comment">%#ok<CLOCK></span>

<span class="keyword">if</span> verbosity, dispf('</span>INTPER3SPH is summing <span class="comment">%s grid values over %d kernels (K)...<span class="string">',fmtsize(Xq),k), <span class="keyword">end</span></span>
<span class="keyword">for</span> i=1:k
    <span class="comment">% initialization <span class="keyword">if</span> needed</span>
    <span class="keyword">if</span> i==1
        <span class="keyword">for</span> iy=1:ny
            sumW{iy} = zeros(size(Xq),class(Xq));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% verbosity</span>
    <span class="keyword">if</span> verbosity
        <span class="keyword">if</span> largek
            t_ = clock;
            <span class="keyword">if</span> mod(i,500)==0 || (etime(t_,t1_)>0.5) <span class="comment">%#ok<*DETIM> </span>
                t1_=t_;
                dt_ = etime(t_,t0_); done_ = i/k;
                screen = dispb(screen,'</span>[K<span class="comment">%d:%d] INTERP3SPH | elapsed %0.1f s | done %0.1f %% | remaining %0.1f s<span class="string">', ...</span>
                               i,k,dt_,100*done_,(1/done_-1)*dt_);
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            dispf('</span>... interpolate respectively to kernel <span class="comment">%d of %d<span class="string">',i,k);</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% interpolation</span>
    R = sqrt( (Xq-centers(i,1)).^2 + (Yq-centers(i,2)).^2 + (Zq-centers(i,3)).^2 );
    <span class="keyword">for</span> iy = 1:ny
        sumW{iy} = sumW{iy} + y(i,iy) * V(i) * W(R);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% output</span>
<span class="keyword">if</span> ny==1
    Vq = sumW{1};
<span class="keyword">else</span>
    Vq = cat(ndims(Xq)+1,sumW{:});
<span class="keyword">end</span>

<span class="comment">% verbosity</span>
<span class="keyword">if</span> verbosity
    dispb(screen,'</span>done in . INTERP3SPH interpolated <span class="comment">%s grid points with %d kernels in %0.4g s', ...</span>
                               etime(clock,t0_),fmtsize(Xq),k);
<span class="keyword">end</span></code></pre></div>
</div>
<div id='interp3SPHVerlet' class='doc-content' style='display: none;'>
<h1>INTERP3SPHVerlet interpolates y at XYZgrid using the GridVerletList and the 3D kernel W centered on XYZ</h1>
<p>Vgrid = interp3SPHVerlet(XYZ,y,XYZgrid,GridVerletList [,W,V])</p>
<p>Inputs:<br/>XYZ : kx3 coordinates of the kernel centers<br/>y : kxny values at XYZ (m is the number of values associated with the same center)<br/>[] (empty matrix) forces a uniform density calculatoin<br/>XYZgrid : gx3 grid coordinates<br/>GridVerletList : VerletList of the grid<br/>W : kernel function @(r) &lt;-- use kernelSPH() to supply a vectorized kernel<br/>V : kx1 volume of the kernels (default=1)<br/>[] (empty matrix) or scalar value forces uniform volumes (default =1)</p>
<p>Output:<br/>Vgrid : gxny array</p>
<h2>See also</h2>
<p><a href="#buildVerletList">buildVerletList</a>, <a href="#interp3SPH">interp3SPH</a>, <a href="#interp2SPH">interp2SPH</a>, <a href="#kernelSPH">kernelSPH</a>, <a href="#packSPH">packSPH</a>, virialStress</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> Vq = interp3SPHVerlet(XYZ,y,XYZgrid,GridVerletList,W,V)
<span class="comment">% INTERP3SPHVerlet interpolates y at XYZgrid using the GridVerletList and the 3D kernel W centered on XYZ</span>
<span class="comment">%</span>
<span class="comment">%       Vgrid = interp3SPHVerlet(XYZ,y,XYZgrid,GridVerletList [,W,V])</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%            XYZ : kx3 coordinates of the kernel centers</span>
<span class="comment">%              y : kxny values at XYZ (m is the number of values associated with the same center)</span>
<span class="comment">%                  [] (empty matrix) forces a uniform density calculatoin</span>
<span class="comment">%        XYZgrid : gx3 grid coordinates</span>
<span class="comment">% GridVerletList : VerletList of the grid</span>
<span class="comment">%              W : kernel <span class="keyword">function</span> @(r) <-- use kernelSPH() to supply a vectorized kernel</span>
<span class="comment">%              V : kx1 volume of the kernels (default=1)</span>
<span class="comment">%                  [] (empty matrix) or scalar value forces uniform volumes (default =1)</span>
<span class="comment">%</span>
<span class="comment">%   Output:</span>
<span class="comment">%       Vgrid : gxny array</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: buildVerletList, interp3SPH, interp2SPH, kernelSPH, packSPH, virialStress</span>

<span class="comment">% 2023-05-16 | INRAE\Olivier Vitrac | rev. 2023-05-17</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-05-16 alpha version</span>
<span class="comment">% 2023-05-17 RC</span>
<span class="comment">% 2023-05-18 improve verbosity</span>


<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<1, XYZ = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, y = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, XYZgrid = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, GridVerletList= []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, W = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<6, V = []; <span class="keyword">end</span>
[k,d] = size(XYZ);
<span class="keyword">if</span> d~=3, error(<span class="string">'3 dimensions (columns) are required <span class="keyword">for</span> XYZ'</span>), <span class="keyword">end</span>
[ky,ny] = size(y);
<span class="keyword">if</span> ky*ny==0, y = ones(k,1); ky=k; ny=1; <span class="keyword">end</span>
<span class="keyword">if</span> ky~=k, error(<span class="string">'the number of y values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,ky,k), <span class="keyword">end</span></span>
<span class="keyword">if</span> k==0, error(<span class="string">'please supply some centers XYZ'</span>), <span class="keyword">end</span>
[kg,dg] = size(XYZgrid);
<span class="keyword">if</span> dg~=3, error(<span class="string">'3 dimensions (columns) are required <span class="keyword">for</span> XYZgrid'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> ~iscell(GridVerletList) || length(GridVerletList)~=kg
    error(<span class="string">'the supplied VerletList (<span class="comment">%d atoms) does not match the number of grid points (%d)'</span>,length(GridVerletList),kg)</span>
<span class="keyword">end</span>
kv = length(V);
<span class="keyword">if</span> kv==0, V=1;  kv=1; <span class="keyword">end</span>
<span class="keyword">if</span> kv==1, V = ones(k,1)*V; kv=k; <span class="keyword">end</span>
<span class="keyword">if</span> kv~=k, error(<span class="string">'the number of V values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,kv,k); <span class="keyword">end</span></span>
fmtsize = @(array) sprintf([repmat(<span class="string">'<span class="comment">%d x '</span>, 1, ndims(array)-1), <span class="string">'%d'</span>], size(array));</span>

<span class="comment">% main</span>
t0_ = clock; t1_=t0_; screen=<span class="string">''</span>; <span class="comment">%#ok<CLOCK></span>
Vq = NaN(kg,ny,class(y));
sizVerlet = cellfun(@length,GridVerletList);
dispf(<span class="string">'INTERP3SPHVERLET interpolates <span class="comment">%s grid points with a Verlet list including from %d to %d neighbors...'</span>,...</span>
    fmtsize(XYZgrid),min(sizVerlet),max(sizVerlet))
<span class="keyword">for</span> i=1:kg
    t_ = clock; <span class="comment">%#ok<CLOCK></span>
    <span class="keyword">if</span> mod(i,200)==0 || (etime(t_,t1_)>0.5) <span class="comment">%#ok<*DETIM> </span>
        t1_=t_; dt_ = etime(t_,t0_); done_ = i/kg;
        screen = dispb(screen,<span class="string">'[GridPoint <span class="comment">%d:%d] INTERP3SPHVerlet | elapsed %0.1f s | done %0.1f %% | remaining %0.1f s'</span>, ...</span>
                               i,kg,dt_,100*done_,(1/done_-1)*dt_);
    <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(GridVerletList{i})
        Vq(i,:) = interp3SPH( ...
            XYZ(GridVerletList{i},:),...
            y(GridVerletList{i},:),...
            XYZgrid(i,1),...
            XYZgrid(i,2),...
            XYZgrid(i,3),...
            W,...
            V(GridVerletList{i}),...volume of the kernel
            true ...silent
            );
    <span class="keyword">end</span>
<span class="keyword">end</span>
dispb(screen,<span class="string">'...done in <span class="comment">%0.4g s. INTERP3SPHVerlet completed the interpolation of %d points with %d kernels'</span>, ...</span>
                               etime(clock,t0_),kg,k); <span class="comment">%#ok<CLOCK></span>
</code></pre></div>
</div>
<div id='interp3cauchy' class='doc-content' style='display: none;'>
<h1>INTERP3CAYCHY Computes the local stress tensor at each point in a 3D grid.</h1>
<p>stress = interp3cauchy(Xw, Yw, Zw, FXw, FYw, FZw)</p>
<p>This function calculates the local stress tensor at each grid point<br/>in a non-uniform 3D grid using the given force components at each point.<br/>The calculated stress tensor reflects the mechanical state of the grid.</p>
<p>Inputs:<br/>- Xw, Yw, Zw: 3D matrices containing the x, y, and z coordinates of the grid points.<br/>- FXw, FYw, FZw: 3D matrices containing the x, y, and z components of the force at each grid point.</p>
<p>Output:<br/>- stress: 4D array where the first three dimensions correspond to the size<br/>of the input grid (minus one in each dimension to avoid index overflow),<br/>and the fourth dimension contains the 9 components of the<br/>local stress tensor for each grid cell (flattened 3x3 tensor).</p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>[Xw,Yw,Zw] = meshgrid(1:0.1:2, 1:0.2:3, 1:0.3:2);
FXw = rand(size(Xw));
FYw = rand(size(Yw));
FZw = rand(size(Zw));
stress = interp3virial(Xw, Yw, Zw, FXw, FYw, FZw);</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>=== Interpretation and comparison with Cauchy tensor definition ===</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>In continuum mechanics, the Cauchy stress tensor, often represented by the symbol
\( \sigma \), is a second-order tensor describing the stress state at a given point
in a material. The Cauchy stress tensor is defined as follows:</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>\[
\sigma_{ij} = \lim_{{\Delta A \to 0}} \frac{\Delta F_j}{\Delta A_i}
\]</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>where \( \Delta F_j \) is the force in the \( j \) direction acting on a differential
area \( \Delta A_i \) oriented along the \( i \) direction. The indices \( i \) and
\( j \) run from 1 to 3, referring to the spatial dimensions \( x, y, z \).</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>In the code, the variable `local_tensor` serves as the Cauchy stress tensor
for a particular grid cell. For this tensor, the components are computed as:</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>\[
\text{local\_tensor}(\alpha, \beta) = \frac{F_{\text{avg}}(\alpha) \times
n_{\beta}(\beta)}{A(\beta)}
\]</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>Here, \( F_{\text{avg}}(\alpha) \) is the average force in the \( \alpha \)
direction acting on the cell, \( n_{\beta}(\beta) \) is the normal vector to
the face of the cell in the \( \beta \) direction, and \( A(\beta) \) is the area
of the face in the \( \beta \) direction.</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>### Comparison of Indices
In the Matlab implementation, the components of `local_tensor(alpha, beta)`
essentially represent \( \sigma_{\alpha \beta} \) if \( \alpha, \beta \) refer to the
\( x, y, z \) directions. In other words, \( \alpha = i \) and \( \beta = j \).</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>It&#x27;s important to note that Matlab uses 1-based indexing, so the components
\( \sigma_{11}, \sigma_{12}, \sigma_{13}, \ldots, \sigma_{33} \) in continuum
mechanics are stored as `local_tensor(1,1), local_tensor(2,1),
local_tensor(3,1), ..., local_tensor(3,3)` in Matlab.</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>So, in conclusion, `local_tensor` in the Matlab code is essentially the Cauchy stress
tensor \( \sigma \), and its components are consistent with the definitions used
in continuum mechanics, albeit with 1-based indexing with the following rule:
first dimension = normal direction, second = considered force component.</code></pre>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> stress = interp3cauchy(Xw, Yw, Zw, FXw, FYw, FZw)
<span class="comment">%INTERP3CAYCHY Computes the local stress tensor at each point in a 3D grid.</span>
<span class="comment">%</span>
<span class="comment">% stress = interp3cauchy(Xw, Yw, Zw, FXw, FYw, FZw)</span>
<span class="comment">%</span>
<span class="comment">% This <span class="keyword">function</span> calculates the local stress tensor at each grid point</span>
<span class="comment">% in a non-uniform 3D grid using the given force components at each point.</span>
<span class="comment">% The calculated stress tensor reflects the mechanical state of the grid.</span>
<span class="comment">%</span>
<span class="comment">% Inputs:</span>
<span class="comment">% - Xw, Yw, Zw: 3D matrices containing the x, y, and z coordinates of the grid points.</span>
<span class="comment">% - FXw, FYw, FZw: 3D matrices containing the x, y, and z components of the force at each grid point.</span>
<span class="comment">%</span>
<span class="comment">% Output:</span>
<span class="comment">% - stress: 4D array where the first three dimensions correspond to the size</span>
<span class="comment">%           of the input grid (minus one in each dimension to avoid index overflow),</span>
<span class="comment">%           and the fourth dimension contains the 9 components of the</span>
<span class="comment">%           local stress tensor <span class="keyword">for</span> each grid cell (flattened 3x3 tensor).</span>
<span class="comment">%</span>
<span class="comment">% Example:</span>
<span class="comment">% [Xw,Yw,Zw] = meshgrid(1:0.1:2, 1:0.2:3, 1:0.3:2);</span>
<span class="comment">% FXw = rand(size(Xw));</span>
<span class="comment">% FYw = rand(size(Yw));</span>
<span class="comment">% FZw = rand(size(Zw));</span>
<span class="comment">% stress = interp3virial(Xw, Yw, Zw, FXw, FYw, FZw);</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% === Interpretation and comparison with Cauchy tensor definition ===</span>
<span class="comment">%</span>
<span class="comment">% In continuum mechanics, the Cauchy stress tensor, often represented by the symbol</span>
<span class="comment">% \( \sigma \), is a second-order tensor describing the stress state at a given point</span>
<span class="comment">% in a material. The Cauchy stress tensor is defined as follows:</span>
<span class="comment">% </span>
<span class="comment">% \[</span>
<span class="comment">% \sigma_{ij} = \lim_{{\Delta A \to 0}} \frac{\Delta F_j}{\Delta A_i}</span>
<span class="comment">% \]</span>
<span class="comment">% </span>
<span class="comment">% where \( \Delta F_j \) is the force in the \( j \) direction acting on a differential</span>
<span class="comment">% area \( \Delta A_i \) oriented along the \( i \) direction. The indices \( i \) and</span>
<span class="comment">% \( j \) run from 1 to 3, referring to the spatial dimensions \( x, y, z \).</span>
<span class="comment">% </span>
<span class="comment">% In the code, the variable `local_tensor` serves as the Cauchy stress tensor</span>
<span class="comment">% <span class="keyword">for</span> a particular grid cell. For this tensor, the components are computed as:</span>
<span class="comment">% </span>
<span class="comment">% \[</span>
<span class="comment">% \text{local\_tensor}(\alpha, \beta) = \frac{F_{\text{avg}}(\alpha) \times </span>
<span class="comment">% n_{\beta}(\beta)}{A(\beta)}</span>
<span class="comment">% \]</span>
<span class="comment">% </span>
<span class="comment">% Here, \( F_{\text{avg}}(\alpha) \) is the average force in the \( \alpha \)</span>
<span class="comment">% direction acting on the cell, \( n_{\beta}(\beta) \) is the normal vector to </span>
<span class="comment">% the face of the cell in the \( \beta \) direction, and \( A(\beta) \) is the area</span>
<span class="comment">% of the face in the \( \beta \) direction.</span>
<span class="comment">% </span>
<span class="comment">% ### Comparison of Indices</span>
<span class="comment">% In the Matlab implementation, the components of `local_tensor(alpha, beta)` </span>
<span class="comment">% essentially represent \( \sigma_{\alpha \beta} \) <span class="keyword">if</span> \( \alpha, \beta \) refer to the </span>
<span class="comment">% \( x, y, z \) directions. In other words, \( \alpha = i \) and \( \beta = j \).</span>
<span class="comment">% </span>
<span class="comment">% It<span class="string">'s important to note that Matlab uses 1-based indexing, so the components</span>
<span class="comment">% \( \sigma_{11}, \sigma_{12}, \sigma_{13}, \ldots, \sigma_{33} \) in continuum </span>
<span class="comment">% mechanics are stored as `local_tensor(1,1), local_tensor(2,1),</span>
<span class="comment">% local_tensor(3,1), ..., local_tensor(3,3)` in Matlab.</span>
<span class="comment">% </span>
<span class="comment">% So, in conclusion, `local_tensor` in the Matlab code is essentially the Cauchy stress</span>
<span class="comment">% tensor \( \sigma \), and its components are consistent with the definitions used</span>
<span class="comment">% in continuum mechanics, albeit with 1-based indexing with the following rule:</span>
<span class="comment">% first dimension = normal direction, second = considered force component.</span>



<span class="comment">% MS 3.0 | 2023-09-09 | INRAE\Olivier.vitrac@agroparistech.fr | rev.</span>

<span class="comment">% Revision history</span>

<span class="comment">% Check argument compatibility</span>
<span class="keyword">if</span> nargin~=6, error('</span>Six arguments are required: stress = interp3virial(Xw, Yw, Zw, FXw, FYw, FZw)<span class="string">'), <span class="keyword">end</span>
<span class="keyword">if</span> any(size(Xw) ~= size(Yw)) || any(size(Yw) ~= size(Zw)) || ...
        any(size(FXw) ~= size(FYw)) || any(size(FYw) ~= size(FZw)) || ...
        any(size(Xw) ~= size(FXw))
    error('</span>Dimension mismatch among the input matrices.<span class="string">');
<span class="keyword">end</span>
<span class="comment">% Pre-check to ensure Xw, Yw, Zw are meshgrid-generated</span>
tolerance = 1e-10;  <span class="comment">% Tolerance <span class="keyword">for</span> checking uniform increments</span>
<span class="keyword">if</span> ~all(std(diff(Xw(:,1,1), 1, 1), 0, 2,'</span>omitnan<span class="string">') < tolerance) || ...
   ~all(std(diff(Yw(1,:,1), 1, 2), 0, 1, '</span>omitnan<span class="string">') < tolerance) || ...
   ~all(std(diff(Zw(1,1,:), 1, 3), 0, 3, '</span>omitnan<span class="string">') < tolerance)
    error('</span>Input matrices Xw, Yw, and Zw must be generated using meshgrid<span class="string">');
<span class="keyword">end</span>

<span class="comment">% Initialize 4D array to store local stress tensor <span class="keyword">for</span> each cell</span>
<span class="comment">% Dimensions: size(Xw) x 9 (flattened 3x3 tensor)</span>
stress = NaN([size(Xw), 9],class(FXw));

<span class="comment">% Loop through all grid points except the last in each dimension</span>
<span class="comment">% to avoid index overflow</span>
[ny,nx,nz] = size(Xw); <span class="comment">% remember than Xw,Yw and Zw are generated by meshgrid (variation directions: 1=y, 2=x, 3=z)</span>
nxyz = ny * nx * nz;   <span class="comment">% total number of elements</span>
verbose = nxyz > 1000;

<span class="keyword">if</span> verbose
    dispf('</span>Calculate the local Cauchy stress from a [<span class="comment">%d x %d x %d] grid...<span class="string">',ny,nx,nz)</span>
    t0_ = clock; <span class="comment">%#ok<CLOCK></span>
    t1_ = t0_;
    screen = '</span><span class="string">';
<span class="keyword">end</span>

iter = 0;
<span class="keyword">for</span> iy = 1:ny
    <span class="keyword">for</span> ix = 1:nx
        <span class="keyword">for</span> iz = 1:nz

            iter = iter + 1;

            <span class="comment">% Initialize local tensor</span>
            local_tensor = zeros(3, 3);

            <span class="comment">% Edge cases <span class="keyword">for</span> dx, dy, dz</span>
            dx = Xw(iy, min(ix+1,nx), iz) - Xw(iy, ix, iz);
            dy = Yw(min(iy+1,ny), ix, iz) - Yw(iy, ix, iz);
            dz = Zw(iy, ix, min(iz+1,nz)) - Zw(iy, ix, iz);

            <span class="comment">% Calculate area of each face of this cell</span>
            A = [dy * dz, dx * dz, dx * dy];  <span class="comment">% Face areas</span>


            <span class="comment">% Calculate tensor components <span class="keyword">for</span> each face considering only the four vertices of the face</span>

            <span class="keyword">for</span> beta = 1:3 <span class="comment">% -> direction beta=1 (x-face), beta=2 (y-face), beta=3 (z-face)</span>
                
                <span class="comment">%vert_idx = []; vert_idy = []; vert_idz = [];</span>
                <span class="comment">% Define the indices <span class="keyword">for</span> the 4 vertices constituting each face</span>
                <span class="keyword">if</span> beta == 1 && iy < ny && iz < nz
                    vert_idx = repmat(ix, 1, 4);
                    vert_idy = [iy, iy, iy+1, iy+1];
                    vert_idz = [iz, iz+1, iz, iz+1];
                <span class="keyword">elseif</span> beta == 2 && ix < nx && iz < nz
                    vert_idy = repmat(iy, 1, 4);
                    vert_idx = [ix, ix+1, ix, ix+1];
                    vert_idz = [iz, iz, iz+1, iz+1];
                <span class="keyword">elseif</span> beta == 3 && ix < nx && iy < ny
                    vert_idz = repmat(iz, 1, 4);
                    vert_idx = [ix, ix+1, ix, ix+1];
                    vert_idy = [iy, iy, iy+1, iy+1];
                <span class="keyword">else</span>
                    continue;  <span class="comment">% Skip, as it'</span>s the edge of the grid</span>
                <span class="keyword">end</span>

                <span class="comment">% Translate to 1D indices <span class="keyword">for</span> force matrices</span>
                ind = sub2ind([ny, nx, nz], vert_idy, vert_idx, vert_idz);

                <span class="keyword">for</span> alpha = 1:3 <span class="comment">% -> force component</span>

                    <span class="comment">% Compute average force on vertices</span>
                    <span class="keyword">if</span> alpha == 1
                        F_alpha_avg = mean(FXw(ind), <span class="string">'omitnan'</span>);
                    <span class="keyword">elseif</span> alpha == 2
                        F_alpha_avg = mean(FYw(ind), <span class="string">'omitnan'</span>);
                    <span class="keyword">elseif</span> alpha == 3
                        F_alpha_avg = mean(FZw(ind), <span class="string">'omitnan'</span>);
                    <span class="keyword">end</span>

                    <span class="keyword">if</span> isnan(F_alpha_avg), continue; <span class="keyword">end</span>

                    <span class="comment">% Update the stress tensor component</span>
                    local_tensor(beta, alpha) = F_alpha_avg / A(beta);

                <span class="keyword">end</span> <span class="comment">% next alpha</span>

            <span class="keyword">end</span> <span class="comment">% next beta</span>

            <span class="comment">% Store this tensor</span>
            stress(iy, ix, iz, :) = local_tensor(:);

            <span class="comment">% verbosity</span>
            t_ = clock; <span class="comment">%#ok<CLOCK></span>
            <span class="keyword">if</span> verbose && (mod(iter,200)==0 || (etime(t_,t1_)>0.5))  <span class="comment">%#ok<*DETIM></span>
                t1_=t_; dt_ = etime(t_,t0_); done_ = iter/nxyz;
                screen = dispb(screen,<span class="string">'[GridPoint <span class="comment">%d:%d] INTERP3 Cauchy Stress | elapsed %0.1f s | done %0.1f %% | remaining %0.1f s'</span>, ...</span>
                    iter,nxyz,dt_,100*done_,(1/done_-1)*dt_);
            <span class="keyword">end</span>

        <span class="keyword">end</span> <span class="comment">% next iz (variation direction = 1) -- see meshgrid</span>
    <span class="keyword">end</span> <span class="comment">% next ix  (variation direction = 2)  -- see meshgrid</span>
<span class="keyword">end</span> <span class="comment">% next iy  (variation direction = 3)  -- see meshgrid</span>

<span class="keyword">if</span> verbose
    dispb(screen,<span class="string">'\t ... done in <span class="comment">%0.3g s from %d GRIDPOINTS'</span>,etime(clock,t0_),nxyz); %#ok<CLOCK></span>
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='kernelSPH' class='doc-content' style='display: none;'>
<h1>KERNELSPH return a SPH kernel as an anonymous function in 3D or 2D (kernels are zero for r&gt;h)</h1>
<p>Syntax:<br/>W = kernelSPH(h,type,d)<br/>Inputs:<br/>h : cutoff (all kernels have support between 0 and h)<br/>type : kenel name (default = Lucy)<br/>d : dimension (3 or 2)<br/>Output:<br/>W : kernel function @(r)</p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>W = kernelSPH(1,&#x27;lucy&#x27;,3)</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>List of implemented Kernels (aliases can be defined)
Suffix der is added to first-order derivative kernels</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>lucy and lucyder:  used for the Morris calculation in the SPH source code of LAMMPS:
lammps-2022-10-04/src/SPH/pair_sph_taitwater_morris.cpp ln. 138
poly6, polyder:       used for ULSPH density calculation in SMD source code of LAMMPS:
lammps-2022-10-04/src/MACHDYN/pair_smd_ulsph.cpp
cubicspline, cubic:   used for ULSPH artificial pressure calculation in SMD source code of LAMMPS:
cubicder            lammps-2022-10-04/src/MACHDYN/pair_smd_ulsph.cpp
USER-SMD/smd_kernels.h
spikykernel,spiky     used for ULSPH and TLSPH force calculation in SMD source code of LAMMPS:
spikyder            lammps-2022-10-04/src/MACHDYN/pair_smd_ulsph.cpp
lammps-2022-10-04/src/MACHDYN/pair_smd_tlsph.cpp
gaussian, gaussiankernel
gaussiander</code></pre>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> W = kernelSPH(h,type,d)
<span class="comment">% KERNELSPH <span class="keyword">return</span> a SPH kernel as an anonymous <span class="keyword">function</span> in 3D or 2D (kernels are zero <span class="keyword">for</span> r>h)</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       W = kernelSPH(h,type,d)</span>
<span class="comment">%    Inputs:</span>
<span class="comment">%           h : cutoff (all kernels have support between 0 and h)</span>
<span class="comment">%        type : kenel name (default = Lucy)</span>
<span class="comment">%           d : dimension (3 or 2)</span>
<span class="comment">%   Output:</span>
<span class="comment">%           W : kernel <span class="keyword">function</span> @(r)</span>
<span class="comment">%   Example:</span>
<span class="comment">%       W = kernelSPH(1,<span class="string">'lucy'</span>,3)</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   List of implemented Kernels (aliases can be defined)</span>
<span class="comment">%       Suffix der is added to first-order derivative kernels</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   lucy and lucyder:  used <span class="keyword">for</span> the Morris calculation in the SPH source code of LAMMPS:</span>
<span class="comment">%                       lammps-2022-10-04/src/SPH/pair_sph_taitwater_morris.cpp ln. 138</span>
<span class="comment">%   poly6, polyder:       used <span class="keyword">for</span> ULSPH density calculation in SMD source code of LAMMPS:</span>
<span class="comment">%                       lammps-2022-10-04/src/MACHDYN/pair_smd_ulsph.cpp</span>
<span class="comment">%   cubicspline, cubic:   used <span class="keyword">for</span> ULSPH artificial pressure calculation in SMD source code of LAMMPS:</span>
<span class="comment">%   cubicder            lammps-2022-10-04/src/MACHDYN/pair_smd_ulsph.cpp</span>
<span class="comment">%                       USER-SMD/smd_kernels.h</span>
<span class="comment">%   spikykernel,spiky     used <span class="keyword">for</span> ULSPH and TLSPH force calculation in SMD source code of LAMMPS:</span>
<span class="comment">%   spikyder            lammps-2022-10-04/src/MACHDYN/pair_smd_ulsph.cpp</span>
<span class="comment">%                       lammps-2022-10-04/src/MACHDYN/pair_smd_tlsph.cpp</span>
<span class="comment">%   gaussian, gaussiankernel</span>
<span class="comment">%   gaussiander</span>

<span class="comment">%   See also: interp3SPH, interp3SPHVerlet, interp2SPH, interp2SPHVerlet, packSPH</span>


<span class="comment">% 2023-02-20 | INRAE\Olivier Vitrac | rev. 2023-10-29</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-04-03 WJ. addition of the `poly6kernel<span class="string">', the `cubicsplinekernel'</span> and the `spikykernel<span class="string">' as set in the SMD source code of LAMMPS:</span>
<span class="comment">%            lammps-2022-10-04/src/MACHDYN/smdkernel.cpp</span>
<span class="comment">% 2023-10-29 major revision, updated and new kernels, help improvement, all kernels are zero beyond h</span>


<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<1, h = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, type = '</span><span class="string">'; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, d = []; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(h), error('</span>Supply a value <span class="keyword">for</span> h<span class="string">'), <span class="keyword">end</span>
<span class="keyword">if</span> isempty(type), type = '</span>lucy<span class="string">'; <span class="keyword">end</span>
<span class="keyword">if</span> ~ischar(type), error('</span>type must be a char array<span class="string">'), <span class="keyword">end</span>
<span class="keyword">if</span> isempty(d), d = 3; <span class="keyword">end</span>
<span class="keyword">if</span> (d<2) || (d>3), error('</span>d must be equal to 1, 2 or 3<span class="string">'), <span class="keyword">end</span>

<span class="comment">% main</span>
<span class="keyword">switch</span> lower(type)
    <span class="keyword">case</span> '</span>lucy<span class="string">'
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
                s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<h)
                matlabFunction((subs(W3(R),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* ( 1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1) )./pi;
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<h)
                matlabFunction((subs(W2(R),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* ( 1.0./h.^2.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*-5.0 )./pi;
        <span class="keyword">end</span>
    <span class="keyword">case</span> '</span>lucyder<span class="string">'
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
                s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<h)
                matlabFunction((subs(diff(W3(R),R,1),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* ( (1.0./h.^4.*(r./h-1.0).^3.*(-3.15e+2./1.6e+1))./pi-(1.0./h.^4.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*(3.15e+2./1.6e+1))./pi );
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 2D</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<h)
                matlabFunction((subs(diff(W2(R),R,1),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* ( (1.0./h.^3.*(r./h-1.0).^3.*-1.5e+1)./pi-(1.0./h.^3.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*1.5e+1)./pi );
        <span class="keyword">end</span>
    <span class="keyword">case</span> {'</span>poly6kernel<span class="string">','</span>poly6<span class="string">'}
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                W(r) = piecewise(r<h,(1/s)*((h^2 - r^2)*(h^2 - r^2)*(h^2 - r^2))/((h^2)*(h^2)*(h^2)*(h^2)*(h)),r>=h,0); <span class="comment">% kernel definition</span>
                s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<h)
                matlabFunction((subs(W3(R),R,r)))
                
            <span class="comment">%}</span>
            W = @(r) (r<h) .* (1.0./h.^9.*(h.^2-r.^2).^3.*(3.15e+2./6.4e+1))./pi;
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                W(r) = piecewise(r<h,(1/s)*((h^2 - r^2)*(h^2 - r^2)*(h^2 - r^2))/((h^2)*(h^2)*(h^2)*(h^2)),r>=h,0)
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<h)
                matlabFunction((subs(W2(R),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* (1.0./h.^8.*(h.^2-r.^2).^3.*4.0)./pi;
        <span class="keyword">end</span>
    <span class="keyword">case</span>  {'</span>cubicsplinekernel<span class="string">','</span>cubicspline<span class="string">','</span>cubic<span class="string">'}
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                q = 2*r/h;
                W(r) = piecewise(q<1,(1/s)*(2/3-q^2+0.5*q^3),(q>=1) & (q<2),(1/s)*((2-q)^3)/6,q>=2,0); <span class="comment">% kernel definition</span>
                s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<h/2)
                matlabFunction(simplify(subs(W3(R),R,r)))
                assume(R,'</span>clear<span class="string">')
                assume((R>h/2) & (R<h))
                matlabFunction(simplify(subs(W3(R),R,r)))           
            <span class="comment">%}</span>
            W = @(r) (r<h/2) .* ...
                (1.0./h.^6.*(h.*r.^2.*-4.8e+1+h.^3.*8.0+r.^3.*4.8e+1))./pi ...
                + ((r>=h/2) & (r<h)) .* ...
                (1.0./h.^6.*(h-r).^3.*1.6e+1)./pi;
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                q = 2*r/h;
                W(r) = piecewise(q<1,(1/s)*(2/3-q^2+0.5*q^3),(q>=1) & (q<2),(1/s)*((2-q)^3)/6,q>=2,0); <span class="comment">% kernel definition</span>
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 2D</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<h/2)
                matlabFunction(simplify(subs(W2(R),R,r)))
                assume(R,'</span>clear<span class="string">')
                assume((R>h/2) & (R<h))
                matlabFunction(simplify(subs(W2(R),R,r))) 
            <span class="comment">%}</span>
            W = @(r) (r<h/2) .* ...
                (1.0./h.^5.*(h.*r.^2.*-2.4e+2+h.^3.*4.0e+1+r.^3.*2.4e+2))./(pi.*7.0) ...
                + ((r>=h/2) & (r<h)) .* ...
                (1.0./h.^5.*(h-r).^3.*(8.0e+1./7.0))./pi;
        <span class="keyword">end</span>
    <span class="keyword">case</span>  {'</span>cubicsplineder<span class="string">','</span>cubicder<span class="string">'}
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                q = 2*r/h;
                W(r) = piecewise(q<1,(1/s)*(2/3-q^2+0.5*q^3),(q>=1) & (q<2),(1/s)*((2-q)^3)/6,q>=2,0); <span class="comment">% kernel definition</span>
                s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<h/2)
                matlabFunction(simplify(subs(diff(W3(R),R,1),R,r)))
                assume(R,'</span>clear<span class="string">')
                assume((R>h/2) & (R<h))
                matlabFunction(simplify(subs(diff(W3(R),R,1),R,r)))           
            <span class="comment">%}</span>
            W = @(r) (r<h/2) .* ...
                (1.0./h.^6.*r.*(h.*2.0-r.*3.0).*-4.8e+1)./pi ...
                + ((r>=h/2) & (r<h)) .* ...
                (1.0./h.^6.*(h-r).^2.*-4.8e+1)./pi;
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                q = 2*r/h;
                W(r) = piecewise(q<1,(1/s)*(2/3-q^2+0.5*q^3),(q>=1) & (q<2),(1/s)*((2-q)^3)/6,q>=2,0); <span class="comment">% kernel definition</span>
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 2D</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<h/2)
                matlabFunction(simplify(subs(diff(W2(R),R,1),R,r)))
                assume(R,'</span>clear<span class="string">')
                assume((R>h/2) & (R<h))
                matlabFunction(simplify(subs(diff(W2(R),R,1),R,r))) 
            <span class="comment">%}</span>
            W = @(r) (r<h/2) .* ...
                (1.0./h.^5.*r.*(h.*2.0-r.*3.0).*(-2.4e+2./7.0))./pi ...
                + ((r>=h/2) & (r<h)) .* ...
                (1.0./h.^5.*(h-r).^2.*(-2.4e+2./7.0))./pi;
        <span class="keyword">end</span>        

    <span class="keyword">case</span> {'</span>spikykernel<span class="string">' '</span>spiky<span class="string">'}        
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                hr = h - r
                n = h^6
                W(r) = piecewise(r<h,(1/s)*(hr*hr*hr/n),r>=h,0); <span class="comment">% kernel definition</span>
                s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<h)
                matlabFunction((subs(W3(R),R,r)))
                
            <span class="comment">%}</span>
            W = @(r) (r<h) .* (1.0./h.^6.*(h-r).^3.*1.5e+1)./pi;
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                hr = h - r
                n = h^5
                W(r) = piecewise(r<h,(1/s)*(hr*hr*hr/n),r>=h,0); <span class="comment">% kernel definition</span>
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<h)
                matlabFunction((subs(W2(R),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* (1.0./h.^5.*(h-r).^3.*1.0e+1)./pi;
        <span class="keyword">end</span>
    <span class="keyword">case</span> {'</span>spikykernelder<span class="string">','</span>spikyder<span class="string">'}
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                hr = h - r
                n = h^6
                W(r) = piecewise(r<h,(1/s)*(hr*hr*hr/n),r>=h,0); <span class="comment">% kernel definition</span>
                s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<h)
                matlabFunction((subs(diff(W3(R),R,1),R,r)))
                
            <span class="comment">%}</span>
            W = @(r) (r<h) .* (1.0./h.^6.*(h-r).^2.*-4.5e+1)./pi;
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                hr = h - r
                n = h^5
                W(r) = piecewise(r<h,(1/s)*(hr*hr*hr/n),r>=h,0); <span class="comment">% kernel definition</span>
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<h)
                matlabFunction((subs(diff(W2(R),R,1),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* (1.0./h.^5.*(h-r).^2.*-3.0e+1)./pi;
        <span class="keyword">end</span>

    <span class="keyword">case</span> '</span>gaussian<span class="string">'
        <span class="comment">% M. Liu, & G. Liu, Smoothed particle hydrodynamics (SPH): an overview and recent developments, “Archives of computational methods in engineering”, 17.1 (2010), pp. 25-76.</span>
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r) pi
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                W(r) = piecewise(r<=h,(1/s)*(exp(-(3*r/h)^2) - exp(-(3)^2)),r>h,0); <span class="comment">% kernel definition</span>
                s3D = simplify(solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s)); <span class="comment">% scaling factor in 3D</span>
                <span class="comment">% -pi*((2*h^3*exp(-9))/9 + (2276509072173613*h^3)/13835058055282163712 - (h^3*pi^(1/2)*erf(3))/27)</span>
                s3D = h^3*pi^(3/2)/27;
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<=h)
                matlabFunction((subs(W3(R),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* 1.0./h.^3.*1.0./pi.^(3.0./2.0).*(exp(1.0./h.^2.*r.^2.*-9.0)-1.234098040866796e-4).*2.7e+1;
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                W(r) = piecewise(r<=h,(1/s)*(exp(-(3*r/h)^2) - exp(-(3)^2)),r>h,0); <span class="comment">% kernel definition</span>
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 2D</span>
                <span class="comment">% (h^2*pi*exp(-9)*(18426255492059989099*exp(9) - 18446744073709551616))/166020696663385964544</span>
                s2D = pi*h^2/9; <span class="comment">% exp(-9) is dropped</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<=h)
                matlabFunction((subs(W2(R),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* (1.0./h.^2.*(exp(1.0./h.^2.*r.^2.*-9.0)-1.234098040866796e-4).*9.0)./pi;
        <span class="keyword">end</span>
    <span class="keyword">case</span> '</span>gaussiander<span class="string">'
        <span class="comment">% M. Liu, & G. Liu, Smoothed particle hydrodynamics (SPH): an overview and recent developments, “Archives of computational methods in engineering”, 17.1 (2010), pp. 25-76.</span>
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                W(r) = piecewise(r<=h,(1/s)*(exp(-(3*r/h)^2) - exp(-(3)^2)),r>h,0); <span class="comment">% kernel definition</span>
                s3D = simplify(solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s)); <span class="comment">% scaling factor in 3D</span>
                <span class="comment">% -pi*((2*h^3*exp(-9))/9 + (2276509072173613*h^3)/13835058055282163712 - (h^3*pi^(1/2)*erf(3))/27)</span>
                s3D = h^3*pi^(3/2)/27;
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<=h)
                matlabFunction((subs(diff(W3(R),R,1),R,r)))
            <span class="comment">%}</span>
            W =  @(r) (r<h) .* 1.0./h.^5.*r.*exp(1.0./h.^2.*r.^2.*-9.0).*(-8.727934135283096e+1);
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})
                assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})
                W(r) = piecewise(r<=h,(1/s)*(exp(-(3*r/h)^2) - exp(-(3)^2)),r>h,0); <span class="comment">% kernel definition</span>
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 2D</span>
                <span class="comment">% (h^2*pi*exp(-9)*(18426255492059989099*exp(9) - 18446744073709551616))/166020696663385964544</span>
                s2D = pi*h^2/9; <span class="comment">% exp(-9) is dropped</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<=h)
                matlabFunction((subs(diff(W2(R),R,1),R,r)))
            <span class="comment">%}</span>
            W =  @(r) (r<h) .* (1.0./h.^4.*r.*exp(1.0./h.^2.*r.^2.*-9.0).*-1.62e+2)./pi;

        <span class="keyword">end</span>
    <span class="keyword">case</span> {'</span>kernelwendlandquintic<span class="string">' '</span>wendlandquintickernel<span class="string">' '</span>wendlandquintic<span class="string">'}
        error('</span>the kernel <span class="string">''</span><span class="comment">%s<span class="string">''</span> is not implemented yet (pending)<span class="string">',type)</span>
    <span class="keyword">otherwise</span>
        error('</span>the kernel <span class="string">''</span><span class="comment">%s<span class="string">''</span> is not implemented<span class="string">',type)</span>
<span class="keyword">end</span>

<span class="comment">% --- old code --</span>

<span class="comment">% <span class="keyword">function</span> W = kernelSPH(h,type,d)</span>
<span class="comment">% % KERNELSPH <span class="keyword">return</span> a SPH kernel</span>
<span class="comment">% %</span>
<span class="comment">% %   Syntax:</span>
<span class="comment">% %       W = kernelSPH(h,type,d)</span>
<span class="comment">% %    Inputs:</span>
<span class="comment">% %           h : cutoff</span>
<span class="comment">% %        type : kenel name (default = Lucy)</span>
<span class="comment">% %           d : dimension</span>
<span class="comment">% %   Output:</span>
<span class="comment">% %           W : kernel <span class="keyword">function</span> @(r)</span>
<span class="comment">% %</span>
<span class="comment">% %   Example:</span>
<span class="comment">% %       W = kernelSPH(1,'</span>lucy<span class="string">',3)</span>
<span class="comment">% %</span>
<span class="comment">% %</span>
<span class="comment">% %   See also: interp3SPH, interp2SPH, packSPH</span>
<span class="comment">% </span>
<span class="comment">% </span>
<span class="comment">% % 2023-02-20 | INRAE\Olivier Vitrac | rev.</span>
<span class="comment">% </span>
<span class="comment">% % arg check</span>
<span class="comment">% <span class="keyword">if</span> nargin<1, h = []; <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> nargin<2, type = '</span><span class="string">'; <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> nargin<3, d = []; <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> isempty(h), error('</span>Supply a value <span class="keyword">for</span> h<span class="string">'), <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> isempty(type), type = '</span>lucy<span class="string">'; <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> ~ischar(type), error('</span>type must be a char array<span class="string">'), <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> isempty(d), d = 3; <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">if</span> (d<2) || (d>3), error('</span>d must be equal to 1, 2 or 3<span class="string">'), <span class="keyword">end</span></span>
<span class="comment">% </span>
<span class="comment">% % main</span>
<span class="comment">% <span class="keyword">switch</span> lower(type)</span>
<span class="comment">%     <span class="keyword">case</span> '</span>lucy<span class="string">'</span>
<span class="comment">%         <span class="keyword">if</span> d==3</span>
<span class="comment">%             %{</span>
<span class="comment">%                 syms R h s W(r)</span>
<span class="comment">%                 assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})</span>
<span class="comment">%                 assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})</span>
<span class="comment">%                 W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); % kernel definition</span>
<span class="comment">%                 s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); % scaling factor in 3D</span>
<span class="comment">%                 W3(r) = subs(W(r),s,s3D); % scaled kernel in 3D</span>
<span class="comment">%                 assume(R<h)</span>
<span class="comment">%                 matlabFunction((subs(W3(R),R,r)))</span>
<span class="comment">%             %}</span>
<span class="comment">%             W = @(r) (r<h) .* ( 1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1) )./pi;</span>
<span class="comment">%         <span class="keyword">elseif</span> d==2</span>
<span class="comment">%             %{</span>
<span class="comment">%                 syms R h s W(r)</span>
<span class="comment">%                 assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})</span>
<span class="comment">%                 assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})</span>
<span class="comment">%                 W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); % kernel definition</span>
<span class="comment">%                 s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); % scaling factor in 3D</span>
<span class="comment">%                 W2(r) = subs(W(r),s,s2D); % scaled kernel in 2D</span>
<span class="comment">%                 assume(R<h)</span>
<span class="comment">%                 matlabFunction((subs(W2(R),R,r)))</span>
<span class="comment">%             %}</span>
<span class="comment">%             W = @(r) (r<h) .* ( 1.0./h.^2.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*-5.0 )./pi;</span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">case</span> '</span>lucyder<span class="string">'</span>
<span class="comment">%         <span class="keyword">if</span> d==3</span>
<span class="comment">%             %{</span>
<span class="comment">%                 syms R h s W(r)</span>
<span class="comment">%                 assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})</span>
<span class="comment">%                 assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})</span>
<span class="comment">%                 W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); % kernel definition</span>
<span class="comment">%                 s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); % scaling factor in 3D</span>
<span class="comment">%                 W3(r) = subs(W(r),s,s3D); % scaled kernel in 3D</span>
<span class="comment">%                 assume(R<h)</span>
<span class="comment">%                 matlabFunction((subs(diff(W3(R),R,1),R,r)))</span>
<span class="comment">%             %}</span>
<span class="comment">%             W = @(r) (r<h) .* ( (1.0./h.^4.*(r./h-1.0).^3.*(-3.15e+2./1.6e+1))./pi-(1.0./h.^4.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*(3.15e+2./1.6e+1))./pi );</span>
<span class="comment">%         <span class="keyword">elseif</span> d==2</span>
<span class="comment">%             %{</span>
<span class="comment">%                 syms R h s W(r)</span>
<span class="comment">%                 assume(h,{'</span>real<span class="string">','</span>positive<span class="string">'})</span>
<span class="comment">%                 assume(r,{'</span>real<span class="string">','</span>positive<span class="string">'})</span>
<span class="comment">%                 W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); % kernel definition</span>
<span class="comment">%                 s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); % scaling factor in 2D</span>
<span class="comment">%                 W2(r) = subs(W(r),s,s2D); % scaled kernel in 2D</span>
<span class="comment">%                 assume(R<h)</span>
<span class="comment">%                 matlabFunction((subs(diff(W2(R),R,1),R,r)))</span>
<span class="comment">%             %}</span>
<span class="comment">%             W = @(r) (r<h) .* ( (1.0./h.^3.*(r./h-1.0).^3.*-1.5e+1)./pi-(1.0./h.^3.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*1.5e+1)./pi );</span>
<span class="comment">%         <span class="keyword">end</span></span>
<span class="comment">%     <span class="keyword">otherwise</span></span>
<span class="comment">%         error('</span>the kernel <span class="string">''</span>%s<span class="string">''</span> is not implemented',type)</span>
<span class="comment">% <span class="keyword">end</span></span>
</code></pre></div>
</div>
<div id='lamdumpread2' class='doc-content' style='display: none;'>
<h1>LAMDUMPREAD2 read on the fly LAMMPS dump files (recognized formats: TEXT=&#x27;*&#x27;, TEXT GZIPPED=&#x27;*.gz&#x27;, BINARIES=&#x27;*.bin&#x27;)</h1>
<p>LAMDUMPRREAD2 is a fork of LAMDUMPREAD (work in progress to implement standards similar to those those used in OVITO)</p>
<p>LAMMPS FORMATS<br/>TEXT: editable, readable format (default format in LAMMPS)<br/>loading time: +++++            : file size ++++++++<br/>TEXT GZIPPED: as above but compressed (file size reduction 60 %, LAMMPS requires to be compiled with -DGZIP flag)<br/>loading time: ++++++++++++++++ : file size ++++<br/>BINARY: proprietary format (leads to the largest files but the fastest to open)<br/>loading time: ++               : file size +++++++++++<br/>SYNTAX AND OUTPUTS<br/>------------------<br/>X = lamdumpread(dumpfilename)<br/>X.KEYWORD{i} = RECORD (by default)<br/>X.KEYWORD(:,:,i) = RECORD when collect is used (or when LAMDUMPSAVE is used);<br/>KEYWORD = keyword (e.g. TIMESTEP NUMBEROFATOMS BOXBOUNDS ATOMS ... )<br/>RECORD  = array<br/>OPTIONS FOR ALL FORMATS<br/>-----------------------<br/>X = lamdumpread(dumpfilename [,action, molecules, itimes, iatoms])</p>
<p>action: keyword among &#x27;collect&#x27;,&#x27;count&#x27;,&#x27;robot&#x27;,&#x27;split&#x27;, &#x27;default&#x27;, &#x27;search&#x27;</p>
<p>Actions controlling the way the file filename is read<br/>if &#x27;collect&#x27; is used, array data are stored into a 3 dims-arrays instead of a cell array<br/>if &#x27;count&#x27; is used, the size of each dataset is determined and not loaded<br/>For binary files, &#x27;collect&#x27; is always applied.<br/>Actions controlling batches<br/>if &#x27;robot&#x27; or &#x27;prefetch&#x27; is used, all files are read and a prefetch is created<br/>if &#x27;split&#x27; is used, all files are split into small prefetch files<br/>if &#x27;usesplit&#x27; is used, split files have higher precedence than prefetch files<br/>if &#x27;forceprefetch&#x27; is used, it force the genration of prefetch files even if split files exist)<br/>-- notes --<br/>lampdumpread() generate all prefetch files (high memory footprint)<br/>lamdumpread2(&#x27;dump.*&#x27;,&#x27;split&#x27;) force split even if prefetch files have been generated<br/>lamdumpread(&#x27;mydump&#x27;,&#x27;usesplit&#x27;,[],[0 500]) load specifically frames 0 and 500 from split files<br/>Actions giving details on dump files and their prefetches<br/>if &#x27;default&#x27; is used (same behavior with &quot;#prefetch&quot; as filename), X is a structure with fields:<br/>prefetch.file giving the prefetch file or anonymous function doing so for any filename fn<br/>prefetch.folder idem for the prefetch folder<br/>prefetch.frame is anonymous function @(filname,iframe) or @(itime) giving the filename of each split frame<br/>if &#x27;search&#x27; is used the dump file is looked for inside subfolders with the following precedence : splits, prefetech and<br/>original files</p>
<p>molecules: cell array to build molecules according to X.ATOMS<br/>molecules{i} list all atoms belonging to the ith molecule<br/>X.ATOMS is replaced by X.MOLECULES<br/>where X.MOLECULES{molecule index}(internal atom index,coordinate index,time step index)</p>
<p>OPTIONS FOR TEXT AND GZIPPED FORMATS<br/>------------------------------------<br/>X = lamdumpread(dumpfilename,[action],[molecules],[itimes],[iatoms])<br/>itimes: requested timestep index (if empty, all timesteps are loadted)<br/>iatoms: requested atom index; when molecules is used, index of molecules instead</p>
<p>SIMPLE EXAMPLE: based on in.LJ<br/>------------------------------<br/>X=lamdumpread(&#x27;dump.atom&#x27;)<br/>X =<br/>TIMESTEP: [0 100]<br/>NUMBEROFATOMS: [32000 32000]<br/>BOXBOUNDS: {[3x2 single]  [3x2 single]}<br/>ATOMS: {[32000x5 single]  [32000x5 single]}</p>
<p>&gt;&gt; simple 3D plot with: plot3(X.ATOMS{2}(:,3),X.ATOMS{2}(:,4),X.ATOMS{2}(:,5),&#x27;ro&#x27;)</p>
<p>ADVANCED EXAMPLES<br/>-----------------<br/>1) Extract the coordinates of 2 molecules consisting in atoms 1:1000 and 3001:4000 respectively<br/>for the timestep indices 1 and 11<br/>X=lamdumpread(&#x27;dump.atom.gz&#x27;,&#x27;collect&#x27;,{1:1000 3001:4000},[1 11])<br/>X =<br/>TIMESTEP: [0 1000]<br/>NUMBEROFATOMS: [32000 32000]<br/>BOXBOUNDS: [3x2x2 single]<br/>ATOMS: [32000 5 11]    &lt;&lt; this field is only informative<br/>MOLECULES: {2x1 cell}      &lt;&lt; Molecular data are stored here ({[1000x3x2 single];[1000x3x2 single]})</p>
<p>2) Extract the coordinates of a group of atoms [1:1000 3001:4000] for all timesteps<br/>X=lamdumpread(&#x27;dump.atom.gz&#x27;,&#x27;collect&#x27;,{},[],[1:1000 3001:4000])<br/>X =<br/>TIMESTEP: [0 100 200 300 400 500 600 700 800 900 1000]<br/>NUMBEROFATOMS: [32000 32000 32000 32000 32000 32000 32000 32000 32000 32000 32000]<br/>BOXBOUNDS: [3x2x11 single]<br/>ATOMS: [2000x5x11 single]</p>
<h2>See also</h2>
<p>LAMDUMPSAVE, LAMMPSCHAIN, LAMPLOT, GZIPR</p>
<h2>See also</h2>
<p></p>
<h2>See also</h2>
<p>-------------------------------------------------, EXAMPLES, FROM, THE, PHD, THESIS, OF, WILLIAM, JENKINSON, -------------------------------------------------, {</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> X=lamdumpread2(filename,action,molecules,itimes,iatoms)
<span class="comment">%LAMDUMPREAD2 read on the fly LAMMPS dump files (recognized formats: TEXT=<span class="string">'*'</span>, TEXT GZIPPED=<span class="string">'*.gz'</span>, BINARIES=<span class="string">'*.bin'</span>)</span>
<span class="comment">% LAMDUMPRREAD2 is a fork of LAMDUMPREAD (work in progress to implement standards similar to those those used in OVITO)</span>
<span class="comment">%</span>
<span class="comment">% LAMMPS FORMATS</span>
<span class="comment">%               TEXT: editable, readable format (default format in LAMMPS)</span>
<span class="comment">%                     loading time: +++++            : file size ++++++++</span>
<span class="comment">%       TEXT GZIPPED: as above but compressed (file size reduction 60 %, LAMMPS requires to be compiled with -DGZIP flag)</span>
<span class="comment">%                     loading time: ++++++++++++++++ : file size ++++</span>
<span class="comment">%             BINARY: proprietary format (leads to the largest files but the fastest to open)</span>
<span class="comment">%                     loading time: ++               : file size +++++++++++</span>
<span class="comment">% SYNTAX AND OUTPUTS</span>
<span class="comment">% ------------------</span>
<span class="comment">%   X = lamdumpread(dumpfilename)</span>
<span class="comment">%         X.KEYWORD{i} = RECORD (by default)</span>
<span class="comment">%         X.KEYWORD(:,:,i) = RECORD when collect is used (or when LAMDUMPSAVE is used);</span>
<span class="comment">%           KEYWORD = keyword (e.g. TIMESTEP NUMBEROFATOMS BOXBOUNDS ATOMS ... )</span>
<span class="comment">%           RECORD  = array</span>
<span class="comment">% OPTIONS FOR ALL FORMATS</span>
<span class="comment">% -----------------------</span>
<span class="comment">%   X = lamdumpread(dumpfilename [,action, molecules, itimes, iatoms])</span>
<span class="comment">%</span>
<span class="comment">%          action: keyword among <span class="string">'collect'</span>,<span class="string">'count'</span>,<span class="string">'robot'</span>,<span class="string">'split'</span>, <span class="string">'default'</span>, <span class="string">'search'</span></span>
<span class="comment">%</span>
<span class="comment">%               Actions controlling the way the file filename is read</span>
<span class="comment">%                  <span class="keyword">if</span> <span class="string">'collect'</span> is used, array data are stored into a 3 dims-arrays instead of a cell array</span>
<span class="comment">%                  <span class="keyword">if</span> <span class="string">'count'</span> is used, the size of each dataset is determined and not loaded</span>
<span class="comment">%                  For binary files, <span class="string">'collect'</span> is always applied.</span>
<span class="comment">%               Actions controlling batches</span>
<span class="comment">%                  <span class="keyword">if</span> <span class="string">'robot'</span> or <span class="string">'prefetch'</span> is used, all files are read and a prefetch is created</span>
<span class="comment">%                  <span class="keyword">if</span> <span class="string">'split'</span> is used, all files are split into small prefetch files</span>
<span class="comment">%                  <span class="keyword">if</span> <span class="string">'usesplit'</span> is used, split files have higher precedence than prefetch files</span>
<span class="comment">%                  <span class="keyword">if</span> <span class="string">'forceprefetch'</span> is used, it force the genration of prefetch files even <span class="keyword">if</span> split files exist)</span>
<span class="comment">%                   -- notes --</span>
<span class="comment">%                       lampdumpread() generate all prefetch files (high memory footprint)</span>
<span class="comment">%                       lamdumpread2(<span class="string">'dump.*'</span>,<span class="string">'split'</span>) force split even <span class="keyword">if</span> prefetch files have been generated</span>
<span class="comment">%                       lamdumpread(<span class="string">'mydump'</span>,<span class="string">'usesplit'</span>,[],[0 500]) load specifically frames 0 and 500 from split files</span>
<span class="comment">%               Actions giving details on dump files and their prefetches</span>
<span class="comment">%                   <span class="keyword">if</span> <span class="string">'default'</span> is used (same behavior with "#prefetch" as filename), X is a structure with fields:</span>
<span class="comment">%                                 prefetch.file giving the prefetch file or anonymous <span class="keyword">function</span> doing so <span class="keyword">for</span> any filename fn</span>
<span class="comment">%                                 prefetch.folder idem <span class="keyword">for</span> the prefetch folder</span>
<span class="comment">%                                 prefetch.frame is anonymous <span class="keyword">function</span> @(filname,iframe) or @(itime) giving the filename of each split frame</span>
<span class="comment">%                   <span class="keyword">if</span> <span class="string">'search'</span> is used the dump file is looked <span class="keyword">for</span> inside subfolders with the following precedence : splits, prefetech and</span>
<span class="comment">%                   original files</span>
<span class="comment">%</span>
<span class="comment">%       molecules: cell array to build molecules according to X.ATOMS</span>
<span class="comment">%                  molecules{i} list all atoms belonging to the ith molecule</span>
<span class="comment">%                  X.ATOMS is replaced by X.MOLECULES</span>
<span class="comment">%                  where X.MOLECULES{molecule index}(internal atom index,coordinate index,time step index)</span>
<span class="comment">%</span>
<span class="comment">% OPTIONS FOR TEXT AND GZIPPED FORMATS</span>
<span class="comment">% ------------------------------------</span>
<span class="comment">%   X = lamdumpread(dumpfilename,[action],[molecules],[itimes],[iatoms])</span>
<span class="comment">%          itimes: requested timestep index (<span class="keyword">if</span> empty, all timesteps are loadted)</span>
<span class="comment">%          iatoms: requested atom index; when molecules is used, index of molecules instead</span>
<span class="comment">%</span>
<span class="comment">% SIMPLE EXAMPLE: based on in.LJ</span>
<span class="comment">% ------------------------------</span>
<span class="comment">%   X=lamdumpread(<span class="string">'dump.atom'</span>)</span>
<span class="comment">%   X =</span>
<span class="comment">%        TIMESTEP: [0 100]</span>
<span class="comment">%   NUMBEROFATOMS: [32000 32000]</span>
<span class="comment">%       BOXBOUNDS: {[3x2 single]  [3x2 single]}</span>
<span class="comment">%           ATOMS: {[32000x5 single]  [32000x5 single]}</span>
<span class="comment">%</span>
<span class="comment">%   >> simple 3D plot with: plot3(X.ATOMS{2}(:,3),X.ATOMS{2}(:,4),X.ATOMS{2}(:,5),<span class="string">'ro'</span>)</span>
<span class="comment">%</span>
<span class="comment">% ADVANCED EXAMPLES</span>
<span class="comment">% -----------------</span>
<span class="comment">%  1) Extract the coordinates of 2 molecules consisting in atoms 1:1000 and 3001:4000 respectively</span>
<span class="comment">%     <span class="keyword">for</span> the timestep indices 1 and 11</span>
<span class="comment">%     X=lamdumpread(<span class="string">'dump.atom.gz'</span>,<span class="string">'collect'</span>,{1:1000 3001:4000},[1 11])</span>
<span class="comment">%     X =</span>
<span class="comment">%          TIMESTEP: [0 1000]</span>
<span class="comment">%     NUMBEROFATOMS: [32000 32000]</span>
<span class="comment">%         BOXBOUNDS: [3x2x2 single]</span>
<span class="comment">%             ATOMS: [32000 5 11]    << this field is only informative</span>
<span class="comment">%         MOLECULES: {2x1 cell}      << Molecular data are stored here ({[1000x3x2 single];[1000x3x2 single]})</span>
<span class="comment">%</span>
<span class="comment">%   2) Extract the coordinates of a group of atoms [1:1000 3001:4000] <span class="keyword">for</span> all timesteps</span>
<span class="comment">%      X=lamdumpread(<span class="string">'dump.atom.gz'</span>,<span class="string">'collect'</span>,{},[],[1:1000 3001:4000])</span>
<span class="comment">%      X =</span>
<span class="comment">%          TIMESTEP: [0 100 200 300 400 500 600 700 800 900 1000]</span>
<span class="comment">%     NUMBEROFATOMS: [32000 32000 32000 32000 32000 32000 32000 32000 32000 32000 32000]</span>
<span class="comment">%         BOXBOUNDS: [3x2x11 single]</span>
<span class="comment">%             ATOMS: [2000x5x11 single]</span>
<span class="comment">%</span>
<span class="comment">%   See also: LAMDUMPSAVE, LAMMPSCHAIN, LAMPLOT, GZIPR</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">% -------------------------------------------------</span>
<span class="comment">% EXAMPLES FROM THE PHD THESIS OF WILLIAM JENKINSON</span>
<span class="comment">% -------------------------------------------------</span>
<span class="comment">%{</span>
    cd ~/billy/matlab/sandbox/

    <span class="comment">% == simple 2D simulation (standard nomenclature) ==</span>
    X = lamdumpread2(fullfile(<span class="string">'misc_dumpfiles'</span>,<span class="string">'dump.wall.2d'</span>))

    <span class="comment">% == complex 3D simulation ==</span>
    X = lamdumpread2(fullfile(<span class="string">'misc_dumpfiles'</span>,<span class="string">'dump.backextrusion_v3b'</span>)) <span class="comment">% nothing inside</span>
    TIMESTEP = X.TIMESTEP;
    A = X.ATOMS(X.ATOMS.type==1,:); <span class="comment">% liquid</span>
    B = X.ATOMS(X.ATOMS.type==2,:); <span class="comment">% walls</span>
    listidB = B.id(B.TIMESTEP==TIMESTEP(1));
    zB = B.z; idB = B.id; <span class="comment">% to reduce memory impact when arrayfun is used</span>
    dzB = arrayfun(@(id) sqrt(mean(diff(zB(idB==id)).^2)),listidB); <span class="comment">% mean displacement (long calculations)</span>
    B0 = B(ismember(B.id,listidB(dzB==0)),:); <span class="comment">% static cylinder</span>
    B1 = B(ismember(B.id,listidB(dzB>0)),:);  <span class="comment">% moving cylinder</span>
    plotback =  @(it) [
    plot3(A.x (A.TIMESTEP ==TIMESTEP(it)), A.y( A.TIMESTEP==TIMESTEP(it)),A.z( A.TIMESTEP==TIMESTEP(it)),<span class="string">'bo'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'b'</span>,<span class="string">'markersize'</span>,5)
    plot3(B0.x(B0.TIMESTEP==TIMESTEP(it)),B0.y(B0.TIMESTEP==TIMESTEP(it)),B0.z(B0.TIMESTEP==TIMESTEP(it)),<span class="string">'r.'</span>)
    plot3(B1.x(B1.TIMESTEP==TIMESTEP(it)),B1.y(B1.TIMESTEP==TIMESTEP(it)),B1.z(B1.TIMESTEP==TIMESTEP(it)),<span class="string">'g.'</span>)
     ];
    figure, view(3), <span class="keyword">for</span> it=1:length(TIMESTEP), cla, hold on, plotback(it); title(sprintf(<span class="string">'t= <span class="comment">%4g'</span>,TIMESTEP(it))), drawnow, <span class="keyword">end</span></span>

    <span class="comment">% == complex 3D simulation ==</span>
    X = lamdumpread2(<span class="string">'/home/olivi/billy/lammps/sandbox/dump.backextrusion_v3a'</span>);
    TIMESTEP = unique(X.ATOMS_grp01.TIMESTEP);
    A = X.ATOMS_grp01(X.ATOMS_grp01.type==1,:); <span class="comment">% liquid</span>
    B = X.ATOMS_grp01(X.ATOMS_grp01.type==2,:); <span class="comment">% walls</span>
    listidB = B.id(B.TIMESTEP==TIMESTEP(1));
    zB = B.z; idB = B.id; <span class="comment">% to reduce memory impact when arrayfun is used</span>
    dzB = arrayfun(@(id) sqrt(mean(diff(zB(idB==id)).^2)),listidB); <span class="comment">% mean displacement (long calculations)</span>
    B0 = B(ismember(B.id,listidB(dzB==0)),:); <span class="comment">% static cylinder</span>
    B1 = B(ismember(B.id,listidB(dzB>0)),:);  <span class="comment">% moving cylinder</span>
    plotback =  @(it) [
    plot3(A.x(A.TIMESTEP ==TIMESTEP(it)), A.y( A.TIMESTEP==TIMESTEP(it)),A.z( A.TIMESTEP==TIMESTEP(it)),<span class="string">'bo'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'b'</span>,<span class="string">'markersize'</span>,5)
    plot3(B0.x(B0.TIMESTEP==TIMESTEP(it)),B0.y(B0.TIMESTEP==TIMESTEP(it)),B0.z(B0.TIMESTEP==TIMESTEP(it)),<span class="string">'r.'</span>)
    plot3(B1.x(B1.TIMESTEP==TIMESTEP(it)),B1.y(B1.TIMESTEP==TIMESTEP(it)),B1.z(B1.TIMESTEP==TIMESTEP(it)),<span class="string">'g.'</span>)
     ];
    figure, view(3), cameratoolbar(<span class="string">'Show'</span>), <span class="keyword">for</span> it=1:length(TIMESTEP), cla, hold on, plotback(it); title(sprintf(<span class="string">'t= <span class="comment">%4g'</span>,TIMESTEP(it))), drawnow, <span class="keyword">end</span></span>
    
    <span class="comment">% profile extraction</span>
    <span class="comment">% bottom position of B0</span>
    [~,ibottom] = min(B1.z(B1.TIMESTEP==TIMESTEP(1)));
    zbottom = B1.z(B1.id==B1.id(ibottom));
    figure, plot(TIMESTEP,zbottom), ylabel(<span class="string">'z'</span>), xlabel(<span class="string">'t'</span>)
    <span class="comment">% center and radius of B0</span>
    xmean = mean(B0.x(B0.TIMESTEP==TIMESTEP(1)));
    ymean = mean(B0.y(B0.TIMESTEP==TIMESTEP(1)));
    rB0 = max( sqrt( (B0.x(B0.TIMESTEP==TIMESTEP(1)) - xmean).^2 + (B0.y(B0.TIMESTEP==TIMESTEP(1)) - ymean).^2 ) );
    <span class="comment">% sample positions</span>
    nr = 200; r = linspace(0,rB0,nr+1);
    rA = sqrt( (A.x - xmean).^2 + (A.y - ymean).^2 );
	nt = length(TIMESTEP);
    vz = zeros(nt,nr);
    <span class="keyword">for</span> it=1:nt
        okt  = (A.TIMESTEP==TIMESTEP(it)) & (A.z>zbottom(it));
        <span class="keyword">if</span> any(okt)
            vzt  = A.vz(okt);
            rAt = rA(okt); 
            <span class="keyword">for</span> ir = 1:nr
                ind = (rAt>=r(ir)) & (rAt<r(ir+1));
                vz(it,ir) = max(0,mean(vzt(ind)));
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    itplot = find(any(abs(vz)>0,1),1,<span class="string">'first'</span>):nt; nitplot = length(itplot);
    figure, colororder(jet(nitplot)); plot(r(1:<span class="keyword">end</span>-1),vz(itplot,:),<span class="string">'-'</span>,<span class="string">'linewidth'</span>,2), xlabel(<span class="string">'r'</span>), ylabel(<span class="string">'vz'</span>)
    
<span class="comment">%}    </span>


<span class="comment">% MS 2.1 - 22/01/08 - INRA\Olivier Vitrac rev. 2023-08-22</span>

<span class="comment">% Revision history</span>
<span class="comment">% 05/03/08 add action</span>
<span class="comment">% 05/03/08 convert ATOMS field into MOLECULES</span>
<span class="comment">% 09/03/08 add an efficient engine <span class="keyword">for</span> binary files</span>
<span class="comment">% 12/03/08 add support <span class="keyword">for</span> GZ files using gzipr and popenr</span>
<span class="comment">% 13/03/08 fix error index associated to matrices with a sintle timestep, impose single precision</span>
<span class="comment">% 14/03/08 add itimes, iatoms, generalized counter</span>
<span class="comment">% 15/03/08 fix numberofdims (improve rules <span class="keyword">for</span> row and column vectors)</span>
<span class="comment">% 17/04/09 trim data</span>
<span class="comment">% 06/10/09 add excludedexpr</span>
<span class="comment">% 2021/02/11 implement R2020b standards</span>
<span class="comment">% 2021/02/15 format ATOMS as Ovito 3.x</span>
<span class="comment">% 2021/02/15a updated version to split automatically broken simulations (with non constant number of atoms)</span>
<span class="comment">% 2021/03/03 generalized ITEM: %[] ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_[]</span>
<span class="comment">% 2021/03/04 the rule to separate keywords (keys) and their descriptions (variable names) has been customized</span>
<span class="comment">%            initially it was thought that keys were uppercase and descriptions lowercase.</span>
<span class="comment">%            It is not the <span class="keyword">case</span>, some variables include letters in capitals (e.g. c_S_s[1])</span>
<span class="comment">%            In the future, the implemented rule may suffer some flaws as not all possible variable names have not been explored.</span>
<span class="comment">% 2022/11/26 remove \d ([0-9]) from keywords</span>
<span class="comment">% 2023-03-23 add robot, prefetch management, remove [] from ITEM</span>
<span class="comment">% 2023-04-02 sort files by size before applying the robot (smaller files first)</span>
<span class="comment">% 2023-04-04 fix lampdumpread2 or files inclding one single frame</span>
<span class="comment">% 2023-04-11 split all dumpfiles larger than 8GB into individual frames</span>
<span class="comment">% 2023-04-14 set actions <span class="string">'prefetch'</span>,<span class="string">'split'</span>,<span class="string">'usesplit'</span></span>
<span class="comment">% 2023-04-25 add forceprefetch</span>
<span class="comment">% 2023-04-27 add TIMESTEPS, TIMESTEPfirst, TIMESTEPlast when <span class="string">'usesplit'</span> is used</span>
<span class="comment">% 2023-08-22 fixes <span class="keyword">for</span> workshop on post treatment</span>

<span class="comment">% KNOWN LIMITATIONS</span>
<span class="comment">% <span class="string">'collect'</span> works only on standard MD DUMP files, not on SMD/SMD dump files... <span class="keyword">for</span> now</span>

<span class="comment">% Patterns (see textscan <span class="keyword">for</span> details and the example provided)</span>
<span class="comment">% a=textscan(<span class="string">'ITEM: NUMBER OF ATOMS'</span>,[<span class="string">'ITEM: %[ '</span> <span class="string">'A'</span>:<span class="string">'Z'</span> <span class="string">']'</span>]); a{1}</span>
variablepattern = [<span class="string">'ITEM: <span class="comment">%[] '</span> <span class="string">'A'</span>:<span class="string">'Z'</span> <span class="string">'a'</span>:<span class="string">'z'</span> <span class="string">'0'</span>:<span class="string">'9'</span> <span class="string">'_[]'</span>];</span>
numsep = <span class="string">' '</span>;        <span class="comment">% column separator    A = X.ATOMS(X.ATOMS.type==1,:);</span>
datatype = <span class="string">'single'</span>; <span class="comment">% single precision (replace by <span class="string">'double'</span> to force double precision)</span>
numpattern = <span class="string">'<span class="comment">%f32'</span>; % idem (replace by <span class="string">'%f'</span> to force double precision<span class="string">')</span>
maxfilesize = 8e9;   <span class="comment">% 8 GB (size before splitting)</span>
<span class="comment">%prefetchthreshold = 1e7; % bytes</span>
robotdepth = 100; <span class="comment">% maxdepth search</span>
<span class="comment">% excludedexpr = '</span>\sid type xu yu zu\s$<span class="string">'; % regular expression % removed 02/14/2021</span>
SPLITPREFIX = '</span>TIMESTEP_<span class="string">'; <span class="comment">% added 2023/04/11</span>
makeprefetch = @(fn) fullfile(rootdir(fn),['</span>PREFETCH_<span class="string">' lastdir(fn) '</span>.mat<span class="string">']); <span class="comment">% added 2023/03/23</span>
makesplitdir = @(fn) fullfile(rootdir(fn),['</span>PREFETCH_<span class="string">' lastdir(fn)]); <span class="comment">% added 2023/03/23</span>
makesplit = @(fn,itime) fullfile(makesplitdir(fn),sprintf('</span><span class="comment">%s%09d.mat<span class="string">',SPLITPREFIX,itime)); % added 2023/04/11</span>

<span class="comment">% Arg check</span>
robot = false;
<span class="keyword">if</span> nargin<1, robot = true; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, action = '</span><span class="string">'; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, molecules = {}; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, itimes = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, iatoms = []; <span class="keyword">end</span>
collecton = strcmpi(action,'</span>collect<span class="string">');
DEBUGON = true; <span class="comment">% set DEBUGON to true <span class="keyword">for</span> debuggind, false <span class="keyword">otherwise</span></span>

<span class="comment">% automatic robot (added 2023-03-23)</span>
<span class="keyword">if</span> robot, filename = '</span>dump.*<span class="string">'; <span class="keyword">end</span>
<span class="keyword">if</span> any(filename=='</span>*<span class="string">'), robot = true; <span class="keyword">end</span>
<span class="keyword">if</span> strcmpi(filename,'</span>#prefetch<span class="string">'), action='</span>default<span class="string">'; filename='</span><span class="string">'; <span class="keyword">end</span>
[datafolder,fn,en] = fileparts(filename);
dumpfile = [fn en];

<span class="comment">% action on several files</span>
<span class="keyword">switch</span> lower(action)
    <span class="keyword">case</span> '</span>prefetch<span class="string">'
        robot = true;
        action = '</span><span class="string">';
    <span class="keyword">case</span> '</span>forceprefetch<span class="string">'
        robot = true;
        action = '</span>robotprefetch<span class="string">';
    <span class="keyword">case</span> '</span>split<span class="string">'
        robot = true;
        action = '</span>robotsplit<span class="string">';
    <span class="keyword">case</span> '</span>default<span class="string">'
        <span class="comment">% <span class="keyword">return</span> the default prefetch files</span>
        <span class="keyword">if</span> isempty(filename)
            X = struct('</span>prefetch<span class="string">',struct('</span>file<span class="string">',makeprefetch,'</span>folder<span class="string">',makesplitdir), ...
                '</span>frame<span class="string">',makesplit);
        <span class="keyword">elseif</span> ischar(filename)
            X = struct( ...
                '</span>source<span class="string">',filename,...
                '</span>prefetch<span class="string">',struct('</span>file<span class="string">',makeprefetch(filename),'</span>folder<span class="string">',makesplitdir(filename)), ...
                '</span>frame<span class="string">',@(itime) makesplit(filename,itime));
            <span class="keyword">return</span>
        <span class="keyword">else</span>
            error('</span>filename should be a char or empty when action=<span class="string">''</span>default<span class="string">''</span><span class="string">')
        <span class="keyword">end</span>
    <span class="keyword">case</span> '</span>search<span class="string">'
        found = false; completed = false;
        searchmode = {'</span>splitfolder<span class="string">','</span>prefetch<span class="string">','</span>original<span class="string">'};
        isearchmode = 0;
        <span class="keyword">while</span> ~found && ~completed
            isearchmode = isearchmode+1;
            current_searchmode = searchmode{isearchmode};
            framefolder = '</span><span class="string">';
            <span class="comment">% search</span>
            datafolder_bak = datafolder;
            <span class="keyword">switch</span> current_searchmode
                <span class="keyword">case</span> '</span>original<span class="string">'
                    <span class="comment">% We look <span class="keyword">for</span> the original dump files</span>
                    foundmatchingdumps = explore(dumpfile,datafolder,[],'</span>abbreviate<span class="string">');
                    found = ~isempty(foundmatchingdumps);
                    <span class="keyword">if</span> found
                        <span class="keyword">if</span> length(foundmatchingdumps)>1
                            warning('</span><span class="comment">%d copies of the same dump file has been found in <span class="string">''</span>%s<span class="string">''</span>, the first is used<span class="string">',length(dumpfiles),datafolder)</span>
                            foundmatchingdumps = foundmatchingdumps(1);
                        <span class="keyword">end</span>
                        datafolder = foundmatchingdumps.path;
                        framefolder = fullfile(datafolder,makesplitdir(dumpfile));
                    <span class="keyword">end</span>
                <span class="keyword">case</span> '</span>prefetch<span class="string">'
                    <span class="comment">% We look <span class="keyword">for</span> the prefetch dump files</span>
                    foundmatchingdumps = explore(lastdir(makeprefetch(dumpfile)),datafolder,[],'</span>abbreviate<span class="string">');
                    found = ~isempty(foundmatchingdumps);
                    <span class="keyword">if</span> found
                        <span class="keyword">if</span> length(foundmatchingdumps)>1
                            warning('</span><span class="comment">%d copies of the same dump file has been found in <span class="string">''</span>%s<span class="string">''</span>, the first is used<span class="string">',length(dumpfiles),datafolder)</span>
                            foundmatchingdumps = foundmatchingdumps(1);
                        <span class="keyword">end</span>
                        datafolder = foundmatchingdumps.path;
                        framefolder = fullfile(datafolder,makesplitdir(dumpfile));
                    <span class="keyword">end</span>
                <span class="keyword">case</span> '</span>splitfolder<span class="string">'
                    framefilepattern = makesplit(fullfile(datafolder,dumpfile),0);
                    <span class="keyword">if</span> ~exist(framefilepattern,'</span>file<span class="string">')
                        dispf('</span>Look <span class="keyword">for</span> <span class="string">''</span><span class="comment">%s<span class="string">''</span>... (be patient)<span class="string">',dumpfile)</span>
                        frameid = lastdir(framefilepattern);
                        parentframeid = lastdir(rootdir(framefilepattern));
                        foundmatchingdumps = explore(frameid,datafolder,[],'</span>abbreviate<span class="string">');
                        found = ~isempty(foundmatchingdumps);
                        <span class="keyword">if</span> found
                            foundmatchingdumps = foundmatchingdumps(strcmp(cellfun(@lastdir,{foundmatchingdumps.subpath}'</span>,<span class="string">'UniformOutput'</span>,false),parentframeid));
                            nfoundmatchingdumps = length(foundmatchingdumps);
                            <span class="keyword">if</span> nfoundmatchingdumps==1
                                datafolder = rootdir(foundmatchingdumps.path);
                                dispf(<span class="string">'...found in '</span><span class="string">'<span class="comment">%s'</span><span class="string">'\n'</span>,datafolder)</span>
                            <span class="keyword">elseif</span> nfoundmatchingdumps>1
                                warning(<span class="string">'<span class="comment">%d dump files are matching, only the first is used'</span>,nfoundmatchingdumps)</span>
                                datafolder = rootdir(foundmatchingdumps(1).path);
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                    framefolder = makesplitdir(fullfile(datafolder,dumpfile));
                    framefile = makesplit(fullfile(datafolder,dumpfile),0);
                <span class="keyword">otherwise</span>
                    error(<span class="string">'unrecognized searchmode '</span><span class="string">'<span class="comment">%s'</span><span class="string">''</span>,searcurrent_searchmodechmode)</span>
            <span class="keyword">end</span> <span class="comment">% <span class="keyword">end</span> <span class="keyword">switch</span></span>
            <span class="keyword">if</span> found
                firstframeok = false;
                dispf(<span class="string">'The dumpfile '</span><span class="string">'<span class="comment">%s'</span><span class="string">' has been found with the method '</span><span class="string">'%s'</span><span class="string">''</span>,dumpfile,current_searchmode)</span>
                dispf(<span class="string">'\tin the folder: <span class="comment">%s'</span>,datafolder);</span>
                <span class="keyword">if</span> ~strcmp(datafolder,datafolder_bak)
                    dispf(<span class="string">'the original search started in <span class="comment">%s'</span>,datafolder_bak)</span>
                <span class="keyword">end</span>
                <span class="keyword">if</span> exist(framefolder,<span class="string">'dir'</span>)
                    dispf(<span class="string">'The frame (split) folder is: <span class="comment">%s'</span>,framefolder)</span>
                <span class="keyword">end</span>
                <span class="keyword">if</span> exist(framefile,<span class="string">'file'</span>)
                    dispf(<span class="string">'The first frame (split) is located in: <span class="comment">%s'</span>,framefile)</span>
                    firstframeok = true;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            completed = strcmp(current_searchmode,searchmode{<span class="keyword">end</span>});
        <span class="keyword">end</span> <span class="comment">% <span class="keyword">end</span> <span class="keyword">while</span></span>
        <span class="keyword">if</span> ~found,
            error(<span class="string">'the dumpfile '</span><span class="string">'<span class="comment">%s'</span><span class="string">' does not exist in '</span><span class="string">'%s'</span><span class="string">''</span>,dumpfile,datafolder_bak)</span>
        <span class="keyword">else</span>
            <span class="keyword">if</span> firstframeok <span class="comment">% we <span class="keyword">return</span> the first frame (default behavior)</span>
                X = lamdumpread2(fullfile(datafolder,dumpfile),<span class="string">'usesplit'</span>);
            <span class="keyword">end</span>
            X = datafolder;
            <span class="keyword">return</span>
        <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">% swicth action</span>

<span class="comment">% Pseudo-recursion on many files</span>
<span class="keyword">if</span> robot
    <span class="keyword">if</span> isempty(datafolder), robotpath = pwd; <span class="keyword">else</span>, robotpath = datafolder; <span class="keyword">end</span>
    robotfile = dumpfile;
    dumpfiles = explore(robotfile,robotpath,robotdepth,<span class="string">'abbreviate'</span>);
    dumpfiles = dumpfiles(cellfun(@isempty,regexp({dumpfiles.ext},<span class="string">'gz$'</span>,<span class="string">'once'</span>)));
    [~,ind] = sort([dumpfiles.bytes],<span class="string">'ascend'</span>); dumpfiles = dumpfiles(ind);
    nfiles = length(dumpfiles);
    <span class="keyword">for</span> ifile = 1:nfiles
        currentdumpfile = fullfile(dumpfiles(ifile).path,dumpfiles(ifile).file);
        <span class="keyword">if</span> ~exist(makeprefetch(currentdumpfile),<span class="string">'file'</span>) || strcmpi(action,<span class="string">'robotsplit'</span>)
            dispf(<span class="string">'LAMPDUMPREAD AUTO <span class="comment">%d of %d'</span>,ifile,nfiles)</span>
            <span class="keyword">if</span> DEBUGON
                lamdumpread2(currentdumpfile,action)
            <span class="keyword">else</span>
                try
                    lamdumpread2(currentdumpfile,action)
                catch ME
                    warning(ME.message)
                    dispf(<span class="string">'ERROR to read the file '</span><span class="string">'<span class="comment">%s'</span><span class="string">' in '</span><span class="string">'%s'</span><span class="string">''</span>,dumpfiles(ifile).file,dumpfiles(ifile).path)</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            dispf(<span class="string">'<span class="comment">%d:%d %s'</span>,ifile,nfiles,currentdumpfile)</span>
            fileinfo(makeprefetch(currentdumpfile))
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span>
<span class="keyword">end</span>

<span class="comment">% display help</span>
<span class="keyword">if</span> strcmp(filename,<span class="string">''</span>), error(<span class="string">'syntax: X=lamdumpread(dumpfilename,[collect],[molecules],[itimes],[iatoms])'</span>), <span class="keyword">end</span> 

<span class="comment">% Manage forcesplit and usesplit</span>
forcesplit = strcmpi(action,<span class="string">'robotsplit'</span>);
forceprefetch = strcmpi(action,<span class="string">'robotprefetch'</span>);
usesplit = strcmpi(action,<span class="string">'usesplit'</span>);


<span class="comment">% prefetch (added 2023-03-23)</span>
prefetchfile = makeprefetch(filename);
hasprefetchfile = exist(prefetchfile,<span class="string">'file'</span>);
hasprefetchfolder = exist(makesplitdir(filename),<span class="string">'dir'</span>);

<span class="keyword">if</span> (hasprefetchfile && ~forcesplit && ~usesplit) || (hasprefetchfile && ~hasprefetchfolder) <span class="comment">% fixed on 2023-08-21 (hasprefetchfile added)</span>
    dispf(<span class="string">'Load prefetch file (instead of '</span><span class="string">'<span class="comment">%s'</span><span class="string">')...'</span>,filename), fileinfo(prefetchfile), t0=clock;</span>
    load(prefetchfile)
    dispf(<span class="string">'...loaded in <span class="comment">%0.3g s'</span>,etime(clock,t0)) %#ok<*CLOCK,*DETIM> </span>
    <span class="keyword">return</span>
<span class="keyword">elseif</span> (hasprefetchfolder && ~forcesplit && ~forceprefetch) || usesplit <span class="comment">% prefetch dir (added 2023-03-11)</span>
    <span class="keyword">if</span> isempty(itimes)
        tmplist = explore([SPLITPREFIX <span class="string">'*.mat'</span>],makesplitdir(filename),0,<span class="string">'abbreviate'</span>);
        itimes = str2double(strrep({tmplist.name},SPLITPREFIX,<span class="string">''</span>))<span class="string">';
        ncol = 10;
        nrow = ceil(length(itimes) / ncol);
        itimes_cell = cell(nrow, ncol);
        <span class="keyword">for</span> i = 1:length(itimes)
            [row, col] = ind2sub([nrow, ncol], i);
            itimes_cell{row, col} = sprintf('</span><span class="comment">%9d<span class="string">', itimes(i));</span>
        <span class="keyword">end</span>
        dispf('</span>The prefetch is split in several files.\n<span class="comment">%d TIMESTEPS are availble:<span class="string">',length(itimes))</span>
        <span class="keyword">for</span> col = 1:ncol, fprintf('</span>  Column <span class="comment">%02d\t<span class="string">', col); <span class="keyword">end</span>, fprintf('</span>\n<span class="string">');</span>
        <span class="keyword">for</span> row = 1:nrow, <span class="keyword">for</span> col = 1:ncol, fprintf('</span><span class="comment">%s\t<span class="string">', itimes_cell{row, col}); <span class="keyword">end</span>, fprintf('</span>\n<span class="string">'); <span class="keyword">end</span></span>
        dispf('</span>Choose the time step you are interested in.\nOnly the first one is returned <span class="keyword">for</span> now.<span class="string">')
        itimes_all = itimes;
        itimes = itimes(1);
    <span class="keyword">else</span>
        itimes_all = [];
    <span class="keyword">end</span>
    t0 = clock;
    <span class="keyword">for</span> it = 1:numel(itimes)
        tmpfile = makesplit(filename,itimes(it));
        <span class="keyword">if</span> ~exist(tmpfile,'</span>file<span class="string">'), error('</span>the time step <span class="comment">%d does not exist (%s)<span class="string">',itimes(it),filename); <span class="keyword">end</span></span>
        dispf('</span>Use the prefetch (split: TIMESTEP <span class="comment">%d) folder (instead of <span class="string">''</span>%s<span class="string">''</span>)...<span class="string">',itimes(it), filename), fileinfo(tmpfile)</span>
        tmp = load(tmpfile);
        <span class="keyword">if</span> ~isfield(tmp,'</span>X<span class="string">'), error('</span>corrupted frame<span class="string">'), <span class="keyword">end</span>
        <span class="keyword">if</span> isfield(tmp.X,'</span>description<span class="string">')
            ttmp = tmp.X.TIMESTEP*ones(tmp.X.NUMBER,1,class(tmp.X.ATOMS));
            vtmp = unique(strsplit(tmp.X.description.ATOMS,'</span> <span class="string">'),'</span>stable<span class="string">');
            <span class="keyword">if</span> isempty(iatoms)
                tmp.X.ATOMS = array2table([ttmp tmp.X.ATOMS],'</span>VariableNames<span class="string">',[{'</span>TIMESTEP<span class="string">'} vtmp]);
            <span class="keyword">else</span>
                [~,~,jatoms] = intersect(iatoms,tmp.X.ATOMS(:,ismember(vtmp,'</span>id<span class="string">')),'</span>stable<span class="string">');
                 tmp.X.ATOMS = array2table([ttmp(jatoms) tmp.X.ATOMS(jatoms,:)],'</span>VariableNames<span class="string">',[{'</span>TIMESTEP<span class="string">'} vtmp]);
            <span class="keyword">end</span>
            oktable = true;
        <span class="keyword">else</span>
            oktable = false;
        <span class="keyword">end</span>
        <span class="keyword">if</span> it==1
            X = tmp.X;
        <span class="keyword">else</span>
            <span class="keyword">if</span> oktable
                X.TIMESTEP(<span class="keyword">end</span>+1) = tmp.X.TIMESTEP;
                <span class="keyword">if</span> isfield(tmp.X,'</span>TIME<span class="string">'), X.TIME(<span class="keyword">end</span>+1) = tmp.X.TIME; <span class="keyword">end</span>
                X.ATOMS = [X.ATOMS;tmp.X.ATOMS];
            <span class="keyword">else</span>
                X(<span class="keyword">end</span>+1) = tmp.X; <span class="comment">%#ok<*AGROW></span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    dispf('</span>...loaded in <span class="comment">%0.3g s<span class="string">',etime(clock,t0))</span>
    X.TIMESTEPS = itimes_all'</span>;
    X.TIMESTEPfirst = min(itimes_all);
    X.TIMESTEPlast = max(itimes_all);
    <span class="keyword">return</span>    
<span class="keyword">end</span>

<span class="comment">% <span class="keyword">return</span> an error <span class="keyword">if</span> the original file does not exist</span>
<span class="keyword">if</span> ~exist(filename,<span class="string">'file'</span>), error(<span class="string">'the file '</span><span class="string">'<span class="comment">%s'</span><span class="string">' does not exist'</span>,filename), <span class="keyword">end</span></span>

<span class="comment">% Check extensions: .bin (binary mode) and .gz (text mode but gzipped)</span>
[~,~,de] = fileparts(filename);
<span class="keyword">if</span> strcmpi(de,<span class="string">'.bin'</span>), fprintf(<span class="string">'\n>> Switch to binary <<\n\n'</span>), X = dumpbinary(filename,1,molecules); <span class="keyword">return</span>, <span class="keyword">end</span>
isgz = strcmpi(de,<span class="string">'.gz'</span>); <span class="keyword">if</span> isgz, fprintf(<span class="string">'\n>> Switch to GZIPPED text mode <<\n\n'</span>), <span class="keyword">end</span>
<span class="comment">%d = dir(filename);</span>
counton   = strcmpi(action,<span class="string">'count'</span>); <span class="comment">% || (d.bytes>prefetchthreshold);</span>
nmol      = length(molecules);

<span class="comment">% detect large file</span>
<span class="keyword">if</span> ~isgz
    nfo = dir(filename);
    islargefile = (nfo.bytes>maxfilesize) || forcesplit;
<span class="keyword">else</span>
    islargefile = false;
<span class="keyword">end</span>
<span class="keyword">if</span> islargefile && ~exist(makesplitdir(filename),<span class="string">'dir'</span>), mkdir(makesplitdir(filename)); <span class="keyword">end</span>
ipartlargefile = 0;


<span class="comment">% PREALLOCATE when collect is active</span>
<span class="keyword">if</span> collecton
    fprintf(<span class="string">'Count timesteps <span class="keyword">for</span> all fields...\nPreallocation to preserve memory usage...\nThe file will be read twice.\n'</span>)
    fprintf(<span class="string">'DATA format: '</span><span class="string">'<span class="comment">%s'</span><span class="string">' [%s]\n'</span>,datatype,numpattern)</span>
    clock0 = clock;
    <span class="keyword">if</span> isempty(itimes) || isempty(iatoms)
        X = lamdumpread(filename,<span class="string">'count'</span>,molecules,itimes,iatoms); <span class="comment">% whole procedure</span>
    <span class="keyword">else</span> <span class="comment">% the structure is assumed to be known (bad prediction will generate an error)</span>
        fprintf(<span class="string">'Assume a general DUMP format (faster)\nBad parameters <span class="keyword">for</span> iatoms and itimes will result in an error.\n\n'</span>)
        ntimes = length(itimes); natoms = length(iatoms);
        X = struct(<span class="string">'TIMESTEP'</span>,[1 1 ntimes],...
            <span class="string">'NUMBEROFATOMS'</span>,[1 1 ntimes],...
            <span class="string">'BOXBOUNDS'</span>,[3 2 ntimes],...
            <span class="string">'ATOMS'</span>,[natoms 5 11]);
    <span class="keyword">end</span>
    <span class="keyword">if</span> isempty(itimes), fprintf(<span class="string">'\nFOUND records: [size]\n\n'</span>), <span class="keyword">else</span> fprintf(<span class="string">'\nFOUND records: [size]\n between timesteps [<span class="comment">%d %d]\n'</span>,min(itimes),max(itimes)), <span class="keyword">end</span></span>
    disp(X)
    restart=true; iserrorgenerated = false;
    key=fieldnames(X)<span class="string">'; siz = X.(key{1});
    <span class="keyword">if</span> isempty(itimes), ntimes = siz(3); <span class="keyword">else</span> ntimes=length(itimes); <span class="keyword">end</span>
    <span class="keyword">if</span> isempty(iatoms), natoms = siz(1); <span class="keyword">else</span> natoms = length(iatoms); <span class="keyword">end</span>
    <span class="keyword">while</span> restart
        try
            <span class="keyword">for</span> key=fieldnames(X)'</span>
                siz = X.(key{1});
                <span class="keyword">if</span> isempty(itimes), ntimes = siz(3); <span class="keyword">else</span> ntimes=length(itimes); <span class="keyword">end</span>
                <span class="keyword">if</span> nmol && strcmp(key{1},<span class="string">'ATOMS'</span>) <span class="comment">% molecules assembling</span>
                    <span class="keyword">if</span> isempty(iatoms), listofmol = 1:nmol; <span class="keyword">else</span> listofmol = iatoms; <span class="keyword">end</span>
                    <span class="keyword">if</span> (max(listofmol)>nmol) || (min(listofmol)<1), iserrorgenerated=true; error(<span class="string">'invalid molecules index'</span>), <span class="keyword">end</span>
                    X.MOLECULES = cell(length(listofmol),1);
                    <span class="keyword">for</span> imol=listofmol, X.MOLECULES{imol} = zeros(length(molecules{imol}),3,ntimes,datatype); <span class="keyword">end</span>
                <span class="keyword">else</span>
                    <span class="keyword">if</span> strcmp(key{1},<span class="string">'ATOMS'</span>)
                        <span class="keyword">if</span> isempty(iatoms), natoms = siz(1); <span class="keyword">else</span> natoms = length(iatoms); <span class="keyword">end</span>
                        X.(key{1}) = zeros(squeezedims([natoms siz(2) ntimes]),datatype);
                    <span class="keyword">else</span> <span class="comment">% other fields</span>
                        X.(key{1}) = zeros(squeezedims([siz(1:<span class="keyword">end</span>-1) ntimes]),datatype);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            restart = false;
        catch ME
            <span class="keyword">if</span> iserrorgenerated, rethrow(ME), <span class="keyword">end</span>
            fprintf(<span class="string">'Insifficient memory <span class="keyword">for</span> <span class="comment">%d timesteps ranged between [%d %d] and %d atoms ranged between [%d %d]\n'</span>,ntimes,min(itimes),max(itimes),natoms,min(iatoms),max(iatoms))</span>
            disp(<span class="string">'a 1 <span class="keyword">for</span> 2 decimation rule wil be tented'</span>)
            <span class="keyword">if</span> length(itimes)==1 || isempty(itimes), rethrow(ME), <span class="keyword">end</span>
            itimes = unique(round(linspace(min(itimes),max(itimes),round(ntimes/2)))); <span class="comment">% decimation</span>
        <span class="keyword">end</span> <span class="comment">% try/catch</span>
    <span class="keyword">end</span> <span class="comment">% wend</span>
    fprintf(<span class="string">''</span><span class="string">'<span class="comment">%s'</span><span class="string">' preallocated in %0.4g s\n\n'</span>,filename,etime(clock,clock0))</span>
    counton = false;
<span class="keyword">else</span> <span class="comment">% no preallocation (efficient but less usefull <span class="keyword">for</span> interpretation)</span>
    X = [];
<span class="keyword">end</span>

<span class="comment">% fast scan file based on BLOCKS and PATTERNS (low memory usage)</span>
disp(<span class="string">'LAMMPS DUMP file...'</span>), fileinfo(filename)
start = clock;
<span class="keyword">if</span> isgz, fid = gzipr(filename); <span class="keyword">else</span> fid = fopen(filename,<span class="string">'r'</span>,<span class="string">'n'</span>,<span class="string">'US-ASCII'</span>); <span class="keyword">end</span>
foundrecord = true;
eof = false;
[RAWKEYLIST,KEYLIST,DESRCLIST] = deal({}); KEYOCC  = []; <span class="comment">%raw counters (replace pos.(<span class="string">'key'</span>) when it is not defined)</span>
CURRENTOCC = -Inf; <span class="comment">% number of occurence</span>
<span class="keyword">if</span> isempty(itimes), itimesmax=Inf; <span class="keyword">else</span> itimesmax = max(itimes); <span class="keyword">end</span>
screen=<span class="string">''</span>; isfirstframe = true; nodisplay = false; tsplit = clock;
<span class="keyword">while</span> foundrecord && ~eof
    <span class="comment">% look <span class="keyword">for</span> the keyword ITEM (stop when it does not match, i.e. numerical data</span>
    <span class="keyword">if</span> isgz, [key,eof,row] = textscanp(fid,variablepattern,<span class="string">'delimiter'</span>,<span class="string">'\n'</span>);
    <span class="keyword">else</span> key = textscan(fid,variablepattern,<span class="string">'delimiter'</span>,<span class="string">'\n'</span>); <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(key) && ~isempty(key{1})
        <span class="keyword">if</span> isfirstframe && any(strcmp(key{1},{<span class="string">'TIME'</span>,<span class="string">'TIMESTEP'</span>})), keyforfirstframe = key{1}; isfirstframe = false; <span class="keyword">end</span>
        <span class="keyword">if</span> islargefile && strcmp(key{1},keyforfirstframe) && ~isempty(X) && isfield(X,keyforfirstframe)
            X.description = cell2struct(DESRCLIST<span class="string">',KEYLIST'</span>);
            X.nfo = nfo; ipartlargefile = ipartlargefile +1;
            save(makesplit(filename,X.TIMESTEP),<span class="string">'X'</span>)
            [~,nfotxt] = fileinfo(makesplit(filename,X.TIMESTEP),<span class="string">''</span>,false);
            screen = dispb(screen,<span class="string">'[<span class="comment">%d:%d] split in %0.3g s ==> %s'</span>,ipartlargefile,X.TIMESTEP,etime(clock,tsplit),nfotxt);</span>
            X = []; nodisplay = true; tsplit = clock;
        <span class="keyword">end</span>
        <span class="comment">%key{1}{1} = regexprep(key{1}{1},excludedexpr,<span class="string">''</span>); % remove undesirable set of characters (<span class="keyword">for</span> new version of LAMMPS may 2009)</span>
        <span class="comment">% counters based on raw names</span>
        <span class="keyword">if</span> ~ismember(key{1}{1},RAWKEYLIST)
            RAWKEYLIST{<span class="keyword">end</span>+1} = key{1}{1}; <span class="comment">%#ok<AGROW></span>
            KEYLIST{<span class="keyword">end</span>+1} = regexprep(key{1}{1},{<span class="string">'[a-z_]'</span>,<span class="string">'\d'</span>,<span class="string">'\s*$'</span>,<span class="string">'\s+'</span>,<span class="string">'_[A-Z]?\[\d+\]'</span>,<span class="string">'_'</span>,<span class="string">'[\[\]]'</span>},{<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">'_'</span>,<span class="string">''</span>,<span class="string">' '</span>,<span class="string">''</span>}); <span class="comment">%#ok<AGROW> % only A-Z characters are kept</span>
            DESRCLIST{<span class="keyword">end</span>+1} = regexprep(key{1}{1},{<span class="string">'^[A-Z\s]*([a-z])'</span>,<span class="string">'^\s*'</span>,<span class="string">'\s*$'</span>,KEYLIST{<span class="keyword">end</span>}},{<span class="string">'$1'</span>,<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>}); <span class="comment">%#ok<AGROW> % <span class="string">'[A-Z]'</span>, the remaining characters are kept <span class="keyword">for</span> description</span>
            KEYLIST{<span class="keyword">end</span>} = regexprep(KEYLIST{<span class="keyword">end</span>},{<span class="string">'\s+'</span>,<span class="string">'_[A-Z]*'</span>},{<span class="string">'_'</span>,<span class="string">''</span>}); <span class="comment">% remove residual _XX names (e.g., _VM)</span>
            KEYOCC(<span class="keyword">end</span>+1)=0; <span class="comment">%#ok<AGROW></span>
        <span class="keyword">end</span> <span class="comment">% create the counter <span class="keyword">if</span> it does not exist</span>
        ikey = find(ismember(RAWKEYLIST,key{1}{1})); <span class="comment">%key index</span>
        KEYOCC(ikey)=KEYOCC(ikey)+1; <span class="comment">%#ok<AGROW> % increment the counter (not order dependent)</span>
        <span class="comment">% keyname standardization</span>
        <span class="comment">%key = strrep(key{1}{1},<span class="string">' '</span>,<span class="string">'_'</span>);        % remove all spaces</span>
        key = KEYLIST{ikey};
        <span class="keyword">if</span> ~isgz                                <span class="comment">% read the next line</span>
            row = <span class="string">''</span>;
            <span class="keyword">while</span> isempty(row) && ~feof(fid)    <span class="comment">% <span class="keyword">while</span> the current line is not valid</span>
                currentpos = ftell(fid);        <span class="comment">% current position in the file</span>
                row = fgetl(fid);               <span class="comment">% read a single line/row to identify the pattern</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        n = length(find(strtrim(row)==numsep)); <span class="comment">% number of data per row</span>
        <span class="keyword">if</span> ~isempty(row)                        <span class="comment">% records were found</span>
            <span class="comment">% Read values</span>
            <span class="keyword">if</span> ~counton && ~nodisplay, display(1.001,<span class="string">'[<span class="comment">%d] %s reading...'</span>,KEYOCC(ikey),KEYLIST{ikey}); <span class="keyword">end</span></span>
            clock1 = clock;
            <span class="keyword">if</span> isgz
                [val,eof] = textscanp(fid,[repmat([numpattern numsep],1,n) numpattern],<span class="string">'delimiter'</span>,<span class="string">'\n'</span>,<span class="string">'CollectOutput'</span>, 1);
            <span class="keyword">else</span>
                fseek(fid,currentpos,<span class="string">'bof'</span>);    <span class="comment">% go back to the last position</span>
                val = textscan(fid,[repmat([numpattern numsep],1,n) numpattern],<span class="string">'delimiter'</span>,<span class="string">'\n'</span>,<span class="string">'CollectOutput'</span>, 1); <span class="comment">% read the values</span>
            <span class="keyword">end</span>
            <span class="comment">% Timestep counter</span>
            <span class="keyword">if</span> CURRENTOCC<KEYOCC(ikey), CURRENTOCC=KEYOCC(ikey); <span class="keyword">if</span> counton, screen=dispb(screen,<span class="string">'Preallocate TIMESTEP index: <span class="comment">%d '</span>,CURRENTOCC); <span class="keyword">end</span>, <span class="keyword">end</span></span>
            <span class="keyword">if</span> CURRENTOCC>itimesmax, eof = true; <span class="keyword">end</span> <span class="comment">% force <span class="keyword">end</span> of file</span>
            <span class="comment">% Check validity of the current time step, sort ATOMS values, verbosity</span>
            <span class="comment">% Note that a robust/clean counter is used when a PREALLOCATION is performed, <span class="keyword">if</span> not a raw counter (field order dependent) is used</span>
            <span class="keyword">if</span> ~counton
                <span class="keyword">if</span> isempty(itimes), validtime = true; storeposition = KEYOCC(ikey);
                <span class="keyword">else</span>
                    validtime = ismember(KEYOCC(ikey),itimes);
                    <span class="keyword">if</span> validtime, storeposition = find(itimes==KEYOCC(ikey)); storeposition=storeposition(1); <span class="keyword">end</span>
                <span class="keyword">end</span>
                <span class="keyword">if</span> ~nodisplay, <span class="keyword">if</span> numel(val{1})<2, display(1.002,<span class="string">'= <span class="comment">%0.6g'</span>,val{1}), <span class="keyword">else</span>, display(1.002,<span class="string">'= %s%s array'</span>,sprintf(<span class="string">'%dx'</span>,size(val{1})),char(8)),<span class="keyword">end</span>, <span class="keyword">end</span></span>
                <span class="keyword">if</span> strcmp(key,<span class="string">'ATOMS'</span>) && validtime, <span class="keyword">if</span> ~nodisplay, display(1.003,<span class="string">'>>sorting'</span>), <span class="keyword">end</span>, [~,ia] = sort(val{1}(:,1)); val{1} = val{1}(ia,:); <span class="keyword">end</span>
                <span class="keyword">if</span> ~nodisplay, display(1.004,<span class="string">'... <span class="keyword">end</span> in <span class="comment">%0.3g s\n'</span>,etime(clock,clock1)); <span class="keyword">end</span></span>
            <span class="keyword">end</span>
            <span class="comment">% Assign values</span>
            <span class="keyword">if</span> counton                          <span class="comment">% count values (<span class="keyword">if</span> requested)</span>
                <span class="keyword">if</span> isfield(X,key), X.(key)(<span class="keyword">end</span>)=X.(key)(<span class="keyword">end</span>)+1; <span class="keyword">else</span> X.(key)=[size(val{1}) 1]; <span class="keyword">end</span>
            <span class="keyword">elseif</span> collecton <span class="comment">% collect</span>
                <span class="keyword">if</span> strcmp(key,<span class="string">'ATOMS'</span>) && nmol <span class="comment">% replace ATOMS by MOLECULES</span>
                    key = <span class="string">'MOLECULES'</span>;
                    <span class="keyword">if</span> validtime
                        <span class="keyword">if</span> isempty(iatoms), listofmol = 1:nmol; <span class="keyword">else</span>, listofmol = iatoms; <span class="keyword">end</span>
                        <span class="keyword">for</span> imol = listofmol, X.(key){imol}(:,:,storeposition)=val{1}(molecules{imol},3:5); <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">elseif</span> validtime
                    <span class="keyword">if</span> numberofel(X.(key),val{1})==numel(val{1})
                        <span class="keyword">switch</span> numberofdims(val{1})
                            <span class="keyword">case</span> 0, X.(key)(storeposition) = val{1};
                            <span class="keyword">case</span> 1, X.(key)(:,storeposition)  = val{1}(:);
                            <span class="keyword">case</span> 2, X.(key)(:,:,storeposition)= val{1};
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">elseif</span> validtime
                <span class="keyword">if</span> ~isfield(X,key), X.(key) = val{1}; <span class="comment">% create a new keyword</span>
                <span class="keyword">elseif</span> ~iscell(X.(key))     <span class="comment">% convert to a cell array to store results from several records</span>
                    <span class="keyword">if</span> numel(val{1})==1, X.(key)(<span class="keyword">end</span>+1) = val{1};
                    <span class="keyword">else</span>                 X.(key) = {X.(key) val{1}}; <span class="comment">%#ok<*SEPEX></span>
                    <span class="keyword">end</span>
                <span class="keyword">else</span>                                  <span class="comment">% append records</span>
                    <span class="keyword">if</span> numel(val{1})==1, X.(key)(<span class="keyword">end</span>+1)=val{1};
                    <span class="keyword">else</span>                 X.(key){<span class="keyword">end</span>+1}=val{1};
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span> <span class="comment">% count on</span>
        <span class="keyword">else</span>                                <span class="comment">% likely corrupted file</span>
            foundrecord = false;
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        foundrecord = false;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> isgz, try textscanp(fid); catch ME, fprintf(<span class="string">'*-*- ERROR -*-*'</span>), rethrow(ME), <span class="keyword">end</span>, gzipr(fid); <span class="keyword">else</span> fclose(fid); <span class="keyword">end</span>
fprintf(<span class="string">'... <span class="keyword">end</span> in <span class="comment">%0.3g s\n'</span>,etime(clock,start))</span>
<span class="keyword">if</span> isempty(X), disp(<span class="string">'It seems not to be a valid file'</span>), <span class="keyword">return</span>, <span class="keyword">end</span>

<span class="comment">% last frame <span class="keyword">for</span> large file</span>
<span class="keyword">if</span> islargefile && ~isempty(X)
    X.description = cell2struct(DESRCLIST<span class="string">',KEYLIST'</span>);
    X.nfo = nfo;
    save(makesplit(filename,X.TIMESTEP),<span class="string">'X'</span>)
    nfotxt = fileinfo(makesplit(filename,X.TIMESTEP),<span class="string">''</span>,false);
    dispb(screen,<span class="string">'[last=<span class="comment">%d] %d split files completed in %0.3g s\n in\t%s\n'</span>,X.TIMESTEP,ipartlargefile+1,etime(clock,start),nfotxt.path);</span>
    <span class="keyword">return</span>
<span class="keyword">end</span>

<span class="comment">%% rearrangement of outputs to match description, when possible</span>
<span class="comment">% added INRAE\Olivier Vitrac, 2021-02-15 (RC)</span>
X.description=cell2struct(DESRCLIST<span class="string">',KEYLIST'</span>);

<span class="keyword">if</span> length(X.TIMESTEP)>1 <span class="comment">% more than one frame</span>
    iseries = find(~cellfun(@isempty,DESRCLIST));
    <span class="keyword">if</span> isempty(iseries), <span class="keyword">return</span>; <span class="keyword">end</span>
    nseries = length(iseries);
    
    <span class="keyword">for</span> j=1:nseries        
        
        tmp = unique(strsplit(DESRCLIST{iseries(j)},<span class="string">' '</span>),<span class="string">'stable'</span>);
        siz = size(X.(KEYLIST{iseries(j)}){1});
        <span class="keyword">if</span> (siz(2)==length(tmp)) && strcmpi(KEYLIST{iseries(j)},<span class="string">'ATOMS'</span>) <span class="comment">% === ATOMS ===</span>
            nt = length(X.(KEYLIST{iseries(j)}));
            na = zeros(nt,1);
            <span class="keyword">for</span> it=1:nt, na(it) = size(X.(KEYLIST{iseries(j)}){it},1); <span class="keyword">end</span>
            grps = unique(na,<span class="string">'stable'</span>); ngrps = length(grps);
            <span class="keyword">for</span> igrp = 1:ngrps
                jgrp = find(na==grps(igrp)); njgrp = length(jgrp);
                tmp2 = reshape(permute(cat(length(siz)+1,X.(KEYLIST{iseries(j)}){jgrp}),[1 3 2]),[grps(igrp)*njgrp siz(2)]);
                t = ones(grps(igrp),1,<span class="string">'single'</span>)*X.TIMESTEP(jgrp); <span class="comment">% time steps</span>
                tmp2 = [t(:) tmp2]; <span class="comment">%#ok<AGROW></span>
                <span class="keyword">if</span> ngrps==1, suffix=<span class="string">''</span>; <span class="keyword">else</span>, suffix=sprintf(<span class="string">'_grp<span class="comment">%02d'</span>,igrp); <span class="keyword">end</span></span>
                X.([KEYLIST{iseries(j)} suffix]) = array2table(tmp2,<span class="string">'VariableNames'</span>,[{<span class="string">'TIMESTEP'</span>} tmp]);
            <span class="keyword">end</span>
            <span class="keyword">if</span> ngrps>1, X = rmfield(X,<span class="string">'ATOMS'</span>); <span class="keyword">end</span>
        <span class="keyword">elseif</span> prod(siz)>max(siz) && strcmpi(KEYLIST{iseries(j)},<span class="string">'BOX'</span>) <span class="comment">% array %% === BOX_BOUNDS ===</span>
            try
                X.(KEYLIST{iseries(j)}) = cat(length(siz)+1,X.(KEYLIST{iseries(j)}){:});
                siz = size(X.(KEYLIST{iseries(j)}));
                <span class="keyword">if</span> ndims(X.(KEYLIST{iseries(j)}))==3
                    X.(KEYLIST{iseries(j)}) = reshape(permute(X.(KEYLIST{iseries(j)}),[3 2 1]),[siz(3) siz(1)*siz(2)]);
                <span class="keyword">end</span>
            catch
                fprintf(<span class="string">'\nWARNING: unable to collect all data <span class="keyword">for</span> '</span><span class="string">'<span class="comment">%s'</span><span class="string">'\n\t The likely cause is incompatible size.\n'</span>,KEYLIST{iseries(j)});</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        
        
    <span class="keyword">end</span> <span class="comment">% next j (series)</span>
    
<span class="keyword">elseif</span> isfield(X,<span class="string">'ATOMS'</span>)
    
    
<span class="keyword">end</span> <span class="comment">% <span class="keyword">if</span> nframes > 1</span>

<span class="comment">% save prefetch - added 2023-03-23</span>
dispf(<span class="string">'save prefetch file (<span class="keyword">for</span> '</span><span class="string">'<span class="comment">%s'</span><span class="string">')...'</span>,filename), t0=clock;</span>
save(prefetchfile,<span class="string">'X'</span>,<span class="string">'filename'</span>)
<span class="keyword">if</span> ~exist(prefetchfile,<span class="string">'file'</span>)
    switch73 = true;
<span class="keyword">else</span>
    details = dir(prefetchfile);
    switch73 = details.bytes<1000;
<span class="keyword">end</span>
<span class="keyword">if</span> switch73
    dispf(<span class="string">'--> too large file <span class="keyword">for</span> default save format, <span class="keyword">switch</span> to v7.3 (HDF5) format'</span>)
    save(prefetchfile,<span class="string">'X'</span>,<span class="string">'filename'</span>,<span class="string">'-v7.3'</span>);
<span class="keyword">end</span>
fileinfo(prefetchfile)
dispf(<span class="string">'...saved in <span class="comment">%0.3g s'</span>,etime(clock,t0))</span>




<span class="keyword">end</span> <span class="comment">% ENDFUNCTION</span>

<span class="comment">%% =====================================================</span>
<span class="comment">% PRIVATE FUNCTIONS</span>
<span class="comment">% ====================================================</span>

<span class="comment">% Display <span class="keyword">function</span> with id manager</span>
<span class="keyword">function</span> display(id,varargin)
    <span class="comment">% manage display at prescribed intervals with an id manager</span>
    <span class="comment">% id = 2.001 means event=2, message instance = 1;</span>
    persistent TDISP
    <span class="keyword">if</span> isempty(TDISP), TDISP = struct(<span class="string">'t'</span>,clock,<span class="string">'updateinterval'</span>,0.5,<span class="string">'idevent'</span>,NaN,<span class="string">'idinstance'</span>,NaN); <span class="keyword">end</span>
    t = clock; dt = etime(t,TDISP.t);
    idevent = floor(id); idinstance = round(1000*(id-idevent));
    <span class="keyword">if</span> TDISP.idevent==idevent                <span class="comment">% same event </span>
        forced = (idinstance>TDISP.idinstance);<span class="comment">% the instances are assumed linked <span class="keyword">if</span> incremented</span>
    <span class="keyword">else</span>
        forced = false;
    <span class="keyword">end</span>
    <span class="keyword">if</span> ((dt>TDISP.updateinterval) && (idinstance==1)) || forced
        TDISP.t = t;
        TDISP.idevent = idevent;
        TDISP.idinstance = idinstance;
        fprintf(varargin{:});
    <span class="keyword">end</span>
<span class="keyword">end</span> <span class="comment">% ENDFUNCTION</span>

<span class="comment">% BASIC FUNCTIONS to work multidimensional arrays (replace SQUEEZE, NUMEL, NDIMS)</span>
<span class="keyword">function</span> d=squeezedims(d1)
<span class="comment">% move singleton dimension</span>
d = d1(d1>1);
<span class="keyword">if</span> (length(d)==1), <span class="keyword">if</span> d<20, d = [1 d]; <span class="keyword">else</span> d = [d 1]; <span class="keyword">end</span>, <span class="keyword">end</span> <span class="comment">%% [1 d] improve the readability of small vectors</span>
<span class="keyword">end</span> <span class="comment">% ENDFUNCTION</span>

<span class="keyword">function</span> ne=numberofel(x,ref)
<span class="comment">% <span class="keyword">return</span> the expected number of elements</span>
dref = numberofdims(ref);
ne = size(x);
ne = prod(ne(1:min(length(ne),dref)));
<span class="keyword">end</span> <span class="comment">% ENDFUNCTION</span>

<span class="keyword">function</span> d=numberofdims(x)
<span class="comment">% returns the expected number of dimension of x (0=scalar, 1=vector, 2=matrix)</span>
d = length(find(size(x)>1));
<span class="keyword">end</span> <span class="comment">% ENDFUNCTION</span>

<span class="comment">%% CODE FOR BINARY DUMP ===============================</span>
<span class="comment">% TO DO LIST: to implement: itimes and imolecules</span>
<span class="keyword">function</span> X=dumpbinary(filename,colsort,molecules)
<span class="comment">%READ BINARY DUMP FILES based on tools/binary2txt.cpp (Matlab comment is given as comment)</span>
<span class="comment">% Field names are a priori set since this information is not available in the binary files</span>
<span class="comment">%<span class="string">'collect'</span> is always applied in this optimized version</span>
<span class="comment">% Definitions</span>
colsort_default = 1;
<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<2, colsort = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, molecules = {}; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(colsort), colsort=colsort_default; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(molecules), molecules = {}; <span class="keyword">end</span>
nmol = length(molecules);
<span class="comment">% 2 steps reading</span>
clock0 = clock;
fp = fopen(filename,<span class="string">'r'</span>); <span class="comment">% use fopen(filename,<span class="string">'r'</span>,<span class="string">'b'</span>) <span class="keyword">if</span> any problem in future Matlab versions</span>
<span class="keyword">for</span> do={<span class="string">'prealloc'</span> <span class="string">'load'</span>}
    <span class="keyword">switch</span> do{1}
        <span class="keyword">case</span> <span class="string">'prealloc'</span>
            disp(<span class="string">'BINARY Memory preallocation...'</span>)
            X = struct(<span class="string">'TIMESTEP'</span>,[],<span class="string">'NUMBEROFATOMS'</span>,[],<span class="string">'BOXBOUNDS'</span>,[],<span class="string">'ATOMS'</span>,[]);
            [ncol,nproc,nbuff] = deal([]);
        <span class="keyword">case</span> <span class="string">'load'</span>
            disp(<span class="string">'BINARY reading...'</span>);
            X.BOXBOUNDS = zeros(3,2,numel(X.TIMESTEP)); <span class="comment">% 3 dim array</span>
            <span class="keyword">if</span> nmol
                X.MOLECULES = cell(nmol,1);
                <span class="keyword">for</span> imol=1:nmol, X.MOLECULES{imol}=zeros(length(molecules{imol}),3,numel(X.TIMESTEP)); <span class="keyword">end</span>
                X.ATOMS = zeros(max(sum(nbuff,2))/min(ncol),max(ncol)); <span class="comment">% only used as a buffer</span>
            <span class="keyword">else</span>
                X.ATOMS  = zeros(max(sum(nbuff,2))/min(ncol),max(ncol),numel(X.TIMESTEP)); <span class="comment">% 3 dim array</span>
            <span class="keyword">end</span>
    <span class="keyword">end</span>
    [u,v]=deal(0); <span class="comment">% u=low cost index, v=expensive index (to be used only with LOAD)</span>
    <span class="keyword">while</span> ~feof(fp)
        <span class="keyword">switch</span> do{1}, <span class="keyword">case</span> <span class="string">'prealloc'</span>, v=1; <span class="keyword">case</span> <span class="string">'load'</span>, v=v+1; <span class="keyword">end</span>
        u = u+1;
        tmp = fread(fp,1,<span class="string">'int'</span>);
        <span class="keyword">if</span> ~isempty(tmp) || ~feof(fp)
            clock1   = clock;
            X.TIMESTEP(u)      = tmp;
            X.NUMBEROFATOMS(u) = fread(fp,1,<span class="string">'int'</span>);
            X.BOXBOUNDS(:,:,v) = fread(fp,[2 3],<span class="string">'double'</span>)<span class="string">';
            ncol(u)  = fread(fp,1,'</span>int<span class="string">');
            nproc(u) = fread(fp,1,'</span>int<span class="string">');
            k = 1;
            iatomtime = min(v,size(X.ATOMS,3));
            <span class="keyword">for</span>  i=1:nproc(u)
                nbuff(u,i) = fread(fp,1,'</span>int<span class="string">');
                <span class="keyword">switch</span> do{1}
                    <span class="keyword">case</span> '</span>prealloc<span class="string">', fseek(fp,8*nbuff(<span class="keyword">end</span>,i),'</span>cof<span class="string">');
                    <span class="keyword">case</span> '</span>load<span class="string">'
                        <span class="keyword">if</span> i==1; display(10.001,'</span>time step = <span class="comment">%d\n<span class="string">',tmp), <span class="keyword">end</span></span>
                        nlig = nbuff(u,i)/ncol(u);
                        X.ATOMS(k:(k+nlig-1),:,iatomtime)= fread(fp,[ncol(u) nlig],'</span>double<span class="string">')'</span>;
                        k = k + nlig;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">switch</span> do{1}
                <span class="keyword">case</span> <span class="string">'load'</span>
                    display(10.002,<span class="string">'<span class="comment">%s >>sorting'</span>)</span>
                    [~,is] = sort(X.ATOMS(:,colsort,iatomtime));
                    X.ATOMS(:,:,iatomtime) = X.ATOMS(is,:,iatomtime);
                    <span class="keyword">if</span> nmol, <span class="keyword">for</span> imol=1:nmol, X.MOLECULES{imol}(:,:,v)=X.ATOMS(molecules{imol},3:5); <span class="keyword">end</span>, <span class="keyword">end</span>
                    display(10.003,<span class="string">'... <span class="keyword">end</span> in <span class="comment">%0.3g s\n'</span>,etime(clock,clock1))</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    fseek(fp,0,<span class="string">'bof'</span>);
<span class="keyword">end</span>
fclose(fp);
fprintf(<span class="string">''</span><span class="string">'<span class="comment">%s'</span><span class="string">' loaded in %0.3g s\n'</span>,filename,etime(clock,clock0))</span>

<span class="keyword">end</span> <span class="comment">%ENDFUNCTION ===============================</span>

<span class="comment">% INITIAL PROTOTYPE BASED ON BINARY2TXT</span>
<span class="comment">% filename = <span class="string">'dump.atom.bin'</span>;</span>
<span class="comment">% fp = fopen(filename,<span class="string">'r'</span>);</span>
<span class="comment">% <span class="keyword">while</span> ~feof(fp)</span>
<span class="comment">%     ntimestep = fread(fp,1,<span class="string">'int'</span>);</span>
<span class="comment">%     natoms    = fread(fp,1,<span class="string">'int'</span>);</span>
<span class="comment">%     bounds    = fread(fp,[2 3],<span class="string">'double'</span>);</span>
<span class="comment">%     size_one = fread(fp,1,<span class="string">'int'</span>);</span>
<span class="comment">%     nchunk = fread(fp,1,<span class="string">'int'</span>);</span>
<span class="comment">%     <span class="keyword">for</span>  i=1:nchunk</span>
<span class="comment">%         n = fread(fp,1,<span class="string">'int'</span>);</span>
<span class="comment">%         buf = fread(fp,[size_one n/size_one],<span class="string">'double'</span>);</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% fclose(fp);</span></code></pre></div>
</div>
<div id='lastdir' class='doc-content' style='display: none;'>
<h1>LASTDIR extrait le nom du dernier r�pertoire du chemin (et la racine correspondante)</h1>
<p>ex. rep = last_dir(chemin)<br/>options : [rep,root] = last_dir(chemin)</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [rep,root] = lastdir(chemin)
<span class="comment">% LASTDIR extrait le nom du dernier r�pertoire du chemin (et la racine correspondante)</span>
<span class="comment">%		ex. rep = last_dir(chemin)</span>
<span class="comment">%		options : [rep,root] = last_dir(chemin)</span>

<span class="comment">% Woodox 1.0 - 27/02/01 - Olivier Vitrac - rev.  02/02/08</span>

<span class="comment">% Revision history</span>
<span class="comment">% 24/01/08 optimization, filesep instead of <span class="string">'\'</span></span>
<span class="comment">% 02/02/08 Unix compatibility</span>
<span class="comment">% 07/02/2019 fix lastdir(filesep)</span>

<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<1, chemin = <span class="string">''</span>; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(chemin), chemin = pwd; <span class="keyword">end</span>
<span class="keyword">if</span> ~ischar(<span class="string">'the argument must be a string'</span>), <span class="keyword">end</span>

<span class="keyword">if</span> isunix 
    <span class="keyword">if</span> (length(chemin)<1), warning(<span class="string">''</span><span class="string">'<span class="comment">%s'</span><span class="string">' does not seem to be a valid path'</span>,chemin), rep = <span class="string">''</span>; <span class="keyword">end</span></span>
<span class="keyword">else</span>
    <span class="keyword">if</span> (length(chemin)==1) && (chemin==filesep), warning(<span class="string">''</span><span class="string">'<span class="comment">%s'</span><span class="string">' does not seem to be a valid path'</span>,chemin), rep = <span class="string">''</span>; <span class="keyword">end</span></span>
<span class="keyword">end</span>

chemin = remove_slash(chemin);
ind = find(chemin == filesep);

<span class="keyword">if</span> any(ind) && ind(<span class="keyword">end</span>)<length(chemin)
   rep = chemin(ind(<span class="keyword">end</span>)+1:<span class="keyword">end</span>);
   <span class="keyword">if</span> nargout>1, root = remove_slash(chemin(1:ind(<span class="keyword">end</span>))); <span class="keyword">end</span>
<span class="keyword">else</span>
   rep = chemin;
   <span class="keyword">if</span> nargout>1, root = <span class="string">''</span>; <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">function</span> chemin = remove_slash(chemin_sl)
<span class="keyword">if</span> isempty(chemin_sl) || (length(chemin_sl)==1 && (chemin_sl(<span class="keyword">end</span>)==filesep) )
    chemin = <span class="string">''</span>;
<span class="keyword">elseif</span> chemin_sl(<span class="keyword">end</span>)==filesep && (isunix || (chemin_sl(<span class="keyword">end</span>-1)~=<span class="string">':'</span>) )
   chemin = chemin_sl(1:<span class="keyword">end</span>-1);
<span class="keyword">else</span>
   chemin = chemin_sl;
<span class="keyword">end</span></code></pre></div>
</div>
<div id='nearestpoint' class='doc-content' style='display: none;'>
<h1>NEARESTPOINT - find the nearest value in another vector</h1>
<p>IND = NEARESTPOINT(X,Y) finds the value in Y which is the closest to<br/>each value in X, so that abs(Xi-Yk) =&gt; abs(Xi-Yj) when k is not equal to j.<br/>IND contains the indices of each of these points.</p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>NEARESTPOINT([1 4 12],[0 3]) -&gt; [1 2 2]</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>[IND,D] = ... also returns the absolute distances in D,
that is D == abs(X - Y(IND))</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>NEARESTPOINT(X, Y, M) specifies the operation mode M:
&#x27;nearest&#x27; : default, same as above
&#x27;previous&#x27;: find the points in Y that are closest, but preceeds a point in X
NEARESTPOINT([0 4 3 12],[0 3],&#x27;previous&#x27;) -&gt; [NaN 2 1 2]
&#x27;next&#x27;    : find the points in Y that are closets, but follow a point in X
NEARESTPOINT([1 4 3 12],[0 3],&#x27;next&#x27;) -&gt; [2 NaN 2 NaN]</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>If there is no previous or next point in Y for a point X(i), IND(i)
will be NaN.</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>X and Y may be unsorted.</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>This function is quite fast, and especially suited for large arrays with
time data. For instance, X and Y may be the times of two separate events,
like simple and complex spike data of a neurophysiological study.</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>EXAMPLE</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>disp(&#x27;TEST for nearestpoint, please wait ... &#x27;) ;
M = 13 ;
tim = NaN(M,3) ;
tim(8:M,1) = 2.^[8:M].&#x27; ;
figure(&#x27;Name&#x27;,&#x27;NearestPointTest&#x27;,&#x27;doublebuffer&#x27;,&#x27;on&#x27;) ;
h = plot(tim(:,1),tim(:,2),&#x27;bo-&#x27;,tim(:,1),tim(:,3),&#x27;rs-&#x27;) ;
xlabel(&#x27;N&#x27;) ;
ylabel(&#x27;Time (seconds)&#x27;) ;
title(&#x27;Test for Nearestpoint function ... please wait ...&#x27;) ;
set(gca,&#x27;xlim&#x27;,[0 max(tim(:,1))+10]) ;
for j=8:M,
N = 2.^j ;
A = rand(N,1) ; B = rand(N,1) ;
tic ;
D1 = zeros(N,1) ;
I1 = zeros(N,1) ;
for i=1:N,
[D1(i), I1(i)] = min(abs(A(i)-B)) ;
end
tim(j,2) = toc ;
pause(0.1) ;
tic ;
[I2,D2] = nearestpoint(A,B) ;
tim(j,3) = toc ;
% isequal(I1,I2)
set(h(1),&#x27;Ydata&#x27;,tim(:,2)) ;
set(h(2),&#x27;Ydata&#x27;,tim(:,3)) ;
drawnow ;
end
title(&#x27;Test for Nearestpoint function&#x27;) ;
legend(&#x27;Traditional for-loop&#x27;,&#x27;Nearestpoint&#x27;,2) ;</code></pre>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [IND, D] = nearestpoint(x,y,m)
<span class="comment">% NEARESTPOINT - find the nearest value in another vector</span>
<span class="comment">%</span>
<span class="comment">%   IND = NEARESTPOINT(X,Y) finds the value in Y which is the closest to </span>
<span class="comment">%   each value in X, so that abs(Xi-Yk) => abs(Xi-Yj) when k is not equal to j.</span>
<span class="comment">%   IND contains the indices of each of these points.</span>
<span class="comment">%   Example: </span>
<span class="comment">%      NEARESTPOINT([1 4 12],[0 3]) -> [1 2 2]</span>
<span class="comment">%</span>
<span class="comment">%   [IND,D] = ... also returns the absolute distances in D,</span>
<span class="comment">%   that is D == abs(X - Y(IND))</span>
<span class="comment">%</span>
<span class="comment">%   NEARESTPOINT(X, Y, M) specifies the operation mode M:</span>
<span class="comment">%   <span class="string">'nearest'</span> : default, same as above</span>
<span class="comment">%   <span class="string">'previous'</span>: find the points in Y that are closest, but preceeds a point in X</span>
<span class="comment">%               NEARESTPOINT([0 4 3 12],[0 3],<span class="string">'previous'</span>) -> [NaN 2 1 2]</span>
<span class="comment">%   <span class="string">'next'</span>    : find the points in Y that are closets, but follow a point in X</span>
<span class="comment">%               NEARESTPOINT([1 4 3 12],[0 3],<span class="string">'next'</span>) -> [2 NaN 2 NaN]</span>
<span class="comment">%</span>
<span class="comment">%   If there is no previous or next point in Y <span class="keyword">for</span> a point X(i), IND(i)</span>
<span class="comment">%   will be NaN.</span>
<span class="comment">%</span>
<span class="comment">%   X and Y may be unsorted.</span>
<span class="comment">%</span>
<span class="comment">%   This <span class="keyword">function</span> is quite fast, and especially suited <span class="keyword">for</span> large arrays with</span>
<span class="comment">%   time data. For instance, X and Y may be the times of two separate events,</span>
<span class="comment">%   like simple and complex spike data of a neurophysiological study.</span>
<span class="comment">%</span>
<span class="comment">%   </span>
<span class="comment">% EXAMPLE</span>
<span class="comment">%</span>
<span class="comment">% disp(<span class="string">'TEST <span class="keyword">for</span> nearestpoint, please wait ... '</span>) ;</span>
<span class="comment">% M = 13 ;</span>
<span class="comment">% tim = NaN(M,3) ;</span>
<span class="comment">% tim(8:M,1) = 2.^[8:M].<span class="string">' ;</span>
<span class="comment">% figure('</span>Name<span class="string">','</span>NearestPointTest<span class="string">','</span>doublebuffer<span class="string">','</span>on<span class="string">') ;</span>
<span class="comment">% h = plot(tim(:,1),tim(:,2),'</span>bo-<span class="string">',tim(:,1),tim(:,3),'</span>rs-<span class="string">') ;</span>
<span class="comment">% xlabel('</span>N<span class="string">') ;</span>
<span class="comment">% ylabel('</span>Time (seconds)<span class="string">') ;</span>
<span class="comment">% title('</span>Test <span class="keyword">for</span> Nearestpoint <span class="keyword">function</span> ... please wait ...<span class="string">') ;</span>
<span class="comment">% set(gca,'</span>xlim<span class="string">',[0 max(tim(:,1))+10]) ;</span>
<span class="comment">% <span class="keyword">for</span> j=8:M,</span>
<span class="comment">%     N = 2.^j ;</span>
<span class="comment">%     A = rand(N,1) ; B = rand(N,1) ;</span>
<span class="comment">%     tic ;</span>
<span class="comment">%     D1 = zeros(N,1) ;</span>
<span class="comment">%     I1 = zeros(N,1) ;</span>
<span class="comment">%     <span class="keyword">for</span> i=1:N,</span>
<span class="comment">%         [D1(i), I1(i)] = min(abs(A(i)-B)) ;</span>
<span class="comment">%     <span class="keyword">end</span></span>
<span class="comment">%     tim(j,2) = toc ;</span>
<span class="comment">%     pause(0.1) ;</span>
<span class="comment">%     tic ;</span>
<span class="comment">%     [I2,D2] = nearestpoint(A,B) ;</span>
<span class="comment">%     tim(j,3) = toc ;</span>
<span class="comment">%     % isequal(I1,I2)</span>
<span class="comment">%     set(h(1),'</span>Ydata<span class="string">',tim(:,2)) ;</span>
<span class="comment">%     set(h(2),'</span>Ydata<span class="string">',tim(:,3)) ;</span>
<span class="comment">%     drawnow ;</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% title('</span>Test <span class="keyword">for</span> Nearestpoint <span class="keyword">function</span><span class="string">') ;</span>
<span class="comment">% legend('</span>Traditional <span class="keyword">for</span>-loop<span class="string">','</span>Nearestpoint<span class="string">',2) ;</span>

<span class="comment">% Created       : august 2004</span>
<span class="comment">% Author        : Jos van der Geest</span>
<span class="comment">% Email         : matlab@jasen.nl</span>
<span class="comment">% Modifications : </span>
<span class="comment">%  aug 25, 2004 - corrected to work with unsorted input values</span>
<span class="comment">%  nov 02, 2005 - </span>
<span class="comment">%  apr 28, 2006 - fixed problem with previous points</span>

<span class="comment">% Revision INRA\Olivier Vitrac - 25/08/11</span>

<span class="comment">% argcheck</span>
<span class="keyword">if</span> nargin<2, error('</span>2 arguments are required<span class="string">'); <span class="keyword">end</span>
<span class="keyword">if</span> nargin==2,
    m = '</span>nearest<span class="string">' ;
<span class="keyword">else</span>
    <span class="keyword">if</span> ~ischar(m),
        error('</span>Mode argument should be a string (either <span class="string">''</span>nearest<span class="string">''</span>, <span class="string">''</span>previous<span class="string">''</span>, or <span class="string">''</span>next<span class="string">''</span>)<span class="string">') ;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> ~isa(x,'</span>double<span class="string">') || ~isa(y,'</span>double<span class="string">'),
    error('</span>X and Y should be double matrices<span class="string">') ;
<span class="keyword">end</span>

<span class="comment">% sort the input vectors</span>
sz = size(x) ;
[x, xi] = sort(x(:)) ; 
[~, xi] = sort(xi) ; <span class="comment">% <span class="keyword">for</span> rearranging the output back to X</span>
nx = numel(x) ; 
cx = zeros(nx,1) ;
qx = isnan(x) ; <span class="comment">% <span class="keyword">for</span> replacing NaNs with NaNs later on</span>

[y,yi] = sort(y(:)) ; 
ny = length(y) ; 
cy = ones(ny,1) ;

xy = [x ; y] ;

[~, xyi] = sort(xy) ;
cxy = [cx ; cy] ;
cxy = cxy(xyi) ; <span class="comment">% cxy(i) = 0 -> xy(i) belongs to X, = 1 -> xy(i) belongs to Y</span>
ii = cumsum(cxy) ;  
ii = ii(cxy==0).'</span> ; <span class="comment">% ii should be a row vector</span>

<span class="comment">% reduce overhead</span>
clear cxy xy xyi ;

<span class="keyword">switch</span> lower(m),
    <span class="keyword">case</span> {<span class="string">'nearest'</span>,<span class="string">'near'</span>,<span class="string">'absolute'</span>}
        <span class="comment">% the indices of the nearest point</span>
        ii = [ii ; ii+1] ;
        ii(ii==0) = 1 ;
        ii(ii>ny) = ny ;         
        yy = y(ii) ;
        dy = abs(repmat(x.<span class="string">',2,1) - yy) ;
        [~, ai] = min(dy) ;
        IND = ii(sub2ind(size(ii),ai,1:nx)) ;
    <span class="keyword">case</span> {'</span>previous<span class="string">','</span>prev<span class="string">','</span>before<span class="string">'}
        <span class="comment">% the indices of the previous points</span>
        ii(ii < 1) = NaN ;
        IND = ii ;
    <span class="keyword">case</span> {'</span>next<span class="string">','</span>after<span class="string">'}
        <span class="comment">% the indices of the next points</span>
        ii = ii + 1 ;
        ii(ii>ny) = NaN ;
        IND = ii ;
    <span class="keyword">otherwise</span>
        error('</span>Unknown method "<span class="comment">%s"',m);</span>
<span class="keyword">end</span>

IND(qx) = NaN ; <span class="comment">% put NaNs back in</span>
<span class="comment">% IND = IND(:) ; % solves a problem <span class="keyword">for</span> x = 1-by-n and y = 1-by-1</span>

<span class="keyword">if</span> nargout==2,
    <span class="comment">% also <span class="keyword">return</span> distance <span class="keyword">if</span> requested;</span>
    D = NaN(1,nx) ;
    q = ~isnan(IND) ;    
    D(q) = abs(x(q) - y(IND(q))) ;
    D = reshape(D(xi),sz) ;
<span class="keyword">end</span>
    
<span class="comment">% reshape and sort to match input X</span>
IND = reshape(IND(xi),sz) ;

<span class="comment">% because Y was sorted, we have to unsort the indices</span>
q = ~isnan(IND) ;
IND(q) = yi(IND(q)) ;

<span class="comment">% END OF FUNCTION</span>



</code></pre></div>
</div>
<div id='packSPH' class='doc-content' style='display: none;'>
<h1>PACKSPH returns the HCP, FCC, or SC packing of siz spheres of radius r</h1>
<p>Syntax:<br/>W = packSPH(siz,r,typ)<br/>Inputs:<br/>siz : [5 5 5] number of spheres along x,y,z<br/>if siz is a scalar, the same siz is applied to all dimensions [siz siz siz]<br/>r : bead radius<br/>typ : &#x27;HCP&#x27; (default, period 2), &#x27;FCC&#x27; (period 3), or &#x27;SC&#x27; (period 1)<br/>&#x27;SC2&#x27; and &#x27;SC3&#x27; implement Simple Cubic with period 2 and period 3, respectively<br/>Output:<br/>X : [size(1)xsize(2)xsize(3)] x 3 centers</p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>X = packSPH(5)</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>See also</h2>
<p><a href="#interp3SPH">interp3SPH</a>, <a href="#interp2SPH">interp2SPH</a>, <a href="#kernelSPH">kernelSPH</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> X = packSPH(siz, r, typ)
<span class="comment">% PACKSPH returns the HCP, FCC, or SC packing of siz spheres of radius r</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       W = packSPH(siz,r,typ)</span>
<span class="comment">%    Inputs:</span>
<span class="comment">%         siz : [5 5 5] number of spheres along x,y,z </span>
<span class="comment">%               <span class="keyword">if</span> siz is a scalar, the same siz is applied to all dimensions [siz siz siz]</span>
<span class="comment">%           r : bead radius</span>
<span class="comment">%         typ : <span class="string">'HCP'</span> (default, period 2), <span class="string">'FCC'</span> (period 3), or <span class="string">'SC'</span> (period 1)</span>
<span class="comment">%               <span class="string">'SC2'</span> and <span class="string">'SC3'</span> implement Simple Cubic with period 2 and period 3, respectively</span>
<span class="comment">%   Output:</span>
<span class="comment">%           X : [size(1)xsize(2)xsize(3)] x 3 centers</span>
<span class="comment">%</span>
<span class="comment">%   Example:</span>
<span class="comment">%       X = packSPH(5)</span>
<span class="comment">%</span>
<span class="comment">%   See also: interp3SPH, interp2SPH, kernelSPH</span>

<span class="comment">% 2023-02-20 | INRAE\Olivier Vitrac | rev. 2023-09-11</span>

<span class="comment">% Revision History</span>
<span class="comment">% 2023-09-11 add SC</span>

<span class="comment">% Argument check</span>
rdefault = 0.5;
typdefault = <span class="string">'HCP'</span>;
<span class="keyword">if</span> nargin < 1, siz = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin < 2, r = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin < 3, typ = <span class="string">''</span>; <span class="keyword">end</span>
<span class="keyword">if</span> numel(siz) == 1, siz = [1,1,1] * siz; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(siz) || numel(siz) ~= 3, error(<span class="string">'siz must be a 1x3 or 3x1 vector'</span>); <span class="keyword">end</span>
<span class="keyword">if</span> isempty(r), r = rdefault; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(typ), typ = typdefault; <span class="keyword">end</span>
<span class="keyword">if</span> ~ischar(typ), error(<span class="string">'typ must be a char array'</span>); <span class="keyword">end</span>

<span class="keyword">switch</span> upper(typ)
    <span class="keyword">case</span> <span class="string">'HCP'</span>
        lattice_type = 0;
    <span class="keyword">case</span> <span class="string">'FCC'</span>
        lattice_type = 1;
    <span class="keyword">case</span> <span class="string">'SC'</span>
        lattice_type = 2;
    <span class="keyword">case</span> <span class="string">'SC2'</span>
        lattice_type = 3;
    <span class="keyword">case</span> <span class="string">'SC3'</span>
        lattice_type = 4;
    <span class="keyword">otherwise</span>
        error(<span class="string">'Valid packaging type is '</span><span class="string">'HCP'</span><span class="string">', '</span><span class="string">'FCC'</span><span class="string">', '</span><span class="string">'SC'</span><span class="string">', '</span><span class="string">'SC2'</span><span class="string">', or '</span><span class="string">'SC3'</span><span class="string">''</span>)
<span class="keyword">end</span>




<span class="comment">% Lattice</span>
[i, j, k] = ndgrid(0:(siz(1) - 1), 0:(siz(2) - 1), 0:(siz(3) - 1));
[i, j, k] = deal(i(:), j(:), k(:));

<span class="keyword">switch</span> lattice_type
    <span class="keyword">case</span> 0  <span class="comment">% HCP</span>
        X = [
            2 * i + mod(j + k, 2), ...
            sqrt(3) * (j + mod(k, 2) / 3), ...
            (2 * sqrt(6) / 3) * k ...
            ] * r;
    <span class="keyword">case</span> 1  <span class="comment">% FCC</span>
        X = [
            2 * i + mod(j + k, 2), ...
            sqrt(3) * (j + mod(k, 2) / 3) + (mod(k, 3) == 2), ...
            (2 * sqrt(6) / 3) * k ...
            ] * r;
    <span class="keyword">case</span> 2  <span class="comment">% SC (Simple Cubic)</span>
        X = [
            i, ...
            j, ...
            k ...
            ] * r * 2;
    <span class="keyword">case</span> 3  <span class="comment">% SC2 (Simple Cubic with a period 2)</span>
        X = [
            i + 0.5 * mod(j + k, 2), ...
            j + 0.5 * mod(k + i, 2), ...
            k + 0.5 * mod(i + j, 2) ...
            ] * r * 2;
    <span class="keyword">case</span> 4  <span class="comment">% SC3 (Simple Cubic with a period 3)</span>
        X = [
            i + mod(j + k, 3) / 3, ...
            j + mod(k + i, 3) / 3, ...
            k + mod(i + j, 3) / 3 ...
            ] * r * 2;
<span class="keyword">end</span>

<span class="comment">% ---- before 2023-09-11 ----</span>
<span class="comment">% % Lattice</span>
<span class="comment">% [i,j,k] = ndgrid(0:(siz(1)-1),0:(siz(2)-1),0:(siz(3)-1)); % HCP is period 2, FCC is period 3</span>
<span class="comment">% [i,j,k] = deal(i(:),j(:),k(:));</span>
<span class="comment">% X = [</span>
<span class="comment">%     2*i + mod(j+k,2) ...x</span>
<span class="comment">%     sqrt(3)*(j+mod(k,2)/3)  + (mod(k,3)==2)*forceFCC...y</span>
<span class="comment">%     (2*sqrt(6)/3)*k ... z</span>
<span class="comment">%     ]*r; % https://en.wikipedia.org/wiki/Close-packing_of_equal_spheres</span></code></pre></div>
</div>
<div id='packing' class='doc-content' style='display: none;'>
<h1>Simple HCP (hexagonal closed pack) lattice</h1>
<p>generator from: https://en.wikipedia.org/wiki/Close-packing_of_equal_spheres<br/>INRAE\Olivier Vitrac, Han Chen - rev. 2023-02-20</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">%% Simple HCP (hexagonal closed pack) lattice</span>
<span class="comment">% generator from: https://en.wikipedia.org/wiki/Close-packing_of_equal_spheres</span>
<span class="comment">% INRAE\Olivier Vitrac, Han Chen - rev. 2023-02-20</span>


<span class="comment">% Define parameters</span>
r = 0.5; <span class="comment">% Radius of spheres</span>
forceFCC = 0; <span class="comment">% 0 <span class="keyword">for</span> HCP and 1 <span class="keyword">for</span> FCC</span>

<span class="comment">% Lattice</span>
[i,j,k] = ndgrid(0:2,0:2,0:2); <span class="comment">% HCP is period 2, FCC is period 3</span>
[i,j,k] = deal(i(:),j(:),k(:));
centers = [
    2*i + mod(j+k,2) ...x
    sqrt(3)*(j+mod(k,2)/3)  + (mod(k,3)==2)*forceFCC...y
    (2*sqrt(6)/3)*k ... z
    ]*r;

<span class="comment">% Create sphere coordinates</span>
[xs,ys,zs] = sphere(100);

<span class="comment">% Translate spheres to close-packed positions</span>
figure
<span class="keyword">for</span> i = 1:size(centers, 1)
    surf(xs*r + centers(i,1), ys*r + centers(i,2), zs*r + centers(i,3),<span class="string">'FaceColor'</span>,rgb(<span class="string">'deepskyblue'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
    hold on;
<span class="keyword">end</span>
lighting gouraud
camlight left
shading interp
axis equal


<span class="comment">%% Lucy kernel, note that s scales the kernel (different scaling in 2D and 3D)</span>
syms h s W(r)
assume(h,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
assume(r,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s);   <span class="comment">% scaling factor in 2D</span>
s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>

<span class="comment">% radial position where the 3D kernel is equal to its average</span>
r1 = solve(W3(r)==1,r,<span class="string">'Maxdegree'</span>,4); <span class="comment">% all solutions (4)</span>
<span class="comment">% only the second root is real and positive</span>
vpa(subs(r1,h,1))
r1 = simplify(r1(2));

<span class="comment">% convert the kernel to a Matlab anonymous <span class="keyword">function</span></span>
<span class="comment">%   function_handle with value:</span>
<span class="comment">%     @(h,r)(1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi</span>
syms R
assume(R<h)
matlabFunction((subs(W3(R),R,r)))

<span class="comment">%% Kernel: numeric implementation</span>
<span class="comment">% single accuracy is used instead of double to reduce memory load</span>
r = single(0.5);
h= single(2*r);
cutoff = @(r) single(r<h);
W = @(r) cutoff(r) .* ( (1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi );
r1expr = matlabFunction(r1);
rplot = linspace(0,1.5*h,1e3);
Wref = 0.1:0.1:floor(W(0));
figure, plot(rplot,W(rplot),<span class="string">'-'</span>,<span class="string">'linewidth'</span>,2), xlabel(<span class="string">'r'</span>), ylabel(<span class="string">'kernel'</span>)
hold on, plot(interpleft(W(rplot),rplot,Wref),Wref,<span class="string">'ro'</span>,<span class="string">'markerfacecolor'</span>,rgb(<span class="string">'Crimson'</span>))
line(r1expr(h)*[1;1;0],[0;1;1],<span class="string">'linewidth'</span>,1.5,<span class="string">'linestyle'</span>,<span class="string">':'</span>,<span class="string">'color'</span>,rgb(<span class="string">'deepskyblue'</span>))
line([r h;r h],[0 0;1 1],<span class="string">'linewidth'</span>,1.5,<span class="string">'linestyle'</span>,<span class="string">'--'</span>,<span class="string">'color'</span>,rgb(<span class="string">'coral'</span>))
text(double(r),1,sprintf(<span class="string">'\\leftarrow r_{bead}=<span class="comment">%0.3g'</span>,r),<span class="string">'HorizontalAlignment'</span>,<span class="string">'left'</span>,<span class="string">'VerticalAlignment'</span>,<span class="string">'top'</span>,<span class="string">'fontsize'</span>,12,<span class="string">'color'</span>,rgb(<span class="string">'Coral'</span>))</span>
text(double(h),1,sprintf(<span class="string">'\\leftarrow h=<span class="comment">%0.3g'</span>,h),<span class="string">'HorizontalAlignment'</span>,<span class="string">'left'</span>,<span class="string">'VerticalAlignment'</span>,<span class="string">'top'</span>,<span class="string">'fontsize'</span>,12,<span class="string">'color'</span>,rgb(<span class="string">'Coral'</span>))</span>

<span class="comment">% 3D field</span>
nresolution = 200;
xw = single(linspace(min(centers(:,1))-h,max(centers(:,1))+h,nresolution));
yw = single(linspace(min(centers(:,2))-h,max(centers(:,2))+h,nresolution));
zw = single(linspace(min(centers(:,3))-h,max(centers(:,3))+h,nresolution));
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
<span class="comment">% calculate the radial distance to the center of the ith sphere</span>
R = @(i) sqrt( (Xw-centers(i,1)).^2 + (Yw-centers(i,2)).^2 + (Zw-centers(i,3)).^2 );
sumW = zeros(size(Xw),<span class="string">'single'</span>);
<span class="keyword">for</span> i=1:size(centers,1)
    dispf(<span class="string">'evaluate field respective to kernel <span class="comment">%d'</span>,i)</span>
    sumW = sumW + W(R(i));
<span class="keyword">end</span>
<span class="comment">% full domain</span>
figure, isosurface(Xw,Yw,Zw,sumW,1), axis equal
<span class="comment">% cut domain x>1.3</span>
figure
sumWcut = sumW;
xcut = 1.3;
sumWcut(xw>xcut,:,:) = [];
[Xwcut,Ywcut,Zwcut] = deal(Xw,Yw,Zw);
Xwcut(xw>xcut,:,:) = [];
Ywcut(xw>xcut,:,:) = [];
Zwcut(xw>xcut,:,:) = [];
p1 = patch(isosurface(Xwcut,Ywcut,Zwcut,sumWcut, 1),<span class="string">'FaceColor'</span>,rgb(<span class="string">'tomato'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
p2 = patch(isocaps(Xwcut,Ywcut,Zwcut,sumWcut, 1),<span class="string">'FaceColor'</span>,<span class="string">'interp'</span>,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
colormap(gray(100)), camlight left, camlight, lighting gouraud, view(-138,28), axis equal
<span class="comment">% slice</span>
figure, hs= slice(Xw,Yw,Zw,sumW,single(1:3),single(1:3),single([])); set(hs,<span class="string">'edgecolor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.5), axis equal

<span class="comment">%% Calculate the field between two beads</span>
r = 0.5; <span class="comment">% Radius of spheres</span>
forceFCC = 1; <span class="comment">% 0 <span class="keyword">for</span> HCP and 1 <span class="keyword">for</span> FCC</span>

<span class="comment">% Lattice</span>
[i,j,k] = ndgrid(0:4,0:4,0:4); <span class="comment">% HCP is period 2, FCC is period 3</span>
[i,j,k] = deal(i(:),j(:),k(:));
centers = [
    2*i + mod(j+k,2) ...x
    sqrt(3)*(j+mod(k,2)/3)  + (mod(k,3)==2)*forceFCC...y
    (2*sqrt(6)/3)*k ... z
    ]*r;

<span class="comment">% Create sphere coordinates</span>
[xs,ys,zs] = sphere(100);

<span class="comment">% Translate spheres to close-packed positions</span>
figure
ncenters = size(centers,1);
<span class="keyword">for</span> i = 1:size(centers, 1)
    hs(i) = surf(xs*r + centers(i,1), ys*r + centers(i,2), zs*r + centers(i,3),<span class="string">'FaceColor'</span>,rgb(<span class="string">'deepskyblue'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.2);
    hold on;
<span class="keyword">end</span>
lighting gouraud
camlight left
shading interp
axis equal

<span class="comment">% the most central bead and found the next neighbors (coordination number = 12 with HCP)</span>
[~,icentral] = min(sum((centers-mean(centers)).^2,2));
set(hs(icentral),<span class="string">'facecolor'</span>,rgb(<span class="string">'Crimson'</span>),<span class="string">'FaceAlpha'</span>,1)
dcentral = sqrt(sum((centers-centers(icentral,:)).^2,2));
icontact = find( (dcentral>=2*r-0.0001) & (dcentral<=2*r+0.0001) );
ncontact = length(icontact);
set(hs(icontact),<span class="string">'facecolor'</span>,rgb(<span class="string">'ForestGreen'</span>),<span class="string">'FaceAlpha'</span>,1)

<span class="comment">%% Averaged field between the icentral (red) bead and the icontact (green) one</span>
nd = 1000;
d = linspace(-0.1*r,2*r+0.1*r,nd)<span class="string">'; <span class="comment">% support</span>
r = 0.5;
hlist = r*linspace(1.5,4,20);
nh = length(hlist);
sumW = zeros(nd,nh,ncontact);

<span class="keyword">for</span> ih = 1:nh
    h= hlist(ih);
    cutoff = @(r) single(r<h);
    W = @(r) cutoff(r) .* ( (1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi );
    <span class="keyword">for</span> j = 1:ncontact
        xyz0 = centers(icentral,:);   <span class="comment">% red bead coordinates</span>
        xyz = centers(icontact(j),:); <span class="comment">% green bead coordinated</span>
        direction = (xyz-xyz0)/norm(xyz-xyz0);
        xyzd = xyz0 + direction .* d;
        R = @(i) sqrt( sum((xyzd-centers(i,:)).^2,2));
        <span class="keyword">for</span> i=1:size(centers,1)
            sumW(:,ih,j) = sumW(:,ih,j) + W(R(i));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
figure('</span>defaultAxesColorOrder<span class="string">',parula(nh))
leg = arrayfun(@(x) sprintf('</span>h/r_{bead}=<span class="comment">%0.3g<span class="string">',x),hlist/r,'</span>UniformOutput<span class="string">',false);</span>
hp = plot(d/r,mean(sumW,3),'</span>-<span class="string">','</span>linewidth<span class="string">',3);
legend(hp,leg,'</span>location<span class="string">','</span>eastoutside<span class="string">','</span>fontsize<span class="string">',10,'</span>box<span class="string">','</span>off<span class="string">')
formatax(gca,'</span>fontsize<span class="string">',12)
xlabel('</span>r/r_{bead}<span class="string">','</span>fontsize<span class="string">',16)
ylabel('</span>density<span class="string">','</span>fontsize',16)</code></pre></div>
</div>
<div id='packing_WJbranch' class='doc-content' style='display: none;'>
<h1>Simple HCP (hexagonal closed pack) lattice</h1>
<p>generator from: https://en.wikipedia.org/wiki/Close-packing_of_equal_spheres<br/>INRAE\Olivier Vitrac, Han Chen - rev. 2023-02-20</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">%% Simple HCP (hexagonal closed pack) lattice</span>
<span class="comment">% generator from: https://en.wikipedia.org/wiki/Close-packing_of_equal_spheres</span>
<span class="comment">% INRAE\Olivier Vitrac, Han Chen - rev. 2023-02-20</span>


<span class="comment">% Define parameters</span>
r = 0.5; <span class="comment">% Radius of spheres</span>
forceFCC = 0; <span class="comment">% 0 <span class="keyword">for</span> HCP and 1 <span class="keyword">for</span> FCC</span>

<span class="comment">% Lattice</span>
[i,j,k] = ndgrid(0:2,0:2,0:2); <span class="comment">% HCP is period 2, FCC is period 3</span>
[i,j,k] = deal(i(:),j(:),k(:));
centers = [
    2*i + mod(j+k,2) ...x
    sqrt(3)*(j+mod(k,2)/3)  + (mod(k,3)==2)*forceFCC...y
    (2*sqrt(6)/3)*k ... z
    ]*r;

<span class="comment">% Create sphere coordinates</span>
[xs,ys,zs] = sphere(100);

<span class="comment">% Translate spheres to close-packed positions</span>
figure
<span class="keyword">for</span> i = 1:size(centers, 1)
    surf(xs*r + centers(i,1), ys*r + centers(i,2), zs*r + centers(i,3),<span class="string">'FaceColor'</span>,rgb(<span class="string">'deepskyblue'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
    hold on;
<span class="keyword">end</span>
lighting gouraud
camlight left
shading interp
axis equal


<span class="comment">%% Lucy kernel, note that s scales the kernel (different scaling in 2D and 3D)</span>
syms h s W(r)
assume(h,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
assume(r,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s);   <span class="comment">% scaling factor in 2D</span>
s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>

<span class="comment">% radial position where the 3D kernel is equal to its average</span>
r1 = solve(W3(r)==1,r,<span class="string">'Maxdegree'</span>,4); <span class="comment">% all solutions (4)</span>
<span class="comment">% only the second root is real and positive</span>
vpa(subs(r1,h,1))
r1 = simplify(r1(2));

<span class="comment">% convert the kernel to a Matlab anonymous <span class="keyword">function</span></span>
<span class="comment">%   function_handle with value:</span>
<span class="comment">%     @(h,r)(1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi</span>
syms R
assume(R<h)
matlabFunction((subs(W3(R),R,r)))

<span class="comment">%% Kernel: numeric implementation</span>
<span class="comment">% single accuracy is used instead of double to reduce memory load</span>
r = single(0.5);
h= single(2*r);
cutoff = @(r) single(r<h);
W = kernelSPH(h,<span class="string">'spikykernelder'</span>,2);
r1expr = matlabFunction(r1);
rplot = linspace(0,1.5*h,1e3);
Wref = 0.1:0.1:floor(W(0));
figure, plot(rplot,W(rplot),<span class="string">'-'</span>,<span class="string">'linewidth'</span>,2), xlabel(<span class="string">'r'</span>), ylabel(<span class="string">'kernel'</span>)
hold on, plot(interpleft(W(rplot),rplot,Wref),Wref,<span class="string">'ro'</span>,<span class="string">'markerfacecolor'</span>,rgb(<span class="string">'Crimson'</span>))
line(r1expr(h)*[1;1;0],[0;1;1],<span class="string">'linewidth'</span>,1.5,<span class="string">'linestyle'</span>,<span class="string">':'</span>,<span class="string">'color'</span>,rgb(<span class="string">'deepskyblue'</span>))
line([r h;r h],[0 0;1 1],<span class="string">'linewidth'</span>,1.5,<span class="string">'linestyle'</span>,<span class="string">'--'</span>,<span class="string">'color'</span>,rgb(<span class="string">'coral'</span>))
text(double(r),1,sprintf(<span class="string">'\\leftarrow r_{bead}=<span class="comment">%0.3g'</span>,r),<span class="string">'HorizontalAlignment'</span>,<span class="string">'left'</span>,<span class="string">'VerticalAlignment'</span>,<span class="string">'top'</span>,<span class="string">'fontsize'</span>,12,<span class="string">'color'</span>,rgb(<span class="string">'Coral'</span>))</span>
text(double(h),1,sprintf(<span class="string">'\\leftarrow h=<span class="comment">%0.3g'</span>,h),<span class="string">'HorizontalAlignment'</span>,<span class="string">'left'</span>,<span class="string">'VerticalAlignment'</span>,<span class="string">'top'</span>,<span class="string">'fontsize'</span>,12,<span class="string">'color'</span>,rgb(<span class="string">'Coral'</span>))</span>

<span class="comment">% 3D field</span>
nresolution = 200;
xw = single(linspace(min(centers(:,1))-h,max(centers(:,1))+h,nresolution));
yw = single(linspace(min(centers(:,2))-h,max(centers(:,2))+h,nresolution));
zw = single(linspace(min(centers(:,3))-h,max(centers(:,3))+h,nresolution));
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
<span class="comment">% calculate the radial distance to the center of the ith sphere</span>
R = @(i) sqrt( (Xw-centers(i,1)).^2 + (Yw-centers(i,2)).^2 + (Zw-centers(i,3)).^2 );
sumW = zeros(size(Xw),<span class="string">'single'</span>);
<span class="keyword">for</span> i=1:size(centers,1)
    dispf(<span class="string">'evaluate field respective to kernel <span class="comment">%d'</span>,i)</span>
    sumW = sumW + W(R(i));
<span class="keyword">end</span>
<span class="comment">% full domain</span>
figure, isosurface(Xw,Yw,Zw,sumW,1), axis equal
<span class="comment">% cut domain x>1.3</span>
figure
sumWcut = sumW;
xcut = 1.3;
sumWcut(xw>xcut,:,:) = [];
[Xwcut,Ywcut,Zwcut] = deal(Xw,Yw,Zw);
Xwcut(xw>xcut,:,:) = [];
Ywcut(xw>xcut,:,:) = [];
Zwcut(xw>xcut,:,:) = [];
p1 = patch(isosurface(Xwcut,Ywcut,Zwcut,sumWcut, 1),<span class="string">'FaceColor'</span>,rgb(<span class="string">'tomato'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
p2 = patch(isocaps(Xwcut,Ywcut,Zwcut,sumWcut, 1),<span class="string">'FaceColor'</span>,<span class="string">'interp'</span>,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
colormap(gray(100)), camlight left, camlight, lighting gouraud, view(-138,28), axis equal
<span class="comment">% slice</span>
figure, hs= slice(Xw,Yw,Zw,sumW,single(1:3),single(1:3),single([])); set(hs,<span class="string">'edgecolor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.5), axis equal

<span class="comment">%% Calculate the field between two beads</span>
r = 0.5; <span class="comment">% Radius of spheres</span>
forceFCC = 1; <span class="comment">% 0 <span class="keyword">for</span> HCP and 1 <span class="keyword">for</span> FCC</span>

<span class="comment">% Lattice</span>
[i,j,k] = ndgrid(0:4,0:4,0:4); <span class="comment">% HCP is period 2, FCC is period 3</span>
[i,j,k] = deal(i(:),j(:),k(:));
centers = [
    2*i + mod(j+k,2) ...x
    sqrt(3)*(j+mod(k,2)/3)  + (mod(k,3)==2)*forceFCC...y
    (2*sqrt(6)/3)*k ... z
    ]*r;

<span class="comment">% Create sphere coordinates</span>
[xs,ys,zs] = sphere(100);

<span class="comment">% Translate spheres to close-packed positions</span>
figure
ncenters = size(centers,1);
<span class="keyword">for</span> i = 1:size(centers, 1)
    hs(i) = surf(xs*r + centers(i,1), ys*r + centers(i,2), zs*r + centers(i,3),<span class="string">'FaceColor'</span>,rgb(<span class="string">'deepskyblue'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.2);
    hold on;
<span class="keyword">end</span>
lighting gouraud
camlight left
shading interp
axis equal

<span class="comment">% the most central bead and found the next neighbors (coordination number = 12 with HCP)</span>
[~,icentral] = min(sum((centers-mean(centers)).^2,2));
set(hs(icentral),<span class="string">'facecolor'</span>,rgb(<span class="string">'Crimson'</span>),<span class="string">'FaceAlpha'</span>,1)
dcentral = sqrt(sum((centers-centers(icentral,:)).^2,2));
icontact = find( (dcentral>=2*r-0.0001) & (dcentral<=2*r+0.0001) );
ncontact = length(icontact);
set(hs(icontact),<span class="string">'facecolor'</span>,rgb(<span class="string">'ForestGreen'</span>),<span class="string">'FaceAlpha'</span>,1)

<span class="comment">%% Averaged field between the icentral (red) bead and the icontact (green) one</span>
nd = 1000;
d = linspace(-0.1*r,2*r+0.1*r,nd)<span class="string">'; <span class="comment">% support</span>
r = 0.5;
hlist = r*linspace(1.5,4,20);
nh = length(hlist);
sumW = zeros(nd,nh,ncontact);

<span class="keyword">for</span> ih = 1:nh
    h= hlist(ih);
    cutoff = @(r) single(r<h);
    W = @(r) cutoff(r) .* ( (1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi );
    <span class="keyword">for</span> j = 1:ncontact
        xyz0 = centers(icentral,:);   <span class="comment">% red bead coordinates</span>
        xyz = centers(icontact(j),:); <span class="comment">% green bead coordinated</span>
        direction = (xyz-xyz0)/norm(xyz-xyz0);
        xyzd = xyz0 + direction .* d;
        R = @(i) sqrt( sum((xyzd-centers(i,:)).^2,2));
        <span class="keyword">for</span> i=1:size(centers,1)
            sumW(:,ih,j) = sumW(:,ih,j) + W(R(i));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
figure('</span>defaultAxesColorOrder<span class="string">',parula(nh))
leg = arrayfun(@(x) sprintf('</span>h/r_{bead}=<span class="comment">%0.3g<span class="string">',x),hlist/r,'</span>UniformOutput<span class="string">',false);</span>
hp = plot(d/r,mean(sumW,3),'</span>-<span class="string">','</span>linewidth<span class="string">',3);
legend(hp,leg,'</span>location<span class="string">','</span>eastoutside<span class="string">','</span>fontsize<span class="string">',10,'</span>box<span class="string">','</span>off<span class="string">')
formatax(gca,'</span>fontsize<span class="string">',12)
xlabel('</span>r/r_{bead}<span class="string">','</span>fontsize<span class="string">',16)
ylabel('</span>density<span class="string">','</span>fontsize',16)</code></pre></div>
</div>
<div id='particle_flux' class='doc-content' style='display: none;'>
<h1>particle_flux for post-treatment of Billy&#x27; dump files (3D viscosimeter)</h1>
<p>INRAE\Olivier Vitrac - rev. 2023-03-26<br/>INRAE\William Jenkinson</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% particle_flux <span class="keyword">for</span> post-treatment of Billy<span class="string">' dump files (3D viscosimeter)</span>
<span class="comment">% INRAE\Olivier Vitrac - rev. 2023-03-26</span>
<span class="comment">% INRAE\William Jenkinson</span>

<span class="comment">% Dependencies (not included in MS, at least not yet)</span>
<span class="comment">%   lamdumpread2()    version 2023-03-23 or later</span>
<span class="comment">%   buildVerletList() version 2023-03-25 or later</span>
<span class="comment">%</span>
<span class="comment">% note: be sure Olivier/INRA/Codes/MS is in your Path (MS=Molecular Studio)</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-03-23 RC, early design based on dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_Hertzdiv100_lite</span>
<span class="comment">% 2023-03-24 first interaction with Billy</span>
<span class="comment">%            the file <span class="keyword">for</span> design was shifted to dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_Hertzdiv10_lite</span>
<span class="comment">% 2023-03-25 implementation of a full Verletlist, automatic identification of fluid-solid contacts without using any</span>
<span class="comment">%            particular topology, the template is fully operational and used to plot the number of contacts with time</span>
<span class="comment">% 2023-03-06 first implementation of Hertz contacts (to be validated and extended)</span>
<span class="comment">%            better figure management (previous results can be reloaded)</span>
<span class="comment">% 2023-03-29 [BRANCH - WJ] script taken to template the kinetic energy vs time</span>
<span class="comment">% 2023-03-31 WJ - meta data and script are up-to-date <span class="keyword">for</span> the calculation of Kinetic Energy</span>
<span class="comment">% 2023-03-31 [BRANCH - WJ] script taken to template the particle flux past a point</span>

<span class="comment">%% read datafile</span>

<span class="comment">% path definitions (please add your machine name by typing localname in your command window)</span>
<span class="keyword">switch</span> localname
    <span class="keyword">case</span> '</span>LP-OLIVIER2022<span class="string">'
        local = '</span>C:\Users\olivi\OneDrive - agroparistech.fr\Billy\ProductionSandbox_toOV_23-03-2023<span class="string">';
    <span class="keyword">case</span> '</span>LX-Willy2021<span class="string">'
        local = '</span>/Data/billy/Results/Viscosimeter_SMJ_V6/ProductionSandbox_toOV_23-03-2023<span class="string">';
    <span class="keyword">case</span> '</span>YOUR MACHINE<span class="string">'
        local = '</span>it is the path where the dump file is located, results are stored at the sample place<span class="string">';
    <span class="keyword">otherwise</span>
        error('</span>add a <span class="keyword">case</span> with your machine name, which is <span class="string">''</span><span class="comment">%s<span class="string">''</span><span class="string">',localname)</span>
<span class="keyword">end</span>
datafile = '</span>dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1<span class="string">';
<span class="comment">%datafile = '</span>dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1<span class="string">';</span>
fulldatafile = fullfile(local,datafile); <span class="comment">% concatenate path (local) and data filename</span>
X = lamdumpread2(fulldatafile); <span class="comment">% be sure the last version of lamdumpread2() is in the same folder as this script</span>

<span class="comment">% result file (to store results)</span>
resultfile = fullfile(local,['</span>RESULT_<span class="string">' datafile '</span>.mat<span class="string">']);

<span class="comment">%% Region-based definitions:  Wall and fluid regions</span>
<span class="comment">% note that the interface between regions is defined from pair-distances</span>
types = struct('</span>wall<span class="string">',1,'</span>fluid<span class="string">',2);
X.ATOMS.iswall = X.ATOMS.type==types.wall;  <span class="comment">% add the column iswall to the table X.ATOMS</span>
X.ATOMS.isfluid = X.ATOMS.type==types.fluid;<span class="comment">% add the column isfluid to the table X.ATOMS</span>
X.ATOMS.isundef = ~X.ATOMS.iswall & ~X.ATOMS.isfluid; <span class="comment">% add the column isundef to the table X.ATOMS</span>

<span class="comment">%% Control frame</span>
<span class="comment">% note that the data are stored in data.ATOMS, which is a table with named colums allowing hybrid indexing</span>
nsteps = length(X.TIMESTEP);
icurrenttime = ceil(0.5*nsteps); <span class="comment">% index of the control frame (used to set basic definitions before more advanced interpretation)</span>
currenttime = X.TIMESTEP(icurrenttime);
rawframe = X.ATOMS(X.ATOMS.TIMESTEP==currenttime,{'</span>id<span class="string">','</span>type<span class="string">','</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">','</span>iswall<span class="string">','</span>isfluid<span class="string">','</span>isundef<span class="string">'});
frame = table2array(rawframe(:,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'})); <span class="comment">% generate an array of coordinates</span>

<span class="comment">% % Build the main Verlet list (<span class="keyword">for</span> all particles)</span>
<span class="comment">% % V use the natural indexing instead of rawframe.id</span>
<span class="comment">% cutoff = 60e-6; % empty or NaN value will force an automatic estimation of cutoff</span>
<span class="comment">% [V,cutoff,dmin] = buildVerletList(frame,cutoff); % cutoff can be omitted</span>
<span class="comment">%  </span>
<span class="comment">% % Build the secondary Verlet lists (highly vectorized code)</span>
<span class="comment">% % V1 the neighbors of type 2 (fluid) <span class="keyword">for</span> type 1 atoms (1..n1)</span>
<span class="comment">% % V2 the neighbors of type 1 (wall) <span class="keyword">for</span> type 2 atoms (1..n2)</span>
<span class="comment">% idx1 = find(rawframe.type==1); n1 = length(idx1); % indices of the wall particles in the current frame</span>
<span class="comment">% idx2 = find(rawframe.type==2); n2 = length(idx2); % indices of the fluid particles in the current frame</span>
<span class="comment">% V1 = cellfun(@(v) v(rawframe.type(v)==2),V(idx1),'</span>UniformOutput<span class="string">',false); % Verlet list <span class="keyword">for</span> type 1 in contact with type 2</span>
<span class="comment">% V2 = cellfun(@(v) v(rawframe.type(v)==1),V(idx2),'</span>UniformOutput<span class="string">',false); % Verlet list <span class="keyword">for</span> type 1 in contact with type 2</span>
<span class="comment">% % corresponding distances d1,d2</span>
<span class="comment">% % some distances can be empty <span class="keyword">for</span> d2</span>
<span class="comment">% d1 = arrayfun(@(i) pdist2(frame(idx1(i),:),frame(V1{i},:)),(1:n1)'</span>,<span class="string">'UniformOutput'</span>,false); % evaluate the distance <span class="keyword">for</span> each idx1(i)</span>
<span class="comment">% d2 = arrayfun(@(i) pdist2(frame(idx2(i),:),frame(V2{i},:)),(1:n2)<span class="string">','</span>UniformOutput<span class="string">',false); % evaluate the distance <span class="keyword">for</span> each idx2(i)</span>
<span class="comment">% d1min = cellfun(@min,d1); % minimum distance <span class="keyword">for</span> each idx1()</span>
<span class="comment">% d2min = cellfun(@min,d2,'</span>UniformOutput<span class="string">',false); % minimum distance <span class="keyword">for</span> each idx2()</span>
<span class="comment">% [d2min{cellfun(@isempty,d2)}] = deal(NaN); % populate empty distances with NaN</span>
<span class="comment">% d2min = cat(1,d2min{:}); % we collect all now all distances (since the fluid is moving with respect with the wall)</span>
<span class="comment">%  </span>
<span class="comment">% % Identify beads of type 1 (wall) directly in contact with fluids</span>
<span class="comment">% % this method is general and relies only on pair distances</span>
<span class="comment">% % the term "contact" is general (vincinity) not a "real" contact as set later</span>
<span class="comment">% iswallcontact = d1min < 1.5 * dmin;  % condition <span class="keyword">for</span> a wall particle to be considered possibly in contact with the fluid</span>
<span class="comment">% isfluidcontact = ~isnan(d2min);      % the condition is less restrictive <span class="keyword">for</span> the fluid, based on the cutoff distance</span>
<span class="comment">% V1contact = V1(iswallcontact);       % "contact" Verlet list corresponding to V1</span>
<span class="comment">% V2contact = V2(isfluidcontact);      % "contact" Verlet list corresponding to V1</span>
<span class="comment">% iwallcontact = idx1(iswallcontact);</span>
<span class="comment">% ifluidcontact = unique(cat(2,V1contact{:})); % within cutoff</span>
<span class="comment">% % </span>
<span class="comment">% % control plot</span>
<span class="comment">% % one color is assigned to each phase</span>
<span class="comment">% % symbols are filled <span class="keyword">if</span> they are included in the contact Verlet list</span>
<span class="comment">% % type figure, rgb() to list all available colors</span>
<span class="comment">% colors = struct('</span>wall<span class="string">',rgb('</span>Crimson<span class="string">'),'</span>fluid<span class="string">',rgb('</span>DeepSkyBlue<span class="string">'),'</span>none<span class="string">','</span>None<span class="string">');</span>
<span class="comment">% figure, hold on</span>
<span class="comment">% plot3D(frame(rawframe.isundef,:),'</span>ko<span class="string">');</span>
<span class="comment">% plot3D(frame(rawframe.iswall,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.wall,'</span>MarkerFaceColor<span class="string">',colors.none);</span>
<span class="comment">% plot3D(frame(iwallcontact,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.none,'</span>MarkerFaceColor<span class="string">',colors.wall);</span>
<span class="comment">% plot3D(frame(rawframe.isfluid,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.fluid,'</span>MarkerFaceColor<span class="string">',colors.none);</span>
<span class="comment">% plot3D(frame(ifluidcontact,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.none,'</span>MarkerFaceColor<span class="string">',colors.fluid);</span>
<span class="comment">% axis equal, axis tight, view(3)</span>

<span class="comment">%% [1:X] INTERPRETATION: counting the number of contact with time</span>
<span class="comment">% count the number of fluid beads in contact with wall (within 2*R)</span>
R = 0.5*0.001/48; <span class="comment">% radius of the particle (please, be very accurate)</span>
dbond = 2*R; <span class="comment">% bond = link between 2 atoms</span>
wall_id  = rawframe.id(iwallcontact);   <span class="comment">% extract the ids matching the contact condition in the reference frame</span>
fluid_id = rawframe.id(ifluidcontact);  <span class="comment">% idem <span class="keyword">for</span> the fluid particles within the contact Verlet list</span>
<span class="comment">% config setup</span>
E = 2e4 ; <span class="comment">% ref:2e6, Hertzdiv10:2e5, Hertzdiv100:2e4</span>
Hertzconfig = struct('</span>name<span class="string">',{'</span>wall<span class="string">','</span>fluid<span class="string">'},'</span>R<span class="string">',R,'</span>E<span class="string">',E); <span class="comment">% entries are duplicated <span class="keyword">if</span> not mentioned</span>

<span class="comment">% prepare to calculate pair distances between different beads</span>
pairdist = @(X,Y) triu(pdist2(X,Y),0); <span class="comment">% note that the diagonal is included here (since X and Y are different)</span>
ncontacts = zeros(nsteps,1);
particleflux = zeros(nsteps,1);
[t_,t__] = deal(clock); <span class="comment">%#ok<*CLOCK> </span>
screen = '</span><span class="string">';
<span class="keyword">for</span> icurrenttime = 2:nsteps
    currenttime = X.TIMESTEP(icurrenttime);
    previoustime = X.TIMESTEP(icurrenttime-1);
    <span class="comment">% --- some display, to encourage the user to be patient</span>
    <span class="keyword">if</span> mod(icurrenttime,5)
        <span class="keyword">if</span> etime(clock,t__)>2 <span class="comment">%#ok<*DETIM></span>
            t__ = clock; dt = etime(t__,t_); done = 100*(icurrenttime-1)/nsteps;
            screen = dispb(screen,'</span>[<span class="comment">%d/%d] interpretation [ done %0.3g %% | elapsed %0.3g s | remaining %0.3g s ] ...<span class="string">', ...</span>
                icurrenttime,nsteps,done,dt,dt*(100/done-1));
        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">% --- <span class="keyword">end</span> of display</span>
    x1 = table2array(X.ATOMS((X.ATOMS.TIMESTEP==(previoustime)) & (X.ATOMS.type==1),{'</span>id<span class="string">','</span>x<span class="string">','</span>mass<span class="string">'})); <span class="comment">% raw data <span class="keyword">for</span> the previous frame</span>
    x2 = table2array(X.ATOMS((X.ATOMS.TIMESTEP==(currenttime)) & (X.ATOMS.type==1),{'</span>id<span class="string">','</span>x<span class="string">','</span>mass<span class="string">'})); <span class="comment">% raw data <span class="keyword">for</span> the current frame</span>
    passpoint = 0.0005;
    <span class="keyword">for</span> i = 1:numel(x1(:,2))
        <span class="keyword">if</span> (x1(i,2)-passpoint < 0) && (x2(i,2)-passpoint > 0)
            particleflux(icurrenttime) = particleflux(icurrenttime) + 1; <span class="comment">% sum forces along x</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% save the data to enable a refresh of the figure without restarting this block</span>
timesteps = X.TIMESTEP;
save(resultfile,'</span>datafile<span class="string">','</span>KEnergy<span class="string">','</span>ncontacts<span class="string">','</span>timesteps<span class="string">','</span>Hertzconfig<span class="string">')
dispf('</span>Results saved (<span class="comment">%s):<span class="string">',datafile), fileinfo(resultfile)</span>

<span class="comment">%% PLots and figure management</span>

<span class="comment">% reload the data</span>
<span class="keyword">if</span> exist(resultfile,'</span>file<span class="string">'), load(resultfile), <span class="keyword">end</span>

<span class="comment">% plot number of contacts vs. time</span>
contactfigure = figure;
formatfig(contactfigure,'</span>figname<span class="string">',['</span>NumberContact<span class="string">' datafile],'</span>PaperPosition<span class="string">',[1.5000    9.2937   18.0000   11.1125])
plot(timesteps,ncontacts,'</span>linewidth<span class="string">',0.5,'</span>Color<span class="string">',rgb('</span>Crimson<span class="string">'))
formatax(gca,'</span>fontsize<span class="string">',14)
xlabel('</span>time (units)<span class="string">','</span>fontsize<span class="string">',16)
ylabel('</span>Kinetic energy of particles ()<span class="string">','</span>fontsize<span class="string">',16)
wtitle = textwrap({'</span>\bfdump file:\rm<span class="string">';datafile},40);
title(regexprep(wtitle,'</span>_<span class="string">','</span>\\_<span class="string">'),'</span>fontsize<span class="string">',10)

<span class="comment">% plot number of Hertz projection along x vs. time</span>
hertzfigure = figure;
formatfig(hertzfigure,'</span>figname<span class="string">',['</span>ParticleFlux<span class="string">' datafile],'</span>PaperPosition<span class="string">',[1.5000    9.2937   18.0000   11.1125])
plot(timesteps,particleflux,'</span>linewidth<span class="string">',0.5,'</span>Color<span class="string">',rgb('</span>Teal<span class="string">'))
formatax(gca,'</span>fontsize<span class="string">',14)
xlabel('</span>Frame (-)<span class="string">','</span>fontsize<span class="string">',16)
ylabel('</span>Particle flux (s^-1)<span class="string">','</span>fontsize<span class="string">',16)
wtitle = textwrap({'</span>\bfdump file:\rm<span class="string">';datafile},40);
title(regexprep(wtitle,'</span>_<span class="string">','</span>\\_<span class="string">'),'</span>fontsize<span class="string">',10)

<span class="comment">% save images in all valid formats (including Matlab one, the data can be extracted with this format)</span>
<span class="comment">% filenames are identical to the dump file with the proper extension: fig, pdf, png</span>
<span class="keyword">for</span> myfig = [contactfigure,hertzfigure] <span class="comment">% loop over all figures to print</span>
    figure(myfig)
    saveas(gcf,fullfile(local,[get(gcf,'</span>filename<span class="string">') '</span>.fig<span class="string">']),'</span>fig<span class="string">') <span class="comment">% fig can be open without restarting the code</span>
    print_pdf(600,[get(gcf,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],local,'</span>nocheck<span class="string">') <span class="comment">% PDF 600 dpi</span>
    print_png(600,[get(gcf,'</span>filename<span class="string">') '</span>.png<span class="string">'],local,'</span>',0,0,0)  <span class="comment">% PNG 600 dpi</span>
<span class="keyword">end</span>

</code></pre></div>
</div>
<div id='partitionVerletList' class='doc-content' style='display: none;'>
<h1>PARTITIONVERLETLIST partition an existing Verlet list based on type (cross-terms)</h1>
<p>Syntax: partV = partitionVerletList(V,typ)</p>
<h2>See also</h2>
<p><a href="#buildVerletList">buildVerletList</a>, <a href="#updateVerletList">updateVerletList</a>, <a href="#selfVerletList">selfVerletList</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> partV = partitionVerletList(V,typ)
<span class="comment">% PARTITIONVERLETLIST partition an existing Verlet list based on type (cross-terms)</span>
<span class="comment">%</span>
<span class="comment">%   Syntax: partV = partitionVerletList(V,typ)</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: buildVerletList, updateVerletList, selfVerletList</span>


<span class="comment">% MS 3.0 | 2023-04-01 | INRAE\Olivier.vitrac@agroparistech.fr | rev. 2023-08-29</span>

<span class="comment">% CHeck arguments</span>
<span class="keyword">if</span> nargin<2, error(<span class="string">'two arguments are required:  partV = partitionVerletList(V,typ)'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> istable(typ), typ = typ.type; <span class="keyword">end</span>
n = length(typ); <span class="comment">% number of particless</span>
<span class="keyword">if</span> ~iscell(V) || length(V)~=n
    error(<span class="string">'the supplied VerletList (<span class="comment">%d atoms) is not compatible with X (%d atoms)'</span>,length(V),n)</span>
<span class="keyword">end</span>

<span class="comment">% Main</span>
partV = cell(n,1);
<span class="keyword">for</span> i=1:n
    partV{i} = V{i}(typ(V{i})~=typ(i));
<span class="keyword">end</span>

</code></pre></div>
</div>
<div id='plot3D' class='doc-content' style='display: none;'>
<h1>PLOT3D wrapper of plot3(X(:,1),X(:,2),X(:,3),&#x27;property&#x27;,&#x27;value&#x27;)</h1>
<p>syntax: h=plot3D(X,property,value...)<br/>NB: works also on cell array</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> ho=plot3D(X,varargin)
<span class="comment">%PLOT3D wrapper of plot3(X(:,1),X(:,2),X(:,3),<span class="string">'property'</span>,<span class="string">'value'</span>)</span>
<span class="comment">%   syntax: h=plot3D(X,property,value...)</span>
<span class="comment">%   NB: works also on cell array</span>

<span class="comment">% MS 2.1 - 30/03/08 - INRA\Olivier Vitrac rev.</span>

<span class="comment">% default</span>

<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<1, error(<span class="string">'h=plot3D(X,property,value...)'</span>), <span class="keyword">end</span>
options = varargin;
<span class="keyword">if</span> iscell(X)
    nX = length(X);
    h = [];
    <span class="keyword">if</span> ~iscell(X{1}) <span class="comment">% new molecule</span>
        pos=1; ntot = sum(cellfun(<span class="string">'length'</span>,X));
        <span class="keyword">for</span> i=1:nX
            h =[h;plot3D(X{i},<span class="string">'colrange'</span>,[pos ntot],options{:})];
            pos = pos+length(X{i});
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        <span class="keyword">if</span> isempty(options)
            col = jet(nX);
            <span class="keyword">for</span> i=1:nX, h= [h;plot3D(X{i},<span class="string">'-o'</span>,<span class="string">'color'</span>,col(i,:),<span class="string">'markeredgecolor'</span>,col(i,:),<span class="string">'markerfacecolor'</span>,col(i,:),<span class="string">'linewidth'</span>,2,<span class="string">'markersize'</span>,12)]; <span class="keyword">end</span>
        <span class="keyword">else</span>
            <span class="keyword">for</span> i=1:nX, h= [h;plot3D(X{i},options{:})]; <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> nargout, ho = h; <span class="keyword">end</span>
    <span class="keyword">return</span>
<span class="keyword">elseif</span> size(X,3)>1
    nX = size(X,3);
    col = jet(nX); h = [];
    <span class="keyword">for</span> i=1:nX, h=[h;plot3D(X(:,:,i),<span class="string">'-'</span>,<span class="string">'color'</span>,col(i,:))]; <span class="keyword">end</span>
    <span class="keyword">if</span> nargout, ho = h; <span class="keyword">end</span>
    <span class="keyword">return</span>
<span class="keyword">end</span>     
<span class="keyword">if</span> size(X,2)~=3 && size(X,1)==3, X=X<span class="string">'; <span class="keyword">end</span>
[m,n] = size(X); <span class="keyword">if</span> n~=3, error('</span>X must be a mx3 array<span class="string">'), <span class="keyword">end</span>

<span class="comment">% non standard options</span>
ikw = find(cellfun('</span>isclass<span class="string">',options,'</span>char<span class="string">'));
<span class="keyword">if</span> ismember('</span>colrange<span class="string">',options(ikw))
    iopt = ikw(find(ismember(options(ikw),'</span>colrange<span class="string">'),1,'</span>first<span class="string">'));
    colrange = options{iopt+1};
    options = options(setdiff(1:length(options),[0 1]+iopt));
 <span class="keyword">else</span>
    colrange = [];
<span class="keyword">end</span>
ikw = find(cellfun('</span>isclass<span class="string">',options,'</span>char<span class="string">'));
<span class="keyword">if</span> ismember('</span>autocol<span class="string">',options(ikw))
    iopt = ikw(find(ismember(options(ikw),'</span>autocol<span class="string">'),1,'</span>first<span class="string">'));
    options = options(setdiff(1:length(options),iopt));
    autocol = true;
    <span class="keyword">if</span> isempty(colrange)
        collist = jet(m);
        colstart = 0;
    <span class="keyword">else</span>
        collist = jet(colrange(2));
        colstart = colrange(1);
    <span class="keyword">end</span>
<span class="keyword">else</span>
    autocol = false;
    collist = [];
<span class="keyword">end</span>

<span class="comment">% plots</span>
hold on
<span class="keyword">if</span> autocol && m>1
    h = zeros(m-1,1);
    <span class="keyword">for</span> i=1:m-1
        h(i) = plot3(X(i:i+1,1),X(i:i+1,2),X(i:i+1,3),options{:});
        set(h(i),'</span>color<span class="string">',collist(colstart+i,:),'</span>markerfacecolor<span class="string">',collist(colstart+i,:),'</span>markeredgecolor',collist(colstart+i,:))
    <span class="keyword">end</span>
<span class="keyword">else</span>
    h = plot3(X(:,1),X(:,2),X(:,3),options{:});
<span class="keyword">end</span>
<span class="keyword">if</span> nargout, ho = h; <span class="keyword">end</span></code></pre></div>
</div>
<div id='quiverc' class='doc-content' style='display: none;'>
<h1>Modified version of Quiver to plots velocity vectors as arrows</h1>
<p>with components (u,v) at the points (x,y) using the current colormap<br/>Bertrand Dano 3-3-03<br/>Copyright 1984-2002 The MathWorks, Inc.<br/>QUIVERC Quiver color plot.<br/>QUIVERC(X,Y,U,V) plots velocity vectors as arrows with components (u,v)<br/>at the points (x,y).  The matrices X,Y,U,V must all be the same size<br/>and contain corresponding position and velocity components (X and Y<br/>can also be vectors to specify a uniform grid).  QUIVER automatically<br/>scales the arrows to fit within the grid.</p>
<p>QUIVERC(U,V) plots velocity vectors at equally spaced points in<br/>the x-y plane.</p>
<p>QUIVERC(U,V,S) or QUIVER(X,Y,U,V,S) automatically scales the<br/>arrows to fit within the grid and then stretches them by S.  Use<br/>S=0 to plot the arrows without the automatic scaling.</p>
<p>QUIVERC(...,LINESPEC) uses the plot linestyle specified for<br/>the velocity vectors.  Any marker in LINESPEC is drawn at the base<br/>instead of an arrow on the tip.  Use a marker of &#x27;.&#x27; to specify<br/>no marker at all.  See PLOT for other possibilities.</p>
<p>QUIVERC(...,&#x27;filled&#x27;) fills any markers specified.</p>
<p>H = QUIVERC(...) returns a vector of line handles.</p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>[x,y] = meshgrid(-2:.2:2,-1:.15:1);
z = x .* exp(-x.^2 - y.^2); [px,py] = gradient(z,.2,.15);
contour(x,y,z), hold on
quiverc(x,y,px,py), hold off, axis image</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>See also FEATHER, QUIVER3, PLOT.
Clay M. Thompson 3-3-94
Copyright 1984-2002 The MathWorks, Inc.
$Revision: 5.21 $  $Date: 2002/06/05 20:05:16 $
-------------------------------------------------------------</code></pre>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"> <span class="keyword">function</span> hh = quiverc(varargin)
<span class="comment">% Modified version of Quiver to plots velocity vectors as arrows </span>
<span class="comment">% with components (u,v) at the points (x,y) using the current colormap </span>
<span class="comment">% Bertrand Dano 3-3-03</span>
<span class="comment">% Copyright 1984-2002 The MathWorks, Inc. </span>
<span class="comment">%QUIVERC Quiver color plot.</span>
<span class="comment">%   QUIVERC(X,Y,U,V) plots velocity vectors as arrows with components (u,v)</span>
<span class="comment">%   at the points (x,y).  The matrices X,Y,U,V must all be the same size</span>
<span class="comment">%   and contain corresponding position and velocity components (X and Y</span>
<span class="comment">%   can also be vectors to specify a uniform grid).  QUIVER automatically</span>
<span class="comment">%   scales the arrows to fit within the grid.</span>
<span class="comment">%</span>
<span class="comment">%   QUIVERC(U,V) plots velocity vectors at equally spaced points in</span>
<span class="comment">%   the x-y plane.</span>
<span class="comment">%</span>
<span class="comment">%   QUIVERC(U,V,S) or QUIVER(X,Y,U,V,S) automatically scales the </span>
<span class="comment">%   arrows to fit within the grid and then stretches them by S.  Use</span>
<span class="comment">%   S=0 to plot the arrows without the automatic scaling.</span>
<span class="comment">%</span>
<span class="comment">%   QUIVERC(...,LINESPEC) uses the plot linestyle specified <span class="keyword">for</span></span>
<span class="comment">%   the velocity vectors.  Any marker in LINESPEC is drawn at the base</span>
<span class="comment">%   instead of an arrow on the tip.  Use a marker of <span class="string">'.'</span> to specify</span>
<span class="comment">%   no marker at all.  See PLOT <span class="keyword">for</span> other possibilities.</span>
<span class="comment">%</span>
<span class="comment">%   QUIVERC(...,<span class="string">'filled'</span>) fills any markers specified.</span>
<span class="comment">%</span>
<span class="comment">%   H = QUIVERC(...) returns a vector of line handles.</span>
<span class="comment">%</span>
<span class="comment">%   Example:</span>
<span class="comment">%      [x,y] = meshgrid(-2:.2:2,-1:.15:1);</span>
<span class="comment">%      z = x .* exp(-x.^2 - y.^2); [px,py] = gradient(z,.2,.15);</span>
<span class="comment">%      contour(x,y,z), hold on</span>
<span class="comment">%      quiverc(x,y,px,py), hold off, axis image</span>
<span class="comment">%</span>
<span class="comment">%   See also FEATHER, QUIVER3, PLOT. </span>
<span class="comment">%   Clay M. Thompson 3-3-94</span>
<span class="comment">%   Copyright 1984-2002 The MathWorks, Inc. </span>
<span class="comment">%   $Revision: 5.21 $  $Date: 2002/06/05 20:05:16 $ </span>
<span class="comment">%-------------------------------------------------------------</span>
set(gca, <span class="string">'color'</span>, <span class="string">'blue'</span>);
<span class="comment">% Arrow head parameters</span>
alpha = 0.33; <span class="comment">% Size of arrow head relative to the length of the vector</span>
beta = 0.23;  <span class="comment">% Width of the base of the arrow head relative to the length</span>
autoscale = 1; <span class="comment">% Autoscale <span class="keyword">if</span> ~= 0 then scale by this.</span>
plotarrows = 1; <span class="comment">% Plot arrows</span>
sym = <span class="string">''</span>;
filled = 0;
ls = <span class="string">'-'</span>;
ms = <span class="string">''</span>;
col = <span class="string">''</span>;
lw=1;
nin = nargin;
<span class="comment">% Parse the string inputs</span>
<span class="keyword">while</span> isstr(varargin{nin}),
  vv = varargin{nin};
  <span class="keyword">if</span> ~isempty(vv) & strcmp(lower(vv(1)),<span class="string">'f'</span>)
    filled = 1;
    nin = nin-1;
  <span class="keyword">else</span>
    [l,c,m,msg] = colstyle(vv);
    <span class="keyword">if</span> ~isempty(msg), 
      error(sprintf(<span class="string">'Unknown option "<span class="comment">%s".'</span>,vv));</span>
    <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(l), ls = l; <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(c), col = c; <span class="keyword">end</span>
    <span class="keyword">if</span> ~isempty(m), ms = m; plotarrows = 0; <span class="keyword">end</span>
    <span class="keyword">if</span> isequal(m,<span class="string">'.'</span>), ms = <span class="string">''</span>; <span class="keyword">end</span> <span class="comment">% Don<span class="string">'t plot '</span>.<span class="string">'</span>
    nin = nin-1;
  <span class="keyword">end</span>
<span class="keyword">end</span>
error(nargchk(2,5,nin));
<span class="comment">% Check numeric input arguments</span>
<span class="keyword">if</span> nin<4, <span class="comment">% quiver(u,v) or quiver(u,v,s)</span>
  [msg,x,y,u,v] = xyzchk(varargin{1:2});
<span class="keyword">else</span>
  [msg,x,y,u,v] = xyzchk(varargin{1:4});
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(msg), error(msg); <span class="keyword">end</span>
<span class="keyword">if</span> nin==3 | nin==5, <span class="comment">% quiver(u,v,s) or quiver(x,y,u,v,s)</span>
  autoscale = varargin{nin};
<span class="keyword">end</span>
<span class="comment">% Scalar expand u,v</span>
<span class="keyword">if</span> prod(size(u))==1, u = u(ones(size(x))); <span class="keyword">end</span>
<span class="keyword">if</span> prod(size(v))==1, v = v(ones(size(u))); <span class="keyword">end</span>
<span class="keyword">if</span> autoscale,
  <span class="comment">% Base autoscale value on average spacing in the x and y</span>
  <span class="comment">% directions.  Estimate number of points in each direction as</span>
  <span class="comment">% either the size of the input arrays or the effective square</span>
  <span class="comment">% spacing <span class="keyword">if</span> x and y are vectors.</span>
  <span class="keyword">if</span> min(size(x))==1, n=sqrt(prod(size(x))); m=n; <span class="keyword">else</span> [m,n]=size(x); <span class="keyword">end</span>
  delx = diff([min(x(:)) max(x(:))])/n;
  dely = diff([min(y(:)) max(y(:))])/m;
  len = sqrt((u.^2 + v.^2)/(delx.^2 + dely.^2));
  autoscale = autoscale*0.9 / max(len(:));
  u = u*autoscale; v = v*autoscale;
<span class="keyword">end</span>
<span class="comment">%----------------------------------------------</span>
<span class="comment">% Define colormap </span>
vr=sqrt(u.^2+v.^2);
vrn=round(vr/max(vr(:))*64);
CC=colormap;
ax = newplot;
next = lower(get(ax,'</span>NextPlot<span class="string">'));
hold_state = ishold;
<span class="comment">%----------------------------------------------</span>
<span class="comment">% Make velocity vectors and plot them</span>
x = x(:).'</span>;y = y(:).<span class="string">';
u = u(:).'</span>;v = v(:).<span class="string">';
vrn=vrn(:).'</span>;
uu = [x;x+u;repmat(NaN,size(u))];
vv = [y;y+v;repmat(NaN,size(u))];
vrn1= [vrn;repmat(NaN,size(u));repmat(NaN,size(u))];
uui=uu(:);  vvi=vv(:);  vrn1=vrn1(:); imax=size(uui);
hold on
 <span class="keyword">for</span> i=  1:3:imax-1
    ii=int8(round(vrn1(i)));
    <span class="keyword">if</span> ii==0; ii=1; <span class="keyword">end</span>        
    c1= CC(ii,1);    c2= CC(ii,2);    c3= CC(ii,3);
    plot(uui(i:i+1),vvi(i:i+1),<span class="string">'linewidth'</span>,lw,<span class="string">'color'</span>,[c1 c2 c3]);
<span class="keyword">end</span>
<span class="comment">%----------------------------------------------</span>
<span class="comment">% Make arrow heads and plot them</span>
<span class="keyword">if</span> plotarrows,
 
  hu = [x+u-alpha*(u+beta*(v+eps));x+u; ...
        x+u-alpha*(u-beta*(v+eps));repmat(NaN,size(u))];
  hv = [y+v-alpha*(v-beta*(u+eps));y+v; ...
        y+v-alpha*(v+beta*(u+eps));repmat(NaN,size(v))];
  vrn2= [vrn;vrn;vrn;vrn];
 uui=hu(:);  vvi=hv(:);  vrn2=vrn2(:); imax=size(uui);
 <span class="keyword">for</span> i=  1:imax-1
    ii=int8(round(vrn2(i)));
    <span class="keyword">if</span> ii==0; ii=1; <span class="keyword">end</span>   
    c1= CC(ii,1);    c2= CC(ii,2);    c3= CC(ii,3);
    plot(uui(i:i+1),vvi(i:i+1),<span class="string">'linewidth'</span>,lw,<span class="string">'color'</span>,[c1 c2 c3]);
 <span class="keyword">end</span>
<span class="keyword">else</span>
  h2 = [];
<span class="keyword">end</span>
<span class="comment">%----------------------------------------------</span>
<span class="keyword">if</span> ~isempty(ms), <span class="comment">% Plot marker on base</span>
  hu = x; hv = y;
  hold on
  h3 = plot(hu(:),hv(:),[col ms]);
  <span class="keyword">if</span> filled, set(h3,<span class="string">'markerfacecolor'</span>,get(h1,<span class="string">'color'</span>)); <span class="keyword">end</span>
<span class="keyword">else</span>
  h3 = [];
<span class="keyword">end</span>
<span class="keyword">if</span> ~hold_state, hold off, view(2); set(ax,<span class="string">'NextPlot'</span>,next); <span class="keyword">end</span>
<span class="keyword">if</span> nargout>0, hh = [h1;h2;h3]; <span class="keyword">end</span>
<span class="comment">% set(gca, <span class="string">'color'</span>, [0 0 0],<span class="string">'Xcolor'</span>,<span class="string">'w'</span>,<span class="string">'Ycolor'</span>,<span class="string">'w'</span>);</span>
<span class="comment">% set(gcf, <span class="string">'color'</span>, [0 0 0]);</span>
<span class="comment">%set(gcf, <span class="string">'InvertHardCopy'</span>, <span class="string">'off'</span>);</span>
</code></pre></div>
</div>
<div id='rootdir' class='doc-content' style='display: none;'>
<h1>ROOTDIR extract the root of path using [last,root]=lastdir(pathstr)</h1>
<p>syntax: root = rootdir(pathstr)</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> rpath = rootdir(pathstr)
<span class="comment">%ROOTDIR extract the root of path using [last,root]=lastdir(pathstr)</span>
<span class="comment">%   syntax: root = rootdir(pathstr) </span>

<span class="comment">% MS 2.1 - 09/02/08 - INRA\Olivier  - rev.</span>
[tmp,rpath] = lastdir(pathstr);</code></pre></div>
</div>
<div id='selfVerletList' class='doc-content' style='display: none;'>
<h1>SELFVERLETLIST include self in the VerletList (required for density)</h1>
<p>Syntax: selfV = selfVerletList(V,typ)</p>
<h2>See also</h2>
<p><a href="#buildVerletList">buildVerletList</a>, <a href="#updateVerletList">updateVerletList</a>, <a href="#partitionVerletList">partitionVerletList</a>, <a href="#interp3SPHVerlet">interp3SPHVerlet</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> selfV = selfVerletList(V)
<span class="comment">% SELFVERLETLIST include self in the VerletList (required <span class="keyword">for</span> density)</span>
<span class="comment">%</span>
<span class="comment">%   Syntax: selfV = selfVerletList(V,typ)</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: buildVerletList, updateVerletList, partitionVerletList, interp3SPHVerlet</span>


<span class="comment">% MS 3.0 | 2023-04-02 | INRAE\Olivier.vitrac@agroparistech.fr | rev. 2023-05-17</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-04-02 RC</span>
<span class="comment">% 2023-05-16 fix arg check</span>
<span class="comment">% 2023-05-17 updated help</span>


<span class="comment">% CHeck arguments</span>
<span class="keyword">if</span> nargin<1, error(<span class="string">'one arguments is required:  selfV = selfVerletList(V)'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> ~iscell(V)
    error(<span class="string">'the supplied VerletList (<span class="comment">%d atoms) is invalid'</span>,length(V))</span>
<span class="keyword">end</span>

<span class="comment">% Main</span>
selfV = V;
<span class="keyword">for</span> i=1:n
    selfV{i}(1:<span class="keyword">end</span>+1) = [i;V{i}(:)]; <span class="comment">% instead of crude concatenation, keep column or row vector</span>
<span class="keyword">end</span>

</code></pre></div>
</div>
<div id='shapeSPH' class='doc-content' style='display: none;'>
<h1>SHAPESPH evaluate the solid shape matrix for each center according to Eq. 15 of Comput. Methods Appl. Mech. Engrg. 286 (2015) 87–106</h1>
<p>Syntax:<br/>out = shapeSPH(centers,gradW [, V, config, silent])</p>
<p>Inputs:<br/>centers : kxd coordinates of the kernel centers<br/>gradW : derivative kernel function @(r) &lt;-- use kernelSPH() to supply a vectorized kernel<br/>V : kx1 volume of the kernels (default=1)<br/>[] (empty matrix) or scalar value forces uniform volumes (default =1)<br/>config: structure with fields coding for Lamé parameters (not used directly by shapeSPH)<br/>lambda (default = 30 000 Pa)<br/>mu (default = 3000 Pa)<br/>forcesilent: flag to force silence mode (default = false)</p>
<p>Output: out structure with fields<br/>L : k x d^2 shape matrix, where reshape(L(i,:),[d d]) is the dxd matrix respectively to kernel i<br/>Linv : k x d^2 pseudo-inverse of L so that Linv * L = I<br/>correctedgradW : k x d corrected gradient for each kernel (used by defgradSPH)<br/>k,d,V,config : inputs<br/>engine : &#x27;shapeSPH&#x27;</p>
<p>Refer to Ganzenmuller (2015) for details: https://doi.org/10.1016/j.cma.2014.12.005<br/>~/han/biblio/Ganzenmuller2015-Hourglass_control_algorithm.pdf</p>
<h2>See also</h2>
<p><a href="#defgradSPH">defgradSPH</a>, <a href="#interp2SPH">interp2SPH</a>, <a href="#interp3SPH">interp3SPH</a>, <a href="#kernelSPH">kernelSPH</a>, <a href="#packSPH">packSPH</a></p>
<h2>See also</h2>
<p></p>
<h2>See also</h2>
<p></p>
<h2>See also</h2>
<p>2023-10-31, |, INRAE\Olivier, Vitrac, |, rev., 2023-11-01</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> out = shapeSPH(centers,gradW,V,config,forcesilent)
<span class="comment">% SHAPESPH evaluate the solid shape matrix <span class="keyword">for</span> each center according to Eq. 15 of Comput. Methods Appl. Mech. Engrg. 286 (2015) 87–106</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       out = shapeSPH(centers,gradW [, V, config, silent])</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%         centers : kxd coordinates of the kernel centers</span>
<span class="comment">%           gradW : derivative kernel <span class="keyword">function</span> @(r) <-- use kernelSPH() to supply a vectorized kernel</span>
<span class="comment">%               V : kx1 volume of the kernels (default=1)</span>
<span class="comment">%                   [] (empty matrix) or scalar value forces uniform volumes (default =1)</span>
<span class="comment">%           config: structure with fields coding <span class="keyword">for</span> Lamé parameters (not used directly by shapeSPH)</span>
<span class="comment">%                   lambda (default = 30 000 Pa)</span>
<span class="comment">%                   mu (default = 3000 Pa)</span>
<span class="comment">%      forcesilent: flag to force silence mode (default = false)</span>
<span class="comment">%</span>
<span class="comment">%   Output: out structure with fields</span>
<span class="comment">%               L : k x d^2 shape matrix, where reshape(L(i,:),[d d]) is the dxd matrix respectively to kernel i</span>
<span class="comment">%            Linv : k x d^2 pseudo-inverse of L so that Linv * L = I</span>
<span class="comment">%  correctedgradW : k x d corrected gradient <span class="keyword">for</span> each kernel (used by defgradSPH)</span>
<span class="comment">%    k,d,V,config : inputs</span>
<span class="comment">%          engine : <span class="string">'shapeSPH'</span></span>
<span class="comment">%</span>
<span class="comment">%   Refer to Ganzenmuller (2015) <span class="keyword">for</span> details: https://doi.org/10.1016/j.cma.2014.12.005</span>
<span class="comment">%   ~/han/biblio/Ganzenmuller2015-Hourglass_control_algorithm.pdf</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: defgradSPH, interp2SPH, interp3SPH, kernelSPH, packSPH</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%  </span>
<span class="comment">% 2023-10-31 | INRAE\Olivier Vitrac | rev. 2023-11-01</span>


<span class="comment">%{</span>
<span class="comment">% Example:</span>
r = 0.5;
X0 = packSPH(5,r);
X0(sqrt(sum((X0-mean(X0,1)).^2,2))>4*r,:) = [];
[xs,ys,zs] = sphere(100);

<span class="comment">% Translate spheres to close-packed positions</span>
figure, hold on
<span class="keyword">for</span> i = 1:size(X0, 1), surf(xs*r + X0(i,1), ys*r + X0(i,2), zs*r + X0(i,3),<span class="string">'FaceColor'</span>,rgb(<span class="string">'deepskyblue'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>); <span class="keyword">end</span>
lighting gouraud, camlight left, shading interp, axis equal, view(3)

<span class="comment">% deformation (vertical compression + shearing)</span>
Xc = mean(X0,1); Xmin = min(X0,[],1); Xmax = max(X0,[],1)

<span class="comment">% compression along z, with support at zmin, compression rate = 20%</span>
X = X0; X(:,3) = 0.8*(X(:,3)-Xmin(1,3)) + Xmin(1,3);
<span class="comment">% shearing 20% along y</span>
X(:,2) = X(:,2) + 0.2 * (Xmax(1,2)-Xmin(1,2)) * (X(:,3)-Xmin(1,3))/(Xmax(1,3)-Xmin(1,3));

<span class="comment">% plot</span>
figure, hold on
<span class="keyword">for</span> i = 1:size(X, 1), surf(xs*r + X(i,1), ys*r + X(i,2), zs*r + X(i,3),<span class="string">'FaceColor'</span>,rgb(<span class="string">'deepskyblue'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>); <span class="keyword">end</span>
lighting gouraud, camlight left, shading interp, axis equal, view(3)

<span class="comment">% displacement</span>
u = X-X0;
<span class="comment">% shape matrix</span>
gradW = kernelSPH(2*r,<span class="string">'lucyder'</span>,3);
shapeout = shapeSPH(X0,gradW)
defgradout = defgradSPH(u,shapeout)

<span class="comment">% visualization</span>
figure, hold on
scatter3(X(:,1),X(:,2),X(:,3),40,defgradout.G)
f= defgradout.f; fn=sqrt(sum(f.^2,2)); f = f./fn;
f90 = prctile(fn,90); fn(fn>f90) = f90; f = f .* f90;
quiver3(X(:,1),X(:,2),X(:,3),f(:,1),f(:,2),f(:,3))
<span class="comment">%}</span>

<span class="comment">%Revision history</span>
<span class="comment">% 2023-10-31 alpha version</span>
<span class="comment">% 2023-11-01 collect all outputs and inputs into out, replace all reshapes by vec2tensor</span>
<span class="comment">% 2023-11-13 fixes, RC, example</span>

<span class="comment">% Default Lamé parameters</span>
config_default = struct(...
    <span class="string">'lambda'</span>,3e4, ...first Lamé  parameter
    <span class="string">'mu'</span>,3e3 ... shear modulus (second Lamé parameterà
);

<span class="comment">%% arg check</span>
<span class="keyword">if</span> nargin<1, centers = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, gradW = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, V = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, config = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, forcesilent = []; <span class="keyword">end</span>
[k,d] = size(centers);
kv = length(V);
<span class="keyword">if</span> k==0, error(<span class="string">'please supply some centers'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> d>3, error(<span class="string">'3 dimensions maximum'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> kv==0, V=1;  kv=1; <span class="keyword">end</span>
<span class="keyword">if</span> kv==1, V = ones(k,1)*V; kv=k; <span class="keyword">end</span>
<span class="keyword">if</span> kv~=k, error(<span class="string">'the number of V values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,kv,k); <span class="keyword">end</span></span>
<span class="keyword">if</span> isempty(forcesilent), forcesilent = false; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(config), config = config_default; <span class="keyword">end</span>
<span class="keyword">for</span> f = fieldnames(config_default)<span class="string">'
    <span class="keyword">if</span> ~isfield(config,f{1}) || isempty(config.(f{1}))
        config.(f{1}) = config_default.(f{1});
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% initialization</span>
verbosity = (k>1e3) & ~forcesilent;
largek = k>200;
t0_ = clock; t1_=t0_; screen='</span><span class="string">'; 

<span class="comment">% coding linearized outer product (https://en.wikipedia.org/wiki/Outer_product)</span>
[left,right] = ndgrid(1:d,1:d);
outerproductindex = struct('</span>u<span class="string">',left(:),'</span>v<span class="string">',right(:));

<span class="comment">% vec2tensor: indices to convert a vector to a 2D tensor (faster than many reshapes)</span>
vec2tensor_reshape = reshape(1:d^2,d,d);
vec2tensor = @(x) x(vec2tensor_reshape);

<span class="comment">%% Output correction/shape matrix: L</span>
L = zeros(k,d*d,class(centers));
<span class="keyword">if</span> verbosity, dispf('</span>SHAPESPH calculate L correction matrix <span class="keyword">for</span> all <span class="comment">%d kernels (K) in %d dimensions...<span class="string">',k,d), <span class="keyword">end</span></span>
<span class="comment">% loop over all j <span class="keyword">for</span> summation</span>
<span class="keyword">for</span> j=1:k
    <span class="comment">% verbosity</span>
    <span class="keyword">if</span> verbosity
        <span class="keyword">if</span> largek
            t_ = clock; <span class="comment">%#ok<*CLOCK></span>
            <span class="keyword">if</span> mod(j,10)==0 || (etime(t_,t1_)>0.5) <span class="comment">%#ok<*DETIM> </span>
                t1_=t_;
                dt_ = etime(t_,t0_); done_ = j/k;
                screen = dispb(screen,'</span>[K<span class="comment">%d:%d] SHAPESPH | elapsed %0.1f s | done %0.1f %% | remaining %0.1f s<span class="string">', ...</span>
                               j,k,dt_,100*done_,(1/done_-1)*dt_);
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            dispf('</span>... SHAPESPH respectively to kernel <span class="comment">%d of %d<span class="string">',j,k);</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% Correction shape matrix (accumulation over j, but computation <span class="keyword">for</span> all i)</span>
    Xij = centers(j,:)-centers; <span class="comment">% j - all i</span>
    Xij_d = sqrt(dot(Xij,Xij,2));
    Xij_n = Xij ./ Xij_d;
    gradWi = gradW(Xij_n).*Xij_n;
    gradWi(j,:) = 0;
    L = L + V(j) * Xij(:,outerproductindex.u).*gradWi(:,outerproductindex.v); <span class="comment">% u and v are left and right indices with repetitions</span>

<span class="keyword">end</span>

<span class="comment">%% output Linv (pseudo-inverse of L)</span>
Linv = zeros(size(L),class(centers));
<span class="keyword">for</span> i = 1:k
    <span class="keyword">if</span> verbosity, screen = dispb(screen,'</span>[K<span class="comment">%d:%d] SHAPESPH, pseudoinverse...<span class="string">',i,k); <span class="keyword">end</span></span>
    tmp = pinv(vec2tensor(L(i,:)));
    Linv(i,:) = tmp(:)'</span>;
<span class="keyword">end</span>

<span class="comment">%% output correctedgradW (Eq. 14)</span>
correctedgradW = zeros(d,k,k);
<span class="keyword">for</span> j = 1:k
    Xij = centers(j,:)-centers; <span class="comment">% j - all i</span>
    Xij_d = sqrt(dot(Xij,Xij,2));
    Xij_n = Xij ./ Xij_d;
    gradWi = gradW(Xij_n).*Xij_n;
    gradWi(j,:) = 0; <span class="comment">% when i=j</span>
    <span class="keyword">for</span> i=1:k
        <span class="keyword">if</span> verbosity, screen = dispb(screen,<span class="string">'[K<span class="comment">%d:%d]-[K%d:%d] SHAPESPH, corrected gradient...'</span>,i,k,j,k); <span class="keyword">end</span></span>
        correctedgradW(:,i,j) = vec2tensor(Linv(i,:))*gradWi(i,:)<span class="string">';
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% verbosity</span>
<span class="keyword">if</span> verbosity
    dispb(screen,'</span>SHAPESPH <span class="comment">%d L matrix calculated in %0.4g s<span class="string">',k,etime(clock,t0_));</span>
<span class="keyword">end</span>

<span class="comment">% collect outputs</span>
out = struct('</span>k<span class="string">',k,'</span>d<span class="string">',d,'</span>V<span class="string">',V,'</span>config<span class="string">',config,...
    '</span>L<span class="string">',L,'</span>Linv<span class="string">',Linv,'</span>correctedgradW<span class="string">',correctedgradW,...
    '</span>engine<span class="string">','</span>shapeSPH<span class="string">','</span>forcesilent',forcesilent);</code></pre></div>
</div>
<div id='trajunwrap' class='doc-content' style='display: none;'>
<h1>UNWRAP Unwrap trajectorycoordinates in a periodic box</h1>
<p>USAGE: trajunwrapped = trajunwrap(traj, box, PBC)</p>
<p>This function unwraps the coordinates of atoms in a periodic simulation<br/>box after they have been wrapped due to periodic boundary conditions.<br/>It is designed to handle large sets of atom coordinates efficiently<br/>through vectorized operations. This function should be used when atoms<br/>undergo displacements that might cause them to cross periodic boundaries,<br/>ensuring that their continuous trajectory is accurately represented.</p>
<p>INPUTS:<br/>traj: nx2 or nx3 array coding for the initial coordinates of the n particles<br/>in 2D and 3D, respectively.<br/>box: 2x2 or 3x3 array coding for the dimensions of the periodic simulation box.<br/>The box spans along dimension i between box(i,1) and box(i,2).<br/>It is assumed that all X values initially lie within these box limits.<br/>PBC: 1x2 or 1x3 flags (PBC(j) is true if the jth dimension is periodic)</p>
<p>OUTPUTS:<br/>Xunwrapped: nx2 or nx3 array coding for the unwrapped coordinates of the particles,<br/>reflecting their continuous trajectory across periodic boundaries.</p>
<h2>See also</h2>
<p><a href="#PBCimagesshift">PBCimagesshift</a>, <a href="#PBCgrid">PBCgrid</a>, <a href="#PBCgridshift">PBCgridshift</a>, <a href="#PBCimages">PBCimages</a>, <a href="#PBCincell">PBCincell</a></p>
<h2>See also</h2>
<p></p>
<h2>See also</h2>
<p></p>
<h2>See also</h2>
<p>MS, 3.1, |, 2024-04-05, |, INRAE\olivier.vitrac@agroparistech.fr, |, rev.</p>
<h2>See also</h2>
<p>Revision, history:, 2024-04-05, -, Initial, version</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> trajunwrapped = trajunwrap(traj, box)
<span class="comment">%UNWRAP Unwrap trajectorycoordinates in a periodic box</span>
<span class="comment">%</span>
<span class="comment">%   USAGE: trajunwrapped = trajunwrap(traj, box, PBC)</span>
<span class="comment">%</span>
<span class="comment">%   This <span class="keyword">function</span> unwraps the coordinates of atoms in a periodic simulation</span>
<span class="comment">%   box after they have been wrapped due to periodic boundary conditions.</span>
<span class="comment">%   It is designed to handle large sets of atom coordinates efficiently</span>
<span class="comment">%   through vectorized operations. This <span class="keyword">function</span> should be used when atoms</span>
<span class="comment">%   undergo displacements that might cause them to cross periodic boundaries,</span>
<span class="comment">%   ensuring that their continuous trajectory is accurately represented.</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%      traj: nx2 or nx3 array coding <span class="keyword">for</span> the initial coordinates of the n particles</span>
<span class="comment">%          in 2D and 3D, respectively.</span>
<span class="comment">%       box: 2x2 or 3x3 array coding <span class="keyword">for</span> the dimensions of the periodic simulation box.</span>
<span class="comment">%            The box spans along dimension i between box(i,1) and box(i,2).</span>
<span class="comment">%            It is assumed that all X values initially lie within these box limits.</span>
<span class="comment">%       PBC: 1x2 or 1x3 flags (PBC(j) is true <span class="keyword">if</span> the jth dimension is periodic)</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%    Xunwrapped: nx2 or nx3 array coding <span class="keyword">for</span> the unwrapped coordinates of the particles,</span>
<span class="comment">%                reflecting their continuous trajectory across periodic boundaries.</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: PBCimagesshift, PBCgrid, PBCgridshift, PBCimages, PBCincell</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   MS 3.1 | 2024-04-05 | INRAE\olivier.vitrac@agroparistech.fr | rev.</span>
<span class="comment">%</span>
<span class="comment">%   Revision history:</span>
<span class="comment">%       2024-04-05 - Initial version</span>

<span class="comment">% Calculate the box lengths in each dimension</span>
boxLength = diff(box, 1, 2);

<span class="comment">% Calculate displacement as the difference between wrapped and initial positions</span>
displacement = [zeros(size(traj(1,:))) ; diff(traj,1,1) ];
    
<span class="comment">% Identify atoms that crossed the boundary and adjust the displacement accordingly</span>
<span class="keyword">for</span> j = 1:size(displacement, 2)
    positiveCross = displacement(:, j) > boxLength(j) / 2;
    negativeCross = displacement(:, j) < -boxLength(j) / 2;

    displacement(positiveCross, j) = displacement(positiveCross, j) - boxLength(j);
    displacement(negativeCross, j) = displacement(negativeCross, j) + boxLength(j);
<span class="keyword">end</span>

<span class="comment">% Adjust the positions to get the unwrapped coordinates</span>
trajunwrapped = traj(1,:) + cumsum(displacement,1);

<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='unwrapPBC' class='doc-content' style='display: none;'>
<h1>UNWRAPBC Unwrap atom coordinates in a periodic box</h1>
<p>USAGE: Xunwrapped = unwrapPBC(X, Pshift, box, PBC)</p>
<p>This function unwraps the coordinates of atoms in a periodic simulation<br/>box after they have been wrapped due to periodic boundary conditions.<br/>It is designed to handle large sets of atom coordinates efficiently<br/>through vectorized operations. This function should be used when atoms<br/>undergo displacements that might cause them to cross periodic boundaries,<br/>ensuring that their continuous trajectory is accurately represented.</p>
<p>INPUTS:<br/>X: nx2 or nx3 array coding for the initial coordinates of the n particles<br/>in 2D and 3D, respectively.<br/>Pshift: 1x2 or 1x3 array coding for the translation applied to the coordinates,<br/>which is subject to periodic wrapping.<br/>box: 2x2 or 3x3 array coding for the dimensions of the periodic simulation box.<br/>The box spans along dimension i between box(i,1) and box(i,2).<br/>It is assumed that all X values initially lie within these box limits.<br/>PBC: 1x2 or 1x3 flags (PBC(j) is true if the jth dimension is periodic)</p>
<p>OUTPUTS:<br/>Xunwrapped: nx2 or nx3 array coding for the unwrapped coordinates of the particles,<br/>reflecting their continuous trajectory across periodic boundaries.</p>
<h2>See also</h2>
<p><a href="#PBCimagesshift">PBCimagesshift</a>, <a href="#PBCgrid">PBCgrid</a>, <a href="#PBCgridshift">PBCgridshift</a>, <a href="#PBCimages">PBCimages</a>, <a href="#PBCincell">PBCincell</a></p>
<h2>See also</h2>
<p></p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>% Define initial positions, a periodic shift, and box dimensions
X = [1.0, 1.5; 0.5, 2.0]; % Example in 2D
Pshift = [0.5, 0.0]; % Shift right by 0.5 units
box = [0, 3; 0, 3]; % Square box with sides of length 3
Xunwrapped = unwrapPBC(X, Pshift, box);
disp(&#x27;Unwrapped Coordinates:&#x27;);
disp(Xunwrapped);</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>This function is part of a suite designed to facilitate simulations and
analyses using periodic boundary conditions. It relies on MATLAB&#x27;s ability
to perform array operations efficiently and is optimized for handling
large numbers of particles.</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>MS 3.1 | 2024-04-04 | INRAE\olivier.vitrac@agroparistech.fr | rev.</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>Revision history:
2024-04-04 - Initial version</code></pre>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> Xunwrapped = unwrapPBC(X, Pshift, box, PBC)
<span class="comment">%UNWRAPBC Unwrap atom coordinates in a periodic box</span>
<span class="comment">%</span>
<span class="comment">%   USAGE: Xunwrapped = unwrapPBC(X, Pshift, box, PBC)</span>
<span class="comment">%</span>
<span class="comment">%   This <span class="keyword">function</span> unwraps the coordinates of atoms in a periodic simulation</span>
<span class="comment">%   box after they have been wrapped due to periodic boundary conditions.</span>
<span class="comment">%   It is designed to handle large sets of atom coordinates efficiently</span>
<span class="comment">%   through vectorized operations. This <span class="keyword">function</span> should be used when atoms</span>
<span class="comment">%   undergo displacements that might cause them to cross periodic boundaries,</span>
<span class="comment">%   ensuring that their continuous trajectory is accurately represented.</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%       X: nx2 or nx3 array coding <span class="keyword">for</span> the initial coordinates of the n particles</span>
<span class="comment">%          in 2D and 3D, respectively.</span>
<span class="comment">%    Pshift: 1x2 or 1x3 array coding <span class="keyword">for</span> the translation applied to the coordinates,</span>
<span class="comment">%            which is subject to periodic wrapping.</span>
<span class="comment">%       box: 2x2 or 3x3 array coding <span class="keyword">for</span> the dimensions of the periodic simulation box.</span>
<span class="comment">%            The box spans along dimension i between box(i,1) and box(i,2).</span>
<span class="comment">%            It is assumed that all X values initially lie within these box limits.</span>
<span class="comment">%       PBC: 1x2 or 1x3 flags (PBC(j) is true <span class="keyword">if</span> the jth dimension is periodic)</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%    Xunwrapped: nx2 or nx3 array coding <span class="keyword">for</span> the unwrapped coordinates of the particles,</span>
<span class="comment">%                reflecting their continuous trajectory across periodic boundaries.</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: PBCimagesshift, PBCgrid, PBCgridshift, PBCimages, PBCincell</span>
<span class="comment">%</span>
<span class="comment">%   Example:</span>
<span class="comment">%       % Define initial positions, a periodic shift, and box dimensions</span>
<span class="comment">%       X = [1.0, 1.5; 0.5, 2.0]; % Example in 2D</span>
<span class="comment">%       Pshift = [0.5, 0.0]; % Shift right by 0.5 units</span>
<span class="comment">%       box = [0, 3; 0, 3]; % Square box with sides of length 3</span>
<span class="comment">%       Xunwrapped = unwrapPBC(X, Pshift, box);</span>
<span class="comment">%       disp(<span class="string">'Unwrapped Coordinates:'</span>);</span>
<span class="comment">%       disp(Xunwrapped);</span>
<span class="comment">%</span>
<span class="comment">%   This <span class="keyword">function</span> is part of a suite designed to facilitate simulations and</span>
<span class="comment">%   analyses using periodic boundary conditions. It relies on MATLAB's ability</span>
<span class="comment">%   to perform array operations efficiently and is optimized <span class="keyword">for</span> handling</span>
<span class="comment">%   large numbers of particles.</span>
<span class="comment">%</span>
<span class="comment">%   MS 3.1 | 2024-04-04 | INRAE\olivier.vitrac@agroparistech.fr | rev.</span>
<span class="comment">%</span>
<span class="comment">%   Revision history:</span>
<span class="comment">%       2024-04-04 - Initial version</span>


    <span class="comment">% Apply the periodic shift and wrapping</span>
    <span class="comment">%[Xwrapped, ~] = PBCimagesshift(X, Pshift, box);</span>
    Xwrapped = PBCincell(X+Pshift, box, PBC);
    
    <span class="comment">% Calculate the box lengths in each dimension</span>
    boxLength = diff(box, 1, 2);
    
    <span class="comment">% Calculate displacement as the difference between wrapped and initial positions</span>
    displacement = Xwrapped - X;
    
    <span class="comment">% Identify atoms that crossed the boundary and adjust the displacement accordingly</span>
    <span class="keyword">for</span> j = 1:size(X, 2)
        positiveCross = displacement(:, j) > boxLength(j) / 2;
        negativeCross = displacement(:, j) < -boxLength(j) / 2;
        
        displacement(positiveCross, j) = displacement(positiveCross, j) - boxLength(j);
        displacement(negativeCross, j) = displacement(negativeCross, j) + boxLength(j);
    <span class="keyword">end</span>
    
    <span class="comment">% Adjust the positions to get the unwrapped coordinates</span>
    Xunwrapped = X + displacement;

<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='updateVerletList' class='doc-content' style='display: none;'>
<h1>UPDATEVERLETLIST update the verlet list if the number of sampled modified neighbors exceed a threshold</h1>
<p>Syntax: [verletList,configout] = updateVerletList(X, previousVerletList, config)</p>
<p>Inputs:<br/>X: n x 3 updated X<br/>previousVerletList: n x 1 cell array corresponding to the previous list<br/>config: output of buildVerletList<br/>config.tolerance set the tolerance<br/>config.nsamples set the number of samples</p>
<p>Outputs:<br/>verletList: n x 1 cell coding for the verletList<br/>config: configuration structure to be used with updateVerletList()</p>
<h2>See also</h2>
<p><a href="#buildVerletList">buildVerletList</a>, <a href="#partitionVerletList">partitionVerletList</a>, <a href="#selfVerletList">selfVerletList</a>, <a href="#interp3SPHVerlet">interp3SPHVerlet</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [verletList,configout] = updateVerletList(X, previousVerletList, config)
<span class="comment">%UPDATEVERLETLIST update the verlet list <span class="keyword">if</span> the number of sampled modified neighbors exceed a threshold</span>
<span class="comment">%</span>
<span class="comment">%   Syntax: [verletList,configout] = updateVerletList(X, previousVerletList, config)</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%                   X: n x 3 updated X</span>
<span class="comment">%  previousVerletList: n x 1 cell array corresponding to the previous list</span>
<span class="comment">%              config: output of buildVerletList</span>
<span class="comment">%                   config.tolerance set the tolerance</span>
<span class="comment">%                   config.nsamples set the number of samples</span>
<span class="comment">%</span>
<span class="comment">%   Outputs:</span>
<span class="comment">%         verletList: n x 1 cell coding <span class="keyword">for</span> the verletList</span>
<span class="comment">%             config: configuration structure to be used with updateVerletList()</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: buildVerletList, partitionVerletList, selfVerletList, interp3SPHVerlet</span>


<span class="comment">% MS 3.0 | 2023-04-01 | INRAE\Olivier.vitrac@agroparistech.fr | rev. 2023-05-17</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-05-17 updated help</span>



<span class="comment">%% Check arguments</span>
<span class="keyword">if</span> nargin<3, error(<span class="string">'three arguments are reqiured: [verletList,configout] = updateVerletList(X, previousVerletList, config)'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> istable(X), X = table2array(X(:,{<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>})); <span class="keyword">end</span>
[n,d] = size(X); <span class="comment">% number of particless</span>
typ = class(X);  <span class="comment">% class of coordinates</span>
<span class="keyword">if</span> ~iscell(previousVerletList) || length(previousVerletList)~=n
    error(<span class="string">'the supplied VerletList (<span class="comment">%d atoms) is not compatible with X (% atoms)'</span>,length(previousVerletList),n)</span>
<span class="keyword">end</span>
<span class="keyword">if</span> isstruct(config)
    <span class="keyword">if</span> isfield(config,<span class="string">'engine'</span>) && strcmp(config.engine,<span class="string">'buildVerletList'</span>)
        <span class="keyword">if</span> (config.natoms ~= n) || (config.dimensions~=d)
            error(<span class="string">'the number of atoms (<span class="comment">%d) or/and dimensions (%d) have changed, expected %d x %d'</span>,...</span>
                n,d,config.natoms,config.dimensions)
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        error(<span class="string">'unrecognized configuration structure'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>
nsamples = min(config.nsamples,n/10);

<span class="comment">%% check the stability of the previousVerletList</span>
cutoff2 = config.cutoff^2;
stable = true;
i = 0;
<span class="keyword">while</span> (i < nsamples) && stable
    i = i + 1;
    isample = unidrnd(n);
    Xsample = X(isample,:);
    jneigh = find( sum((X-Xsample).^2,2) <= cutoff2 );
    stable = length(intersect(jneigh,previousVerletList{isample})) > ...
        ((1-config.tolerance)*length(previousVerletList{isample}));
<span class="keyword">end</span>

<span class="comment">%% take decision</span>
<span class="keyword">if</span> stable
    verletList = previousVerletList;
<span class="keyword">else</span>
    <span class="keyword">if</span> config.verbose, dispf(<span class="string">'The current VerletList is obsolete'</span>), <span class="keyword">end</span>
    verletList = buildVerletList(X, config.cutoff, config.sorton, config.nblocks, config.verbose);
<span class="keyword">end</span>

<span class="comment">% output</span>
<span class="keyword">if</span> nargout>1, configout = config; <span class="keyword">end</span>
</code></pre></div>
</div>
<div id='wallstress' class='doc-content' style='display: none;'>
<h1>WALLSTRESS first template to perform post-treatment of Billy&#x27; dump files (3D viscosimeter)</h1>
<p>INRAE\Olivier Vitrac - rev. 2023-03-31<br/>INRAE\William Jenkinson     2023-04-03</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% WALLSTRESS first template to perform post-treatment of Billy<span class="string">' dump files (3D viscosimeter)</span>
<span class="comment">% INRAE\Olivier Vitrac - rev. 2023-03-31</span>
<span class="comment">% INRAE\William Jenkinson     2023-04-03</span>

<span class="comment">% Dependencies (not included in MS, at least not yet)</span>
<span class="comment">%   lamdumpread2() version 2023-03-23 or later</span>
<span class="comment">%   buildVerletList() version 2023-03-25 or later (recommended version 2023-03-31 to get the memory efficient block search)</span>
<span class="comment">%   forceHertz() version 2023-03-26 or later</span>
<span class="comment">%</span>
<span class="comment">% note: be sure Olivier/INRA/Codes/MS is in your Path (MS=Molecular Studio)</span>

<span class="comment">% Revision history</span>
<span class="comment">% 2023-03-23 RC, early design based on dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_Hertzdiv100_lite</span>
<span class="comment">% 2023-03-24 first interaction with Billy</span>
<span class="comment">%            the file <span class="keyword">for</span> design was shifted to dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_Hertzdiv10_lite</span>
<span class="comment">% 2023-03-25 implementation of a full Verletlist, automatic identification of fluid-solid contacts without using any</span>
<span class="comment">%            particular topology, the template is fully operational and used to plot the number of contacts with time</span>
<span class="comment">% 2023-03-26 first implementation of Hertz contacts (to be validated and extended)</span>
<span class="comment">%            better figure management (previous results can be reloaded)</span>
<span class="comment">% 2023-03-30 minor fixes to adapt the new buildVerletList (block)</span>
<span class="comment">% 2023-03-31 increase cutoff from 1.5*dmin to 1.7 dmin to select all fluid and wall atoms correctly (it was finally not a bug)</span>

<span class="comment">%% read datafile</span>

<span class="comment">% path definitions (please add your machine name by typing localname in your command window)</span>
<span class="keyword">switch</span> localname
    <span class="keyword">case</span> '</span>LP-OLIVIER2022<span class="string">'
        local = '</span>C:\Users\olivi\OneDrive - agroparistech.fr\Billy\ProductionSandbox_toOV_23-03-2023<span class="string">'; 
    <span class="keyword">case</span> '</span>LX-Willy2021<span class="string">'
        local = '</span>/Data/billy/Results/Viscosimeter_SMJ_V6/ProductionSandbox_toOV_23-03-2023<span class="string">';
    <span class="keyword">case</span> '</span>YOUR MACHINE<span class="string">'
        local = '</span>it is the path where the dump file is located, results are stored at the sample place<span class="string">';
    <span class="keyword">otherwise</span>
        error('</span>add a <span class="keyword">case</span> with your machine name, which is <span class="string">''</span><span class="comment">%s<span class="string">''</span><span class="string">',localname)</span>
<span class="keyword">end</span>
<span class="comment">%datafile = '</span>dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_Hertzdiv100_lite<span class="string">';</span>
<span class="comment">%datafile = '</span>dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_Hertzdiv10_lite<span class="string">';</span>
datafile = '</span>dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_Hertzdiv10_centrebulk<span class="string">';
fulldatafile = fullfile(local,datafile); <span class="comment">% concatenate path (local) and data filename</span>
X = lamdumpread2(fulldatafile); <span class="comment">% be sure the last version of lamdumpread2() is in the same folder as this script</span>

<span class="comment">% result file (to store results)</span>
resultfile = fullfile(local,['</span>RESULT_<span class="string">' datafile '</span>.mat<span class="string">']);

<span class="comment">%% Region-based definitions:  Wall and fluid regions</span>
<span class="comment">% note that the interface between regions is defined from pair-distances</span>
types = struct('</span>wall<span class="string">',3,'</span>fluid<span class="string">',1);
X.ATOMS.iswall = X.ATOMS.type==types.wall;  <span class="comment">% add the column iswall to the table X.ATOMS</span>
X.ATOMS.isfluid = X.ATOMS.type==types.fluid;<span class="comment">% add the column isfluid to the table X.ATOMS</span>
X.ATOMS.isundef = ~X.ATOMS.iswall & ~X.ATOMS.isfluid; <span class="comment">% add the column isundef to the table X.ATOMS</span>

<span class="comment">%% Control frame</span>
<span class="comment">% note that the data are stored in data.ATOMS, which is a table with named colums allowing hybrid indexing</span>
nsteps = length(X.TIMESTEP);
icurrenttime = ceil(0.5*nsteps); <span class="comment">% index of the control frame (used to set basic definitions before more advanced interpretation)</span>
currenttime = X.TIMESTEP(icurrenttime);
rawframe = X.ATOMS(X.ATOMS.TIMESTEP==currenttime,{'</span>id<span class="string">','</span>type<span class="string">','</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">','</span>vx<span class="string">','</span>vy<span class="string">','</span>vz<span class="string">','</span>iswall<span class="string">','</span>isfluid<span class="string">','</span>isundef<span class="string">'});
frame = table2array(rawframe(:,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'})); <span class="comment">% generate an array of coordinates</span>
framev = table2array(rawframe(:,{'</span>vx<span class="string">','</span>vy<span class="string">','</span>vz<span class="string">'})); <span class="comment">% generate an array with the velocities</span>

<span class="comment">% Build the main Verlet list (<span class="keyword">for</span> all particles)</span>
<span class="comment">% V use the natural indexing instead of rawframe.id</span>
cutoff = 60e-6; <span class="comment">% empty or NaN value will force an automatic estimation of cutoff</span>
[V,cutoff,dmin,configVerletList] = buildVerletList(frame,cutoff); <span class="comment">% cutoff can be omitted</span>

<span class="comment">% Build the secondary Verlet lists (highly vectorized code)</span>
<span class="comment">% V1 the neighbors of type 2 (fluid) <span class="keyword">for</span> type 1 atoms (1..n1)</span>
<span class="comment">% V2 the neighbors of type 1 (wall) <span class="keyword">for</span> type 2 atoms (1..n2)</span>
idx1 = find(rawframe.type==3); n1 = length(idx1); <span class="comment">% indices of the wall particles in the current frame</span>
idx2 = find(rawframe.type==1); n2 = length(idx2); <span class="comment">% indices of the fluid particles in the current frame</span>
V1 = cellfun(@(v) v(rawframe.type(v)==1),V(idx1),'</span>UniformOutput<span class="string">',false); <span class="comment">% Verlet list <span class="keyword">for</span> type 1 in contact with type 2</span>
V2 = cellfun(@(v) v(rawframe.type(v)==3),V(idx2),'</span>UniformOutput<span class="string">',false); <span class="comment">% Verlet list <span class="keyword">for</span> type 1 in contact with type 2</span>
<span class="comment">% corresponding distances d1,d2</span>
<span class="comment">% some distances can be empty <span class="keyword">for</span> d2</span>
d1 = arrayfun(@(i) pdist2(frame(idx1(i),:),frame(V1{i},:)),(1:n1)'</span>,<span class="string">'UniformOutput'</span>,false); <span class="comment">% evaluate the distance <span class="keyword">for</span> each idx1(i)</span>
d2 = arrayfun(@(i) pdist2(frame(idx2(i),:),frame(V2{i},:)),(1:n2)<span class="string">','</span>UniformOutput<span class="string">',false); <span class="comment">% evaluate the distance <span class="keyword">for</span> each idx2(i)</span>
d1min = cellfun(@min,d1,'</span>UniformOutput<span class="string">',false); <span class="comment">% minimum distance <span class="keyword">for</span> each idx1()</span>
[d1min{cellfun(@isempty,d1)}] = deal(NaN);
d1min = cat(1,d1min{:}); 
d2min = cellfun(@min,d2,'</span>UniformOutput<span class="string">',false); <span class="comment">% minimum distance <span class="keyword">for</span> each idx2()</span>
[d2min{cellfun(@isempty,d2)}] = deal(NaN); <span class="comment">% populate empty distances with NaN</span>
d2min = cat(1,d2min{:}); <span class="comment">% we collect all now all distances (since the fluid is moving with respect with the wall)</span>

<span class="comment">% Identify beads of type 1 (wall) directly in contact with fluids</span>
<span class="comment">% this method is general and relies only on pair distances</span>
<span class="comment">% the term "contact" is general (vincinity) not a "real" contact as set later</span>
iswallcontact = d1min < 1.7 * dmin;  <span class="comment">% condition <span class="keyword">for</span> a wall particle to be considered possibly in contact with the fluid</span>
isfluidcontact = ~isnan(d2min);      <span class="comment">% the condition is less restrictive <span class="keyword">for</span> the fluid, based on the cutoff distance</span>
V1contact = V1(iswallcontact);       <span class="comment">% "contact" Verlet list corresponding to V1</span>
V2contact = V2(isfluidcontact);      <span class="comment">% "contact" Verlet list corresponding to V2</span>
iwallcontact = idx1(iswallcontact);
ifluidcontact = unique(cat(2,V1contact{:})); <span class="comment">% within cutoff</span>

<span class="comment">% control plot</span>
<span class="comment">% one color is assigned to each phase</span>
<span class="comment">% symbols are filled <span class="keyword">if</span> they are included in the contact Verlet list</span>
<span class="comment">% type figure, rgb() to list all available colors</span>
colors = struct('</span>wall<span class="string">',rgb('</span>Crimson<span class="string">'),'</span>fluid<span class="string">',rgb('</span>DeepSkyBlue<span class="string">'),'</span>none<span class="string">','</span>None<span class="string">');
figure, hold on
plot3D(frame(rawframe.isundef,:),'</span>ko<span class="string">');
plot3D(frame(rawframe.iswall,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.wall,'</span>MarkerFaceColor<span class="string">',colors.none);
plot3D(frame(iwallcontact,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.none,'</span>MarkerFaceColor<span class="string">',colors.wall);
plot3D(frame(rawframe.isfluid,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.fluid,'</span>MarkerFaceColor<span class="string">',colors.none);
plot3D(frame(ifluidcontact,:),'</span>o<span class="string">','</span>MarkerEdgeColor<span class="string">',colors.none,'</span>MarkerFaceColor<span class="string">',colors.fluid);
axis equal, axis tight, view(3)

<span class="comment">%% [1] INTERPRETATION of Lanshoff foces on the reference frame</span>
R = 0.5*0.001/48; <span class="comment">% radius of the particle (please, be very accurate)</span>
h = 2*R;
Vlandhsoff = buildVerletList(frame,1.2*h);
configLandshoff = struct( ...
   '</span>gradkernel<span class="string">', kernelSPH(cutoff,'</span>lucyder<span class="string">',3),...
            '</span>h<span class="string">', h,...
           '</span>c0<span class="string">', 10,...
           '</span>q1<span class="string">', 1,...
          '</span>rho<span class="string">', 1000 ...
    );
[FLandshoff,nLandshoff] = forceLandshoff(frame,framev,Vlandhsoff,configLandshoff);
FLandshoff_vec = FLandshoff .* nLandshoff;
figure, hold on
<span class="comment">% quiver plot <span class="keyword">for</span> the fluid</span>
hqfluid = quiver3( ...
    frame(rawframe.isfluid,1), ...
    frame(rawframe.isfluid,2), ...
    frame(rawframe.isfluid,3), ...
    FLandshoff_vec(rawframe.isfluid,1), ...
    FLandshoff_vec(rawframe.isfluid,2), ...
    FLandshoff_vec(rawframe.isfluid,3), ...
    5 ...
    ); set(hqfluid,'</span>color<span class="string">',colors.fluid)
<span class="comment">% quiver plot <span class="keyword">for</span> the wall</span>
hqwall = quiver3( ...
    frame(rawframe.iswall,1), ...
    frame(rawframe.iswall,2), ...
    frame(rawframe.iswall,3), ...
    FLandshoff_vec(rawframe.iswall,1), ...
    FLandshoff_vec(rawframe.iswall,2), ...
    FLandshoff_vec(rawframe.iswall,3), ...
    5 ...
    ); set(hqwall,'</span>color<span class="string">',colors.wall)

axis tight, axis equal, view(3)

[
mean(FLandshoff_vec(rawframe.isfluid,:),1)
mean(FLandshoff_vec(rawframe.iswall,:),1)
]

<span class="comment">%% [2] similar analysis of Landshoff with all frames</span>
<span class="comment">% incorporate easy syntaxes developed on April 1, 2023 and later</span>
<span class="comment">% the simulation set is too small to conclude anything (not enough layers)</span>
[Vlandhsoff,~,~,configVerletLandshoff] = buildVerletList(frame,1.2*h,false,[],false);
FLandshoff = zeros(nsteps,3);
[t_,t__] = deal(clock); <span class="comment">%#ok<*CLOCK> </span>
screen = '</span><span class="string">';
<span class="keyword">for</span> icurrenttime = 1:nsteps
    currenttime = X.TIMESTEP(icurrenttime);
    <span class="comment">% --- some display, to encourage the user to be patient</span>
    <span class="keyword">if</span> mod(icurrenttime,5)
        <span class="keyword">if</span> etime(clock,t__)>2 <span class="comment">%#ok<*DETIM></span>
            t__ = clock; dt = etime(t__,t_); done = 100*(icurrenttime-1)/nsteps;
            screen = dispb(screen,'</span>[<span class="comment">%d/%d] Landshoff interpretation [ done %0.3g %% | elapsed %0.4g s | remaining %0.4g s ] ...<span class="string">', ...</span>
                icurrenttime,nsteps,done,dt,dt*(100/done-1));
        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">% --- <span class="keyword">end</span> of display</span>
    R0 = X.ATOMS(X.ATOMS.TIMESTEP==currenttime,{'</span>id<span class="string">','</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">','</span>vx<span class="string">','</span>vy<span class="string">','</span>vz<span class="string">','</span>isfluid<span class="string">'}); <span class="comment">% raw data <span class="keyword">for</span> the current frame</span>
    [Vlandhsoff,configVerletLandshoff] = updateVerletList(R0,Vlandhsoff,configVerletLandshoff);
    tmpF = forceLandshoff(R0,[],Vlandhsoff,configLandshoff,false);
    FLandshoff(icurrenttime,:) = sum(tmpF(R0.isfluid,:),1);
<span class="keyword">end</span>

<span class="comment">%% [3] Analysis of Hertz contacts with similarly as Landshoff forces (procedure implemented on 2023-04-02)</span>
[VHertz,~,~,configVerletHertz] = buildVerletList(frame,1.2*h,false,[],false);
R = 0.5*0.001/48; <span class="comment">% radius of the particle (please, be very accurate)</span>
<span class="comment">% config setup</span>
E = 2e5 ; <span class="comment">% ref:2e6, Hertzdiv10:2e5, Hertzdiv100:2e4</span>
Hertzconfig = struct('</span>name<span class="string">',{'</span>wall<span class="string">','</span>fluid<span class="string">'},'</span>R<span class="string">',R,'</span>E<span class="string">',E); <span class="comment">% entries are duplicated <span class="keyword">if</span> not mentioned</span>
FHertz = zeros(nsteps,3);
[t_,t__] = deal(clock); <span class="comment">%#ok<*CLOCK> </span>
screen = '</span><span class="string">';
<span class="keyword">for</span> icurrenttime = 1:nsteps
    currenttime = X.TIMESTEP(icurrenttime);
        R0 = X.ATOMS(X.ATOMS.TIMESTEP==currenttime,{'</span>id<span class="string">','</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">','</span>type<span class="string">','</span>isfluid<span class="string">','</span>iswall<span class="string">'}); <span class="comment">% raw data <span class="keyword">for</span> the current frame</span>
        <span class="comment">% --- some display, to encourage the user to be patient</span>
        <span class="keyword">if</span> mod(icurrenttime,5)
            <span class="keyword">if</span> etime(clock,t__)>2 <span class="comment">%#ok<*DETIM></span>
                t__ = clock; dt = etime(t__,t_); done = 100*(icurrenttime-1)/nsteps;
                screen = dispb(screen,'</span>[<span class="comment">%d/%d] Hertz contact interpretation [ done %0.3g %% | elapsed %0.4g s | remaining %0.4g s ] ...<span class="string">', ...</span>
                    icurrenttime,nsteps,done,dt,dt*(100/done-1));
            <span class="keyword">end</span>
        <span class="keyword">end</span> <span class="comment">% --- <span class="keyword">end</span> of display</span>
        [VHertz,configVerletHertz] = updateVerletList(R0,VHertz,configVerletHertz);
        partVHertz = partitionVerletList(VHertz,R0); <span class="comment">% partition the Verletlist</span>
        tmpF = forceHertz(R0,VHertz,Hertzconfig,false);
        FHertz(icurrenttime,:) = sum(tmpF(R0.isfluid,:),1); <span class="comment">% fluid only</span>
<span class="keyword">end</span>


<span class="comment">%% [4] Analysis of the number of contacts and Hertz forces (first analysis without using the new tools)</span>
<span class="comment">% count the number of fluid beads in contact with wall (within 2*R)</span>
R = 0.5*0.001/48; <span class="comment">% radius of the particle (please, be very accurate)</span>
dbond = 2*R; <span class="comment">% bond = link between 2 atoms</span>
wall_id  = rawframe.id(iwallcontact);   <span class="comment">% extract the ids matching the contact condition in the reference frame</span>
fluid_id = rawframe.id(ifluidcontact);  <span class="comment">% idem <span class="keyword">for</span> the fluid particles within the contact Verlet list</span>
<span class="comment">% config setup</span>
E = 2e5 ; <span class="comment">% ref:2e6, Hertzdiv10:2e5, Hertzdiv100:2e4</span>
Hertzconfig = struct('</span>name<span class="string">',{'</span>wall<span class="string">','</span>fluid<span class="string">'},'</span>R<span class="string">',R,'</span>E<span class="string">',E); <span class="comment">% entries are duplicated <span class="keyword">if</span> not mentioned</span>

<span class="comment">% prepare to calculate pair distances between different beads</span>
pairdist = @(X,Y) triu(pdist2(X,Y),0); <span class="comment">% note that the diagonal is included here (since X and Y are different)</span>
ncontacts = zeros(nsteps,1);
FHertz = zeros(nsteps,1);
[t_,t__] = deal(clock); <span class="comment">%#ok<*CLOCK> </span>
screen = '</span><span class="string">';
<span class="keyword">for</span> icurrenttime = 1:nsteps
    currenttime = X.TIMESTEP(icurrenttime);
    <span class="comment">% --- some display, to encourage the user to be patient</span>
    <span class="keyword">if</span> mod(icurrenttime,5)
        <span class="keyword">if</span> etime(clock,t__)>2 <span class="comment">%#ok<*DETIM></span>
            t__ = clock; dt = etime(t__,t_); done = 100*(icurrenttime-1)/nsteps;
            screen = dispb(screen,'</span>[<span class="comment">%d/%d] interpretation [ done %0.3g %% | elapsed %0.3g s | remaining %0.3g s ] ...<span class="string">', ...</span>
                icurrenttime,nsteps,done,dt,dt*(100/done-1));
        <span class="keyword">end</span>
    <span class="keyword">end</span> <span class="comment">% --- <span class="keyword">end</span> of display</span>
    R0 = X.ATOMS(X.ATOMS.TIMESTEP==currenttime,{'</span>id<span class="string">','</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'}); <span class="comment">% raw data <span class="keyword">for</span> the current frame</span>
    [~,idx_wallcontact] = intersect(R0.id,wall_id);   <span class="comment">% index of wall particles (in contact) in the current frame</span>
    [~,idx_fluidcontact] = intersect(R0.id,fluid_id); <span class="comment">% index of fluid particles in the contact Verle tlist</span>
    Xw = table2array(R0(idx_wallcontact,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'})); <span class="comment">% coordinates of wall particles</span>
    Xf = table2array(R0(idx_fluidcontact,{'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'})); <span class="comment">% coordinates of fluid particles</span>
    <span class="comment">% count contacts</span>
    dxf = pairdist(Xw,Xf); <span class="comment">% calculate all pair distances between the two type of particles (with the builtin pdist2())</span>
    dcontacts = find(dxf>0 & dxf<dbond); <span class="comment">% contacts defined by a positive distance greater than dbond</span>
    ncontacts(icurrenttime) = length(dcontacts); <span class="comment">% store the number of contacts</span>
    <span class="comment">% Hertz contact forces (note that the number contact could be also extracted from non-zero forces)</span>
    Ftmp = forceHertzAB(Xw,Xf,Hertzconfig,false);  <span class="comment">% calculate all contact forces, false prevents display</span>
    FHertz(icurrenttime) = sum(Ftmp(:,1)); <span class="comment">% sum forces along x</span>
<span class="keyword">end</span>

<span class="comment">% save the data to enable a refresh of the figure without restarting this block</span>
timesteps = X.TIMESTEP;
save(resultfile,'</span>datafile<span class="string">','</span>FHertz<span class="string">','</span>ncontacts<span class="string">','</span>timesteps<span class="string">','</span>Hertzconfig<span class="string">')
dispf('</span>Results saved (<span class="comment">%s):<span class="string">',datafile), fileinfo(resultfile)</span>

<span class="comment">%% PLots and figure management</span>

<span class="comment">% reload the data</span>
<span class="keyword">if</span> exist(resultfile,'</span>file<span class="string">'), load(resultfile), <span class="keyword">end</span>

<span class="comment">% plot number of contacts vs. time</span>
contactfigure = figure;
formatfig(contactfigure,'</span>figname<span class="string">',['</span>NumberContact<span class="string">' datafile],'</span>PaperPosition<span class="string">',[1.5000    9.2937   18.0000   11.1125])
plot(timesteps,ncontacts,'</span>linewidth<span class="string">',0.5,'</span>Color<span class="string">',rgb('</span>Crimson<span class="string">'))
formatax(gca,'</span>fontsize<span class="string">',14)
xlabel('</span>time (units)<span class="string">','</span>fontsize<span class="string">',16)
ylabel('</span>number of contacts<span class="string">','</span>fontsize<span class="string">',16)
wtitle = textwrap({'</span>\bfdump file:\rm<span class="string">';datafile},40);
title(regexprep(wtitle,'</span>_<span class="string">','</span>\\_<span class="string">'),'</span>fontsize<span class="string">',10)

<span class="comment">% plot number of Hertz projection along x vs. time</span>
hertzfigure = figure;
formatfig(hertzfigure,'</span>figname<span class="string">',['</span>HertzContact<span class="string">' datafile],'</span>PaperPosition<span class="string">',[1.5000    9.2937   18.0000   11.1125])
plot(timesteps,FHertz,'</span>linewidth<span class="string">',0.5,'</span>Color<span class="string">',rgb('</span>Teal<span class="string">'))
mu = 0.01; L = 0.001; A = 2*L^2; U = 0.001 ;
yline = -mu*A*U/L;  <span class="comment">% Replace with the y-value of your horizontal line</span>
line(get(gca,'</span>xlim<span class="string">'), [yline yline], '</span>Color<span class="string">', '</span>r<span class="string">', '</span>LineStyle<span class="string">', '</span>--<span class="string">')
text(20000, yline*1.1, '</span>system-wise viscous force<span class="string">', '</span>HorizontalAlignment<span class="string">', '</span>center<span class="string">')
formatax(gca,'</span>fontsize<span class="string">',14)
xlabel('</span>time (units)<span class="string">','</span>fontsize<span class="string">',16)
ylabel('</span>Hertz forces along x (N)<span class="string">','</span>fontsize<span class="string">',16)
wtitle = textwrap({'</span>\bfdump file:\rm<span class="string">';datafile},40);
title(regexprep(wtitle,'</span>_<span class="string">','</span>\\_<span class="string">'),'</span>fontsize<span class="string">',10)

<span class="comment">% save images in all valid formats (including Matlab one, the data can be extracted with this format)</span>
<span class="comment">% filenames are identical to the dump file with the proper extension: fig, pdf, png</span>
<span class="keyword">for</span> myfig = [contactfigure,hertzfigure] <span class="comment">% loop over all figures to print</span>
    figure(myfig)
    saveas(gcf,fullfile(local,[get(gcf,'</span>filename<span class="string">') '</span>.fig<span class="string">']),'</span>fig<span class="string">') <span class="comment">% fig can be open without restarting the code</span>
    print_pdf(600,[get(gcf,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],local,'</span>nocheck<span class="string">') <span class="comment">% PDF 600 dpi</span>
    print_png(600,[get(gcf,'</span>filename<span class="string">') '</span>.png<span class="string">'],local,'</span>',0,0,0)  <span class="comment">% PNG 600 dpi</span>
<span class="keyword">end</span>

</code></pre></div>
</div>
<div id='yao_initialization' class='doc-content' style='display: none;'>
<h1>YAO_INITIALIZATION load data corresponding to tframe</h1>
<p>Typical usages<br/>Xframe = yao_initialization(tframe)<br/>[Xframe,details] = yao_initialization(tframe)</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> [Xframe,details] = yao_initialization(tframe)
<span class="comment">%YAO_INITIALIZATION load data corresponding to tframe</span>
<span class="comment">%   Typical usages</span>
<span class="comment">%      Xframe = yao_initialization(tframe)</span>
<span class="comment">%      [Xframe,details] = yao_initialization(tframe)</span>

<span class="comment">% INRAE\Olivier Vitrac, Yao Liu</span>

<span class="comment">% 2024-05-03 first version</span>

<span class="keyword">if</span> nargin<1, tframe = []; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(tframe), error(<span class="string">'set tframe first'</span>), <span class="keyword">end</span>

<span class="comment">%% Definitions</span>
t0_ = clock;

<span class="comment">%% check folders</span>
outputfolder = fullfile(pwd,<span class="string">'preproduction'</span>);
savefolder = fullfile(pwd,<span class="string">'results'</span>);
prefetchfolder = fullfile(pwd,<span class="string">'prefetch'</span>);
<span class="keyword">if</span> ~exist(outputfolder,<span class="string">'dir'</span>), mkdir(outputfolder); <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(prefetchfolder,<span class="string">'dir'</span>), mkdir(prefetchfolder); <span class="keyword">end</span>
<span class="keyword">if</span> ~exist(savefolder,<span class="string">'dir'</span>), mkdir(savefolder); <span class="keyword">end</span>

<span class="comment">% Anonymous functions</span>
prefetchvar = @(varargin) fullfile(prefetchfolder,sprintf(<span class="string">'t<span class="comment">%0.4f_%s.mat'</span>,tframe,varargin{1}));</span>
isprefetch = @(varargin) exist(prefetchvar(varargin{1}),<span class="string">'file'</span>) && ~RESETPREFETCH;
dispsection = @(s) dispf(<span class="string">'\n<span class="comment">%s\ntframe=%0.4g s \t[  %s  ]   elapsed time: %4g s\n%s'</span>,repmat(<span class="string">'*'</span>,1,120),tframe,regexprep(upper(s),<span class="string">'.'</span>,<span class="string">'$0 '</span>),etime(clock,t0_),repmat(<span class="string">'*'</span>,1,120)); %#ok<DETIM></span>
fighandle = @(id) formatfig(figure,<span class="string">'figname'</span>,sprintf(<span class="string">'t<span class="comment">%0.3g_%s'</span>,tframe,id));</span>
printhandle = @(hfig) print_png(300,fullfile(outputfolder,[get(hfig,<span class="string">'filename'</span>) <span class="string">'.png'</span>]),<span class="string">''</span>,<span class="string">''</span>,0,0,0);

<span class="comment">%% path and metadata</span>
dispsection(<span class="string">'INITIALIZATION'</span>)
originalroot = <span class="string">'/media/olivi/T7 Shield/Thomazo_V2'</span>;
<span class="keyword">if</span> exist(originalroot,<span class="string">'dir'</span>)
    root = originalroot;
    rootlocal = fullfile(pwd,<span class="string">'smalldumps'</span>);
    copymode = true;
<span class="keyword">else</span>
    root = fullfile(pwd,<span class="string">'smalldumps'</span>);
    copymode = false;
<span class="keyword">end</span>

simfolder = ...
    struct(...
    <span class="string">'A1'</span>,struct(<span class="string">'artificial'</span>,...
<span class="string">'Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz'</span>,...
    <span class="string">'Morris'</span>,...
<span class="string">'Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle.tar.gz'</span> ...
                ),...
    <span class="string">'A2'</span>,struct(<span class="string">'artificial'</span>,...
<span class="string">'./Production/numericalViscosimeter_reference_ulsphBulk_hertzBoundary/dump.ulsphBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_2.tar.gz'</span> ...
    ),...
    <span class="string">'B1'</span>,struct(<span class="string">'Morris'</span>,...
<span class="string">'./Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft.tar.gz'</span> ...
    ),...
    <span class="string">'B2'</span>,struct(<span class="string">'Morris'</span>,...
<span class="string">'Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_1.tar.gz'</span> ...
    ),...
    <span class="string">'B3'</span>,struct(<span class="string">'Morris'</span>,...
<span class="string">'/Production/numericalViscosimeter_reference_morrisBulk_hertzBoundary/dump.morrisBulk_hertzBoundary_referenceParameterExponent+1_with1SuspendedParticle_soft_2_3.tar.gz'</span> ...
    ) ...
    );

<span class="comment">% selection (not change it <span class="keyword">if</span> you do not have the full dataset/hard disk attached to your system)</span>
config = <span class="string">'A1'</span>;
viscosity = <span class="string">'Morris'</span>;
sourcefolder= fullfile(root,rootdir(simfolder.(config).(viscosity)));
sourcefile = regexprep(lastdir(simfolder.(config).(viscosity)),<span class="string">'.tar.gz$'</span>,<span class="string">''</span>);
dumpfile = fullfile(sourcefolder,sourcefile);
dispf(<span class="string">'config: <span class="comment">%s | viscosity: %s | source: %s'</span>,config,viscosity,dumpfile)</span>

<span class="comment">%% extract information</span>
dispsection(<span class="string">'OVERVIEW'</span>)
X0 = lamdumpread2(dumpfile); <span class="comment">% first frame</span>
natoms = X0.NUMBER;
timesteps = X0.TIMESTEPS;
X1 = lamdumpread2(dumpfile,<span class="string">'usesplit'</span>,[],timesteps(2));
dt = (X1.TIME-X0.TIME)/(timesteps(2)-timesteps(1)); <span class="comment">% integration time step</span>
times = double(timesteps * dt); <span class="comment">% in seconds </span>
atomtypes = unique(X0.ATOMS.type);
ntimesteps = length(timesteps);
T = X0.ATOMS.type;
natomspertype = arrayfun(@(t) length(find(T==t)),atomtypes);
[~,ind] = sort(natomspertype,<span class="string">'descend'</span>);
<span class="comment">% Thomazo simulation details</span>
fluidtype  = ind(1);
pillartype = ind(2);
walltype   = ind(3);
spheretype = ind(4);
<span class="comment">% coordinate system</span>
coords = {<span class="string">'z'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>}; <span class="comment">% to match Thomazo<span class="string">'s movies</span>
vcoords = cellfun(@(c) sprintf('</span>v<span class="comment">%s<span class="string">',c),coords,'</span>UniformOutput<span class="string">',false);</span>
icoords = cellfun(@(c) find(ismember({'</span>x<span class="string">','</span>y<span class="string">','</span>z<span class="string">'},c)),coords); <span class="comment">%<- use this index <span class="keyword">for</span> BOX</span>
<span class="comment">% Simulation parameters</span>
<span class="comment">% Billy choose a reference density of 900 kg/m3 <span class="keyword">for</span> a physical density of 1000 kg/m3</span>
<span class="comment">% Viscosity: 0.13 Pa.s</span>
mbead = 4.38e-12; <span class="comment">% kg</span>
rho = 1000; <span class="comment">% kg / m3 (density of the fluid)</span>
Vbead = mbead/rho;
dispf('</span>SUMMARY: natoms: <span class="comment">%d | dt: %0.3g s | rho: %0.4g<span class="string">',natoms,dt,rho)</span>

<span class="comment">%% load the frame closest to simulation time: tframe</span>
<span class="comment">% with the mini dataset, are available:</span>
<span class="comment">% 0.30s 0.40s 0.45s 0.50s 0.55s 0.60s 0.65s 0.70s 0.75s 0.80s 0.85s 0.90s 0.95s 1.00s 1.05s 1.10s </span>
<span class="comment">% tframelist = [0.3 0.4 0.45:0.05:1.10]; % verysmalldumps</span>
tframelist = 0.0:0.01:1.2; <span class="comment">% updated time frames</span>
<span class="keyword">if</span> ~exist('</span>tframe<span class="string">','</span>var<span class="string">')
    tframe = 0.85; <span class="comment">%0.55; % s <-------------------- select time here</span>
<span class="keyword">else</span>
    tframe = tframelist(nearestpoint(tframe,tframelist)); <span class="comment">% restrict to existing tframes</span>
<span class="keyword">end</span>
iframe = nearestpoint(tframe,times); <span class="comment">% closest index</span>
Xframe = lamdumpread2(dumpfile,'</span>usesplit<span class="string">',[],timesteps(iframe));

<span class="comment">%% Implement isfluid, issphere, iswall, ispillar</span>
Xframe.ATOMS.isfluid = Xframe.ATOMS.type==fluidtype;
Xframe.ATOMS.ispillar = Xframe.ATOMS.type==pillartype;
Xframe.ATOMS.issphere = Xframe.ATOMS.type==spheretype;
Xframe.ATOMS.iswall = Xframe.ATOMS.type==walltype;
Xframe.ATOMS.issolid = Xframe.ATOMS.type==spheretype | Xframe.ATOMS.type==pillartype;

<span class="comment">%% second output</span>
<span class="keyword">if</span> nargout>1
details = struct(...
    '</span>tframe<span class="string">',tframe,...
    '</span>iframe<span class="string">',iframe,...
    '</span>dt<span class="string">',dt,...
    '</span>ntimesteps<span class="string">',ntimesteps,...
    '</span>coords<span class="string">',{coords},...
    '</span>vcoords<span class="string">',{vcoords},...
    '</span>type<span class="string">',struct('</span>fluid<span class="string">',fluidtype,'</span>pillar<span class="string">',pillartype,'</span>wall<span class="string">',walltype,'</span>sphere<span class="string">',spheretype),...
    '</span>mbead<span class="string">',mbead,...
    '</span>Vbead<span class="string">',Vbead,...
    '</span>box<span class="string">',Xframe.BOX(icoords,:),...
    '</span>boxsize<span class="string">',diff(Xframe.BOX(icoords,:),1,2),...
    '</span>dumpfile',dumpfile ...
    );
<span class="keyword">end</span></code></pre></div>
</div>
<div id='sphereObjective' class='doc-content' style='display: none;'>
<h1>error = imgd/max(imgd,[],&#x27;all&#x27;) - sphereProfile/max(sphereProfile,[],&#x27;all&#x27;);</h1>
<p>error = sum(error(:).^2);</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% Script to manage results</span>
<span class="comment">% 20240517Yao</span>
<span class="comment">% INRAE\Olivier Vitrac</span>

<span class="comment">% Comments</span>
<span class="comment">% Series 1 difficult to inteerpret but principles are there between frames 1à-14</span>
<span class="comment">% Series 2 nothing changed</span>
<span class="comment">% Series 3 </span>

<span class="comment">%% Definitions</span>
<span class="keyword">switch</span> localname
    <span class="keyword">case</span> <span class="string">'WS-OLIVIER2023'</span>
        root = <span class="string">'C:\Users\olivi\Seafile\Han\Experiments\Yao'</span>;
    <span class="keyword">otherwise</span>
        root = pwd;
<span class="keyword">end</span>
result_folder = <span class="string">'20240517Yao'</span>;
local = fullfile(root,result_folder);
<span class="keyword">if</span> ~exist(local,<span class="string">'dir'</span>), error(<span class="string">'the folder '</span><span class="string">'<span class="comment">%s'</span><span class="string">' does not exist'</span>), <span class="keyword">end</span></span>

<span class="comment">%% load data</span>
<span class="keyword">if</span> ~exist(<span class="string">'raw'</span>,<span class="string">'var'</span>)
    f = explore(<span class="string">'*.tif'</span>,local,[],<span class="string">'abbreviate'</span>);
    nf = length(f);
    raw = repmat(struct(<span class="string">'im'</span>,[],<span class="string">'finfo'</span>,[],<span class="string">'iminfo'</span>,[]),nf,1);
    screen = <span class="string">''</span>;
    <span class="keyword">for</span> i = 1:nf
        raw(i).iminfo = imfinfo(fullfile(f(i).path,f(i).file));
        raw(i).finfo = f(i);
        npages = length(raw(i).iminfo);
        raw(i).im = zeros(raw(i).iminfo(1).Height,raw(i).iminfo(1).Width,raw(i).iminfo(1).BitDepth/8,npages,<span class="string">'uint8'</span>);
        <span class="keyword">for</span> j = 1:npages
            screen = dispb(screen,<span class="string">'[im: <span class="comment">%d/%d] load frame %d of %d'</span>,i,nf,j,npages);</span>
            raw(i).im(:,:,:,j) = imread(fullfile(f(i).path,f(i).file),j);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%% Series 1 </span>
<span class="comment">% control</span>
i = 1;
selection = 10:14;
figure, montage(raw(i).im(:,:,:,selection))
title(sprintf(<span class="string">'Series <span class="comment">%d | frame %d-->%d'</span>,i,selection(1),selection(<span class="keyword">end</span>)))</span>

close all
<span class="keyword">for</span> j=selection
    figure, imagesc(double(raw(i).im(:,:,2,j))), colorbar
    title(sprintf(<span class="string">'Series <span class="comment">%d | frame %d'</span>,i,j))</span>
<span class="keyword">end</span>

<span class="comment">% select the image</span>
<span class="comment">% Summary of results</span>
<span class="comment">% frame 10:  r=49.94  r=52.55 (metric = 0.63)</span>
<span class="comment">% frame 11:  r=61.78  r=33.85 (metric = 0.33)</span>
<span class="comment">% frame 12:  r=59.02  r=54.27 (metric = 0.63)</span>
<span class="comment">% frame 13:  r=59.02  r=54.27 (metric = 0.40)</span>
<span class="comment">% frame 14:  r=68.6 r=59.27 (metric = 0.86)</span>
nselection = length(selection);
nr = 301; cutoff = 2;
R = repmat(struct(<span class="string">'Icrop'</span>,[],<span class="string">'xmin'</span>,NaN,<span class="string">'xmax'</span>,NaN,<span class="string">'ymin'</span>,NaN,<span class="string">'ymax'</span>,NaN,...
    <span class="string">'r0'</span>,NaN,<span class="string">'r1'</span>,NaN,<span class="string">'metric'</span>,NaN,<span class="string">'r'</span>,[],<span class="string">'intensity'</span>,zeros(nr-1,1)),nselection,1);
<span class="keyword">for</span> iselection = 1:nselection
    I = raw(i).im(:,:,2,selection(iselection));      <span class="comment">% to show it: figure, imshow(imadjust(rescale(I)))</span>
    <span class="comment">% find the sphere (assuming only one)</span>
    filtwidth = 2;                          <span class="comment">% default filter width</span>
    found = false; niter = 0;
    <span class="keyword">while</span> ~found && niter<5
        niter = niter +1;                   <span class="comment">% next iteration</span>
        filtwidth = 2 * filtwidth;          <span class="comment">% double filter width</span>
        If_ = imgaussfilt(I, filtwidth);    <span class="comment">% Apply Gaussian filter</span>
        [centers,radii,metric] = imfindcircles(If_,round([0.3 2]*sqrt(numel(I))/6));
        found = ~isempty(centers);
    <span class="keyword">end</span>
    [~,ibest] = max(metric);
    dispf(<span class="string">'frame <span class="comment">%d: %d particles have been found'</span>,selection(iselection),length(radii));</span>
    dispf(<span class="string">'\t best candidate has a radius of <span class="comment">%0.4g pixels (metric=%0.4g)'</span>,radii(ibest),metric(ibest));</span>
    If2 = imgaussfilt(I, 2);            <span class="comment">% Apply Gaussian filter</span>
    [Gmag, Gdir] = imgradient(If2);     <span class="comment">% Calculate gradient, figure, imagesc(Gmag)</span>
    objectiveFunction = @(params) sphereObjective(params, Gmag);      <span class="comment">% Define objective <span class="keyword">function</span> <span class="keyword">for</span> optimization</span>
    initialGuess = [centers(ibest,:), radii(ibest)]; <span class="comment">% Initial guess <span class="keyword">for</span> [center_x, center_y, radius]</span>
    OptOptions = optimoptions(@lsqnonlin, <span class="string">'Display'</span>, <span class="string">'iter'</span>,<span class="string">'MaxFunctionEvaluations'</span>,1000);      <span class="comment">% Optimization options</span>
    paramsOptimized = lsqnonlin(objectiveFunction, initialGuess, [], [], OptOptions); <span class="comment">% Perform optimization</span>
    <span class="comment">% paramsOptimized = fminsearch(objectiveFunction, initialGuess); % Perform optimization</span>
    <span class="comment">% Extract optimized center and radius</span>
    center_x = paramsOptimized(1);
    center_y = paramsOptimized(2);
    radius = paramsOptimized(3);
    dispf(<span class="string">'\t optimized search found <span class="comment">%0.4g pixels'</span>,radius);</span>
    <span class="comment">% Display results</span>
    figure, hold on, imshow(imadjust(rescale(I)));
    viscircles([center_x, center_y], radius, <span class="string">'EdgeColor'</span>, <span class="string">'r'</span>);
    title(sprintf(<span class="string">'Series <span class="comment">%d, Frame %d of %d (%d): Detected Sphere'</span>,i, iselection, nselection, selection(iselection)));</span>
    drawnow
    <span class="comment">% store results</span>
    R(iselection).r0 = radii(ibest);
    R(iselection).r1 = radius;
    R(iselection).metric = metric;
    r01 = max(R(iselection).r0,R(iselection).r1);
    R(iselection).xmin = max(1,floor(center_x-cutoff*r01));
    R(iselection).ymin = max(1,floor(center_y-cutoff*r01));
    R(iselection).xmax = min(size(I,2),ceil(center_x+cutoff*r01));
    R(iselection).ymax = min(size(I,1),ceil(center_y+cutoff*r01));
    R(iselection).Icrop = double(I(R(iselection).ymin:R(iselection).ymax,R(iselection).xmin:R(iselection).xmax));
    R(iselection).r = linspace(0,cutoff*r01,nr)<span class="string">';
    [X_,Y_] = meshgrid(R(iselection).xmin:R(iselection).xmax,R(iselection).ymin:R(iselection).ymax);
    R_ = sqrt((X_-center_x).^2 + (Y_-center_y).^2);
    <span class="keyword">for</span> ir = 1:nr-1
        <span class="keyword">if</span> ir<nr-1
            ok = (R_>=R(iselection).r(ir)) & (R_<R(iselection).r(ir+1));
        <span class="keyword">else</span>
            ok = (R_>=R(iselection).r(ir)) & (R_<=R(iselection).r(ir+1));
        <span class="keyword">end</span>
        R(iselection).intensity(ir) = mean(R(iselection).Icrop(ok),'</span>all<span class="string">');
    <span class="keyword">end</span>
    R(iselection).intensity(isnan(R(iselection).intensity))=0;
<span class="keyword">end</span>

figure, hold on
<span class="keyword">for</span> i=1:length(R)
    stairs(R(i).r(1:<span class="keyword">end</span>-1)+diff(R(i).r)/2,R(i).intensity)
<span class="keyword">end</span>

<span class="comment">%% Series 3</span>
i = 3;
selection = 56:68;
close all
figure, montage(raw(i).im(:,:,:,selection))
title(sprintf('</span>Series <span class="comment">%d | frame %d-->%d<span class="string">',i,selection(1),selection(<span class="keyword">end</span>)))</span>
<span class="keyword">for</span> j=selection
    I = raw(i).im(:,:,2,j);
    If = imgaussfilt(I,5);
    figure, imagesc(double(If)), colorbar
    title(sprintf('</span>Series <span class="comment">%d | frame %d<span class="string">',i,j))</span>
<span class="keyword">end</span>


nselection = length(selection);
nr = 301; cutoff = 2;
R = repmat(struct('</span>Icrop<span class="string">',[],'</span>xmin<span class="string">',NaN,'</span>xmax<span class="string">',NaN,'</span>ymin<span class="string">',NaN,'</span>ymax<span class="string">',NaN,...
    '</span>r0<span class="string">',NaN,'</span>r1<span class="string">',NaN,'</span>metric<span class="string">',NaN,'</span>r<span class="string">',[],'</span>intensity<span class="string">',zeros(nr-1,1)),nselection,1);
<span class="keyword">for</span> iselection = 1:nselection
    I = raw(i).im(:,:,2,selection(iselection));      <span class="comment">% to show it: figure, imshow(imadjust(rescale(I)))</span>
    <span class="comment">% find the sphere (assuming only one)</span>
    filtwidth = 2;                          <span class="comment">% default filter width</span>
    found = false; niter = 0;
    <span class="keyword">while</span> ~found && niter<5
        niter = niter +1;                   <span class="comment">% next iteration</span>
        filtwidth = 2 * filtwidth;          <span class="comment">% double filter width</span>
        If_ = imgaussfilt(I, filtwidth);    <span class="comment">% Apply Gaussian filter</span>
        [centers,radii,metric] = imfindcircles(If_,round([0.3 2]*sqrt(numel(I))/6));
        found = ~isempty(centers);
    <span class="keyword">end</span>
    [~,ibest] = max(metric);
    dispf('</span>frame <span class="comment">%d: %d particles have been found<span class="string">',selection(iselection),length(radii));</span>
    dispf('</span>\t best candidate has a radius of <span class="comment">%0.4g pixels (metric=%0.4g)<span class="string">',radii(ibest),metric(ibest));</span>
    If2 = imgaussfilt(I, 2);            <span class="comment">% Apply Gaussian filter</span>
    [Gmag, Gdir] = imgradient(If2);     <span class="comment">% Calculate gradient, figure, imagesc(Gmag)</span>
    objectiveFunction = @(params) sphereObjective(params, Gmag);      <span class="comment">% Define objective <span class="keyword">function</span> <span class="keyword">for</span> optimization</span>
    initialGuess = [centers(ibest,:), radii(ibest)]; <span class="comment">% Initial guess <span class="keyword">for</span> [center_x, center_y, radius]</span>
    OptOptions = optimoptions(@lsqnonlin, '</span>Display<span class="string">', '</span>iter<span class="string">','</span>MaxFunctionEvaluations<span class="string">',1000);      <span class="comment">% Optimization options</span>
    paramsOptimized = lsqnonlin(objectiveFunction, initialGuess, [], [], OptOptions); <span class="comment">% Perform optimization</span>
    <span class="comment">% paramsOptimized = fminsearch(objectiveFunction, initialGuess); % Perform optimization</span>
    <span class="comment">% Extract optimized center and radius</span>
    center_x = paramsOptimized(1);
    center_y = paramsOptimized(2);
    radius = paramsOptimized(3);
    dispf('</span>\t optimized search found <span class="comment">%0.4g pixels<span class="string">',radius);</span>
    <span class="comment">% Display results</span>
    figure, hold on, imshow(imadjust(rescale(I)));
    viscircles([center_x, center_y], radius, '</span>EdgeColor<span class="string">', '</span>r<span class="string">');
    title(sprintf('</span>Series <span class="comment">%d, Frame %d of %d (%d): Detected Sphere<span class="string">',i, iselection, nselection, selection(iselection)));</span>
    drawnow
    <span class="comment">% store results</span>
    R(iselection).r0 = radii(ibest);
    R(iselection).r1 = radius;
    R(iselection).metric = metric;
    r01 = max(R(iselection).r0,R(iselection).r1);
    R(iselection).xmin = max(1,floor(center_x-cutoff*r01));
    R(iselection).ymin = max(1,floor(center_y-cutoff*r01));
    R(iselection).xmax = min(size(I,2),ceil(center_x+cutoff*r01));
    R(iselection).ymax = min(size(I,1),ceil(center_y+cutoff*r01));
    R(iselection).Icrop = double(I(R(iselection).ymin:R(iselection).ymax,R(iselection).xmin:R(iselection).xmax));
    R(iselection).r = linspace(0,cutoff*r01,nr)'</span>;
    [X_,Y_] = meshgrid(R(iselection).xmin:R(iselection).xmax,R(iselection).ymin:R(iselection).ymax);
    R_ = sqrt((X_-center_x).^2 + (Y_-center_y).^2);
    <span class="keyword">for</span> ir = 1:nr-1
        <span class="keyword">if</span> ir<nr-1
            ok = (R_>=R(iselection).r(ir)) & (R_<R(iselection).r(ir+1));
        <span class="keyword">else</span>
            ok = (R_>=R(iselection).r(ir)) & (R_<=R(iselection).r(ir+1));
        <span class="keyword">end</span>
        R(iselection).intensity(ir) = mean(R(iselection).Icrop(ok),<span class="string">'all'</span>);
    <span class="keyword">end</span>
    R(iselection).intensity(isnan(R(iselection).intensity))=0;
<span class="keyword">end</span>

figure, hold on
<span class="keyword">for</span> i=1:length(R)
    stairs(R(i).r(1:<span class="keyword">end</span>-1)+diff(R(i).r)/2,R(i).intensity)
<span class="keyword">end</span>

<span class="comment">%% =================================================================</span>
<span class="comment">%   the last part of the code is to define functions in a script</span>
<span class="comment">%</span>
<span class="comment">% =================================================================</span>

<span class="keyword">function</span> criterion = sphereObjective(params, img)
    sgrad = 8;
    center_x = params(1);
    center_y = params(2);
    radius = params(3);
    [X, Y] = meshgrid(1:size(img,2), 1:size(img,1));
    distFromCenter = sqrt((X - center_x).^2 + (Y - center_y).^2);
    sphereProfile = exp(-((distFromCenter - radius).^2)/(2*(radius/sgrad)^2)); <span class="comment">% Example halo profile</span>
    xmin = max(1,floor(center_x - radius - 3 * sgrad));
    xmax = min(size(img,1),ceil(center_x + radius + 3 * sgrad));
    ymin = max(1,floor(center_y - radius - 3 * sgrad));
    ymax = min(size(img,1),ceil(center_y + radius + 3 * sgrad));

    imgd = double(img(ymin:ymax,xmin:xmax));
    <span class="comment">%error = imgd/max(imgd,[],<span class="string">'all'</span>) - sphereProfile/max(sphereProfile,[],<span class="string">'all'</span>);</span>
    <span class="comment">%error = sum(error(:).^2);</span>
    localerr = imgd/prctile(imgd(:),95) - sphereProfile(ymin:ymax,xmin:xmax);
    criterion = zeros(size(img));
    criterion(ymin:ymax,xmin:xmax) = localerr;
    criterion = criterion(:);
<span class="keyword">end</span></code></pre></div>
</div>
<div id='yao_stress' class='doc-content' style='display: none;'>
<h1>Template for Yao</h1>
<h2>Authors</h2>
<p>INRAE\Olivier Vitrac, INRAE\Yao Liu</p>
<h2>Authors</h2>
<p>The work is based on the simulation of Billy (publication so-called pizza2, and series Thomazo_v2)<br/>The dataset is accessible on lab PCs via yao_initialization(tframe)<br/>tframe should be chosen among 0.11:0.01:1.11 (0.11, 0.12, 0.13, ... 1.11 s)<br/>The data corresponding to tframe and additional details are accessible via<br/>[Xframe,details] = yao_initialization(tframe)<br/>Due to the many depencies with pizza3, the code needs to be run from : Thomazo_v2\</p>
<h2>Authors</h2>
<p>Revision history<br/>2024-05-03 early version<br/>2024-05-05 ROI with PBC implemented<br/>2024-05-06 shear stress and shear rate implementated on a two 2D 1024*1024 grids separated by h</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% Template <span class="keyword">for</span> Yao</span>
<span class="comment">%</span>
<span class="comment">%   Authors: INRAE\Olivier Vitrac, INRAE\Yao Liu</span>
<span class="comment">%</span>
<span class="comment">% The work is based on the simulation of Billy (publication so-called pizza2, and series Thomazo_v2)</span>
<span class="comment">% The dataset is accessible on lab PCs via yao_initialization(tframe)</span>
<span class="comment">% tframe should be chosen among 0.11:0.01:1.11 (0.11, 0.12, 0.13, ... 1.11 s)</span>
<span class="comment">% The data corresponding to tframe and additional details are accessible via</span>
<span class="comment">%     [Xframe,details] = yao_initialization(tframe)</span>
<span class="comment">% Due to the many depencies with pizza3, the code needs to be run from : Thomazo_v2\</span>
<span class="comment">% </span>
<span class="comment">% Revision history</span>
<span class="comment">% 2024-05-03 early version</span>
<span class="comment">% 2024-05-05 ROI with PBC implemented</span>
<span class="comment">% 2024-05-06 shear stress and shear rate implementated on a two 2D 1024*1024 grids separated by h</span>


<span class="comment">%% The code is split in blocks starting with "%%", they can be run independently</span>
<span class="comment">% by pressing CTRL+Enter or by choosing Run Section.</span>
<span class="comment">% The entire script can be run by pressing F5 or by choosing Run</span>
<span class="comment">%</span>
<span class="comment">% Control sections are enclosed between "%{ ... %}", they can be run by selecting</span>
<span class="comment">% the code between {} and by pressing F9 or by using the mouse right click and by</span>
<span class="comment">% choosing Evaluating the selection.</span>
<span class="comment">%</span>
<span class="comment">% visualization of the full dataset as a movie</span>
<span class="comment">%{</span>
clf,
coords = {<span class="string">'z'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>};
<span class="keyword">for</span> tframe = 0.11:0.01:1.11
    Xframe = yao_initialization(tframe);
    clf, hold on, axis equal, view(3)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==1,coords},<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==2,coords},<span class="string">'co'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==3,coords},<span class="string">'go'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==4,coords},<span class="string">'rs'</span>)
    drawnow
<span class="keyword">end</span>
<span class="comment">%}</span>

<span class="comment">%% initialization</span>
close all
clearvars -global -except tframe ztop

<span class="comment">%% actions</span>
actions = {<span class="string">'plot'</span>,<span class="string">'save'</span>};
<span class="keyword">if</span> exist(<span class="string">'D:\Yao'</span>,<span class="string">'dir'</span>)
    local = <span class="string">'D:\Yao'</span>;
<span class="keyword">else</span>
    local = pwd;
<span class="keyword">end</span>
backupfolder = fullfile(local,<span class="string">'Yao_xy'</span>);
<span class="keyword">if</span> ~exist(backupfolder,<span class="string">'dir'</span>), mkdir(backupfolder), <span class="keyword">end</span>

<span class="comment">%% load the frame</span>
<span class="keyword">if</span> ~exist(<span class="string">'tframe'</span>,<span class="string">'var'</span>)
    tframe = 0.67; <span class="comment">% choose any frame between 0.11 and 1.11</span>
<span class="keyword">end</span>
[Xframe,details] = yao_initialization(tframe);
pillarxyz = Xframe.ATOMS{Xframe.ATOMS.ispillar,details.coords};
<span class="comment">% control</span>
<span class="comment">%{</span>
    figure, hold on, axis equal, view(3)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.fluid,details.coords},<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.wall,details.coords},<span class="string">'co'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.pillar,details.coords},<span class="string">'go'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.sphere,details.coords},<span class="string">'rs'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
<span class="comment">%}</span>


<span class="comment">%% Selection of the thick plane or ROI (region of interest)</span>
<span class="keyword">if</span> ~exist(<span class="string">'ztop'</span>,<span class="string">'var'</span>)
    ztop = max(pillarxyz(:,3)); <span class="comment">% top z coord of the pillar</span>
<span class="keyword">end</span>
zthick = ztop*0.15;          <span class="comment">% define the thickness of the plane around ztop</span>
ROIbox = details.box;      <span class="comment">% select the ROI (region of interest)</span>
ROIbox(3,:) = ztop + [-0.5 +0.5]*zthick; <span class="comment">% update the ROI to ztop-zthick/2 and ztop+zthick/2</span>
insideROIbox = true(height(Xframe.ATOMS),1); <span class="comment">% boolean flag (by default all atoms are considered in ROI)</span>
<span class="keyword">for</span> icoord = 1:3 <span class="comment">% <span class="keyword">for</span> each coordinate</span>
    insideROIbox = insideROIbox ... the operator & (<span class="string">'and'</span>) enable to uncheck atoms beyond the bounds
        & Xframe.ATOMS{:,details.coords{icoord}}>=ROIbox(icoord,1) ...
        & Xframe.ATOMS{:,details.coords{icoord}}<=ROIbox(icoord,2);
<span class="keyword">end</span>
atomsROI = Xframe.ATOMS(insideROIbox,:); <span class="comment">% atom table <span class="keyword">for</span> only ROI atoms</span>

<span class="comment">% control</span>
<span class="comment">%{</span>
    figure, hold on, axis equal, view(3)
    plot3D(atomsROI{atomsROI.type==details.type.fluid,details.coords},<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(atomsROI{atomsROI.type==details.type.wall,details.coords},<span class="string">'co'</span>)
    plot3D(atomsROI{atomsROI.type==details.type.pillar,details.coords},<span class="string">'go'</span>)
    plot3D(atomsROI{atomsROI.type==details.type.sphere,details.coords},<span class="string">'rs'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
<span class="comment">%}</span>

<span class="comment">%% add PBC images (periodic boundary)</span>
XYZ = atomsROI{:,details.coords}; <span class="comment">% coordinates of ROI atoms</span>
vXYZ = atomsROI{:,details.vcoords}; <span class="comment">% coordinates of ROI atoms</span>
rhoXYZ = atomsROI.c_rho_smd;
[XYZimagesONLY ,indXimagesONLY]= PBCimages(XYZ,ROIbox,[true,true,false],zthick); <span class="comment">% add periodic images within zthick around x and y (z is not periodic)</span>
XYZwithImages = [XYZ;XYZimagesONLY]; <span class="comment">% all atoms including their images</span>
vXYZwithImages = [vXYZ;vXYZ(indXimagesONLY,:)]; <span class="comment">% all atoms including their images</span>
rhoXYZwithImages = [rhoXYZ;rhoXYZ(indXimagesONLY,:)];
isImages = true(size(XYZwithImages,1),1); isImages(1:size(XYZ,1))=false; <span class="comment">% true <span class="keyword">if</span> the atom is an image</span>

<span class="comment">% control - plot particle positions</span>
<span class="comment">%{</span>
    figure, hold on, axis equal, view(3)
    plot3D(XYZ(atomsROI.type==details.type.fluid,:),<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(XYZ(atomsROI.type==details.type.wall,:),<span class="string">'co'</span>)
    plot3D(XYZ(atomsROI.type==details.type.pillar,:),<span class="string">'go'</span>)
    plot3D(XYZ(atomsROI.type==details.type.sphere,:),<span class="string">'rs'</span>)
    <span class="comment">% add images with filled symbols</span>
    plot3D(XYZimagesONLY(atomsROI.isfluid(indXimagesONLY),:),<span class="string">'bo'</span>,<span class="string">'markersize'</span>,2,<span class="string">'markerfacecolor'</span>,<span class="string">'b'</span>)
    plot3D(XYZimagesONLY(atomsROI.iswall(indXimagesONLY),:),<span class="string">'co'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'c'</span>)
    plot3D(XYZimagesONLY(atomsROI.ispillar(indXimagesONLY),:),<span class="string">'go'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'g'</span>)
    plot3D(XYZimagesONLY(atomsROI.issphere(indXimagesONLY),:),<span class="string">'rs'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
<span class="comment">%}</span>

<span class="comment">% control - plot velocity field</span>
<span class="comment">%{</span>
    figure, hold on
    quiver3(XYZ(:,1),XYZ(:,2),XYZ(:,3),vXYZ(:,1),vXYZ(:,2),vXYZ(:,3))
    view(3), axis equal
<span class="comment">%}</span>

<span class="comment">%% determine the separation distance in simulation</span>
boxdims = ROIbox(:,2) - ROIbox(:,1);
Vbead_guess = prod(boxdims)/size(XYZ,1); <span class="comment">% m3</span>
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
[verletList,~,dmin] = buildVerletList(XYZ,cutoff); <span class="comment">% ~ means here that the 2nd output is not used</span>
rbead = dmin/2;
s = 2*rbead; <span class="comment">% separation distance</span>
h = 2*s;     <span class="comment">% smoothing length</span>


<span class="comment">%% add 3D Verlet list</span>
<span class="comment">% we focus on fluid atoms (only)</span>
XYZfluid = XYZ(atomsROI.isfluid,:);
natomsfluid = size(XYZfluid,1);
isfluidwithimages = [atomsROI.isfluid;atomsROI.isfluid(indXimagesONLY)];
XYZfluidwithimages = XYZwithImages(isfluidwithimages,:);
vXYZfluidwithImages = vXYZwithImages(isfluidwithimages,:);
isImagesfluid =  isImages & isfluidwithimages;
[Vfluidwithimages,cutoff,dmin] = buildVerletList(XYZfluidwithimages,1.2*h,[],[],[],isImagesfluid(isfluidwithimages),isImagesfluid(isfluidwithimages) & false);

<span class="comment">% control of neighboring particles or one </span>
<span class="comment">%{</span>
figure, hold on
<span class="keyword">for</span> itest = unidrnd(natomsfluid,1,100)
    plot3D(XYZfluidwithimages(~isImagesfluid(isfluidwithimages),:),<span class="string">'bo'</span>)
    plot3D(XYZfluidwithimages(isImagesfluid(isfluidwithimages),:),<span class="string">'bo'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'b'</span>)
    plot3D(XYZfluidwithimages(Vfluidwithimages{itest,:},:),<span class="string">'ro'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
    plot3D(XYZfluidwithimages(itest,:),<span class="string">'ko'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'k'</span>)
<span class="keyword">end</span>
view(3), axis equal
<span class="comment">%}</span>


<span class="comment">%% ForceLanshoff</span>
<span class="comment">% This pairwise force is an artificial force controlling the dissipation of velocity in the simulation</span>
<span class="comment">% its value is not stored in the simulation and it needs to be calculated from pairwise distances and</span>
<span class="comment">% relative velocities</span>

<span class="comment">% General syntax:</span>
<span class="comment">% [F,W] = forceLandshoff(XYZ,vXYZ,V,config)</span>
<span class="comment">% XYZ   : coordinates</span>
<span class="comment">% vXYZ  : velocities</span>
<span class="comment">% V     : corresponding Verlet list</span>
<span class="comment">% config: configuration <span class="keyword">for</span> Landshoff calculations based on the properties of the simulation</span>

c0 = 1500; <span class="comment">% speed of sound (m/s) % maxVelocity / MachTarget;</span>
dynamicViscosity = 0.13; <span class="comment">% Pa.s (viscosity to find)</span>
q1 = 1; <span class="comment">% 8 * dynamicViscosity / (hinformed*c0*rho);</span>
mbead = 4.38e-12; <span class="comment">% kg</span>
configL  = struct( ...real dynamic viscosity: rho * q1 * h * c0 / 8 (2D) or 10 (3D)
   <span class="string">'gradkernel'</span>, kernelSPH(h,<span class="string">'lucyder'</span>,3),...<span class="comment">% kernel gradient (note that h is bound with the kernel)</span>
            <span class="string">'h'</span>, h,...   smoothing length (m)
           <span class="string">'c0'</span>,1500,... speed of the sound (m/s)
           <span class="string">'q1'</span>,1,...    constant
          <span class="string">'rho'</span>, rhoXYZwithImages(isfluidwithimages), ... fluid density
         <span class="string">'mass'</span>, mbead,...  bead weight
          <span class="string">'vol'</span>, mbead./rhoXYZwithImages(isfluidwithimages), ...       bead volume (uniquely <span class="keyword">for</span> virial stress)
<span class="string">'repulsiononly'</span>, false ...    <span class="keyword">if</span> true, only Landshoff forces when dot(rij,vij)<0
    );
[Fwithimages,Wwithimages] = forceLandshoff(XYZfluidwithimages,vXYZfluidwithImages,Vfluidwithimages,configL);
wihtoutimages = ~isImagesfluid(isfluidwithimages);
Fland = Fwithimages(wihtoutimages,:); <span class="comment">% F Landshoff forces</span>
Wland = Wwithimages(wihtoutimages,:); <span class="comment">% corresponding Virial Stress Tensor</span>

<span class="comment">% plot the Landshoff forces acting on particles</span>
figure, hold on
plot3D(XYZfluid,<span class="string">'bo'</span>,<span class="string">'markersize'</span>,2)
quiver3(XYZfluid(:,1),XYZfluid(:,2),XYZfluid(:,3),Fland(:,1),Fland(:,2),Fland(:,3),<span class="string">'r-'</span>)
axis equal, view(3)
figure, histogram(log10(vecnorm(Fland,2,2))) <span class="comment">% magnitude of the force on a log10 scale</span>



<span class="comment">%% Interpolate Virial Stress along an horizontal plane (has Han did)</span>
nresolution = [1024 1024 1];
xw = linspace(ROIbox(1,1),ROIbox(1,2),nresolution(1));
yw = linspace(ROIbox(2,1),ROIbox(2,2),nresolution(1));
zw = ztop; <span class="comment">% vertical position used <span class="keyword">for</span> interpolation</span>
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];
VXYZgrid = buildVerletList({XYZgrid XYZfluidwithimages},2*h);  <span class="comment">% neighbors = fluid particles</span>
W = kernelSPH(2*h,<span class="string">'lucy'</span>,3); <span class="comment">% kernel expression</span>
Wgrid = zeros(prod(nresolution(1:2)),9,<span class="string">'single'</span>);
<span class="keyword">for</span> i = 1:9 <span class="comment">% <span class="keyword">for</span> all diagonal terms</span>
    Wgrid(:,i) = interp3SPHVerlet(XYZfluidwithimages,Wwithimages(:,i),XYZgrid,VXYZgrid,W,mbead./rhoXYZwithImages(isfluidwithimages));
<span class="keyword">end</span>

<span class="comment">%% Interpolate the Velocity, extraction of the strain rate tensor</span>
vxyzgrid = zeros(prod(nresolution(1:2)),3,<span class="string">'single'</span>);
vxyzgridabove = vxyzgrid;
XYZgridabove = XYZgrid;
XYZgridabove(:,3) = XYZgridabove(:,3) + h; <span class="comment">% information along z</span>
<span class="keyword">for</span> i = 1:3
    vxyzgrid(:,i) = interp3SPHVerlet(XYZfluidwithimages,vXYZfluidwithImages(:,i),XYZgrid,VXYZgrid,W,mbead./rhoXYZwithImages(isfluidwithimages));
    vxyzgridabove(:,i) = interp3SPHVerlet(XYZfluidwithimages,vXYZfluidwithImages(:,i),XYZgridabove,VXYZgrid,W,mbead./rhoXYZwithImages(isfluidwithimages));
<span class="keyword">end</span>
gxz = reshape( (vxyzgridabove(:,1) - vxyzgrid(:,1)) / h, nresolution(1:2));
gyz = reshape( (vxyzgridabove(:,2) - vxyzgrid(:,2)) / h, nresolution(1:2));
gzz = reshape( (vxyzgridabove(:,3) - vxyzgrid(:,3)) / h, nresolution(1:2));
[gxx,gxy] = gradient(reshape(vxyzgrid(:,1),nresolution(1:2)),Xw(1,2)-Xw(1,1),Yw(2,1)-Yw(1,1));
[gyx,gyy] = gradient(reshape(vxyzgrid(:,2),nresolution(1:2)),Xw(1,2)-Xw(1,1),Yw(2,1)-Yw(1,1));
[gzx,gzy] = gradient(reshape(vxyzgrid(:,3),nresolution(1:2)),Xw(1,2)-Xw(1,1),Yw(2,1)-Yw(1,1));
Ggrid = [gxx(:) gxy(:) gxz(:) gyx(:) gyy(:) gyz(:) gzx(:) gzy(:) gzz(:)]; <span class="comment">% nine tensor components</span>

<span class="comment">% Velocity control</span>
<span class="keyword">if</span> ismember(<span class="string">'plot'</span>,actions)
    close all
    formatfig(figure,<span class="string">'figname'</span>,sprintf(<span class="string">'YAOxy_t<span class="comment">%0.3g_z%0.3g'</span>,round(tframe*100),round(ztop*1e6)),<span class="string">'PaperPosition'</span>,[1.4920    7.8613   18.0000   14.0000]), hold on</span>
    step = 8; [ix,iy] = meshgrid(1:step:nresolution(1),1:step:nresolution(2)); indok = sub2ind(nresolution(1:2),ix,iy);
    quiver3(XYZgrid(indok,1),XYZgrid(indok,2),XYZgrid(indok,3),vxyzgrid(indok,1),vxyzgrid(indok,2),vxyzgrid(indok,3),<span class="string">'r-'</span>)
    axis tight
    view(23,29)
    daspect([1 1 0.03 ])
    xlabel(<span class="string">'x (m)'</span>,<span class="string">'fontsize'</span>,12)
    ylabel(<span class="string">'y (m)'</span>,<span class="string">'fontsize'</span>,12)
    title(sprintf(<span class="string">'t = <span class="comment">%0.3g s - z = %0.3g µm'</span>,tframe,round(ztop*1e6)))</span>
    print_png(200,fullfile(backupfolder,get(gcf,<span class="string">'filename'</span>)),<span class="string">''</span>,<span class="string">''</span>,0,0,0)
    <span class="keyword">return</span>
<span class="keyword">end</span>
<span class="comment">%{</span>
figure, hold on
step = 8; [ix,iy] = meshgrid(1:step:nresolution(1),1:step:nresolution(2)); indok = sub2ind(nresolution(1:2),ix,iy);
quiver3(XYZgrid(indok,1),XYZgrid(indok,2),XYZgrid(indok,3),vxyzgrid(indok,1),vxyzgrid(indok,2),vxyzgrid(indok,3),<span class="string">'r-'</span>)
quiver3(XYZgridabove(:,1),XYZgridabove(:,2),XYZgridabove(:,3),vxyzgridabove(:,1),vxyzgridabove(:,2),vxyzgridabove(:,3),<span class="string">'g-'</span>)
<span class="comment">%}</span>

<span class="comment">%% save</span>
backfolder = fullfile(<span class="string">'backupfolder'</span>,<span class="string">'details'</span>);
backfolder = <span class="string">'D:\Yao'</span>;
<span class="keyword">if</span> exist(backfolder,<span class="string">'dir'</span>) 
    prefetchresult = sprintf(<span class="string">'YAO_xy_t<span class="comment">%0.3g_z%0.3g'</span>,tframe*1e2,ztop*1e6);</span>
    save(fullfile(backfolder,prefetchresult))
<span class="keyword">end</span>

<span class="comment">%% figure of 3D velocity field</span>
figure, hold on
step = 16; [ix,iy] = meshgrid(1:step:nresolution(1),1:step:nresolution(2)); indok = sub2ind(nresolution(1:2),ix,iy);
quiver3(XYZgrid(indok,1),XYZgrid(indok,2),XYZgrid(indok,3),vxyzgrid(indok,1),vxyzgrid(indok,2),vxyzgrid(indok,3),<span class="string">'r-'</span>)
view(3)
xlabel(<span class="string">'x (m)'</span>,<span class="string">'fontsize'</span>,12)
ylabel(<span class="string">'y (m)'</span>,<span class="string">'fontsize'</span>,12)
zlabel(<span class="string">'z (m)'</span>,<span class="string">'fontsize'</span>,12)
set(gcf,<span class="string">'color'</span>,<span class="string">'w'</span>)

<span class="comment">%% Density</span>
XYZs = atomsROI{atomsROI.issolid,details.coords};
rhobeadXYZ = atomsROI.c_rho_smd; <span class="comment">% volume of the bead</span>
rhobeadXYZwithImages = [rhobeadXYZ;rhobeadXYZ(indXimagesONLY)];
VbeadXYZwithImages = mbead./rhobeadXYZwithImages;
VXYZ  = buildVerletList({XYZgrid XYZwithImages},1.2*h);  <span class="comment">% neighbors = fluid particles</span>
VXYZs = buildVerletList({XYZgrid XYZs},h); <span class="comment">% neighbors = solid particles (0.85*s)</span>
icontactsolid = find(cellfun(@length,VXYZs)>0);
VXYZ(icontactsolid) = repmat({[]},length(icontactsolid),1);
rhobeadXYZgrid = interp3SPHVerlet(XYZwithImages,rhobeadXYZwithImages,XYZgrid,VXYZ,W,VbeadXYZwithImages);
rhobeadXYZgrid = reshape(rhobeadXYZgrid,size(Xw));


<span class="comment">%% Symmetric Strain</span>
Straingrid = [gxx(:) 0.5*(gxy(:)+gyx(:)) 0.5*(gxz(:)+gzx(:))   0.5*(gxy(:)+gyx(:))  gyy(:) 0.5*(gyz(:)+gzy(:))  0.5*(gxz(:)+gzx(:))  0.5*(gyz(:)+gzy(:)) gzz(:)];
Straingrid(find(isnan(rhobeadXYZgrid)),:) = NaN;

formatfig(figure,<span class="string">'figname'</span>,sprintf(<span class="string">'Yao_xy_SHEAR_t<span class="comment">%d_z%d'</span>,round(tframe*100),round(zw*1e6)))</span>
hs2 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,<span class="string">'alive'</span>,offdiag);</span>
leg = {<span class="string">'$\dot{\varepsilon}_{xx}$'</span>,<span class="string">'$\dot{\varepsilon}_{xy}$'</span>,<span class="string">'$\dot{\varepsilon}_{xz}$'</span>,...
       <span class="string">'$\dot{\varepsilon}_{yx}$'</span>,<span class="string">'$\dot{\varepsilon}_{yy}$'</span>,<span class="string">'$\dot{\varepsilon}_{yz}$'</span>,...
       <span class="string">'$\dot{\varepsilon}_{zx}$'</span>,<span class="string">'$\dot{\varepsilon}_{zy}$'</span>,<span class="string">'$\dot{\varepsilon}_{zz}$'</span>};
<span class="keyword">for</span> i=1:9
    subplot(hs2(i)), imagesc(flipud(reshape(Straingrid(:,i),nresolution([1 2]))))
    c=colorbar; <span class="keyword">if</span> i==7, c.Label.String = <span class="string">'strain rate (s^{-1})'</span>; <span class="keyword">end</span>
    axis image
    caxis([-5 5])
    title(leg{i},<span class="string">'fontsize'</span>,12,<span class="string">'visible'</span>,<span class="string">'on'</span>,<span class="string">'Interpreter'</span>,<span class="string">'Latex'</span>)
<span class="keyword">end</span>
set(hs2,<span class="string">'visible'</span>,<span class="string">'off'</span>)
print_png(400,fullfile(backfolder,get(gcf,<span class="string">'filename'</span>)),<span class="string">''</span>,<span class="string">''</span>,0,0,0)

<span class="comment">%% Stress</span>
formatfig(figure,<span class="string">'figname'</span>,sprintf(<span class="string">'Yao_xy_STRESS_t<span class="comment">%d_z%d'</span>,round(tframe*100),round(zw*1e6)))</span>
hs2 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,<span class="string">'alive'</span>,offdiag);</span>
leg = {<span class="string">'\tau_{xx}'</span>,<span class="string">'\tau_{xy}'</span>,<span class="string">'\tau_{xz}'</span>,<span class="string">'\tau_{yx}'</span>,<span class="string">'\tau_{yy}'</span>,<span class="string">'\tau_{yz}'</span>,<span class="string">'\tau_{zx}'</span>,<span class="string">'\tau_{zy}'</span>,<span class="string">'\tau_{zz}'</span>};
Wgrid(find(isnan(rhobeadXYZgrid)),:) = NaN;
<span class="keyword">for</span> i=1:9
    subplot(hs2(i)), imagesc(flipud(reshape(Wgrid(:,i),nresolution([1 2]))))
    c=colorbar; <span class="keyword">if</span> i==7, c.Label.String = <span class="string">'stress (Pa)'</span>; <span class="keyword">end</span>
    axis image
    caxis([-0.1 0.8])
    title(leg{i},<span class="string">'fontsize'</span>,12,<span class="string">'visible'</span>,<span class="string">'on'</span>)
<span class="keyword">end</span>
set(hs2,<span class="string">'visible'</span>,<span class="string">'off'</span>)
print_png(400,fullfile(backfolder,get(gcf,<span class="string">'filename'</span>)),<span class="string">''</span>,<span class="string">''</span>,0,0,0)


<span class="comment">%% Lamé coefficients</span>
<span class="comment">% Extract the diagonal terms <span class="keyword">for</span> the trace calculation</span>
iok = find(~isnan(rhobeadXYZgrid)); nok = length(iok);
<span class="comment">% Extract the diagonal terms <span class="keyword">for</span> the trace calculation</span>
trace_Strain = Straingrid(iok,1) + Straingrid(iok,5) + Straingrid(iok,9);
<span class="comment">% Form the matrix A <span class="keyword">for</span> the global least-square problem</span>
A = zeros(nok* 9, 2);
<span class="comment">% Fill in the lambda * trace(Straingrid) * I part</span>
trace_Strain_repeated = repmat(trace_Strain, 9, 1); <span class="comment">% Repeat trace_Strain 9 times</span>
A(:, 1) = trace_Strain_repeated(:); <span class="comment">% Fill the first column of A with the repeated trace</span>
<span class="comment">% Fill in the 2 * mu * Straingrid part</span>
A(:, 2) = reshape(2 * Straingrid(iok,:)<span class="string">', [], 1); <span class="comment">% Reshape 2 * Straingrid to a column vector</span>
<span class="comment">% Reshape Wgrid to a vector</span>
Wgrid_vectorized = reshape(Wgrid(iok,:)'</span>, [], 1);
<span class="comment">% Solve the non-negative least squares problem</span>
params = lsqnonneg(A, double(Wgrid_vectorized));
<span class="comment">% Extract the results</span>
lam_global = params(1);
mu_global = params(2);

<span class="comment">% Display the results</span>
disp([<span class="string">'Lambda (λ): '</span>, num2str(lam_global)]);
disp([<span class="string">'Mu (μ): '</span>, num2str(mu_global)]);

<span class="comment">% Local approximates</span>
<span class="comment">% Initialize arrays to store the local estimations of mu and lam</span>
mu_local = zeros(1048576, 1);
lam_local = zeros(1048576, 1);

<span class="comment">% Extract the diagonal terms of Straingrid <span class="keyword">for</span> trace calculation</span>
trace_Strain = Straingrid(:,1) + Straingrid(:,5) + Straingrid(:,9);

<span class="comment">% Construct the identity matrix as a vector</span>
I_vector = [1 0 0 0 1 0 0 0 1];

<span class="keyword">for</span> i = 1:1048576
    <span class="comment">% Create the system of equations <span class="keyword">for</span> the current grid point</span>
    A_local = zeros(9, 2);
    
    <span class="comment">% Fill in the lambda * trace(Straingrid) * I part</span>
    A_local(:, 1) = trace_Strain(i) * I_vector<span class="string">';
    
    <span class="comment">% Fill in the 2 * mu * Straingrid part</span>
    A_local(:, 2) = 2 * Straingrid(i, :)'</span>;
    
    <span class="comment">% Solve <span class="keyword">for</span> lam and mu using non-negative least squares</span>
    params_local = lsqnonneg(A_local, double(Wgrid(i, :))<span class="string">');
    
    <span class="comment">% Store the results</span>
    lam_local(i) = params_local(1);
    mu_local(i) = params_local(2);
<span class="keyword">end</span>

<span class="comment">% Display a sample of the results</span>
disp('</span>Sample of local Lambda (λ) estimates:<span class="string">');
disp(lam_local(1:10)'</span>);
disp(<span class="string">'Sample of local Mu (μ) estimates:'</span>);
disp(mu_local(1:10)<span class="string">');

<span class="comment">%% Lambda, Mu plots</span>
formatfig(figure,'</span>figname<span class="string">',sprintf('</span>Yao_xy_VISCO_L2_t<span class="comment">%d_z%d<span class="string">',round(tframe*100),round(zw*1e6)))</span>
imagesc(xw,yw,flipud(reshape(mu_local,nresolution([1 2]))))
c=colorbar; c.Label.String = '</span>\mu (Pa\cdot s^{-1})<span class="string">'; caxis([0 0.15])
c.FontSize=12; formatax(gca,'</span>fontsize<span class="string">',12), c.Label.FontSize=16;
xlabel('</span>x (µm)<span class="string">','</span>fontsize<span class="string">',14), ylabel('</span>y (µm)<span class="string">','</span>fontsize<span class="string">',14)
title({'</span>Dynamic Viscosity<span class="string">' sprintf('</span>t = \\bf<span class="comment">%0.3g s\\rm, z = \\bf%0.3g\\rm µm<span class="string">',tframe,1e6*ztop)},'</span>fontsize<span class="string">',14,'</span>visible<span class="string">','</span>on<span class="string">')</span>
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)

formatfig(figure,'</span>figname<span class="string">',sprintf('</span>Yao_xy_VISCOVOL_L2_t<span class="comment">%d_z%d<span class="string">',round(tframe*100),round(zw*1e6)))</span>
imagesc(xw,yw,flipud(reshape(lam_local,nresolution([1 2]))))
c=colorbar; c.Label.String = '</span>\lambda (Pa\cdot s^{-1})<span class="string">'; caxis([0 2])
c.FontSize=12; formatax(gca,'</span>fontsize<span class="string">',12), c.Label.FontSize=16;
xlabel('</span>x (µm)<span class="string">','</span>fontsize<span class="string">',14), ylabel('</span>y (µm)<span class="string">','</span>fontsize<span class="string">',14)
title({'</span>Elongational Viscosity<span class="string">' sprintf('</span>t = \\bf<span class="comment">%0.3g s\\rm, z = \\bf%0.3g\\rm µm<span class="string">',tframe,1e6*ztop)},'</span>fontsize<span class="string">',14,'</span>visible<span class="string">','</span>on<span class="string">')</span>
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)

<span class="keyword">return</span>

RECOresult = fullfile(backfolder,sprintf('</span>YAO_VISCOL2_xy_t<span class="comment">%0.3g_z%0.3g<span class="string">',tframe*1e2,ztop*1e6));</span>
save(RECOresult,'</span>mu_local<span class="string">','</span>lam_local<span class="string">','</span>Straingrid<span class="string">','</span>Wgrid<span class="string">','</span>Xw<span class="string">','</span>Yw<span class="string">','</span>xw<span class="string">','</span>yw<span class="string">','</span>tframe<span class="string">','</span>ztop<span class="string">')

<span class="comment">%% Comparison</span>
backfolder = '</span>D:\Yao<span class="string">';
RECO = [
    load('</span>D:\Yao\YAO_VISCOL2_xy_t57_z425.mat<span class="string">')
    load('</span>D:\Yao\YAO_VISCOL2_xy_t67_z425.mat<span class="string">')
    load('</span>D:\Yao\YAO_VISCOL2_xy_t77_z425.mat<span class="string">')
    ];
formatfig(figure,'</span>figname<span class="string">','</span>Yao_distributionStrain<span class="string">'), hold on
<span class="keyword">for</span> i=1:length(RECO)
    histogram(RECO(i).Straingrid(:,2),linspace(-5,5,100),'</span>DisplayName<span class="string">',sprintf('</span>t=<span class="comment">%0.3g s<span class="string">',RECO(i).tframe),'</span>FaceAlpha<span class="string">',0.5)</span>
<span class="keyword">end</span>
formatax(gca,'</span>fontsize<span class="string">',12)
legend('</span>fontsize<span class="string">',14,'</span>box<span class="string">','</span>off<span class="string">')
xlabel('</span>Strain Rate: $\dot{\varepsilon}_{yx}$ (s$^{-1}$)<span class="string">', '</span>fontsize<span class="string">', 14, '</span>Interpreter<span class="string">', '</span>latex<span class="string">')
ylabel('</span>Counts<span class="string">','</span>fontsize<span class="string">',14)
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)

formatfig(figure,'</span>figname<span class="string">','</span>Yao_distributionStress<span class="string">'), hold on
<span class="keyword">for</span> i=1:length(RECO)
    histogram(RECO(i).Wgrid(:,2),linspace(-0.1,0.1,500),'</span>DisplayName<span class="string">',sprintf('</span>t=<span class="comment">%0.3g s<span class="string">',RECO(i).tframe),'</span>FaceAlpha<span class="string">',0.5)</span>
<span class="keyword">end</span>
formatax(gca,'</span>xlim<span class="string">',[-0.07 0.07],'</span>ylim<span class="string">',[0 2.5]*1e4,'</span>fontsize<span class="string">',12)
legend('</span>fontsize<span class="string">',14,'</span>box<span class="string">','</span>off<span class="string">')
xlabel('</span>Shear Stress: \tau_{yx} (Pa)<span class="string">','</span>fontsize<span class="string">',14)
ylabel('</span>Counts<span class="string">','</span>fontsize<span class="string">',14)
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)

formatfig(figure,'</span>figname<span class="string">','</span>Yao_distributionVisco<span class="string">'), hold on
<span class="keyword">for</span> i=1:length(RECO)
    histogram(RECO(i).mu_local,linspace(0,0.3,100),'</span>DisplayName<span class="string">',sprintf('</span>t=<span class="comment">%0.3g s<span class="string">',RECO(i).tframe),'</span>FaceAlpha<span class="string">',0.5)</span>
<span class="keyword">end</span>
formatax(gca,'</span>xlim<span class="string">',[0 0.18],'</span>ylim<span class="string">',[0 2.5]*1e4,'</span>fontsize<span class="string">',12)
legend('</span>fontsize<span class="string">',14,'</span>box<span class="string">','</span>off<span class="string">')
xlabel('</span>Dynamic Viscosity: \mu (Pa\cdot s^{-1})<span class="string">','</span>fontsize<span class="string">',14)
ylabel('</span>Counts<span class="string">','</span>fontsize<span class="string">',14)
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)

formatfig(figure,'</span>figname<span class="string">','</span>Yao_distributionElongVisco<span class="string">'), hold on
<span class="keyword">for</span> i=1:length(RECO)
    histogram(RECO(i).lam_local,linspace(0,0.5,200),'</span>DisplayName<span class="string">',sprintf('</span>t=<span class="comment">%0.3g s<span class="string">',RECO(i).tframe),'</span>FaceAlpha<span class="string">',0.5)</span>
<span class="keyword">end</span>
formatax(gca,'</span>xlim<span class="string">',[0 0.4],'</span>ylim<span class="string">',[0 2.5]*1e4,'</span>fontsize<span class="string">',12)
legend('</span>fontsize<span class="string">',14,'</span>box<span class="string">','</span>off<span class="string">')
xlabel('</span>Elongational Viscosity: \lambda (Pa\cdot s^{-1})<span class="string">','</span>fontsize<span class="string">',14)
ylabel('</span>Counts<span class="string">','</span>fontsize<span class="string">',14)
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)

<span class="comment">% obsolete below ---------------------------------------------------------------------------------------------------------</span>

<span class="comment">%% Viscosity estimation</span>
<span class="comment">% Egrid = abs(Wgrid./Ggrid);</span>
Egrid = 0.5*abs(Wgrid./Straingrid);
formatfig(figure,'</span>figname<span class="string">',sprintf('</span>Yao_xy_VISCO_t<span class="comment">%d_z%d<span class="string">',round(tframe*100),round(zw*1e6)))</span>
hs2 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,'</span>alive<span class="string">',offdiag);</span>
leg = {'</span>\mu_{xx}<span class="string">','</span>\mu_{xy}<span class="string">','</span>\mu_{xz}<span class="string">','</span>\mu_{yx}<span class="string">','</span>\mu_{yy}<span class="string">','</span>\mu_{yz}<span class="string">','</span>\mu_{zx}<span class="string">','</span>\mu_{zy}<span class="string">','</span>\mu_{zz}<span class="string">'};
<span class="keyword">for</span> i=1:9
    subplot(hs2(i)), imagesc(reshape(Straingrid(:,i),nresolution([1 2])))
    c=colorbar; <span class="keyword">if</span> i==7, c.Label.String = '</span>stress (Pa\cdot s)<span class="string">'; <span class="keyword">end</span>
    axis image
    caxis([0 1])
    title(leg{i},'</span>fontsize<span class="string">',12,'</span>visible<span class="string">','</span>on<span class="string">')
<span class="keyword">end</span>
set(hs2,'</span>visible<span class="string">','</span>off<span class="string">')
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)

<span class="comment">% %% plot stress results</span>
<span class="comment">% close all</span>
<span class="comment">% offdiag = [2 3 4 6 7 8];</span>
<span class="comment">% figstresstensor = figure;</span>
<span class="comment">% figsheartensor = figure;</span>
<span class="comment">% figviscosity = figure;</span>
<span class="comment">% formatfig(figstresstensor,'</span>figname<span class="string">',sprintf('</span>STRESS_t%d_z%d<span class="string">',round(tframe*100),round(zw*1e6)))</span>
<span class="comment">% formatfig(figsheartensor,'</span>figname<span class="string">',sprintf('</span>SHEAR_t%d_z%d<span class="string">',round(tframe*100),round(zw*1e6)))</span>
<span class="comment">% formatfig(figviscosity,'</span>figname<span class="string">',sprintf('</span>VISCO_t%d_z%d<span class="string">',round(tframe*100),round(zw*1e6)))</span>
<span class="comment">% </span>
<span class="comment">% figure(figstresstensor), hs1 = subplots([1 1 1],[1 1 1],0.01,0.01); %,'</span>alive<span class="string">',offdiag);</span>
<span class="comment">% figure(figsheartensor), hs2 = subplots([1 1 1],[1 1 1],0.01,0.01); %,'</span>alive<span class="string">',offdiag);</span>
<span class="comment">% figure(figviscosity), hs3 = subplots([1 1 1],[1 1 1],0.01,0.01); %,'</span>alive<span class="string">',offdiag);</span>
<span class="comment">% [Wmin,Wmax,Gmin,Gmax,Emin,Emax] = deal(+Inf,-Inf,+Inf,-Inf,+Inf,-Inf);</span>
<span class="comment">% <span class="keyword">for</span> i=1:9</span>
<span class="comment">%     figure(figstresstensor), subplot(hs1(i)), imagesc(reshape(Wgrid(:,i),nresolution([1 2]))), colorbar</span>
<span class="comment">%     figure(figsheartensor), subplot(hs2(i)), imagesc(reshape(Ggrid(:,i),nresolution([1 2]))), colorbar</span>
<span class="comment">%     figure(figviscosity), subplot(hs3(i)), imagesc(reshape(Egrid(:,i),nresolution([1 2]))), colorbar</span>
<span class="comment">%     Wmin = min(Wmin,min(Wgrid(:,i)));</span>
<span class="comment">%     Wmax = max(Wmax,max(Wgrid(:,i)));</span>
<span class="comment">%     Gmin = min(Wmin,min(Ggrid(:,i)));</span>
<span class="comment">%     Gmax = max(Wmax,max(Ggrid(:,i)));</span>
<span class="comment">%     Emin = min(Wmin,min(Egrid(:,i)));</span>
<span class="comment">%     Emax = max(Wmax,max(Egrid(:,i)));</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% set(hs1,'</span>visible<span class="string">','</span>off<span class="string">')</span>
<span class="comment">% set(hs2,'</span>visible<span class="string">','</span>off<span class="string">')</span>
<span class="comment">% set(hs3,'</span>visible<span class="string">','</span>off<span class="string">')</span>
<span class="comment">% <span class="keyword">for</span> i=1:9</span>
<span class="comment">%     figure(figstresstensor), subplot(hs1(i)), clim([Wmin Wmax])</span>
<span class="comment">%     figure(figsheartensor), subplot(hs1(i)), clim([Gmin Gmax])</span>
<span class="comment">%     figure(figviscosity), subplot(hs1(i)), clim([Emin Emax])</span>
<span class="comment">% <span class="keyword">end</span></span>
<span class="comment">% set(hs3,'</span>clim<span class="string">',[0.01 10 ])</span>
<span class="comment">% </span>
<span class="comment">% % plot </span>
<span class="comment">% figsumall = figure;</span>
<span class="comment">% formatfig(figsumall,'</span>figname<span class="string">',sprintf('</span>STRESS_sumoff_t%d_z%d<span class="string">',round(tframe*100)))</span>
<span class="comment">% title('</span>all off-diagonal terms are added<span class="string">')</span>
<span class="comment">% imagesc(reshape(sum(Wgrid(:,offdiag),2),nresolution([1 2])))</span>
<span class="comment">% </span>
<span class="comment">% %% print </span>
<span class="comment">% outputfolder = '</span>YAOresults<span class="string">';</span>
<span class="comment">% <span class="keyword">if</span> ~exist(outputfolder,'</span>dir<span class="string">'), mkdir(outputfolder), <span class="keyword">end</span></span>
<span class="comment">%  figure(figstresstensor)</span>
<span class="comment">%  print_pdf(300,[get(figstresstensor,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') % PDF 300 dpi</span>
<span class="comment">%  print_png(300,fullfile(outputfolder,get(figstresstensor,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)</span>
<span class="comment">%  figure(figsheartensor)</span>
<span class="comment">%  print_pdf(300,[get(figsheartensor,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') % PDF 300 dpi</span>
<span class="comment">%  print_png(300,fullfile(outputfolder,get(figsheartensor,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)</span>
<span class="comment">%  figure(figviscosity)</span>
<span class="comment">%  print_pdf(300,[get(figviscosity,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') % PDF 300 dpi</span>
<span class="comment">%  print_png(300,fullfile(outputfolder,get(figviscosity,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)</span>
<span class="comment">% figure(figsumall)</span>
<span class="comment">%  print_pdf(300,[get(figsumall,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') % PDF 300 dpi</span>
<span class="comment">%  print_png(300,fullfile(outputfolder,get(figsumall,'</span>filename<span class="string">')),'</span><span class="string">','</span>',0,0,0)</span></code></pre></div>
</div>
<div id='yao_stress_vertical_xz' class='doc-content' style='display: none;'>
<h1>Template for Yao</h1>
<h2>Authors</h2>
<p>INRAE\Olivier Vitrac, INRAE\Yao Liu</p>
<h2>Authors</h2>
<p>The work is based on the simulation of Billy (publication so-called pizza2, and series Thomazo_v2)<br/>The dataset is accessible on lab PCs via yao_initialization(tframe)<br/>tframe should be chosen among 0.11:0.01:1.11 (0.11, 0.12, 0.13, ... 1.11 s)<br/>The data corresponding to tframe and additional details are accessible via<br/>[Xframe,details] = yao_initialization(tframe)<br/>Due to the many depencies with pizza3, the code needs to be run from : Thomazo_v2\</p>
<h2>Authors</h2>
<p>Revision history<br/>2024-05-03 early version<br/>2024-05-05 ROI with PBC implemented<br/>2024-05-06 shear stress and shear rate implementated on a two 2D 1024*1024 grids separated by h</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% Template <span class="keyword">for</span> Yao</span>
<span class="comment">%</span>
<span class="comment">%   Authors: INRAE\Olivier Vitrac, INRAE\Yao Liu</span>
<span class="comment">%</span>
<span class="comment">% The work is based on the simulation of Billy (publication so-called pizza2, and series Thomazo_v2)</span>
<span class="comment">% The dataset is accessible on lab PCs via yao_initialization(tframe)</span>
<span class="comment">% tframe should be chosen among 0.11:0.01:1.11 (0.11, 0.12, 0.13, ... 1.11 s)</span>
<span class="comment">% The data corresponding to tframe and additional details are accessible via</span>
<span class="comment">%     [Xframe,details] = yao_initialization(tframe)</span>
<span class="comment">% Due to the many depencies with pizza3, the code needs to be run from : Thomazo_v2\</span>
<span class="comment">% </span>
<span class="comment">% Revision history</span>
<span class="comment">% 2024-05-03 early version</span>
<span class="comment">% 2024-05-05 ROI with PBC implemented</span>
<span class="comment">% 2024-05-06 shear stress and shear rate implementated on a two 2D 1024*1024 grids separated by h</span>


<span class="comment">%% The code is split in blocks starting with "%%", they can be run independently</span>
<span class="comment">% by pressing CTRL+Enter or by choosing Run Section.</span>
<span class="comment">% The entire script can be run by pressing F5 or by choosing Run</span>
<span class="comment">%</span>
<span class="comment">% Control sections are enclosed between "%{ ... %}", they can be run by selecting</span>
<span class="comment">% the code between {} and by pressing F9 or by using the mouse right click and by</span>
<span class="comment">% choosing Evaluating the selection.</span>
<span class="comment">%</span>
<span class="comment">% visualization of the full dataset as a movie</span>
<span class="comment">%{</span>
clf,
coords = {<span class="string">'z'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>};
<span class="keyword">for</span> tframe = 0.11:0.01:1.11
    Xframe = yao_initialization(tframe);
    clf, hold on, axis equal, view(3)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==1,coords},<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==2,coords},<span class="string">'co'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==3,coords},<span class="string">'go'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==4,coords},<span class="string">'rs'</span>)
    drawnow
<span class="keyword">end</span>
<span class="comment">%}</span>


<span class="comment">%% load the frame</span>
tframe = 0.67; <span class="comment">% choose any frame between 0.11 and 1.11</span>
[Xframe,details] = yao_initialization(tframe);
pillarxyz = Xframe.ATOMS{Xframe.ATOMS.ispillar,details.coords};
<span class="comment">% control</span>
<span class="comment">%{</span>
    figure, hold on, axis equal, view(3)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.fluid,details.coords},<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.wall,details.coords},<span class="string">'co'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.pillar,details.coords},<span class="string">'go'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.sphere,details.coords},<span class="string">'rs'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
<span class="comment">%}</span>


<span class="comment">%% Selection of the thick plane or ROI (region of interest)</span>
ymean = mean(pillarxyz(:,2)); <span class="comment">% mean y coord of the pillar</span>
ythick = ymean*0.15*5;          <span class="comment">% define the thickness of the plane around ztop</span>
ROIbox = details.box;      <span class="comment">% select the ROI (region of interest)</span>
ROIbox(2,:) = ymean + [-0.5 +0.5]*ythick; <span class="comment">% update the ROI to ztop-zthick/2 and ztop+zthick/2</span>
insideROIbox = true(height(Xframe.ATOMS),1); <span class="comment">% boolean flag (by default all atoms are considered in ROI)</span>
<span class="keyword">for</span> icoord = 1:3 <span class="comment">% <span class="keyword">for</span> each coordinate</span>
    insideROIbox = insideROIbox ... the operator & (<span class="string">'and'</span>) enable to uncheck atoms beyond the bounds
        & Xframe.ATOMS{:,details.coords{icoord}}>=ROIbox(icoord,1) ...
        & Xframe.ATOMS{:,details.coords{icoord}}<=ROIbox(icoord,2);
<span class="keyword">end</span>
atomsROI = Xframe.ATOMS(insideROIbox,:); <span class="comment">% atom table <span class="keyword">for</span> only ROI atoms</span>

<span class="comment">% control</span>
<span class="comment">%{</span>
    figure, hold on, axis equal, view(3)
    plot3D(atomsROI{atomsROI.type==details.type.fluid,details.coords},<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(atomsROI{atomsROI.type==details.type.wall,details.coords},<span class="string">'co'</span>)
    plot3D(atomsROI{atomsROI.type==details.type.pillar,details.coords},<span class="string">'go'</span>)
    plot3D(atomsROI{atomsROI.type==details.type.sphere,details.coords},<span class="string">'rs'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
<span class="comment">%}</span>

<span class="comment">%% add PBC images (periodic boundary)</span>
XYZ = atomsROI{:,details.coords}; <span class="comment">% coordinates of ROI atoms</span>
vXYZ = atomsROI{:,details.vcoords}; <span class="comment">% coordinates of ROI atoms</span>
rhoXYZ = atomsROI.c_rho_smd;
[XYZimagesONLY ,indXimagesONLY]= PBCimages(XYZ,ROIbox,[true,false,true],ythick); <span class="comment">% add periodic images within zthick around x and z (y is not periodic)</span>
XYZwithImages = [XYZ;XYZimagesONLY]; <span class="comment">% all atoms including their images</span>
vXYZwithImages = [vXYZ;vXYZ(indXimagesONLY,:)]; <span class="comment">% all atoms including their images</span>
rhoXYZwithImages = [rhoXYZ;rhoXYZ(indXimagesONLY,:)];
isImages = true(size(XYZwithImages,1),1); isImages(1:size(XYZ,1))=false; <span class="comment">% true <span class="keyword">if</span> the atom is an image</span>

<span class="comment">% control - plot particle positions</span>
<span class="comment">%{</span>
    figure, hold on, axis equal, view(3)
    plot3D(XYZ(atomsROI.type==details.type.fluid,:),<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(XYZ(atomsROI.type==details.type.wall,:),<span class="string">'co'</span>)
    plot3D(XYZ(atomsROI.type==details.type.pillar,:),<span class="string">'go'</span>)
    plot3D(XYZ(atomsROI.type==details.type.sphere,:),<span class="string">'rs'</span>)
    <span class="comment">% add images with filled symbols</span>
    plot3D(XYZimagesONLY(atomsROI.isfluid(indXimagesONLY),:),<span class="string">'bo'</span>,<span class="string">'markersize'</span>,2,<span class="string">'markerfacecolor'</span>,<span class="string">'b'</span>)
    plot3D(XYZimagesONLY(atomsROI.iswall(indXimagesONLY),:),<span class="string">'co'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'c'</span>)
    plot3D(XYZimagesONLY(atomsROI.ispillar(indXimagesONLY),:),<span class="string">'go'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'g'</span>)
    plot3D(XYZimagesONLY(atomsROI.issphere(indXimagesONLY),:),<span class="string">'rs'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
<span class="comment">%}</span>

<span class="comment">% control - plot velocity field</span>
<span class="comment">%{</span>
    figure, hold on
    quiver3(XYZ(:,1),XYZ(:,2),XYZ(:,3),vXYZ(:,1),vXYZ(:,2),vXYZ(:,3))
    view(3), axis equal
<span class="comment">%}</span>

<span class="comment">%% determine the separation distance in simulation</span>
boxdims = ROIbox(:,2) - ROIbox(:,1);
Vbead_guess = prod(boxdims)/size(XYZ,1); <span class="comment">% m3</span>
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
[verletList,~,dmin] = buildVerletList(XYZ,cutoff); <span class="comment">% ~ means here that the 2nd output is not used</span>
rbead = dmin/2;
s = 2*rbead; <span class="comment">% separation distance</span>
h = 2*s;     <span class="comment">% smoothing length</span>


<span class="comment">%% add 3D Verlet list</span>
<span class="comment">% we focus on fluid atoms (only)</span>
XYZfluid = XYZ(atomsROI.isfluid,:);
natomsfluid = size(XYZfluid,1);
isfluidwithimages = [atomsROI.isfluid;atomsROI.isfluid(indXimagesONLY)];
XYZfluidwithimages = XYZwithImages(isfluidwithimages,:);
vXYZfluidwithImages = vXYZwithImages(isfluidwithimages,:);
isImagesfluid =  isImages & isfluidwithimages;
[Vfluidwithimages,cutoff,dmin] = buildVerletList(XYZfluidwithimages,1.2*h,[],[],[],isImagesfluid(isfluidwithimages),isImagesfluid(isfluidwithimages) & false);

<span class="comment">% control of neighboring particles or one </span>
<span class="comment">%{</span>
figure, hold on
<span class="keyword">for</span> itest = unidrnd(natomsfluid,1,100)
    plot3D(XYZfluidwithimages(~isImagesfluid(isfluidwithimages),:),<span class="string">'bo'</span>)
    plot3D(XYZfluidwithimages(isImagesfluid(isfluidwithimages),:),<span class="string">'bo'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'b'</span>)
    plot3D(XYZfluidwithimages(Vfluidwithimages{itest,:},:),<span class="string">'ro'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
    plot3D(XYZfluidwithimages(itest,:),<span class="string">'ko'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'k'</span>)
<span class="keyword">end</span>
view(3), axis equal
<span class="comment">%}</span>


<span class="comment">%% ForceLanshoff</span>
<span class="comment">% This pairwise force is an artificial force controlling the dissipation of velocity in the simulation</span>
<span class="comment">% its value is not stored in the simulation and it needs to be calculated from pairwise distances and</span>
<span class="comment">% relative velocities</span>

<span class="comment">% General syntax:</span>
<span class="comment">% [F,W] = forceLandshoff(XYZ,vXYZ,V,config)</span>
<span class="comment">% XYZ   : coordinates</span>
<span class="comment">% vXYZ  : velocities</span>
<span class="comment">% V     : corresponding Verlet list</span>
<span class="comment">% config: configuration <span class="keyword">for</span> Landshoff calculations based on the properties of the simulation</span>

c0 = 1500; <span class="comment">% speed of sound (m/s) % maxVelocity / MachTarget;</span>
dynamicViscosity = 0.13; <span class="comment">% Pa.s (viscosity to find)</span>
q1 = 1; <span class="comment">% 8 * dynamicViscosity / (hinformed*c0*rho);</span>
mbead = 4.38e-12; <span class="comment">% kg</span>
configL  = struct( ...real dynamic viscosity: rho * q1 * h * c0 / 8 (2D) or 10 (3D)
   <span class="string">'gradkernel'</span>, kernelSPH(h,<span class="string">'lucyder'</span>,3),...<span class="comment">% kernel gradient (note that h is bound with the kernel)</span>
            <span class="string">'h'</span>, h,...   smoothing length (m)
           <span class="string">'c0'</span>,1500,... speed of the sound (m/s)
           <span class="string">'q1'</span>,1,...    constant
          <span class="string">'rho'</span>, rhoXYZwithImages(isfluidwithimages), ... fluid density
         <span class="string">'mass'</span>, mbead,...  bead weight
          <span class="string">'vol'</span>, mbead./rhoXYZwithImages(isfluidwithimages), ...       bead volume (uniquely <span class="keyword">for</span> virial stress)
<span class="string">'repulsiononly'</span>, false ...    <span class="keyword">if</span> true, only Landshoff forces when dot(rij,vij)<0
    );
[Fwithimages,Wwithimages] = forceLandshoff(XYZfluidwithimages,vXYZfluidwithImages,Vfluidwithimages,configL);
wihtoutimages = ~isImagesfluid(isfluidwithimages);
Fland = Fwithimages(wihtoutimages,:); <span class="comment">% F Landshoff forces</span>
Wland = Wwithimages(wihtoutimages,:); <span class="comment">% corresponding Virial Stress Tensor</span>

<span class="comment">% plot the Landshoff forces acting on particles</span>
figure, hold on
plot3D(XYZfluid,<span class="string">'bo'</span>,<span class="string">'markersize'</span>,2)
quiver3(XYZfluid(:,1),XYZfluid(:,2),XYZfluid(:,3),Fland(:,1),Fland(:,2),Fland(:,3),<span class="string">'r-'</span>)
axis equal, view(3)
figure, histogram(log10(vecnorm(Fland,2,2))) <span class="comment">% magnitude of the force on a log10 scale</span>


<span class="comment">%% Interpolate Virial Stress along an xz vertical plane (as Han did)</span>
nresolution = [1024 1 1024];
xw = linspace(ROIbox(1,1),ROIbox(1,2),nresolution(1));
yw = ymean;
zw = linspace(ROIbox(3,1),ROIbox(3,2),nresolution(3)); <span class="comment">% vertical position used <span class="keyword">for</span> interpolation</span>
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];
VXYZgrid = buildVerletList({XYZgrid, XYZfluidwithimages}, 2*h);  <span class="comment">% neighbors = fluid particles</span>
W = kernelSPH(2*h, <span class="string">'lucy'</span>, 3); <span class="comment">% kernel expression</span>
Wgrid = zeros(prod(nresolution(1:3)), 9, <span class="string">'single'</span>);
<span class="keyword">for</span> i = 1:9 <span class="comment">% <span class="keyword">for</span> all diagonal terms</span>
    Wgrid(:,i) = interp3SPHVerlet(XYZfluidwithimages, Wwithimages(:,i), XYZgrid, VXYZgrid, W, mbead./rhoXYZwithImages(isfluidwithimages));
<span class="keyword">end</span>

<span class="comment">%% Interpolate the Velocity, extraction of the strain rate tensor</span>
vxyzgrid = zeros(prod(nresolution(1:3)),3,<span class="string">'single'</span>);
vxyzgridabove = vxyzgrid;
XYZgridabove = XYZgrid;
XYZgridabove(:,2) = XYZgridabove(:,2) + h; <span class="comment">% information along z</span>
<span class="keyword">for</span> i = 1:3
    vxyzgrid(:,i) = interp3SPHVerlet(XYZfluidwithimages,vXYZfluidwithImages(:,i),XYZgrid,VXYZgrid,W,mbead./rhoXYZwithImages(isfluidwithimages));
    vxyzgridabove(:,i) = interp3SPHVerlet(XYZfluidwithimages,vXYZfluidwithImages(:,i),XYZgridabove,VXYZgrid,W,mbead./rhoXYZwithImages(isfluidwithimages));
<span class="keyword">end</span>
gxy = reshape( (vxyzgridabove(:,1) - vxyzgrid(:,1)) / h, nresolution(1:3));
gyy = reshape( (vxyzgridabove(:,2) - vxyzgrid(:,2)) / h, nresolution(1:3));
gzy = reshape( (vxyzgridabove(:,3) - vxyzgrid(:,3)) / h, nresolution(1:3));
[gxx,gxz] = gradient(reshape(vxyzgrid(:,1),nresolution([1 3])),Xw(1,2,1)-Xw(1,1,1),Zw(1,1,2)-Zw(1,1,1));
[gyx,gyz] = gradient(reshape(vxyzgrid(:,2),nresolution([1 3])),Xw(1,2,1)-Xw(1,1,1),Zw(1,1,2)-Zw(1,1,1));
[gzx,gzz] = gradient(reshape(vxyzgrid(:,3),nresolution([1 3])),Xw(1,2,1)-Xw(1,1,1),Zw(1,1,2)-Zw(1,1,1));
Ggrid = [gxx(:) gxy(:) gxz(:) gyx(:) gyy(:) gyz(:) gzx(:) gzy(:) gzz(:)]; <span class="comment">% nine tensor components</span>

<span class="comment">% Velocity control</span>
<span class="comment">%{</span>
figure, hold on
step = 16; [ix,iy,iz] = meshgrid(1:step:nresolution(1),1,1:step:nresolution(3)); indok = sub2ind(nresolution,ix,iy,iz);
quiver3(XYZgrid(indok,1),XYZgrid(indok,2),XYZgrid(indok,3),vxyzgrid(indok,1),vxyzgrid(indok,2),vxyzgrid(indok,3),<span class="string">'b-'</span>)

quiver3(XYZgridabove(:,1),XYZgridabove(:,2),XYZgridabove(:,3),vxyzgridabove(:,1),vxyzgridabove(:,2),vxyzgridabove(:,3),<span class="string">'g-'</span>)
<span class="comment">%}</span>

<span class="comment">%% save</span>
backfolder = <span class="string">'D:\Yao'</span>;
<span class="keyword">if</span> exist(backfolder,<span class="string">'dir'</span>) 
    prefetchresult = sprintf(<span class="string">'YAO_xz_t<span class="comment">%0.3g_y%0.3g'</span>,tframe*1e2,ymean*1e6);</span>
    save(fullfile(backfolder,prefetchresult))
<span class="keyword">end</span>

<span class="comment">%% Symmetric Strain</span>
Straingrid = [gxx(:) 0.5*(gxy(:)+gyx(:)) 0.5*(gxz(:)+gzx(:))   0.5*(gxy(:)+gyx(:))  gyy(:) 0.5*(gyz(:)+gzy(:))  0.5*(gxz(:)+gzx(:))  0.5*(gyz(:)+gzy(:)) gzz(:)];
formatfig(figure,<span class="string">'figname'</span>,sprintf(<span class="string">'Yao_xz_SHEAR_t<span class="comment">%d_y%d'</span>,round(tframe*100),round(ymean*1e6)))</span>
hs2 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,<span class="string">'alive'</span>,offdiag);</span>
leg = {<span class="string">'\epsilon_{xx}'</span>,<span class="string">'\epsilon_{xy}'</span>,<span class="string">'\epsilon_{xz}'</span>,<span class="string">'\epsilon_{yx}'</span>,<span class="string">'\epsilon_{yy}'</span>,<span class="string">'\epsilon_{yz}'</span>,<span class="string">'\epsilon_{zx}'</span>,<span class="string">'\epsilon_{zy}'</span>,<span class="string">'\epsilon_{zz}'</span>};
<span class="keyword">for</span> i=1:9
    subplot(hs2(i)), imagesc(flipud(reshape(Straingrid(:,i),nresolution([1 3]))<span class="string">'))
    c=colorbar; <span class="keyword">if</span> i==7, c.Label.String = '</span>strain rate (s^{-1})<span class="string">'; <span class="keyword">end</span>
    axis image
    caxis([-5 5])
    title(leg{i},'</span>fontsize<span class="string">',12,'</span>visible<span class="string">','</span>on<span class="string">')
<span class="keyword">end</span>
set(hs2,'</span>visible<span class="string">','</span>off<span class="string">')
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)


<span class="comment">%% Stress Tensor</span>
formatfig(figure,'</span>figname<span class="string">',sprintf('</span>Yao_xz_STRESS_t<span class="comment">%d_y%d<span class="string">',round(tframe*100),round(ymean*1e6)))</span>
hs1 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,'</span>alive<span class="string">',offdiag);</span>
leg = {'</span>\tau_{xx}<span class="string">','</span>\tau_{xy}<span class="string">','</span>\tau_{xz}<span class="string">','</span>\tau_{yx}<span class="string">','</span>\tau_{yy}<span class="string">','</span>\tau_{yz}<span class="string">','</span>\tau_{zx}<span class="string">','</span>\tau_{zy}<span class="string">','</span>\tau_{zz}<span class="string">'};
<span class="keyword">for</span> i=1:9
    subplot(hs1(i)), imagesc(flipud(reshape(Wgrid(:,i),nresolution([1 3]))'</span>))
    c=colorbar; <span class="keyword">if</span> i==7, c.Label.String = <span class="string">'stress (Pa)'</span>; <span class="keyword">end</span>
    axis image
    caxis([-0.1 0.8])
    title(leg{i},<span class="string">'fontsize'</span>,12,<span class="string">'visible'</span>,<span class="string">'on'</span>)
<span class="keyword">end</span>
set(hs1,<span class="string">'visible'</span>,<span class="string">'off'</span>)
print_png(400,fullfile(backfolder,get(gcf,<span class="string">'filename'</span>)),<span class="string">''</span>,<span class="string">''</span>,0,0,0)


<span class="comment">%% Viscosity estimation</span>
Egrid = 0.5*abs(Wgrid./Straingrid);
formatfig(figure,<span class="string">'figname'</span>,sprintf(<span class="string">'Yao_xz_VISCO_t<span class="comment">%d_y%d'</span>,round(tframe*100),round(ymean*1e6)))</span>
hs1 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,<span class="string">'alive'</span>,offdiag);</span>
leg = {<span class="string">'\mu_{xx}'</span>,<span class="string">'\mu_{xy}'</span>,<span class="string">'\mu_{xz}'</span>,<span class="string">'\mu_{yx}'</span>,<span class="string">'\mu_{yy}'</span>,<span class="string">'\mu_{yz}'</span>,<span class="string">'\mu_{zx}'</span>,<span class="string">'\mu_{zy}'</span>,<span class="string">'\mu_{zz}'</span>};
<span class="keyword">for</span> i=1:9
    subplot(hs1(i)), imagesc(flipud(reshape(Egrid(:,i),nresolution([1 3]))<span class="string">'))
    c=colorbar; <span class="keyword">if</span> i==7, c.Label.String = '</span>viscosity (Pa\cdot s)<span class="string">'; <span class="keyword">end</span>
    axis image
    caxis([0 0.4])
    title(leg{i},'</span>fontsize<span class="string">',12,'</span>visible<span class="string">','</span>on<span class="string">')
<span class="keyword">end</span>
set(hs1,'</span>visible<span class="string">','</span>off<span class="string">')
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)



<span class="comment">%% plot stress results</span>
close all
offdiag = [2 3 4 6 7 8];
figstresstensor = figure;
figsheartensor = figure;
figviscosity = figure;
formatfig(figstresstensor,'</span>figname<span class="string">',sprintf('</span>STRESS_xz_t<span class="comment">%d_z%d<span class="string">',round(tframe*100),round(yw*1e6)))</span>
formatfig(figsheartensor,'</span>figname<span class="string">',sprintf('</span>SHEAR_xz_t<span class="comment">%d_z%d<span class="string">',round(tframe*100),round(yw*1e6)))</span>
formatfig(figviscosity,'</span>figname<span class="string">',sprintf('</span>VISCO_xz_t<span class="comment">%d_z%d<span class="string">',round(tframe*100),round(yw*1e6)))</span>

figure(figstresstensor), hs1 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,'</span>alive<span class="string">',offdiag);</span>
figure(figsheartensor), hs2 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,'</span>alive<span class="string">',offdiag);</span>
figure(figviscosity), hs3 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,'</span>alive<span class="string">',offdiag);</span>
[Wmin,Wmax,Gmin,Gmax,Emin,Emax] = deal(+Inf,-Inf,+Inf,-Inf,+Inf,-Inf);
<span class="keyword">for</span> i=1:9
    figure(figstresstensor), subplot(hs1(i)), imagesc(flipud(reshape(Wgrid(:,i),nresolution([1 3]))'</span>)), colorbar
    figure(figsheartensor), subplot(hs2(i)), imagesc(flipud(reshape(Ggrid(:,i),nresolution([1 3]))<span class="string">')), colorbar
    figure(figviscosity), subplot(hs3(i)), imagesc(flipud(reshape(Egrid(:,i),nresolution([1 3]))'</span>)), colorbar
    Wmin = min(Wmin,min(Wgrid(:,i)));
    Wmax = max(Wmax,max(Wgrid(:,i)));
    Gmin = min(Wmin,min(Ggrid(:,i)));
    Gmax = max(Wmax,max(Ggrid(:,i)));
    Emin = min(Wmin,min(Egrid(:,i)));
    Emax = max(Wmax,max(Egrid(:,i)));
<span class="keyword">end</span>
set(hs1,<span class="string">'visible'</span>,<span class="string">'off'</span>)
set(hs2,<span class="string">'visible'</span>,<span class="string">'off'</span>)
set(hs3,<span class="string">'visible'</span>,<span class="string">'off'</span>)
<span class="keyword">for</span> i=1:9
    figure(figstresstensor), subplot(hs1(i)), clim([Wmin Wmax])
    figure(figsheartensor), subplot(hs1(i)), clim([Gmin Gmax])
    figure(figviscosity), subplot(hs1(i)), clim([Emin Emax])
<span class="keyword">end</span>
set(hs3,<span class="string">'clim'</span>,[0.01 10 ])

<span class="comment">% plot </span>
figsumall = figure;
formatfig(figsumall,<span class="string">'figname'</span>,sprintf(<span class="string">'STRESS_sumoff_t<span class="comment">%d_z%d'</span>,round(tframe*100)))</span>
title(<span class="string">'all off-diagonal terms are added'</span>)
imagesc(flipud(reshape(sum(Wgrid(:,offdiag),2),nresolution([1 3]))<span class="string">'))

<span class="comment">%% print </span>
outputfolder = '</span>YAOresults<span class="string">';
<span class="keyword">if</span> ~exist(outputfolder,'</span>dir<span class="string">'), mkdir(outputfolder), <span class="keyword">end</span>
 figure(figstresstensor)
 print_pdf(300,[get(figstresstensor,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') <span class="comment">% PDF 300 dpi</span>
 print_png(300,fullfile(outputfolder,get(figstresstensor,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)
 figure(figsheartensor)
 print_pdf(300,[get(figsheartensor,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') <span class="comment">% PDF 300 dpi</span>
 print_png(300,fullfile(outputfolder,get(figsheartensor,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)
 figure(figviscosity)
 print_pdf(300,[get(figviscosity,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') <span class="comment">% PDF 300 dpi</span>
 print_png(300,fullfile(outputfolder,get(figviscosity,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)
figure(figsumall)
 print_pdf(300,[get(figsumall,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') <span class="comment">% PDF 300 dpi</span>
 print_png(300,fullfile(outputfolder,get(figsumall,'</span>filename<span class="string">')),'</span><span class="string">','</span>',0,0,0)</code></pre></div>
</div>
<div id='yao_stress_vertical_yz' class='doc-content' style='display: none;'>
<h1>Template for Yao</h1>
<h2>Authors</h2>
<p>INRAE\Olivier Vitrac, INRAE\Yao Liu</p>
<h2>Authors</h2>
<p>The work is based on the simulation of Billy (publication so-called pizza2, and series Thomazo_v2)<br/>The dataset is accessible on lab PCs via yao_initialization(tframe)<br/>tframe should be chosen among 0.11:0.01:1.11 (0.11, 0.12, 0.13, ... 1.11 s)<br/>The data corresponding to tframe and additional details are accessible via<br/>[Xframe,details] = yao_initialization(tframe)<br/>Due to the many depencies with pizza3, the code needs to be run from : Thomazo_v2\</p>
<h2>Authors</h2>
<p>Revision history<br/>2024-05-03 early version<br/>2024-05-05 ROI with PBC implemented<br/>2024-05-06 shear stress and shear rate implementated on a two 2D 1024*1024 grids separated by h</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">% Template <span class="keyword">for</span> Yao</span>
<span class="comment">%</span>
<span class="comment">%   Authors: INRAE\Olivier Vitrac, INRAE\Yao Liu</span>
<span class="comment">%</span>
<span class="comment">% The work is based on the simulation of Billy (publication so-called pizza2, and series Thomazo_v2)</span>
<span class="comment">% The dataset is accessible on lab PCs via yao_initialization(tframe)</span>
<span class="comment">% tframe should be chosen among 0.11:0.01:1.11 (0.11, 0.12, 0.13, ... 1.11 s)</span>
<span class="comment">% The data corresponding to tframe and additional details are accessible via</span>
<span class="comment">%     [Xframe,details] = yao_initialization(tframe)</span>
<span class="comment">% Due to the many depencies with pizza3, the code needs to be run from : Thomazo_v2\</span>
<span class="comment">% </span>
<span class="comment">% Revision history</span>
<span class="comment">% 2024-05-03 early version</span>
<span class="comment">% 2024-05-05 ROI with PBC implemented</span>
<span class="comment">% 2024-05-06 shear stress and shear rate implementated on a two 2D 1024*1024 grids separated by h</span>


<span class="comment">%% The code is split in blocks starting with "%%", they can be run independently</span>
<span class="comment">% by pressing CTRL+Enter or by choosing Run Section.</span>
<span class="comment">% The entire script can be run by pressing F5 or by choosing Run</span>
<span class="comment">%</span>
<span class="comment">% Control sections are enclosed between "%{ ... %}", they can be run by selecting</span>
<span class="comment">% the code between {} and by pressing F9 or by using the mouse right click and by</span>
<span class="comment">% choosing Evaluating the selection.</span>
<span class="comment">%</span>
<span class="comment">% visualization of the full dataset as a movie</span>
<span class="comment">%{</span>
clf,
coords = {<span class="string">'z'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>};
<span class="keyword">for</span> tframe = 0.11:0.01:1.11
    Xframe = yao_initialization(tframe);
    clf, hold on, axis equal, view(3)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==1,coords},<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==2,coords},<span class="string">'co'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==3,coords},<span class="string">'go'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==4,coords},<span class="string">'rs'</span>)
    drawnow
<span class="keyword">end</span>
<span class="comment">%}</span>


<span class="comment">%% load the frame</span>
tframe = 0.67; <span class="comment">% choose any frame between 0.11 and 1.11</span>
[Xframe,details] = yao_initialization(tframe);
pillarxyz = Xframe.ATOMS{Xframe.ATOMS.ispillar,details.coords};
<span class="comment">% control</span>
<span class="comment">%{</span>
    figure, hold on, axis equal, view(3)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.fluid,details.coords},<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.wall,details.coords},<span class="string">'co'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.pillar,details.coords},<span class="string">'go'</span>)
    plot3D(Xframe.ATOMS{Xframe.ATOMS.type==details.type.sphere,details.coords},<span class="string">'rs'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
<span class="comment">%}</span>


<span class="comment">%% Selection of the thick plane or ROI (region of interest)</span>
xmean = mean(pillarxyz(:,1)); <span class="comment">% mean y coord of the pillar</span>
xthick = xmean*0.15*5;          <span class="comment">% define the thickness of the plane around ztop</span>
ROIbox = details.box;      <span class="comment">% select the ROI (region of interest)</span>
ROIbox(1,:) = xmean + [-0.5 +0.5]*xthick; <span class="comment">% update the ROI to ztop-zthick/2 and ztop+zthick/2</span>
insideROIbox = true(height(Xframe.ATOMS),1); <span class="comment">% boolean flag (by default all atoms are considered in ROI)</span>
<span class="keyword">for</span> icoord = 1:3 <span class="comment">% <span class="keyword">for</span> each coordinate</span>
    insideROIbox = insideROIbox ... the operator & (<span class="string">'and'</span>) enable to uncheck atoms beyond the bounds
        & Xframe.ATOMS{:,details.coords{icoord}}>=ROIbox(icoord,1) ...
        & Xframe.ATOMS{:,details.coords{icoord}}<=ROIbox(icoord,2);
<span class="keyword">end</span>
atomsROI = Xframe.ATOMS(insideROIbox,:); <span class="comment">% atom table <span class="keyword">for</span> only ROI atoms</span>

<span class="comment">% control</span>
<span class="comment">%{</span>
    figure, hold on, axis equal, view(3)
    plot3D(atomsROI{atomsROI.type==details.type.fluid,details.coords},<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(atomsROI{atomsROI.type==details.type.wall,details.coords},<span class="string">'co'</span>)
    plot3D(atomsROI{atomsROI.type==details.type.pillar,details.coords},<span class="string">'go'</span>)
    plot3D(atomsROI{atomsROI.type==details.type.sphere,details.coords},<span class="string">'rs'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
<span class="comment">%}</span>

<span class="comment">%% add PBC images (periodic boundary)</span>
XYZ = atomsROI{:,details.coords}; <span class="comment">% coordinates of ROI atoms</span>
vXYZ = atomsROI{:,details.vcoords}; <span class="comment">% coordinates of ROI atoms</span>
rhoXYZ = atomsROI.c_rho_smd;
[XYZimagesONLY ,indXimagesONLY]= PBCimages(XYZ,ROIbox,[false,true,true],xthick); <span class="comment">% add periodic images within zthick around x and z (y is not periodic)</span>
XYZwithImages = [XYZ;XYZimagesONLY]; <span class="comment">% all atoms including their images</span>
vXYZwithImages = [vXYZ;vXYZ(indXimagesONLY,:)]; <span class="comment">% all atoms including their images</span>
rhoXYZwithImages = [rhoXYZ;rhoXYZ(indXimagesONLY,:)];
isImages = true(size(XYZwithImages,1),1); isImages(1:size(XYZ,1))=false; <span class="comment">% true <span class="keyword">if</span> the atom is an image</span>

<span class="comment">% control - plot particle positions</span>
<span class="comment">%{</span>
    figure, hold on, axis equal, view(3)
    plot3D(XYZ(atomsROI.type==details.type.fluid,:),<span class="string">'b.'</span>,<span class="string">'markersize'</span>,2)
    plot3D(XYZ(atomsROI.type==details.type.wall,:),<span class="string">'co'</span>)
    plot3D(XYZ(atomsROI.type==details.type.pillar,:),<span class="string">'go'</span>)
    plot3D(XYZ(atomsROI.type==details.type.sphere,:),<span class="string">'rs'</span>)
    <span class="comment">% add images with filled symbols</span>
    plot3D(XYZimagesONLY(atomsROI.isfluid(indXimagesONLY),:),<span class="string">'bo'</span>,<span class="string">'markersize'</span>,2,<span class="string">'markerfacecolor'</span>,<span class="string">'b'</span>)
    plot3D(XYZimagesONLY(atomsROI.iswall(indXimagesONLY),:),<span class="string">'co'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'c'</span>)
    plot3D(XYZimagesONLY(atomsROI.ispillar(indXimagesONLY),:),<span class="string">'go'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'g'</span>)
    plot3D(XYZimagesONLY(atomsROI.issphere(indXimagesONLY),:),<span class="string">'rs'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
<span class="comment">%}</span>

<span class="comment">% control - plot velocity field</span>
<span class="comment">%{</span>
    figure, hold on
    quiver3(XYZ(:,1),XYZ(:,2),XYZ(:,3),vXYZ(:,1),vXYZ(:,2),vXYZ(:,3))
    view(3), axis equal
<span class="comment">%}</span>

<span class="comment">%% determine the separation distance in simulation</span>
boxdims = ROIbox(:,2) - ROIbox(:,1);
Vbead_guess = prod(boxdims)/size(XYZ,1); <span class="comment">% m3</span>
rbead_guess = (3/(4*pi)*Vbead_guess)^(1/3);
cutoff = 3*rbead_guess;
[verletList,~,dmin] = buildVerletList(XYZ,cutoff); <span class="comment">% ~ means here that the 2nd output is not used</span>
rbead = dmin/2;
s = 2*rbead; <span class="comment">% separation distance</span>
h = 2*s;     <span class="comment">% smoothing length</span>


<span class="comment">%% add 3D Verlet list</span>
<span class="comment">% we focus on fluid atoms (only)</span>
XYZfluid = XYZ(atomsROI.isfluid,:);
natomsfluid = size(XYZfluid,1);
isfluidwithimages = [atomsROI.isfluid;atomsROI.isfluid(indXimagesONLY)];
XYZfluidwithimages = XYZwithImages(isfluidwithimages,:);
vXYZfluidwithImages = vXYZwithImages(isfluidwithimages,:);
isImagesfluid =  isImages & isfluidwithimages;
[Vfluidwithimages,cutoff,dmin] = buildVerletList(XYZfluidwithimages,1.2*h,[],[],[],isImagesfluid(isfluidwithimages),isImagesfluid(isfluidwithimages) & false);

<span class="comment">% control of neighboring particles or one </span>
<span class="comment">%{</span>
figure, hold on
<span class="keyword">for</span> itest = unidrnd(natomsfluid,1,100)
    plot3D(XYZfluidwithimages(~isImagesfluid(isfluidwithimages),:),<span class="string">'bo'</span>)
    plot3D(XYZfluidwithimages(isImagesfluid(isfluidwithimages),:),<span class="string">'bo'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'b'</span>)
    plot3D(XYZfluidwithimages(Vfluidwithimages{itest,:},:),<span class="string">'ro'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'r'</span>)
    plot3D(XYZfluidwithimages(itest,:),<span class="string">'ko'</span>,<span class="string">'markerfacecolor'</span>,<span class="string">'k'</span>)
<span class="keyword">end</span>
view(3), axis equal
<span class="comment">%}</span>


<span class="comment">%% ForceLanshoff</span>
<span class="comment">% This pairwise force is an artificial force controlling the dissipation of velocity in the simulation</span>
<span class="comment">% its value is not stored in the simulation and it needs to be calculated from pairwise distances and</span>
<span class="comment">% relative velocities</span>

<span class="comment">% General syntax:</span>
<span class="comment">% [F,W] = forceLandshoff(XYZ,vXYZ,V,config)</span>
<span class="comment">% XYZ   : coordinates</span>
<span class="comment">% vXYZ  : velocities</span>
<span class="comment">% V     : corresponding Verlet list</span>
<span class="comment">% config: configuration <span class="keyword">for</span> Landshoff calculations based on the properties of the simulation</span>

c0 = 1500; <span class="comment">% speed of sound (m/s) % maxVelocity / MachTarget;</span>
dynamicViscosity = 0.13; <span class="comment">% Pa.s (viscosity to find)</span>
q1 = 1; <span class="comment">% 8 * dynamicViscosity / (hinformed*c0*rho);</span>
mbead = 4.38e-12; <span class="comment">% kg</span>
configL  = struct( ...real dynamic viscosity: rho * q1 * h * c0 / 8 (2D) or 10 (3D)
   <span class="string">'gradkernel'</span>, kernelSPH(h,<span class="string">'lucyder'</span>,3),...<span class="comment">% kernel gradient (note that h is bound with the kernel)</span>
            <span class="string">'h'</span>, h,...   smoothing length (m)
           <span class="string">'c0'</span>,1500,... speed of the sound (m/s)
           <span class="string">'q1'</span>,1,...    constant
          <span class="string">'rho'</span>, rhoXYZwithImages(isfluidwithimages), ... fluid density
         <span class="string">'mass'</span>, mbead,...  bead weight
          <span class="string">'vol'</span>, mbead./rhoXYZwithImages(isfluidwithimages), ...       bead volume (uniquely <span class="keyword">for</span> virial stress)
<span class="string">'repulsiononly'</span>, false ...    <span class="keyword">if</span> true, only Landshoff forces when dot(rij,vij)<0
    );
[Fwithimages,Wwithimages] = forceLandshoff(XYZfluidwithimages,vXYZfluidwithImages,Vfluidwithimages,configL);
wihtoutimages = ~isImagesfluid(isfluidwithimages);
Fland = Fwithimages(wihtoutimages,:); <span class="comment">% F Landshoff forces</span>
Wland = Wwithimages(wihtoutimages,:); <span class="comment">% corresponding Virial Stress Tensor</span>

<span class="comment">% plot the Landshoff forces acting on particles</span>
figure, hold on
plot3D(XYZfluid,<span class="string">'bo'</span>,<span class="string">'markersize'</span>,2)
quiver3(XYZfluid(:,1),XYZfluid(:,2),XYZfluid(:,3),Fland(:,1),Fland(:,2),Fland(:,3),<span class="string">'r-'</span>)
axis equal, view(3)
figure, histogram(log10(vecnorm(Fland,2,2))) <span class="comment">% magnitude of the force on a log10 scale</span>


<span class="comment">%% Interpolate Virial Stress along an xz vertical plane (as Han did)</span>
nresolution = [1 1024 1024];
xw = xmean;
yw = linspace(ROIbox(2,1),ROIbox(2,2),nresolution(2));
zw = linspace(ROIbox(3,1),ROIbox(3,2),nresolution(3)); <span class="comment">% vertical position used <span class="keyword">for</span> interpolation</span>
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
XYZgrid = [Xw(:),Yw(:),Zw(:)];
VXYZgrid = buildVerletList({XYZgrid, XYZfluidwithimages}, 2*h);  <span class="comment">% neighbors = fluid particles</span>
W = kernelSPH(2*h, <span class="string">'lucy'</span>, 3); <span class="comment">% kernel expression</span>
Wgrid = zeros(prod(nresolution(1:3)), 9, <span class="string">'single'</span>);
<span class="keyword">for</span> i = 1:9 <span class="comment">% <span class="keyword">for</span> all diagonal terms</span>
    Wgrid(:,i) = interp3SPHVerlet(XYZfluidwithimages, Wwithimages(:,i), XYZgrid, VXYZgrid, W, mbead./rhoXYZwithImages(isfluidwithimages));
<span class="keyword">end</span>

<span class="comment">%% Interpolate the Velocity, extraction of the strain rate tensor</span>
vxyzgrid = zeros(prod(nresolution(1:3)),3,<span class="string">'single'</span>);
vxyzgridabove = vxyzgrid;
XYZgridabove = XYZgrid;
XYZgridabove(:,1) = XYZgridabove(:,1) + h; <span class="comment">% information along z</span>
<span class="keyword">for</span> i = 1:3
    vxyzgrid(:,i) = interp3SPHVerlet(XYZfluidwithimages,vXYZfluidwithImages(:,i),XYZgrid,VXYZgrid,W,mbead./rhoXYZwithImages(isfluidwithimages));
    vxyzgridabove(:,i) = interp3SPHVerlet(XYZfluidwithimages,vXYZfluidwithImages(:,i),XYZgridabove,VXYZgrid,W,mbead./rhoXYZwithImages(isfluidwithimages));
<span class="keyword">end</span>
gxx = reshape( (vxyzgridabove(:,1) - vxyzgrid(:,1)) / h, nresolution(1:3));
gyx = reshape( (vxyzgridabove(:,2) - vxyzgrid(:,2)) / h, nresolution(1:3));
gzx = reshape( (vxyzgridabove(:,3) - vxyzgrid(:,3)) / h, nresolution(1:3));
[gxy,gxz] = gradient(reshape(vxyzgrid(:,1),nresolution([2 3])),Yw(2,1,1)-Xw(1,1,1),Zw(1,1,2)-Zw(1,1,1));
[gyy,gyz] = gradient(reshape(vxyzgrid(:,2),nresolution([2 3])),Yw(2,1,1)-Xw(1,1,1),Zw(1,1,2)-Zw(1,1,1));
[gzy,gzz] = gradient(reshape(vxyzgrid(:,3),nresolution([2 3])),Yw(2,1,1)-Xw(1,1,1),Zw(1,1,2)-Zw(1,1,1));
Ggrid = [gxx(:) gxy(:) gxz(:) gyx(:) gyy(:) gyz(:) gzx(:) gzy(:) gzz(:)]; <span class="comment">% nine tensor components</span>

<span class="comment">% Velocity control</span>
<span class="comment">%{</span>
figure, hold on
step = 16; [ix,iy,iz] = meshgrid(1,1:step:nresolution(2),1:step:nresolution(3)); indok = sub2ind(nresolution,ix,iy,iz);
quiver3(XYZgrid(indok,1),XYZgrid(indok,2),XYZgrid(indok,3),vxyzgrid(indok,1),vxyzgrid(indok,2),vxyzgrid(indok,3),<span class="string">'g-'</span>)

quiver3(XYZgridabove(:,1),XYZgridabove(:,2),XYZgridabove(:,3),vxyzgridabove(:,1),vxyzgridabove(:,2),vxyzgridabove(:,3),<span class="string">'g-'</span>)
<span class="comment">%}</span>

<span class="comment">%% save</span>
backfolder = <span class="string">'D:\Yao'</span>;
<span class="keyword">if</span> exist(backfolder,<span class="string">'dir'</span>) 
    prefetchresult = sprintf(<span class="string">'YAO_yz_t<span class="comment">%0.3g_x%0.3g'</span>,tframe*1e2,xmean*1e6);</span>
    save(fullfile(backfolder,prefetchresult))
<span class="keyword">end</span>

<span class="comment">%% Symmetric Strain</span>
Straingrid = [gxx(:) 0.5*(gxy(:)+gyx(:)) 0.5*(gxz(:)+gzx(:))   0.5*(gxy(:)+gyx(:))  gyy(:) 0.5*(gyz(:)+gzy(:))  0.5*(gxz(:)+gzx(:))  0.5*(gyz(:)+gzy(:)) gzz(:)];
formatfig(figure,<span class="string">'figname'</span>,sprintf(<span class="string">'Yao_yz_SHEAR_t<span class="comment">%d_x%d'</span>,round(tframe*100),round(xmean*1e6)))</span>
hs2 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,<span class="string">'alive'</span>,offdiag);</span>
leg = {<span class="string">'\epsilon_{xx}'</span>,<span class="string">'\epsilon_{xy}'</span>,<span class="string">'\epsilon_{xz}'</span>,<span class="string">'\epsilon_{yx}'</span>,<span class="string">'\epsilon_{yy}'</span>,<span class="string">'\epsilon_{yz}'</span>,<span class="string">'\epsilon_{zx}'</span>,<span class="string">'\epsilon_{zy}'</span>,<span class="string">'\epsilon_{zz}'</span>};
<span class="keyword">for</span> i=1:9
    subplot(hs2(i)), imagesc(flipud(reshape(Straingrid(:,i),nresolution([2 3]))<span class="string">'))
    c=colorbar; <span class="keyword">if</span> i==7, c.Label.String = '</span>strain rate (s^{-1})<span class="string">'; <span class="keyword">end</span>
    axis image
    caxis([-5 5])
    title(leg{i},'</span>fontsize<span class="string">',12,'</span>visible<span class="string">','</span>on<span class="string">')
<span class="keyword">end</span>
set(hs2,'</span>visible<span class="string">','</span>off<span class="string">')
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)

<span class="comment">%% Stress</span>
formatfig(figure,'</span>figname<span class="string">',sprintf('</span>Yao_yz_STRESS_t<span class="comment">%d_x%d<span class="string">',round(tframe*100),round(xmean*1e6)))</span>
hs1 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,'</span>alive<span class="string">',offdiag);</span>
leg = {'</span>\tau_{xx}<span class="string">','</span>\tau_{xy}<span class="string">','</span>\tau_{xz}<span class="string">','</span>\tau_{yx}<span class="string">','</span>\tau_{yy}<span class="string">','</span>\tau_{yz}<span class="string">','</span>\tau_{zx}<span class="string">','</span>\tau_{zy}<span class="string">','</span>\tau_{zz}<span class="string">'};
<span class="keyword">for</span> i=1:9
    subplot(hs1(i)), imagesc(flipud(reshape(Straingrid(:,i),nresolution([2 3]))'</span>))
    c=colorbar; <span class="keyword">if</span> i==7, c.Label.String = <span class="string">'stress (Pa)'</span>; <span class="keyword">end</span>
    axis image
    caxis([-0.1 0.8])
    title(leg{i},<span class="string">'fontsize'</span>,12,<span class="string">'visible'</span>,<span class="string">'on'</span>)
<span class="keyword">end</span>
set(hs1,<span class="string">'visible'</span>,<span class="string">'off'</span>)
print_png(400,fullfile(backfolder,get(gcf,<span class="string">'filename'</span>)),<span class="string">''</span>,<span class="string">''</span>,0,0,0)

<span class="comment">%% Viscosity estimation</span>
Egrid = 0.5*abs(Wgrid./Straingrid);
formatfig(figure,<span class="string">'figname'</span>,sprintf(<span class="string">'Yao_yz_VISCO_t<span class="comment">%d_x%d'</span>,round(tframe*100),round(xmean*1e6)))</span>
hs1 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,<span class="string">'alive'</span>,offdiag);</span>
leg = {<span class="string">'\mu_{xx}'</span>,<span class="string">'\mu_{xy}'</span>,<span class="string">'\mu_{xz}'</span>,<span class="string">'\mu_{yx}'</span>,<span class="string">'\mu_{yy}'</span>,<span class="string">'\mu_{yz}'</span>,<span class="string">'\mu_{zx}'</span>,<span class="string">'\mu_{zy}'</span>,<span class="string">'\mu_{zz}'</span>};
<span class="keyword">for</span> i=1:9
    subplot(hs1(i)), imagesc(flipud(reshape(Egrid(:,i),nresolution([2 3]))<span class="string">'))
    c=colorbar; <span class="keyword">if</span> i==7, c.Label.String = '</span>viscosity (Pa\cdot s)<span class="string">'; <span class="keyword">end</span>
    axis image
    caxis([0 0.4])
    title(leg{i},'</span>fontsize<span class="string">',12,'</span>visible<span class="string">','</span>on<span class="string">')
<span class="keyword">end</span>
set(hs1,'</span>visible<span class="string">','</span>off<span class="string">')
print_png(400,fullfile(backfolder,get(gcf,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)

<span class="comment">%% plot stress results</span>
close all
offdiag = [2 3 4 6 7 8];
figstresstensor = figure;
figsheartensor = figure;
figviscosity = figure;
formatfig(figstresstensor,'</span>figname<span class="string">',sprintf('</span>STRESS_xz_t<span class="comment">%d_z%d<span class="string">',round(tframe*100),round(yw*1e6)))</span>
formatfig(figsheartensor,'</span>figname<span class="string">',sprintf('</span>SHEAR_xz_t<span class="comment">%d_z%d<span class="string">',round(tframe*100),round(yw*1e6)))</span>
formatfig(figviscosity,'</span>figname<span class="string">',sprintf('</span>VISCO_xz_t<span class="comment">%d_z%d<span class="string">',round(tframe*100),round(yw*1e6)))</span>

figure(figstresstensor), hs1 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,'</span>alive<span class="string">',offdiag);</span>
figure(figsheartensor), hs2 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,'</span>alive<span class="string">',offdiag);</span>
figure(figviscosity), hs3 = subplots([1 1 1],[1 1 1],0.01,0.01); <span class="comment">%,'</span>alive<span class="string">',offdiag);</span>
[Wmin,Wmax,Gmin,Gmax,Emin,Emax] = deal(+Inf,-Inf,+Inf,-Inf,+Inf,-Inf);
<span class="keyword">for</span> i=1:9
    figure(figstresstensor), subplot(hs1(i)), imagesc(flipud(reshape(Wgrid(:,i),nresolution([1 3]))'</span>)), colorbar
    figure(figsheartensor), subplot(hs2(i)), imagesc(flipud(reshape(Ggrid(:,i),nresolution([1 3]))<span class="string">')), colorbar
    figure(figviscosity), subplot(hs3(i)), imagesc(flipud(reshape(Egrid(:,i),nresolution([1 3]))'</span>)), colorbar
    Wmin = min(Wmin,min(Wgrid(:,i)));
    Wmax = max(Wmax,max(Wgrid(:,i)));
    Gmin = min(Wmin,min(Ggrid(:,i)));
    Gmax = max(Wmax,max(Ggrid(:,i)));
    Emin = min(Wmin,min(Egrid(:,i)));
    Emax = max(Wmax,max(Egrid(:,i)));
<span class="keyword">end</span>
set(hs1,<span class="string">'visible'</span>,<span class="string">'off'</span>)
set(hs2,<span class="string">'visible'</span>,<span class="string">'off'</span>)
set(hs3,<span class="string">'visible'</span>,<span class="string">'off'</span>)
<span class="keyword">for</span> i=1:9
    figure(figstresstensor), subplot(hs1(i)), clim([Wmin Wmax])
    figure(figsheartensor), subplot(hs1(i)), clim([Gmin Gmax])
    figure(figviscosity), subplot(hs1(i)), clim([Emin Emax])
<span class="keyword">end</span>
set(hs3,<span class="string">'clim'</span>,[0.01 10 ])

<span class="comment">% plot </span>
figsumall = figure;
formatfig(figsumall,<span class="string">'figname'</span>,sprintf(<span class="string">'STRESS_sumoff_t<span class="comment">%d_z%d'</span>,round(tframe*100)))</span>
title(<span class="string">'all off-diagonal terms are added'</span>)
imagesc(flipud(reshape(sum(Wgrid(:,offdiag),2),nresolution([1 3]))<span class="string">'))

<span class="comment">%% print </span>
outputfolder = '</span>YAOresults<span class="string">';
<span class="keyword">if</span> ~exist(outputfolder,'</span>dir<span class="string">'), mkdir(outputfolder), <span class="keyword">end</span>
 figure(figstresstensor)
 print_pdf(300,[get(figstresstensor,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') <span class="comment">% PDF 300 dpi</span>
 print_png(300,fullfile(outputfolder,get(figstresstensor,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)
 figure(figsheartensor)
 print_pdf(300,[get(figsheartensor,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') <span class="comment">% PDF 300 dpi</span>
 print_png(300,fullfile(outputfolder,get(figsheartensor,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)
 figure(figviscosity)
 print_pdf(300,[get(figviscosity,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') <span class="comment">% PDF 300 dpi</span>
 print_png(300,fullfile(outputfolder,get(figviscosity,'</span>filename<span class="string">')),'</span><span class="string">','</span><span class="string">',0,0,0)
figure(figsumall)
 print_pdf(300,[get(figsumall,'</span>filename<span class="string">') '</span>.pdf<span class="string">'],outputfolder,'</span>nocheck<span class="string">') <span class="comment">% PDF 300 dpi</span>
 print_png(300,fullfile(outputfolder,get(figsumall,'</span>filename<span class="string">')),'</span><span class="string">','</span>',0,0,0)</code></pre></div>
</div>
<div id='interp2SPH' class='doc-content' style='display: none;'>
<h1>INTERP2SPH interpolates y at Xq,Yq using the 2D kernel W centered on centers</h1>
<p>Syntax:<br/>Vq = interp2SPH(X,y,Xq,Yq [,W,V])</p>
<p>Inputs:<br/>centers : kx2 coordinates of the kernel centers<br/>y : kxny values at X (m is the number of values associated with the same center)<br/>[] (empty matrix) forces a uniform density calculatoin<br/>Xq : array or matrix coordinates along X<br/>Yq : array or matrix coordinates along Y<br/>W : kernel function @(r) &lt;-- use kernelSPH() to supply a vectorized kernel<br/>V : kx1 volume of the kernels (default=1)<br/>[] (empty matrix) or scalar value forces uniform volumes (default =1)</p>
<p>Output:<br/>Vq : same size as Xq, with an additional dimension if y was an array</p>
<h2>See also</h2>
<p><a href="#interp3SPH">interp3SPH</a>, <a href="#kernelSPH">kernelSPH</a>, <a href="#packSPH">packSPH</a></p>
<h2>See also</h2>
<p></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> Vq = interp2SPH(centers,y,Xq,Yq,Zq,W,V)
<span class="comment">% INTERP2SPH interpolates y at Xq,Yq using the 2D kernel W centered on centers</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       Vq = interp2SPH(X,y,Xq,Yq [,W,V])</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%     centers : kx2 coordinates of the kernel centers</span>
<span class="comment">%           y : kxny values at X (m is the number of values associated with the same center)</span>
<span class="comment">%               [] (empty matrix) forces a uniform density calculatoin</span>
<span class="comment">%          Xq : array or matrix coordinates along X</span>
<span class="comment">%          Yq : array or matrix coordinates along Y</span>
<span class="comment">%           W : kernel <span class="keyword">function</span> @(r) <-- use kernelSPH() to supply a vectorized kernel</span>
<span class="comment">%           V : kx1 volume of the kernels (default=1)</span>
<span class="comment">%               [] (empty matrix) or scalar value forces uniform volumes (default =1)</span>
<span class="comment">%</span>
<span class="comment">%   Output:</span>
<span class="comment">%           Vq : same size as Xq, with an additional dimension <span class="keyword">if</span> y was an array</span>
<span class="comment">%</span>
<span class="comment">%   See also: interp3SPH, kernelSPH, packSPH</span>
<span class="comment">%</span>

<span class="comment">% 2023-02-20 | INRAE\Olivier Vitrac | rev.</span>

<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<1, centers = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, y = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, Xq = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, Yq = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, W = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<6, V = []; <span class="keyword">end</span>
[k,d] = size(centers);
[ky,ny] = size(y);
kv = length(V);
<span class="keyword">if</span> k==0, error(<span class="string">'please supply some centers'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> d~=2, error(<span class="string">'2 dimensions (columns) are required'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> ky*ny==0, y = ones(k,1); ky=k; ny=1; <span class="keyword">end</span>
<span class="keyword">if</span> ky~=k, error(<span class="string">'the number of y values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,ky,k), <span class="keyword">end</span></span>
<span class="keyword">if</span> ~isequal(size(Xq),size(Yq)) || ~isequal(size(Yq),size(Zq)), error(<span class="string">'Xq,Yq and Zq do not have compatible sizes'</span>), <span class="keyword">end</span> 
<span class="keyword">if</span> kv==0, V=1;  kv=1; <span class="keyword">end</span>
<span class="keyword">if</span> kv==1, V = ones(k,1)*V; kv=k; <span class="keyword">end</span>
<span class="keyword">if</span> kv~=k, error(<span class="string">'the number of V values (<span class="comment">%d) does not match the number of kernels (%d)'</span>,kv,k); <span class="keyword">end</span></span>

<span class="comment">% main</span>
sumW = cell(1,ny);
verbosity = numel(Xq)>1e4;
<span class="keyword">for</span> i=1:k
    <span class="comment">% initialization <span class="keyword">if</span> needed</span>
    <span class="keyword">if</span> i==1
        <span class="keyword">for</span> iy=1:ny
            sumW{iy} = zeros(size(Xq),class(Xq));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% interpolation</span>
    <span class="keyword">if</span> verbosity, dispf(<span class="string">'interpolate respectively to kernel <span class="comment">%d of %d'</span>,i,k); <span class="keyword">end</span>    </span>
    R = sqrt( (Xq-centers(i,1)).^2 + (Yq-centers(i,2)).^2  );
    <span class="keyword">for</span> iy = 1:ny
        sumW{iy} = sumW{iy} + y(i,iy) * V(i) * W(R);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% output</span>
<span class="keyword">if</span> ny==1
    Vq = sumW{1};
<span class="keyword">else</span>
    Vq = cat(ndims(Xq)+1,sumW{:});
<span class="keyword">end</span></code></pre></div>
</div>
<div id='interp3SPH' class='doc-content' style='display: none;'>
<h1>INTERP3SPH interpolates y at Xq,Yq,Zq using the 3D kernel W centered on centers</h1>
<p>Syntax:<br/>Vq = interp3SPH(X,y,Xq,Yq,Zq [,W,V])</p>
<p>Inputs:<br/>centers : kx3 coordinates of the kernel centers<br/>y : kxny values at X (m is the number of values associated with the same center)<br/>[] (empty matrix) forces a uniform density calculatoin<br/>Xq : array or matrix coordinates along X<br/>Yq : array or matrix coordinates along Y<br/>Zq : array or matrix coordinates along Z<br/>W : kernel function @(r) &lt;-- use kernelSPH() to supply a vectorized kernel<br/>V : kx1 volume of the kernels (default=1)<br/>[] (empty matrix) or scalar value forces uniform volumes (default =1)</p>
<p>Output:</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> Vq = interp3SPH(centers,y,Xq,Yq,Zq,W,V)
<span class="comment">% INTERP3SPH interpolates y at Xq,Yq,Zq using the 3D kernel W centered on centers</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       Vq = interp3SPH(X,y,Xq,Yq,Zq [,W,V])</span>
<span class="comment">%</span>
<span class="comment">%   Inputs:</span>
<span class="comment">%     centers : kx3 coordinates of the kernel centers</span>
<span class="comment">%           y : kxny values at X (m is the number of values associated with the same center)</span>
<span class="comment">%               [] (empty matrix) forces a uniform density calculatoin</span>
<span class="comment">%          Xq : array or matrix coordinates along X</span>
<span class="comment">%          Yq : array or matrix coordinates along Y</span>
<span class="comment">%          Zq : array or matrix coordinates along Z</span>
<span class="comment">%           W : kernel <span class="keyword">function</span> @(r) <-- use kernelSPH() to supply a vectorized kernel</span>
<span class="comment">%           V : kx1 volume of the kernels (default=1)</span>
<span class="comment">%               [] (empty matrix) or scalar value forces uniform volumes (default =1)</span>
<span class="comment">%</span>
<span class="comment">%   Output:</span>
,<span class="comment">%           Vq : same size as Xq, with an additional dimension <span class="keyword">if</span> y was an array</span>
<span class="comment">%</span>
<span class="comment">%   See also: interp2SPH, kernelSPH, packSPH</span>
<span class="comment">%</span>
<span class="comment">%   Example : interpolate the field x+2*y-3*z</span>
<span class="comment">%{</span>
    r = 0.5;
    h = 2*r;
    XYZ = packSPH(5,r);
    W = kernelSPH(h,<span class="string">'lucy'</span>,3);
    y = XYZ*[1;2;-3]; <span class="comment">% arbitrary field to be interpolated x+2*y-3*z</span>
    nresolution = 50;
    xg = linspace(min(XYZ(:,1))-h,max(XYZ(:,1))+h,nresolution);
    yg = linspace(min(XYZ(:,2))-h,max(XYZ(:,2))+h,nresolution);
    zg = linspace(min(XYZ(:,3))-h,max(XYZ(:,3))+h,nresolution);
    [Xg,Yg,Zg] = meshgrid(xg,yg,zg);
    Vg = interp3SPH(XYZ,y,Xg,Yg,Zg,W);
    figure, hs= slice(Xg,Yg,Zg,Vg,1:3,1:3,[]); set(hs,<span class="string">'edgecolor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.5), axis equal
    <span class="comment">% comparison with standard scattered interpolation</span>
    F = scatteredInterpolant(XYZ(:,1),XYZ(:,2),XYZ(:,3),y);
    Vg = F(Xg,Yg,Zg);
    figure, hs= slice(Xg,Yg,Zg,Vg,1:3,1:3,[]); set(hs,<span class="string">'edgecolor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.5), axis equal
<span class="comment">%}</span>
<span class="comment">%</span>
<span class="comment">% Example : calculate the density between the central bead and its closest neighbor</span>
<span class="comment">%{</span>
    r = 0.5;
    h = 2*r;
    XYZ = packSPH(5,r);
    W = kernelSPH(h,<span class="string">'lucy'</span>,3);
    [~,icentral] = min(sum((XYZ-mean(XYZ)).^2,2));
    dcentral = sqrt(sum((XYZ-XYZ(icentral,:)).^2,2));
    icontact = find( (dcentral>=2*r-0.0001) & (dcentral<=2*r+0.0001) );
    [~,closest] = min(dcentral(icontact));
    icontact = icontact(closest);
    reducedcurvilinear = linspace(-2.5,2.5,100)<span class="string">';
    curvilinear = reducedcurvilinear*norm(XYZ(icontact,:)-XYZ(icentral,:));
    XYZg = XYZ(icentral,:) + reducedcurvilinear*(XYZ(icontact,:)-XYZ(icentral,:));
    Vg = interp3SPH(XYZ,[],XYZg(:,1),XYZg(:,2),XYZg(:,3),W);
    figure, plot(curvilinear,Vg), xlabel('</span>distance to the central bead<span class="string">'), ylabel('</span>density<span class="string">')
<span class="comment">%}</span>

<span class="comment">% 2023-02-20 | INRAE\Olivier Vitrac | rev.</span>

<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<1, centers = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, y = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, Xq = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<4, Yq = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<5, Zq = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<6, W = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<7, V = []; <span class="keyword">end</span>
[k,d] = size(centers);
[ky,ny] = size(y);
kv = length(V);
<span class="keyword">if</span> k==0, error('</span>please supply some centers<span class="string">'), <span class="keyword">end</span>
<span class="keyword">if</span> d~=3, error('</span>3 dimensions (columns) are required<span class="string">'), <span class="keyword">end</span>
<span class="keyword">if</span> ky*ny==0, y = ones(k,1); ky=k; ny=1; <span class="keyword">end</span>
<span class="keyword">if</span> ky~=k, error('</span>the number of y values (<span class="comment">%d) does not match the number of kernels (%d)<span class="string">',ky,k), <span class="keyword">end</span></span>
<span class="keyword">if</span> ~isequal(size(Xq),size(Yq)) || ~isequal(size(Yq),size(Zq)), error('</span>Xq,Yq and Zq do not have compatible sizes<span class="string">'), <span class="keyword">end</span> 
<span class="keyword">if</span> kv==0, V=1;  kv=1; <span class="keyword">end</span>
<span class="keyword">if</span> kv==1, V = ones(k,1)*V; kv=k; <span class="keyword">end</span>
<span class="keyword">if</span> kv~=k, error('</span>the number of V values (<span class="comment">%d) does not match the number of kernels (%d)<span class="string">',kv,k); <span class="keyword">end</span></span>

<span class="comment">% main</span>
sumW = cell(1,ny);
verbosity = numel(Xq)>1e4;
<span class="keyword">for</span> i=1:k
    <span class="comment">% initialization <span class="keyword">if</span> needed</span>
    <span class="keyword">if</span> i==1
        <span class="keyword">for</span> iy=1:ny
            sumW{iy} = zeros(size(Xq),class(Xq));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% interpolation</span>
    <span class="keyword">if</span> verbosity, dispf('</span>interpolate respectively to kernel <span class="comment">%d of %d',i,k); <span class="keyword">end</span>    </span>
    R = sqrt( (Xq-centers(i,1)).^2 + (Yq-centers(i,2)).^2 + (Zq-centers(i,3)).^2 );
    <span class="keyword">for</span> iy = 1:ny
        sumW{iy} = sumW{iy} + y(i,iy) * V(i) * W(R);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% output</span>
<span class="keyword">if</span> ny==1
    Vq = sumW{1};
<span class="keyword">else</span>
    Vq = cat(ndims(Xq)+1,sumW{:});
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='kernelSPH' class='doc-content' style='display: none;'>
<h1>KERNELSPH return a SPH kernel</h1>
<p>Syntax:<br/>W = kernelSPH(h,type,d)<br/>Inputs:<br/>h : cutoff<br/>type : kenel name (default = Lucy)<br/>d : dimension<br/>Output:<br/>W : kernel function @(r)</p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>W = kernelSPH(1,&#x27;lucy&#x27;,3)</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>See also</h2>
<p><a href="#interp3SPH">interp3SPH</a>, <a href="#interp2SPH">interp2SPH</a>, <a href="#packSPH">packSPH</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> W = kernelSPH(h,type,d)
<span class="comment">% KERNELSPH <span class="keyword">return</span> a SPH kernel</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       W = kernelSPH(h,type,d)</span>
<span class="comment">%    Inputs:</span>
<span class="comment">%           h : cutoff</span>
<span class="comment">%        type : kenel name (default = Lucy)</span>
<span class="comment">%           d : dimension</span>
<span class="comment">%   Output:</span>
<span class="comment">%           W : kernel <span class="keyword">function</span> @(r)</span>
<span class="comment">%</span>
<span class="comment">%   Example:</span>
<span class="comment">%       W = kernelSPH(1,<span class="string">'lucy'</span>,3)</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: interp3SPH, interp2SPH, packSPH</span>


<span class="comment">% 2023-02-20 | INRAE\Olivier Vitrac | rev.</span>

<span class="comment">% arg check</span>
<span class="keyword">if</span> nargin<1, h = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, type = <span class="string">''</span>; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, d = []; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(h), error(<span class="string">'Supply a value <span class="keyword">for</span> h'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> isempty(type), type = <span class="string">'lucy'</span>; <span class="keyword">end</span>
<span class="keyword">if</span> ~ischar(type), error(<span class="string">'type must be a char array'</span>), <span class="keyword">end</span>
<span class="keyword">if</span> isempty(d), d = 3; <span class="keyword">end</span>
<span class="keyword">if</span> (d<2) || (d>3), error(<span class="string">'d must be equal to 1, 2 or 3'</span>), <span class="keyword">end</span>

<span class="comment">% main</span>
<span class="keyword">switch</span> lower(type)
    <span class="keyword">case</span> <span class="string">'lucy'</span>
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
                assume(r,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
                W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
                s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<h)
                matlabFunction((subs(W3(R),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* (1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi;
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
                assume(r,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
                W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<h)
                matlabFunction((subs(W2(R),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* (1.0./h.^2.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*-5.0)./pi;
        <span class="keyword">end</span>
    <span class="keyword">case</span> <span class="string">'lucyder'</span>
        <span class="keyword">if</span> d==3
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
                assume(r,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
                W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
                s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
                W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>
                assume(R<h)
                matlabFunction((subs(diff(W3(R),R,1),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* ( (1.0./h.^4.*(r./h-1.0).^3.*(-3.15e+2./1.6e+1))./pi-(1.0./h.^4.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*(3.15e+2./1.6e+1))./pi );
        <span class="keyword">elseif</span> d==2
            <span class="comment">%{</span>
                syms R h s W(r)
                assume(h,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
                assume(r,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
                W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
                s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 2D</span>
                W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
                assume(R<h)
                matlabFunction((subs(diff(W2(R),R,1),R,r)))
            <span class="comment">%}</span>
            W = @(r) (r<h) .* ( (1.0./h.^3.*(r./h-1.0).^3.*-1.5e+1)./pi-(1.0./h.^3.*(r./h-1.0).^2.*((r.*3.0)./h+1.0).*1.5e+1)./pi );
        <span class="keyword">end</span>
    <span class="keyword">otherwise</span>
        error(<span class="string">'the kernel '</span><span class="string">'<span class="comment">%s'</span><span class="string">' is not implemented'</span>,type)</span>
<span class="keyword">end</span>
</code></pre></div>
</div>
<div id='packSPH' class='doc-content' style='display: none;'>
<h1>PACKSPH returns the HCP or FCC packing of siz spheres of radius r</h1>
<p>Syntax:<br/>W = packSPH(siz,r,typ)<br/>Inputs:<br/>siz : [5 5 5] number of spheres along x,y,z<br/>if siz is a scalar, the same siz is applied to all dimensions [siz siz siz]<br/>r : bead radius<br/>typ : &#x27;HCP&#x27; (default, period 2) or &#x27;FCC&#x27; (period 3)<br/>Output:<br/>X : [size(1)xsize(2)xsize(3)] x 3 centers</p>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'>X = packSPH(5)</code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>Example</h2>
<pre class='code'><code class='language-matlab'></code></pre>
<h2>See also</h2>
<p><a href="#interp3SPH">interp3SPH</a>, <a href="#interp2SPH">interp2SPH</a>, <a href="#kernelSPH">kernelSPH</a></p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="keyword">function</span> X = packSPH(siz,r,typ)
<span class="comment">% PACKSPH returns the HCP or FCC packing of siz spheres of radius r</span>
<span class="comment">%</span>
<span class="comment">%   Syntax:</span>
<span class="comment">%       W = packSPH(siz,r,typ)</span>
<span class="comment">%    Inputs:</span>
<span class="comment">%         siz : [5 5 5] number of spheres along x,y,z </span>
<span class="comment">%               <span class="keyword">if</span> siz is a scalar, the same siz is applied to all dimensions [siz siz siz]</span>
<span class="comment">%           r : bead radius</span>
<span class="comment">%         typ : <span class="string">'HCP'</span> (default, period 2) or <span class="string">'FCC'</span> (period 3)</span>
<span class="comment">%   Output:</span>
<span class="comment">%           X : [size(1)xsize(2)xsize(3)] x 3 centers</span>
<span class="comment">%</span>
<span class="comment">%   Example:</span>
<span class="comment">%       X = packSPH(5)</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%   See also: interp3SPH, interp2SPH, kernelSPH</span>


<span class="comment">% 2023-02-20 | INRAE\Olivier Vitrac | rev.</span>

<span class="comment">% arg check</span>
rdefault = 0.5;
typdefault = <span class="string">'HCP'</span>;
<span class="keyword">if</span> nargin<1, siz = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<2, r = []; <span class="keyword">end</span>
<span class="keyword">if</span> nargin<3, typ = <span class="string">''</span>; <span class="keyword">end</span>
<span class="keyword">if</span> numel(siz)==1, siz = [1,1,1]*siz; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(siz) || numel(siz)~=3, error(<span class="string">'siz must be 1x3 or 3x1 vector'</span>); <span class="keyword">end</span>
<span class="keyword">if</span> isempty(r), r = rdefault; <span class="keyword">end</span>
<span class="keyword">if</span> isempty(typ), typ = typdefault; <span class="keyword">end</span>
<span class="keyword">if</span> ~ischar(typ), error(<span class="string">'typ must be a char array'</span>); <span class="keyword">end</span>
<span class="keyword">switch</span> upper(typ)
    <span class="keyword">case</span> <span class="string">'HCP'</span>
        forceFCC = 0; <span class="comment">% 0 <span class="keyword">for</span> HCP and 1 <span class="keyword">for</span> FCC</span>
    <span class="keyword">case</span> <span class="string">'FCC'</span>
        forceFCC = 1; <span class="comment">% 0 <span class="keyword">for</span> HCP and 1 <span class="keyword">for</span> FCC</span>
    <span class="keyword">otherwise</span>
        error(<span class="string">'valid packaging typ is '</span><span class="string">'HCP'</span><span class="string">' or '</span><span class="string">'FCC'</span><span class="string">''</span>)
<span class="keyword">end</span>

<span class="comment">% Lattice</span>
[i,j,k] = ndgrid(0:(siz(1)-1),0:(siz(2)-1),0:(siz(3)-1)); <span class="comment">% HCP is period 2, FCC is period 3</span>
[i,j,k] = deal(i(:),j(:),k(:));
X = [
    2*i + mod(j+k,2) ...x
    sqrt(3)*(j+mod(k,2)/3)  + (mod(k,3)==2)*forceFCC...y
    (2*sqrt(6)/3)*k ... z
    ]*r;</code></pre></div>
</div>
<div id='packing' class='doc-content' style='display: none;'>
<h1>Simple HCP (hexagonal closed pack) lattice</h1>
<p>generator from: https://en.wikipedia.org/wiki/Close-packing_of_equal_spheres<br/>INRAE\Olivier Vitrac, Han Chen - rev. 2023-02-20</p>
<button class="collapsible">Show MATLAB Code</button>
<div class="content"><pre class="code"><code class="language-matlab"><span class="comment">%% Simple HCP (hexagonal closed pack) lattice</span>
<span class="comment">% generator from: https://en.wikipedia.org/wiki/Close-packing_of_equal_spheres</span>
<span class="comment">% INRAE\Olivier Vitrac, Han Chen - rev. 2023-02-20</span>


<span class="comment">% Define parameters</span>
r = 0.5; <span class="comment">% Radius of spheres</span>
forceFCC = 0; <span class="comment">% 0 <span class="keyword">for</span> HCP and 1 <span class="keyword">for</span> FCC</span>

<span class="comment">% Lattice</span>
[i,j,k] = ndgrid(0:2,0:2,0:2); <span class="comment">% HCP is period 2, FCC is period 3</span>
[i,j,k] = deal(i(:),j(:),k(:));
centers = [
    2*i + mod(j+k,2) ...x
    sqrt(3)*(j+mod(k,2)/3)  + (mod(k,3)==2)*forceFCC...y
    (2*sqrt(6)/3)*k ... z
    ]*r;

<span class="comment">% Create sphere coordinates</span>
[xs,ys,zs] = sphere(100);

<span class="comment">% Translate spheres to close-packed positions</span>
figure
<span class="keyword">for</span> i = 1:size(centers, 1)
    surf(xs*r + centers(i,1), ys*r + centers(i,2), zs*r + centers(i,3),<span class="string">'FaceColor'</span>,rgb(<span class="string">'deepskyblue'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
    hold on;
<span class="keyword">end</span>
lighting gouraud
camlight left
shading interp
axis equal


<span class="comment">%% Lucy kernel, note that s scales the kernel (different scaling in 2D and 3D)</span>
syms h s W(r)
assume(h,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
assume(r,{<span class="string">'real'</span>,<span class="string">'positive'</span>})
W(r) = piecewise(r<h,(1/s)*(1+3*r/h)*(1-r/h)^3,r>=h,0); <span class="comment">% kernel definition</span>
s2D = solve( int(2*pi*r * W(r),r,0,Inf)==1,s);   <span class="comment">% scaling factor in 2D</span>
s3D = solve( int(4*pi*r^2 * W(r),r,0,Inf)==1,s); <span class="comment">% scaling factor in 3D</span>
W2(r) = subs(W(r),s,s2D); <span class="comment">% scaled kernel in 2D</span>
W3(r) = subs(W(r),s,s3D); <span class="comment">% scaled kernel in 3D</span>

<span class="comment">% radial position where the 3D kernel is equal to its average</span>
r1 = solve(W3(r)==1,r,<span class="string">'Maxdegree'</span>,4); <span class="comment">% all solutions (4)</span>
<span class="comment">% only the second root is real and positive</span>
vpa(subs(r1,h,1))
r1 = simplify(r1(2));

<span class="comment">% convert the kernel to a Matlab anonymous <span class="keyword">function</span></span>
<span class="comment">%   function_handle with value:</span>
<span class="comment">%     @(h,r)(1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi</span>
syms R
assume(R<h)
matlabFunction((subs(W3(R),R,r)))

<span class="comment">%% Kernel: numeric implementation</span>
<span class="comment">% single accuracy is used instead of double to reduce memory load</span>
r = single(0.5);
h= single(2*r);
cutoff = @(r) single(r<h);
W = @(r) cutoff(r) .* ( (1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi );
r1expr = matlabFunction(r1);
rplot = linspace(0,1.5*h,1e3);
Wref = 0.1:0.1:floor(W(0));
figure, plot(rplot,W(rplot),<span class="string">'-'</span>,<span class="string">'linewidth'</span>,2), xlabel(<span class="string">'r'</span>), ylabel(<span class="string">'kernel'</span>)
hold on, plot(interpleft(W(rplot),rplot,Wref),Wref,<span class="string">'ro'</span>,<span class="string">'markerfacecolor'</span>,rgb(<span class="string">'Crimson'</span>))
line(r1expr(h)*[1;1;0],[0;1;1],<span class="string">'linewidth'</span>,1.5,<span class="string">'linestyle'</span>,<span class="string">':'</span>,<span class="string">'color'</span>,rgb(<span class="string">'deepskyblue'</span>))
line([r h;r h],[0 0;1 1],<span class="string">'linewidth'</span>,1.5,<span class="string">'linestyle'</span>,<span class="string">'--'</span>,<span class="string">'color'</span>,rgb(<span class="string">'coral'</span>))
text(double(r),1,sprintf(<span class="string">'\\leftarrow r_{bead}=<span class="comment">%0.3g'</span>,r),<span class="string">'HorizontalAlignment'</span>,<span class="string">'left'</span>,<span class="string">'VerticalAlignment'</span>,<span class="string">'top'</span>,<span class="string">'fontsize'</span>,12,<span class="string">'color'</span>,rgb(<span class="string">'Coral'</span>))</span>
text(double(h),1,sprintf(<span class="string">'\\leftarrow h=<span class="comment">%0.3g'</span>,h),<span class="string">'HorizontalAlignment'</span>,<span class="string">'left'</span>,<span class="string">'VerticalAlignment'</span>,<span class="string">'top'</span>,<span class="string">'fontsize'</span>,12,<span class="string">'color'</span>,rgb(<span class="string">'Coral'</span>))</span>

<span class="comment">% 3D field</span>
nresolution = 200;
xw = single(linspace(min(centers(:,1))-h,max(centers(:,1))+h,nresolution));
yw = single(linspace(min(centers(:,2))-h,max(centers(:,2))+h,nresolution));
zw = single(linspace(min(centers(:,3))-h,max(centers(:,3))+h,nresolution));
[Xw,Yw,Zw] = meshgrid(xw,yw,zw);
<span class="comment">% calculate the radial distance to the center of the ith sphere</span>
R = @(i) sqrt( (Xw-centers(i,1)).^2 + (Yw-centers(i,2)).^2 + (Zw-centers(i,3)).^2 );
sumW = zeros(size(Xw),<span class="string">'single'</span>);
<span class="keyword">for</span> i=1:size(centers,1)
    dispf(<span class="string">'evaluate field respective to kernel <span class="comment">%d'</span>,i)</span>
    sumW = sumW + W(R(i));
<span class="keyword">end</span>
<span class="comment">% full domain</span>
figure, isosurface(Xw,Yw,Zw,sumW,1), axis equal
<span class="comment">% cut domain x>1.3</span>
figure
sumWcut = sumW;
xcut = 1.3;
sumWcut(xw>xcut,:,:) = [];
[Xwcut,Ywcut,Zwcut] = deal(Xw,Yw,Zw);
Xwcut(xw>xcut,:,:) = [];
Ywcut(xw>xcut,:,:) = [];
Zwcut(xw>xcut,:,:) = [];
p1 = patch(isosurface(Xwcut,Ywcut,Zwcut,sumWcut, 1),<span class="string">'FaceColor'</span>,rgb(<span class="string">'tomato'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
p2 = patch(isocaps(Xwcut,Ywcut,Zwcut,sumWcut, 1),<span class="string">'FaceColor'</span>,<span class="string">'interp'</span>,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
colormap(gray(100)), camlight left, camlight, lighting gouraud, view(-138,28), axis equal
<span class="comment">% slice</span>
figure, hs= slice(Xw,Yw,Zw,sumW,single(1:3),single(1:3),single([])); set(hs,<span class="string">'edgecolor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.5), axis equal

<span class="comment">%% Calculate the field between two beads</span>
r = 0.5; <span class="comment">% Radius of spheres</span>
forceFCC = 1; <span class="comment">% 0 <span class="keyword">for</span> HCP and 1 <span class="keyword">for</span> FCC</span>

<span class="comment">% Lattice</span>
[i,j,k] = ndgrid(0:4,0:4,0:4); <span class="comment">% HCP is period 2, FCC is period 3</span>
[i,j,k] = deal(i(:),j(:),k(:));
centers = [
    2*i + mod(j+k,2) ...x
    sqrt(3)*(j+mod(k,2)/3)  + (mod(k,3)==2)*forceFCC...y
    (2*sqrt(6)/3)*k ... z
    ]*r;

<span class="comment">% Create sphere coordinates</span>
[xs,ys,zs] = sphere(100);

<span class="comment">% Translate spheres to close-packed positions</span>
figure
ncenters = size(centers,1);
<span class="keyword">for</span> i = 1:size(centers, 1)
    hs(i) = surf(xs*r + centers(i,1), ys*r + centers(i,2), zs*r + centers(i,3),<span class="string">'FaceColor'</span>,rgb(<span class="string">'deepskyblue'</span>),<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>,<span class="string">'facealpha'</span>,0.2);
    hold on;
<span class="keyword">end</span>
lighting gouraud
camlight left
shading interp
axis equal

<span class="comment">% the most central bead and found the next neighbors (coordination number = 12 with HCP)</span>
[~,icentral] = min(sum((centers-mean(centers)).^2,2));
set(hs(icentral),<span class="string">'facecolor'</span>,rgb(<span class="string">'Crimson'</span>),<span class="string">'FaceAlpha'</span>,1)
dcentral = sqrt(sum((centers-centers(icentral,:)).^2,2));
icontact = find( (dcentral>=2*r-0.0001) & (dcentral<=2*r+0.0001) );
ncontact = length(icontact);
set(hs(icontact),<span class="string">'facecolor'</span>,rgb(<span class="string">'ForestGreen'</span>),<span class="string">'FaceAlpha'</span>,1)

<span class="comment">%% Averaged field between the icentral (red) bead and the icontact (green) one</span>
nd = 1000;
d = linspace(-0.1*r,2*r+0.1*r,nd)<span class="string">'; <span class="comment">% support</span>
r = 0.5;
hlist = r*linspace(1.5,4,20);
nh = length(hlist);
sumW = zeros(nd,nh,ncontact);

<span class="keyword">for</span> ih = 1:nh
    h= hlist(ih);
    cutoff = @(r) single(r<h);
    W = @(r) cutoff(r) .* ( (1.0./h.^3.*(r./h-1.0).^3.*((r.*3.0)./h+1.0).*(-1.05e+2./1.6e+1))./pi );
    <span class="keyword">for</span> j = 1:ncontact
        xyz0 = centers(icentral,:);   <span class="comment">% red bead coordinates</span>
        xyz = centers(icontact(j),:); <span class="comment">% green bead coordinated</span>
        direction = (xyz-xyz0)/norm(xyz-xyz0);
        xyzd = xyz0 + direction .* d;
        R = @(i) sqrt( sum((xyzd-centers(i,:)).^2,2));
        <span class="keyword">for</span> i=1:size(centers,1)
            sumW(:,ih,j) = sumW(:,ih,j) + W(R(i));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
figure('</span>defaultAxesColorOrder<span class="string">',parula(nh))
leg = arrayfun(@(x) sprintf('</span>h/r_{bead}=<span class="comment">%0.3g<span class="string">',x),hlist/r,'</span>UniformOutput<span class="string">',false);</span>
hp = plot(d/r,mean(sumW,3),'</span>-<span class="string">','</span>linewidth<span class="string">',3);
legend(hp,leg,'</span>location<span class="string">','</span>eastoutside<span class="string">','</span>fontsize<span class="string">',10,'</span>box<span class="string">','</span>off<span class="string">')
formatax(gca,'</span>fontsize<span class="string">',12)
xlabel('</span>r/r_{bead}<span class="string">','</span>fontsize<span class="string">',16)
ylabel('</span>density<span class="string">','</span>fontsize',16)</code></pre></div>
</div>
</div>
</div>
<script>
// Toggle visibility of folder contents
function toggleFolder(el) {
    var content = el.nextElementSibling;
    if (content.style.display === "none" || content.style.display === "") {
        content.style.display = "block";
    } else {
        content.style.display = "none";
    }
};

// Load documentation into the main panel
function loadDoc(id) {
    // Hide all documentation sections
    var docs = document.getElementsByClassName('doc-content');
    for (var i = 0; i < docs.length; i++) {
        docs[i].style.display = 'none';
    }
    // Hide the welcome message
    var welcome = document.getElementById('welcome-message');
    if (welcome) {
        welcome.style.display = 'none';
    }
    // Show the selected documentation
    var selectedDoc = document.getElementById(id);
    if (selectedDoc) {
        selectedDoc.style.display = 'block';
    }
    
    // Reinitialize collapsible buttons within the displayed documentation
    var coll = selectedDoc.getElementsByClassName("collapsible");
    for (var i = 0; i < coll.length; i++) {
        // Remove existing event listeners to prevent multiple bindings
        coll[i].removeEventListener("click", toggleCollapsible);
        // Add event listener
        coll[i].addEventListener("click", toggleCollapsible);
    }
}

// Function to toggle collapsible sections
function toggleCollapsible() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.display === "block") {
        content.style.display = "none";
    } else {
        content.style.display = "block";
    }
}

// Toggle Sidebar Functionality
const toggleButton = document.getElementById('toggleSidebar');
const nav = document.getElementById('nav');

toggleButton.addEventListener('click', () => {
    nav.classList.toggle('collapsed');
    document.body.classList.toggle('nav-open'); // Toggle overlay on small screens
    // Change icon based on sidebar state
    if(nav.classList.contains('collapsed')) {
        toggleButton.innerHTML = '<kbd>&#9776;</kbd>'; // Hamburger icon
        toggleButton.setAttribute('aria-expanded', 'false');
    } else {
        toggleButton.innerHTML = '<kbd>&#10005;</kbd>'; // Close icon (X)
        toggleButton.setAttribute('aria-expanded', 'true');
    }
});

// Handle URL hash on page load to display the corresponding documentation or welcome page
window.addEventListener('load', function() {
    const hash = window.location.hash.substring(1);
    const docs = document.querySelectorAll('.doc-content');
    if(hash) {
        docs.forEach(doc => {
            if(doc.id === hash) {
                doc.style.display = 'block';
            } else {
                doc.style.display = 'none';
            }
        });
        // If sidebar is open on small screens, ensure it's visible
        if (window.innerWidth <= 768 && !nav.classList.contains('collapsed')) {
            document.body.classList.add('nav-open');
        }
    } else {
        // Show welcome content if no hash is present
        const welcome = document.getElementById('welcome-message');
        if(welcome) {
            welcome.style.display = 'block';
        }
    }
});
</script>
</body>
</html>